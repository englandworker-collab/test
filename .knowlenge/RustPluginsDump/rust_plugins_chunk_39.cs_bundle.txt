ion

            #region Here TP
            if (args[0] == "heretp")
            {
                if (!HasPerm(player, permHere))
                {
                    SendReply(player, GetMessage("NoPermission"));
                    return;
                }

                if (args.Length < 2) return;

                string userIDString = args[1];
                ulong userID;
                if (!ulong.TryParse(userIDString, out userID)) return;

                TPHere(player, userID);
                return;
            }
            #endregion

            #region Set
            if (args[0] == "set")
            {
                if (args.Length < 3) return;

                switch (args[1])
                {
                    case "page":
                        int page;
                        if (!Int32.TryParse(args[2], out page)) return;
                        GUIManager.Get(player).Page = page;
                        UIChooser(player);
                        break;

                    case "tphere":
                        if (!HasPerm(player, permHere))
                        {
                            SendReply(player, GetMessage("NoPermission"));
                            return;
                        }
                        bool here = args[2] == bool.TrueString;
                        GUIManager.Get(player).TPHere = here;
                        UIChooser(player);
                        break;

                    case "sleepers":
                        if (!HasPerm(player, permSleepers))
                        {
                            SendReply(player, GetMessage("NoPermission"));
                            return;
                        }
                        bool sleepers = args[2] == bool.TrueString;
                        GUIManager.Get(player).Sleepers = sleepers;
                        UIChooser(player);
                        break;
                }
                return;
            }
            #endregion
        }

        [ConsoleCommand("tpgui.resetdatafile")]
        void ResetAllCommand(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null) return;

            if (!DebuggingMode)
            {
                Debug.LogError("[TeleportGUI] You may not use this command. Warning: It is highly untested and unsafe. Please to not bypass this warning.");
                return;
            }

            storedData.Cooldowns.Clear();
            storedData.UsesToday.Clear();
            SaveData();
            Puts("Cleared data file and saved.");
        }

        #endregion

        #region GUIs

        void ShowTeleportUI(BasePlayer player)
        {
            if (!GUIOpen.ContainsKey(player))
                GUIOpen.Add(player, false);
            if (GUIOpen[player])
            {
                CloseUI(player);
                GUIOpen[player] = false;
                return;
            }
            GUIOpen[player] = true;

            UIChooser(player);
        }

        void UIChooser(BasePlayer player)
        {
            var guiSettings = GUIManager.Get(player);

            if (BasePlayer.activePlayerList.Count > 25 || guiSettings.Sleepers)
            {
                BigUI(player);
                return;
            }

            SmallUI(player);
        }

        void CloseUI(BasePlayer player)
        {
            if (!GUIOpen.ContainsKey(player))
                GUIOpen.Add(player, false);
            GUIOpen[player] = false;
            CuiHelper.DestroyUi(player, "smallTeleportGUI");
            CuiHelper.DestroyUi(player, "bigTeleportGUI");
        }

        void SmallUI(BasePlayer player)
        {
            var GUIElement = new CuiElementContainer();

            var guiSettings = GUIManager.Get(player);

            List<BasePlayer> players = !guiSettings.Sleepers ?
                                       BasePlayer.activePlayerList :
                                       BasePlayer.sleepingPlayerList;
            players = new List<BasePlayer>(players);

            if (!DebuggingMode && players.Contains(player))
            {
                players.Remove(player);
            }

            //if (debuggingMode) players.AddRange(SpareNames());

            players = players.OrderBy(x => x.displayName).ToList();

            #region Whole Panel

            var smallTeleportGUI = GUIElement.Add(new CuiPanel
            {
                Image =
                {
                    Color = "0 0 0 0.75"
                },
                RectTransform =
                {
                    AnchorMin = "0.3 0.3", //Left Bottom
                    AnchorMax = "0.7 0.75" // Right Top
                },
                CursorEnabled = true
            }, "Hud", "smallTeleportGUI");

            #endregion

            #region Title Bar

            var titleBar = GUIElement.Add(new CuiPanel
            {
                Image =
                {
                    Color = "0 0 0 0.75"
                },
                RectTransform =
                {
                    AnchorMin = "0 0.9", //Left Bottom
                    AnchorMax = "0.998 0.999" // Right Top
                }
            }, smallTeleportGUI);

            #region Pending Request Buttons

            bool pendingRequest = (player.gameObject.GetComponent<PendingRequest>() != null);
            string requestFrom = player.gameObject.GetComponent<PendingRequest>()?.From.displayName;

            if (pendingRequest)
            {
                GUIElement.Add(new CuiButton
                {
                    RectTransform =
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "0.12 0.96"
                    },
                    Button =
                    {
                        Command = "tpgui accept",
                        Color = "0 1 0 1",
                    },
                    Text =
                    {
                        Text = "Accept",
                        FontSize = 18,
                        Color = "1 1 1 1",
                        Align = TextAnchor.MiddleCenter
                    }
                }, titleBar);

                GUIElement.Add(new CuiButton
                {
                    RectTransform =
                    {
                        AnchorMin = "0.122 0",
                        AnchorMax = "0.24 0.96"
                    },
                    Button =
                    {
                        Command = "tpgui decline",
                        Color = "1 0 0 1",
                    },
                    Text =
                    {
                        Text = "Decline",
                        FontSize = 18,
                        Color = "1 1 1 1",
                        Align = TextAnchor.MiddleCenter
                    }
                }, titleBar);

                GUIElement.Add(new CuiLabel
                {
                    Text =
                    {
                        Text = lang.GetMessage("RequestFrom", this).Replace("{0}", requestFrom),
                        FontSize = 16,
                        Align = TextAnchor.MiddleLeft
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.26 0",
                        AnchorMax = "1 1"
                    }
                }, titleBar);
            }

            #endregion

            #region Title

            if (!pendingRequest)
            {
                GUIElement.Add(new CuiLabel
                {
                    Text =
                    {
                        Text = lang.GetMessage("TeleportTitle", this),
                        FontSize = 20,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    }
                }, titleBar);
            }

            #endregion

            #region Sleepers
            if (HasPerm(player, permSleepers))
            {
                var sleepers = GUIManager.Get(player).Sleepers;
                string colour = (sleepers) ? "1 0.2 0.2 1" : "0.5 0.5 0.5 1";
                GUIElement.Add(new CuiButton
                {
                    RectTransform =
                    {
                        AnchorMin = "0.61 0",
                        AnchorMax = "0.71 0.97"
                    },
                    Text =
                    {
                        Text = "Sleepers",
                        Color = "1 1 1 1",
                        Align = TextAnchor.MiddleCenter
                    },
                    Button =
                    {
                        Command = $"tpgui set sleepers {!sleepers}",
                        Color = colour
                    }
                }, titleBar);
            }
            #endregion

            #region TPHere
            if (HasPerm(player, permHere))
            {
                var tpHere = GUIManager.Get(player).TPHere;
                string colour = (tpHere) ? "0 1 0 1" : "0.5 0.5 0.5 1";
                GUIElement.Add(new CuiButton
                {
                    RectTransform =
                    {
                        AnchorMin = "0.71 0",
                        AnchorMax = "0.78 0.97"
                    },
                    Text =
                    {
                        Text = "Here",
                        Color = "1 1 1 1",
                        Align = TextAnchor.MiddleCenter
                    },
                    Button =
                    {
                        Command = $"tpgui set tphere {!tpHere}",
                        Color = colour
                    }
                }, titleBar);
            }
            #endregion

            #region TPBack
            if (HasPerm(player, permBack))
            {
                var colour = (LastTeleport.ContainsKey(player)) ? "0.15 0.15 1 1" : "0.5 0.5 0.5 1";
                var command = (LastTeleport.ContainsKey(player)) ? "tpgui back" : "";
                GUIElement.Add(new CuiButton
                {
                    RectTransform =
                    {
                        AnchorMin = "0.78 0",
                        AnchorMax = "0.85 0.97"
                    },
                    Text =
                    {
                        Text = "Back",
                        Color = "1 1 1 1",
                        Align = TextAnchor.MiddleCenter
                    },
                    Button =
                    {
                        Command = command,
                        Color = colour
                    }
                }, titleBar);
            }
            #endregion

            #region TPCancel
            if (HasPerm(player, permCancel))
            {
                var colour = (HasPendingTeleport(player)) ? "1 0.5 0 1" : "0.5 0.5 0.5 1";
                var command = (HasPendingTeleport(player)) ? "tpgui cancel" : "";
                GUIElement.Add(new CuiButton
                {
                    RectTransform =
                    {
                        AnchorMin = "0.85 0",
                        AnchorMax = "0.934 0.97"
                    },
                    Text =
                    {
                        Text = "Cancel",
                        Color = "1 1 1 1",
                        Align = TextAnchor.MiddleCenter
                    },
                    Button =
                    {
                        Command = command,
                        Color = colour
                    }
                }, titleBar);
            }
            #endregion

            #region Close Button

            GUIElement.Add(new CuiButton
            {
                RectTransform =
                {
                    AnchorMin = "0.935 0",
                    AnchorMax = "0.998 0.97"
                },
                Button =
                {
                    Command = "tpgui close",
                    Color = "1 0 0 1"
                },
                Text =
                {
                    Text = "X",
                    FontSize = 20,
                    Align = TextAnchor.MiddleCenter,
                    Color = "1 1 1 1"
                }
            }, titleBar);

            #endregion

            #endregion

            #region Player List

            var playerList = GUIElement.Add(new CuiPanel
            {
                Image =
                {
                    Color = "0 0 0 0"
                },
                RectTransform =
                {
                    AnchorMin = "0 0",
                    AnchorMax = "1 0.9"
                }
            }, smallTeleportGUI);

            const float columnWidth = 0.2f;
            const float rowWidth = 0.2f;

            int playerCount = 0;
            for (int i = 0; i < 5; i++)
            {
                for (int j = 0; j < 5; j++)
                {
                    if (players.Count <= playerCount) continue;

                    BasePlayer target = players[playerCount];

                    var panel = GUIElement.Add(new CuiPanel
                    {
                        RectTransform =
                        {
                            AnchorMin = (columnWidth * j).ToString() + " " + (1f - (rowWidth * i) - rowWidth).ToString(),
                            AnchorMax = ((columnWidth * j) + columnWidth).ToString() + " " + (1f - (rowWidth * i)).ToString()
                        },
                        Image =
                        {
                            Color = "0 0 0 0"
                        }
                    }, playerList);

                    GUIElement.Add(new CuiButton
                    {
                        RectTransform =
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1"
                        },
                        Text =
                        {
                            Text = CleanText(target.displayName),
                            Align = TextAnchor.MiddleCenter,
                            FontSize = 18,
                            Color = "1 1 1 1",
                            Font = "robotocondensed-regular.ttf"
                        },
                        Button =
                        {
                            Command = $"tpgui to {target.userID}",
                            Color = "0 0 0 0"
                        }
                    }, panel);

                    if (GUIManager.Get(player).TPHere)
                    {
                        GUIElement.Add(new CuiButton
                        {
                            RectTransform =
                            {
                                AnchorMin = "0.7 0.005",
                                AnchorMax = "0.97 0.2"
                            },
                            Text =
                            {
                                Text = "Here",
                                Color = "1 1 1 1",
                                Align = TextAnchor.MiddleCenter,
                                FontSize = 12
                            },
                            Button =
                            {
                                Command = $"tpgui heretp {target.userID}",
                                Color = "0 1 0 0.5"
                            }
                        }, panel);
                    }

                    playerCount++;
                }
            }

            #endregion

            #region Empty List

            if (players.Count == 0)
            {
                GUIElement.Add(new CuiLabel
                {
                    Text =
                    {
                        Text = "Looks like you're a lone survivor!",
                        FontSize = 20,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0 0.1",
                        AnchorMax = "1 1"
                    }
                }, playerList);
            }

            #endregion

            CuiHelper.DestroyUi(player, "smallTeleportGUI");
            CuiHelper.DestroyUi(player, "bigTeleportGUI");
            CuiHelper.AddUi(player, GUIElement);
        }

        void BigUI(BasePlayer player)
        {
            var GUIElement = new CuiElementContainer();

            var guiSettings = GUIManager.Get(player);

            List<BasePlayer> players = !guiSettings.Sleepers ?
                                       BasePlayer.activePlayerList :
                                       BasePlayer.sleepingPlayerList;
            players = new List<BasePlayer>(players);

            if (!DebuggingMode && players.Contains(player))
            {
                players.Remove(player);
            }

            //if (debuggingMode) players.AddRange(SpareNames());

            players = players.OrderBy(x => x.displayName).ToList();

            int maxPages = CalculatePages(players.Count);

            #region Whole Panel

            var bigTeleportGUI = GUIElement.Add(new CuiPanel
            {
                Image =
                {
                    Color = "0 0 0 0.75"
                },
                RectTransform =
                {
                    AnchorMin = "0.2 0.125", //Left Bottom
                    AnchorMax = "0.8 0.9" // Right Top
                },
                CursorEnabled = true
            }, "Hud", "bigTeleportGUI");

            #endregion

            #region Title Bar

            var titleBar = GUIElement.Add(new CuiPanel
            {
                Image =
                {
                    Color = "0 0 0 0.75"
                },
                RectTransform =
                {
                    AnchorMin = "0 0.935", //Left Bottom
                    AnchorMax = "0.997 1.0" // Right Top
                }
            }, bigTeleportGUI);

            #region Pending Request Buttons

            bool pendingRequest = (player.gameObject.GetComponent<PendingRequest>() != null);
            string requestFrom = player.gameObject.GetComponent<PendingRequest>()?.From.displayName;

            if (pendingRequest)
            {
                GUIElement.Add(new CuiButton
                {
                    RectTransform =
                    {
                        AnchorMin = "0 0.01",
                        AnchorMax = "0.16 0.98"
                    },
                    Button =
                    {
                        Command = "tpgui accept",
                        Color = "0 1 0 1",
                    },
                    Text =
                    {
                        Text = "Accept",
                        FontSize = 18,
                        Color = "1 1 1 1",
                        Align = TextAnchor.MiddleCenter
                    }
                }, titleBar);

                GUIElement.Add(new CuiButton
                {
                    RectTransform =
                    {
                        AnchorMin = "0.1615 0.01",
                        AnchorMax = "0.32 0.98"
                    },
                    Button =
                    {
                        Command = "tpgui decline",
                        Color = "1 0 0 1",
                    },
                    Text =
                    {
                        Text = "Decline",
                        FontSize = 18,
                        Color = "1 1 1 1",
                        Align = TextAnchor.MiddleCenter
                    }
                }, titleBar);

                GUIElement.Add(new CuiLabel
                {
                    Text =
                    {
                        Text = lang.GetMessage("RequestFrom", this).Replace("{0}", requestFrom),
                        FontSize = 18,
                        Align = TextAnchor.MiddleLeft
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.34 0",
                        AnchorMax = "1 1"
                    }
                }, titleBar);
            }

            #endregion

            #region Title

            if (!pendingRequest)
            {
                string pageNum = (maxPages > 1) ? $" - {GUIManager.Get(player).Page}" : "";
                GUIElement.Add(new CuiLabel
                {
                    Text =
                    {
                        Text = lang.GetMessage("TeleportTitle", this) + pageNum,
                        FontSize = 20,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    }
                }, titleBar);
            }

            #endregion

            #region Sleepers
            if (HasPerm(player, permSleepers))
            {
                var sleepers = GUIManager.Get(player).Sleepers;
                string colour = (sleepers) ? "1 0.2 0.2 1" : "0.5 0.5 0.5 1";
                GUIElement.Add(new CuiButton
                {
                    RectTransform =
                    {
                        AnchorMin = "0.62 0",
                        AnchorMax = "0.70 0.97"
                    },
                    Text =
                    {
                        Text = "Sleepers",
                        Color = "1 1 1 1",
                        Align = TextAnchor.MiddleCenter
                    },
                    Button =
                    {
                        Command = $"tpgui set sleepers {!sleepers}",
                        Color = colour
                    }
                }, titleBar);
            }
            #endregion

            #region TPHere
            if (HasPerm(player, permHere))
            {
                var tpHere = GUIManager.Get(player).TPHere;
                string colour = (tpHere) ? "0 1 0 1" : "0.5 0.5 0.5 1";
                GUIElement.Add(new CuiButton
                {
                    RectTransform =
                    {
                        AnchorMin = "0.70 0",
                        AnchorMax = "0.78 0.97"
                    },
                    Text =
                    {
                        Text = "Here",
                        Color = "1 1 1 1",
                        Align = TextAnchor.MiddleCenter
                    },
                    Button =
                    {
                        Command = $"tpgui set tphere {!tpHere}",
                        Color = colour
                    }
                }, titleBar);
            }
            #endregion

            #region TPBack
            if (HasPerm(player, permBack))
            {
                var colour = (LastTeleport.ContainsKey(player)) ? "0.15 0.15 1 1" : "0.5 0.5 0.5 1";
                var command = (LastTeleport.ContainsKey(player)) ? "tpgui back" : "";
                GUIElement.Add(new CuiButton
                {
                    RectTransform =
                    {
                        AnchorMin = "0.78 0",
                        AnchorMax = "0.86 0.97"
                    },
                    Text =
                    {
                        Text = "Back",
                        Color = "1 1 1 1",
                        Align = TextAnchor.MiddleCenter
                    },
                    Button =
                    {
                        Command = command,
                        Color = colour
                    }
                }, titleBar);
            }
            #endregion

            #region TPCancel
            if (HasPerm(player, permCancel))
            {
                var colour = (HasPendingTeleport(player)) ? "1 0.5 0 1" : "0.5 0.5 0.5 1";
                var command = (HasPendingTeleport(player)) ? "tpgui cancel" : "";
                GUIElement.Add(new CuiButton
                {
                    RectTransform =
                    {
                        AnchorMin = "0.86 0",
                        AnchorMax = "0.9385 0.98"
                    },
                    Text =
                    {
                        Text = "Cancel",
                        Color = "1 1 1 1",
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 16
                    },
                    Button =
                    {
                        Command = command,
                        Color = colour
                    }
                }, titleBar);
            }
            #endregion

            #region Close Button

            GUIElement.Add(new CuiButton
            {
                RectTransform =
                {
                    AnchorMin = "0.94 0.01",
                    AnchorMax = "1.0 0.98"
                },
                Button =
                {
                    Command = "tpgui close",
                    Color = "1 0 0 1"
                },
                Text =
                {
                    Text = "X",
                    FontSize = 20,
                    Align = TextAnchor.MiddleCenter,
                    Color = "1 1 1 1"
                }
            }, titleBar);

            #endregion

            #endregion

            #region Player List

            var playerList = GUIElement.Add(new CuiPanel
            {
                Image =
                {
                    Color = "0 0 0 0"
                },
                RectTransform =
                {
                    AnchorMin = "0 0",
                    AnchorMax = "1 0.9"
                }
            }, bigTeleportGUI);

            var page = GUIManager.Get(player).Page;
            int playerCount = (page * 100) - 100;
            for (int j = 0; j < 20; j++)
            {
                for (int i = 0; i < 5; i++)
                {
                    if (players.Count <= playerCount) continue;

                    BasePlayer target = players[playerCount];

                    var panel = GUIElement.Add(new CuiPanel
                    {
                        RectTransform =
                        {
                            AnchorMin = (0.2f * i).ToString() + " " + (1f - (0.05f * j) - 0.05f).ToString(),
                            AnchorMax = ((0.2f * i) + 0.2f).ToString() + " " + (1f - (0.05f * j)).ToString()
                        },
                        Image =
                        {
                            Color = "0 1 0 0"
                        }
                    }, playerList);

                    GUIElement.Add(new CuiButton
                    {
                        RectTransform =
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1"
                        },
                        Text =
                        {
                            Text = CleanText(target.displayName),
                            Align = TextAnchor.MiddleCenter,
                            FontSize = 18,
                            Color = "1 1 1 1"
                        },
                        Button =
                        {
                            Command = $"tpgui to {target.userID}",
                            Color = "0 0 0 0"
                        }
                    }, panel);

                    if (GUIManager.Get(player).TPHere)
                    {
                        GUIElement.Add(new CuiButton
                        {
                            RectTransform =
                            {
                                AnchorMin = "0.85 0",
                                AnchorMax = "0.98 0.5"
                            },
                            Text =
                            {
                                Text = "Here",
                                FontSize = 8,
                                Align = TextAnchor.MiddleCenter,
                                Color = "1 1 1 1"
                            },
                            Button =
                            {
                                Command = $"tpgui heretp {target.userID}",
                                Color = "0 1 0 1"
                            }
                        }, panel);
                    }

                    playerCount++;
                }
            }

            #endregion

            #region Empty List

            if (players.Count == 0)
            {
                GUIElement.Add(new CuiLabel
                {
                    Text =
                    {
                        Text = "Looks like you're a lone survivor!",
                        FontSize = 20,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0 0.1",
                        AnchorMax = "1 1"
                    }
                }, playerList);
            }

            #endregion

            #region Page Buttons

            if (page < maxPages)
            {
                GUIElement.Add(new CuiButton
                {
                    RectTransform =
                    {
                        AnchorMin = "1.025 0.575",
                        AnchorMax = "1.1 0.675"
                    },
                    Text =
                    {
                        Text = "Up",
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 16,
                        Color = "1 1 1 1"
                    },
                    Button =
                    {
                        Command = $"tpgui set page {(page + 1).ToString()}",
                        Color = "0 0 0 0.75"
                    }
                }, bigTeleportGUI);
            }

            if (page > 1)
            {
                GUIElement.Add(new CuiButton
                {
                    RectTransform =
                    {
                        AnchorMin = "1.025 0.45",
                        AnchorMax = "1.1 0.55"
                    },
                    Text =
                    {
                        Text = "Down",
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 16,
                        Color = "1 1 1 1"
                    },
                    Button =
                    {
                        Command = $"tpgui set page {(page - 1).ToString()}",
                        Color = "0 0 0 0.75"
                    }
                }, bigTeleportGUI);
            }

            #endregion

            CuiHelper.DestroyUi(player, "smallTeleportGUI");
            CuiHelper.DestroyUi(player, "bigTeleportGUI");
            CuiHelper.AddUi(player, GUIElement);
        }

        #endregion

        #region TP Functions

        void TPR(BasePlayer player, BasePlayer targetPlayer, bool tpHere)
        {
            bool playerIsPaying = false;

            if (player.IsAdmin && ConfigFile.AdminTPEnabled)
            {
                if (!ConfigFile.AdminTPSilent)
                {
                    SendReply(player, GetMessage("TeleportedToYou").Replace("{0}", player.displayName));
                }

                SendReply(player, GetMessage("YouTeleportedTo").Replace("{0}", targetPlayer.displayName));

                Vector3 currentPos = player.transform.position;
                RecordLastTP(player, currentPos);

                Teleport(player, targetPlayer);
                return;
            }

            if (storedData.Cooldowns.ContainsKey(player.userID))
            {
                SendReply(player, GetMessage("OnCooldown").Replace("{0}", storedData.Cooldowns[player.userID].ToString()));
                return;
            }

            if (player.IsWounded())
            {
                SendReply(player, GetMessage("CantTPWhilstWounded"));
                return;
            }

            if (!ConfigFile.AllowTeleportWhilstBleeding)
            {
                if (player.metabolism.bleeding.value > 0f)
                {
                    SendReply(player, GetMessage("PlayerIsBleeding"));
                    return;
                }
            }

            if (!ConfigFile.AllowTeleportFromBuildBlock)
            {
                if (!player.CanBuild())
                {
                    SendReply(player, GetMessage("PlayerIsBuildBlocked"));
                    return;
                }
            }

            if (!ConfigFile.AllowTeleportToBuildBlockedPlayer)
            {
                if (!targetPlayer.CanBuild())
                {
                    SendReply(player, GetMessage("TargetIsBuildBlocked"));
                    return;
                }
            }

            if (IsCrafting(player))
            {
                SendReply(player, GetMessage("BlockTPCrafting"));
                return;
            }

            if (HasComponent<PendingRequest>(targetPlayer))
            {
                SendReply(player, GetMessage("HasPendingRequest").Replace("{0}", targetPlayer.displayName));
                return;
            }

            if (ConfigFile.UseEconomicsPlugin &&
                !ConfigFile.PayAfterUsingDailyLimits)
            {
                if (EconomicsInstalled())
                {
                    if (!PayEconomics(player))
                    {
                        SendReply(player, GetMessage("CantAffordEconomics").Replace("{0}", ConfigFile.EconomicsPrice.ToString("N2")));
                        return;
                    }

                    SendReply(player, GetMessage("EconomicsYouSpent").Replace("{0}", ConfigFile.EconomicsPrice.ToString("N2")));
                    playerIsPaying = true;
                }
            }

            if (ConfigFile.UseServerRewardsPlugin &&
                !ConfigFile.PayAfterUsingDailyLimits)
            {
                if (ServerRewardsInstalled())
                {
                    if (!PayServerRewards(player))
                    {
                        SendReply(player, GetMessage("CantAffordServerRewards").Replace("{0}", ConfigFile.ServerRewardsPrice.ToString("N1")));
                        return;
                    }

                    SendReply(player, GetMessage("ServerRewardsYouSpent").Replace("{0}", ConfigFile.ServerRewardsPrice.ToString("N1")));
                    playerIsPaying = true;
                }
            }

            if (HasReachedDailyLimit(player))
            {
                if (!ConfigFile.PayAfterUsingDailyLimits)
                {
                    SendReply(player, GetMessage("MaxTeleportsReached"));
                    return;
                }

                if (ConfigFile.UseEconomicsPlugin)
                {
                    if (!PayEconomics(player))
                    {
                        SendReply(player, GetMessage("CantAffordEconomics").Replace("{0}", ConfigFile.EconomicsPrice.ToString("N1")));
                        return;
                    }

                    SendReply(player, GetMessage("EconomicsYouSpent").Replace("{0}", ConfigFile.EconomicsPrice.ToString("N1")));
                    playerIsPaying = true;
                }

                if (ConfigFile.UseServerRewardsPlugin)
                {
                    if (!PayServerRewards(player))
                    {
                        SendReply(player, GetMessage("CantAffordServerRewards").Replace("{0}", ConfigFile.ServerRewardsPrice.ToString("N1")));
                        return;
                    }

                    SendReply(player, GetMessage("ServerRewardsYouSpent").Replace("{0}", ConfigFile.ServerRewardsPrice.ToString("N1")));
                    playerIsPaying = true;
                }
            }

            string canTeleport = Interface.Oxide.CallHook("CanTeleport", player) as string;
            if (canTeleport != null)
            {
                SendReply(player, canTeleport);
                return;
            }

            bool escapeBlocked = NoEscape?.Call<bool>("IsBlocked", player) ?? false;
            if (escapeBlocked)
            {
                SendReply(player, GetMessage("IsEscapeBlocked"));
                return;
            }

            if (ZoneManager != null)
            {
                if (!ConfigFile.CanTeleportFromZone)
                {
                    var call = ZoneManager.Call("EntityHasFlag", player, "notp");
                    if (call is bool && (bool)call)
                    {
                        SendReply(player, GetMessage("CantTeleportFromZone"));
                        return;
                    }
                }

                if (!ConfigFile.CanTeleportIntoZone)
                {
                    var call = ZoneManager.Call("EntityHasFlag", targetPlayer, "notp");
                    if (call is bool && (bool)call)
                    {
                        SendReply(player, GetMessage("CantTeleportToZone"));
                        return;
                    }
                }
            }

            TeleportRequest.Create(
                player,
                targetPlayer,
                ConfigFile.RequestTimeoutTime,
                tpHere,
                playerIsPaying);
        }

        void TPC(BasePlayer player)
        {
            if (HasComponent<Teleporter>(player))
            {
                var teleporter = player.GetComponent<Teleporter>();
                teleporter.CancelTeleport();
                return;
            }

            var call = Interface.Oxide.CallHook("CancelAllTeleports", player);
            if (call is string)
            {
                SendReply(player, call as string);
                return;
            }

            SendReply(player, GetMessage("NothingToCancel"));
            return;
        }

        void TPB(BasePlayer player)
        {
            if (!LastTeleport.ContainsKey(player))
            {
                SendReply(player, GetMessage("NoBackLocation"));
                return;
            }

            Teleport(player, LastTeleport[player]);
            SendReply(player, GetMessage("TeleportedBack"));
        }

        void TPHere(BasePlayer player, ulong targetID)
        {
            if (!HasPerm(player, permHere))
            {
                SendReply(player, GetMessage("NoPermission"));
                return;
            }

            BasePlayer target = BasePlayer.FindByID(targetID) ??
                                BasePlayer.sleepingPlayerList.FirstOrDefault(x => x.userID == targetID);

            if (target == null)
            {
                SendReply(player, GetMessage("PlayerIDNotFound").Replace("{0}", targetID.ToString()));
                return;
            }

            if (!DebuggingMode && player == target)
            {
                SendReply(player, GetMessage("CantTeleportToSelf"));
                return;
            }

            TPR(target, player, true);
        }

        void Teleport(BasePlayer player, BasePlayer target) => Teleport(player, target.transform.position);

        void Teleport(BasePlayer player, Vector3 position)
        {
            if (player.net?.connection != null)
                player.ClientRPCPlayer(null, player, "StartLoading");
            StartSleeping(player);
            player.MovePosition(position);
            if (player.net?.connection != null)
                player.ClientRPCPlayer(null, player, "ForcePositionTo", position);
            if (player.net?.connection != null)
                player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
            player.UpdateNetworkGroup();
            player.SendNetworkUpdateImmediate(false);
            if (player.net?.connection == null) return;
            try { player.ClearEntityQueue(null); } catch { }
            player.SendFullSnapshot();
        }

        void StartSleeping(BasePlayer player)
        {
            if (player.IsSleeping()) return;
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Sleeping, true);
            if (!BasePlayer.sleepingPlayerList.Contains(player))
                BasePlayer.sleepingPlayerList.Add(player);
            player.CancelInvoke("InventoryUpdate");
        }

        #endregion

        #region Functions

        void RecordLastTP(BasePlayer player, Vector3 oldPos)
        {
            if (!LastTeleport.ContainsKey(player))
                LastTeleport.Add(player, Vector3.zero);
            LastTeleport[player] = oldPos;
        }

        bool HasPendingTeleport(BasePlayer player) => HasComponent<PendingRequest>(player) || HasComponent<Teleporter>(player);

        bool HasReachedDailyLimit(BasePlayer player)
        {
            int maxTeleports = ConfigFile.DefaultDailyLimit;

            if (maxTeleports <= 0) return false;

            var highestMaxTeleports = ConfigFile.DailyLimit
                .Where(x => permission.UserHasPermission(player.UserIDString, x.Key) &&
                            x.Value > maxTeleports)
                .OrderByDescending(x => x.Value)
                .FirstOrDefault();

            if (!highestMaxTeleports.Equals(default(KeyValuePair<string, int>)))
            {
                maxTeleports = highestMaxTeleports.Value;
            }

            if (!storedData.UsesToday.ContainsKey(player.userID))
            {
                storedData.UsesToday.Add(player.userID, 0);
            }

            return storedData.UsesToday[player.userID] >= maxTeleports;
        }

        int IncrementUses(BasePlayer player)
        {
            if (!storedData.UsesToday.ContainsKey(player.userID))
            {
                storedData.UsesToday.Add(player.userID, 0);
            }

            storedData.UsesToday[player.userID]++;
            SaveData();

            int maxTeleports = ConfigFile.DefaultDailyLimit;

            var highestMaxTeleports = ConfigFile.DailyLimit
                .Where(x => permission.UserHasPermission(player.UserIDString, x.Key) &&
                            x.Value > maxTeleports)
                .OrderByDescending(x => x.Value)
                .FirstOrDefault();

            if (!highestMaxTeleports.Equals(default(KeyValuePair<string, int>)))
            {
                maxTeleports = highestMaxTeleports.Value;
            }

            return maxTeleports - storedData.UsesToday[player.userID];
        }

        void ResetDailyUses()
        {
            storedData.UsesToday.Clear();
            SaveData();
            timer.Once(TimeUntilMidnight(), () => ResetDailyUses());
        }

        bool IsCrafting(BasePlayer player) => (player.inventory.crafting.queue.Count() > 0);

        int CalculatePages(int value) => (int)Math.Ceiling(value / 100d);

        BasePlayer FindByName(string name, bool sleepers = false)
        {
            List<BasePlayer> players = new List<BasePlayer>();
            if (sleepers) players = new List<BasePlayer>(BasePlayer.sleepingPlayerList);
            else players = new List<BasePlayer>(BasePlayer.activePlayerList);
            return players.Where(x => x.displayName.ToLower().Replace(" ", "")
                                       .Contains(name.ToLower().Replace(" ", "")))
                                       .FirstOrDefault();
        }

        List<BasePlayer> FindByNameMulti(string name, bool sleepers = false)
        {
            List<BasePlayer> players = new List<BasePlayer>();
            if (sleepers) players = new List<BasePlayer>(BasePlayer.sleepingPlayerList);
            else players = new List<BasePlayer>(BasePlayer.activePlayerList);
            return players.Where(x => x.displayName.ToLower().Replace(" ", "")
                                       .Contains(name.ToLower().Replace(" ", "")))
                                       .ToList();
        }

        #region Economics/ServerRewards

        bool EconomicsInstalled() => Economics != null;

        bool ServerRewardsInstalled() => ServerRewards != null;

        bool PayEconomics(BasePlayer player)
        {
            double price = ConfigFile.EconomicsPrice;
            double playerMoney = (double)Economics.Call("Balance", player.userID);

            if (playerMoney - price >= 0)
            {
                Economics?.Call("Withdraw", player.userID, price);
                return true;
            }
            return false;
        }

        bool PayServerRewards(BasePlayer player)
        {
            int price = ConfigFile.ServerRewardsPrice;
            int currentPoints;
            var call = ServerRewards?.Call("CheckPoints", player.userID);
            if (call == null) currentPoints = 0;
            else currentPoints = (int)call;

            if (currentPoints - price >= 0)
            {
                ServerRewards.Call("TakePoints", player.userID, price);
                return true;
            }
            return false;
        }

        void RefundPlayerEconomics(BasePlayer player)
        {
            double price = ConfigFile.EconomicsPrice;
            Economics?.Call("Deposit", player.userID, price);
            SendReply(player, GetMessage("EconomicsRefunded").Replace("{0}", price.ToString("N2")));
        }

        void RefundServerRewards(BasePlayer player)
        {
            int price = ConfigFile.ServerRewardsPrice;
            ServerRewards.Call("AddPoints", player.userID, price);
            SendReply(player, GetMessage("ServerRewardsRefunded").Replace("{0}", price.ToString("N1")));
        }

        #endregion

        #endregion

        #region Helpers

        bool HasPerm(BasePlayer player) => (permission.UserHasPermission(player.UserIDString, permUse) || player.IsAdmin);
        bool HasPerm(BasePlayer player, string perm) => (permission.UserHasPermission(player.UserIDString, perm) || player.IsAdmin);

        string CleanText(string text) => ConfigFile.AllowSpecialCharacters ? text : new Regex(@"[^A-Za-z0-9\/:*?<>|!@#$%^&()\[\] ]+").Replace(text, " ");

        int TimeUntilMidnight() => ((59 - DateTime.Now.Second) + ((59 - DateTime.Now.Minute) * 60) + ((23 - DateTime.Now.Hour) * 3600));

        string GetMessage(string key) => (ConfigFile.PrefixEnabled ? ConfigFile.PrefixText : string.Empty) + lang.GetMessage(key, this);

        bool HasComponent<T>(GameObject go) => (go.GetComponent<T>() != null);
        bool HasComponent<T>(BasePlayer player) => (player.GetComponent<T>() != null);

        void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(this.Title, storedData);
        void ReadData() => storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(this.Title);

        #endregion

        #region Spare Names (For Testing)

        List<BasePlayer> SpareNames() => nameList.Select(x => new BasePlayer() { displayName = x, userID = 1 }).ToList();

        static string names = @"AaronLongjohnsonson John Thomas George James Henry Charles Joseph Frederick Robert Alfred Edward Arthur Richard Samuel Walter David Harry Albert Edwin Francis Frank Benjamin Herbert Daniel Tom Isaac Fred Peter Ernest Michael Stephen Patrick Matthew Edmund Frederic Alexander Philip Mark Evan Andrew Abraham Hugh Christopher Sidney Lewis Jonathan Jesse Ralph Joshua Sam Martin Owen Josiah Jacob Reuben Joe Leonard Edgar Eli Enoch Job Oliver Anthony Amos Horace Elijah Timothy Cornelius Moses Jeremiah Sydney Louis Nicholas Aaron Percy Ebenezer Willie Luke Dennis Jabez Levi Augustus Adam Nathaniel Harold Allen Griffith Bernard Rowland Ben Ellis Rees Archibald Ambrose Lawrence Morgan Noah Simon Ephraim Caleb Elias Reginald Roger Isaiah Phillip Jonas Nathan Clement Solomon Morris Charley Emanuel Gilbert Paul Hubert Maurice Simeon Abel Wilfred Dan Emmanuel Jim Ezra Squire Theodore Seth Horatio Wright Theophilus Vincent Wilson Alan Stanley Sampson Miles Wallace Israel Smith Humphrey Hiram Howard Cecil Felix Allan Oswald Silas Austin Nelson Douglas Hedley Enos Eugene Percival Spencer Edmond Septimus Robinson Luther Joel Adolphus Cuthbert Donald Bartholomew Elisha Uriah Laurence Johnson Lionel Clarence Llewellyn Oscar Norman Dick Charlie Godfrey Herman Colin Harvey Walker Denis Claude Zachariah Hezekiah Roland Llewelyn Harrison Julius Duncan Victor Jasper Jackson Lancelot Giles Jenkin Hartley Gerald Valentine Clifford Thompson Charlie Godfrey Herman Colin Harvey Walker Denis Claude Zachariah Hezekiah Roland Llewelyn Harrison Julius Duncan Victor Jasper Jackson Lancelot Giles Jenkin Hartley Gerald Valentine Clifford Thompson";

        string[] nameList = names.Split(' ');

        #endregion
    }
}

// --- End of file: TeleportGUI.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/VKBot.cs ---
// --- Original Local Path: VKBot.cs ---

using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("VKBot", "SkiTles", "1.6")]
    class VKBot : RustPlugin
    {
        //Данный плагин принадлежит группе vk.com/vkbotrust
        //Данный плагин предоставляется в существующей форме,
        //"как есть", без каких бы то ни было явных или
        //подразумеваемых гарантий, разработчик не несет
        //ответственность в случае его неправильного использования.

        #region Variables
        private System.Random random = new System.Random();
        private string opc;
        private string stw;
        private string sts;
        private string str;
        private string stb;
        private string ste;
        private string wd;
        private string su;
        private string msg;
        private string cone;
        private string slprs;
        private string mapfile;
        private bool NewWipe = false;
        JsonSerializerSettings jsonsettings;
        private bool OxideUpdateNotice = false;
        private Dictionary<ulong, ulong> PlayersCheckList = new Dictionary<ulong, ulong>();
        private int serverOxideVersion;
        private List<string> allowedentity = new List<string>()
        {
            "door",
            "wall.window.bars.metal",
            "wall.window.bars.toptier",
            "wall.external",
            "gates.external.high",
            "floor.ladder",
            "embrasure",
            "floor.grill",
            "wall.frame.fence",
            "wall.frame.cell"
        };
        private List<ulong> BDayPlayers = new List<ulong>();
        #endregion

        #region Config
        private ConfigData config;
        private class ConfigData
        {
            [JsonProperty(PropertyName = "Ключи VK API, ID группы")]
            public VKAPITokens VKAPIT { get; set; }

            [JsonProperty(PropertyName = "Настройки оповещений администраторов")]
            public AdminNotify AdmNotify { get; set; }

            [JsonProperty(PropertyName = "Настройки статуса")]
            public StatusSettings StatusStg { get; set; }

            [JsonProperty(PropertyName = "Оповещения при вайпе")]
            public WipeSettings WipeStg { get; set; }

            [JsonProperty(PropertyName = "Награда за вступление в группу")]
            public GroupGifts GrGifts { get; set; }

            [JsonProperty(PropertyName = "Награда для именинников")]
            public BDayGiftSet BDayGift { get; set; }

            [JsonProperty(PropertyName = "Настройки текста в уведомлениях в чат")]
            public TextSettings TxtSet { get; set; }

            [JsonProperty(PropertyName = "Поддержка нескольких серверов")]
            public MultipleServersSettings MltServSet { get; set; }

            [JsonProperty(PropertyName = "Проверка игроков на читы")]
            public PlayersCheckingSettings PlChkSet { get; set; }

            [JsonProperty(PropertyName = "Топ игроки вайпа и промо")]
            public TopWPlPromoSet TopWPlayersPromo { get; set; }

            public class VKAPITokens
            {
                [JsonProperty(PropertyName = "VK Token группы (для сообщений)")]
                [DefaultValue("Заполните эти поля, и выполните команду o.reload VKBot")]
                public string VKToken { get; set; } = "Заполните эти поля, и выполните команду o.reload VKBot";

                [JsonProperty(PropertyName = "VK Token приложения (для записей на стене и статуса)")]
                [DefaultValue("Заполните эти поля, и выполните команду o.reload VKBot")]
                public string VKTokenApp { get; set; } = "Заполните эти поля, и выполните команду o.reload VKBot";

                [JsonProperty(PropertyName = "VKID группы")]
                [DefaultValue("Заполните эти поля, и выполните команду o.reload VKBot")]
                public string GroupID { get; set; } = "Заполните эти поля, и выполните команду o.reload VKBot";
            }

            public class AdminNotify
            {
                [JsonProperty(PropertyName = "VkID администраторов (пример /11111, 22222/)")]
                [DefaultValue("Заполните эти поля, и выполните команду o.reload VKBot")]
                public string VkID { get; set; } = "Заполните эти поля, и выполните команду o.reload VKBot";

                [JsonProperty(PropertyName = "Включить отправку сообщений администратору командой /report ?")]
                [DefaultValue(true)]
                public bool SendReports { get; set; } = true;

                [JsonProperty(PropertyName = "Предупреждение о злоупотреблении функцией репортов")]
                [DefaultValue("Наличие в тексте нецензурных выражений, оскорблений администрации или игроков сервера, а так же большое количество безсмысленных сообщений приведет к бану!")]
                public string ReportsNotify { get; set; } = "Наличие в тексте нецензурных выражений, оскорблений администрации или игроков сервера, а так же большое количество безсмысленных сообщений приведет к бану!";

                [JsonProperty(PropertyName = "Отправлять сообщение администратору о бане игрока?")]
                [DefaultValue(true)]
                public bool UserBannedMsg { get; set; } = true;

                [JsonProperty(PropertyName = "Отправлять сообщение администратору о выходе нового обновления Oxide?")]
                [DefaultValue(true)]
                public bool OxideNewVersionMsg { get; set; } = true;
            }

            public class StatusSettings
            {
                [JsonProperty(PropertyName = "Обновлять статус в группе? Если стоит /false/ статистика собираться не будет")]
                [DefaultValue(true)]
                public bool UpdateStatus { get; set; } = true;

                [JsonProperty(PropertyName = "Вид статуса (1 - текущий сервер, 2 - список серверов, необходим Rust:IO на каждом сервере)")]
                [DefaultValue(1)]
                public int StatusSet { get; set; } = 1;

                [JsonProperty(PropertyName = "Онлайн в статусе вида '125/200'")]
                [DefaultValue(false)]
                public bool OnlWmaxslots { get; set; } = false;

                [JsonProperty(PropertyName = "Таймер обновления статуса (минуты)")]
                [DefaultValue(30)]
                public int UpdateTimer { get; set; } = 30;

                [JsonProperty(PropertyName = "Формат статуса")]
                [DefaultValue("{usertext}. Сервер вайпнут: {wipedate}. Онлайн игроков: {onlinecounter}. Спящих: {sleepers}. Добыто дерева: {woodcounter}. Добыто серы: {sulfurecounter}. Выпущено ракет: {rocketscounter}. Использовано взрывчатки: {explosivecounter}. Создано чертежей: {blueprintsconter}. {connect}")]
                public string StatusText { get; set; } = "{usertext}. Сервер вайпнут: {wipedate}. Онлайн игроков: {onlinecounter}. Добыто дерева: {woodcounter}. Добыто серы: {sulfurecounter}. Выпущено ракет: {rocketscounter}. Использовано взрывчатки: {explosivecounter}. Создано чертежей: {blueprintsconter}. {connect}";

                [JsonProperty(PropertyName = "Список счетчиков, которые будут отображаться в виде emoji")]
                [DefaultValue("onlinecounter, rocketscounter, blueprintsconter, explosivecounter, wipedate")]
                public string EmojiCounterList { get; set; } = "onlinecounter, rocketscounter, blueprintsconter, explosivecounter, wipedate";

                [JsonProperty(PropertyName = "Ссылка на коннект сервера вида /connect 111.111.111.11:11111/")]
                [DefaultValue("connect 111.111.111.11:11111")]
                public string connecturl { get; set; } = "connect 111.111.111.11:11111";

                [JsonProperty(PropertyName = "Текст для статуса")]
                [DefaultValue("Сервер 1")]
                public string StatusUT { get; set; } = "Сервер 1";
            }

            public class WipeSettings
            {
                [JsonProperty(PropertyName = "Отправлять пост в группу после вайпа?")]
                [DefaultValue(false)]
                public bool WPostB { get; set; } = false;

                [JsonProperty(PropertyName = "Текст поста о вайпе")]
                [DefaultValue("Заполните эти поля, и выполните команду o.reload VKBot")]
                public string WPostMsg { get; set; } = "Заполните эти поля, и выполните команду o.reload VKBot";

                [JsonProperty(PropertyName = "Добавить изображение к посту о вайпе?")]
                [DefaultValue(false)]
                public bool WPostAttB { get; set; } = false;

                [JsonProperty(PropertyName = "Ссылка на изображение к посту о вайпе вида 'photo-1_265827614' (изображение должно быть в альбоме группы)")]
                [DefaultValue("photo-1_265827614")]
                public string WPostAtt { get; set; } = "photo-1_265827614";

                [JsonProperty(PropertyName = "Отправлять сообщение администратору о вайпе?")]
                [DefaultValue(true)]
                public bool WPostMsgAdmin { get; set; } = true;

                [JsonProperty(PropertyName = "Отправлять игрокам сообщение о вайпе автоматически?")]
                [DefaultValue(false)]
                public bool WMsgPlayers { get; set; } = false;

                [JsonProperty(PropertyName = "Текст сообщения игрокам о вайпе (сообщение отправляется только тем кто подписался командой /vk wipealerts)")]
                [DefaultValue("Сервер вайпнут! Залетай скорее!")]
                public string WMsgText { get; set; } = "Сервер вайпнут! Залетай скорее!";

                [JsonProperty(PropertyName = "Игнорировать команду /vk wipealerts? (если включено, сообщение о вайпе будет отправляться всем)")]
                [DefaultValue(false)]
                public bool WCMDIgnore { get; set; } = false;
            }

            public class GroupGifts
            {
                [JsonProperty(PropertyName = "Выдавать подарок игроку за вступление в группу ВК?")]
                [DefaultValue(true)]
                public bool VKGroupGifts { get; set; } = true;

                [JsonProperty(PropertyName = "Подарки за вступление в группу (shortname предмета, количество)")]
                [DefaultValue(null)]
                public Dictionary<string, object> VKGroupGiftList { get; set; } = new Dictionary<string, object>
                {
                  {"supply.signal", 1},
                  {"pookie.bear", 2}
                };

                [JsonProperty(PropertyName = "Ссылка на группу ВК")]
                [DefaultValue("vk.com/1234")]
                public string VKGroupUrl { get; set; } = "vk.com/1234";

                [JsonProperty(PropertyName = "Оповещения в общий чат о получении награды")]
                [DefaultValue(true)]
                public bool GiftsBool { get; set; } = true;

                [JsonProperty(PropertyName = "Включить оповещения для игроков не получивших награду за вступление в группу?")]
                [DefaultValue(true)]
                public bool VKGGNotify { get; set; } = true;

                [JsonProperty(PropertyName = "Интервал оповещений для игроков не получивших награду за вступление в группу (в минутах)")]
                [DefaultValue(30)]
                public int VKGGTimer { get; set; } = 30;

                [JsonProperty(PropertyName = "Выдавать награду каждый вайп?")]
                [DefaultValue(true)]
                public bool GiftsWipe { get; set; } = true;
            }

            public class BDayGiftSet
            {
                [JsonProperty(PropertyName = "Включить награду для именинников?")]
                [DefaultValue(true)]
                public bool BDayEnabled { get; set; } = true;

                [JsonProperty(PropertyName = "Группа для именинников")]
                [DefaultValue("bdaygroup")]
                public string BDayGroup { get; set; } = "bdaygroup";

                [JsonProperty(PropertyName = "Текст поздравления")]
                [DefaultValue("<size=17><color=#990404>Администрация сервера поздравляет вас с днем рождения! В качестве подарка мы добавили вас в группу с рейтами x4 и китом bday!</color></size>")]
                public string BDayText { get; set; } = "<size=17><color=#990404>Администрация сервера поздравляет вас с днем рождения! В качестве подарка мы добавили вас в группу с рейтами x4 и китом bday!</color></size>";

                [JsonProperty(PropertyName = "Оповещения в общий чат о имениннках")]
                [DefaultValue(false)]
                public bool BDayNotify { get; set; } = false;
            }

            public class TextSettings
            {
                [JsonProperty(PropertyName = "Размер текста")]
                [DefaultValue("17")]
                public string TxtSize { get; set; } = "17";

                [JsonProperty(PropertyName = "Цвет выделенного текста")]
                [DefaultValue("#990404")]
                public string TxtColor { get; set; } = "#990404";
            }

            public class MultipleServersSettings
            {
                [JsonProperty(PropertyName = "Включить поддержку несколько серверов?")]
                [DefaultValue(false)]
                public bool MSSEnable { get; set; } = false;

                [JsonProperty(PropertyName = "Номер сервера")]
                [DefaultValue(1)]
                public int ServerNumber { get; set; } = 1;

                [JsonProperty(PropertyName = "Сервер 1 IP:PORT (пример: 111.111.111.111:28015)")]
                [DefaultValue("none")]
                public string Server1ip { get; set; } = "none";

                [JsonProperty(PropertyName = "Сервер 2 IP:PORT (пример: 111.111.111.111:28015)")]
                [DefaultValue("none")]
                public string Server2ip { get; set; } = "none";

                [JsonProperty(PropertyName = "Сервер 3 IP:PORT (пример: 111.111.111.111:28015)")]
                [DefaultValue("none")]
                public string Server3ip { get; set; } = "none";

                [JsonProperty(PropertyName = "Сервер 4 IP:PORT (пример: 111.111.111.111:28015)")]
                [DefaultValue("none")]
                public string Server4ip { get; set; } = "none";

                [JsonProperty(PropertyName = "Сервер 5 IP:PORT (пример: 111.111.111.111:28015)")]
                [DefaultValue("none")]
                public string Server5ip { get; set; } = "none";

                [JsonProperty(PropertyName = "Онлайн в emoji?")]
                [DefaultValue(true)]
                public bool EmojiStatus { get; set; } = true;
            }

            public class PlayersCheckingSettings
            {
                [JsonProperty(PropertyName = "Текст уведомления")]
                [DefaultValue("<color=#990404>Модератор вызвал вас на проверку.</color> \nНапишите свой скайп с помощью команды <color=#990404>/skype <НИК в СКАЙПЕ>.</color>\nЕсли вы покините сервер, Вы будете забанены на нашем проекте серверов.")]
                public string PlCheckText { get; set; } = "<color=#990404>Модератор вызвал вас на проверку.</color> \nНапишите свой скайп с помощью команды <color=#990404>/skype <НИК в СКАЙПЕ>.</color>\nЕсли вы покините сервер, Вы будете забанены на нашем проекте серверов.";

                [JsonProperty(PropertyName = "Размер текста")]
                [DefaultValue(17)]
                public int PlCheckSize { get; set; } = 17;

                [JsonProperty(PropertyName = "Привилегия для команд /alert и /unalert")]
                [DefaultValue("vkbot.checkplayers")]
                public string PlCheckPerm { get; set; } = "vkbot.checkplayers";

                [JsonProperty(PropertyName = "Позиция GUI AnchorMin (дефолт 0 0.826)")]
                [DefaultValue("0 0.826")]
                public string GUIAnchorMin { get; set; } = "0 0.826";

                [JsonProperty(PropertyName = "Позиция GUI AnchorMax (дефолт 1 0.965)")]
                [DefaultValue("1 0.965")]
                public string GUIAnchorMax { get; set; } = "1 0.965";
            }

            public class TopWPlPromoSet
            {
                [JsonProperty(PropertyName = "Включить топ игроков вайпа")]
                [DefaultValue(true)]
                public bool TopWPlEnabled { get; set; } = true;

                [JsonProperty(PropertyName = "Включить отправку промо кодов за топ?")]
                [DefaultValue(false)]
                public bool TopPlPromoGift { get; set; } = false;

                [JsonProperty(PropertyName = "Пост на стене группы о топ игроках вайпа")]
                [DefaultValue(true)]
                public bool TopPlPost { get; set; } = true;

                [JsonProperty(PropertyName = "Промо для топ рэйдера")]
                [DefaultValue("topraider")]
                public string TopRaiderPromo { get; set; } = "topraider";

                [JsonProperty(PropertyName = "Промо для топ килера")]
                [DefaultValue("topkiller")]
                public string TopKillerPromo { get; set; } = "topkiller";

                [JsonProperty(PropertyName = "Промо для топ фармера")]
                [DefaultValue("topfarmer")]
                public string TopFarmerPromo { get; set; } = "topfarmer";

                [JsonProperty(PropertyName = "Ссылка на донат магазин")]
                [DefaultValue("server.gamestores.ru")]
                public string StoreUrl { get; set; } = "server.gamestores.ru";

                [JsonProperty(PropertyName = "Автоматическая генерация промокодов после вайпа")]
                [DefaultValue(false)]
                public bool GenRandomPromo { get; set; } = false;
            }
        }
        private void LoadVariables()
        {
            Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;

            config = Config.ReadObject<ConfigData>();

            Config.WriteObject(config, true);
        }

        protected override void LoadDefaultConfig()
        {
            var configData = new ConfigData
            {
                VKAPIT = new ConfigData.VKAPITokens(),
                AdmNotify = new ConfigData.AdminNotify(),
                StatusStg = new ConfigData.StatusSettings(),
                WipeStg = new ConfigData.WipeSettings(),
                GrGifts = new ConfigData.GroupGifts(),
                BDayGift = new ConfigData.BDayGiftSet(),
                TxtSet = new ConfigData.TextSettings(),
                MltServSet = new ConfigData.MultipleServersSettings(),
                PlChkSet = new ConfigData.PlayersCheckingSettings(),
                TopWPlayersPromo = new ConfigData.TopWPlPromoSet()
            };
            Config.WriteObject(configData, true);
            PrintWarning("Поддержи разработчика! Вступи в группу vk.com/vkbotrust");
        }
        #endregion

        #region Datastorage
        class DataStorageStats
        {
            public int WoodGath;
            public int SulfureGath;
            public int Rockets;
            public int Blueprints;
            public int Explosive;
            public DataStorageStats() { }
        }
        class DataStorageUsers
        {
            public Dictionary<ulong, VKUDATA> VKUsersData = new Dictionary<ulong, VKUDATA>();
            public DataStorageUsers() { }
        }
        class VKUDATA
        {
            public ulong UserID;
            public string Name;
            public string VkID;
            public int ConfirmCode;
            public bool Confirmed;
            public bool GiftRecived;
            public string LastRaidNotice;
            public bool WipeMsg;
            public string Bdate;
            public int Raids;
            public int Kills;
            public int Farm;
        }
        DataStorageStats statdata;
        DataStorageUsers usersdata;
        private DynamicConfigFile VKBData;
        private DynamicConfigFile StatData;
        void LoadData()
        {
            try
            {
                statdata = Interface.GetMod().DataFileSystem.ReadObject<DataStorageStats>("VKBot");
                usersdata = Interface.GetMod().DataFileSystem.ReadObject<DataStorageUsers>("VKBotUsers");
            }

            catch
            {
                statdata = new DataStorageStats();
                usersdata = new DataStorageUsers();
            }
        }
        #endregion

        #region Oxidehooks
        void OnServerInitialized()
        {
            LoadVariables();
            VKBData = Interface.Oxide.DataFileSystem.GetFile("VKBotUsers");
            StatData = Interface.Oxide.DataFileSystem.GetFile("VKBot");
            LoadData();
            if (!permission.PermissionExists(config.PlChkSet.PlCheckPerm)) permission.RegisterPermission(config.PlChkSet.PlCheckPerm, this);
            if (NewWipe)
            {
                WipeFunctions(mapfile);
            }
            if (config.StatusStg.UpdateStatus)
            {
                if (config.StatusStg.StatusSet == 1)
                {
                    timer.Repeat(config.StatusStg.UpdateTimer * 60, 0, Update1ServerStatus);
                }
                if (config.StatusStg.StatusSet == 2)
                {
                    timer.Repeat(config.StatusStg.UpdateTimer * 60, 0, UpdateMultiServerStatus);
                }
            }
            if (config.GrGifts.VKGGNotify)
            {
                timer.Repeat(config.GrGifts.VKGGTimer * 60, 0, GiftNotifier);
            }
            if (config.AdmNotify.OxideNewVersionMsg)
            {
                CheckOxideCommits();
                timer.Repeat(3600, 0, CheckOxideCommits);
            }
        }
        void OnServerSave()
        {
            if (config.TopWPlayersPromo.TopWPlEnabled)
            {
                VKBData.WriteObject(usersdata);
            }
        }
        private void Init()
        {
            cmd.AddChatCommand("report", this, "SendReport");
            cmd.AddChatCommand("vk", this, "VKcommand");
            cmd.AddConsoleCommand("updatestatus", this, "UStatus");
            cmd.AddConsoleCommand("sendmsgadmin", this, "MsgAdmin");
            cmd.AddConsoleCommand("wipealerts", this, "WipeAlerts");
            cmd.AddChatCommand("alert", this, "StartCheckPlayer");
            cmd.AddChatCommand("unalert", this, "StopCheckPlayer");
            cmd.AddChatCommand("skype", this, "SkypeSending");
            cmd.AddConsoleCommand("userinfo", this, "GetUserInfo");
            jsonsettings = new JsonSerializerSettings();
            jsonsettings.Converters.Add(new KeyValuePairConverter());
            serverOxideVersion = Convert.ToInt32(Manager.GetPlugin("RustCore").Version.Patch);
        }
        void Unload()
        {
            if (config.StatusStg.UpdateStatus)
            {
                StatData.WriteObject(statdata);
            }
            if (config.TopWPlayersPromo.TopWPlEnabled)
            {
                VKBData.WriteObject(usersdata);
            }
            if (PlayersCheckList.Count == 0) return;
            for (int i = 0; i < PlayersCheckList.Count; i++)
            {
                var playerid = PlayersCheckList.ElementAt(i).Value;
                var player = BasePlayer.FindByID(playerid);
                if (player != null)
                {
                    StopGui(player);
                }
            }
            PlayersCheckList.Clear();
            if (config.BDayGift.BDayEnabled && BDayPlayers.Count > 0)
            {
                foreach (var id in BDayPlayers)
                {
                    permission.RemoveUserGroup(id.ToString(), config.BDayGift.BDayGroup);
                    Puts($"Список игроков bday очищен"); //debug
                }
                BDayPlayers.Clear();
            }
        }
        void OnNewSave(string filename)
        {
            NewWipe = true;
            mapfile = filename;
        }
        void OnPlayerInit(BasePlayer player)
        {
            if (usersdata.VKUsersData.ContainsKey(player.userID))
            {
                if (usersdata.VKUsersData[player.userID].Name != player.displayName)
                {
                    usersdata.VKUsersData[player.userID].Name = player.displayName;
                    VKBData.WriteObject(usersdata);
                }
                if (usersdata.VKUsersData[player.userID].Bdate == null)
                {
                    AddBdate(player);
                }
            }
        }
        void OnPlayerSleepEnded(BasePlayer player)
        {
            if (!usersdata.VKUsersData.ContainsKey(player.userID)) return;
            if (config.BDayGift.BDayEnabled && permission.GroupExists(config.BDayGift.BDayGroup))
            {
                if (permission.UserHasGroup(player.userID.ToString(), config.BDayGift.BDayGroup)) return;
                var today = DateTime.Now.ToString("d.M", CultureInfo.InvariantCulture);
                var bday = usersdata.VKUsersData[player.userID].Bdate;
                if (bday == null || bday == "noinfo") return;
                string[] array = bday.Split('.');
                if (array.Length == 3)
                {
                    bday = bday.Remove(bday.Length - 5, 5);
                }
                if (bday == today)
                {
                    permission.AddUserGroup(player.userID.ToString(), config.BDayGift.BDayGroup);
                    PrintToChat(player, String.Format(config.BDayGift.BDayText));
                    Log("bday", $"Игрок {player.displayName} добавлен в группу {config.BDayGift.BDayGroup}");
                    BDayPlayers.Add(player.userID);
                    if (config.BDayGift.BDayNotify)
                    {
                        Server.Broadcast(String.Format($"<size={config.TxtSet.TxtSize}>Администрация сервера поздравляет игрока <color={config.TxtSet.TxtColor}>{player.displayName}</color> с Днем Рождения!</size>"));
                    }
                }
            }
        }
        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (PlayersCheckList.Count > 0 && PlayersCheckList.ContainsValue(player.userID))
            {
                CuiHelper.DestroyUi(player, "AlertGUI");
                BasePlayer moder = null;
                for (int i = 0; i < PlayersCheckList.Count; i++)
                {
                    if (PlayersCheckList.ElementAt(i).Value == player.userID)
                    {
                        ulong moderid = PlayersCheckList.ElementAt(i).Key;
                        moder = BasePlayer.FindByID(moderid);
                        PlayersCheckList.Remove(moderid);
                        if (moder != null)
                        {
                            PrintToChat(moder, $"Игрок вызванный на проверку покинул сервер. Причина: {reason}");
                        }
                    }
                }
            }
            if (PlayersCheckList.Count > 0 && PlayersCheckList.ContainsKey(player.userID))
            {
                ulong targetid;
                PlayersCheckList.TryGetValue(player.userID, out targetid);
                BasePlayer target = BasePlayer.FindByID(targetid);
                if (target != null)
                {
                    CuiHelper.DestroyUi(target, "AlertGUI");
                    PrintToChat(target, $"Модератор отключился от сервера, ожидайте следующей проверки.");
                }
                PlayersCheckList.Remove(player.userID);
            }
            if (config.BDayGift.BDayEnabled && permission.GroupExists(config.BDayGift.BDayGroup))
            {
                if (BDayPlayers.Contains(player.userID))
                {
                    permission.RemoveUserGroup(player.userID.ToString(), config.BDayGift.BDayGroup);
                    BDayPlayers.Remove(player.userID);
                    Log("bday", $"Игрок {player.displayName} удален из группы {config.BDayGift.BDayGroup}");
                }
            }
        }
        #endregion

        #region Stats
        private void OnItemResearch(ResearchTable table, Item targetItem, BasePlayer player)
        {
            if (config.StatusStg.UpdateStatus)
            {
                statdata.Blueprints++;
            }
        }
        private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            if (config.StatusStg.UpdateStatus)
            {
                if (item.info.shortname == "wood")
                {
                    statdata.WoodGath = statdata.WoodGath + item.amount;
                }
                if (item.info.shortname == "sulfur.ore")
                {
                    statdata.SulfureGath = statdata.SulfureGath + item.amount;
                }
            }
            if (config.TopWPlayersPromo.TopWPlEnabled)
            {
                BasePlayer player = entity.ToPlayer();
                if (player == null) return;
                if (usersdata.VKUsersData.ContainsKey(player.userID))
                {
                    usersdata.VKUsersData[player.userID].Farm = usersdata.VKUsersData[player.userID].Farm + item.amount;
                }
            }
        }
        private void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            if (config.StatusStg.UpdateStatus && item.info.shortname == "sulfur.ore")
            {
                statdata.SulfureGath = statdata.SulfureGath + item.amount;
            }
            if (config.TopWPlayersPromo.TopWPlEnabled)
            {
                if (usersdata.VKUsersData.ContainsKey(player.userID))
                {
                    usersdata.VKUsersData[player.userID].Farm = usersdata.VKUsersData[player.userID].Farm + item.amount;
                }
            }
        }
        private void OnCollectiblePickup(Item item, BasePlayer player)
        {
            if (config.StatusStg.UpdateStatus)
            {
                if (item.info.shortname == "wood")
                {
                    statdata.WoodGath = statdata.WoodGath + item.amount;
                }
                if (item.info.shortname == "sulfur.ore")
                {
                    statdata.SulfureGath = statdata.SulfureGath + item.amount;
                }
            }
            if (config.TopWPlayersPromo.TopWPlEnabled)
            {
                if (usersdata.VKUsersData.ContainsKey(player.userID))
                {
                    usersdata.VKUsersData[player.userID].Farm = usersdata.VKUsersData[player.userID].Farm + item.amount;
                }
            }
        }
        private void OnRocketLaunched(BasePlayer player, BaseEntity entity)
        {
            if (config.StatusStg.UpdateStatus)
            {
                statdata.Rockets++;
            }
        }
        private void OnExplosiveThrown(BasePlayer player, BaseEntity entity)
        {
            if (config.StatusStg.UpdateStatus)
            {
                List<object> include = new List<object>()
                {
                "explosive.satchel.deployed",
                "grenade.f1.deployed",
                "grenade.beancan.deployed",
                "explosive.timed.deployed"
                };
                if (include.Contains(entity.ShortPrefabName))
                {
                    statdata.Explosive++;
                }
            }
        }
        void OnEntityDeath(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (config.TopWPlayersPromo.TopWPlEnabled)
            {
                if (entity.name.Contains("corpse"))  return;
                if (hitInfo == null) return;
                var attacker = hitInfo.Initiator?.ToPlayer();
                if (attacker == null) return;
                if (entity is BasePlayer)
                {
                    CheckDeath(entity.ToPlayer(), hitInfo);
                }
                if (entity is BaseEntity)
                {
                    if (hitInfo.damageTypes.GetMajorityDamageType() != Rust.DamageType.Explosion && hitInfo.damageTypes.GetMajorityDamageType() != Rust.DamageType.Heat && hitInfo.damageTypes.GetMajorityDamageType() != Rust.DamageType.Bullet) return;
                    if (attacker.userID == entity.OwnerID) return;
                    BuildingBlock block = entity.GetComponent<BuildingBlock>();
                    if (block != null)
                    {
                        if (block.currentGrade.gradeBase.type.ToString() == "Twigs" || block.currentGrade.gradeBase.type.ToString() == "Wood")
                        {
                            return;
                        }
                    }
                    else
                    {
                        bool ok = false;
                        foreach (var ent in allowedentity)
                        {
                            if (entity.LookupPrefab().name.Contains(ent))
                            {
                                ok = true;
                            }
                        }
                        if (!ok) return;
                    }
                    if (entity.OwnerID == 0) return;
                    if (usersdata.VKUsersData.ContainsKey(attacker.userID))
                    {
                        usersdata.VKUsersData[attacker.userID].Raids++;
                    }
                }                
            }
        }
        private void CheckDeath(BasePlayer player, HitInfo info)
        {
            if (info == null) return;
            var attacker = info.Initiator?.ToPlayer();
            if (attacker == null || attacker == player) return;
            if (!usersdata.VKUsersData.ContainsKey(attacker.userID)) return;
            if (!player.IsConnected) return;
            usersdata.VKUsersData[attacker.userID].Kills++;
        }
        #endregion

        #region Wipe
        private void WipeFunctions(string filename)
        {
            if (config.StatusStg.UpdateStatus)
            {
                statdata.Blueprints = 0;
                statdata.Rockets = 0;
                statdata.SulfureGath = 0;
                statdata.WoodGath = 0;
                statdata.Explosive = 0;
                StatData.WriteObject(statdata);
                NewWipe = false;
                if (config.StatusStg.StatusSet == 1) { Update1ServerStatus(); }
                if (config.StatusStg.StatusSet == 2) { UpdateMultiServerStatus(); }
            }
            if (config.WipeStg.WPostMsgAdmin)
            {
                string s = filename;
                string[] array = s.Split('/');
                int t = array.Length - 1;
                string savename = array[t];
                string[] mapname = savename.Split('.');
                string msg2 = null;
                if (config.MltServSet.MSSEnable)
                {
                    msg2 = $"[VKBot] Сервер {config.MltServSet.ServerNumber.ToString()} вайпнут. Установлена карта: {mapname[0]}. Размер: {mapname[1]}. Сид: {mapname[2]}";
                }
                else
                {
                    msg2 = $"[VKBot] Сервер вайпнут. Установлена карта: {mapname[0]}. Размер: {mapname[1]}. Сид: {mapname[2]}";
                }
                SendVkMessage(config.AdmNotify.VkID, msg2);
            }
            if (config.WipeStg.WPostB)
            {
                if (config.WipeStg.WPostAttB)
                {
                    SendVkWall($"{config.WipeStg.WPostMsg}&attachments={config.WipeStg.WPostAtt}");
                }
                else
                {
                    SendVkWall($"{config.WipeStg.WPostMsg}");
                }
            }
            if (config.GrGifts.GiftsWipe)
            {
                int amount = usersdata.VKUsersData.Count;
                if (amount != 0)
                {
                    for (int i = 0; i < amount; i++)
                    {
                        usersdata.VKUsersData.ElementAt(i).Value.GiftRecived = false;
                    }
                    VKBData.WriteObject(usersdata);
                }
            }
            if (config.TopWPlayersPromo.TopWPlEnabled)
            {
                if (config.TopWPlayersPromo.TopPlPost || config.TopWPlayersPromo.TopPlPromoGift)
                {
                    SendPromoMsgsAndPost();
                    if (config.TopWPlayersPromo.TopPlPromoGift && config.TopWPlayersPromo.GenRandomPromo)
                    {
                        SetRandomPromo();
                    }
                }
                int amount = usersdata.VKUsersData.Count;
                if (amount != 0)
                {
                    for (int i = 0; i < amount; i++)
                    {
                        usersdata.VKUsersData.ElementAt(i).Value.Farm = 0;
                        usersdata.VKUsersData.ElementAt(i).Value.Kills = 0;
                        usersdata.VKUsersData.ElementAt(i).Value.Raids = 0;
                    }
                    VKBData.WriteObject(usersdata);
                }
            }
            if (config.WipeStg.WMsgPlayers)
            {
                WipeAlertsSend();
            }
        }
        private void WipeAlerts(ConsoleSystem.Arg arg)
        {
            if (arg.IsAdmin != true) { return; }
            WipeAlertsSend();
        }
        private void WipeAlertsSend()
        {
            List<string> UserList = new List<string>();
            string userlist = "";
            int usercount = 0;
            int amount = usersdata.VKUsersData.Count;
            if (amount != 0)
            {
                for (int i = 0; i < amount; i++)
                {
                    if (config.WipeStg.WCMDIgnore || usersdata.VKUsersData.ElementAt(i).Value.WipeMsg)
                    {
                        if (usercount == 100)
                        {
                            UserList.Add(userlist);
                            userlist = "";
                            usercount = 0;
                        }
                        if (usercount > 0)
                        {
                            userlist = userlist + ", ";
                        }
                        userlist = userlist + usersdata.VKUsersData.ElementAt(i).Value.VkID;
                        usercount++;
                    }
                }
            }
            if (userlist == "" && UserList.Count == 0) { PrintWarning($"Список адресатов рассылки о вайпе пуст."); return; }
            if (UserList.Count > 0)
            {
                foreach (var list in UserList)
                {
                    SendVkMessage(list, config.WipeStg.WMsgText);
                }
            }
            SendVkMessage(userlist, config.WipeStg.WMsgText);
        }
        #endregion

        #region MainMethods
        private void UStatus(ConsoleSystem.Arg arg)
        {
            if (arg.IsAdmin != true) { return; }
            if (config.StatusStg.UpdateStatus)
            {
                if (config.StatusStg.StatusSet == 1) { Update1ServerStatus(); }
                if (config.StatusStg.StatusSet == 2) { UpdateMultiServerStatus(); }
            }
            else
            {
                PrintWarning($"Функция обновления статуса отключена. Status update disabled");
            }
        }
        void OnPlayerBanned(string name, ulong id, string address, string reason)
        {
            if (config.AdmNotify.UserBannedMsg)
            {
                string msg2 = null;
                if (config.MltServSet.MSSEnable)
                {
                    msg2 = $"[Сервер {config.MltServSet.ServerNumber.ToString()}] Игрок {name} ({id}) был забанен на сервере. Причина: {reason}. Ссылка на профиль стим: steamcommunity.com/profiles/{id}/";
                }
                else
                {
                    msg2 = $"Игрок {name} ({id}) был забанен на сервере. Причина: {reason}. Ссылка на профиль стим: steamcommunity.com/profiles/{id}/";
                }
                if (usersdata.VKUsersData.ContainsKey(id) && usersdata.VKUsersData[id].Confirmed)
                {
                    msg2 = msg2 + $" . Ссылка на профиль ВК: vk.com/id{usersdata.VKUsersData[id].VkID}";
                }
                SendVkMessage(config.AdmNotify.VkID, msg2);
            }
        }
        private void SendReport(BasePlayer player, string cmd, string[] args)
        {
            if (config.AdmNotify.SendReports)
            {
                if (args.Length > 0)
                {
                    string text = string.Join(" ", args.Skip(0).ToArray());
                    string reciverID = config.AdmNotify.VkID;
                    string reporttext = "[VKBot]";
                    if (config.MltServSet.MSSEnable)
                    {
                        reporttext = reporttext + " [Сервер " + config.MltServSet.ServerNumber.ToString() + "]\n";
                    }
                    reporttext = reporttext + player.displayName + "(" + player.UserIDString + ")";
                    if (usersdata.VKUsersData.ContainsKey(player.userID))
                    {
                        if (usersdata.VKUsersData[player.userID].Confirmed)
                        {
                            reporttext = reporttext + ". ВК: vk.com/id" + usersdata.VKUsersData[player.userID].VkID;
                        }
                        else
                        {
                            reporttext = reporttext + ". ВК: vk.com/id" + usersdata.VKUsersData[player.userID].VkID + " (не подтвержден)";
                        }
                    }
                    reporttext = reporttext + "\nСообщение: " + text;                    
                    SendVkMessage(reciverID, reporttext);
                    Log("Log", $"{player.displayName} ({player.userID}): написал администратору: {reporttext}");
                    PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Ваше сообщение было отправлено администратору. \n <color={config.TxtSet.TxtColor}>ВНИМАНИЕ! </color> {config.AdmNotify.ReportsNotify}</size>"));
                }
                else
                {
                    PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Введите команду <color={config.TxtSet.TxtColor}>/report сообщение</color> . Текст сообщения будет отправлен администратору. \n <color={config.TxtSet.TxtColor}>ВНИМАНИЕ! </color> {config.AdmNotify.ReportsNotify}</size>"));
                    return;
                }
            }
            else
            {
                PrintToChat(player, String.Format("Данная функция отключена администратором."));
            }
        }
        private void AddBdate(BasePlayer player)
        {
            if (usersdata.VKUsersData[player.userID].Bdate != null) return;
            string Userid = null;
            string userid = usersdata.VKUsersData[player.userID].VkID;
            string url2 = "https://api.vk.com/method/users.get?user_ids=" + userid + "&v=5.69&fields=bdate&access_token=" + config.VKAPIT.VKToken;
            webrequest.Enqueue(url2, null, (code, response) => {
                var json = JObject.Parse(response);
                Userid = (string)json["response"][0]["id"];
                if (Userid == null) return;
                usersdata.VKUsersData[player.userID].Bdate = "noinfo";
                var bdate = (string)json["response"][0]["bdate"];
                if (bdate != null)
                {
                    usersdata.VKUsersData[player.userID].Bdate = bdate;
                }
                VKBData.WriteObject(usersdata);
            }, this);
        }
        private void CheckVkUser(BasePlayer player, string url)
        {
            string Userid = null;
            string[] arr1 = url.Split('/');
            int num = arr1.Length - 1;
            string vkname = arr1[num];
            string url2 = "https://api.vk.com/method/users.get?user_ids=" + vkname + "&v=5.69&fields=bdate&access_token=" + config.VKAPIT.VKToken;
            webrequest.Enqueue(url2, null, (code, response) => {
                var json = JObject.Parse(response);
                Userid = (string)json["response"][0]["id"];
                string bdate = null;
                bdate = (string)json["response"][0]["bdate"];
                if (Userid != null)
                {
                    AddVKUser(player, Userid, bdate);
                }
                else
                {
                    PrintToChat(player, "Ошибка обработки вашей ссылки ВК, обратитесь к администратору.");
                }
            }, this);
        }
        private void AddVKUser(BasePlayer player, string Userid, string bdate)
        {
            if (!usersdata.VKUsersData.ContainsKey(player.userID))
            {
                usersdata.VKUsersData.Add(player.userID, new VKUDATA()
                {
                    UserID = player.userID,
                    Name = player.displayName,
                    VkID = Userid,
                    ConfirmCode = random.Next(1, 9999999),
                    Confirmed = false,
                    GiftRecived = false,
                    Bdate = bdate,
                    Farm = 0,
                    Kills = 0,
                    Raids = 0
                });
                VKBData.WriteObject(usersdata);
                SendVkMessage(usersdata.VKUsersData[player.userID].VkID, $"Для подтверждения вашего ВК профиля введите в игровой чат команду /vk confirm {usersdata.VKUsersData[player.userID].ConfirmCode}");
                PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Вам был отправлен код подтверждения. Если сообщение не пришло, зайдите в группу <color={config.TxtSet.TxtColor}>{config.GrGifts.VKGroupUrl}</color> и напишите любое сообщение. После этого введите команду <color={config.TxtSet.TxtColor}>/vk confirm</color></size>"));
            }
            else
            {
                if (Userid == usersdata.VKUsersData[player.userID].VkID && usersdata.VKUsersData[player.userID].Confirmed) { PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Вы уже добавили и подтвердили свой профиль.</size>")); return; }
                if (Userid == usersdata.VKUsersData[player.userID].VkID && !usersdata.VKUsersData[player.userID].Confirmed) { PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Вы уже добавили свой профиль. Если вам не пришел код подтверждения, введите команду <color={config.TxtSet.TxtColor}>/vk confirm</color></size>")); return; }
                usersdata.VKUsersData[player.userID].Name = player.displayName;
                usersdata.VKUsersData[player.userID].VkID = Userid;
                usersdata.VKUsersData[player.userID].Confirmed = false;
                usersdata.VKUsersData[player.userID].ConfirmCode = random.Next(1, 9999999);
                usersdata.VKUsersData[player.userID].Bdate = bdate;
                VKBData.WriteObject(usersdata);
                SendVkMessage(usersdata.VKUsersData[player.userID].VkID, $"Для подтверждения вашего ВК профиля введите в игровой чат команду /vk confirm {usersdata.VKUsersData[player.userID].ConfirmCode}");
                PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Вам был отправлен код подтверждения. Если сообщение не пришло, зайдите в группу <color={config.TxtSet.TxtColor}>{config.GrGifts.VKGroupUrl}</color> и напишите любое сообщение. После этого введите команду <color={config.TxtSet.TxtColor}>/vk confirm</color></size>"));
            }
        }
        private void VKcommand(BasePlayer player, string cmd, string[] args)
        {
            if (args.Length > 0)
            {
                if (args[0] == "add")
                {
                    if (args.Length == 1) { PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Список доступных команд: \n /vk add ссылка на вашу страницу - добавление вашего профиля ВК в базу</size>")); return; }
                    if (!args[1].Contains("vk.com/")) { PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Ссылка на страницу должна быть вида |vk.com/testpage| или |vk.com/id0000|</size>")); return; }
                    CheckVkUser(player, args[1]);
                }
                if (args[0] == "confirm")
                {
                    if (args.Length >= 2)
                    {
                        if (usersdata.VKUsersData.ContainsKey(player.userID))
                        {
                            if (usersdata.VKUsersData[player.userID].Confirmed) { PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Вы уже подтвердили свой профиль.</size>")); return; }
                            if (args[1] == usersdata.VKUsersData[player.userID].ConfirmCode.ToString())
                            {
                                usersdata.VKUsersData[player.userID].Confirmed = true;
                                VKBData.WriteObject(usersdata);
                                PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Вы подтвердили свой профиль! Спасибо!</size>"));
                                if (config.GrGifts.VKGroupGifts) { PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Вы можете получить награду, если вступили в нашу группу <color={config.TxtSet.TxtColor}>{config.GrGifts.VKGroupUrl}</color> введя команду <color={config.TxtSet.TxtColor}>/vk gift</color></size>")); }
                            }
                            else
                            {
                                PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Неверный код подтверждения.</size>"));
                            }
                        }
                        else
                        {
                            PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Сначала добавьте свой VK ID командой <color={config.TxtSet.TxtColor}>/vk add ссылка на вашу страницу</color></size>"));
                        }
                    }
                    else
                    {
                        if (usersdata.VKUsersData[player.userID].Confirmed) { PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Вы уже подтвердили свой профиль.</size>")); return; }
                        if (usersdata.VKUsersData.ContainsKey(player.userID))
                        {
                            SendVkMessage(usersdata.VKUsersData[player.userID].VkID, $"Для подтверждения вашего ВК профиля введите в игровой чат команду /vk confirm {usersdata.VKUsersData[player.userID].ConfirmCode}");
                            PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Вам был отправлен код подтверждения. Если сообщение не пришло, зайдите в группу <color={config.TxtSet.TxtColor}>{config.GrGifts.VKGroupUrl}</color> и напишите любое сообщение. После этого введите команду <color={config.TxtSet.TxtColor}>/vk confirm</color></size>"));
                        }
                        else
                        {
                            PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Сначала добавьте свой VK ID командой <color={config.TxtSet.TxtColor}>/vk add ссылка на вашу страницу</color></size>"));
                        }
                    }
                }
                if (args[0] == "gift")
                {
                    if (config.GrGifts.VKGroupGifts)
                    {
                        if (!usersdata.VKUsersData.ContainsKey(player.userID)) { PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Сначала добавьте свой VK ID командой <color={config.TxtSet.TxtColor}>/vk add ссылка на вашу страницу</color></size>")); return; }
                        if (!usersdata.VKUsersData[player.userID].Confirmed) { PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Сначала подтвердите свой профиль ВК командой <color={config.TxtSet.TxtColor}>/vk confirm</color></size>")); return; }
                        if (usersdata.VKUsersData[player.userID].GiftRecived) { PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Вы уже получили свою награду.</size>")); return; }
                        string url = $"https://api.vk.com/method/groups.isMember?group_id={config.VKAPIT.GroupID}&user_id={usersdata.VKUsersData[player.userID].VkID}&v=5.69&access_token={config.VKAPIT.VKToken}";
                        webrequest.Enqueue(url, null, (code, response) => {
                            var json = JObject.Parse(response);
                            string Result = (string)json["response"];
                            GetGift(code, Result, player);
                        }, this);
                    }
                    else
                    {
                        PrintToChat(player, String.Format("Данная функция отключена администратором."));
                    }
                }
                if (args[0] == "wipealerts")
                {
                    if (!usersdata.VKUsersData.ContainsKey(player.userID)) { PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Сначала добавьте свой VK ID командой <color={config.TxtSet.TxtColor}>/vk add ссылка на вашу страницу</color></size>")); return; }
                    if (!usersdata.VKUsersData[player.userID].Confirmed) { PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Сначала подтвердите свой профиль ВК командой <color={config.TxtSet.TxtColor}>/vk confirm</color></size>")); return; }
                    if (usersdata.VKUsersData[player.userID].WipeMsg)
                    {
                        usersdata.VKUsersData[player.userID].WipeMsg = false;
                        PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Вы <color={config.TxtSet.TxtColor}>отключили</color> подписку на сообщения о вапах сервера. Что бы включить подписку снова, введите команду <color={config.TxtSet.TxtColor}>/vk wipealerts</color></size>"));
                    }
                    else
                    {
                        usersdata.VKUsersData[player.userID].WipeMsg = true;
                        PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Вы <color={config.TxtSet.TxtColor}>включили</color> подписку на сообщения о вапах сервера. Что бы отключить подписку, введите команду <color={config.TxtSet.TxtColor}>/vk wipealerts</color></size>"));
                    }
                }
                if (args[0] != "add" && args[0] != "gift" && args[0] != "confirm")
                {
                    PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Список доступных команд: \n /vk add ссылка на вашу страницу - добавление вашего профиля ВК в базу. \n /vk confirm - подтверждение вашего профиля ВК</size>"));
                    if (config.GrGifts.VKGroupGifts)
                    {
                        PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>/vk gift - получение награды за вступление в группу <color={config.TxtSet.TxtColor}>{config.GrGifts.VKGroupUrl}</color></size>"));
                    }
                }
            }
            else
            {
                PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Список доступных команд: \n /vk add ссылка на вашу страницу - добавление вашего профиля ВК в базу. \n /vk confirm - подтверждение вашего профиля ВК</size>"));
                if (config.GrGifts.VKGroupGifts)
                {
                    PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>/vk gift - получение награды за вступление в группу <color={config.TxtSet.TxtColor}>{config.GrGifts.VKGroupUrl}</color></size>"));
                }
            }
        }
        private void GetGift(int code, string Result, BasePlayer player)
        {
            if (Result == "1")
            {
                int FreeSlots = 24 - player.inventory.containerMain.itemList.Count;
                if (FreeSlots >= config.GrGifts.VKGroupGiftList.Count)
                {
                    usersdata.VKUsersData[player.userID].GiftRecived = true;
                    VKBData.WriteObject(usersdata);
                    PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Вы получили свою награду! Проверьте инвентарь!</size>"));
                    if (config.GrGifts.GiftsBool)
                    {
                        Server.Broadcast(String.Format($"<size={config.TxtSet.TxtSize}>Игрок <color={config.TxtSet.TxtColor}>{player.displayName}</color> получил награду за вступление в группу <color={config.TxtSet.TxtColor}>{config.GrGifts.VKGroupUrl}.</color> \n Хочешь тоже получить награду? Введи в чат команду <color={config.TxtSet.TxtColor}>/vk gift</color>.</size>"));
                    }
                    for (int i = 0; i < config.GrGifts.VKGroupGiftList.Count; i++)
                    {
                        if (Convert.ToInt32(config.GrGifts.VKGroupGiftList.ElementAt(i).Value) > 0)
                        {
                            Item gift = ItemManager.CreateByName(config.GrGifts.VKGroupGiftList.ElementAt(i).Key, Convert.ToInt32(config.GrGifts.VKGroupGiftList.ElementAt(i).Value));
                            gift.MoveToContainer(player.inventory.containerMain, -1, false);
                        }
                    }
                }
                else
                {
                    PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Недостаточно места для получения награды.</size>"));
                }
            }
            else
            {
                PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Вы не являетесь участником группы <color={config.TxtSet.TxtColor}>{config.GrGifts.VKGroupUrl}</color></size>"));
            }
        }
        private void GiftNotifier()
        {
            if (config.GrGifts.VKGroupGifts)
            {
                foreach (var pl in BasePlayer.activePlayerList)
                {
                    if (!usersdata.VKUsersData.ContainsKey(pl.userID))
                    {
                        PrintToChat(pl, String.Format($"<size={config.TxtSet.TxtSize}>Вступите в нашу группу <color={config.TxtSet.TxtColor}>{config.GrGifts.VKGroupUrl}</color> и получите награду! \n Введите команду <color={config.TxtSet.TxtColor}>/vk gift</color></size>"));
                    }
                    else
                    {
                        if (!usersdata.VKUsersData[pl.userID].GiftRecived)
                        {
                            PrintToChat(pl, String.Format($"<size={config.TxtSet.TxtSize}>Вступите в нашу группу <color={config.TxtSet.TxtColor}>{config.GrGifts.VKGroupUrl}</color> и получите награду! \n Введите команду <color={config.TxtSet.TxtColor}>/vk gift</color></size>"));
                        }
                    }
                }
            }
        }
        void Update1ServerStatus()
        {
            var sleepPlayers = BasePlayer.sleepingPlayerList.Count.ToString();
            var onlcount = GetOnline();
            if (config.StatusStg.UpdateStatus)
            {
                StatData.WriteObject(statdata);
                if (config.StatusStg.EmojiCounterList.Contains("onlinecounter"))
                {
                    opc = EmojiCounters(onlcount);
                }
                else
                {
                    opc = onlcount;
                }
                if (config.StatusStg.EmojiCounterList.Contains("sleepers"))
                {
                    slprs = EmojiCounters(sleepPlayers);
                }
                else
                {
                    slprs = sleepPlayers;
                }
                if (config.StatusStg.EmojiCounterList.Contains("woodcounter"))
                {
                    stw = EmojiCounters(statdata.WoodGath.ToString());
                }
                else
                {
                    stw = statdata.WoodGath.ToString();
                }
                if (config.StatusStg.EmojiCounterList.Contains("sulfurecounter"))
                {
                    sts = EmojiCounters(statdata.SulfureGath.ToString());
                }
                else
                {
                    sts = statdata.SulfureGath.ToString();
                }
                if (config.StatusStg.EmojiCounterList.Contains("rocketscounter"))
                {
                    str = EmojiCounters(statdata.Rockets.ToString());
                }
                else
                {
                    str = statdata.Rockets.ToString();
                }
                if (config.StatusStg.EmojiCounterList.Contains("blueprintsconter"))
                {
                    stb = EmojiCounters(statdata.Blueprints.ToString());
                }
                else
                {
                    stb = statdata.Blueprints.ToString();
                }
                if (config.StatusStg.EmojiCounterList.Contains("explosivecounter"))
                {
                    ste = EmojiCounters(statdata.Explosive.ToString());
                }
                else
                {
                    ste = statdata.Explosive.ToString();
                }
                if (config.StatusStg.EmojiCounterList.Contains("wipedate"))
                {
                    wd = EmojiCounters((string)WipeDate());
                }
                else
                {
                    wd = (string)WipeDate();
                }
                if (config.StatusStg.EmojiCounterList.Contains("usertext"))
                {
                    su = EmojiCounters(config.StatusStg.StatusUT);
                }
                else
                {
                    su = config.StatusStg.StatusUT;
                }
                if (config.StatusStg.EmojiCounterList.Contains("connect"))
                {
                    cone = EmojiCounters(config.StatusStg.connecturl);
                }
                else
                {
                    cone = config.StatusStg.connecturl;
                }
                SendStatus(config.StatusStg.StatusText,
                    new KeyValuePair<string, string>("onlinecounter", opc),
                    new KeyValuePair<string, string>("sleepers", slprs),
                    new KeyValuePair<string, string>("woodcounter", stw),
                    new KeyValuePair<string, string>("sulfurecounter", sts),
                    new KeyValuePair<string, string>("rocketscounter", str),
                    new KeyValuePair<string, string>("blueprintsconter", stb),
                    new KeyValuePair<string, string>("explosivecounter", ste),
                    new KeyValuePair<string, string>("connect", cone),
                    new KeyValuePair<string, string>("wipedate", wd),
                    new KeyValuePair<string, string>("usertext", su));
            }
        }
        void UpdateMultiServerStatus()
        {
            string text = "";
            string server1 = "";
            string server2 = "";
            string server3 = "";
            string server4 = "";
            string server5 = "";
            if (config.MltServSet.Server1ip != "none")
            {
                var url = "http://" + config.MltServSet.Server1ip + "/status.json";
                webrequest.Enqueue(url, null, (code, response) => {
                    if (response != null || code == 200)
                    {

                        var jsonresponse3 = JsonConvert.DeserializeObject<Dictionary<string, object>>(response, jsonsettings);
                        if (!(jsonresponse3 is Dictionary<string, object>) || jsonresponse3.Count == 0 || !jsonresponse3.ContainsKey("players") || !jsonresponse3.ContainsKey("maxplayers")) return;
                        string online = jsonresponse3["players"].ToString();
                        string slots = jsonresponse3["maxplayers"].ToString();
                        if (config.MltServSet.EmojiStatus) { online = EmojiCounters(online); slots = EmojiCounters(slots); }
                        server1 = "1⃣: " + online.ToString() + "/" + slots.ToString();
                    }
                }, this);
            }
            if (config.MltServSet.Server2ip != "none")
            {
                var url = "http://" + config.MltServSet.Server2ip + "/status.json";
                webrequest.Enqueue(url, null, (code, response) => {
                    if (response != null || code == 200)
                    {

                        var jsonresponse3 = JsonConvert.DeserializeObject<Dictionary<string, object>>(response, jsonsettings);
                        if (!(jsonresponse3 is Dictionary<string, object>) || jsonresponse3.Count == 0 || !jsonresponse3.ContainsKey("players") || !jsonresponse3.ContainsKey("maxplayers")) return;
                        string online = jsonresponse3["players"].ToString();
                        string slots = jsonresponse3["maxplayers"].ToString();
                        if (config.MltServSet.EmojiStatus) { online = EmojiCounters(online); slots = EmojiCounters(slots); }
                        server2 = ", 2⃣: " + online.ToString() + "/" + slots.ToString();
                    }
                }, this);
            }
            if (config.MltServSet.Server3ip != "none")
            {
                var url = "http://" + config.MltServSet.Server3ip + "/status.json";
                webrequest.Enqueue(url, null, (code, response) => {
                    if (response != null || code == 200)
                    {

                        var jsonresponse3 = JsonConvert.DeserializeObject<Dictionary<string, object>>(response, jsonsettings);
                        if (!(jsonresponse3 is Dictionary<string, object>) || jsonresponse3.Count == 0 || !jsonresponse3.ContainsKey("players") || !jsonresponse3.ContainsKey("maxplayers")) return;
                        string online = jsonresponse3["players"].ToString();
                        string slots = jsonresponse3["maxplayers"].ToString();
                        if (config.MltServSet.EmojiStatus) { online = EmojiCounters(online); slots = EmojiCounters(slots); }
                        server3 = ", 3⃣: " + online.ToString() + "/" + slots.ToString();
                    }
                }, this);
            }
            if (config.MltServSet.Server4ip != "none")
            {
                var url = "http://" + config.MltServSet.Server4ip + "/status.json";
                webrequest.Enqueue(url, null, (code, response) => {
                    if (response != null || code == 200)
                    {

                        var jsonresponse3 = JsonConvert.DeserializeObject<Dictionary<string, object>>(response, jsonsettings);
                        if (!(jsonresponse3 is Dictionary<string, object>) || jsonresponse3.Count == 0 || !jsonresponse3.ContainsKey("players") || !jsonresponse3.ContainsKey("maxplayers")) return;
                        string online = jsonresponse3["players"].ToString();
                        string slots = jsonresponse3["maxplayers"].ToString();
                        if (config.MltServSet.EmojiStatus) { online = EmojiCounters(online); slots = EmojiCounters(slots); }
                        server4 = ", 4⃣: " + online.ToString() + "/" + slots.ToString();
                    }
                }, this);
            }
            if (config.MltServSet.Server5ip != "none")
            {
                var url = "http://" + config.MltServSet.Server5ip + "/status.json";
                webrequest.Enqueue(url, null, (code, response) => {
                    if (response != null || code == 200)
                    {

                        var jsonresponse3 = JsonConvert.DeserializeObject<Dictionary<string, object>>(response, jsonsettings);
                        if (!(jsonresponse3 is Dictionary<string, object>) || jsonresponse3.Count == 0 || !jsonresponse3.ContainsKey("players") || !jsonresponse3.ContainsKey("maxplayers")) return;
                        string online = jsonresponse3["players"].ToString();
                        string slots = jsonresponse3["maxplayers"].ToString();
                        if (config.MltServSet.EmojiStatus) { online = EmojiCounters(online); slots = EmojiCounters(slots); }
                        server5 = ", 5⃣: " + online.ToString() + "/" + slots.ToString();
                    }
                }, this);
            }
            Puts("Обработка данных. Статус будет отправлен через 10 секунд.");
            timer.Once(10f, () =>
            {
                text = server1 + server2 + server3 + server4 + server5;
                if (text != "")
                {
                    StatusCheck(text);
                    SendVkStatus(text);
                }
                else
                {
                    PrintWarning("Текст статуса пуст, не заполнен конфиг или не получены данные с Rust:IO");
                }
            });
        }
        private void SendStatus(string key, params KeyValuePair<string, string>[] replacements)
        {
            string message = key;
            foreach (var replacement in replacements)
                message = message.Replace($"{{{replacement.Key}}}", replacement.Value);
            SendVkStatus(message);
        }
        private void MsgAdmin(ConsoleSystem.Arg arg)
        {
            if (arg.IsAdmin != true) { return; }
            if (arg.Args == null)
            {
                PrintWarning($"Текст сообщения отсутсвует, правильная команда |sendmsgadmin сообщение|. Message missing, use command |sendmsgadmin message|");
                return;
            }
            string[] args = arg.Args;
            if (args.Length > 0)
            {
                string text = null;
                if (config.MltServSet.MSSEnable)
                {
                    text = $"[VKBot msgadmin] [Сервер {config.MltServSet.ServerNumber}] " + string.Join(" ", args.Skip(0).ToArray());
                }
                else
                {
                    text = $"[VKBot msgadmin] " + string.Join(" ", args.Skip(0).ToArray());
                }
                SendVkMessage(config.AdmNotify.VkID, text);
                Log("Log", $"|sendmsgadmin| Отправлено новое сообщение администратору: ({text})");
            }
        }
        private void GetUserInfo(ConsoleSystem.Arg arg)
        {
            if (arg.IsAdmin != true) { return; }
            if (arg.Args == null)
            {
                PrintWarning($"Введите команду playerinfo имя для получения информации о игроке из базы vkbot");
                return;
            }
            string[] args = arg.Args;
            if (args.Length > 0)
            {
                bool returned = false;
                int amount = usersdata.VKUsersData.Count;
                if (amount != 0)
                {
                    for (int i = 0; i < amount; i++)
                    {
                        if (usersdata.VKUsersData.ElementAt(i).Value.Name.ToLower().Contains(args[0]))
                        {
                            returned = true;
                            string text = "Никнейм: " + usersdata.VKUsersData.ElementAt(i).Value.Name + "\nSTEAM: steamcommunity.com/profiles/" + usersdata.VKUsersData.ElementAt(i).Value.UserID + "/";
                            if (usersdata.VKUsersData.ElementAt(i).Value.Confirmed)
                            {
                                text = text + "\nVK: vk.com/id" + usersdata.VKUsersData.ElementAt(i).Value.VkID;
                            }
                            else
                            {
                                text = text + "\nVK: vk.com/id" + usersdata.VKUsersData.ElementAt(i).Value.VkID + " (не подтвержден)";
                            }
                            if (usersdata.VKUsersData.ElementAt(i).Value.Bdate != null && usersdata.VKUsersData.ElementAt(i).Value.Bdate != "noinfo")
                            {
                                text = text + "\nДата рождения: " + usersdata.VKUsersData.ElementAt(i).Value.Bdate;
                            }
                            if (config.TopWPlayersPromo.TopWPlEnabled)
                            {
                                text = text + "\nРазрушено строений: " + usersdata.VKUsersData.ElementAt(i).Value.Raids + "\nУбито игроков: " + usersdata.VKUsersData.ElementAt(i).Value.Kills + "\nНафармил: " + usersdata.VKUsersData.ElementAt(i).Value.Farm;
                            }
                            Puts(text);
                        }
                    }
                }
                if (!returned)
                {
                    Puts("Не найдено игроков с таким именем");
                }
            }
        }
        #endregion

        #region VKAPI
        private void SendVkMessage(string reciverID, string msg)
        {
            string type = "message";
            string url = "https://api.vk.com/method/messages.send?user_ids=" + reciverID + "&message=" + msg + "&v=5.69&access_token=" + config.VKAPIT.VKToken;
            webrequest.Enqueue(url, null, (code, response) => GetCallback(code, response, type), this);
        }
        private void SendVkWall(string msg)
        {
            string type = "post";
            string url = "https://api.vk.com/method/wall.post?owner_id=-" + config.VKAPIT.GroupID + "&message=" + msg + "&from_group=1&v=5.69&access_token=" + config.VKAPIT.VKTokenApp;
            webrequest.Enqueue(url, null, (code, response) => GetCallback(code, response, type), this);
        }
        private void SendVkStatus(string msg)
        {
            StatusCheck(msg);
            string type = "status";
            string url = "https://api.vk.com/method/status.set?group_id=" + config.VKAPIT.GroupID + "&text=" + msg + "&v=5.69&access_token=" + config.VKAPIT.VKTokenApp;
            webrequest.Enqueue(url, null, (code, response) => GetCallback(code, response, type), this);
        }
        #endregion

        #region VKBotAPI
        string GetUserVKId(ulong userid)
        {
            if (usersdata.VKUsersData.ContainsKey(userid) && usersdata.VKUsersData[userid].Confirmed)
            {
                return usersdata.VKUsersData[userid].VkID;
            }
            else
            {
                return null;
            }
        }
        string GetUserLastNotice(ulong userid)
        {
            if (usersdata.VKUsersData.ContainsKey(userid) && usersdata.VKUsersData[userid].Confirmed)
            {
                return usersdata.VKUsersData[userid].LastRaidNotice;
            }
            else
            {
                return null;
            }
        }
        string AdminVkID()
        {
            return config.AdmNotify.VkID;
        }
        private void VKAPISaveLastNotice(ulong userid, string lasttime)
        {
            if (usersdata.VKUsersData.ContainsKey(userid))
            {
                usersdata.VKUsersData[userid].LastRaidNotice = lasttime;
                VKBData.WriteObject(usersdata);
            }
            else
            {
                return;
            }
        }
        private void VKAPIWall(string text, string attachments, bool atimg)
        {
            if (atimg)
            {
                SendVkWall($"{text}&attachments={attachments}");
                Log("vkbotapi", $"Отправлен новый пост на стену: ({text}&attachments={attachments})");
            }
            else
            {
                SendVkWall($"{text}");
                Log("vkbotapi", $"Отправлен новый пост на стену: ({text})");
            }
        }
        private void VKAPIMsg(string text, string attachments, string reciverID, bool atimg)
        {
            if (atimg)
            {
                SendVkMessage(reciverID, $"{text}&attachment={attachments}");
                Log("vkbotapi", $"Отправлено новое сообщение пользователю {reciverID}: ({text}&attachments={attachments})");
            }
            else
            {
                SendVkMessage(reciverID, $"{text}");
                Log("vkbotapi", $"Отправлено новое сообщение пользователю {reciverID}: ({text})");
            }
        }
        private void VKAPIStatus(string msg)
        {
            SendVkStatus(msg);
            Log("vkbotapi", $"Отправлен новый статус: {msg}");
        }
        #endregion

        #region UpdatesChecks
        void CheckOxideCommits()
        {
            var url = $"https://api.github.com/repos/OxideMod/Oxide.Rust/releases/latest";
            Dictionary<string, string> userAgent = new Dictionary<string, string>();
            userAgent.Add("User-Agent", "OxideMod");
            try { webrequest.Enqueue(url, null, (code, response) => APIResponse(code, response), this, Core.Libraries.RequestMethod.GET, userAgent); }
            catch { timer.Once(60f, CheckOxideCommits); }
        }
        void APIResponse(int code, string response)
        {
            if (response != null || code == 200)
            {
                var jsonresponse2 = JsonConvert.DeserializeObject<Dictionary<string, object>>(response, jsonsettings);
                if (!(jsonresponse2 is Dictionary<string, object>) || jsonresponse2.Count == 0 || !jsonresponse2.ContainsKey("name")) return;
                string message = (string)jsonresponse2["name"];
                if (message == "")
                    message = Oxide.Core.OxideMod.Version.ToString();
                var buildNum = Convert.ToInt32(message.Substring(4));
                bool buildChanged = false;
                if (serverOxideVersion < buildNum)
                {
                    buildChanged = true;
                }
                if (buildChanged && !OxideUpdateNotice)
                {
                    string oxidenotice = null;
                    if (config.MltServSet.MSSEnable)
                    {
                        oxidenotice = $"[VKBot] [Сервер {config.MltServSet.ServerNumber}] Вышло обновление Oxide {message}. Ссылка: github.com/OxideMod/Oxide/releases/latest";
                    }
                    else
                    {
                        oxidenotice = $"[VKBot] Вышло обновление Oxide {message}. Ссылка: github.com/OxideMod/Oxide.Rust/releases/latest";
                    }
                    SendVkMessage(config.AdmNotify.VkID, oxidenotice);
                    OxideUpdateNotice = true;
                }
            }
        }
        #endregion

        #region Helpers
        void Log(string filename, string text)
        {
            LogToFile(filename, $"[{DateTime.Now}] {text}", this);
        }
        void GetCallback(int code, string response, string type)
        {
            if (!response.Contains("error"))
            {
                Puts($"New {type} sended: {response}");
            }
            else
            {
                PrintWarning($"{type} not sended. Error logs: /oxide/logs/VKBot/");
                Log("Errors", $"{type} not sended. Error: {response}");

            }
        }
        private string EmojiCounters(string counter)
        {
            var chars = counter.ToCharArray();
            string emoji = "";
            for (int ctr = 0; ctr < chars.Length; ctr++)
            {
                List<object> digits = new List<object>()
                {
                    "0",
                    "1",
                    "2",
                    "3",
                    "4",
                    "5",
                    "6",
                    "7",
                    "8",
                    "9"
                };
                if (digits.Contains(chars[ctr].ToString()))
                {
                    string replace = chars[ctr] + "⃣";
                    emoji = emoji + replace;
                }
                else
                {
                    emoji = emoji + chars[ctr];
                }
            }
            return emoji;
        }
        private string WipeDate()
        {
            DateTime LastWipe = SaveRestore.SaveCreatedTime.ToLocalTime();
            string LastWipeInfo = LastWipe.ToString("dd.MM");
            return LastWipeInfo;
        }
        private string GetOnline()
        {
            string onlinecounter = "";
            List<ulong> OnlinePlayers = new List<ulong>();
            foreach (var pl in BasePlayer.activePlayerList)
            {
                OnlinePlayers.Add(pl.userID);
            }
            if (config.StatusStg.OnlWmaxslots)
            {
                var slots = ConVar.Server.maxplayers.ToString();
                onlinecounter = OnlinePlayers.Count.ToString() + "/" + slots.ToString();
            }
            else
            {
                onlinecounter = OnlinePlayers.Count.ToString();
            }
            return onlinecounter;
        }
        private static List<BasePlayer> FindPlayersOnline(string nameOrIdOrIp)
        {
            var players = new List<BasePlayer>();
            if (string.IsNullOrEmpty(nameOrIdOrIp)) return players;
            foreach (var activePlayer in BasePlayer.activePlayerList)
            {
                if (activePlayer.UserIDString.Equals(nameOrIdOrIp))
                    players.Add(activePlayer);
                else if (!string.IsNullOrEmpty(activePlayer.displayName) && activePlayer.displayName.Contains(nameOrIdOrIp, CompareOptions.IgnoreCase))
                    players.Add(activePlayer);
                else if (activePlayer.net?.connection != null && activePlayer.net.connection.ipaddress.Equals(nameOrIdOrIp))
                    players.Add(activePlayer);
            }
            return players;
        }
        private void StatusCheck(string msg)
        {
            if (msg.Length > 140)
            {
                PrintWarning($"Текст статуса слишком длинный. Измените формат статуса чтобы текст отобразился полностью. Лимит символов в статусе - 140. Длина текста - {msg.Length.ToString()}");
            }
        }
        #endregion

        #region CheatCheking
        private void StartGUI(BasePlayer player)
        {
            var RankElements = new CuiElementContainer();
            var Choose = RankElements.Add(new CuiPanel
            {
                Image = { Color = $"0.0 0.0 0 0.35" },
                RectTransform = { AnchorMin = config.PlChkSet.GUIAnchorMin, AnchorMax = config.PlChkSet.GUIAnchorMax },
                CursorEnabled = false,
            }, "Hud", "AlertGUI");
            RankElements.Add(new CuiButton
            {
                Button = { Color = $"0.34 0.34 0.34 0" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Text = { Text = String.Format(config.PlChkSet.PlCheckText), Align = TextAnchor.MiddleCenter, Color = "1 1 1 1", FontSize = config.PlChkSet.PlCheckSize }
            }, Choose);
            CuiHelper.AddUi(player, RankElements);
        }
        private void StopGui(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "AlertGUI");
        }
        private void StopCheckPlayer(BasePlayer player, string cmd, string[] args)
        {
            if (!permission.UserHasPermission(player.userID.ToString(), config.PlChkSet.PlCheckPerm))
            {
                PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Увас нет прав для использования данной команды</size>"));
                return;
            }
            if (args.Length == 1)
            {
                var targets = FindPlayersOnline(args[0]);
                if (targets.Count <= 0)
                {
                    PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Игрок не найден</size>"));
                    return;
                }
                if (targets.Count > 1)
                {
                    PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Найдено несколько игроков: " + string.Join(", ", targets.ConvertAll(p => p.displayName).ToArray()) + ". Уточните имя игрока.</size>"));
                    return;
                }
                var target = targets[0];
                if (target == player)
                {
                    PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Вас вызвали на проверку, вы не можете сами ее закончить</size>"));
                    return;
                }
                if (!PlayersCheckList.ContainsValue(target.userID))
                {
                    PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Этого игрока не вызывали на проверку</size>"));
                    return;
                }
                ulong targetid;
                PlayersCheckList.TryGetValue(player.userID, out targetid);
                if (targetid != target.userID)
                {
                    PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Вы не можете закончить проверку, начатую другим модератором</size>"));
                    return;
                }
                StopGui(target);
                PlayersCheckList.Remove(player.userID);
                PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Вы закончили проверку игрока <color={config.TxtSet.TxtColor}>{target.displayName}</color></size>"));
            }
            else
            {
                PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Команда <color={config.TxtSet.TxtColor}>/unalert имя_игрока</color> или <color={config.TxtSet.TxtColor}>/unalert steamid</color></size>"));
                return;
            }
        }
        private void StartCheckPlayer(BasePlayer player, string cmd, string[] args)
        {
            if (!permission.UserHasPermission(player.userID.ToString(), config.PlChkSet.PlCheckPerm))
            {
                PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Увас нет прав для использования данной команды</size>"));
                return;
            }
            if (!usersdata.VKUsersData.ContainsKey(player.userID) || !usersdata.VKUsersData[player.userID].Confirmed)
            {
                PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Сначала добавьте и подтвердите свой профиль командой <color={config.TxtSet.TxtColor}>/vk add ссылка на страницу</color></size>"));
                return;
            }
            if (args.Length == 1)
            {
                var targets = FindPlayersOnline(args[0]);
                if (targets.Count <= 0)
                {
                    PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Игрок не найден</size>"));
                    return;
                }
                if (targets.Count > 1)
                {
                    PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Найдено несколько игроков: " + string.Join(", ", targets.ConvertAll(p => p.displayName).ToArray()) + ". Уточните имя игрока.</size>"));
                    return;
                }
                var target = targets[0];
                if (target == player)
                {
                    PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Вы не можете проверить сами себя</size>"));
                    return;
                }
                if (PlayersCheckList.ContainsValue(target.userID))
                {
                    PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Этого игрока уже вызвали на проверку</size>"));
                    return;
                }
                if (PlayersCheckList.ContainsKey(player.userID))
                {
                    PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Сначала закончите предыдущую проверку</size>"));
                    return;
                }
                StartGUI(target);
                PlayersCheckList.Add(player.userID, target.userID);
                PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Вы вызвали игрока <color={config.TxtSet.TxtColor}>{target.displayName}</color> на проверку</size>"));
            }
            else
            {
                PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Команда <color={config.TxtSet.TxtColor}>/alert имя_игрока</color> или <color={config.TxtSet.TxtColor}>/alert steamid</color></size>"));
                return;
            }
        }
        private void SkypeSending(BasePlayer player, string cmd, string[] args)
        {
            if (!PlayersCheckList.ContainsValue(player.userID))
            {
                PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Вас не вызывали на проверку. Ваш скайп нам не нужен <color={config.TxtSet.TxtColor}>:)</color></size>"));
                return;
            }
            if (args.Length == 1)
            {
                string reciverid = null;
                for (int i = 0; i < PlayersCheckList.Count; i++)
                {
                    if (PlayersCheckList.ElementAt(i).Value == player.userID)
                    {
                        ulong moderid = PlayersCheckList.ElementAt(i).Key;
                        reciverid = usersdata.VKUsersData[moderid].VkID;
                    }
                }
                if (reciverid != null)
                {
                    if (config.MltServSet.MSSEnable)
                    {
                        msg = "[VKBot] [Сервер " + config.MltServSet.ServerNumber.ToString() + "] " + player.displayName + "(" + player.UserIDString + ") предоставил скайп для проверки: " + args[0] + ". По завершению проверки введите команду /unalert " + player.displayName + " . Ссылка на профиль стим: steamcommunity.com/profiles/" + player.userID.ToString() + "/";
                    }
                    else
                    {
                        msg = "[VKBot] " + player.displayName + "(" + player.UserIDString + ") предоставил скайп для проверки: " + args[0] + ". Ссылка на профиль стим: steamcommunity.com/profiles/" + player.userID.ToString() + "/";
                    }
                    if (usersdata.VKUsersData.ContainsKey(player.userID) && usersdata.VKUsersData[player.userID].Confirmed)
                    {
                        msg = msg + " . Ссылка на профиль ВК: vk.com/id" + usersdata.VKUsersData[player.userID].VkID;
                    }
                    SendVkMessage(reciverid, msg);
                    PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Ваш скайп был отправлен модератору. Ожидайте звонка.</size>"));
                }
                else
                {
                    PrintWarning("Не удалось найти id модератора. Напишите разработчику.");
                    return;
                }
            }
            else
            {
                PrintToChat(player, String.Format($"<size={config.TxtSet.TxtSize}>Команда <color={config.TxtSet.TxtColor}>:)/skype НИК в СКАЙПЕ</color></size>"));
                return;
            }
        }
        #endregion
        
        #region TopWipePlayersStatsAndPromo
        private ulong GetTopRaider()
        {
            int max = 0;
            ulong TopID = 0;
            int amount = usersdata.VKUsersData.Count;
            if (amount != 0)
            {
                for (int i = 0; i < amount; i++)
                {
                    if (usersdata.VKUsersData.ElementAt(i).Value.Raids > max)
                    {
                        max = usersdata.VKUsersData.ElementAt(i).Value.Raids;
                        TopID = usersdata.VKUsersData.ElementAt(i).Value.UserID;
                    }
                }
            }
            return TopID;
        }
        private ulong GetTopKiller()
        {
            int max = 0;
            ulong TopID = 0;
            int amount = usersdata.VKUsersData.Count;
            if (amount != 0)
            {
                for (int i = 0; i < amount; i++)
                {
                    if (usersdata.VKUsersData.ElementAt(i).Value.Kills > max)
                    {
                        max = usersdata.VKUsersData.ElementAt(i).Value.Kills;
                        TopID = usersdata.VKUsersData.ElementAt(i).Value.UserID;
                    }
                }
            }
            return TopID;
        }
        private ulong GetTopFarmer()
        {
            int max = 0;
            ulong TopID = 0;
            int amount = usersdata.VKUsersData.Count;
            if (amount != 0)
            {
                for (int i = 0; i < amount; i++)
                {
                    if (usersdata.VKUsersData.ElementAt(i).Value.Farm > max)
                    {
                        max = usersdata.VKUsersData.ElementAt(i).Value.Farm;
                        TopID = usersdata.VKUsersData.ElementAt(i).Value.UserID;
                    }
                }
            }
            return TopID;
        }
        private void SendPromoMsgsAndPost()
        {
            var traider = GetTopRaider();
            var tkiller = GetTopKiller();
            var tfarmer = GetTopFarmer();
            if (config.TopWPlayersPromo.TopPlPost)
            {
                bool check = false;
                string text = "Топ игроки прошедшего вайпа:";
                if (traider != 0)
                {
                    text = text + "\nТоп рэйдер: " + usersdata.VKUsersData[traider].Name;
                    check = true;
                }
                if (tkiller != 0)
                {
                    text = text + "\nТоп киллер: " + usersdata.VKUsersData[tkiller].Name;
                    check = true;
                }
                if (tfarmer != 0)
                {
                    text = text + "\nТоп фармер: " + usersdata.VKUsersData[tfarmer].Name;
                    check = true;
                }
                if (config.TopWPlayersPromo.TopPlPromoGift)
                {
                    text = text + "\nТоп игроки получают в качестве награды промокод на баланс в магазине.\n P.S. Если вы заняли топ место, но вам не пришел промокод, значит вы не добавили свой профиль вк командой /vk add или не подтвердили его.";
                }
                if (check)
                {
                    SendVkWall(text);
                }
            }
            if (traider != 0 && config.TopWPlayersPromo.TopPlPromoGift && usersdata.VKUsersData.ContainsKey(traider) && usersdata.VKUsersData[traider].Confirmed)
            {
                string text = "";
                if (config.MltServSet.MSSEnable)
                {
                    text = "[Сервер " + config.MltServSet.ServerNumber.ToString() + "] ";
                }
                text = text + "Поздравляем! Вы Топ 1 рэйдер по результатам этого вайпа! В качестве награды, вы получаете промокод " + config.TopWPlayersPromo.TopRaiderPromo + " на баланс в нашем магазине! " + config.TopWPlayersPromo.StoreUrl;
                string reciver = usersdata.VKUsersData[traider].VkID;
                SendVkMessage(reciver, text);
            }
            if (tkiller != 0 && config.TopWPlayersPromo.TopPlPromoGift && usersdata.VKUsersData.ContainsKey(tkiller) && usersdata.VKUsersData[tkiller].Confirmed)
            {
                string text = "";
                if (config.MltServSet.MSSEnable)
                {
                    text = "[Сервер " + config.MltServSet.ServerNumber.ToString() + "] ";
                }
                text = text + "Поздравляем! Вы Топ 1 киллер по результатам этого вайпа! В качестве награды, вы получаете промокод " + config.TopWPlayersPromo.TopKillerPromo + " на баланс в нашем магазине! " + config.TopWPlayersPromo.StoreUrl;
                string reciver = usersdata.VKUsersData[tkiller].VkID;
                SendVkMessage(reciver, text);
            }
            if (tfarmer != 0 && config.TopWPlayersPromo.TopPlPromoGift && usersdata.VKUsersData.ContainsKey(tfarmer) && usersdata.VKUsersData[tfarmer].Confirmed)
            {
                string text = "";
                if (config.MltServSet.MSSEnable)
                {
                    text = "[Сервер " + config.MltServSet.ServerNumber.ToString() + "] ";
                }
                text = text + "Поздравляем! Вы Топ 1 фармер по результатам этого вайпа! В качестве награды, вы получаете промокод " + config.TopWPlayersPromo.TopFarmerPromo + " на баланс в нашем магазине! " + config.TopWPlayersPromo.StoreUrl;
                string reciver = usersdata.VKUsersData[tfarmer].VkID;
                SendVkMessage(reciver, text);
            }
        }
        private string PromoGenerator()
        {
            List<string> Chars = new List<string>() { "A", "1", "B", "2", "C", "3", "D", "4", "F", "5", "G", "6", "H", "7", "I", "8", "J", "9", "K", "0", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z" };
            string promo = "";
            for (int i = 0; i < 6; i++)
            {
                promo = promo + Chars.GetRandom();
            }
            return promo;
        }
        private void SetRandomPromo()
        {
            config.TopWPlayersPromo.TopFarmerPromo = PromoGenerator();
            config.TopWPlayersPromo.TopKillerPromo = PromoGenerator();
            config.TopWPlayersPromo.TopRaiderPromo = PromoGenerator();
            Config.WriteObject(config, true);
            string msg = "[VKBot]";
            if (config.MltServSet.MSSEnable)
            {
                msg = msg + " [Сервер " + config.MltServSet.ServerNumber.ToString() + "]";
            }
            msg = msg + " В настройки добавлены новые промокоды: \nТоп рэйдер - " + config.TopWPlayersPromo.TopRaiderPromo + "\nТоп киллер - " + config.TopWPlayersPromo.TopKillerPromo + "\nТоп фармер - " + config.TopWPlayersPromo.TopFarmerPromo;
            SendVkMessage(config.AdmNotify.VkID, msg);
        }
        #endregion
    }
}

// --- End of file: VKBot.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SkinBox.cs ---
// --- Original Local Path: SkinBox.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core.Libraries;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using System.Text;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("SkinBox", "k1lly0u", "2.0.4"), Description("Allows you to reskin item's by placing it in the SkinBox and selecting a new skin")]
    class SkinBox : RustPlugin
    {
        #region Fields
        [PluginReference]
        private Plugin ServerRewards, Economics;


        private Hash<string, HashSet<ulong>> _skinList = new Hash<string, HashSet<ulong>>();

        private Hash<ulong, string> _skinPermissions = new Hash<ulong, string>();

        private Hash<ulong, LootHandler> _activeSkinBoxes = new Hash<ulong, LootHandler>();

        private Hash<string, string> _shortnameToDisplayname = new Hash<string, string>();

        private Hash<ulong, string> _skinNameLookup = new Hash<ulong, string>();

        private Hash<ulong, double> _cooldownTimes = new Hash<ulong, double>();


        private bool _apiKeyMissing = false;

        private bool _skinsLoaded = false;


        private CostType _costType;


        private static SkinBox Instance { get; set; }

        private static Func<string, ulong, string> GetMessage;

        private const string COFFIN_PREFAB = "assets/prefabs/misc/halloween/coffin/coffinstorage.prefab";

        private const int SCRAP_ITEM_ID = -932201673;

        private enum CostType { Scrap, ServerRewards, Economics }
        #endregion

        #region Oxide Hooks
        private void Loaded()
        {
            Instance = this;

            Configuration.Permission.RegisterPermissions(permission, this);
            Configuration.Permission.ReverseCustomSkinPermissions(ref _skinPermissions);

            Configuration.Command.RegisterCommands(cmd, this);

            _costType = ParseType<CostType>(Configuration.Cost.Currency);

            GetMessage = (string key, ulong userId) => lang.GetMessage(key, this, userId.ToString());
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoAPIKey"] = "The server owner has not entered a Steam API key in the config. Unable to continue!",
                ["SkinsLoading"] = "SkinBox is still gathering skins. Please try again soon",
                ["NoPermission"] = "You don't have permission to use the SkinBox",
                ["ToNearPlayer"] = "The SkinBox is currently not usable at this place",
                ["CooldownTime"] = "You need to wait {0} seconds to use the SkinBox again",

                ["NotEnoughBalanceOpen"] = "You need at least {0} {1} to open the SkinBox",
                ["NotEnoughBalanceUse"] = "You would need at least {0} {1} to skin {2}",
                ["NotEnoughBalanceTake"] = "{0} was not skinned. You do not have enough {1}",
                ["CostToUse"] = "Skinning a item is not free!\n{0} {3} to skin a deployable\n{1} {3} to skin a weapon\n{2} {3} to skin attire",

                ["Cost.Scrap"] = "Scrap",
                ["Cost.ServerRewards"] = "RP",
                ["Cost.Economics"] = "Eco",
            }, this);
        }

        private void OnServerInitialized()
        {
            if (string.IsNullOrEmpty(Configuration.Skins.APIKey))
            {
                _apiKeyMissing = true;
                SendAPIMissingWarning();                
                return;
            }

            if ((Steamworks.SteamInventory.Definitions?.Length ?? 0) == 0)
            {
                PrintWarning("Waiting for Steamworks to update item definitions....");
                Steamworks.SteamInventory.OnDefinitionsUpdated += StartSkinRequest;
            }
            else StartSkinRequest();
        }

        private object CanAcceptItem(ItemContainer container, Item item)
        {
            if (container.entityOwner == null)
                return null;

            LootHandler lootHandler = container.entityOwner.GetComponent<LootHandler>();
            if (lootHandler == null)
                return null;

            if (item.isBroken || lootHandler.HasItem || !HasItemPermissions(lootHandler.Looter, item))
                return ItemContainer.CanAcceptResult.CannotAccept;

            string shortname = GetRedirectedShortname(item.info.shortname);

            if (!Configuration.Skins.UseRedirected && !shortname.Equals(item.info.shortname, StringComparison.OrdinalIgnoreCase))
                return ItemContainer.CanAcceptResult.CannotAccept;

            HashSet<ulong> skins;
            if (!_skinList.TryGetValue(shortname, out skins) || skins.Count == 0)
            {
                Debug.Log(skins?.Count ?? 0);
                return ItemContainer.CanAcceptResult.CannotAccept;
            }

            int reskinCost = GetReskinCost(item);

            if (reskinCost > 0 && !CanAffordToUse(lootHandler.Looter, reskinCost))
            {
                lootHandler.PopupMessage(string.Format(GetMessage("NotEnoughBalanceUse", lootHandler.Looter.userID), 
                                                                   reskinCost,
                                                                   GetCostType(lootHandler.Looter.userID),
                                                                   item.info.displayName.english));

                return ItemContainer.CanAcceptResult.CannotAccept;

            }

            return null;
        }

        private void OnItemSplit(Item item, int amount)
        {
            LootHandler lootHandler = item.parent?.entityOwner?.GetComponent<LootHandler>();
            if (lootHandler != null)
                lootHandler.CheckItemHasSplit(item);
        }        

        private object CanMoveItem(Item movedItem, PlayerInventory inventory, uint targetContainerID, int targetSlot, int amount)
        {
            if (movedItem.parent?.entityOwner != null)
            {
                LootHandler lootHandler = movedItem.parent?.entityOwner?.GetComponent<LootHandler>();
                if (lootHandler != null && lootHandler.InputAmount > 1)
                {
                    ItemContainer targetContainer = inventory.FindContainer(targetContainerID);
                    if (targetContainer != null && targetContainer.GetSlot(targetSlot) != null)
                        return false;
                }
            }
            return null;
        }

        private void OnItemAddedToContainer(ItemContainer container, Item item) => container?.entityOwner?.GetComponent<LootHandler>()?.OnItemAdded(item);

        private void OnItemRemovedFromContainer(ItemContainer container, Item item) => container?.entityOwner?.GetComponent<LootHandler>()?.OnItemRemoved(item);

        private void OnLootEntityEnd(BasePlayer player, StorageContainer storageContainer)
        {
            LootHandler lootHandler;
            if (_activeSkinBoxes.TryGetValue(player.userID, out lootHandler))            
                UnityEngine.Object.Destroy(lootHandler);            
        }

        private void Unload()
        {
            LootHandler[] lootHandlers = UnityEngine.Object.FindObjectsOfType<LootHandler>();
            for (int i = 0; i < lootHandlers.Length; i++)
            {
                LootHandler lootHandler = lootHandlers[i];
                if (lootHandler.Looter != null)                
                    lootHandler.Looter.EndLooting();                
                UnityEngine.Object.Destroy(lootHandler);
            }

            Configuration = null;
            Instance = null;
        }
        #endregion

        #region Functions
        private void SendAPIMissingWarning()
        {
            Debug.LogWarning("You must enter a Steam API key in the config!\nYou can get a API key here -> https://steamcommunity.com/dev/apikey \nOnce you have your API key copy it to the 'Skin Options/Steam API Key' field in your SkinBox.json config file");
        }

        private void ChatMessage(BasePlayer player, string key, params object[] args)
        {
            if (args == null)
                player.ChatMessage(lang.GetMessage(key, this, player.UserIDString));
            else player.ChatMessage(string.Format(lang.GetMessage(key, this, player.UserIDString), args));
        }

        private void CreateSkinBox(BasePlayer player)
        {
            StorageContainer container = GameManager.server.CreateEntity(COFFIN_PREFAB, player.transform.position + (Vector3.down * 250f)) as StorageContainer;
            container.limitNetworking = true;
            container.enableSaving = false;

            UnityEngine.Object.Destroy(container.GetComponent<DestroyOnGroundMissing>());
            UnityEngine.Object.Destroy(container.GetComponent<GroundWatch>());

            container.Spawn();

            LootHandler lootHandler;
            if (_activeSkinBoxes.TryGetValue(player.userID, out lootHandler))
            {
                player.EndLooting();
                UnityEngine.Object.Destroy(lootHandler);
            }

            lootHandler = container.gameObject.AddComponent<LootHandler>();
            lootHandler.Looter = player;

            player.inventory.loot.Clear();
            player.inventory.loot.PositionChecks = false;
            player.inventory.loot.entitySource = container;
            player.inventory.loot.itemSource = null;
            player.inventory.loot.MarkDirty();
            player.inventory.loot.AddContainer(container.inventory);
            player.inventory.loot.SendImmediate();

            player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", container.panelName);
            container.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

            if (Configuration.Cost.Enabled && !permission.UserHasPermission(player.UserIDString, Configuration.Permission.NoCost))
            {
                lootHandler.PopupMessage(string.Format(GetMessage("CostToUse", lootHandler.Looter.userID), Configuration.Cost.Deployable, 
                                                                                                           Configuration.Cost.Weapon, 
                                                                                                           Configuration.Cost.Attire,
                                                                                                           GetCostType(player.userID)));
            }

            _activeSkinBoxes[player.userID] = lootHandler;
        }
        #endregion

        #region Helpers
        private void GetSkinsFor(BasePlayer player, string shortname, ref List<ulong> list)
        {
            list.Clear();

            HashSet<ulong> skins;
            if (_skinList.TryGetValue(shortname, out skins))
            {                
                foreach(ulong skinId in skins)
                {
                    string perm;
                    if (_skinPermissions.TryGetValue(skinId, out perm) && !permission.UserHasPermission(player.UserIDString, perm))
                        continue;

                    if (Configuration.Blacklist.Contains(skinId) && player.net.connection.authLevel < Configuration.Other.BlacklistAuth)
                        continue;

                    list.Add(skinId);
                }
            }
        }

        private bool HasItemPermissions(BasePlayer player, Item item)
        {
            switch (item.info.category)
            {
                case ItemCategory.Weapon:
                case ItemCategory.Tool:
                    return permission.UserHasPermission(player.UserIDString, Configuration.Permission.Weapon);
                case ItemCategory.Construction:                   
                case ItemCategory.Items:
                    return permission.UserHasPermission(player.UserIDString, Configuration.Permission.Deployable);
                case ItemCategory.Attire:
                    return permission.UserHasPermission(player.UserIDString, Configuration.Permission.Attire);
                default:
                    return true;
            }            
        }
        
        private T ParseType<T>(string type)
        {
            try
            {
                return (T)Enum.Parse(typeof(T), type, true);
            }
            catch
            {
                return default(T);
            }
        }

        private double CurrentTime => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;
        #endregion

        #region Usage Costs 
        private string GetCostType(ulong playerId) => GetMessage($"Cost.{_costType}", playerId);

        private int GetReskinCost(Item item)
        {
            if (!Configuration.Cost.Enabled)
                return 0;

            switch (item.info.category)
            {
                case ItemCategory.Weapon:
                case ItemCategory.Tool:
                    return Configuration.Cost.Weapon;
                case ItemCategory.Construction:
                case ItemCategory.Items:
                    return Configuration.Cost.Deployable;
                case ItemCategory.Attire:
                    return Configuration.Cost.Attire;
                default:
                    return 0;
            }
        }

        private bool CanAffordToUse(BasePlayer player, int amount)
        {
            if (!Configuration.Cost.Enabled || amount == 0 || permission.UserHasPermission(player.UserIDString, Configuration.Permission.NoCost))
                return true;

            switch (_costType)
            {
                case CostType.Scrap:
                    return player.inventory.GetAmount(SCRAP_ITEM_ID) >= amount;
                case CostType.ServerRewards:
                    return (int)ServerRewards?.Call("CheckPoints", player.userID) >= amount;
                case CostType.Economics:
                    return (double)Economics?.Call("Balance", player.UserIDString) >= amount;                
            }

            return false;
        }

        private bool ChargePlayer(BasePlayer player, ItemCategory itemCategory)
        {
            if (!Configuration.Cost.Enabled || permission.UserHasPermission(player.UserIDString, Configuration.Permission.NoCost))
                return true;

            int amount = itemCategory == ItemCategory.Weapon || itemCategory == ItemCategory.Tool ? Configuration.Cost.Weapon :
                         itemCategory == ItemCategory.Items || itemCategory == ItemCategory.Construction ? Configuration.Cost.Deployable :
                         itemCategory == ItemCategory.Attire ? Configuration.Cost.Attire : 0;

            return ChargePlayer(player, amount);
        }

        private bool ChargePlayer(BasePlayer player, int amount)
        {
            if (amount == 0 || !Configuration.Cost.Enabled || permission.UserHasPermission(player.UserIDString, Configuration.Permission.NoCost))
                return true;

            switch (_costType)
            {
                case CostType.Scrap:
                    if (amount <= player.inventory.GetAmount(SCRAP_ITEM_ID))
                    {
                        player.inventory.Take(null, SCRAP_ITEM_ID, amount);
                        return true;
                    }
                    return false;
                case CostType.ServerRewards:
                    return (bool)ServerRewards?.Call("TakePoints", player.userID, amount);
                case CostType.Economics:
                    return (bool)Economics?.Call("Withdraw", player.UserIDString, (double)amount);
            }
            return false;
        }
        #endregion

        #region Cooldown
        private void ApplyCooldown(BasePlayer player)
        {
            if (!Configuration.Cooldown.Enabled || permission.UserHasPermission(player.UserIDString, Configuration.Permission.NoCooldown))
                return;

            _cooldownTimes[player.userID] = CurrentTime + Configuration.Cooldown.Time;
        }

        private bool IsOnCooldown(BasePlayer player)
        {
            if (!Configuration.Cooldown.Enabled || permission.UserHasPermission(player.UserIDString, Configuration.Permission.NoCooldown))
                return false;

            double time;
            if (_cooldownTimes.TryGetValue(player.userID, out time) && time > CurrentTime)
                return true;

            return false;
        }

        private bool IsOnCooldown(BasePlayer player, out double remaining)
        {
            remaining = 0;

            if (!Configuration.Cooldown.Enabled || permission.UserHasPermission(player.UserIDString, Configuration.Permission.NoCooldown))
                return false;

            double time;
            if (_cooldownTimes.TryGetValue(player.userID, out time) && time > CurrentTime)
            {
                remaining = time - CurrentTime;
                return true;
            }
            
            return false;
        }
        #endregion

        #region Approved Skins
        private void StartSkinRequest()
        {
            Steamworks.SteamInventory.OnDefinitionsUpdated -= StartSkinRequest;

            UpdateWorkshopNameConversionList();

            FindItemRedirects();

            if (!Configuration.Skins.UseApproved && !Configuration.Skins.UseWorkshop)
            {
                PrintError("You have approved skins and workshop skins disabled. This leaves no skins available to use in SkinBox!");
                return;
            }

            if (!Configuration.Skins.UseApproved && Configuration.Skins.UseWorkshop)
            {
                VerifyWorkshopSkins();
                return;
            }

            PrintWarning("Retrieving approved skin lists...");

            CollectApprovedSkins();
        }

        private void CollectApprovedSkins()
        {
            int count = 0;

            bool addApprovedPermission = Configuration.Permission.Approved != Configuration.Permission.Use;

            bool updateConfig = false;

            List<ulong> list = Facepunch.Pool.GetList<ulong>();

            List<int> itemSkinDirectory = Facepunch.Pool.GetList<int>();
            itemSkinDirectory.AddRange(ItemSkinDirectory.Instance.skins.Select(x => x.id));

            foreach (ItemDefinition itemDefinition in ItemManager.itemList)
            {
                list.Clear();                 

                foreach (Steamworks.InventoryDef item in Steamworks.SteamInventory.Definitions)
                {
                    string shortname = item.GetProperty("itemshortname");
                    if (string.IsNullOrEmpty(shortname) || item.Id < 100)
                        continue;
                                        
                    if (_workshopNameToShortname.ContainsKey(shortname))
                        shortname = _workshopNameToShortname[shortname];

                    if (!shortname.Equals(itemDefinition.shortname, StringComparison.OrdinalIgnoreCase))  
                        continue;                    

                    ulong skinId;

                    if (itemSkinDirectory.Contains(item.Id))
                        skinId = (ulong)item.Id;
                    else if (!ulong.TryParse(item.GetProperty("workshopid"), out skinId))
                        continue;

                    if (list.Contains(skinId) || Configuration.Skins.ApprovedLimit > 0 && list.Count >= Configuration.Skins.ApprovedLimit)                    
                        continue;
                    
                    list.Add(skinId);

                    _skinNameLookup[skinId] = item.Name;
                }

                if (list.Count > 1)
                {
                    count += list.Count;

                    HashSet<ulong> skins;
                    if (!_skinList.TryGetValue(itemDefinition.shortname, out skins))
                        skins = _skinList[itemDefinition.shortname] = new HashSet<ulong>();

                    int removeCount = 0;

                    list.ForEach((ulong skin) =>
                    {
                        if (Configuration.Skins.RemoveApproved && Configuration.SkinList.ContainsKey(itemDefinition.shortname) && 
                                                                  Configuration.SkinList[itemDefinition.shortname].Contains(skin))
                        {
                            Configuration.SkinList[itemDefinition.shortname].Remove(skin);
                            removeCount++;
                            updateConfig = true;
                        }

                        skins.Add(skin);

                        if (addApprovedPermission)
                            _skinPermissions[skin] = Configuration.Permission.Approved;
                    });

                    if (removeCount > 0)
                        Debug.Log($"[SkinBox] Removed {removeCount} approved skin ID's for {itemDefinition.shortname} from the config skin list");
                }
            }

            if (updateConfig)
                SaveConfig();

            Facepunch.Pool.FreeList(ref list);
            Facepunch.Pool.FreeList(ref itemSkinDirectory);

            Debug.Log($"[SkinBox] - Loaded {count} approved skins");

            if (Configuration.Skins.UseWorkshop && Configuration.SkinList.Sum(x => x.Value.Count) > 0)
                VerifyWorkshopSkins();
            else
            {
                _skinsLoaded = true;
                Interface.Oxide.CallHook("OnSkinBoxSkinsLoaded", _skinList);
                Debug.Log($"[SkinBox] - SkinBox has loaded all required skins and is ready to use! ({_skinList.Values.Sum(x => x.Count)} skins acrosss {_skinList.Count} items)");
            }
        }
        #endregion

        #region Workshop Skins
        private List<ulong> _skinsToVerify = new List<ulong>();

        private const string PUBLISHED_FILE_DETAILS = "https://api.steampowered.com/ISteamRemoteStorage/GetPublishedFileDetails/v1/";
        private const string COLLECTION_DETAILS = "https://api.steampowered.com/ISteamRemoteStorage/GetCollectionDetails/v1/";
        private const string ITEMS_BODY = "?key={0}&itemcount={1}";
        private const string ITEM_ENTRY = "&publishedfileids[{0}]={1}";
        private const string COLLECTION_BODY = "?key={0}&collectioncount=1&publishedfileids[0]={1}";

        private void VerifyWorkshopSkins()
        {
            foreach (HashSet<ulong> list in Configuration.SkinList.Values)
                _skinsToVerify.AddRange(list);

            SendWorkshopQuery();
        }

        private void SendWorkshopQuery(int page = 0, ConsoleSystem.Arg arg = null, string perm = null)
        {
            int totalPages = Mathf.CeilToInt((float)_skinsToVerify.Count / 100f);
            int index = page * 100;
            int limit = Mathf.Min((page + 1) * 100, _skinsToVerify.Count);
            string details = string.Format(ITEMS_BODY, Configuration.Skins.APIKey, (limit - index));

            for (int i = index; i < limit; i++)
            {
                details += string.Format(ITEM_ENTRY, i - index, _skinsToVerify[i]);
            }

            try
            {
                webrequest.Enqueue(PUBLISHED_FILE_DETAILS, details, (code, response) => ServerMgr.Instance.StartCoroutine(ValidateRequiredSkins(code, response, page + 1, totalPages, false, arg, perm)), this, RequestMethod.POST);
            }
            catch { }
        }

        private void SendWorkshopCollectionQuery(ulong collectionId, bool add, ConsoleSystem.Arg arg = null, string perm = null)
        {
            string details = string.Format(COLLECTION_BODY, Configuration.Skins.APIKey, collectionId);

            try
            {
                webrequest.Enqueue(COLLECTION_DETAILS, details, (code, response) => ServerMgr.Instance.StartCoroutine(ProcessCollectionRequest(code, response, add, arg, perm)), this, RequestMethod.POST);
            }
            catch { }
        }
       
        private IEnumerator ValidateRequiredSkins(int code, string response, int page, int totalPages, bool isCollection, ConsoleSystem.Arg arg, string perm)
        {
            bool hasChanged = false;
            if (response != null && code == 200)
            {
                QueryResponse queryRespone = JsonConvert.DeserializeObject<QueryResponse>(response);
                if (queryRespone != null && queryRespone.response != null && queryRespone.response.publishedfiledetails?.Length > 0)
                {
                    SendResponse($"Processing workshop response. Page: {page} / {totalPages}", arg);                    

                    foreach (PublishedFileDetails publishedFileDetails in queryRespone.response.publishedfiledetails)
                    {
                        if (publishedFileDetails.tags != null)
                        {
                            foreach (PublishedFileDetails.Tag tag in publishedFileDetails.tags)
                            {                                
                                if (string.IsNullOrEmpty(tag.tag))
                                    continue;

                                ulong workshopid = Convert.ToUInt64(publishedFileDetails.publishedfileid);

                                string adjTag = tag.tag.ToLower().Replace("skin", "").Replace(" ", "").Replace("-", "").Replace(".item", "");
                                if (_workshopNameToShortname.ContainsKey(adjTag))
                                {
                                    string shortname = _workshopNameToShortname[adjTag];

                                    if (shortname == "ammo.snowballgun")
                                        continue;

                                    HashSet<ulong> skins;
                                    if (!_skinList.TryGetValue(shortname, out skins))
                                        skins = _skinList[shortname] = new HashSet<ulong>();

                                    if (!skins.Contains(workshopid))
                                    {
                                        skins.Add(workshopid);
                                        _skinNameLookup[workshopid] = publishedFileDetails.title;
                                    }

                                    HashSet<ulong> configSkins;
                                    if (!Configuration.SkinList.TryGetValue(shortname, out configSkins))
                                        configSkins = Configuration.SkinList[shortname] = new HashSet<ulong>();

                                    if (!configSkins.Contains(workshopid))
                                    {
                                        hasChanged = true;
                                        configSkins.Add(workshopid);
                                    }

                                    if (!string.IsNullOrEmpty(perm) && !Configuration.Permission.Custom[perm].Contains(workshopid))
                                    {
                                        hasChanged = true;
                                        Configuration.Permission.Custom[perm].Add(workshopid);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            yield return CoroutineEx.waitForEndOfFrame;
            yield return CoroutineEx.waitForEndOfFrame;

            if (hasChanged)
                SaveConfig();

            if (page < totalPages)
                SendWorkshopQuery(page);
            else
            {
                if (!_skinsLoaded)
                {
                    _skinsLoaded = true;
                    Interface.Oxide.CallHook("OnSkinBoxSkinsLoaded", _skinList);
                    Debug.Log($"[SkinBox] - SkinBox has loaded all required skins and is ready to use! ({_skinList.Values.Sum(x => x.Count)} skins acrosss {_skinList.Count} items)");
                }
                else SendResponse("New skins have been added!", arg);
            }
        }

        private IEnumerator ProcessCollectionRequest(int code, string response, bool add, ConsoleSystem.Arg arg, string perm)
        {
            if (response != null && code == 200)
            {
                SendResponse("Processing collection response", arg);

                CollectionQueryResponse collectionQuery = JsonConvert.DeserializeObject<CollectionQueryResponse>(response);
                if (collectionQuery == null || !(collectionQuery is CollectionQueryResponse))
                {
                    SendResponse("Failed to receive a valid workshop collection response", arg);
                    yield break;
                }

                if (collectionQuery.response.resultcount == 0 || collectionQuery.response.collectiondetails == null ||
                    collectionQuery.response.collectiondetails.Length == 0 || collectionQuery.response.collectiondetails[0].result != 1)
                {
                    SendResponse("Failed to receive a valid workshop collection response", arg);
                    yield break;
                }

                _skinsToVerify.Clear();

                foreach (CollectionChild child in collectionQuery.response.collectiondetails[0].children)
                {
                    try
                    {
                        _skinsToVerify.Add(Convert.ToUInt64(child.publishedfileid));
                    }
                    catch { }
                }

                if (_skinsToVerify.Count == 0)
                {
                    SendResponse("No valid skin ID's in the specified collection", arg);
                    yield break;
                }

                if (add)
                    SendWorkshopQuery(0, arg, perm);
                else RemoveSkins(arg, perm);
            }
            else SendResponse($"[SkinBox] Collection response failed. Error code {code}", arg);
        }

        private void RemoveSkins(ConsoleSystem.Arg arg, string perm = null)
        {
            int removedCount = 0;
            for (int y = _skinList.Count - 1; y >= 0; y--)
            {
                KeyValuePair<string, HashSet<ulong>> skin = _skinList.ElementAt(y);

                for (int i = 0; i < _skinsToVerify.Count; i++)
                {
                    ulong skinId = _skinsToVerify[i];
                    if (skin.Value.Contains(skinId))
                    {
                        skin.Value.Remove(skinId);
                        Configuration.SkinList[skin.Key].Remove(skinId);
                        removedCount++;

                        if (!string.IsNullOrEmpty(perm))
                            Configuration.Permission.Custom[perm].Remove(skinId);
                    }
                }

            }

            if (removedCount > 0)
                SaveConfig();

            SendReply(arg, $"[SkinBox] - Removed {removedCount} skins");
        }

        private void SendResponse(string message, ConsoleSystem.Arg arg)
        {
            if (arg != null)
                SendReply(arg, message);
            else Debug.Log($"[PlayerSkins] - {message}");
        }
        #endregion

        #region Workshop Name Conversions
        private Dictionary<string, string> _workshopNameToShortname = new Dictionary<string, string>
        {
            {"longtshirt", "tshirt.long" },
            {"cap", "hat.cap" },
            {"beenie", "hat.beenie" },
            {"boonie", "hat.boonie" },
            {"balaclava", "mask.balaclava" },
            {"pipeshotgun", "shotgun.waterpipe" },
            {"woodstorage", "box.wooden" },
            {"ak47", "rifle.ak" },
            {"bearrug", "rug.bear" },
            {"boltrifle", "rifle.bolt" },
            {"bandana", "mask.bandana" },
            {"hideshirt", "attire.hide.vest" },
            {"snowjacket", "jacket.snow" },
            {"buckethat", "bucket.helmet" },
            {"semiautopistol", "pistol.semiauto" },            
            {"roadsignvest", "roadsign.jacket" },
            {"roadsignpants", "roadsign.kilt" },
            {"burlappants", "burlap.trousers" },
            {"collaredshirt", "shirt.collared" },
            {"mp5", "smg.mp5" },
            {"sword", "salvaged.sword" },
            {"workboots", "shoes.boots" },
            {"vagabondjacket", "jacket" },
            {"hideshoes", "attire.hide.boots" },
            {"deerskullmask", "deer.skull.mask" },
            {"minerhat", "hat.miner" },
            {"lr300", "rifle.lr300" },
            {"lr300.item", "rifle.lr300" },
            {"burlapgloves", "burlap.gloves" },
            {"burlap.gloves", "burlap.gloves"},
            {"leather.gloves", "burlap.gloves"},
            {"python", "pistol.python" },
            {"m39", "rifle.m39" },
            {"woodendoubledoor", "door.double.hinged.wood" }
        };

        private void UpdateWorkshopNameConversionList()
        {
            foreach (ItemDefinition item in ItemManager.itemList)
            {
                _shortnameToDisplayname[item.shortname] = item.displayName.english;

                string workshopName = item.displayName.english.ToLower().Replace("skin", "").Replace(" ", "").Replace("-", "");
                
                _workshopNameToShortname[workshopName] = item.shortname;
                _workshopNameToShortname[item.shortname] = item.shortname;
                _workshopNameToShortname[item.shortname.Replace(".", "")] = item.shortname;
            }

            foreach (Skinnable skin in Skinnable.All.ToList())
            {
                if (string.IsNullOrEmpty(skin.Name) || string.IsNullOrEmpty(skin.ItemName))
                    continue;

                _workshopNameToShortname[skin.Name.ToLower()] = skin.ItemName.ToLower();                
            }
        }
        #endregion

        #region Item Skin Redirects
        private Hash<string, string> _itemSkinRedirects = new Hash<string, string>();

        private void FindItemRedirects()
        {            
            bool addApprovedPermission = Configuration.Permission.Approved != Configuration.Permission.Use;

            foreach (ItemSkinDirectory.Skin skin in ItemSkinDirectory.Instance.skins)
            {
                ItemSkin itemSkin = skin.invItem as ItemSkin;
                if (itemSkin == null || itemSkin.Redirect == null)                
                    continue;

                _itemSkinRedirects[itemSkin.Redirect.shortname] = itemSkin.itemDefinition.shortname;

                if (Configuration.Skins.UseRedirected)
                {
                    HashSet<ulong> skins;
                    if (!_skinList.TryGetValue(itemSkin.itemDefinition.shortname, out skins))
                        skins = _skinList[itemSkin.itemDefinition.shortname] = new HashSet<ulong>();

                    skins.Add((ulong)skin.id);

                    if (addApprovedPermission)
                        _skinPermissions[(ulong)skin.id] = Configuration.Permission.Approved;
                }
            }
        }

        private string GetRedirectedShortname(string shortname)
        {
            string redirectedName;

            if (_itemSkinRedirects.TryGetValue(shortname, out redirectedName))
                return redirectedName;

            return shortname;
        }
        #endregion

        #region SkinBox Component
        private class LootHandler : MonoBehaviour
        {
            internal StorageContainer Entity { get; private set; }

            internal BasePlayer Looter { get; set; }


            internal bool HasItem { get; private set; }

            internal int InputAmount => inputItem?.amount ?? 0;


            private InputItem inputItem;

            private int _currentPage = 0;

            private int _maximumPages = 0;

            private int _itemsPerPage;

            private List<ulong> _availableSkins;


            private void Awake()
            {
                _availableSkins = Facepunch.Pool.GetList<ulong>();

                Entity = GetComponent<StorageContainer>();

                if (!Configuration.Other.AllowStacks)
                {
                    Entity.maxStackSize = 1;
                    Entity.inventory.maxStackSize = 1;
                }

                Entity.inventory.capacity = 1;

                Entity.SetFlag(BaseEntity.Flags.Open, true, false);
            }

            private void OnDestroy()
            {
                CuiHelper.DestroyUi(Looter, UI_PANEL);

                Instance?._activeSkinBoxes?.Remove(Looter.userID);

                if (HasItem && inputItem != null)
                    Looter.GiveItem(inputItem.Create(), BaseEntity.GiveItemReason.PickedUp);

                Facepunch.Pool.FreeList(ref _availableSkins);

                if (Entity != null && !Entity.IsDestroyed)
                {
                    if (Entity.inventory.itemList.Count > 0)
                        ClearContainer();

                    Entity.Kill(BaseNetworkable.DestroyMode.None);
                }
            }

            internal void OnItemAdded(Item item)
            {
                if (HasItem)
                    return;

                HasItem = true;

                string shortname = Instance.GetRedirectedShortname(item.info.shortname);

                Instance.GetSkinsFor(Looter, shortname, ref _availableSkins);

                _availableSkins.Remove(0UL);

                if (item.skin != 0UL)
                    _availableSkins.Remove(item.skin);

                inputItem = new InputItem(shortname, item);

                _itemsPerPage = inputItem.skin == 0UL ? 41 : 40;

                _currentPage = 0;
                _maximumPages = Mathf.Min(Configuration.Skins.MaximumPages, Mathf.CeilToInt((float)_availableSkins.Count / (float)_itemsPerPage));

                if (_currentPage > 0 || _maximumPages > 1)
                    CreateOverlay();

                RemoveItem(item);
                ClearContainer();

                StartCoroutine(FillContainer());
            }

            internal void OnItemRemoved(Item item)
            {
                if (!HasItem)
                    return;

                CuiHelper.DestroyUi(Looter, UI_PANEL);

                bool skinChanged = item.skin != 0UL && item.skin != inputItem.skin;

                inputItem.CloneTo(item);

                if (skinChanged && !Instance.ChargePlayer(Looter, inputItem.itemDefinition.category))
                {
                    item.skin = inputItem.skin;

                    if (item.GetHeldEntity() != null)
                        item.GetHeldEntity().skinID = inputItem.skin;

                    PopupMessage(string.Format(GetMessage("NotEnoughBalanceTake", Looter.userID), item.info.displayName.english, Instance.GetCostType(Looter.userID)));
                    //Instance.ChatMessage(Looter, $"NotEnoughBalanceTake{Instance._costType}", item.info.displayName.english);
                }

                item.MarkDirty();

                ClearContainer();

                Entity.inventory.capacity = 1;
                Entity.inventory.MarkDirty();

                inputItem.Dispose();
                inputItem = null;
                HasItem = false;

                if (Configuration.Cooldown.ActivateOnTake)
                    Instance.ApplyCooldown(Looter);

                if (Instance.IsOnCooldown(Looter))
                    Looter.EndLooting();
            }

            internal void ChangePage(int change)
            {
                _currentPage = Mathf.Clamp(_currentPage + change, 0, _maximumPages);

                StartCoroutine(RefillContainer());
            }

            private IEnumerator RefillContainer()
            {
                ClearContainer();

                yield return StartCoroutine(FillContainer());

                CreateOverlay();
            }

            private IEnumerator FillContainer()
            {
                Entity.inventory.capacity = Mathf.Min(_availableSkins.Count, (_currentPage + 1) * _itemsPerPage) - (_currentPage * _itemsPerPage) + (inputItem.skin == 0UL ? 1 : 2);

                CreateItem(0UL);

                if (inputItem.skin != 0UL)
                    CreateItem(inputItem.skin);

                for (int i = _currentPage * _itemsPerPage; i < Mathf.Min(_availableSkins.Count, (_currentPage + 1) * _itemsPerPage); i++)
                {
                    CreateItem(_availableSkins[i]);

                    if (i % 2 == 0)
                        yield return null;
                }
            }

            private void ClearContainer()
            {
                for (int i = Entity.inventory.itemList.Count - 1; i >= 0; i--)
                    RemoveItem(Entity.inventory.itemList[i]);
            }

            private Item CreateItem(ulong skinId)
            {
                Item item = ItemManager.Create(inputItem.itemDefinition, 1, skinId);
                item.contents?.SetFlag(ItemContainer.Flag.IsLocked, true);
                item.contents?.SetFlag(ItemContainer.Flag.NoItemInput, true);

                if (skinId != 0UL)
                    Instance._skinNameLookup.TryGetValue(skinId, out item.name);

                if (!InsertItem(item))
                    item.Remove(0f);
                else item.MarkDirty();

                return item;
            }

            private bool InsertItem(Item item)
            {
                if (Entity.inventory.itemList.Contains(item))
                    return false;

                if (Entity.inventory.IsFull())
                    return false;

                Entity.inventory.itemList.Add(item);
                item.parent = Entity.inventory;

                if (!Entity.inventory.FindPosition(item))
                    return false;

                Entity.inventory.MarkDirty();
                Entity.inventory.onItemAddedRemoved?.Invoke(item, true);

                return true;
            }

            private void RemoveItem(Item item)
            {
                if (!Entity.inventory.itemList.Contains(item))
                    return;

                Entity.inventory.onPreItemRemove?.Invoke(item);

                Entity.inventory.itemList.Remove(item);
                item.parent = null;

                Entity.inventory.MarkDirty();

                Entity.inventory.onItemAddedRemoved?.Invoke(item, false);

                item.Remove(0f);
            }

            internal void CheckItemHasSplit(Item item) => StartCoroutine(CheckItemHasSplit(item, item.amount)); // Item split dupe solution?

            private IEnumerator CheckItemHasSplit(Item item, int originalAmount)
            {
                yield return null;

                if (item != null && item.amount != originalAmount)
                {
                    int splitAmount = originalAmount - item.amount;
                    Looter.inventory.Take(null, item.info.itemid, splitAmount);
                    item.amount += splitAmount;
                }
            }

            private class InputItem
            {
                public ItemDefinition itemDefinition;
                public int amount;
                public ulong skin;

                public float condition;
                public float maxCondition;

                public int magazineContents;
                public int magazineCapacity;
                public ItemDefinition ammoType;

                public List<InputItem> contents;

                internal InputItem(string shortname, Item item)
                {
                    if (!item.info.shortname.Equals(shortname))
                        itemDefinition = ItemManager.FindItemDefinition(shortname);
                    else itemDefinition = item.info;

                    amount = item.amount;
                    skin = item.skin;

                    if (item.hasCondition)
                    {
                        condition = item.condition;
                        maxCondition = item.maxCondition;
                    }

                    BaseProjectile baseProjectile = item.GetHeldEntity() as BaseProjectile;
                    if (baseProjectile != null)
                    {
                        magazineContents = baseProjectile.primaryMagazine.contents;
                        magazineCapacity = baseProjectile.primaryMagazine.capacity;
                        ammoType = baseProjectile.primaryMagazine.ammoType;
                    }

                    if (item.contents?.itemList?.Count > 0)
                    {
                        contents = Facepunch.Pool.GetList<InputItem>();

                        for (int i = 0; i < item.contents.itemList.Count; i++)
                        {
                            Item content = item.contents.itemList[i];
                            contents.Add(new InputItem(content.info.shortname, content));
                        }
                    }
                }

                internal void Dispose()
                {
                    if (contents != null)
                        Facepunch.Pool.FreeList(ref contents);
                }

                internal Item Create()
                {
                    Item item = ItemManager.Create(itemDefinition, amount, skin);

                    if (item.hasCondition)
                    {
                        item.condition = condition;
                        item.maxCondition = maxCondition;
                    }

                    BaseProjectile baseProjectile = item.GetHeldEntity() as BaseProjectile;
                    if (baseProjectile != null)
                    {
                        baseProjectile.primaryMagazine.contents = magazineContents;
                        baseProjectile.primaryMagazine.capacity = magazineCapacity;
                        baseProjectile.primaryMagazine.ammoType = ammoType;
                    }

                    if (contents?.Count > 0)
                    {
                        for (int i = 0; i < contents.Count; i++)
                        {
                            InputItem content = contents[i];

                            Item attachment = ItemManager.Create(content.itemDefinition, content.amount, content.skin);
                            attachment.MoveToContainer(item.contents);
                        }
                    }

                    item.MarkDirty();
                    return item;
                }

                internal void CloneTo(Item item)
                {
                    item.contents?.SetFlag(ItemContainer.Flag.IsLocked, false);
                    item.contents?.SetFlag(ItemContainer.Flag.NoItemInput, false);

                    item.amount = amount;

                    if (item.hasCondition)
                    {
                        item.condition = condition;
                        item.maxCondition = maxCondition;
                    }

                    BaseProjectile baseProjectile = item.GetHeldEntity() as BaseProjectile;
                    if (baseProjectile != null && baseProjectile.primaryMagazine != null)
                    {
                        baseProjectile.primaryMagazine.contents = magazineContents;
                        baseProjectile.primaryMagazine.capacity = magazineCapacity;
                        baseProjectile.primaryMagazine.ammoType = ammoType;
                    }

                    if (contents?.Count > 0)
                    {
                        for (int i = 0; i < contents.Count; i++)
                        {
                            InputItem content = contents[i];

                            Item attachment = ItemManager.Create(content.itemDefinition, content.amount, content.skin);
                            attachment.MoveToContainer(item.contents);
                        }
                    }

                    item.MarkDirty();
                }
            }

            #region UI
            private const string UI_PANEL = "SkinBox_UI";
            private const string UI_POPUP = "SkinBox_Popup";

            private const string PAGE_COLOR = "0.65 0.65 0.65 0.06";
            private const string PAGE_TEXT_COLOR = "0.7 0.7 0.7 1.0";
            private const string BUTTON_COLOR = "0.75 0.75 0.75 0.1";
            private const string BUTTON_TEXT_COLOR = "0.77 0.68 0.68 1";

            private readonly UI4 Popup = new UI4(0.65f, 0.8f, 0.99f, 0.99f);
            private readonly UI4 Container = new UI4(0.9505f, 0.15f, 0.99f, 0.6f);
            private readonly UI4 BackButton = new UI4(0f, 0.7f, 1f, 1f);
            private readonly UI4 Text = new UI4(0f, 0.3f, 1f, 0.7f);
            private readonly UI4 NextButton = new UI4(0f, 0f, 1f, 0.3f);

            private void CreateOverlay()
            {
                CuiElementContainer container = UI.Container(UI_PANEL, Container);

                UI.Button(container, UI_PANEL, BUTTON_COLOR, "◀", BUTTON_TEXT_COLOR, 50, BackButton, _currentPage > 0 ? "skinbox.pageprev" : "");

                UI.Panel(container, UI_PANEL, PAGE_COLOR, Text);
                UI.Label(container, UI_PANEL, $"{_currentPage + 1}\nof\n{_maximumPages}", PAGE_TEXT_COLOR, 20, Text);

                UI.Button(container, UI_PANEL, BUTTON_COLOR, "▶", BUTTON_TEXT_COLOR, 50, NextButton, (_currentPage + 1) < _maximumPages ? "skinbox.pagenext" : "");

                CuiHelper.DestroyUi(Looter, UI_PANEL);
                CuiHelper.AddUi(Looter, container);
            }

            internal void PopupMessage(string message)
            {
                CuiElementContainer container = UI.Container(UI_POPUP, Popup);
             
                UI.Label(container, UI_POPUP, message, BUTTON_TEXT_COLOR, 15, UI4.Full, TextAnchor.UpperRight);

                CuiHelper.DestroyUi(Looter, UI_POPUP);
                CuiHelper.AddUi(Looter, container);

                Looter.Invoke(() => CuiHelper.DestroyUi(Looter, UI_POPUP), 5f);
            }
            #endregion
        }
        #endregion

        #region UI
        public static class UI
        {
            public static CuiElementContainer Container(string panel, UI4 dimensions, string parent = "Hud.Menu")
            {
                CuiElementContainer container = new CuiElementContainer()
                {
                    {
                        new CuiPanel { Image = { Color = "0 0 0 0" }, RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() } },
                        new CuiElement().Parent = parent,
                        panel
                    }
                };
                return container;
            }

            public static void Panel(CuiElementContainer container, string panel, string color, UI4 dimensions)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() },
                },
                panel);
            }

            public static void Label(CuiElementContainer container, string panel, string text, string color, int size, UI4 dimensions, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { FontSize = size, Color = color, Align = align, Text = text },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() }
                },
                panel);

            }

            public static void Button(CuiElementContainer container, string panel, string color, string text, string textColor, int size, UI4 dimensions, string command, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() },
                    Text = { Text = text, Color = textColor, FontSize = size, Align = align }
                },
                panel);
            }            
        }
        public class UI4
        {
            public float xMin, yMin, xMax, yMax;

            public static UI4 Full { get; private set; } = new UI4(0f, 0f, 1f, 1f);

            public UI4(float xMin, float yMin, float xMax, float yMax)
            {
                this.xMin = xMin;
                this.yMin = yMin;
                this.xMax = xMax;
                this.yMax = yMax;
            }
            public string GetMin() => $"{xMin} {yMin}";
            public string GetMax() => $"{xMax} {yMax}";
        }
        #endregion

        #region UI Command
        [ConsoleCommand("skinbox.pagenext")]
        private void cmdPageNext(ConsoleSystem.Arg arg)
        {
            if (arg == null || arg.Connection == null)
                return;

            BasePlayer player = arg.Connection?.player as BasePlayer;
            if (player == null)
                return;

            LootHandler lootHandler;
            if (_activeSkinBoxes.TryGetValue(player.userID, out lootHandler))
                lootHandler.ChangePage(1);            
        }

        [ConsoleCommand("skinbox.pageprev")]
        private void cmdPagePrev(ConsoleSystem.Arg arg)
        {
            if (arg == null || arg.Connection == null)
                return;

            BasePlayer player = arg.Connection?.player as BasePlayer;
            if (player == null)
                return;

            LootHandler lootHandler;
            if (_activeSkinBoxes.TryGetValue(player.userID, out lootHandler))
                lootHandler.ChangePage(-1);
        }
        #endregion

        #region Chat Commands        
        private void cmdSkinBox(BasePlayer player, string command, string[] args)
        {            
            if (_apiKeyMissing)
            {
                SendAPIMissingWarning();
                ChatMessage(player, "NoAPIKey");
                return;
            }

            if (!_skinsLoaded)
            {
                ChatMessage(player, "SkinsLoading");
                return;
            }

            if (player.inventory.loot.IsLooting())
                return;

            if (!player.IsAdmin && !permission.UserHasPermission(player.UserIDString, Configuration.Permission.Use))
            {
                ChatMessage(player, "NoPermission");
                return;
            }

            double cooldownRemaining;
            if (IsOnCooldown(player, out cooldownRemaining))
            {
                ChatMessage(player, "CooldownTime", Mathf.RoundToInt((float)cooldownRemaining));
                return;
            }

            if (!ChargePlayer(player, Configuration.Cost.Open))
            {
                ChatMessage(player, "NotEnoughBalanceOpen", Configuration.Cost.Open, GetCostType(player.userID));
                return;
            }

            timer.In(0.2f, () => CreateSkinBox(player));
        }
        #endregion

        #region Console Commands
        [ConsoleCommand("skinbox.cmds")]
        private void cmdListCmds(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && !permission.UserHasPermission(arg.Connection.userid.ToString(), Configuration.Permission.Admin))
                return;

            StringBuilder sb = new StringBuilder();
            sb.AppendLine("\n> SkinBox command overview <");

            TextTable textTable = new TextTable();
            textTable.AddColumn("Command");
            textTable.AddColumn("Description");
            textTable.AddRow(new string[] { "skinbox.addskin", "Add one or more skin-id's to the workshop skin list" });
            textTable.AddRow(new string[] { "skinbox.removeskin", "Remove one or more skin-id's from the workshop skin list" });
            textTable.AddRow(new string[] { "skinbox.addvipskin", "Add one or more skin-id's to the workshop skin list for the specified permission" });
            textTable.AddRow(new string[] { "skinbox.removevipskin", "Remove one or more skin-id's from the workshop skin list for the specified permission" });
            textTable.AddRow(new string[] { "skinbox.addexcluded", "Add one or more skin-id's to the exclusion list (for players)" });
            textTable.AddRow(new string[] { "skinbox.removeexcluded", "Remove one or more skin-id's from the exclusion list" });
            textTable.AddRow(new string[] { "skinbox.addcollection", "Adds a whole skin-collection to the workshop skin list"});
            textTable.AddRow(new string[] { "skinbox.removecollection", "Removes a whole collection from the workshop skin list" });
            textTable.AddRow(new string[] { "skinbox.addvipcollection", "Adds a whole skin-collection to the workshop skin list for the specified permission" });
            textTable.AddRow(new string[] { "skinbox.removevipcollection", "Removes a whole collection from the workshop skin list for the specified permission" });

            sb.AppendLine(textTable.ToString());
            SendReply(arg, sb.ToString());
        }

        #region Add/Remove Skins
        [ConsoleCommand("skinbox.addskin")]
        private void consoleAddSkin(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && !permission.UserHasPermission(arg.Connection.userid.ToString(), Configuration.Permission.Admin))
            {
                SendReply(arg, "You do not have permission to use this command");
                return;
            }

            if (!_skinsLoaded)
            {
                SendReply(arg, "SkinBox is still loading skins. Please wait");
                return;
            }

            if (arg.Args == null || arg.Args.Length < 1)
            {
                SendReply(arg, "You need to type in one or more workshop skin ID's");
                return;
            }

            _skinsToVerify.Clear();

            for (int i = 0; i < arg.Args.Length; i++)
            {
                ulong fileId = 0uL;
                if (!ulong.TryParse(arg.Args[i], out fileId))
                {
                    SendReply(arg, $"Ignored '{arg.Args[i]}' as it's not a number");
                    continue;
                }
                else
                {
                    if (arg.Args[i].Length < 9 || arg.Args[i].Length > 10)
                    {
                        SendReply(arg, $"Ignored '{arg.Args[i]}' as it is not the correct length (9 - 10 digits)");
                        continue;
                    }

                    _skinsToVerify.Add(fileId);
                }
            }

            if (_skinsToVerify.Count > 0)
                SendWorkshopQuery(0, arg);
            else SendReply(arg, "No valid skin ID's were entered");
        }

        [ConsoleCommand("skinbox.removeskin")]
        private void consoleRemoveSkin(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && !permission.UserHasPermission(arg.Connection.userid.ToString(), Configuration.Permission.Admin))
            {
                SendReply(arg, "You do not have permission to use this command");
                return;
            }

            if (!_skinsLoaded)
            {
                SendReply(arg, "SkinBox is still loading skins. Please wait");
                return;
            }

            if (arg.Args == null || arg.Args.Length < 1)
            {
                SendReply(arg, "You need to type in one or more workshop skin ID's");
                return;
            }

            _skinsToVerify.Clear();

            for (int i = 0; i < arg.Args.Length; i++)
            {
                ulong fileId = 0uL;
                if (!ulong.TryParse(arg.Args[i], out fileId))
                {
                    SendReply(arg, $"Ignored '{arg.Args[i]}' as it's not a number");
                    continue;
                }
                else
                {
                    if (arg.Args[i].Length < 9 || arg.Args[i].Length > 10)
                    {
                        SendReply(arg, $"Ignored '{arg.Args[i]}' as it is not the correct length (9 - 10 digits)");
                        continue;
                    }

                    _skinsToVerify.Add(fileId);
                }
            }

            if (_skinsToVerify.Count > 0)
                RemoveSkins(arg);
            else SendReply(arg, "No valid skin ID's were entered");
        }

        [ConsoleCommand("skinbox.addvipskin")]
        private void consoleAddVIPSkin(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && !permission.UserHasPermission(arg.Connection.userid.ToString(), Configuration.Permission.Admin))
            {
                SendReply(arg, "You do not have permission to use this command");
                return;
            }

            if (!_skinsLoaded)
            {
                SendReply(arg, "SkinBox is still loading skins. Please wait");
                return;
            }

            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "You need to type in a permission and one or more workshop skin ID's");
                return;
            }

            string perm = arg.Args[0];
            if (!Configuration.Permission.Custom.ContainsKey(perm))
            {
                SendReply(arg, $"The permission {perm} does not exist in the custom permission section of the config");
                return;
            }

            _skinsToVerify.Clear();
            
            for (int i = 1; i < arg.Args.Length; i++)
            {
                ulong fileId = 0uL;
                if (!ulong.TryParse(arg.Args[i], out fileId))
                {
                    SendReply(arg, $"Ignored '{arg.Args[i]}' as it's not a number");
                    continue;
                }
                else
                {
                    if (arg.Args[i].Length < 9 || arg.Args[i].Length > 10)
                    {
                        SendReply(arg, $"Ignored '{arg.Args[i]}' as it is not the correct length (9 - 10 digits)");
                        continue;
                    }

                    _skinsToVerify.Add(fileId);
                }
            }

            if (_skinsToVerify.Count > 0)
                SendWorkshopQuery(0, arg, perm);
            else SendReply(arg, "No valid skin ID's were entered");
        }

        [ConsoleCommand("skinbox.removevipskin")]
        private void consoleRemoveVIPSkin(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && !permission.UserHasPermission(arg.Connection.userid.ToString(), Configuration.Permission.Admin))
            {
                SendReply(arg, "You do not have permission to use this command");
                return;
            }

            if (!_skinsLoaded)
            {
                SendReply(arg, "SkinBox is still loading skins. Please wait");
                return;
            }

            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "You need to type in a permission and one or more workshop skin ID's");
                return;
            }

            string perm = arg.Args[0];
            if (!Configuration.Permission.Custom.ContainsKey(perm))
            {
                SendReply(arg, $"The permission {perm} does not exist in the custom permission section of the config");
                return;
            }

            _skinsToVerify.Clear();

            for (int i = 1; i < arg.Args.Length; i++)
            {
                ulong fileId = 0uL;
                if (!ulong.TryParse(arg.Args[i], out fileId))
                {
                    SendReply(arg, $"Ignored '{arg.Args[i]}' as it's not a number");
                    continue;
                }
                else
                {
                    if (arg.Args[i].Length < 9 || arg.Args[i].Length > 10)
                    {
                        SendReply(arg, $"Ignored '{arg.Args[i]}' as it is not the correct length (9 - 10 digits)");
                        continue;
                    }

                    _skinsToVerify.Add(fileId);
                }
            }

            if (_skinsToVerify.Count > 0)
                RemoveSkins(arg, perm);
            else SendReply(arg, "No valid skin ID's were entered");
        }
        #endregion

        #region Add/Remove Collections
        [ConsoleCommand("skinbox.addcollection")]
        private void consoleAddCollection(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && !permission.UserHasPermission(arg.Connection.userid.ToString(), Configuration.Permission.Admin))
            {
                SendReply(arg, "You do not have permission to use this command");
                return;
            }

            if (!_skinsLoaded)
            {
                SendReply(arg, "SkinBox is still loading skins. Please wait");
                return;
            }

            if (arg.Args == null || arg.Args.Length < 1)
            {
                SendReply(arg, "You need to type in a skin collection ID");
                return;
            }

            ulong collectionId = 0uL;
            if (!ulong.TryParse(arg.Args[0], out collectionId))
            {
                SendReply(arg, $"{arg.Args[0]} is an invalid collection ID");
                return;
            }

            SendWorkshopCollectionQuery(collectionId, true, arg);
        }

        [ConsoleCommand("skinbox.removecollection")]
        private void consoleRemoveCollection(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && !permission.UserHasPermission(arg.Connection.userid.ToString(), Configuration.Permission.Admin))
            {
                SendReply(arg, "You do not have permission to use this command");
                return;
            }

            if (!_skinsLoaded)
            {
                SendReply(arg, "SkinBox is still loading skins. Please wait");
                return;
            }

            if (arg.Args == null || arg.Args.Length < 1)
            {
                SendReply(arg, "You need to type in a skin collection ID");
                return;
            }

            ulong collectionId = 0uL;
            if (!ulong.TryParse(arg.Args[0], out collectionId))
            {
                SendReply(arg, $"{arg.Args[0]} is an invalid collection ID");
                return;
            }

            SendWorkshopCollectionQuery(collectionId, false, arg);
        }

        [ConsoleCommand("skinbox.addvipcollection")]
        private void consoleAddVIPCollection(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && !permission.UserHasPermission(arg.Connection.userid.ToString(), Configuration.Permission.Admin))
            {
                SendReply(arg, "You do not have permission to use this command");
                return;
            }

            if (!_skinsLoaded)
            {
                SendReply(arg, "SkinBox is still loading skins. Please wait");
                return;
            }

            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "You need to type in a permission and one or more workshop skin ID's");
                return;
            }

            string perm = arg.Args[0];
            if (!Configuration.Permission.Custom.ContainsKey(perm))
            {
                SendReply(arg, $"The permission {perm} does not exist in the custom permission section of the config");
                return;
            }

            ulong collectionId = 0uL;
            if (!ulong.TryParse(arg.Args[1], out collectionId))
            {
                SendReply(arg, $"{arg.Args[1]} is an invalid collection ID");
                return;
            }

            SendWorkshopCollectionQuery(collectionId, true, arg, perm);
        }

        [ConsoleCommand("skinbox.removevipcollection")]
        private void consoleRemoveVIPCollection(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && !permission.UserHasPermission(arg.Connection.userid.ToString(), Configuration.Permission.Admin))
            {
                SendReply(arg, "You do not have permission to use this command");
                return;
            }

            if (!_skinsLoaded)
            {
                SendReply(arg, "SkinBox is still loading skins. Please wait");
                return;
            }

            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "You need to type in a permission and one or more workshop skin ID's");
                return;
            }

            string perm = arg.Args[0];
            if (!Configuration.Permission.Custom.ContainsKey(perm))
            {
                SendReply(arg, $"The permission {perm} does not exist in the custom permission section of the config");
                return;
            }

            ulong collectionId = 0uL;
            if (!ulong.TryParse(arg.Args[1], out collectionId))
            {
                SendReply(arg, $"{arg.Args[1]} is an invalid collection ID");
                return;
            }

            SendWorkshopCollectionQuery(collectionId, false, arg, perm);
        }
        #endregion

        #region Blacklisted Skins
        [ConsoleCommand("skinbox.addexcluded")]
        private void consoleAddExcluded(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && !permission.UserHasPermission(arg.Connection.userid.ToString(), Configuration.Permission.Admin))
            {
                SendReply(arg, "You do not have permission to use this command");
                return;
            }

            if (!_skinsLoaded)
            {
                SendReply(arg, "SkinBox is still loading skins. Please wait");
                return;
            }

            if (arg.Args == null || arg.Args.Length < 1)
            {
                SendReply(arg, "You need to type in one or more skin ID's");
                return;
            }

            int count = 0;

            for (int i = 0; i < arg.Args.Length; i++)
            {
                ulong skinId = 0uL;
                if (!ulong.TryParse(arg.Args[i], out skinId))
                {
                    SendReply(arg, $"Ignored '{arg.Args[i]}' as it's not a number");
                    continue;
                }
                else
                {
                    Configuration.Blacklist.Add(skinId);
                    count++;
                }
            }

            if (count > 0)
            {
                SaveConfig();
                SendReply(arg, $"Blacklisted {count} skin ID's");
            }
            else SendReply(arg, "No skin ID's were added to the blacklist");
        }

        [ConsoleCommand("skinbox.removeexcluded")]
        private void consoleRemoveExcluded(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && !permission.UserHasPermission(arg.Connection.userid.ToString(), Configuration.Permission.Admin))
            {
                SendReply(arg, "You do not have permission to use this command");
                return;
            }

            if (!_skinsLoaded)
            {
                SendReply(arg, "SkinBox is still loading skins. Please wait");
                return;
            }

            if (arg.Args == null || arg.Args.Length < 1)
            {
                SendReply(arg, "You need to type in one or more skin ID's");
                return;
            }

            int count = 0;

            for (int i = 0; i < arg.Args.Length; i++)
            {
                ulong skinId = 0uL;
                if (!ulong.TryParse(arg.Args[i], out skinId))
                {
                    SendReply(arg, $"Ignored '{arg.Args[i]}' as it's not a number");
                    continue;
                }
                else
                {
                    if (Configuration.Blacklist.Contains(skinId))
                    {
                        Configuration.Blacklist.Remove(skinId);
                        SendReply(arg, $"The skin ID {skinId} is not on the blacklist");
                        count++;
                    }
                }
            }

            if (count > 0)
            {
                SaveConfig();
                SendReply(arg, $"Removed {count} skin ID's from the blacklist");
            }
            else SendReply(arg, "No skin ID's were removed from the blacklist");
        }
        #endregion

        [ConsoleCommand("skinbox.open")]
        private void consoleSkinboxOpen(ConsoleSystem.Arg arg)
        {
            if (arg == null)
                return;

            if (!_skinsLoaded)
            {
                SendReply(arg, "SkinBox is still loading skins. Please wait");
                return;
            }

            if (arg.Connection == null)
            {
                if (arg.Args == null || arg.Args.Length == 0)
                {
                    SendReply(arg, "This command requires a Steam ID of the target user");
                    return;
                }

                ulong targetUserID = 0uL;
                if (!ulong.TryParse(arg.Args[0], out targetUserID) || !Oxide.Core.ExtensionMethods.IsSteamId(targetUserID))
                {
                    SendReply(arg, "Invalid Steam ID entered");
                    return;
                }

                BasePlayer targetPlayer = BasePlayer.FindByID(targetUserID);
                if (targetPlayer == null || !targetPlayer.IsConnected)
                {
                    SendReply(arg, $"Unable to find a player with the specified Steam ID");
                    return;
                }

                if (targetPlayer.IsDead())
                {
                    SendReply(arg, $"The specified player is currently dead");
                    return;
                }

                if (!targetPlayer.inventory.loot.IsLooting())
                    CreateSkinBox(targetPlayer);
            }
            else if (arg.Connection != null && arg.Connection.player != null)
            {
                BasePlayer player = arg.Player();

                cmdSkinBox(player, string.Empty, Array.Empty<string>());
            }
        }
        #endregion

        #region API
        private bool IsSkinBoxPlayer(ulong playerId) => _activeSkinBoxes.ContainsKey(playerId);
        #endregion

        #region Config        
        private static ConfigData Configuration;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Skin Options")]
            public SkinOptions Skins { get; set; }

            [JsonProperty(PropertyName = "Cooldown Options")]
            public CooldownOptions Cooldown { get; set; }

            [JsonProperty(PropertyName = "Command Options")]
            public CommandOptions Command { get; set; }

            [JsonProperty(PropertyName = "Permission Options")]
            public PermissionOptions Permission { get; set; }

            [JsonProperty(PropertyName = "Usage Cost Options")]
            public CostOptions Cost { get; set; }

            [JsonProperty(PropertyName = "Other Options")]
            public OtherOptions Other { get; set; }

            [JsonProperty(PropertyName = "Imported Workshop Skins")]
            public Hash<string, HashSet<ulong>> SkinList { get; set; }

            [JsonProperty(PropertyName = "Blacklisted Skin ID's")]
            public HashSet<ulong> Blacklist { get; set; }

            public class SkinOptions
            {
                [JsonProperty(PropertyName = "Maximum number of approved skins allowed for each item (-1 is unlimited)")]
                public int ApprovedLimit { get; set; }

                [JsonProperty(PropertyName = "Maximum number of pages viewable")]
                public int MaximumPages { get; set; }

                [JsonProperty(PropertyName = "Include approved skins")]
                public bool UseApproved { get; set; }

                [JsonProperty(PropertyName = "Include manually imported workshop skins")]
                public bool UseWorkshop { get; set; }

                [JsonProperty(PropertyName = "Remove approved skin ID's from config workshop skin list")]
                public bool RemoveApproved { get; set; }

                [JsonProperty(PropertyName = "Include redirected skins")]
                public bool UseRedirected { get; set; }

                [JsonProperty(PropertyName = "Steam API key for workshop skins (https://steamcommunity.com/dev/apikey)")]
                public string APIKey { get; set; }
            }

            public class CooldownOptions
            {
                [JsonProperty(PropertyName = "Enable cooldowns")]
                public bool Enabled { get; set; }

                [JsonProperty(PropertyName = "Cooldown time start's when a item is removed from the box")]
                public bool ActivateOnTake { get; set; }

                [JsonProperty(PropertyName = "Length of cooldown time (seconds)")]
                public int Time { get; set; }
            }

            public class PermissionOptions
            {
                [JsonProperty(PropertyName = "Permission required to use SkinBox")]
                public string Use { get; set; }

                [JsonProperty(PropertyName = "Permission required to use admin functions")]
                public string Admin { get; set; }

                [JsonProperty(PropertyName = "Permission that bypasses usage costs")]
                public string NoCost { get; set; }

                [JsonProperty(PropertyName = "Permission that bypasses usage cooldown")]
                public string NoCooldown { get; set; }

                [JsonProperty(PropertyName = "Permission required to skin weapons")]
                public string Weapon { get; set; }

                [JsonProperty(PropertyName = "Permission required to skin deployables")]
                public string Deployable { get; set; }

                [JsonProperty(PropertyName = "Permission required to skin attire")]
                public string Attire { get; set; }

                [JsonProperty(PropertyName = "Permission required to view approved skins")]
                public string Approved { get; set; }

                [JsonProperty(PropertyName = "Custom permissions per skin")]
                public Hash<string, List<ulong>> Custom { get; set; }

                public void RegisterPermissions(Permission permission, Plugin plugin)
                {
                    permission.RegisterPermission(Use, plugin);
                    permission.RegisterPermission(Admin, plugin);
                    permission.RegisterPermission(NoCost, plugin);
                    permission.RegisterPermission(NoCooldown, plugin);

                    if (!permission.PermissionExists(Weapon, plugin))
                        permission.RegisterPermission(Weapon, plugin);

                    if (!permission.PermissionExists(Deployable, plugin))
                        permission.RegisterPermission(Deployable, plugin);

                    if (!permission.PermissionExists(Attire, plugin))
                        permission.RegisterPermission(Attire, plugin);

                    if (!permission.PermissionExists(Approved, plugin))
                        permission.RegisterPermission(Approved, plugin);

                    foreach (string perm in Custom.Keys)
                    {
                        if (!permission.PermissionExists(perm, plugin))
                            permission.RegisterPermission(perm, plugin);
                    }
                }

                public void ReverseCustomSkinPermissions(ref Hash<ulong, string> list)
                {
                    foreach (KeyValuePair<string, List<ulong>> kvp in Custom)
                    {
                        for (int i = 0; i < kvp.Value.Count; i++)
                        {
                            list[kvp.Value[i]] = kvp.Key;
                        }
                    }
                }
            }

            public class CommandOptions
            {
                [JsonProperty(PropertyName = "Commands to open the SkinBox")]
                public string[] Commands { get; set; }

                internal void RegisterCommands(Game.Rust.Libraries.Command cmd, Plugin plugin)
                {
                    for (int i = 0; i < Commands.Length; i++)                    
                        cmd.AddChatCommand(Commands[i], plugin, "cmdSkinBox");                    
                }
            }

            public class CostOptions
            {
                [JsonProperty(PropertyName = "Enable usage costs")]
                public bool Enabled { get; set; }

                [JsonProperty(PropertyName = "Currency used for usage costs (Scrap, Economics, ServerRewards)")]
                public string Currency { get; set; }

                [JsonProperty(PropertyName = "Cost to open the SkinBox")]
                public int Open { get; set; }

                [JsonProperty(PropertyName = "Cost to skin deployables")]
                public int Deployable { get; set; }

                [JsonProperty(PropertyName = "Cost to skin attire")]
                public int Attire { get; set; }

                [JsonProperty(PropertyName = "Cost to skin weapons")]
                public int Weapon { get; set; }
            }  
            
            public class OtherOptions
            {
                [JsonProperty(PropertyName = "Allow stacked items")]
                public bool AllowStacks { get; set; }

                [JsonProperty(PropertyName = "Auth-level required to view blacklisted skins")]
                public int BlacklistAuth { get; set; }
            }
                        
            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Configuration = Config.ReadObject<ConfigData>();

            if (Configuration.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(Configuration, true);
        }

        protected override void LoadDefaultConfig() => Configuration = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                Skins = new ConfigData.SkinOptions
                {
                    APIKey = string.Empty,
                    ApprovedLimit = -1,
                    MaximumPages = 3,
                    UseApproved = true,
                    RemoveApproved = false,
                    UseRedirected = true,
                    UseWorkshop = true
                },
                Command = new ConfigData.CommandOptions
                {
                    Commands = new string[] { "skinbox", "sb" }
                },
                Permission = new ConfigData.PermissionOptions
                {
                    Admin = "skinbox.admin",
                    NoCost = "skinbox.ignorecost",
                    NoCooldown = "skinbox.ignorecooldown",
                    Use = "skinbox.use",
                    Approved = "skinbox.use",
                    Attire = "skinbox.use",
                    Deployable = "skinbox.use",
                    Weapon = "skinbox.use",
                    Custom = new Hash<string, List<ulong>>
                    {
                        ["skinbox.example1"] = new List<ulong>() { 9990, 9991, 9992 },
                        ["skinbox.example2"] = new List<ulong>() { 9993, 9994, 9995 },
                        ["skinbox.example3"] = new List<ulong>() { 9996, 9997, 9998 }
                    }
                },
                Cooldown = new ConfigData.CooldownOptions
                {
                    Enabled = false,
                    ActivateOnTake = true,
                    Time = 60
                },
                Cost = new ConfigData.CostOptions
                {
                    Enabled = false,
                    Currency = "Scrap",
                    Open = 5,
                    Weapon = 30,
                    Attire = 20,
                    Deployable = 10
                },
                Other = new ConfigData.OtherOptions
                {
                    AllowStacks = false,
                    BlacklistAuth = 2,
                },
                SkinList = new Hash<string, HashSet<ulong>>(),
                Blacklist = new HashSet<ulong>(),
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(Configuration, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (Configuration.Version < new VersionNumber(2, 0, 0))
                Configuration = baseConfig;

            Configuration.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion

        #region JSON Deserialization        
        public class QueryResponse
        {
            public Response response;
        }

        public class Response
        {
            public int total;
            public PublishedFileDetails[] publishedfiledetails;
        }

        public class PublishedFileDetails
        {
            public int result;
            public string publishedfileid;
            public string creator;
            public int creator_appid;
            public int consumer_appid;
            public int consumer_shortcutid;
            public string filename;
            public string file_size;
            public string preview_file_size;
            public string file_url;
            public string preview_url;
            public string url;
            public string hcontent_file;
            public string hcontent_preview;
            public string title;
            public string file_description;
            public int time_created;
            public int time_updated;
            public int visibility;
            public int flags;
            public bool workshop_file;
            public bool workshop_accepted;
            public bool show_subscribe_all;
            public int num_comments_public;
            public bool banned;
            public string ban_reason;
            public string banner;
            public bool can_be_deleted;
            public string app_name;
            public int file_type;
            public bool can_subscribe;
            public int subscriptions;
            public int favorited;
            public int followers;
            public int lifetime_subscriptions;
            public int lifetime_favorited;
            public int lifetime_followers;
            public string lifetime_playtime;
            public string lifetime_playtime_sessions;
            public int views;
            public int num_children;
            public int num_reports;
            public Preview[] previews;
            public Tag[] tags;
            public int language;
            public bool maybe_inappropriate_sex;
            public bool maybe_inappropriate_violence;

            public class Tag
            {
                public string tag;
                public bool adminonly;
            }

        }

        public class PublishedFileQueryResponse
        {
            public FileResponse response { get; set; }
        }

        public class FileResponse
        {
            public int result { get; set; }
            public int resultcount { get; set; }
            public PublishedFileQueryDetail[] publishedfiledetails { get; set; }
        }

        public class PublishedFileQueryDetail
        {
            public string publishedfileid { get; set; }
            public int result { get; set; }
            public string creator { get; set; }
            public int creator_app_id { get; set; }
            public int consumer_app_id { get; set; }
            public string filename { get; set; }
            public int file_size { get; set; }
            public string preview_url { get; set; }
            public string hcontent_preview { get; set; }
            public string title { get; set; }
            public string description { get; set; }
            public int time_created { get; set; }
            public int time_updated { get; set; }
            public int visibility { get; set; }
            public int banned { get; set; }
            public string ban_reason { get; set; }
            public int subscriptions { get; set; }
            public int favorited { get; set; }
            public int lifetime_subscriptions { get; set; }
            public int lifetime_favorited { get; set; }
            public int views { get; set; }
            public Tag[] tags { get; set; }

            public class Tag
            {
                public string tag { get; set; }
            }
        }

        public class Preview
        {
            public string previewid;
            public int sortorder;
            public string url;
            public int size;
            public string filename;
            public int preview_type;
            public string youtubevideoid;
            public string external_reference;
        }


        public class CollectionQueryResponse
        {
            public CollectionResponse response { get; set; }
        }

        public class CollectionResponse
        {
            public int result { get; set; }
            public int resultcount { get; set; }
            public CollectionDetails[] collectiondetails { get; set; }
        }

        public class CollectionDetails
        {
            public string publishedfileid { get; set; }
            public int result { get; set; }
            public CollectionChild[] children { get; set; }
        }

        public class CollectionChild
        {
            public string publishedfileid { get; set; }
            public int sortorder { get; set; }
            public int filetype { get; set; }
        }

        #endregion
    }
}


// --- End of file: SkinBox.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/DonateTransport-0.0.2.cs ---
// --- Original Local Path: DonateTransport-0.0.2.cs ---

﻿using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("DonateTransport", "MaltrzD", "0.0.2")]
    class DonateTransport : RustPlugin
    {
        private ConfigData _config;

        #region [ OXIDE HOOKS ]
        private void Loaded() => ReadConfig();
        private void OnEntityBuilt(Planner planner, GameObject go)
        {
            if(go.TryGetComponent(out BaseEntity entity))
            {
                Transport transport = GetTransportBySkinId(entity.skinID);
                if(transport != null)
                {
                    if(transport.CanPlaceOnlyCosntruction)
                    {
                        RaycastHit Hit;
                        if (Physics.Raycast(entity.transform.position, Vector3.down, out Hit, LayerMask.GetMask(new string[] { "Construction" })))
                        {
                            var rhEntity = Hit.GetEntity();
                            if (rhEntity != null)
                            {
                                BaseEntity entityToSpawn = GameManager.server.CreateEntity(transport.TransportPrefab, entity.transform.position, entity.transform.rotation);
                                entityToSpawn.Spawn();

                                entity.Kill();
                            }
                        }
                    }
                    else
                    {
                        Vector3 targetPos = entity.transform.position;

                        if (transport.CordPlus != 0f)
                        {
                            Vector3 entityPos = entity.transform.position;

                            Vector3 forwardDirection = -entity.transform.forward;

                            Vector3 offset = forwardDirection * transport.CordPlus;

                            targetPos = entityPos + offset;
                        }


                        BaseEntity entityToSpawn = GameManager.server.CreateEntity(
                            transport.TransportPrefab,
                            targetPos,
                            entity.transform.rotation);


                        entityToSpawn.Spawn();

                        entity.Kill();
                    }
                }
            }
        }
        #endregion

        #region [ MAIN ]
        [ConsoleCommand("dt.give")]
        private void GiveTransport_ConsoleCommand(ConsoleSystem.Arg arg)
        {
            if(arg.IsAdmin == false)
            {
                return;
            }

            ulong userID = 0;
            string transportName = string.Empty;

            try
            {
                userID = System.Convert.ToUInt64(arg.Args[0]);
                transportName = arg.Args[1];
            }
            catch
            {
                Debug.LogWarning
                    (
                    "Один из аргументов указан неверно!\n" +
                    "Синтаксис:\n" +
                    "dt.give <steamid> <transport name>"
                    );

                return;
            }

            BasePlayer player = BasePlayer.FindByID(userID);
            if(player == null)
            {
                Debug.LogWarning("Игрок с указанным SteamID не найден!");
                return;
            }

            Transport requiredTransport = GetTransportByName(transportName);
            if(requiredTransport == null)
            {
                Debug.LogWarning("Транспорт с указанным именем успешно создан!");
                return;
            }

            GiveTransport(player, requiredTransport);
        }
        private void GiveTransport(BasePlayer player, Transport transport)
        {
            Item itemToGive = ItemManager.CreateByName(transport.BuildItemShortName, 1, transport.SkinId);
            itemToGive.name = transport.DisplayName;

            player.GiveItem(itemToGive);
        }
        #endregion

        #region [ EXT ]
        private Transport GetTransportByName(string name) =>
            _config.Transports
            .Where(x => x.TransportName == name)
            .FirstOrDefault();
        private Transport GetTransportBySkinId(ulong skinId) =>
            _config.Transports
            .Where(x => x.SkinId == skinId)
            .FirstOrDefault();

        #endregion

        #region [ CONFIG ]
        class ConfigData
        {
            [JsonProperty("Настройка транспорта")]
            public List<Transport> Transports = new List<Transport>()
            {
                new Transport()
                {
                    BuildItemShortName = "box.wooden",
                    TransportName = "minicopter",
                    DisplayName = "Миникоптер",
                    TransportPrefab = "assets/content/vehicles/minicopter/minicopter.entity.prefab",
                    CanPlaceOnlyCosntruction = false,
                    SkinId = 1231230
                },
                new Transport()
                {
                    BuildItemShortName = "box.wooden",
                    TransportName = "attackhelicopter",
                    DisplayName = "Аттак хеликоптер",
                    TransportPrefab = "assets/content/vehicles/attackhelicopter/attackhelicopter.entity.prefab",
                    CanPlaceOnlyCosntruction = false,
                    SkinId = 1231231
                },
                new Transport()
                {
                    BuildItemShortName = "box.wooden",
                    TransportName = "scraphelicopter",
                    DisplayName = "Грузовой вертолет",
                    TransportPrefab = "assets/content/vehicles/scrap heli carrier/scraptransporthelicopter.prefab",
                    CanPlaceOnlyCosntruction = false,
                    SkinId = 1231232,
                    CordPlus = 5
                },
                new Transport()
                {
                    BuildItemShortName = "box.wooden",
                    TransportName = "sedantest",
                    DisplayName = "Седан",
                    TransportPrefab = "assets/content/vehicles/sedan_a/sedantest.entity.prefab",
                    CanPlaceOnlyCosntruction = false,
                    SkinId = 1231233
                },
                new Transport()
                {
                    BuildItemShortName = "research.table",
                    TransportName = "recycler",
                    DisplayName = "Переработчик",
                    TransportPrefab = "assets/bundled/prefabs/static/recycler_static.prefab",
                    CanPlaceOnlyCosntruction = true,
                    SkinId = 1231234
                },
            };
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData();
            SaveConfig(config);
        }
        void SaveConfig(object config)
        {
            Config.WriteObject(config, true);
        }
        void ReadConfig()
        {
            base.Config.Settings.ObjectCreationHandling = ObjectCreationHandling.Replace;
            _config = Config.ReadObject<ConfigData>();
            SaveConfig(_config);
        }
        #endregion
        public class Transport
        {
            [JsonProperty("Шортнейм предмета который ставить")]
            public string BuildItemShortName;

            [JsonProperty("корд плюс")]
            public float CordPlus;

            [JsonProperty("Название транспорта (для выдачи)")]
            public string TransportName;

            [JsonProperty("Отображаемое имя айтема")]
            public string DisplayName;

            [JsonProperty("Путь до префаба транспорта")]
            public string TransportPrefab;

            [JsonProperty("Ставится только на конструкцию?")]
            public bool CanPlaceOnlyCosntruction;

            [JsonProperty("Скин ид")]
            public ulong SkinId;
        }
    }
}

// --- End of file: DonateTransport-0.0.2.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RemoveDefaultRadiation.cs ---
// --- Original Local Path: RemoveDefaultRadiation.cs ---

using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("RemoveDefaultRadiation", "k1lly0u", "0.1.0", ResourceId = 0)]
    class RemoveDefaultRadiation : RustPlugin
    {        
        #region Oxide Hooks        
        void OnServerInitialized()
        {
            LoadVariables();
            var allobjects = UnityEngine.Object.FindObjectsOfType<TriggerRadiation>();
            for (int i = 0; i < allobjects.Length; i++)
            {
                UnityEngine.Object.Destroy(allobjects[i]);
            }
            if (configData.PluginList.Count > 0)
            {
                PrintWarning("All radiation elements destroyed, reloading plugins that use radiation");
                foreach (var plugin in configData.PluginList)
                {
                    if (plugins.Exists(plugin))
                    {
                        rust.RunServerCommand($"oxide.reload {plugin}");
                    }
                }
            }
        }
        #endregion

        #region Config        
        private ConfigData configData;
        class ConfigData
        {
            public List<string> PluginList { get; set; }
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                PluginList = new List<string>
                {
                    "MonumentRadiation",
                    "RadPockets",
                    "ZoneManager"
                }
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion       
    }
}


// --- End of file: RemoveDefaultRadiation.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/StrikeSystem.cs ---
// --- Original Local Path: StrikeSystem.cs ---

using System.Collections.Generic;
using Oxide.Core.Plugins;
using System.Linq;
using System;

namespace Oxide.Plugins
{
    [Info("StrikeSystem", "LaserHydra", "2.0.0", ResourceId = 1276)]
    [Description("Strike players & time-ban players with a specific amount of strikes")]
    class StrikeSystem : RustPlugin
    {
        static List<Player> players = new List<Player>();

        [PluginReference("EnhancedBanSystem")]
        Plugin EBS;

        #region Classes

        class Player
        {
            public ulong steamId = 0;
            public string name = "unkown";
            public string lastStrike = "not striked yet";
            public int strikes = 0;
            public int activeStrikes = 0;

            public Player()
            {
            }

            internal Player(BasePlayer player)
            {
                this.steamId = player.userID;
                this.name = player.displayName;
            }

            internal void Update(BasePlayer player) => this.name = player.displayName;
            
            internal static Player Get(BasePlayer player)
            {
                return players.Find((p) =>
                {
                    if (p.steamId == player.userID)
                        return true;
                    else
                        return false;
                });
            }

            public override bool Equals(object obj)
            {
                if (obj is Player && ((Player) obj).steamId == this.steamId)
                    return true;

                return false;
            }

            public override int GetHashCode() => Convert.ToInt32(steamId);
        }

        #endregion

        #region Plugin General

        ////////////////////////////////////////
        ///     Plugin Related Hooks
        ////////////////////////////////////////

        void Loaded()
        {
#if !RUST
            throw new NotSupportedException("This plugin or the version of this plugin does not support this game!");
#endif

            LoadConfig();
            LoadMessages();
            LoadData(ref players);

            RegisterPerm("admin");

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                if (Player.Get(player) == null)
                {
                    players.Add(new Player(player));
                    SaveData(ref players);
                }
                else
                    Player.Get(player).Update(player);
        }

        ////////////////////////////////////////
        ///     Config & Message Loading
        ////////////////////////////////////////

        void LoadConfig()
        {
            SetConfig("Settings", "Strikes Until Ban", 3);
            SetConfig("Settings", "Permanent Ban", false);
            SetConfig("Settings", "Ban Time in Seconds", 86400);

            SaveConfig();
        }

        void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"No Permission", "You don't have permission to use this command."},
                {"Striked", "{player} has been striked. Reason: {reason}"},
                {"Banned", "{player} was banned due too many strikes. Reason: {reason}"},
                {"Can Not Join", "You were banned due too many strikes. Reason: {reason}"},
                {"True Or False", "{arg} must be 'true' or 'false'!"},
                {"Invalid Number", "{arg} must be a valid number!"},
                {"Reset", "{player}'s strikes were reset."},
                {"Removed", "Removed {amount} strikes from {player}"},
                {"Wiped", "Strikes were been wiped!"},
                {"Fully Wiped", "All data was wiped!"}
            }, this);
        }

        protected override void LoadDefaultConfig() => PrintWarning("Generating new config file...");
        #endregion

        #region Commands

        [ChatCommand("strike")]
        void cmdStrike(BasePlayer player, string cmd, string[] args)
        {
            if(args.Length == 0)
            {
                if (HasPerm(player.userID, "admin"))
                    SendChatMessage(player, "<color=#C4FF00>/strike <player> [reason]</color> strike player" + Environment.NewLine +
                                            "<color=#C4FF00>/strike reset <player> [only Active Strikes: true/false]</color> reset players strikes" + Environment.NewLine +
                                            "<color=#C4FF00>/strike remove <player> [amount] [only Active Strikes: true/false]</color> remove strikes of a player " + Environment.NewLine +
                                            "<color=#C4FF00>/strike info [player]</color> get strike info about a player" + Environment.NewLine +
                                            "<color=#C4FF00>/strike wipe [only Active Strikes: true/false]</color> wipe all strikes" + Environment.NewLine +
                                            "<color=#C4FF00>/strike wipefull</color> wipe all data");
                else
                    SendChatMessage(player, "<color=#C4FF00>/strike info</color> get your strike info");

                return;
            }

            switch(args[0].ToLower())
            {
                case "reset":
                    if (!HasPerm(player.userID, "admin"))
                        return;

                    if(args.Length != 2 && args.Length != 3)
                    {
                        SendChatMessage(player, "Syntax: /strike reset <player> [only Active Strikes: true/false]");
                        return;
                    }

                    BasePlayer resetTarget = GetPlayer(args[1], player);

                    if (resetTarget == null)
                        return;

                    Player resetPl = Player.Get(resetTarget);

                    if(resetPl == null)
                    {
                        players.Add(new Player(resetTarget));
                        SaveData(ref players);

                        resetPl = Player.Get(resetTarget);
                    }

                    bool resetOnlyActive = true;

                    if(args.Length == 3)
                    {
                        try
                        {
                            resetOnlyActive = Convert.ToBoolean(args[2]);
                        }
                        catch(FormatException)
                        {
                            SendChatMessage(player, GetMsg("True Or False", player.userID));
                            return;
                        }
                    }

                    resetPl.activeStrikes = 0;

                    if(!resetOnlyActive)
                    {
                        resetPl.strikes = 0;
                        resetPl.lastStrike = "not striked yet";
                    }

                    SaveData(ref players);

                    SendChatMessage(player, GetMsg("Reset", player.userID).Replace("{player}", resetTarget.displayName));

                    break;

                case "remove":
                    if (!HasPerm(player.userID, "admin"))
                        return;

                    if (args.Length != 2 && args.Length != 3 && args.Length != 4)
                    {
                        SendChatMessage(player, "Syntax: /strike remove <player> [amount] [only Active Strikes: true/false]");
                        return;
                    }

                    BasePlayer removeTarget = GetPlayer(args[1], player);

                    if (removeTarget == null)
                        return;

                    Player removePl = Player.Get(removeTarget);

                    if (removePl == null)
                    {
                        players.Add(new Player(removeTarget));
                        SaveData(ref players);

                        removePl = Player.Get(removeTarget);
                    }

                    int removeAmount = 1;

                    if (args.Length >= 3)
                    {
                        try
                        {
                            removeAmount = Convert.ToInt32(args[2]);
                        }
                        catch (FormatException)
                        {
                            SendChatMessage(player, GetMsg("Invalid Number", player.userID));
                            return;
                        }
                    }

                    bool removeOnlyActive = true;

                    if (args.Length == 4)
                    {
                        try
                        {
                            removeOnlyActive = Convert.ToBoolean(args[3]);
                        }
                        catch (FormatException)
                        {
                            SendChatMessage(player, GetMsg("True Or False", player.userID).Replace("{arg}", "[only Active Strikes: true/false]"));
                            return;
                        }
                    }

                    removePl.activeStrikes -= removeAmount;

                    if (!removeOnlyActive)
                        removePl.strikes -= removeAmount;

                    SaveData(ref players);

                    SendChatMessage(player, GetMsg("Removed", player.userID).Replace("{player}", removeTarget.displayName).Replace("{amount}", removeAmount.ToString()));

                    break;

                case "info":
                    if (!HasPerm(player.userID, "admin"))
                    {
                        Player pl = Player.Get(player);

                        if (pl == null)
                        {
                            players.Add(new Player(player));
                            SaveData(ref players);

                            pl = Player.Get(player);
                        }

                        SendChatMessage(player, $"<color=#C4FF00>Last Strike</color>: {pl.lastStrike}" + Environment.NewLine +
                                                $"<color=#C4FF00>Active Strikes</color>: {pl.activeStrikes}" + Environment.NewLine +
                                                $"<color=#C4FF00>Total Strikes</color>: {pl.strikes}");
                    }
                    else
                    {
                        if (args.Length != 1 && args.Length != 2)
                        {
                            SendChatMessage(player, "Syntax: /strike info [player]");
                            return;
                        }

                        if(args.Length == 1)
                        {
                            Player pl = Player.Get(player);

                            if (pl == null)
                            {
                                players.Add(new Player(player));
                                SaveData(ref players);

                                pl = Player.Get(player);
                            }

                            SendChatMessage(player, $"<color=#C4FF00>Last Strike</color>: {pl.lastStrike}" + Environment.NewLine +
                                                    $"<color=#C4FF00>Active Strikes</color>: {pl.activeStrikes}" + Environment.NewLine +
                                                    $"<color=#C4FF00>Total Strikes</color>: {pl.strikes}");
                        }
                        else
                        {
                            BasePlayer infoTarget = GetPlayer(args[1], player);

                            if (infoTarget == null)
                                return;

                            Player infoPl = Player.Get(infoTarget);

                            if (infoPl == null)
                            {
                                players.Add(new Player(infoTarget));
                                SaveData(ref players);

                                infoPl = Player.Get(infoTarget);
                            }

                            SendChatMessage(player, $"<color=#C4FF00>Last Strike</color>: {infoPl.lastStrike}" + Environment.NewLine +
                                                    $"<color=#C4FF00>Active Strikes</color>: {infoPl.activeStrikes}" + Environment.NewLine +
                                                    $"<color=#C4FF00>Total Strikes</color>: {infoPl.strikes}");
                        }
                    }
                    break;

                case "wipe":
                    if (!HasPerm(player.userID, "admin"))
                        return;

                    if (args.Length != 1 && args.Length != 2)
                    {
                        SendChatMessage(player, "Syntax: /strike wipe [only Active Strikes: true/false]");
                        return;
                    }

                    bool wipeOnlyActive = true;

                    if (args.Length == 2)
                    {
                        try
                        {
                            wipeOnlyActive = Convert.ToBoolean(args[1]);
                        }
                        catch (FormatException)
                        {
                            SendChatMessage(player, GetMsg("True Or False", player.userID));
                            return;
                        }
                    }

                    foreach (Player pl in players)
                    {
                        pl.activeStrikes = 0;
                        
                        if(!wipeOnlyActive)
                        {
                            pl.strikes = 0;
                            pl.lastStrike = "not striked yet";
                        }
                    }

                    SaveData(ref players);

                    SendChatMessage(player, GetMsg("Wiped", player.userID));
                    break;

                case "wipefull":
                    if (!HasPerm(player.userID, "admin"))
                        return;

                    players.Clear();
                    SaveData(ref players);

                    SendChatMessage(player, GetMsg("Fully Wiped", player.userID));
                    break;

                default:
                    if (!HasPerm(player.userID, "admin"))
                        return;

                    BasePlayer strikePlayer = GetPlayer(args[0], player);

                    if (strikePlayer == null)
                        return;

                    StrikePlayer(strikePlayer, args.Length == 2 ? args[1] : "none");
                    break;
            }
        }

        #endregion

        #region Subject Related

        void StrikePlayer(BasePlayer player, string reason = "none")
        {
            Player pl = Player.Get(player);

            if (pl == null)
            {
                players.Add(new Player(player));
                SaveData(ref players);

                pl = Player.Get(player);
            }

            pl.strikes++;
            pl.activeStrikes++;
            pl.lastStrike = DateTime.Now.ToString();
            
            pl.Update(player);

            BroadcastChat(GetMsg("Striked", player.userID).Replace("{player}", player.displayName).Replace("{reason}", reason));

            if (ReachedMaxStrikes(player))
                BanPlayer(player, reason);
        }

        bool ReachedMaxStrikes(BasePlayer player)
        {
            Player pl = Player.Get(player);
            int maxStrikes = GetConfig(3, "Settings", "Strikes Until Ban");

            if (pl == null)
                return false;
            else
                return (pl.activeStrikes >= maxStrikes);
        }

        
        void BanPlayer(BasePlayer player, string reason = "none")
        {
            if (EBS == null)
            {
                PrintError($"Failed to ban player {player.displayName} ! EnhancedBanSystem was not found! It is needed for this plugin to work!");
                return;
            }

            int banTime = GetConfig(3, "Settings", "Ban Time in Seconds");

            EBS.Call("BanID", player, player.userID, GetMsg("Can Not Join", player.userID).Replace("{reason}", reason), banTime);

            BroadcastChat(GetMsg("Banned", player.userID).Replace("{player}", player.displayName).Replace("{reason}", reason));
        }

        #endregion

        #region General Methods

        ////////////////////////////////////////
        ///     Player Finding
        ////////////////////////////////////////

        BasePlayer GetPlayer(string searchedPlayer, BasePlayer player)
        {
            foreach (BasePlayer current in BasePlayer.activePlayerList)
                if (current.displayName.ToLower() == searchedPlayer.ToLower())
                    return current;

            List<BasePlayer> foundPlayers =
                (from current in BasePlayer.activePlayerList
                 where current.displayName.ToLower().Contains(searchedPlayer.ToLower())
                 select current).ToList();

            switch (foundPlayers.Count)
            {
                case 0:
                    SendChatMessage(player, "The player can not be found.");
                    break;

                case 1:
                    return foundPlayers[0];

                default:
                    List<string> playerNames = (from current in foundPlayers select current.displayName).ToList();
                    string players = ListToString(playerNames, 0, ", ");
                    SendChatMessage(player, "Multiple matching players found: \n" + players);
                    break;
            }

            return null;
        }

        ////////////////////////////////////////
        ///     Converting
        ////////////////////////////////////////

        string ListToString<T>(List<T> list, int first, string seperator) => string.Join(seperator, (from item in list select item.ToString()).Skip(first).ToArray());

        ////////////////////////////////////////
        ///     Config Related
        ////////////////////////////////////////

        void SetConfig(params object[] args)
        {
            List<string> stringArgs = (from arg in args select arg.ToString()).ToList();
            stringArgs.RemoveAt(args.Length - 1);

            if (Config.Get(stringArgs.ToArray()) == null) Config.Set(args);
        }

        T GetConfig<T>(T defaultVal, params object[] args)
        {
            List<string> stringArgs = (from arg in args select arg.ToString()).ToList();
            if (Config.Get(stringArgs.ToArray()) == null)
            {
                PrintError($"The plugin failed to read something from the config: {ListToString(stringArgs, 0, "/")}{Environment.NewLine}Please reload the plugin and see if this message is still showing. If so, please post this into the support thread of this plugin.");
                return defaultVal;
            }

            return (T)Convert.ChangeType(Config.Get(stringArgs.ToArray()), typeof(T));
        }

        ////////////////////////////////////////
        ///     Data Related
        ////////////////////////////////////////

        void LoadData<T>(ref T data, string filename = "?") => data = Core.Interface.Oxide.DataFileSystem.ReadObject<T>(filename == "?" ? this.Title : filename);

        void SaveData<T>(ref T data, string filename = "?") => Core.Interface.Oxide.DataFileSystem.WriteObject(filename == "?" ? this.Title : filename, data);

        ////////////////////////////////////////
        ///     Message Related
        ////////////////////////////////////////

        string GetMsg(string key, object userID = null) => lang.GetMessage(key, this, userID == null ? null : userID.ToString());

        ////////////////////////////////////////
        ///     Permission Related
        ////////////////////////////////////////

        void RegisterPerm(params string[] permArray)
        {
            string perm = ListToString(permArray.ToList(), 0, ".");

            permission.RegisterPermission($"{PermissionPrefix}.{perm}", this);
        }

        bool HasPerm(object uid, params string[] permArray)
        {
            string perm = ListToString(permArray.ToList(), 0, ".");

            return permission.UserHasPermission(uid.ToString(), $"{PermissionPrefix}.{perm}");
        }

        string PermissionPrefix
        {
            get
            {
                return this.Title.Replace(" ", "").ToLower();
            }
        }

        ////////////////////////////////////////
        ///     Chat Related
        ////////////////////////////////////////

        void BroadcastChat(string prefix, string msg = null) => rust.BroadcastChat(msg == null ? prefix : "<color=#C4FF00>" + prefix + "</color>: " + msg);

        void SendChatMessage(BasePlayer player, string prefix, string msg = null) => rust.SendChatMessage(player, msg == null ? prefix : "<color=#C4FF00>" + prefix + "</color>: " + msg);

        #endregion
    }
}


// --- End of file: StrikeSystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TPApi.cs ---
// --- Original Local Path: TPApi.cs ---

using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("TPApi", "Sempai#3239", "2.0.0")]
    class TPApi : RustPlugin
    {
        #region [ OTHER ]
        [ChatCommand("gtatest")]
        private void Test(BasePlayer player, string cmd, string[] args)
        {
            if(player.IsAdmin == false) { return; }

            ShowGameTip(player, $"{player.displayName}\n{player.userID}", Convert.ToInt32(args[2]));
        }
        #endregion

        #region [ CONSOLE COMMAND ]
        [ConsoleCommand("tpapi.showforall")]
        private void ShowGameTipForAll_ConsoleCommand(ConsoleSystem.Arg arg) //0 = type, 1 = message
        {
            if(arg.IsAdmin == false) { return; }

            int type = 0;
            string message = string.Empty;
            try
            {
                type = Convert.ToInt32(arg.Args[2]);


                for (int i = 1; i < arg.Args.Length; i++)
                    message += arg.Args[i] + " ";
                message.Remove(message.Length - 1, 1);

                message = FormatString(message);
            }
            catch (Exception ex)
            {
                Debug.LogWarning($"Вы неправильно указали аргументы! Ошибка: " + ex.Message);
                return;
            }

            ShowGameTip(BasePlayer.activePlayerList.ToList(), message, type);
        }
        [ConsoleCommand("tpapi.showforplayer")]
        private void ShowGameTipForPlayer_ConsoleCommand(ConsoleSystem.Arg arg) //0 = player, 1 = type, 2 = message
        {
            if (arg.IsAdmin == false) { return; }

            int type = 0;
            BasePlayer? player = null;
            string message = string.Empty;
            try
            {
                player = BasePlayer.FindByID(Convert.ToUInt64(arg.Args[2]));
                type = Convert.ToInt32(arg.Args[1]);


                for (int i = 2; i < arg.Args.Length; i++)
                    message += arg.Args[i] + " ";
                message.Remove(message.Length - 1, 1);

                message = FormatString(message);
            }
            catch (Exception ex)
            {
                Debug.LogWarning($"Вы неправильно указали аргументы! Ошибка: " + ex.Message);
                return;
            }

            if(player != null & string.IsNullOrEmpty(message) == false)
            {
                ShowGameTip(player, message, type);
            }
        }
        #endregion

        #region [ METHODS ]
        private void ShowGameTip(BasePlayer target, string message, int type = 0) // 0 = blue, 1 = red
        {
            target.SendConsoleCommand($"gametip.showtoast", type, message);
        }
        private void ShowGameTip(List<BasePlayer> targets, string message, int type = 0) // 0 = blue, 1 = red
        {
            foreach (BasePlayer target in targets)
            { 
                target.SendConsoleCommand($"gametip.showtoast", type, message);
            }
        }
        #endregion

        #region [ EXT ]
        private string FormatString(string text)
        {
            text = text.Replace('^', '\n');

            return text;
        }
        #endregion

        #region [ API ]
        [HookMethod("ShowGameTipForPlayer")]
        public void ShowGameTipForPlayer_Hook(BasePlayer player, int type, string message)
        {
            if(player == null | message == "Вы получили новый уровень /pass") { return; }

            ShowGameTip(player, message, type);
        }
        [HookMethod("ShowGameTipForAll")]
        public void ShowGameTipForPlayer_Hook(int type, string message)
        {
            if (message == null) { return; }

            ShowGameTip(BasePlayer.activePlayerList.ToList(), message, type);
        }
        #endregion
    }
}

// --- End of file: TPApi.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/PlayerGifts.cs ---
// --- Original Local Path: PlayerGifts.cs ---

﻿using Oxide.Core;
using System.Collections.Generic;
using System.Linq;
using System;
using UnityEngine;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins
{
    [Info("Player Gifts", "TopPlugin.ru", "2.0.1")]
    class PlayerGifts : RustPlugin
    {
        Dictionary<BasePlayer, int> timers = new Dictionary<BasePlayer, int>();
        List<ulong> activePlayers = new List<ulong>();

        #region CONFIGURATION
        public int GameActive = 15;
        string EnableGUIPlayerMin = "0.01041665 0.07825926";
        string EnableGUIPlayerMax = "0.1805 0.122";
        string GUIEnabledColor = "0.44 0.55 0.26 0.70";
        string GUIColor = "0.44 0.55 0.26 1";
        string ImagesGUI = "https://i.imgur.com/w5FhWrR.png";

        private void LoadDefaultConfig()
        {
            GetConfig("Настройки", "Время активности на сервере за какое выдается подарок (в минутах)", ref GameActive);
            GetConfig("GUI", "Цвет фона кнопки 'Забрать подарок'", ref GUIEnabledColor);
            GetConfig("GUI", "Цвет фона заполнения", ref GUIColor);
            GetConfig("GUI", "Ссылка на изображение", ref ImagesGUI);
            GetConfig("GUI", "Anchor Min Основной панели", ref EnableGUIPlayerMin);
            GetConfig("GUI", "Anchor Max Основной панели", ref EnableGUIPlayerMax);
            SaveConfig();
        }

        private void GetConfig<T>(string menu, string Key, ref T var)
        {
            if (Config[menu, Key] != null)
            {
                var = (T)Convert.ChangeType(Config[menu, Key], typeof(T));
            }
            Config[menu, Key] = var;
        }

        #endregion

        #region Core

        bool CanTake(BasePlayer player) => !player.inventory.containerMain.IsFull() || !player.inventory.containerBelt.IsFull();

        bool TakeGifts(BasePlayer player, string gift = "Player Gifts")
        {
            if (data.GiftPlayers[player.userID].ActiveGifts != 0)
            {
                if (!CanTake(player))
                {
                    SendReply(player, Messages["InvFull"]);
                    return false;
                }

                var item = gifts[gift].Items.GetRandom();
                var amount = item.GetRandom();
                player.inventory.GiveItem(ItemManager.CreateByName(item.Shortname, amount, 0));
                var x = ItemManager.CreateByPartialName(item.Shortname);
                data.GiftPlayers[player.userID].ActiveGifts = data.GiftPlayers[player.userID].ActiveGifts = 0;
                SaveData();
                CuiHelper.DestroyUi(player, "GetGift");
                UpdateTimer(player);
                if (amount > 1)
                    SendReply(player, Messages["GiveGift"], x.info.displayName.english, amount);
                else
                {
                    SendReply(player, Messages["GiveGiftAmount"], x.info.displayName.english);
                }
                SaveData();
                return true;
            }
            return false;
        }

        public BasePlayer FindBasePlayer(string nameOrUserId)
        {
            nameOrUserId = nameOrUserId.ToLower();
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (player.displayName.ToLower().Contains(nameOrUserId) || player.UserIDString == nameOrUserId)
                    return player;
            }
            foreach (var player in BasePlayer.sleepingPlayerList)
            {
                if (player.displayName.ToLower().Contains(nameOrUserId) || player.UserIDString == nameOrUserId)
                    return player;
            }
            return default(BasePlayer);
        }

        void TimerHandler()
        {
            foreach (var player in timers.Keys.ToList())
            {
                var seconds = --timers[player];
                var resetTime = (GameActive * 60);
                if (seconds > resetTime)
                {
                    data.GiftPlayers[player.userID].Time = data.GiftPlayers[player.userID].Time = resetTime;
                    TimerHandler();
                    break;
                }

                if (seconds <= 0)
                {
                    var TimerGift = FormatTime(TimeSpan.FromSeconds(resetTime));
                    timers.Remove(player);
                    data.GiftPlayers[player.userID].ActiveGifts = data.GiftPlayers[player.userID].ActiveGifts + 1;
                    data.GiftPlayers[player.userID].Time = data.GiftPlayers[player.userID].Time = resetTime;
                    SaveData();
                    SendReply(player, Messages["TheTimeEnd"], TimerGift);
                    DrawUIGetGift(player);
                    continue;
                }
                if (data.GiftPlayers[player.userID].ActiveGifts == 0)
                {
                    DrawUIBalance(player, seconds);
                    data.GiftPlayers[player.userID].Time = data.GiftPlayers[player.userID].Time = seconds;
                }
            }
        }

        void UpdateTimer(BasePlayer player)
        {
            if (player == null) return;

            var resetTime = (GameActive * 60);
            timers[player] = data.GiftPlayers[player.userID].Time;
            DrawUIBalance(player, timers[player]);
        }

        void DeactivateTimer(BasePlayer player)
        {
            if (activePlayers.Contains(player.userID))
            {
                activePlayers.Remove(player.userID);
                timers.Remove(player);
            }
        }

        void ActivateTimer(ulong userId)
        {
            if (!activePlayers.Contains(userId))
            {
                activePlayers.Add(userId);
            }
        }

        public static string FormatTime(TimeSpan time)
        {
            string result = string.Empty;
            if (time.Days != 0)
                result += $"{Format(time.Days, "дней", "дня", "день")} ";

            if (time.Hours != 0)
                result += $"{Format(time.Hours, "часов", "часа", "час")} ";

            if (time.Minutes != 0)
                result += $"{Format(time.Minutes, "минут", "минуты", "минуту")} ";

            if (time.Seconds != 0)
                result += $"{Format(time.Seconds, "секунд", "секунды", "секунда")} ";

            return result;
        }

        private static string Format(int units, string form1, string form2, string form3)
        {
            var tmp = units % 10;

            if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                return $"{units} {form1}";

            if (tmp >= 2 && tmp <= 4)
                return $"{units} {form2}";

            return $"{units} {form3}";
        }
        #endregion

        #region COMMANDS

        [ChatCommand("gift")]
        void cmdGiveGift(BasePlayer player)
        {
            if (player == null) return;
            if (data.GiftPlayers[player.userID].ActiveGifts == 0)
            {
                SendReply(player, Messages["PlayerNHaveGift"]);
                return;
            }
            if (data.GiftPlayers[player.userID].ActiveGifts >= 1)
            {
                TakeGifts(player);
            }
        }

        [ConsoleCommand("getGift")]
        void CmdGetGift(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;

            if (data.GiftPlayers[player.userID].ActiveGifts == 0)
            {
                SendReply(player, Messages["PlayerNHaveGift"]);
                return;
            }
            if (data.GiftPlayers[player.userID].ActiveGifts >= 1)
            {
                TakeGifts(player);
            }
        }

        #endregion

        #region UI

        int getExperiencePercentInt(int skill)
        {
            var resetTime = (GameActive * 60);
            var next = resetTime;
            var Points = resetTime - skill;
            var reply = 683;
            var experienceProc = Convert.ToInt32((Points / (double)next) * 100);
            if (experienceProc >= 100)
                experienceProc = 99;
            else if (experienceProc == 0)
                experienceProc = 1;
            return experienceProc;
        }

        void DrawUIBalance(BasePlayer player, int seconds)
        {
            CuiHelper.DestroyUi(player, "OpenGift1");
            CuiHelper.DestroyUi(player, "ProcentBar");
            int percent = getExperiencePercentInt(seconds);
            var resetTime = (GameActive * 60);
            var TimerGift = (resetTime / 60);
            CuiElementContainer Container = new CuiElementContainer();
            CuiElement OpenGift = new CuiElement
            {
                Name = "OpenGift",
                Parent = "UIPlayer",
                Components =
                {
                    new CuiTextComponent {
                        Text = $"",
                        Align = TextAnchor.MiddleCenter,
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = "0.15 0",
                        AnchorMax = "1 1"
                    }
                }
            };
            CuiElement ProcentBar = new CuiElement
            {
                Name = "ProcentBar",
                Parent = "OpenGift",
                Components =
                {
                    new CuiButtonComponent
                    {
                        Command = "getGift",
                        Color = GUIColor,
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = "0 0.1",
                        AnchorMax = $"{1 - ((seconds + (float)TimerGift) / (float)resetTime)} 0.85"
                    }
                }
            };
            CuiElement OpenGift1 = new CuiElement
            {
                Name = "OpenGift1",
                Parent = "UIPlayer",
                Components =
                {
                    new CuiTextComponent {
                        Text = $"{percent}%",
                        Align = TextAnchor.MiddleCenter,
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = "0.15 0",
                        AnchorMax = "1 1"
                    },
                        new CuiOutlineComponent {
                            Color = "0 0 0 0.5",
                            Distance = "1.0 -0.5"
                        }
                }
            };

            Container.Add(OpenGift);
            Container.Add(ProcentBar);
            Container.Add(OpenGift1);
            CuiHelper.AddUi(player, Container);

        }

        void DrawUIGetGift(BasePlayer player)
        {
            DrawUIPlayer(player);
            CuiHelper.DestroyUi(player, "OpenGift1");
            CuiElementContainer Container = new CuiElementContainer();

            CuiElement GetGift = new CuiElement
            {
                Name = "GetGift",
                Parent = "UIPlayer",
                Components =
                {
                    new CuiButtonComponent
                    {
                        Command = "getGift",
                        Color = "0.44 0.55 0.26 1",
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = "0.15 0.11",
                        AnchorMax = "0.985 0.88"
                    }
                }
            };

            CuiElement TextGetGift = new CuiElement
            {
                Name = "TextGetGift",
                Parent = "GetGift",
                Components =
                {
                    new CuiTextComponent {
                        Text = Messages["GiveGifts"],
                        Align = TextAnchor.MiddleCenter
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    },
                        new CuiOutlineComponent {
                            Color = "0 0 0 0.5", Distance = "1.0 -0.5"

                        }
                }
            };
            Container.Add(GetGift);
            Container.Add(TextGetGift);
            CuiHelper.AddUi(player, Container);

        }

        void DrawUIPlayer(BasePlayer player)
        {
            if (player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.In(0.1f, () => DrawUIPlayer(player));
                return;
            }
            CuiElementContainer Container = new CuiElementContainer();
            CuiElement GiftIcon = new CuiElement
            {
                Name = "GiftIcon",
                Parent = "BPUI",
                Components = {
                        new CuiRawImageComponent {
                            Url = ImagesGUI,
                            Color = "1 1 1 0.7"
                        },
                        new CuiRectTransformComponent {
                        AnchorMin = "0.1 0.1",
                        AnchorMax = "0.9 0.9"
                        }
                }
            };
            CuiElement BPUI = new CuiElement
            {
                Name = "BPUI",
                Parent = "UIPlayer",
                Components = {
                        new CuiImageComponent {
                            Color = "0 0 0 0.1"
                        },
                        new CuiRectTransformComponent {
                             AnchorMin = "0 0",
                        AnchorMax = "0.14 0.98"
                        }
                    }
            };
            CuiElement UIPlayer = new CuiElement
            {
                Name = "UIPlayer",
                Parent = "Overlay",
                Components =
                {
                    new CuiButtonComponent
                    {
                        Command = "getGift",
                        Color = "0.32 0.32 0.41 0.22",
                    },
                    new CuiRectTransformComponent {
                         AnchorMin = EnableGUIPlayerMin,
                        AnchorMax = EnableGUIPlayerMax
                    }
                }
            };

            Container.Add(UIPlayer);
            Container.Add(BPUI);
            Container.Add(GiftIcon);
            CuiHelper.AddUi(player, Container);
            var resetTime = (GameActive * 60);
            DrawUIBalance(player, resetTime);
        }

        void DestroyUIPlayer(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "UIPlayer");
        }

        #endregion

        #region OXIDE HOOKS

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                DestroyUIPlayer(player);
                DeactivateTimer(player);
            }
            SaveData();
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            DeactivateTimer(player);
        }

        void OnServerInitialized()
        {
            LoadDefaultConfig();
            GiftData = Interface.Oxide.DataFileSystem.GetFile("PlayerGifts/Players");
            LoadData();
            lang.RegisterMessages(Messages, this, "en");
            Messages = lang.GetMessages("en", this);
            timer.Every(1f, TimerHandler);
            foreach (var player in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(player);
            }
        }

        void LoadData()
        {
            try
            {
                data = Interface.GetMod().DataFileSystem.ReadObject<DataStorage>("PlayerGifts/Players");
            }

            catch
            {
                data = new DataStorage();
            }

            if (Interface.Oxide.DataFileSystem.ExistsDatafile("PlayerGifts/Gifts"))
                gifts = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, GiftDefinition>>("PlayerGifts/Gifts");
            else
            {
                gifts.Add("Player Gifts", new GiftDefinition()
                {
                    Type = "Gifts",
                    Items = new List<CaseItem>
                    {
                        new CaseItem
                        {
                            Shortname = "rifle.ak",
                            Min = 1,
                            Max = 1
                        }
                    }
                });
                Interface.Oxide.DataFileSystem.WriteObject("PlayerGifts/Gifts", gifts);
            }
        }

        void SaveData()
        {
            GiftData.WriteObject(data);
        }

        void OnServerSave()
        {
            SaveData();
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.In(1f, () => OnPlayerConnected(player));
                return;
            }
            if (player == null) return;

            var Time = (GameActive * 60);
            if (!data.GiftPlayers.ContainsKey(player.userID))
            {
                data.GiftPlayers.Add(player.userID, new GiftsData()
                {
                    Name = player.displayName,
                    ActiveGifts = 0,
                    Time = Time,
                });
                SaveData();
            }
            if (data.GiftPlayers[player.userID].ActiveGifts == 0)
            {
                UpdateTimer(player);
                ActivateTimer(player.userID);
                DrawUIPlayer(player);
            }
            else
            {
                DrawUIGetGift(player);
            }

        }
        #endregion

        #region DATA

        class DataStorage
        {
            public Dictionary<ulong, GiftsData> GiftPlayers = new Dictionary<ulong, GiftsData>();
            public DataStorage() { }
        }

        class GiftsData
        {
            public string Name;
            public int ActiveGifts;
            public int Time;
        }

        DataStorage data;

        private DynamicConfigFile GiftData;

        static PlayerGifts instance;

        public class GiftDefinition
        {
            public string Type;
            public List<CaseItem> Items;
            public CaseItem Open() => Items.GetRandom();
        }

        public class CaseItem
        {
            public string Shortname;
            public int Min;
            public int Max;
            public int GetRandom() => UnityEngine.Random.Range(Min, Max + 1);
        }

        public Dictionary<string, GiftDefinition> gifts = new Dictionary<string, GiftDefinition>();

        #endregion

        #region LOCALIZATION

        Dictionary<string, string> Messages = new Dictionary<string, string>()
        {
            {"InvFull", "У Вас переполнен инвентарь" },
            {"GiveGift", "Вы получили {0} в размере: {1} шт." },
            {"GiveGiftAmount", "Вы получили {0}" },
            {"TheTimeEnd", "Вы пробыли на сервере: <color=#A6FFAC>{0}</color>, у нас для Вас подарок!\nОткройте чат, и нажмите кнопку <color=#A6FFAC>Забрать подарок</color>, либо используйте <color=#A6FFAC>/gift</color> что бы получить его" },
            {"PlayerNHaveGift", "Для Вас пока нету подарков" },
            {"GiveGifts", "ЗАБРАТЬ ПОДАРОК" },
        };

        #endregion
    }
}
                     

// --- End of file: PlayerGifts.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RustySheriffAlertSystem.cs ---
// --- Original Local Path: RustySheriffAlertSystem.cs ---

using System.Collections.Generic;
using System;
using System.Reflection;
using System.Data;
using UnityEngine;
using Oxide.Core;
using System.IO;
using Oxide.Core.Libraries;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("RaidAlert", "By JV", "1.0.4")]
    class RustySheriffAlertSystem : RustPlugin
    {
        List<BasePlayer> allBasePlayer;
        List<Auth> authList = new List<Auth>();
        List<DrawListEntry> drawList = new List<DrawListEntry>();
        List<IgnoreListEntry> ignoreList = new List<IgnoreListEntry>();
        List<ulong> muteList = new List<ulong>();
        List<Trespasser> newTrespassers = new List<Trespasser>();
        List<Trespasser> oldTrespassers = new List<Trespasser>();
        List<Perimeter> perimeters = new List<Perimeter>();
        List<TestAlert> testAlerts = new List<TestAlert>();
        List<ValReq> valReqs = new List<ValReq>();
        List<ulong> validated = new List<ulong>();

        Dictionary<ulong, int> authDict = new Dictionary<ulong, int>();
        Dictionary<ulong, int> ignoreDict = new Dictionary<ulong, int>();
        Dictionary<ulong, int> perimeterDict = new Dictionary<ulong, int>();
        
        private static DateTime epoch;

        string url = "http://jvetech.co.uk";

        double drawCheck = 0;
        double nextCheck = 0;
        double playerUpdateCheck = 0;

        int maxPerimeterDelta = 75;
        int maxPerimeterPoints = 50;
        int maxPerimetersPerPlayer = 4;
        int playerCheckIndex = 0;
        int timeBetweenChecks = 30;

        bool alertsVisibleInGame = true;
        bool alertTriggeredOnlyWhenSleepingInPerimeter = false;
        bool automaticCheckingEnabled = true;
        bool enabledForAuthorisedUsersOnly = false;
        bool sendAnon = false;
        bool syncWithRustySheriffServer = true;
        bool updatedOldData = false;
        bool useCupboards = false;
        bool adminsAuthed = false;
        
        private FieldInfo buildingPrivlidges;

        float perimeterHeightDelta = 1.5f;
        System.Random rnd = new System.Random(DateTime.Now.Millisecond);

        [ChatCommand("rs")]
        void cmdChatRS(BasePlayer player, string command, string[] args)
        {
            if (getAuthLevel(player.userID) >= 0 || !enabledForAuthorisedUsersOnly)
            {
                if (args == null || args.Length == 0)
                {
                    showMainMenu(player);
                    return;
                }
                else
                {
                    if (args[0] == "set") { set(player, args); return; }
                    if (args[0] == "view") { viewPerimeters(player, args); return; }
                    if (args[0] == "start") { startPerimeter(player, args); return; }
                    if (args[0] == "add") { addPerimeterEntry(player, false); return; }
                    if (args[0] == "stop") { stopPerimeter(player); return; }
                    if (args[0] == "cancel") { cancelPerimeter(player); return; }
                    if (args[0] == "clear") { clearPerimeters(player); return; }
                    if (args[0] == "delete") { deletePerimeter(player, args); return; }
                    if (args[0] == "validate") { validatePlayer(player, false); return; }
                    if (args[0] == "validatenew") { validatePlayer(player, true); return; }
                    if (args[0] == "ignore") { ignorePlayer(player, args); return; }
                    if (args[0] == "unignore") { unignorePlayer(player, args); return; }
                    if (args[0] == "clearignores") { clearIgnoreList(player); return; }
                    if (args[0] == "ignores") { viewIgnoreList(player); return; }
                    if (args[0] == "ignoredetect") { ignoreDetect(player); return; }
                    if (args[0] == "mute") { muteIngameAlerts(player, true); return; }
                    if (args[0] == "unmute") { muteIngameAlerts(player, false); return; }
                    if (args[0] == "help") { showHelpMenu(player); return; }
                    if (args[0] == "undo") { undoLastPoint(player); return; }
                    if (args[0] == "test") { testPerimeter(player); return; }
                    if (args[0] == "adv") { showAdvancedMenu(player); return; }

                    if (getAuthLevel(player.userID) == 2)
                    {
                        if (args[0] == "time") { setTimeBetweenChecks(player, args); return; }
                        if (args[0] == "adduser") { addUser(player, args); return; }
                        if (args[0] == "deluser") { delUser(player, args); return; }
                        if (args[0] == "enable") { toggleAutoCheck(player, true); return; }
                        if (args[0] == "disable") { toggleAutoCheck(player, false); return; }
                        if (args[0] == "save") { saveAllData(player); return; }
                        if (args[0] == "auths") { showAuthorisedUsers(player); return; }
                        if (args[0] == "secure") { toggleSecureMode(player); return; }
                        if (args[0] == "chatmute") { toggleChatMute(player); return; }
                        if (args[0] == "sleepers") { toggleSleepers(player); return; }
                        if (args[0] == "maxperim") { setMaxPerimeters(player, args); return; }
                        if (args[0] == "maxsize") { setMaxSize(player, args); return; }
                        if (args[0] == "maxpoints") { setMaxPoints(player, args); return; }
                        if (args[0] == "checkinterval") { setCheckInterval(player, args); return; }
                        if (args[0] == "sync") { toggleSync(player); return; }
                        if (args[0] == "status") { showStatus(player); return; }
                        if (args[0] == "anon") { toggleAnon(player); return; }
                        if (args[0] == "cupboard") { toggleUseCupboard(player); return; }
                        if (args[0] == "admin") { showAdminMenu(player);
                        Puts("|{}+*#");
                        Puts("CLEAN - " + cleanString("|{}+*#"));
                        return; }
                        if (args[0] == "auth") { showAuthMenu(player); return; }
                    }

                    SendReply(player, "Please enter a valid command.  Do /rs for a list.");
                }
            }
        }

        [ConsoleCommand("rs.adduser")]
        void cmdRSAddUser(ConsoleSystem.Arg arg)
        {
            addUser(null, arg.Args);
        }
        [ConsoleCommand("rs.auths")]
        void cmdRSAuths(ConsoleSystem.Arg arg)
        {
            showAuthorisedUsers(null);
        }
        [ConsoleCommand("rs.deluser")]
        void cmdRSDelUser(ConsoleSystem.Arg arg)
        {
            delUser(null, arg.Args);
        }
        [ConsoleCommand("rs.save")]
        void cmdRSSave(ConsoleSystem.Arg arg)
        {
            saveAllData(null);
            Puts("Config and data saved.");
        }

        void addPerimeter(BasePlayer player, string perimeterName)
        {
            if (isInProgress(player.userID))
            {
                SendReply(player, "You already have a perimeter in progress.  Do /rs cancel to remove it.");
                return;
            }

            perimeterName = cleanString(perimeterName);

            int perimeterIndex = getPerimeterIndex(player.userID);
            if (perimeterIndex == -1)
            {
                Perimeter per = new Perimeter();
                per.steamid = player.userID;
                perimeters.Add(per);
                perimeterDict.Add(player.userID, perimeters.Count - 1);
                perimeterIndex = perimeters.Count - 1;
            }

            if (!isPerimeterNameInUse(player.userID, perimeterName))
            {
                PlayerPerimeter pl = new PlayerPerimeter();
                pl.name = perimeterName;

                Vector3 v = new Vector3();
                v.x = player.transform.position.x;
                v.y = player.transform.position.y;// +perimeterHeightDelta;
                v.z = player.transform.position.z;

                pl.coords.Add(v);
                pl.finished = false;
                pl.id = (uint)rnd.Next(1000, 999999999);

                perimeters[perimeterIndex].playerPerimeters.Add(pl);

                SendReply(player, "Started perimeter entry for perimeter " + perimeterName + ".  Do /rs add to enter, and /rs stop for the last waypoint.");

                //*** ENSURE ANY PLAYER TIMERS ARE DESTROYED HERE ***//
                plotPerimeter(player, perimeterIndex, perimeters[perimeterIndex].playerPerimeters.Count - 1);

                DrawListEntry d = new DrawListEntry();
                d.basePlayer = player;
                d.perimeterIndex = perimeterIndex;
                d.playerPerimeterIndex = perimeters[perimeterIndex].playerPerimeters.Count - 1;

                drawList.Add(d);
            }
            else
            {
                SendReply(player, "You already have a perimeter called " + perimeterName + ". Do /rs delete <index> to remove it, or choose another name.");
            }
        }
        int addPerimeterEntry(BasePlayer player, bool stop)
        {
            PerimeterPosition pPos = getInProgress(player.userID);

            if (pPos.perimeterIndex == -1)
            {
                SendReply(player, "You need to start a perimeter first.  Do /rs start <name>, or /rs set for auto-creation.");
                return -1;
            }

            string perimeterName = perimeters[pPos.perimeterIndex].playerPerimeters[pPos.playerPerimeterIndex].name;
            int perimeterCount = perimeters[pPos.perimeterIndex].playerPerimeters[pPos.playerPerimeterIndex].coords.Count;
            int authLevel = getAuthLevel(player.userID);

            if (!stop)
            {
                if ((perimeterCount > maxPerimeterPoints - 1) && authLevel < 1)
                {
                    SendReply(player, "You cannot enter any more waypoints for perimeter " + perimeterName + ".  Do /rs stop to finalise this perimeter or /rs cancel discard it.");
                    return -1;
                }
            }

            Vector3 ePoint = player.transform.position;
            //ePoint.y += perimeterHeightDelta;

            perimeters[pPos.perimeterIndex].playerPerimeters[pPos.playerPerimeterIndex].coords.Add(ePoint);

            if (!findTolerances(pPos) && authLevel < 1)
            {
                SendReply(player, "You cannot add this waypoint as the resulting perimeter will be larger than permitted. (" + maxPerimeterDelta.ToString() + " x " + maxPerimeterDelta.ToString() + ")");
                perimeters[pPos.perimeterIndex].playerPerimeters[pPos.playerPerimeterIndex].coords.RemoveAt(perimeters[pPos.perimeterIndex].playerPerimeters[pPos.playerPerimeterIndex].coords.Count - 1);
                return -1;
            }

            if (authLevel < 1)
            {
                SendReply(player, "Added current location to perimeter " + perimeterName + ". - " + (perimeterCount + 1).ToString() + "/" + maxPerimeterPoints.ToString() + ".");
            }
            else
            {
                SendReply(player, "Added current location to perimeter " + perimeterName + ".");
            }

            plotPerimeter(player, pPos.perimeterIndex, pPos.playerPerimeterIndex);
            return perimeterCount + 1;
        }
        void addUser(BasePlayer initPlayer, string[] args)
        {
            int argIndexDelta = 0;

            if (initPlayer != null)
            {
                //called from ingame
                argIndexDelta = 1;
            }

            string name = "";

            if ((args == null && initPlayer == null) || (args.Length == 1 && initPlayer != null))
            {
                if (args != null)
                {
                    SendReply(initPlayer, "Do /rs adduser followed by either <steamid> <authlevel> or <name> <authlevel> if the player's online.");
                    SendReply(initPlayer, "Or /rs <steamid> <name> <authLevel> if they're offline.");
                    SendReply(initPlayer, "0 = Normal User, 1 = Privileged user, 2 = Admin.");
                    return;
                }
                else
                {
                    Puts("Do /rs adduser followed by either <steamid> <authlevel> or <name> <authlevel> if the player's online.");
                    Puts("Or /rs <steamid> <name> <authLevel> if they're offline.");
                    Puts("0 = Normal User, 1 = Privileged user, 2 = Admin.");
                    return;
                }
            }

            if (args.Length < 2)
            {
                if (initPlayer != null)
                {
                    SendReply(initPlayer, "Do /rs adduser followed by either <steamid> <authlevel> or <name> <authlevel> if the player's online.  Or /rs <steamid> <name> <authLevel> if they're offline.  0 = Normal User, 1 = Privileged user, 2 = Admin.");
                    return;
                }
                else
                {
                    Puts("Do /rs adduser followed by either <steamid> <authlevel> or <name> <authlevel> if the player's online.");
                    Puts("Or /rs <steamid> <name> <authLevel> if they're offline.");
                    Puts("0 = Normal User, 1 = Privileged user, 2 = Admin.");
                    return;
                }
            }

            //check authLevel
            int argIndex = -1;

            if (args.Length == 2 + argIndexDelta)
            {
                argIndex = 1 + argIndexDelta;
            }
            else
            {
                argIndex = 2 + argIndexDelta;
            }

            int authLevel;

            try
            {
                authLevel = Convert.ToInt32(args[argIndex]);
            }
            catch (Exception e)
            {
                if (initPlayer != null)
                {
                    SendReply(initPlayer, "Invalid auth level entered.  0 = Normal User, 1 = Privileged User, 2 = Admin.");
                }
                else
                {
                    Puts("Invalid auth level entered.  0 = Normal User, 1 = Privileged User, 2 = Admin.");
                }
                return;
            }

            ulong steamid = 0;

            if (args.Length == 2 + argIndexDelta)
            {
                //can be steamid or playername + authlevel
                //check if steamid
                bool match = false;

                if (args[argIndexDelta].Length == 17)
                {
                    match = false;
                    name = "";

                    if (args[argIndexDelta].Substring(0, 6) == "765611")
                    {
                        try
                        {
                            steamid = Convert.ToUInt64(args[argIndexDelta]);
                        }
                        catch (Exception e)
                        {
                            if (initPlayer != null)
                            {
                                SendReply(initPlayer, "Invalid SteamID entered.");
                            }
                            else
                            {
                                Puts("Invalid SteamID entered.");
                            }
                            return;
                        }

                        for (int i = 0; i < allBasePlayer.Count; i++)
                        {
                            if (allBasePlayer[i].userID == (ulong)steamid)
                            {
                                name = allBasePlayer[i].displayName;
                                match = true;
                                break;
                            }
                        }
                    }
                }

                if (!match)
                {
                    //check for playername instead
                    int r = checkDupes(args[argIndexDelta]);

                    if (r >= 0)
                    {
                        for (int i = 0; i < allBasePlayer.Count; i++)
                        {
                            if (allBasePlayer[i].displayName.Length >= args[argIndexDelta].Length)
                            {
                                if (allBasePlayer[i].displayName.Substring(0, args[argIndexDelta].Length) == args[argIndexDelta])
                                {
                                    steamid = allBasePlayer[i].userID;
                                    name = allBasePlayer[i].displayName;
                                    match = true;
                                    break;
                                }
                            }
                        }
                    }
                    else
                    {
                        if (initPlayer != null)
                        {
                            if (r == -2)
                            {
                                SendReply(initPlayer, "There is more than 1 player with that name.");
                            }
                            else
                            {
                                SendReply(initPlayer, "There are no players with that name.");
                            }
                        }
                        else
                        {
                            if (r == -2)
                            {
                                Puts("There is more than 1 player with that name.");
                            }
                            else
                            {
                                Puts("There are no players with that name.");
                            }
                        }
                        return;
                    }
                }

                if (match)
                {
                    int aIndex = -1;

                    if (getPlayerIndex(steamid) != -1)
                    {
                        setAuthLevel(steamid, authLevel, name, initPlayer,false);
                    }
                }
                else
                {
                    if (initPlayer != null)
                    {
                        SendReply(initPlayer, "No players with that name or SteamID are currently online.  Try /rs adduser <steamid> <name> <authlevl> to add an offline player.");
                    }
                    else
                    {
                        Puts("No players with that name or SteamID are currently online.  Try /rs adduser <steamid> <name> <authlevl> to add an offline player.");
                    }
                }
            }

            if (args.Length == 3 + argIndexDelta)
            {
                //<steamid> <name> <level>
                try
                {
                    steamid = Convert.ToUInt64(args[argIndexDelta]);
                }
                catch (Exception e)
                {
                    if (initPlayer != null)
                    {
                        SendReply(initPlayer, "Invalid SteamID entered.");
                    }
                    else
                    {
                        Puts("Invalid SteamID entered.");
                    }
                    return;
                }

                name = args[1 + argIndexDelta];
                setAuthLevel(steamid, authLevel, name, initPlayer,false);
            }
        }
        void addValidationRequest(ulong steamid, bool newCode)
        {
            for (int i = 0; i < valReqs.Count; i++)
            {
                if (valReqs[i].steamid == steamid)
                {
                    valReqs.RemoveAt(i);
                    break;
                }
            }

            ValReq v = new ValReq();
            v.steamid = steamid;
            v.newCode = newCode;

            valReqs.Add(v);
        }
        void cancelPerimeter(BasePlayer player)
        {
            stopPerimeter(player, true);
        }
        void checkAdminsAuthed()
        {
            for (int i = 0; i < allBasePlayer.Count; i++)
            {
                if (isServerModerator(allBasePlayer[i]))
                {
                    setAuthLevel(allBasePlayer[i].userID, 2, allBasePlayer[i].displayName, null, true);
                }
            }
        }
        int checkDupes(string playerName)
        {
            int count = 0;
            int index = 0;

            for (int i = 0; i < allBasePlayer.Count; i++)
            {
                if (allBasePlayer[i].displayName.Length >= playerName.Length)
                {
                    if (allBasePlayer[i].displayName.Substring(0, playerName.Length) == playerName)
                    {
                        count++;
                        index = i;
                    }
                }
            }

            if (count == 0)
            {
                return -1;
            }

            if (count == 1)
            {
                return index;
            }

            //count must be > 1 so
            return -2;
        }
        void checkTrespass()
        {
            if (allBasePlayer.Count > playerCheckIndex)
            {
                BasePlayer serverPlayer = allBasePlayer[playerCheckIndex];
                int authLevel = getAuthLevel(serverPlayer.userID);
                if (authLevel < 2)
                {
                    string serverPlayerName = serverPlayer.displayName;
                    serverPlayerName = cleanString(serverPlayerName);
                    Vector3 serverPlayerPos = serverPlayer.transform.position;

                    for (int i = 0; i < perimeters.Count; i++)
                    {
                        for (int p = 0; p < perimeters[i].playerPerimeters.Count; p++)
                        {
                            bool doCheck = false;

                            if (enabledForAuthorisedUsersOnly)
                            {
                                if (authLevel == 0)
                                {
                                    if (alertTriggeredOnlyWhenSleepingInPerimeter)
                                    {
                                        if (perimeters[i].playerPerimeters[p].sleeperPresent)
                                        {
                                            doCheck = true;
                                        }
                                    }
                                    else
                                    {
                                        doCheck = true;
                                    }
                                }

                                if (authLevel > 0)
                                {
                                    doCheck = true;
                                }
                            }
                            else
                            {
                                if (alertTriggeredOnlyWhenSleepingInPerimeter)
                                {
                                    if (perimeters[i].playerPerimeters[p].sleeperPresent)
                                    {
                                        doCheck = true;
                                    }
                                }
                                else
                                {
                                    doCheck = true;
                                }
                            }

                            if (doCheck)
                            {
                                doCheck = false;

                                if (perimeters[i].playerPerimeters[p].finished)
                                {
                                    int wn = 0;
                                    if (serverPlayerPos.x >= perimeters[i].playerPerimeters[p].minX && serverPlayerPos.x <= perimeters[i].playerPerimeters[p].maxX)
                                    {
                                        if (serverPlayerPos.z >= perimeters[i].playerPerimeters[p].minY && serverPlayerPos.z <= perimeters[i].playerPerimeters[p].maxY)
                                        {
                                            PerimeterPosition pPos = new PerimeterPosition();
                                            pPos.perimeterIndex = i;
                                            pPos.playerPerimeterIndex = p;

                                            wn = windingPoly(serverPlayerPos, pPos);
                                        }
                                    }

                                    if (wn != 0)
                                    {
                                        if (syncWithRustySheriffServer && isValidated(serverPlayer.userID))
                                        {
                                            if (!isPlayerIgnored(perimeters[i].steamid, serverPlayer.userID))
                                            {
                                                Trespasser t = new Trespasser();
                                                t.id = perimeters[i].playerPerimeters[p].id;
                                                t.steamid = perimeters[i].steamid;
                                                t.name = cleanString(perimeters[i].playerPerimeters[p].name);
                                                t.trespasserSteamID = serverPlayer.userID;
                                                t.alertText = "|" + perimeters[i].playerPerimeters[p].id + "|" + cleanString(serverPlayerName) + "|" + serverPlayerPos.x.ToString() + "|" + serverPlayerPos.z.ToString();
                                                newTrespassers.Add(t);
                                            }
                                        }

                                        if (alertsVisibleInGame)
                                        {
                                            doCheck = true;
                                        }
                                        else
                                        {
                                            if (authLevel > 0)
                                            {
                                                doCheck = true;
                                            }
                                        }

                                        if (doCheck)
                                        {
                                            for (int t = 0; t < allBasePlayer.Count; t++)
                                            {
                                                if (perimeters[i].steamid == allBasePlayer[t].userID)
                                                {
                                                    if (!muteList.Contains(perimeters[i].steamid))
                                                    {
                                                        if (!isPlayerIgnored(perimeters[i].steamid, serverPlayer.userID))
                                                        {
                                                            bool isValid = true;

                                                            //if (authLevel == 2 && perimeters[i].steamid != serverPlayer.userID)
                                                            //{
                                                            //    isValid = false;
                                                            //}

                                                            //if (isValid)
                                                            //{
                                                            if (!sendAnon || getAuthLevel(perimeters[i].steamid) == 2)
                                                            {
                                                                SendReply(allBasePlayer[t], serverPlayerName + " " + serverPlayer.userID.ToString() + " has breached perimeter " + perimeters[i].playerPerimeters[p].name + ".");
                                                            }
                                                            else
                                                            {
                                                                SendReply(allBasePlayer[t], "Perimeter " + perimeters[i].playerPerimeters[p].name + " has been breached.");
                                                            }
                                                            // }

                                                            break;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        string cleanString(string msg)
        {
            string newMsg = "";

            for (int i = 0; i < msg.Length; i++)
            {
                if (msg.Substring(i, 1) != "|")
                {
                    if (msg.Substring(i, 1) != "{")
                    {
                        if (msg.Substring(i, 1) != "}")
                        {
                            if (msg.Substring(i, 1) != "+")
                            {
                                if (msg.Substring(i, 1) != "*")
                                {
                                    if (msg.Substring(i, 1) != "#")
                                    {
                                        newMsg += msg.Substring(i, 1);
                                    }
                                }
                            }
                        }
                    }

                }
            }

            return newMsg;
        }
        void clearIgnoreList(BasePlayer player)
        {
            int count = 0;
            int ignoreListIndex = getIgnoreListIndex(player.userID);

            if (ignoreListIndex != -1)
            {
                count = ignoreList[ignoreListIndex].ignores.Count;
                ignoreList[ignoreListIndex].ignores.Clear();
            }
            else
            {
                SendReply(player, "Your ignore list is already empty.");
            }

            if (count == 0)
            {
                SendReply(player, "Your ignore list is already empty.");
            }
            else
            {
                SendReply(player, "Removed " + count.ToString() + " players from your ignore list.");
            }
        }
        void clearPerimeters(BasePlayer player)
        {
            int perimeterIndex = getPerimeterIndex(player.userID);

            if (perimeterIndex == -1)
            {
                SendReply(player, "You have no perimeters to remove.  Do /rs set <name> to create one.");
            }
            else
            {
                if (perimeters[perimeterIndex].playerPerimeters.Count == 0)
                {
                    SendReply(player, "You have no perimeters to remove.  Do /rs set <name> to create one.");
                    return;
                }

                if (isInProgress(player.userID))
                {
                    stopDrawing(player);
                }
                SendReply(player, "Removed " + perimeters[perimeterIndex].playerPerimeters.Count.ToString() + " perimeters on this server.");
                perimeters[perimeterIndex].playerPerimeters.Clear();
            }
        }
        void convertOldAlertsObj(OldAlertsObjectDict oldAlertsObj)
        {
            //Puts("Converting perimeters");
            //key is steamid to which perimeter belongs
            var keyArray = oldAlertsObj.alerts.Keys.ToArray();
            //for each steamid
            for (int i = 0; i < keyArray.Length; i++)
            {
                //Puts(keyArray[i]);
                int pIndex = getPerimeterIndex(Convert.ToUInt64(keyArray[i]));
                //key is alert name
                var pKeyArray = oldAlertsObj.alerts[keyArray[i]].Keys.ToArray();

                //for each alert name
                for (int p = 0; p < pKeyArray.Length; p++)
                {
                    //Puts(pKeyArray[p]);

                    int count = oldAlertsObj.alerts[keyArray[i]][pKeyArray[p]].count;
                    bool finished = oldAlertsObj.alerts[keyArray[i]][pKeyArray[p]].finished;
                    uint id = oldAlertsObj.alerts[keyArray[i]][pKeyArray[p]].id;
                    double maxx = oldAlertsObj.alerts[keyArray[i]][pKeyArray[p]].maxx;
                    double maxy = oldAlertsObj.alerts[keyArray[i]][pKeyArray[p]].maxy;
                    double minx = oldAlertsObj.alerts[keyArray[i]][pKeyArray[p]].minx;
                    double miny = oldAlertsObj.alerts[keyArray[i]][pKeyArray[p]].miny;
                    bool sleeperPresent = oldAlertsObj.alerts[keyArray[i]][pKeyArray[p]].SleeperPresent;

                    PlayerPerimeter pp = new PlayerPerimeter();
                    pp.name = pKeyArray[p];
                    pp.finished = finished;
                    pp.id = id;
                    pp.minX = minx;
                    pp.minY = miny;
                    pp.maxX = maxx;
                    pp.maxY = maxy;
                    pp.sleeperPresent = sleeperPresent;

                    Vector3 vec;
                    for (int c = 0; c < count; c++)
                    {
                        vec = new Vector3();
                        vec.x = (float)oldAlertsObj.alerts[keyArray[i]][pKeyArray[p]].coords[c.ToString()]["0"];
                        vec.y = (float)oldAlertsObj.alerts[keyArray[i]][pKeyArray[p]].coords[c.ToString()]["2"];
                        vec.z = (float)oldAlertsObj.alerts[keyArray[i]][pKeyArray[p]].coords[c.ToString()]["1"];
                        pp.coords.Add(vec);
                    }

                    if (pIndex == -1)
                    {
                        Perimeter per = new Perimeter();
                        per.steamid = Convert.ToUInt64(keyArray[i]);
                        per.playerPerimeters.Add(pp);
                        perimeters.Add(per);
                        pIndex = perimeters.Count - 1;
                        perimeterDict.Add(perimeters[pIndex].steamid, pIndex);
                    }
                    else
                    {
                        perimeters[pIndex].playerPerimeters.Add(pp);
                    }
                }
            }
        }
        void convertOldAuthObjs(OldAuthObjectDict oldAuthObj)
        {
            //Puts("Converting auths");
            var steamIDs = oldAuthObj.authorised.Keys.ToArray();

            for (int i = 0; i < steamIDs.Length; i++)
            {
                //Puts(steamIDs[i]);
                Auth a = new Auth();
                a.steamid = Convert.ToUInt64(steamIDs[i]);
                a.name = oldAuthObj.authNames[steamIDs[i]];
                a.level = Convert.ToInt32(oldAuthObj.authorised[steamIDs[i]]);
                authList.Add(a);
                authDict.Add(a.steamid, authList.Count - 1);
            }
        }
        void convertOldIgnoresObjs(OldIgnoresObjectDict oldIgnoresObj)
        {
            //Puts("Converting ignores");
            var keyArray = oldIgnoresObj.ignores.Keys.ToArray();

            for (int i = 0; i < keyArray.Length; i++)
            {
                IgnoreListEntry ie = new IgnoreListEntry();
                ie.steamid = Convert.ToUInt64(keyArray[i]);

                var pKeyArray = oldIgnoresObj.ignores[keyArray[i]].Keys.ToArray();

                for (int p = 0; p < pKeyArray.Length; p++)
                {
                    IgnoredPlayer ip = new IgnoredPlayer();
                    ip.steamid = Convert.ToUInt64(pKeyArray[p]);
                    ip.name = oldIgnoresObj.ignores[keyArray[i]][pKeyArray[p]];
                    ie.ignores.Add(ip);
                }

                ignoreList.Add(ie);
                ignoreDict.Add(ie.steamid, ignoreList.Count - 1);
            }
        }
        void convertOldMuteList(OldMuteList oldMuteList)
        {
            var steamIDs = oldMuteList.muted.Keys.ToArray();

            //Puts("Converting mute list");
            for (int i = 0; i < oldMuteList.muted.Count; i++)
            {
                muteList.Add(Convert.ToUInt64(steamIDs[i]));
            }
        }
        void convertOldValObjs(OldValidatedObjectDict oldValObj)
        {
            //Puts("Converting validations");
            var steamIDs = oldValObj.validated.Keys.ToArray();

            for (int i = 0; i < steamIDs.Length; i++)
            {
                validated.Add(Convert.ToUInt64(steamIDs[i]));
            }
        }
        int countPerimeters(ulong steamid)
        {
            int cnt = 0;

            if (perimeterDict.ContainsKey(steamid))
            {
                return perimeters[perimeterDict[steamid]].playerPerimeters.Count;
            }

            return cnt;
        }
        double currentTime()
        {
            return System.DateTime.UtcNow.Subtract(epoch).TotalSeconds;
        }
        void deletePerimeter(BasePlayer player, string[] args)
        {
            if (args.Length > 1)
            {
                int perimeterIndex = getPerimeterIndex(player.userID);

                if (perimeterIndex == -1)
                {
                    SendReply(player, "You have no perimeters to delete.  Do /rs set <name> to create one.");
                }

                if (perimeters[perimeterIndex].playerPerimeters.Count == 0)
                {
                    SendReply(player, "You have no perimeters to delete.  Do /rs set <name> to create one.");
                }
                else
                {
                    int index;

                    try
                    {
                        index = Convert.ToInt32(args[1]);
                    }
                    catch (Exception e)
                    {
                        SendReply(player, "Invalid index.  Do /rs view to get a valid index.");
                        return;
                    }

                    bool inProgress = false;

                    if (isInProgress(player.userID))
                    {
                        inProgress = true;

                        for (int i = 0; i < drawList.Count; i++)
                        {
                            if (drawList[i].basePlayer.userID == player.userID)
                            {
                                if (drawList[i].playerPerimeterIndex != index - 1)
                                {
                                    SendReply(player, "You have a perimeter in progress.  Complete or cancel it first.");
                                    return;
                                }
                            }
                        }
                    }

                    if (index > perimeters[perimeterIndex].playerPerimeters.Count || index < 0)
                    {
                        SendReply(player, "Invalid index.  Do /rs view to get a valid index.");
                        return;
                    }

                    SendReply(player, "Removed " + perimeters[perimeterIndex].playerPerimeters[index - 1].name + " from your perimeter list.");

                    if (inProgress) { stopDrawing(player); }
                    perimeters[perimeterIndex].playerPerimeters.RemoveAt(index - 1);
                }
            }
            else
            {
                SendReply(player, "Enter a perimeter index to delete.");
            }
        }
        void delUser(BasePlayer player, string[] args)
        {
            int argIndexDelta = 0;

            if (player != null)
            {
                argIndexDelta = 1;
            }

            int index = -1;

            if (args.Length > argIndexDelta)
            {
                try
                {
                    index = Convert.ToInt32(args[argIndexDelta]);
                }
                catch (Exception e)
                {
                    if (player != null)
                    {
                        SendReply(player, "Invalid index entered.  Do /rs auths for a list of authorised users, and their indices.");
                    }
                    else
                    {
                        Puts("Invalid index entered.  Do rs.auths for a list of authorised users, and their indices.");
                    }
                    return;
                }
            }

            if (index < 1 || index > authList.Count)
            {
                if (player != null)
                {
                    SendReply(player, "Invalid index entered.  Do /rs auths for a list of authorised users, and their indices.");
                }
                else
                {
                    Puts("Invalid index entered.  Do rs.auths for a list of authorised users, and their indices.");
                }
                return;
            }

            string name = authList[index - 1].name;
            ulong steamid = authList[index - 1].steamid;
            int level = authList[index - 1].level;

            string levelText = "";

            if (level == 0)
            {
                levelText = "Basic User ";
            }

            if (level == 1)
            {
                levelText = "Privileged User ";
            }

            if (level == 2)
            {
                levelText = "Raid Alert Admin ";
            }

            if (player != null)
            {
                if (steamid == player.userID)
                {
                    SendReply(player, "You cannot remove yourself.");
                    return;
                }
            }

            authList.RemoveAt(index - 1);
            hashAuths();

            for (int i = 0; i < allBasePlayer.Count; i++)
            {
                if (allBasePlayer[i].userID == steamid)
                {
                    SendReply(allBasePlayer[i], "You have been removed from the authorised users list.");
                }
            }

            if (player != null)
            {
                SendReply(player, levelText + name + " " + steamid.ToString() + " has been removed from the authorised users list.");
            }
            else
            {
                Puts(levelText + name + " " + steamid.ToString() + " has been removed from the authorised users list.");
            }
        }
        Point doFacesJoinTogether(List<Point> perimeterPoints, int facesIndex2, List<Face> faces)
        {
            double delta = 0.5;
            Point nextPnt = new Point();
            int cnt = perimeterPoints.Count - 1;

            if (Math.Abs(perimeterPoints[cnt].x - faces[facesIndex2].sx) < delta)
            {
                if (Math.Abs(perimeterPoints[cnt].y - faces[facesIndex2].sy) < delta)
                {
                    nextPnt.x = faces[facesIndex2].ex;
                    nextPnt.y = faces[facesIndex2].ey;
                    return nextPnt;
                }
            }

            if (Math.Abs(perimeterPoints[cnt].x - faces[facesIndex2].ex) < delta)
            {
                if (Math.Abs(perimeterPoints[cnt].y - faces[facesIndex2].ey) < delta)
                {
                    nextPnt.x = faces[facesIndex2].sx;
                    nextPnt.y = faces[facesIndex2].sy;
                    return nextPnt;
                }
            }

            //if (Math.Abs(faces[facesIndex].ex - faces[facesIndex2].sx) < 0.1)
            //{
            //    if (Math.Abs(faces[facesIndex].ey - faces[facesIndex2].sy) < 0.1)
            //    {
            //        nextPnt.x = faces[facesIndex2].ex;
            //        nextPnt.y = faces[facesIndex2].ey;
            //        return nextPnt;
            //    }
            //}

            //if (Math.Abs(faces[facesIndex].ex - faces[facesIndex2].ex) < 0.1)
            //{
            //    if (Math.Abs(faces[facesIndex].ey - faces[facesIndex2].ey) < 0.1)
            //    {
            //        nextPnt.x = faces[facesIndex2].sx;
            //        nextPnt.y = faces[facesIndex2].sy;
            //        return nextPnt;
            //    }
            //}

            nextPnt.x = -65535;
            nextPnt.y = -65535;

            return nextPnt;
        }
        bool doFacesOverlap(int facesIndex, int facesIndex2, List<Face> faces)
        {
            double pntX, pntY, pntX2, pntY2;
            double pnt2X, pnt2Y, pnt2X2, pnt2Y2;

            pntX = faces[facesIndex].sx;
            pntY = faces[facesIndex].sy;
            pntX2 = faces[facesIndex].ex;
            pntY2 = faces[facesIndex].ey;

            pnt2X = faces[facesIndex2].sx;
            pnt2Y = faces[facesIndex2].sy;
            pnt2X2 = faces[facesIndex2].ex;
            pnt2Y2 = faces[facesIndex2].ey;

            //Puts(pntX.ToString() + "," + pntY.ToString()+ "," + pntX2.ToString() + "," + pntY2.ToString() + "," + pnt2X.ToString() + "," + pnt2Y.ToString() + "," + pnt2X2.ToString() + "," + pnt2Y2.ToString());

            if (Math.Abs(pntX - pnt2X) < 0.1)
            {
                if (Math.Abs(pntY - pnt2Y) < 0.1)
                {
                    if (Math.Abs(pntX2 - pnt2X2) < 0.1)
                    {
                        if (Math.Abs(pntY2 - pnt2Y2) < 0.1)
                        {
                            return true;
                        }
                    }
                }
            }

            if (Math.Abs(pntX - pnt2X2) < 0.1)
            {
                if (Math.Abs(pntY - pnt2Y2) < 0.1)
                {
                    if (Math.Abs(pntX2 - pnt2X) < 0.1)
                    {
                        if (Math.Abs(pntY2 - pnt2Y) < 0.1)
                        {
                            return true;
                        }
                    }
                }
            }

            return false;
        }
        void drawFaces(BasePlayer player, List<Face> faces, double height)
        {
            //Puts("Drawing " + faces.Count.ToString() + " faces!");
            int persistSeconds = 10;
            Vector3 lastPos;
            Vector3 thisPos;

            height += 1;
            int triCount = 1;

            float delta = 0;

            for (int f = 0; f < faces.Count; f++)
            {
                delta += .025f;
                lastPos = new Vector3();
                thisPos = new Vector3();

                lastPos.x = (float)faces[f].sx;
                lastPos.z = (float)faces[f].sy;
                thisPos.x = (float)faces[f].ex;
                thisPos.z = (float)faces[f].ey;

                UnityEngine.Color col;

                lastPos.y = (float)height + delta;
                thisPos.y = (float)height + delta;
                col = UnityEngine.Color.red;

                player.SendConsoleCommand("ddraw.arrow", persistSeconds, col, lastPos, thisPos, 0.25);
            }
        }
        void drawPerimeterPoints(BasePlayer player, List<Point> perimeterPoints, double height)
        {
            //Puts("Drawing perimeter points!");
            int persistSeconds = 10;
            Vector3 lastPos;
            Vector3 thisPos;

            height += perimeterHeightDelta;

            for (int p = 0; p < perimeterPoints.Count - 1; p++)
            {
                lastPos = new Vector3();
                thisPos = new Vector3();

                lastPos.x = (float)perimeterPoints[p].x;
                lastPos.y = (float)height;
                lastPos.z = (float)perimeterPoints[p].y;

                thisPos.x = (float)perimeterPoints[p + 1].x;
                thisPos.y = (float)height;
                thisPos.z = (float)perimeterPoints[p + 1].y;

                player.SendConsoleCommand("ddraw.arrow", persistSeconds, UnityEngine.Color.red, lastPos, thisPos, 0.25);
            }

            if (perimeterPoints.Count > 2)
            {
                lastPos = new Vector3();
                thisPos = new Vector3();

                lastPos.x = (float)perimeterPoints[perimeterPoints.Count - 1].x;
                lastPos.y = (float)height;
                lastPos.z = (float)perimeterPoints[perimeterPoints.Count - 1].y;

                thisPos.x = (float)perimeterPoints[0].x;
                thisPos.y = (float)height;
                thisPos.z = (float)perimeterPoints[0].y;

                player.SendConsoleCommand("ddraw.arrow", persistSeconds, UnityEngine.Color.green, lastPos, thisPos, 0.25);
            }
        }
        void FindAllFrom(BasePlayer player, string perimeterName)
        {
            if (getPerimeterIndex(player.userID, perimeterName).perimeterIndex != -1)
            {
                SendReply(player, "You already have a perimeter called " + perimeterName + ". Do /rs delete <index> to remove it, or choose another name.");
                return;
            }

            int pCount = countPerimeters(player.userID);

            if (pCount >= maxPerimetersPerPlayer && getAuthLevel(player.userID) < 1)
            {
                SendReply(player, "You already have the maximum of " + maxPerimetersPerPlayer.ToString() + " perimeters on this server.  Do /rs delete <index>.");
                return;
            }

            if (useCupboards)
            {
                if (!hasTotalAccess(player) && getAuthLevel(player.userID) < 1)
                {
                    SendReply(player, "You must be authorised on a nearby cupboard to create a perimeter.");
                    return;
                }
            }

            Point nextPnt;
            List<Point> perimeterPoints = new List<Point>();
            List<Face> faces = new List<Face>();
            List<Vector3> positions = new List<Vector3>();
            List<Quaternion> rotations = new List<Quaternion>();
            List<string> foundationNames = new List<string>();
            List<UnityEngine.Collider> wasProcessed = new List<UnityEngine.Collider>();

            positions.Add(player.transform.position);

            int entryCount = 0;
            int currentPos = 0;

            while (true)
            {
                //need to add height checks and perimeter size checks here
                currentPos++;
                if (currentPos > positions.Count)
                    break;
                var objects = UnityEngine.Physics.OverlapSphere(positions[currentPos - 1], 3f);

                foreach (var obj in objects)
                {
                    if (!(wasProcessed.Contains(obj)))
                    {
                        wasProcessed.Add(obj);
                        if (obj.GetComponentInParent<BuildingBlock>() != null)
                        {
                            BuildingBlock fBuildingBlock = obj.GetComponentInParent<BuildingBlock>();
                            //Puts(fBuildingBlock.blockDefinition.info.name.english);

                            string name = fBuildingBlock.blockDefinition.info.name.english;

                            if (name == "Floor") { name = "Foundation"; }
                            if (name == "Floor Triangle") { name = "Triangle Foundation"; }

                            if (name == "Foundation" || name == "Triangle Foundation")
                            {
                                if (Math.Abs(positions[0].y - fBuildingBlock.transform.position.y) < 0.2)
                                {
                                    positions.Add(fBuildingBlock.transform.position);
                                    rotations.Add(fBuildingBlock.transform.rotation);
                                    foundationNames.Add(name);
                                }
                            }
                        }
                    }
                }
            }

            //remove our startpos as it's not a foundation
            if (positions.Count > 1)
            {
                positions.RemoveAt(0);
            }
            else
            {
                SendReply(player, "No foundations within range. Try setting a perimeter manually with /rs start <name>.");
                return;
            }

            //Puts("Faces construction starting.");
            //we now have our lists of foundations info
            double height = positions[0].y;

            for (int i = 0; i < positions.Count; i++)
            {
                Point f = new Point();
                f.x = positions[i].x;
                f.y = positions[i].z;

                Quat q = new Quat();
                q.w = rotations[i].w;
                q.x = rotations[i].x;
                q.y = rotations[i].y;
                q.z = rotations[i].z;

                double rectWidth = 3f;
                Euler e = GetEulerAngles(q);
                double angle = -e.z;

                double minX = 65535;
                double minY = 65535;
                double maxX = -65535;
                double maxY = -65535;

                if (foundationNames[i].Equals("Foundation"))
                {
                    Rect r = new Rect();
                    r.points[0].x = f.x;
                    r.points[0].y = f.y;

                    //1
                    r.points[1].x = Math.Cos(angle) * rectWidth;
                    r.points[1].x += r.points[0].x;
                    r.points[1].y = Math.Sin(angle) * rectWidth;
                    r.points[1].y += r.points[0].y;

                    Point vec = new Point();
                    vec.x = r.points[1].x - r.points[0].x;
                    vec.y = r.points[1].y - r.points[0].y;

                    double tmpX;
                    tmpX = vec.x;
                    vec.x = -vec.y;
                    vec.y = tmpX;

                    //2
                    r.points[2].x = r.points[1].x + vec.x;
                    r.points[2].y = r.points[1].y + vec.y;

                    tmpX = vec.x;
                    vec.x = -vec.y;
                    vec.y = tmpX;

                    //3
                    r.points[3].x = r.points[2].x + vec.x;
                    r.points[3].y = r.points[2].y + vec.y;

                    for (int a = 0; a < 4; a++)
                    {
                        if (r.points[a].x < minX) { minX = r.points[a].x; }
                        if (r.points[a].y < minY) { minY = r.points[a].y; }
                        if (r.points[a].x > maxX) { maxX = r.points[a].x; }
                        if (r.points[a].y > maxY) { maxY = r.points[a].y; }
                    }

                    double cx = minX + ((maxX - minX) / 2);
                    double cy = minY + ((maxY - minY) / 2);

                    double dx = cx - f.x;
                    double dy = cy - f.y;

                    for (int a = 0; a < 4; a++)
                    {
                        r.points[a].x -= dx;
                        r.points[a].y -= dy;
                    }

                    for (int a = 0; a < 4; a++)
                    {
                        Face fce = new Face();
                        fce.sx = r.points[a].x;
                        fce.sy = r.points[a].y;

                        if (a != 3)
                        {
                            fce.ex = r.points[a + 1].x;
                            fce.ey = r.points[a + 1].y;
                        }
                        else
                        {
                            fce.ex = r.points[0].x;
                            fce.ey = r.points[0].y;
                        }

                        fce.name = "Foundation";
                        faces.Add(fce);
                    }
                }
                else
                {
                    Rect t = new Rect();
                    t.points[0].x = f.x;
                    t.points[0].y = f.y;

                    //1
                    t.points[1].x = Math.Cos(angle) * rectWidth;
                    t.points[1].x += t.points[0].x;
                    t.points[1].y = Math.Sin(angle) * rectWidth;
                    t.points[1].y += t.points[0].y;

                    //2
                    double deg60rad = 0.33333333 * Math.PI;
                    angle += deg60rad;

                    t.points[2].x = Math.Cos(angle) * rectWidth;
                    t.points[2].x += t.points[0].x;
                    t.points[2].y = Math.Sin(angle) * rectWidth;
                    t.points[2].y += t.points[0].y;

                    for (int a = 0; a < 2; a++)
                    {
                        if (t.points[a].x < minX) { minX = t.points[a].x; }
                        if (t.points[a].y < minY) { minY = t.points[a].y; }
                        if (t.points[a].x > maxX) { maxX = t.points[a].x; }
                        if (t.points[a].y > maxY) { maxY = t.points[a].y; }
                    }

                    double cx = minX + ((maxX - minX) / 2);
                    double cy = minY + ((maxY - minY) / 2);

                    double dx = cx - f.x;
                    double dy = cy - f.y;

                    for (int a = 0; a < 3; a++)
                    {
                        t.points[a].x -= dx;
                        t.points[a].y -= dy;
                    }

                    for (int a = 0; a < 3; a++)
                    {
                        Face fce = new Face();
                        fce.sx = t.points[a].x;
                        fce.sy = t.points[a].y;

                        if (a != 2)
                        {
                            fce.ex = t.points[a + 1].x;
                            fce.ey = t.points[a + 1].y;
                        }
                        else
                        {
                            fce.ex = t.points[0].x;
                            fce.ey = t.points[0].y;
                        }

                        fce.name = "Triangle Foundation";
                        faces.Add(fce);
                        //Puts("Added triangle face.");
                    }
                }
            }

            //Puts("Constructed " + faces.Count.ToString() + " faces.");
            //Puts("Starting removal of overlapping faces - " + faces.Count.ToString());

            //all foundations added and faces created
            //remove overlapping faces
            int facesIndex = 0;
            int facesIndex2 = 0;

            while (facesIndex < faces.Count)
            {
                facesIndex2 = facesIndex + 1;

                while (facesIndex2 < faces.Count)
                {
                    if (doFacesOverlap(facesIndex, facesIndex2, faces))
                    {
                        faces.RemoveAt(facesIndex2);
                        faces.RemoveAt(facesIndex);
                        facesIndex--;
                        break;
                    }

                    facesIndex2++;
                }

                facesIndex++;
            }

            //Puts("Finished removing overlapping faces." + faces.Count.ToString());

            int startIndex = -1;
            bool doPerimeter = true;

            if (doPerimeter)
            {
                startIndex = 0;
                Point pt = new Point();
                pt.x = faces[startIndex].sx;
                pt.y = faces[startIndex].sy;
                perimeterPoints.Add(pt);

                pt = new Point();
                pt.x = faces[startIndex].ex;
                pt.y = faces[startIndex].ey;
                perimeterPoints.Add(pt);

                faces.RemoveAt(startIndex);

                int loopCnt = 0;
                bool foundNext = false;
                int maxLoops = faces.Count;

                while (true)
                {
                    foundNext = false;
                    if (loopCnt > maxLoops)
                    {
                        SendReply(player, faces.Count.ToString() + " - Error auto creating perimeter.  Try creating one manually using /rs start <name>.");
                        return;
                    }
                    loopCnt++;

                    for (int i = 0; i < faces.Count; i++)
                    {
                        nextPnt = doFacesJoinTogether(perimeterPoints, i, faces);

                        if (nextPnt.x != -65535)
                        {
                            foundNext = true;
                            perimeterPoints.Add(nextPnt);
                            faces.RemoveAt(i);
                            break;
                        }
                    }

                    if (!foundNext) { break; }
                }

                perimeterPoints = removePointlessPoints(perimeterPoints);

                if (perimeterPoints.Count > maxPerimeterPoints && getAuthLevel(player.userID) < 1)
                {
                    SendReply(player, "Perimeter exceeds the maximum number of points. (" + maxPerimeterPoints.ToString() + ").");
                    return;
                }

                int perimeterIndex = getPerimeterIndex(player.userID);

                if (perimeterIndex == -1)
                {
                    Perimeter per = new Perimeter();
                    per.steamid = player.userID;

                    perimeters.Add(per);
                    perimeterDict.Add(player.userID, perimeters.Count - 1);
                    perimeterIndex = perimeters.Count - 1;
                }

                PlayerPerimeter pPer = new PlayerPerimeter();
                pPer.name = perimeterName;
                pPer.id = (uint)rnd.Next(1000, 999999999);
                pPer.finished = true;

                //exclude the last perimeter point as it'll be equal to our first
                for (int i = 0; i < perimeterPoints.Count - 1; i++)
                {
                    Vector3 v = new Vector3();
                    v.x = (float)perimeterPoints[i].x;
                    v.y = (float)height;
                    v.z = (float)perimeterPoints[i].y;

                    pPer.coords.Add(v);
                }

                perimeters[perimeterIndex].playerPerimeters.Add(pPer);
                PerimeterPosition pPos = new PerimeterPosition();
                pPos.perimeterIndex = perimeterIndex;
                pPos.playerPerimeterIndex = perimeters[perimeterIndex].playerPerimeters.Count - 1;

                if (!findTolerances(pPos) && getAuthLevel(player.userID) < 1)
                {
                    SendReply(player, "Perimeter exceeds maximum allowed size of " + maxPerimeterDelta.ToString() + " x " + maxPerimeterDelta.ToString() + ".");
                    perimeters[perimeterIndex].playerPerimeters.RemoveAt(perimeters[perimeterIndex].playerPerimeters.Count - 1);
                    return;
                }
                else
                {
                    plotPerimeter(player, perimeterIndex, perimeters[perimeterIndex].playerPerimeters.Count - 1);
                    sortPlayerPerimeters(perimeterIndex);
                    addValidationRequest(player.userID, false);
                    sendTestAlert(player);
                    ignorePlayer(player.userID, player.userID, player.displayName);
                    SendReply(player, "Perimeter entry successful.");
                }
                //drawPerimeterPoints(player, perimeterPoints, height);
            }
            else
            {
                drawFaces(player, faces, height);
            }
        }
        bool findTolerances(PerimeterPosition pPos)
        {
            //max and min and report if over max
            double minX = 65535;
            double maxX = -65535;
            double minY = 65535;
            double maxY = -65535;
            double x = 0;
            double y = 0;

            for (int i = 0; i < perimeters[pPos.perimeterIndex].playerPerimeters[pPos.playerPerimeterIndex].coords.Count; i++)
            {
                x = perimeters[pPos.perimeterIndex].playerPerimeters[pPos.playerPerimeterIndex].coords[i].x;
                y = perimeters[pPos.perimeterIndex].playerPerimeters[pPos.playerPerimeterIndex].coords[i].z;

                if (x < minX) { minX = x; }
                if (x > maxX) { maxX = x; }
                if (y < minY) { minY = y; }
                if (y > maxY) { maxY = y; }
            }

            if (maxX - minX > maxPerimeterDelta || maxY - minY > maxPerimeterDelta)
            {
                return false;
            }

            perimeters[pPos.perimeterIndex].playerPerimeters[pPos.playerPerimeterIndex].minX = minX;
            perimeters[pPos.perimeterIndex].playerPerimeters[pPos.playerPerimeterIndex].minY = minY;
            perimeters[pPos.perimeterIndex].playerPerimeters[pPos.playerPerimeterIndex].maxX = maxX;
            perimeters[pPos.perimeterIndex].playerPerimeters[pPos.playerPerimeterIndex].maxY = maxY;
            return true;
        }
        int getAuthIndex(ulong steamid)
        {
            if (authDict.ContainsKey(steamid))
            {
                return authDict[steamid];
            }

            return -1;
        }
        int getAuthLevel(ulong steamid)
        {
            if (authDict.ContainsKey(steamid))
            {
                return authList[authDict[steamid]].level;
            }

            return -1;
        }
        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
            }
            return value;
        }
        Euler GetEulerAngles(Quat q)
        {
            double yaw, pitch, roll;
            double w2 = q.w * q.w;
            double x2 = q.x * q.x;
            double y2 = q.y * q.y;
            double z2 = q.z * q.z;
            double unitLength = w2 + x2 + y2 + z2;
            double abcd = q.w * q.x + q.y * q.z;
            double eps = 0.0000001;
            //double pi = Math.PI;

            if (abcd > (0.5 - eps) * unitLength)
            {
                //yaw = 2 * Math.Atan2(q.y, q.w);
                //pitch = pi;
                roll = 0;
            }
            else
            {
                if (abcd < (-0.5 + eps) * unitLength)
                {
                    //yaw = -2 * Math.Atan2(q.y, q.w);
                    //pitch = -pi;
                    roll = 0;
                }
                else
                {
                    //double adbc = q.w * q.z - q.x * q.y;
                    double acbd = q.w * q.y - q.x * q.z;
                    //yaw = Math.Atan2(2 * adbc, 1 - 2 * (z2 + x2));
                    //pitch = Math.Asin(2 * abcd / unitLength);
                    roll = Math.Atan2(2 * acbd, 1 - 2 * (y2 + x2));
                }
            }

            Euler e = new Euler();
            e.x = 0;//yaw;
            e.y = 0;// pitch;
            e.z = roll;

            return e;
        }
        int getIgnoreListIndex(ulong steamid)
        {
            if (ignoreDict.ContainsKey(steamid))
            {
                return (ignoreDict[steamid]);
            }

            return -1;
        }
        PerimeterPosition getInProgress(ulong steamid)
        {
            PerimeterPosition pPos = new PerimeterPosition();
            int i = getPerimeterIndex(steamid);

            if (i != -1)
            {
                for (int p = 0; p < perimeters[i].playerPerimeters.Count; p++)
                {
                    if (!perimeters[i].playerPerimeters[p].finished)
                    {
                        pPos.perimeterIndex = i;
                        pPos.playerPerimeterIndex = p;
                        return pPos;
                    }
                }
            }

            pPos.perimeterIndex = -1;
            pPos.playerPerimeterIndex = -1;
            return pPos;
        }
        int getPerimeterIndex(ulong steamid)
        {
            if (perimeterDict.ContainsKey(steamid))
            {
                return perimeterDict[steamid];
            }

            return -1;
        }
        PerimeterPosition getPerimeterIndex(ulong steamid, string name)
        {
            PerimeterPosition pPos = new PerimeterPosition();
            int i = -1;

            if (perimeterDict.ContainsKey(steamid))
            {
                i = perimeterDict[steamid];
            }

            if (i != -1)
            {
                for (int p = 0; p < perimeters[i].playerPerimeters.Count; p++)
                {
                    if (perimeters[i].playerPerimeters[p].name == name)
                    {
                        pPos.perimeterIndex = i;
                        pPos.playerPerimeterIndex = p;
                        return pPos;
                    }
                }
            }

            pPos.perimeterIndex = -1;
            pPos.playerPerimeterIndex = -1;
            return pPos;
        }
        int getPlayerIndex(ulong steamid)
        {
            for (int i = 0; i < allBasePlayer.Count; i++)
            {
                if (allBasePlayer[i].userID == steamid)
                {
                    return i;
                }
            }

            return -1;
        }
        void hashAuths()
        {
            authDict.Clear();

            for (int i = 0; i < authList.Count; i++)
            {
                authDict.Add(authList[i].steamid, i);
            }
        }
        void hashIgnores()
        {
            ignoreDict.Clear();

            for (int i = 0; i < ignoreList.Count; i++)
            {
                ignoreDict.Add(ignoreList[i].steamid, i);
            }
        }
        void hashPerimeters()
        {
            perimeterDict.Clear();

            for (int i = 0; i < perimeters.Count; i++)
            {
                perimeterDict.Add(perimeters[i].steamid, i);
            }
        }
        bool hasTotalAccess(BasePlayer player)
        {
            List<BuildingPrivlidge> playerpriv = buildingPrivlidges.GetValue(player) as List<BuildingPrivlidge>;
            if (playerpriv.Count == 0)
            {
                return false;
            }
            foreach (BuildingPrivlidge priv in playerpriv.ToArray())
            {
                List<ProtoBuf.PlayerNameID> authorized = priv.authorizedPlayers;
                bool foundplayer = false;
                foreach (ProtoBuf.PlayerNameID pni in authorized.ToArray())
                {
                    if (pni.userid == player.userID)
                        foundplayer = true;
                }
                if (!foundplayer)
                {
                    return false;
                }
            }
            return true;
        }
        void ignoreDetect(BasePlayer player)
        {
            int perimeterIndex = getPerimeterIndex(player.userID);

            if (perimeterIndex == -1)
            {
                SendReply(player, "You have no perimeters to check.  Do /rs set <name>.");
            }
            else
            {

                int ignoredCount = 0;

                for (int i = 0; i < allBasePlayer.Count; i++)
                {
                    for (int p = 0; p < perimeters[perimeterIndex].playerPerimeters.Count; p++)
                    {
                        PerimeterPosition pPos = new PerimeterPosition();
                        pPos.perimeterIndex = perimeterIndex;
                        pPos.playerPerimeterIndex = p;

                        int wn = windingPoly(allBasePlayer[i].transform.position, pPos);

                        if (wn != 0)
                        {
                            bool match = false;
                            int ignoreListIndex = getIgnoreListIndex(player.userID);

                            if (ignoreListIndex != -1)
                            {
                                bool playerMatch = false;

                                for (int pl = 0; pl < ignoreList[ignoreListIndex].ignores.Count; pl++)
                                {
                                    if (ignoreList[ignoreListIndex].ignores[pl].steamid == allBasePlayer[i].userID)
                                    {
                                        playerMatch = true;
                                        if (ignoreList[ignoreListIndex].ignores[pl].name != allBasePlayer[i].displayName)
                                        {
                                            ignoreList[ignoreListIndex].ignores[pl].name = allBasePlayer[i].displayName;
                                            SendReply(player, "Added " + allBasePlayer[i].displayName + " " + allBasePlayer[i].userID.ToString() + " to your ignore list.");
                                            ignoredCount++;
                                            break;
                                        }
                                    }
                                }

                                if (!playerMatch)
                                {
                                    IgnoredPlayer ip = new IgnoredPlayer();
                                    ip.steamid = allBasePlayer[i].userID;
                                    ip.name = allBasePlayer[i].displayName;

                                    ignoreList[ignoreListIndex].ignores.Add(ip);
                                    sortIgnores(ignoreListIndex);
                                    SendReply(player, "Added " + allBasePlayer[i].displayName + " " + allBasePlayer[i].userID.ToString() + " to your ignore list.");
                                    ignoredCount++;
                                }
                            }
                            else
                            {
                                IgnoreListEntry ie = new IgnoreListEntry();
                                ie.steamid = player.userID;

                                IgnoredPlayer ip = new IgnoredPlayer();
                                ip.steamid = allBasePlayer[i].userID;
                                ip.name = allBasePlayer[i].displayName;

                                ie.ignores.Add(ip);
                                ignoreList.Add(ie);
                                ignoreDict.Add(player.userID, ignoreList.Count - 1);
                                SendReply(player, "Added " + allBasePlayer[i].displayName + " " + allBasePlayer[i].userID.ToString() + " to your ignore list.");
                                ignoredCount++;
                            }
                        }
                    }
                }

                if (ignoredCount == 0)
                {
                    SendReply(player, "No players were found within your perimeters to add to the ignore list.");
                }
            }
        }
        void ignorePlayer(BasePlayer player, string[] args)
        {
            if (args.Length > 2)
            {
                if (args[1].Length == 17)
                {
                    if (args[1].Substring(0, 6) == "765611")
                    {
                        ulong steamid;

                        try
                        {
                            steamid = Convert.ToUInt64(args[1]);
                        }
                        catch (Exception e)
                        {
                            SendReply(player, "Please enter a valid Steam ID.");
                            return;
                        }

                        if (args[2] == "")
                        {
                            SendReply(player, "Please enter a valid player name after the Steam ID.");
                            return;
                        }

                        IgnoredPlayer plr;
                        IgnoreListEntry ie;

                        int ignoreListIndex = getIgnoreListIndex(player.userID);

                        if (ignoreListIndex != -1)
                        {
                            for (int p = 0; p < ignoreList[ignoreListIndex].ignores.Count; p++)
                            {
                                if (ignoreList[ignoreListIndex].ignores[p].steamid == steamid)
                                {
                                    if (ignoreList[ignoreListIndex].ignores[p].name != args[2])
                                    {
                                        ignoreList[ignoreListIndex].ignores[p].name = args[2];
                                        SendReply(player, "Updated ignore list entry.");
                                    }
                                    else
                                    {
                                        SendReply(player, "Player is already ignored.");
                                    }
                                    return;
                                }
                            }
                        }

                        if (ignoreListIndex == -1)
                        {
                            ie = new IgnoreListEntry();
                            ie.steamid = player.userID;

                            plr = new IgnoredPlayer();
                            plr.steamid = steamid;
                            plr.name = args[2];

                            ie.ignores.Add(plr);
                            ignoreList.Add(ie);
                            ignoreDict.Add(player.userID, ignoreList.Count - 1);

                            SendReply(player, "Added " + args[2] + " - " + args[1] + " to your ignore list.");
                            return;
                        }
                        else
                        {
                            plr = new IgnoredPlayer();
                            plr.steamid = steamid;
                            plr.name = args[2];

                            ignoreList[ignoreListIndex].ignores.Add(plr);
                            sortIgnores(ignoreListIndex);
                            SendReply(player, "Added " + args[2] + " - " + args[1] + " to your ignore list.");
                            return;
                        }
                    }
                }

                SendReply(player, "Please enter a SteamID and a name to add to your ignore list on this server.");
            }
            else
            {
                if (args.Length == 2)
                {
                    if (args[1].Length == 17)
                    {
                        if (args[1].Substring(0, 6) == "765611")
                        {
                            ulong steamid;

                            try
                            {
                                steamid = Convert.ToUInt64(args[1]);
                            }
                            catch (Exception e)
                            {
                                SendReply(player, "Please enter a valid Steam ID.");
                                return;
                            }

                            for (int a = 0; a < allBasePlayer.Count; a++)
                            {
                                if (allBasePlayer[a].userID == steamid)
                                {
                                    IgnoredPlayer plr = new IgnoredPlayer();
                                    int ignoreListIndex = getIgnoreListIndex(player.userID);

                                    plr.steamid = steamid;
                                    plr.name = allBasePlayer[a].displayName;

                                    if (ignoreListIndex == -1)
                                    {
                                        IgnoreListEntry ie = new IgnoreListEntry();
                                        ie.steamid = player.userID;
                                        ie.ignores.Add(plr);
                                        ignoreList.Add(ie);
                                        ignoreDict.Add(player.userID, ignoreList.Count - 1);
                                        SendReply(player, "Added " + plr.name + " - " + plr.steamid.ToString() + " to your ignore list.");
                                        return;
                                    }
                                    else
                                    {
                                        for (int p = 0; p < ignoreList[ignoreListIndex].ignores.Count; p++)
                                        {
                                            if (ignoreList[ignoreListIndex].ignores[p].steamid == steamid)
                                            {
                                                if (ignoreList[ignoreListIndex].ignores[p].name != plr.name)
                                                {
                                                    ignoreList[ignoreListIndex].ignores[p].name = plr.name;
                                                    SendReply(player, "Updated ignore list entry.");
                                                }
                                                else
                                                {
                                                    SendReply(player, "Player is already ignored.");
                                                }
                                                return;
                                            }
                                        }

                                        ignoreList[ignoreListIndex].ignores.Add(plr);
                                        SendReply(player, "Added " + plr.name + " - " + plr.steamid.ToString() + " to your ignore list.");
                                        return;
                                    }
                                }
                            }
                            SendReply(player, "No players with that SteamID are currently online.");
                        }
                    }
                    else
                    {
                        for (int a = 0; a < allBasePlayer.Count; a++)
                        {
                            if (allBasePlayer[a].displayName.Length >= args[1].Length)
                            {
                                if (allBasePlayer[a].displayName.Substring(0, args[1].Length) == args[1])
                                {
                                    int r = checkDupes(args[1]);

                                    if (r >= 0)
                                    {
                                        ulong steamid = allBasePlayer[a].userID;
                                        int ignoreListIndex = getIgnoreListIndex(player.userID);

                                        IgnoredPlayer plr = new IgnoredPlayer();
                                        plr.steamid = steamid;
                                        plr.name = allBasePlayer[a].displayName;

                                        if (ignoreListIndex != -1)
                                        {
                                            for (int p = 0; p < ignoreList[ignoreListIndex].ignores.Count; p++)
                                            {
                                                if (ignoreList[ignoreListIndex].ignores[p].steamid == steamid)
                                                {
                                                    if (ignoreList[ignoreListIndex].ignores[p].name != plr.name)
                                                    {
                                                        ignoreList[ignoreListIndex].ignores[p].name = plr.name;
                                                        SendReply(player, "Updated ignore list entry.");
                                                    }
                                                    else
                                                    {
                                                        SendReply(player, "Player is already ignored.");
                                                    }
                                                    return;
                                                }
                                            }

                                            ignoreList[ignoreListIndex].ignores.Add(plr);
                                            SendReply(player, "Added " + plr.name + " - " + steamid.ToString() + " to your ignore list.");
                                            return;
                                        }
                                        else
                                        {
                                            IgnoreListEntry ie = new IgnoreListEntry();
                                            ie.steamid = player.userID;
                                            ie.ignores.Add(plr);
                                            ignoreList.Add(ie);
                                            ignoreDict.Add(player.userID, ignoreList.Count - 1);
                                            SendReply(player, "Added " + plr.name + " - " + steamid.ToString() + " to your ignore list.");
                                            return;
                                        }
                                    }
                                    else
                                    {
                                        if (r == -2)
                                        {
                                            SendReply(player, "There is more than 1 player with that name.");
                                        }
                                        else
                                        {
                                            SendReply(player, "There are no players with that name.");
                                        }
                                        return;
                                    }
                                }
                            }
                        }
                        SendReply(player, "Please enter a the name or the SteamID of an online player.");
                    }
                }
                else
                {
                    SendReply(player, "Please enter a SteamID and a name to add to your ignore list on this server.");
                }
            }
        }
        bool ignorePlayer(ulong baseSteamID, ulong otherPlayerSteamID, string otherPlayerName)
        {
            bool baseMatch = false;

            int i = getIgnoreListIndex(baseSteamID);

            if (i != -1)
            {
                baseMatch = true;

                for (int a = 0; a < ignoreList[i].ignores.Count; a++)
                {
                    if (ignoreList[i].ignores[a].steamid == otherPlayerSteamID)
                    {
                        return false;
                    }
                }

                IgnoredPlayer p = new IgnoredPlayer();
                p.steamid = otherPlayerSteamID;
                p.name = otherPlayerName;
                ignoreList[i].ignores.Add(p);
                sortIgnores(i);
                return true;
            }

            if (!baseMatch)
            {
                IgnoreListEntry il = new IgnoreListEntry();
                il.steamid = baseSteamID;

                IgnoredPlayer p = new IgnoredPlayer();
                p.steamid = otherPlayerSteamID;
                p.name = otherPlayerName;

                il.ignores.Add(p);
                ignoreList.Add(il);
                ignoreDict.Add(baseSteamID, ignoreList.Count - 1);
                return true;
            }

            return false;
        }
        bool isInProgress(ulong steamid)
        {
            int i = getPerimeterIndex(steamid);

            if (i != -1)
            {
                for (int p = 0; p < perimeters[i].playerPerimeters.Count; p++)
                {
                    if (!perimeters[i].playerPerimeters[p].finished)
                    {
                        return true;
                    }
                }
            }

            return false;
        }
        bool isPerimeterNameInUse(ulong steamid, string name)
        {
            int i = getPerimeterIndex(steamid);

            if (i != -1)
            {
                for (int p = 0; p < perimeters[i].playerPerimeters.Count; p++)
                {
                    if (perimeters[i].playerPerimeters[p].name == name)
                    {
                        return true;
                    }
                }
            }

            return false;
        }
        bool isPlayerIgnored(ulong steamid, ulong tpsteamid)
        {
            int index = getIgnoreListIndex(steamid);

            if (index != -1)
            {
                for (int i = 0; i < ignoreList[index].ignores.Count; i++)
                {
                    if (ignoreList[index].ignores[i].steamid == tpsteamid)
                    {
                        return true;
                    }
                }
            }
            return false;
        }
        bool isServerModerator(BasePlayer player)
        {
            if (player.net.connection != null)
            {
                if (player.net.connection.authLevel >= 1)
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }
            return false;
        }
        bool isValidated(ulong steamid)
        {
            if (validated.Contains(steamid))
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        double isLeft(Vector3 p0, Vector3 p1, Vector3 p2)
        {
            return ((p1.x - p0.x) * (p2.z - p0.z) - (p2.x - p0.x) * (p1.z - p0.z));
        }
        void LoadDataFiles()
        {
            if (!updatedOldData)
            {
                try
                {
                    OldValidatedObjectDict oldValObj = Interface.Oxide.DataFileSystem.ReadObject<OldValidatedObjectDict>("RaidAlert");
                    convertOldValObjs(oldValObj);
                }
                catch (Exception e)
                {
                    //Puts(e.ToString());
                    //Puts("No validations to migrate");
                }

                try
                {
                    OldAuthObjectDict oldAuthObj = Interface.Oxide.DataFileSystem.ReadObject<OldAuthObjectDict>("RaidAlert");
                    convertOldAuthObjs(oldAuthObj);
                }
                catch (Exception e)
                {
                    //Puts("No auths to migrate");
                }

                try
                {
                    OldMuteList oldMuteList = Interface.Oxide.DataFileSystem.ReadObject<OldMuteList>("RaidAlert");
                    convertOldMuteList(oldMuteList);
                }
                catch (Exception e)
                {
                    //Puts("No muted list to migrate");
                }

                try
                {
                    OldIgnoresObjectDict oldIgnoresObj = Interface.Oxide.DataFileSystem.ReadObject<OldIgnoresObjectDict>("RaidAlert");
                    convertOldIgnoresObjs(oldIgnoresObj);
                }
                catch (Exception e)
                {
                    //Puts("No ignores to migrate");
                    //Puts(e.ToString());
                }

                try
                {
                    OldAlertsObjectDict oldAlertsObj = Interface.Oxide.DataFileSystem.ReadObject<OldAlertsObjectDict>("RaidAlert");
                    convertOldAlertsObj(oldAlertsObj);
                }
                catch (Exception e)
                {
                    //Puts("No perimeters to migrate");
                    //Puts(e.ToString());
                }

                updatedOldData = true;
                saveDataFiles();
                saveConfiguration();
                return;
            }

            //try
            //{
            //oldSaveObj = Interface.Oxide.DataFileSystem.ReadObject<OldSaveObject>("RaidAlert");
            //Puts("Converting old save.");
            //convertOldSave(oldSaveObj);
            //return;
            //}
            //catch (Exception e)
            //{
            //    Puts();
            //    //old save doesn't exist
            //}

            //Load our perimeter/user data here
            SaveObject saveObj = null;

            try
            {
                saveObj = Interface.Oxide.DataFileSystem.ReadObject<SaveObject>("RaidAlert v1");
            }
            catch (Exception e)
            {
                //data file missing, so skip
                return;
            }

            if (saveObj.validated == null) { return; }
            validated = saveObj.validated;
            muteList = saveObj.muteList;
            authList = saveObj.authList;
            ignoreList = saveObj.ignoreList;

            List<SavePerimeterEntry> savePerimeters = Interface.Oxide.DataFileSystem.ReadObject<List<SavePerimeterEntry>>("RaidAlert - Perimeters - delete on server wipe");

            for (int i = 0; i < savePerimeters.Count; i++)
            {
                int baseIndex = getPerimeterIndex(savePerimeters[i].steamid);

                if (baseIndex == -1)
                {
                    //create new base entry
                    Perimeter p = new Perimeter();
                    p.steamid = savePerimeters[i].steamid;
                    perimeters.Add(p);
                    perimeterDict.Add(p.steamid, perimeters.Count - 1);
                    baseIndex = perimeters.Count - 1;
                }

                //add new player perimeter to base entry
                PlayerPerimeter pl = new PlayerPerimeter();
                pl.name = savePerimeters[i].name;
                pl.finished = savePerimeters[i].finished;
                pl.id = savePerimeters[i].id;
                pl.minX = savePerimeters[i].minX;
                pl.minY = savePerimeters[i].minY;
                pl.maxX = savePerimeters[i].maxX;
                pl.maxY = savePerimeters[i].maxY;
                pl.sleeperPresent = savePerimeters[i].sleeperPresent;

                for (int i2 = 0; i2 < savePerimeters[i].coordsX.Count; i2++)
                {
                    Vector3 v = new Vector3();
                    v.x = (float)savePerimeters[i].coordsX[i2];
                    v.y = (float)savePerimeters[i].coordsY[i2];
                    v.z = (float)savePerimeters[i].coordsZ[i2];
                    pl.coords.Add(v);
                }
                perimeters[baseIndex].playerPerimeters.Add(pl);
            }

            hashAuths();
            hashIgnores();
        }
        protected override void LoadDefaultConfig()
        {
            Puts("Rusty Sheriff Raid Alert: Creating new config file");
            Config.Clear();
            saveConfiguration();
            LoadVariables();
        }
        void Loaded()
        {
            epoch = new System.DateTime(1970, 1, 1);
            LoadVariables();
            LoadDataFiles();

            for (int i = 0; i < 999; i++)
            {
                rnd.Next(0, 999999999);
            }

            buildingPrivlidges = typeof(BasePlayer).GetField("buildingPrivlidges", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
        }
        void loadOldConfig()
        {
            try
            {
                alertsVisibleInGame = Convert.ToBoolean(Config["alertsVisiblePlayers"]);
                enabledForAuthorisedUsersOnly = Convert.ToBoolean(Config["enabledForAuthorisedUsersOnly"]);
                maxPerimetersPerPlayer = (int)Config["maxAlertsPerPlayer"];
                maxPerimeterDelta = (int)Config["maxPerimeterDelta"];
                maxPerimeterPoints = (int)Config["maxPerimeterPoints"];
                syncWithRustySheriffServer = Convert.ToBoolean(Config["syncWithRustySheriffServer"]);
                timeBetweenChecks = (int)Config["timeBetweenChecks"];
                alertTriggeredOnlyWhenSleepingInPerimeter = Convert.ToBoolean(Config["alertTriggeredOnlyWhenSleepingInPerimeter"]);
                sendAnon = Convert.ToBoolean(Config["sendAnon"]);

                Puts("Config file updated successfully.");
            }
            catch (Exception e)
            {
                Puts("You may have upgraded from a version lower than 0.9.9.  Check your setttings in-game with /rs status, to make sure your options are as expected. Thanks");
            }

            saveConfiguration();
        }
        void LoadVariables()
        {
            bool configFound = false;

            var a = Config["OPTIONS", "Show alerts in-game"];

            if (a == null)
            {
                Puts("New version of config file not found.");
            }
            else
            {
                //Puts("New config file found.");
                configFound = true;
            }

            if (!configFound)
            {
                var a2 = Convert.ToBoolean(Config["alertsVisiblePlayers"]);
                if (a2 != null)
                {
                    Puts("Old config found.  Converting...");
                    loadOldConfig();
                    return;
                }
                else
                {
                    Puts("Old config not detected.");
                }
            }

            if (!configFound)
            {
                saveConfiguration();
                return;
            }

            updatedOldData = Convert.ToBoolean(GetConfig("SETTINGS", "Converted", false));
            maxPerimetersPerPlayer = Convert.ToInt32(GetConfig("OPTIONS", "Max perimeters per player", 4));
            timeBetweenChecks = Convert.ToInt32(GetConfig("OPTIONS", "Time between updates", 10));
            maxPerimeterDelta = Convert.ToInt32(GetConfig("OPTIONS", "Max perimeter size", 75));
            maxPerimeterPoints = Convert.ToInt32(GetConfig("OPTIONS", "Max points per perimeter", 50));
            maxPerimetersPerPlayer = Convert.ToInt32(GetConfig("OPTIONS", "Max perimeters per player", 4));

            sendAnon = Convert.ToBoolean(GetConfig("OPTIONS", "Hide names and SteamIDs from alerts", false));
            automaticCheckingEnabled = Convert.ToBoolean(GetConfig("OPTIONS", "Enable automatic perimeter checking", true));
            syncWithRustySheriffServer = Convert.ToBoolean(GetConfig("OPTIONS", "Sync alerts with the Raid Alert server", true));
            alertTriggeredOnlyWhenSleepingInPerimeter = Convert.ToBoolean(GetConfig("OPTIONS", "Alerts only triggered if player sleeping in their perimeter", false));
            alertsVisibleInGame = Convert.ToBoolean(GetConfig("OPTIONS", "Show alerts in-game", true));
            useCupboards = Convert.ToBoolean(GetConfig("OPTIONS", "Use cupboard authorisation when creating perimeters", false));
            enabledForAuthorisedUsersOnly = Convert.ToBoolean(GetConfig("OPTIONS", "Enabled for authorised users only", false));
        }
        void muteIngameAlerts(BasePlayer player, bool mute)
        {
            if (muteList.Contains(player.userID))
            {
                if (mute)
                {
                    SendReply(player, "Alerts are already muted in-game.");
                }
                else
                {
                    SendReply(player, "Alerts will be displayed in-game.");
                    muteList.Remove(player.userID);
                }
            }
            else
            {
                if (mute)
                {
                    SendReply(player, "Alerts will be muted in-game.");
                    muteList.Add(player.userID);
                }
                else
                {
                    SendReply(player, "Alerts are already unmuted.");
                }
            }
        }
        void OnPlayerDisconnected(BasePlayer player)
        {
            if (isInProgress(player.userID))
            {
                stopDrawing(player);
            }

            for (int i = 0; i < allBasePlayer.Count; i++)
            {
                if (allBasePlayer[i].userID == player.userID)
                {
                    int perimeterIndex = getPerimeterIndex(player.userID);

                    if (perimeterIndex == -1)
                    {
                        return;
                    }

                    for (int p = 0; p < perimeters[perimeterIndex].playerPerimeters.Count; p++)
                    {
                        PerimeterPosition pPos = new PerimeterPosition();
                        pPos.perimeterIndex = perimeterIndex;
                        pPos.playerPerimeterIndex = p;
                        int wn = windingPoly(player.transform.position, pPos);

                        if (wn != 0)
                        {
                            perimeters[perimeterIndex].playerPerimeters[p].sleeperPresent = true;
                            if (alertTriggeredOnlyWhenSleepingInPerimeter)
                            {
                                Puts("Player " + allBasePlayer[i].displayName + " disconnected within his perimeter, " + perimeters[perimeterIndex].playerPerimeters[p].name);
                            }
                        }
                    }
                }
            }
        }
        void OnPlayerSleepEnded(BasePlayer player)
        {
            if (isServerModerator(player))
            {
                setAuthLevel(player.userID, 2, player.displayName, null, true);
            }

            int perimeterIndex = getPerimeterIndex(player.userID);

            if (perimeterIndex != -1)
            {
                for (int p = 0; p < perimeters[perimeterIndex].playerPerimeters.Count; p++)
                {
                    perimeters[perimeterIndex].playerPerimeters[p].sleeperPresent = false;
                }
            }
        }
        void OnServerInitialized()
        {
        }
        void OnServerSave()
        {
            saveConfiguration();
            saveDataFiles();
        }
        void OnTick()
        {
            if (automaticCheckingEnabled)
            {
                if (currentTime() >= playerUpdateCheck)
                {
                    try
                    {
                        allBasePlayer = BasePlayer.activePlayerList;
                    }
                    catch (Exception e)
                    {

                    }
                    playerUpdateCheck = currentTime() + 30;
                }

                if (currentTime() >= nextCheck)
                {
                    int divisor = 1;

                    try
                    {
                        if (!adminsAuthed) { checkAdminsAuthed(); adminsAuthed = true; }
                        checkTrespass();
                        playerCheckIndex++;

                        if (playerCheckIndex >= allBasePlayer.Count)
                        {
                            updateRSSServer();
                            playerCheckIndex = 0;
                        }

                        if (allBasePlayer.Count > 1) { divisor = allBasePlayer.Count; }
                    }
                    catch (Exception e)
                    {
                    }

                    double delay = timeBetweenChecks / divisor;
                    nextCheck = currentTime() + delay;
                }
            }

            if (currentTime() >= drawCheck)
            {
                try
                {
                    for (int i = 0; i < drawList.Count; i++)
                    {
                        plotPerimeter(drawList[i].basePlayer, drawList[i].perimeterIndex, drawList[i].playerPerimeterIndex);
                    }
                }
                catch (Exception e)
                {
                }

                drawCheck = currentTime() + 4.9;
            }
        }
        void parseWebReply(int code, string response)
        {
            if (response.Length >= 2)
            {
                if (response.Substring(0, 2) == "OK")
                {
                    oldTrespassers = newTrespassers;
                    //oldTrespassers.Clear();

                    //for (int i = 0; i < newTrespassers.Count; i++)
                    //{
                    //    Trespasser t = new Trespasser();
                    //    t.steamid = newTrespassers[i].steamid;
                    //    t.name = newTrespassers[i].name;
                    //    t.trespasserSteamID = newTrespassers[i].trespasserSteamID;
                    //    t.alertText = newTrespassers[i].alertText;

                    //    oldTrespassers.Add(t);
                    //}

                    newTrespassers = new List<Trespasser>();

                    if (response.Length > 2)
                    {
                        respondToValRequests(response.Substring(2));
                    }
                }
                else
                {
                    newTrespassers.Clear();
                    oldTrespassers.Clear();
                }
            }
            else
            {
                newTrespassers.Clear();
                oldTrespassers.Clear();
            }
        }
        void plotPerimeter(BasePlayer player, int perimeterIndex, int playerPerimeterIndex)
        {
            int persistSeconds = 5;
            string name = perimeters[perimeterIndex].playerPerimeters[playerPerimeterIndex].name;

            if (perimeters[perimeterIndex].playerPerimeters[playerPerimeterIndex].finished) { persistSeconds = 20; }

            for (int p = 0; p < perimeters[perimeterIndex].playerPerimeters[playerPerimeterIndex].coords.Count; p++)
            {
                player.SendConsoleCommand("ddraw.text", persistSeconds, UnityEngine.Color.green, perimeters[perimeterIndex].playerPerimeters[playerPerimeterIndex].coords[p], name + " " + (p + 1).ToString());

                if (p > 0) { player.SendConsoleCommand("ddraw.arrow", persistSeconds, UnityEngine.Color.red, perimeters[perimeterIndex].playerPerimeters[playerPerimeterIndex].coords[p - 1], perimeters[perimeterIndex].playerPerimeters[playerPerimeterIndex].coords[p], 0.25); }
            }

            if (perimeters[perimeterIndex].playerPerimeters[playerPerimeterIndex].finished)
            {
                player.SendConsoleCommand("ddraw.arrow", persistSeconds, UnityEngine.Color.red, perimeters[perimeterIndex].playerPerimeters[playerPerimeterIndex].coords[perimeters[perimeterIndex].playerPerimeters[playerPerimeterIndex].coords.Count - 1], perimeters[perimeterIndex].playerPerimeters[playerPerimeterIndex].coords[0], 0.25);
            }
        }
        List<Point> removePointlessPoints(List<Point> perimeterPoints)
        {
            bool done;
            int perimeterIndex = 0;
            List<int> removalList = new List<int>();
            Point inVec = new Point();
            Point outVec = new Point();

            while (perimeterIndex < perimeterPoints.Count)
            {
                done = false;

                if (perimeterIndex == 0)
                {
                    done = true;

                    inVec.x = perimeterPoints[perimeterPoints.Count - 1].x;
                    inVec.y = perimeterPoints[perimeterPoints.Count - 1].y;

                    outVec.x = perimeterPoints[perimeterIndex + 1].x - perimeterPoints[perimeterIndex].x;
                    outVec.y = perimeterPoints[perimeterIndex + 1].y - perimeterPoints[perimeterIndex].y;
                }

                if (perimeterIndex == perimeterPoints.Count - 1 && !done)
                {
                    done = true;

                    inVec.x = perimeterPoints[perimeterIndex].x - perimeterPoints[perimeterIndex - 1].x;
                    inVec.y = perimeterPoints[perimeterIndex].y - perimeterPoints[perimeterIndex - 1].y;

                    outVec.x = perimeterPoints[0].x - perimeterPoints[perimeterIndex].x;
                    outVec.y = perimeterPoints[0].y - perimeterPoints[perimeterIndex].y;
                }

                if (!done)
                {
                    inVec.x = perimeterPoints[perimeterIndex].x - perimeterPoints[perimeterIndex - 1].x;
                    inVec.y = perimeterPoints[perimeterIndex].y - perimeterPoints[perimeterIndex - 1].y;

                    outVec.x = perimeterPoints[perimeterIndex + 1].x - perimeterPoints[perimeterIndex].x;
                    outVec.y = perimeterPoints[perimeterIndex + 1].y - perimeterPoints[perimeterIndex].y;
                }

                if (Math.Abs(inVec.x - outVec.x) < 0.1)
                {
                    if (Math.Abs(inVec.y - outVec.y) < 0.1)
                    {
                        removalList.Add(perimeterIndex);
                    }
                }

                perimeterIndex++;
            }

            for (int i = removalList.Count - 1; i >= 0; i--)
            {
                perimeterPoints.RemoveAt(removalList[i]);
            }

            return perimeterPoints;
        }
        void respondToValRequests(string response)
        {
            string[] responses = response.Split('+');
            List<Validation> validations = new List<Validation>();

            for (int i = 0; i < responses.Length; i++)
            {
                string[] valDetail = responses[i].Split('|');

                Validation v = new Validation();
                v.steamid = Convert.ToUInt64(valDetail[0]);
                v.details = valDetail[1];
                validations.Add(v);
            }

            if (validations.Count > 0)
            {
                for (int i = 0; i < allBasePlayer.Count; i++)
                {
                    for (int val = 0; val < validations.Count; val++)
                    {
                        if (allBasePlayer[i].userID == validations[val].steamid)
                        {
                            if (!validated.Contains(allBasePlayer[i].userID))
                            {
                                validated.Add(allBasePlayer[i].userID);
                            }
                            SendReply(allBasePlayer[i], "Your validation code is " + validations[val].details + " and your SteamID is " + validations[val].steamid.ToString() + ".");
                        }
                    }
                }
            }

            valReqs.Clear();
        }
        void saveAllData(BasePlayer player)
        {
            saveConfiguration();
            saveDataFiles();
            if (player != null) { SendReply(player, "Config and data saved."); }
        }
        void saveConfiguration()
        {
            Config.Clear();
            GetConfig("SETTINGS", "Converted", updatedOldData);
            GetConfig("OPTIONS", "Time between updates", timeBetweenChecks);
            GetConfig("OPTIONS", "Max perimeter size", maxPerimeterDelta);
            GetConfig("OPTIONS", "Max points per perimeter", maxPerimeterPoints);
            GetConfig("OPTIONS", "Max perimeters per player", maxPerimetersPerPlayer);

            GetConfig("OPTIONS", "Hide names and SteamIDs from alerts", sendAnon);
            GetConfig("OPTIONS", "Enable automatic perimeter checking", automaticCheckingEnabled);
            GetConfig("OPTIONS", "Sync alerts with the Raid Alert server", syncWithRustySheriffServer);
            GetConfig("OPTIONS", "Alerts only triggered if player sleeping in their perimeter", alertTriggeredOnlyWhenSleepingInPerimeter);
            GetConfig("OPTIONS", "Show alerts in-game", alertsVisibleInGame);
            GetConfig("OPTIONS", "Use cupboard authorisation when creating perimeters", useCupboards);
            GetConfig("OPTIONS", "Enabled for authorised users only", enabledForAuthorisedUsersOnly);
            SaveConfig();
        }
        void saveDataFiles()
        {
            List<SavePerimeterEntry> savePerimeters = new List<SavePerimeterEntry>();
            //flatten perimeters
            for (int i = 0; i < perimeters.Count; i++)
            {
                for (int i2 = 0; i2 < perimeters[i].playerPerimeters.Count; i2++)
                {
                    SavePerimeterEntry s = new SavePerimeterEntry();
                    s.steamid = perimeters[i].steamid;
                    s.name = perimeters[i].playerPerimeters[i2].name;
                    s.finished = perimeters[i].playerPerimeters[i2].finished;
                    s.id = perimeters[i].playerPerimeters[i2].id;


                    for (int v = 0; v < perimeters[i].playerPerimeters[i2].coords.Count; v++)
                    {
                        s.coordsX.Add(perimeters[i].playerPerimeters[i2].coords[v].x);
                        s.coordsY.Add(perimeters[i].playerPerimeters[i2].coords[v].y);
                        s.coordsZ.Add(perimeters[i].playerPerimeters[i2].coords[v].z);
                    }

                    s.minX = perimeters[i].playerPerimeters[i2].minX;
                    s.minY = perimeters[i].playerPerimeters[i2].minY;
                    s.maxX = perimeters[i].playerPerimeters[i2].maxX;
                    s.maxY = perimeters[i].playerPerimeters[i2].maxY;
                    s.sleeperPresent = perimeters[i].playerPerimeters[i2].sleeperPresent;
                    savePerimeters.Add(s);
                }
            }

            SaveObject saveObj = new SaveObject();
            saveObj.validated = validated;
            saveObj.authList = authList;
            saveObj.muteList = muteList;
            saveObj.ignoreList = ignoreList;
            //saveObj.savePerimeters = savePerimeters;

            Interface.Oxide.DataFileSystem.WriteObject<SaveObject>("RaidAlert v1", saveObj);
            Interface.Oxide.DataFileSystem.WriteObject<List<SavePerimeterEntry>>("RaidAlert - Perimeters - delete on server wipe", savePerimeters);
        }
        void sendTestAlert(BasePlayer player)
        {
            TestAlert t = new TestAlert();
            t.steamid = player.userID;
            t.name = player.displayName;

            testAlerts.Add(t);
            SendReply(player, "A test alert has been queued for external delivery.");
        }
        void set(BasePlayer player, string[] args)
        {
            if (args.Length > 1)
            {
                FindAllFrom(player, args[1]);
            }
            else
            {
                SendReply(player, "Enter a name for this perimeter.");
            }
        }
        void setAuthLevel(ulong steamid, int level, string name, BasePlayer initPlayer, bool quiet)
        {
            if (initPlayer != null)
            {
                if (initPlayer.userID == steamid)
                {
                    SendReply(initPlayer, "You cannot modify your own authorisation level.");
                    return;
                }
            }

            bool match = false;
            int index = getAuthIndex(steamid);

            BasePlayer player = null;
            int playerIndex = getPlayerIndex(steamid);

            if (playerIndex != -1)
            {
                player = allBasePlayer[playerIndex];
            }

            //check for -1 after all getPerimeterIndex etc

            if (index == -1)
            {
                Auth a = new Auth();
                a.steamid = steamid;
                a.name = name;
                a.level = level;
                authList.Add(a);
                sortAuths();
                hashAuths();


                if (level == 0)
                {
                    if (player != null) { SendReply(player, "You've been added as a Raid Alert user."); }
                    if (initPlayer != null && initPlayer != player) { SendReply(initPlayer, "You've been added as a Raid Alert user."); }
                    else
                    {
                        Puts(name + " " + steamid.ToString() + " added as a Raid Alert user.");
                    }
                }

                if (level == 1)
                {
                    if (player != null) { SendReply(player, "You've been added as a Raid Alert privileged user."); }
                    if (initPlayer != null && initPlayer != player) { SendReply(initPlayer, "You've been added as a Raid Alert privileged user."); }
                    else
                    {
                        Puts(name + " " + steamid.ToString() + " added as a Raid Alert privileged user.");
                    }
                }

                if (level == 2)
                {
                    if (player != null) { SendReply(player, "You've been added as a Raid Alert admin."); }
                    if (initPlayer != null && initPlayer != player) { SendReply(initPlayer, "You've been added as a Raid Alert admin."); }
                    else
                    {
                        Puts(name + " " + steamid.ToString() + " added as a Raid Alert admin.");
                    }
                }
            }
            else
            {
                if (authList[index].level == level)
                {
                    if (name == authList[index].name)
                    {
                        if (initPlayer != null)
                        {
                            SendReply(initPlayer, name + " already has that auth level.");
                        }
                        else
                        {
                            if (!quiet)
                            {
                                Puts(name + " already has that auth level.");
                            }
                        }
                        return;
                    }
                    else
                    {
                        if (initPlayer != null)
                        {
                            SendReply(initPlayer, "Updated player name in auth list.");
                        }
                        else
                        {
                            Puts("Updated player name in auth list.");
                        }
                        authList[index].name = name;
                    }
                }

                string newLevel = "";
                string grade = "";

                if (level == 0) { newLevel = "Raid Alert user"; }

                if (level == 1) { newLevel = "Raid Alert privileged user"; }

                if (level == 2) { newLevel = "Raid Alert admin"; }

                if (level < authList[index].level)
                {
                    grade = "downgraded";
                }
                else
                {
                    if (level == authList[index].level)
                    {
                        authList[index].level = level;
                        return;
                    }
                    else
                    {
                        grade = "upgraded";
                    }
                }

                authList[index].level = level;
                if (player != null) { SendReply(player, "You have been " + grade + " to a " + newLevel + "."); }
                if (initPlayer != null && initPlayer != player) { SendReply(initPlayer, name + " has been " + grade + " to a " + newLevel + "."); }
                else
                {
                    Puts(name + " has been " + grade + " to a " + newLevel + ".");
                }
            }
        }
        void setCheckInterval(BasePlayer player, string[] args)
        {
            if (args.Length > 1)
            {
                int val;

                try
                {
                    val = Convert.ToInt32(args[1]);

                    if (val >= 0)
                    {
                        SendReply(player, "Each player and perimeter will be checked over a period of " + val.ToString() + " seconds.");
                    }
                    else
                    {
                        SendReply(player, "Please enter a valid number for the check duration.");
                        return;
                    }
                }
                catch (Exception e)
                {
                    SendReply(player, "Please enter a valid number for the check duration.");
                    return;
                }

                timeBetweenChecks = val;
            }
            else
            {
                SendReply(player, "Please enter a valid number for the check duration.");
            }
        }
        void setMaxPerimeters(BasePlayer player, string[] args)
        {
            if (args.Length > 1)
            {
                int val;

                try
                {
                    val = Convert.ToInt32(args[1]);

                    if (val >= 0)
                    {
                        SendReply(player, "The maximum number of perimeters has been set to " + val.ToString());
                    }
                    else
                    {
                        SendReply(player, "Enter a valid number for the maximum number of perimeters per player.");
                        return;
                    }
                }
                catch (Exception e)
                {
                    SendReply(player, "Enter a valid number for the maximum number of perimeters per player.");
                    return;
                }

                maxPerimetersPerPlayer = val;
            }
            else
            {
                SendReply(player, "Enter a valid number for the maximum number of perimeters per player.");
            }
        }
        void setMaxPoints(BasePlayer player, string[] args)
        {
            if (args.Length > 1)
            {
                int val;

                try
                {
                    val = Convert.ToInt32(args[1]);

                    if (val >= 0)
                    {
                        SendReply(player, "The maximum number of points per perimeter has been set to " + val.ToString());
                    }
                    else
                    {
                        SendReply(player, "Enter a valid number for the maximum number of points per perimiter.");
                        return;
                    }
                }
                catch (Exception e)
                {
                    SendReply(player, "Enter a valid number for the maximum number of points per perimiter.");
                    return;
                }

                maxPerimeterPoints = val;
            }
            else
            {
                SendReply(player, "Enter a valid number for the maximum number of points per perimiter.");
            }
        }
        void setMaxSize(BasePlayer player, string[] args)
        {
            if (args.Length > 1)
            {
                int val;

                try
                {
                    val = Convert.ToInt32(args[1]);

                    if (val >= 0)
                    {
                        SendReply(player, "The maximum perimeter size has been set to " + val.ToString() + " x " + val.ToString());
                    }
                    else
                    {
                        SendReply(player, "Enter a valid number for the maximum perimeter size.");
                        return;
                    }
                }
                catch (Exception e)
                {
                    SendReply(player, "Enter a valid number for the maximum perimeter size.");
                    return;
                }

                maxPerimeterDelta = val;
            }
            else
            {
                SendReply(player, "Enter a valid number for the maximum perimeter size.");
            }
        }
        void setTimeBetweenChecks(BasePlayer player, string[] args)
        {
            if (args.Length == 1)
            {
                SendReply(player, "Please enter the time in seconds over which to check players and perimeters.");
                return;
            }

            int val;

            try
            {
                val = Convert.ToInt32(args[1]);
            }
            catch (Exception e)
            {
                SendReply(player, "Please enter the time in seconds over which to check players and perimeters.");
                return;
            }

            if (val < 5)
            {
                SendReply(player, "The number of seconds you have chosen is too short.");
                return;
            }

            timeBetweenChecks = val;
            SendReply(player, "Players and perimeters will now be checked over an interval of " + timeBetweenChecks.ToString() + " seconds.");
        }
        void showAdminMenu(BasePlayer player)
        {
            SendReply(player, "<color=#00FF00>Rusty Sheriff Raid Alert Admin Commands</color>");
            SendReply(player, "enable/disable - enable/disable perimeter checking");
            SendReply(player, "status - displays the values of the options below");
            SendReply(player, "secure - toggles whether the alert system is available to unauthorised users");
            SendReply(player, "cupboard - toggle whether players can create perimeters if not cupboard authorised");
            SendReply(player, "chatmute - toggle whether player's alerts show in-game");
            SendReply(player, "time <number> - sets the interval over which perimeter checks are made.");
            SendReply(player, "sleepers - toggle whether an alert is triggered only if the player is sleeping within their perimeter");
            SendReply(player, "sync - toggle synchronisation with the Raid Alert server");
            SendReply(player, "maxperim <number> - set the maximum number of perimeters a player can set");
            SendReply(player, "maxsize <number> - set the maximum area a perimeter can span to <number> x <number> metres");
            SendReply(player, "maxpoints <number> - set the maxmimum number of points a player's perimeter can contain");
            SendReply(player, "anon - toggles whether or not alerts display the player's name and SteamID");
            SendReply(player, "auth - shows authorisation commands");
        }
        void showAdvancedMenu(BasePlayer player)
        {
            SendReply(player, "<color=#00FF00>Rusty Sheriff Advanced Player Commands</color>");
            SendReply(player, "start <perimeter name> - to start manually recording a new perimeter");
            SendReply(player, "add - add a waypoint to a perimeter");
            SendReply(player, "undo - remove the previous waypoint");
            SendReply(player, "cancel - cancel logging waypoints");
            SendReply(player, "stop  - finalise a perimeter");
            SendReply(player, "ignore <player name> - add an online player to your ignore list");
            SendReply(player, "ignore <steamid> - add an online player to your ignore list");
            SendReply(player, "ignore <steamid> <player name> - add an offline player to your ignore list");
            SendReply(player, "validate/validatenew - get or create a new validation code for use in the PC/Android app.");
        }
        void showAuthMenu(BasePlayer player)
        {
            SendReply(player, "<color=#00FF00>Rusty Sheriff Raid Alert Auth Commands</color>");
            SendReply(player, "auths - view a list of authorised user for this server");
            SendReply(player, "adduser <steamid>/<playername> <authLevel> - add an online player to the authorised user list.");
            SendReply(player, "adduser <steamid> <playername> <authLevel> - add an offline player to the authorised user list.");
            SendReply(player, "deluser <index> - delete a user from the authorised user list");
            SendReply(player, "save - saves all Raid Alert data and configuration settings");
            SendReply(player, "Console Commands");
            SendReply(player, "rs.auths - as above");
            SendReply(player, "rs.adduser - as above");
        }
        void showAuthorisedUsers(BasePlayer player)
        {
            if (authList.Count > 0)
            {
                if (player != null)
                {
                    SendReply(player, "<color=#00FF00>Raid Alert Authorised Users List</color>");
                }
                else
                {
                    Puts("Raid Alert Authorised Users List");
                }

                for (int i = 0; i < authList.Count; i++)
                {
                    if (authList[i].level == 0)
                    {
                        if (player != null)
                        {

                            SendReply(player, (i + 1).ToString() + " - " + authList[i].name + " " + authList[i].steamid.ToString() + " - Basic User.");
                        }
                        else
                        {
                            Puts((i + 1).ToString() + " - " + authList[i].name + " " + authList[i].steamid.ToString() + " - Basic User.");
                        }
                    }

                    if (authList[i].level == 1)
                    {
                        if (player != null)
                        {
                            SendReply(player, (i + 1).ToString() + " - " + authList[i].name + " " + authList[i].steamid.ToString() + " - Priviledged User.");
                        }
                        else
                        {
                            Puts((i + 1).ToString() + " - " + authList[i].name + " " + authList[i].steamid.ToString() + " - Priviledged User.");
                        }
                    }

                    if (authList[i].level == 2)
                    {
                        if (player != null)
                        {
                            SendReply(player, (i + 1).ToString() + " - " + authList[i].name + " " + authList[i].steamid.ToString() + " - Raid Alert Admin.");
                        }
                        else
                        {
                            Puts((i + 1).ToString() + " - " + authList[i].name + " " + authList[i].steamid.ToString() + " - Raid Alert Admin.");
                        }
                    }
                }
            }
            else
            {
                if (player != null)
                {
                    SendReply(player, "Authorised users list is empty.");
                }
                else
                {
                    Puts("Authorised users list is empty.");
                }
            }

        }
        void showHelpMenu(BasePlayer player)
        {
            SendReply(player, "<color=#00FF00>Rusty Sheriff Raid Alert Instructions</color>");
            SendReply(player, "Use /rs set <perimeter name> to auto create a perimeter around your foundation/floor.");

            if (alertsVisibleInGame)
            {
                SendReply(player, "You will now be alerted in-game if another player breaches your perimeter.");
            }
            else
            {
                SendReply(player, "Your admin has disabled in-game alerts, so you won't be alerted in-game of any perimeter breaches.");
            }

            if (syncWithRustySheriffServer)
            {
                SendReply(player, "Within " + timeBetweenChecks.ToString() + " seconds, you will receive a validation code.");
                SendReply(player, "Enter the code along with your SteamID in the Raid Alert app if you wish to receive alerts externally.");
                SendReply(player, "A test alert will be automatically sent to your device.  To send another do /rs test.");
                SendReply(player, "Within a minute or so, you'll receive a test alert on your PC/Android device.");
                SendReply(player, "To get a copy of the PC/Android App search for \"Rusty Sheriff Raid Alert\" on Google Play.  The PC App is linked in the description.");
            }
            else
            {
                SendReply(player, "Your admin has disabled the option to send alerts to your PC/Android device.");
            }

            SendReply(player, "If you need further assistance or wish to report a bug, contact JV at djgamingservices@gmail.com.");
        }
        void showMainMenu(BasePlayer player)
        {
            SendReply(player, "<color=#00FF00>Welcome to the Rusty Sheriff Raid Alert System</color>");
            SendReply(player, "Use /rs followed by");
            SendReply(player, "set <perimeter name> - automatically create a perimeter around your foundation/floor");
            SendReply(player, "view - show a list of perimeters and draw them in-game");
            SendReply(player, "ignores - show your ignore list");
            SendReply(player, "delete/unignore <index> - remove a perimeter/ignored player");
            SendReply(player, "clear/clearignores - remove all perimeters/ignored players");
            SendReply(player, "ignoredetect - add all players within your perimeters to your ignore list");
            SendReply(player, "mute/unmute - enable/disable in-game alerts");
            SendReply(player, "test - test your perimeter and send a test alert");
            SendReply(player, "adv - advanced commands");
            SendReply(player, "help - show intructions");

            if (getAuthLevel(player.userID) == 2)
            {
                SendReply(player, "admin - show the admin commands menu");
            }
        }
        void showStatus(BasePlayer player)
        {
            SendReply(player, "<color=#00FF00>Rusty Sheriff Raid Alert Status</color>");

            SendReply(player, "Players can have a maximum of " + maxPerimetersPerPlayer.ToString() + " perimeters.");
            SendReply(player, "Time between perimeter checks is " + timeBetweenChecks.ToString() + " seconds.");
            SendReply(player, "The maximum perimeter size is " + maxPerimeterDelta.ToString() + " x " + maxPerimeterDelta.ToString() + ".");
            SendReply(player, "The maximum number of points per perimeter is " + maxPerimeterPoints.ToString() + ".");

            if (alertsVisibleInGame)
            {
                SendReply(player, "Alerts are displayed to players in-game.");
            }
            else
            {
                SendReply(player, "Alerts are not displayed to players in-game.");
            }

            if (alertTriggeredOnlyWhenSleepingInPerimeter)
            {
                SendReply(player, "Alerts are only triggered when the player is sleeping within their perimeter.");
            }
            else
            {
                SendReply(player, "Alerts are sent regardless of the player's online status or sleeper location.");
            }

            if (syncWithRustySheriffServer)
            {
                SendReply(player, "Synchronisation with the Raid Alert server is enabled.");
            }
            else
            {
                SendReply(player, "Synchronisation with the Raid Alert server is DISABLED.");
            }

            if (enabledForAuthorisedUsersOnly)
            {
                SendReply(player, "Raid Alert is only available to authorised users.");
            }
            else
            {
                SendReply(player, "Raid Alert is available to all users.");
            }

            if (sendAnon)
            {
                SendReply(player, "Trespasser names and Steam IDs are not visible to players in-game nor externally.");
            }
            else
            {
                SendReply(player, "Trespasser names and Steam IDs are visible to players in-game and externally.");
            }

            if (automaticCheckingEnabled)
            {
                SendReply(player, "Automatic checking of players and perimeters is enabled.");
            }
            else
            {
                SendReply(player, "Automatic checking of players and perimeters is DISABLED.");
            }

            if (useCupboards)
            {
                SendReply(player, "Players must have tool cupboard authorisation to create a perimeter.");
            }
            else
            {
                SendReply(player, "Players do not need tool cupboard authorisation to create a perimeter.");
            }

            int perimeterCount = 0;
            int players = 0;

            for (int i = 0; i < perimeters.Count; i++)
            {
                perimeterCount += perimeters[i].playerPerimeters.Count;

                if (perimeters[i].playerPerimeters.Count > 0)
                {
                    players++;
                }
            }

            SendReply(player, "There are " + perimeterCount.ToString() + " perimeters defined, by " + players.ToString() + " players.");
        }
        void sortAuths()
        {
            List<string> nameList = new List<string>();

            for (int i = 0; i < authList.Count; i++)
            {
                nameList.Add(authList[i].name);
            }

            nameList.Sort();

            List<Auth> ath = new List<Auth>();

            for (int a = 0; a < nameList.Count; a++)
            {
                for (int b = 0; b < authList.Count; b++)
                {
                    if (nameList[a] == authList[b].name)
                    {
                        ath.Add(authList[b]);
                        authList.RemoveAt(b);
                        break;
                    }
                }
            }

            authList = ath;
        }
        void sortIgnores(int ignoreListIndex)
        {
            if (ignoreList[ignoreListIndex].ignores.Count < 2) { return; }

            List<string> nameList = new List<string>();

            for (int i = 0; i < ignoreList[ignoreListIndex].ignores.Count; i++)
            {
                nameList.Add(ignoreList[ignoreListIndex].ignores[i].name);
            }

            nameList.Sort();

            List<IgnoredPlayer> newIgnores = new List<IgnoredPlayer>();

            for (int n = 0; n < nameList.Count; n++)
            {
                for (int p = 0; p < ignoreList[ignoreListIndex].ignores.Count; p++)
                {
                    if (nameList[n] == ignoreList[ignoreListIndex].ignores[p].name)
                    {
                        newIgnores.Add(ignoreList[ignoreListIndex].ignores[p]);
                        ignoreList[ignoreListIndex].ignores.RemoveAt(p);
                        break;
                    }
                }
            }

            ignoreList[ignoreListIndex].ignores = newIgnores;
        }
        void sortPlayerPerimeters(int perimeterIndex)
        {
            if (perimeters[perimeterIndex].playerPerimeters.Count < 2) { return; }

            List<string> nameList = new List<string>();

            for (int i = 0; i < perimeters[perimeterIndex].playerPerimeters.Count; i++)
            {
                nameList.Add(perimeters[perimeterIndex].playerPerimeters[i].name);
            }

            nameList.Sort();

            List<PlayerPerimeter> newPP = new List<PlayerPerimeter>();

            for (int n = 0; n < nameList.Count; n++)
            {
                for (int p = 0; p < perimeters[perimeterIndex].playerPerimeters.Count; p++)
                {
                    if (nameList[n] == perimeters[perimeterIndex].playerPerimeters[p].name)
                    {
                        newPP.Add(perimeters[perimeterIndex].playerPerimeters[p]);
                        perimeters[perimeterIndex].playerPerimeters.RemoveAt(p);
                        break;
                    }
                }
            }

            perimeters[perimeterIndex].playerPerimeters = newPP;
        }
        void startDrawing(BasePlayer player, int perimeterIndex, int playerPerimeterIndex)
        {
            DrawListEntry d = new DrawListEntry();
            d.basePlayer = player;
            d.perimeterIndex = perimeterIndex;
            d.playerPerimeterIndex = playerPerimeterIndex;

            drawList.Add(d);
        }
        void startPerimeter(BasePlayer player, string[] args)
        {
            ulong steamid = player.userID;

            if (!isInProgress(steamid))
            {
                if (args.Length > 1)
                {
                    int pCount = countPerimeters(steamid);

                    if (pCount >= maxPerimetersPerPlayer && getAuthLevel(player.userID) < 1)
                    {
                        SendReply(player, "You already have the maximum of " + maxPerimetersPerPlayer.ToString() + " perimeters on this server.  Do /rs delete <index>.");
                        return;
                    }

                    if (useCupboards)
                    {
                        if (!hasTotalAccess(player) && getAuthLevel(player.userID) < 1)
                        {
                            SendReply(player, "You must be authorised on a nearby cupboard to create a perimeter here.");
                            return;
                        }
                    }
                    addPerimeter(player, args[1]);
                }
                else
                {
                    SendReply(player, "Please enter a name for this perimeter.  Do /rs start <name>");
                }
            }
            else
            {
                SendReply(player, "You are already logging waypoints for perimeter " + getInProgress(steamid) + ".  Do /rs cancel.");
            }
        }
        void stopDrawing(BasePlayer player)
        {
            for (int i = 0; i < drawList.Count; i++)
            {
                if (drawList[i].basePlayer.userID == player.userID)
                {
                    drawList.RemoveAt(i);
                    return;
                }
            }
        }
        void stopPerimeter(BasePlayer player)
        {
            if (isInProgress(player.userID))
            {
                int r = addPerimeterEntry(player, true);
                if (r == -1)
                {
                    return;
                }
                else
                {
                    if (r < 3)
                    {
                        SendReply(player, "You need at least 3 points to create a perimeter.  Do /rs add to enter more waypoints.");
                        stopPerimeter(player, true);
                        return;
                    }
                }

                stopDrawing(player);
                stopPerimeter(player, false);
            }
            else
            {
                SendReply(player, "You have no perimeters in progress.  Do /rs set <name> to create one.");
            }
        }
        void stopPerimeter(BasePlayer player, bool cancel)
        {
            string name = "";
            int inProgressIndex = -1;

            PerimeterPosition pPos = getInProgress(player.userID);

            if (pPos.perimeterIndex == -1)
            {
                SendReply(player, "You have no perimeters in progress.");
                return;
            }
            else
            {
                name = perimeters[pPos.perimeterIndex].playerPerimeters[pPos.playerPerimeterIndex].name;
            }

            stopDrawing(player);

            if (cancel)
            {
                perimeters[pPos.perimeterIndex].playerPerimeters.RemoveAt(pPos.playerPerimeterIndex);
                SendReply(player, "Perimeter entry for " + name + " cancelled.");
            }
            else
            {
                ignorePlayer(player.userID, player.userID, player.displayName);
                perimeters[pPos.perimeterIndex].playerPerimeters[pPos.playerPerimeterIndex].finished = true;
                addValidationRequest(player.userID, false);
                sendTestAlert(player);
                SendReply(player, "Perimeter entry successful.");
                plotPerimeter(player, pPos.perimeterIndex, pPos.playerPerimeterIndex);
            }
        }
        void testPerimeter(BasePlayer player)
        {
            int perimeterIndex = getPerimeterIndex(player.userID);

            if (perimeterIndex == -1)
            {
                SendReply(player, "You haven't set any perimeters.  Do /rs set <name>.");
                return;
            }

            bool match = false;

            for (int i = 0; i < perimeters[perimeterIndex].playerPerimeters.Count; i++)
            {
                PerimeterPosition pPos = new PerimeterPosition();
                pPos.perimeterIndex = perimeterIndex;
                pPos.playerPerimeterIndex = i;

                int wn = windingPoly(player.transform.position, pPos);

                if (wn != 0)
                {
                    SendReply(player, "You're currently within the bounds of location " + perimeters[pPos.perimeterIndex].playerPerimeters[pPos.playerPerimeterIndex].name + ".");
                    match = true;

                    if (validated.Contains(player.userID))
                    {
                        if (syncWithRustySheriffServer)
                        {
                            TestAlert t = new TestAlert();
                            t.steamid = player.userID;
                            t.name = player.displayName;

                            testAlerts.Add(t);
                            SendReply(player, "A test alert has been queued for external delivery.");
                        }
                        else
                        {
                            SendReply(player, "External alerts have been disabled by the admin.");
                        }
                    }
                }
            }

            if (!match)
            {
                SendReply(player, "You're not currently within any of your perimeters.");
            }
        }
        void toggleAnon(BasePlayer player)
        {
            if (sendAnon)
            {
                sendAnon = false;
                saveConfiguration();
                SendReply(player, "Trespasser names and Steam IDs will be visible to players in=game and externally.");
            }
            else
            {
                sendAnon = true;
                saveConfiguration();
                SendReply(player, "Trespasser names and SteamIDs will be hidden from player in-game and externally.");
            }
        }
        void toggleAutoCheck(BasePlayer player, bool enable)
        {
            if (enable)
            {
                if (automaticCheckingEnabled)
                {
                    SendReply(player, "Automatic perimeter checking is already enabled.");
                }
                else
                {
                    SendReply(player, "Automatic perimeter checking enabled.");
                    automaticCheckingEnabled = true;
                    Puts("Automatic perimeter checking enabled by " + player.userID.ToString());
                }
            }
            else
            {
                if (automaticCheckingEnabled)
                {
                    SendReply(player, "Automatic perimeter checking disabled.");
                    automaticCheckingEnabled = false;
                    Puts("Automatic perimeter checking disabled by " + player.userID.ToString());
                }
                else
                {
                    SendReply(player, "Automatic perimeter checking is already disabled.");
                }
            }
        }
        void toggleChatMute(BasePlayer player)
        {
            if (alertsVisibleInGame)
            {
                alertsVisibleInGame = false;
                saveConfiguration();
                SendReply(player, "Alerts will no longer be displayed to players in-game.");
            }
            else
            {
                alertsVisibleInGame = true;
                saveConfiguration();
                SendReply(player, "Alerts will be displayed to players in-game.");
            }
        }
        void toggleSecureMode(BasePlayer player)
        {
            if (enabledForAuthorisedUsersOnly)
            {
                enabledForAuthorisedUsersOnly = false;
                saveConfiguration();
                SendReply(player, "Raid Alert is now available to all players.");
                Puts("Raid Alert auth mode disabled by player " + player.userID.ToString());
            }
            else
            {
                enabledForAuthorisedUsersOnly = true;
                saveConfiguration();
                SendReply(player, "Raid Alert is only available for authorised players.");
                Puts("Raid Alert auth mode enabled by player " + player.userID.ToString());
            }
        }
        void toggleSleepers(BasePlayer player)
        {
            if (alertTriggeredOnlyWhenSleepingInPerimeter)
            {
                alertTriggeredOnlyWhenSleepingInPerimeter = false;
                saveConfiguration();
                SendReply(player, "Alerts will be sent regardless of the player's online status or sleeper location.");
            }
            else
            {
                alertTriggeredOnlyWhenSleepingInPerimeter = true;
                saveConfiguration();
                SendReply(player, "Alerts will only be triggered if the player logs out within their perimeter.");
            }
        }
        void toggleSync(BasePlayer player)
        {
            if (syncWithRustySheriffServer)
            {
                syncWithRustySheriffServer = false;
                saveConfiguration();
                SendReply(player, "Synchronisation with the Raid Alert server has been disabled.");
            }
            else
            {
                syncWithRustySheriffServer = true;
                saveConfiguration();
                SendReply(player, "Synchronisation with the Raid Alert server has been enabled.");
            }
        }
        void toggleUseCupboard(BasePlayer player)
        {
            if (useCupboards)
            {
                useCupboards = false;
                saveConfiguration();
                SendReply(player, "Players can create perimeters without tool cupboard authorisation.");
            }
            else
            {
                useCupboards = true;
                saveConfiguration();
                SendReply(player, "Players must have tool cupboard authorisation before creating a perimeter.");
            }
        }
        void validatePlayer(BasePlayer player, bool newCode)
        {
            if (syncWithRustySheriffServer)
            {
                SendReply(player, "Please wait up to " + timeBetweenChecks.ToString() + " seconds for your validation code.");
                addValidationRequest(player.userID, newCode);
            }
            else
            {
                SendReply(player, "External alerts are currently disabled by the admin.");
            }
        }
        void undoLastPoint(BasePlayer player)
        {
            if (!isInProgress(player.userID))
            {
                SendReply(player, "You are not currently recording a perimeter.");
            }
            else
            {
                PerimeterPosition pPos = getInProgress(player.userID);
                string perimeterName = perimeters[pPos.perimeterIndex].playerPerimeters[pPos.playerPerimeterIndex].name;

                if (perimeters[pPos.perimeterIndex].playerPerimeters[pPos.playerPerimeterIndex].coords.Count > 0)
                {
                    int cnt = perimeters[pPos.perimeterIndex].playerPerimeters[pPos.playerPerimeterIndex].coords.Count;
                    perimeters[pPos.perimeterIndex].playerPerimeters[pPos.playerPerimeterIndex].coords.RemoveAt(cnt - 1);
                    SendReply(player, "Removed your last waypoint on perimeter " + perimeterName + ".");
                }
                else
                {
                    SendReply(player, "You have no waypoints left to remove from perimeter " + perimeterName + ".");
                }
            }
        }
        void unignorePlayer(BasePlayer player, string[] args)
        {
            if (args.Length > 1)
            {
                int index;

                try
                {
                    index = Convert.ToInt32(args[1]);
                }
                catch (Exception e)
                {
                    SendReply(player, "Please enter a valid index.  Do /rs ignores for a list.");
                    return;
                }

                int i = getIgnoreListIndex(player.userID);

                if (i != -1)
                {
                    if (index < 1 || index > ignoreList[i].ignores.Count)
                    {
                        SendReply(player, "Please enter a valid index.  Do /rs ignores for a list.");
                        return;
                    }

                    SendReply(player, "Removed " + ignoreList[i].ignores[index - 1].name + " from your ignore list.");
                    ignoreList[i].ignores.RemoveAt(index - 1);
                    return;
                }

                SendReply(player, "Your ignore list is empty.");
            }
            else
            {
                SendReply(player, "Please enter a valid index to remove from your ignore list.");
            }
        }
        void updateRSSServer()
        {
            if (syncWithRustySheriffServer)
            {
                List<Trespasser> alertsList = new List<Trespasser>();
                List<Trespasser> cancelsList = new List<Trespasser>();

                for (int i = 0; i < testAlerts.Count; i++)
                {
                    Trespasser t = new Trespasser();
                    t.steamid = testAlerts[i].steamid;
                    t.name = "Test Alert";
                    t.trespasserSteamID = t.steamid;
                    t.alertText = "|" + "1234567" + "|" + cleanString(testAlerts[i].name) + "|" + "0" + "|" + "0";

                    //Puts("nt = " + newTrespassers.Count.ToString());
                    //Puts("ot = " + oldTrespassers.Count.ToString());

                    //Puts("Added to newTrespasssers");
                    newTrespassers.Add(t);

                    //Puts("nt2 = " + newTrespassers.Count.ToString());
                    //Puts("ot2 = " + oldTrespassers.Count.ToString());
                }

                testAlerts.Clear();

                bool match = false;

                for (int i = 0; i < newTrespassers.Count; i++)
                {
                    match = false;
                    for (int j = 0; j < oldTrespassers.Count; j++)
                    {
                        if (newTrespassers[i].steamid == oldTrespassers[j].steamid)
                        {
                            if (newTrespassers[i].name == oldTrespassers[j].name)
                            {
                                if (newTrespassers[i].trespasserSteamID == oldTrespassers[j].trespasserSteamID)
                                {
                                    if (newTrespassers[i].id == oldTrespassers[j].id)
                                    {
                                    //Puts("NEW MATCHES OLD");
                                    match = true;
                                    }
                                }
                            }
                        }
                    }

                    if (!match)
                    {
                        //Puts("ADDED ALERT");
                        alertsList.Add(newTrespassers[i]);
                    }
                }

                for (int i = 0; i < oldTrespassers.Count; i++)
                {
                    match = false;
                    for (int j = 0; j < newTrespassers.Count; j++)
                    {
                        if (oldTrespassers[i].steamid == newTrespassers[j].steamid)
                        {
                            if (oldTrespassers[i].name == newTrespassers[j].name)
                            {
                                if (oldTrespassers[i].trespasserSteamID == newTrespassers[j].trespasserSteamID)
                                {
                                    if (oldTrespassers[i].id == newTrespassers[j].id)
                                    {
                                    //Puts("OLD MATCHES NEW");
                                    match = true;
                                    }
                                }
                            }
                        }
                    }

                    if (!match)
                    {
                        //Puts("ADDED CANCEL");
                        cancelsList.Add(oldTrespassers[i]);
                    }
                }

                string trespassText = "";

                for (int i = 0; i < valReqs.Count; i++)
                {
                    if (valReqs[i].newCode)
                    {
                        trespassText += "+VLN|" + valReqs[i].steamid.ToString();
                    }
                    else
                    {
                        trespassText += "+VLD|" + valReqs[i].steamid.ToString();
                    }
                }

                for (int i = 0; i < cancelsList.Count; i++)
                {
                    if (!sendAnon || getAuthLevel(cancelsList[i].steamid) > 0)
                    {
                        //Puts("C");
                        trespassText += "+CAN|" + cancelsList[i].steamid.ToString() + "|" + cancelsList[i].name + "|" + cancelsList[i].trespasserSteamID.ToString() + cancelsList[i].alertText;
                    }
                    else
                    {
                        trespassText += "+CAN|" + cancelsList[i].steamid.ToString() + "|" + cancelsList[i].name + "|" + cancelsList[i].trespasserSteamID.ToString() + cancelsList[i].alertText + "|HIDDEN";
                    }
                }

                for (int i = 0; i < alertsList.Count; i++)
                {
                    if (!sendAnon || getAuthLevel(alertsList[i].steamid) > 0)
                    {
                        //Puts("A");
                        trespassText += "+ALR|" + alertsList[i].steamid.ToString() + "|" + alertsList[i].name + "|" + alertsList[i].trespasserSteamID.ToString() + alertsList[i].alertText;
                    }
                    else
                    {
                        trespassText += "+ALR|" + alertsList[i].steamid.ToString() + "|" + alertsList[i].name + "|" + alertsList[i].trespasserSteamID.ToString() + alertsList[i].alertText + "|HIDDEN";
                    }
                }

                if (trespassText.Length > 0)
                {
                    string hostname = cleanString(ConVar.Server.hostname);
                    trespassText = "|" + hostname + "|" + ConVar.Server.port.ToString() + trespassText + "#";
                    trespassText = trespassText.Length.ToString() + trespassText;
                    //Puts("Sending " + trespassText);
                    Interface.GetMod().GetLibrary<WebRequests>("WebRequests").EnqueuePost(url, trespassText, (code, response) => parseWebReply(code, response), this);
                }
                else
                {
                    newTrespassers.Clear();
                }
            }
        }
        void viewIgnoreList(BasePlayer player)
        {
            List<string> ignoreEntries = new List<string>();

            int i = getIgnoreListIndex(player.userID);

            if (i != -1)
            {
                for (int p = 0; p < ignoreList[i].ignores.Count; p++)
                {
                    ignoreEntries.Add(ignoreList[i].ignores[p].name + " - " + ignoreList[i].ignores[p].steamid.ToString());
                }

                if (ignoreEntries.Count > 0)
                {
                    SendReply(player, "You are ignoring the following players:");
                    for (int c = 0; c < ignoreEntries.Count; c++)
                    {
                        SendReply(player, (c + 1).ToString() + " - " + ignoreEntries[c]);
                    }
                    return;
                }
                else
                {
                    SendReply(player, "Your ignore list is empty.");
                    return;
                }
            }

            SendReply(player, "Your ignore list is empty.");
        }
        void viewPerimeters(BasePlayer player, string[] args)
        {
            int maxViewDistance = 500;
            int perimeterIndex = getPerimeterIndex(player.userID);

            if (perimeterIndex == -1)
            {
                SendReply(player, "You have no perimeters defined.  Create one with /rs set <name>.");
                return;
            }
            else
            {
                if (perimeters[perimeterIndex].playerPerimeters.Count == 0)
                {
                    SendReply(player, "You have no perimeters defined.  Create one with /rs set <name>.");
                    return;
                }

                SendReply(player, "Your current perimeters are - ");

                for (int i = 0; i < perimeters[perimeterIndex].playerPerimeters.Count; i++)
                {
                    //Puts("Plotting perimeter " + i.ToString());
                    if (Math.Abs(player.transform.position.x - perimeters[perimeterIndex].playerPerimeters[i].coords[0].x) <= 500)
                    {
                        if (Math.Abs(player.transform.position.z - perimeters[perimeterIndex].playerPerimeters[i].coords[0].z) <= 500)
                        {
                            plotPerimeter(player, perimeterIndex, i);
                        }
                    }
                    SendReply(player, (i + 1).ToString() + " - " + perimeters[perimeterIndex].playerPerimeters[i].name);
                }
            }
        }
        int windingPoly(Vector3 position, PerimeterPosition pPos)
        {
            int wn = 0;

            for (int i = 0; i < perimeters[pPos.perimeterIndex].playerPerimeters[pPos.playerPerimeterIndex].coords.Count; i++)
            {
                int tmp;

                if (i == perimeters[pPos.perimeterIndex].playerPerimeters[pPos.playerPerimeterIndex].coords.Count - 1)
                {
                    tmp = 0;
                }
                else
                {
                    tmp = i + 1;
                }

                if (perimeters[pPos.perimeterIndex].playerPerimeters[pPos.playerPerimeterIndex].coords[i].z <= position.z)
                {
                    if (perimeters[pPos.perimeterIndex].playerPerimeters[pPos.playerPerimeterIndex].coords[tmp].z > position.z)
                    {
                        if (isLeft(perimeters[pPos.perimeterIndex].playerPerimeters[pPos.playerPerimeterIndex].coords[i], perimeters[pPos.perimeterIndex].playerPerimeters[pPos.playerPerimeterIndex].coords[tmp], position) > 0)
                        {
                            wn++;
                        }
                    }
                }
                else
                {
                    if (perimeters[pPos.perimeterIndex].playerPerimeters[pPos.playerPerimeterIndex].coords[tmp].z <= position.z)
                    {
                        if (isLeft(perimeters[pPos.perimeterIndex].playerPerimeters[pPos.playerPerimeterIndex].coords[i], perimeters[pPos.perimeterIndex].playerPerimeters[pPos.playerPerimeterIndex].coords[tmp], position) < 0)
                        {
                            wn--;
                        }
                    }
                }
            }

            return wn;
        }

        //***********************//
        //structures/classes here//
        //***********************//
        public class Auth
        {
            public ulong steamid;
            public string name;
            public int level;
        }
        class DrawListEntry
        {
            public BasePlayer basePlayer;
            public int perimeterIndex;
            public int playerPerimeterIndex;
        }
        class Euler
        {
            public double x, y, z;
        }
        class Face
        {
            public double sx, sy, ex, ey;
            public string name;
        }
        class IgnoredPlayer
        {
            public ulong steamid;
            public string name;
        }
        class IgnoreListEntry
        {
            public ulong steamid;
            public List<IgnoredPlayer> ignores = new List<IgnoredPlayer>();
        }
        class name
        {
            public string foundationName;
        }
        class OldAlert
        {
            public Dictionary<string, OldAlertDetails> alertName;
        }
        class OldAlertDetails
        {
            public Dictionary<string, Dictionary<string, double>> coords;
            public int count;
            public bool finished;
            public uint id;
            public double maxx;
            public double maxy;
            public double minx;
            public double miny;
            public bool SleeperPresent;
        }
        class OldAlertsObjectDict
        {
            public Dictionary<string, Dictionary<string, OldAlertDetails>> alerts;
        }
        class OldAuthObjectDict
        {
            public Dictionary<string, string> authNames;
            public Dictionary<string, string> authorised;
        }
        class OldIgnoresObjectDict
        {
            public Dictionary<string, Dictionary<string, string>> ignores;
        }
        class OldIgnoredPlayers
        {
            public Dictionary<string, string> ignoredPlayers;
        }
        class OldMuteList
        {
            public Dictionary<string, string> muted;
        }
        class OldValidatedObjectDict
        {
            public Dictionary<string, string> validated;
        }
        public class Perimeter
        {
            public ulong steamid;
            public List<PlayerPerimeter> playerPerimeters = new List<PlayerPerimeter>();
        }
        class PerimeterPosition
        {
            public int perimeterIndex;
            public int playerPerimeterIndex;
        }
        public class PlayerPerimeter
        {
            public string name;
            public bool finished;
            public uint id;
            public List<Vector3> coords = new List<Vector3>();
            public double minX, minY, maxX, maxY;
            public bool sleeperPresent;
        }
        struct Point
        {
            public double x;
            public double y;
        }
        struct Quat
        {
            public double w;
            public double x;
            public double y;
            public double z;
        }
        class Rect
        {
            public Point[] points = new Point[4];
        }
        class SaveObject
        {
            public List<ulong> validated;
            public List<Auth> authList;
            public List<ulong> muteList;
            public List<IgnoreListEntry> ignoreList;
            //public List<SavePerimeterEntry> savePerimeters;
        }
        public class SavePerimeterEntry
        {
            public ulong steamid;
            public string name;
            public bool finished;
            public uint id;
            public List<double> coordsX = new List<double>();
            public List<double> coordsY = new List<double>();
            public List<double> coordsZ = new List<double>();
            public double minX, minY, maxX, maxY;
            public bool sleeperPresent;
        }
        public class TestAlert
        {
            public ulong steamid;
            public string name;
        }
        struct Trespasser
        {
            public ulong steamid;
            public string name;
            public ulong trespasserSteamID;
            public string alertText;
            public uint id;
        }
        class ValReq
        {
            public ulong steamid;
            public bool newCode;
        }
        class Validation
        {
            public ulong steamid;
            public string details;
        }
    }
}

// --- End of file: RustySheriffAlertSystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NoWeaponDrop.cs ---
// --- Original Local Path: NoWeaponDrop.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("NoWeaponDrop", "Fujikura", "0.2.3", ResourceId = 1960)]
	[Description("Prevents dropping of active weapon on wounded or headshot/instant-kill")]
    class NoWeaponDrop : RustPlugin
    {
		[PluginReference]
		Plugin RestoreUponDeath;
		
		private bool Changed = false;
		private bool usePermission;
		private string permissionName;
		private bool disableForROD;
		
		private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }
		
		void LoadVariables()
        {
			usePermission = Convert.ToBoolean(GetConfig("Settings", "Use permissions", false));
			permissionName = Convert.ToString(GetConfig("Settings", "Permission name", "noweapondrop.active"));
			disableForROD =  Convert.ToBoolean(GetConfig("Settings", "Disable death handler when RestoreUponDeath was found", false));

            if (!Changed) return;
            SaveConfig();
            Changed = false;
        }
		
		protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }
		
		void Loaded()
		{
			LoadVariables();
			if (!permission.PermissionExists(permissionName)) permission.RegisterPermission(permissionName, this);
		}
				
		void OnItemRemovedFromContainer(ItemContainer container, Item item)
		{
			if (container.HasFlag(ItemContainer.Flag.Belt))		
			NextTick(() => {
				if(usePermission && !permission.UserHasPermission(container.playerOwner.userID.ToString(), permissionName)) return;
				if (container.playerOwner.IsWounded() && (item.info.category.value__ == 0 ||  item.info.category.value__ == 5))
					item.MoveToContainer(container);
			});
		}
		
		object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
			if ((entity as BasePlayer) != null && ( info.isHeadshot == true || info.damageTypes.Has(Rust.DamageType.Suicide) )) 
			{
				if(RestoreUponDeath && disableForROD) return null;
				if(usePermission && !permission.UserHasPermission((entity as BasePlayer).userID.ToString(), permissionName)) return null;
				(entity as BasePlayer).svActiveItemID = 0u;
				(entity as BasePlayer).SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
			}
			return null;
        }
	}
}



// --- End of file: NoWeaponDrop.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ExtraSeating.cs ---
// --- Original Local Path: ExtraSeating.cs ---

using System;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins {
    [Info("Extra Seating", "Pho3niX90", "1.0.8")]
    [Description("Allows extra seats on minicopters and horses")]
    class ExtraSeating : RustPlugin {
        #region Config
        public PluginConfig config;
        static ExtraSeating _instance;
        bool debug = false;
        int seats = 0;

        protected override void LoadDefaultConfig() { Config.WriteObject(GetDefaultConfig(), true); }
        public PluginConfig GetDefaultConfig() { return new PluginConfig { EnableMiniSideSeats = true, EnableMiniBackSeat = true, EnableExtraHorseSeat = true }; }
        public class PluginConfig { public bool EnableMiniSideSeats; public bool EnableMiniBackSeat; public bool EnableExtraHorseSeat; }
        #endregion
        private void Init() {
            config = Config.ReadObject<PluginConfig>();
        }

        void LogDebug(string str) {
            if (debug) Puts(str);
        }

        void OnEntitySpawned(BaseNetworkable entity) {
            _instance = this;
            if (entity == null || !(entity is MiniCopter || entity is RidableHorse)) return;
            BaseVehicle vehicle = entity as BaseVehicle;
            seats = vehicle.mountPoints.Count; // default

            if (entity is MiniCopter && entity.ShortPrefabName.Equals("minicopter.entity")) {

                if (_instance.config.EnableMiniSideSeats) seats += 2;
                if (_instance.config.EnableMiniBackSeat) seats += 1;

                if (vehicle.mountPoints.Count < seats)
                    vehicle?.gameObject.AddComponent<Seating>();
            }
            if (entity is RidableHorse) {
                if (_instance.config.EnableExtraHorseSeat) seats += 1;
                if (vehicle.mountPoints.Count < seats)
                    vehicle?.gameObject.AddComponent<Seating>();
            }
        }

        void AddSeat(BaseVehicle ent, Vector3 locPos, Quaternion q) {
            BaseEntity seat = GameManager.server.CreateEntity("assets/prefabs/vehicle/seats/passengerchair.prefab", ent.transform.position, q) as BaseEntity;
            if (seat == null) return;

            seat.SetParent(ent);
            seat.Spawn();
            seat.transform.localPosition = locPos;
            seat.SendNetworkUpdateImmediate(true);
        }

        [ChatCommand("checkmount")]
        private void cmdStats(BasePlayer player, string command, string[] args) {
            RidableHorse entity = player.GetMounted().GetParentEntity() as RidableHorse;
            if (entity == null) {
                _instance.Puts($"entity is null"); return;
            }
            foreach (var s in entity.mountPoints) {
                _instance.Puts($"pos: {s.pos}\n {s.bone}\n {s.mountable}\n IsMounted:{s.mountable.IsMounted()}\n {s.prefab}");
            }
            _instance.Puts($"IsMounted[0]:{entity.mountPoints[0].mountable.IsMounted()}\n IsMounted[1]:{entity.mountPoints[1].mountable.IsMounted()}");
            // _instance.Puts($"HasMountPoints: {entity.HasMountPoints()}");
        }

        BaseVehicle.MountPointInfo CreateMount(Vector3 vec, BaseVehicle.MountPointInfo exampleSeat, Vector3 rotation) {
            return new BaseVehicle.MountPointInfo {
                pos = vec,
                rot = rotation != null ? rotation : new Vector3(0, 0, 0),
                bone = exampleSeat.bone,
                prefab = exampleSeat.prefab,
                mountable = exampleSeat.mountable
            };
        }

        #region Classes
        class HorsePassenger : BaseRidableAnimal {
            override public void PlayerServerInput(InputState inputState, BasePlayer player) {
                if (player.userID == GetDriver().userID) {
                    _instance.Puts("Player is driver");
                    base.PlayerServerInput(inputState, player);
                    return;
                }
                _instance.Puts("Player is NOT driver");
            }
        }

        class Seating : MonoBehaviour {
            public BaseVehicle entity;
            void Awake() {
                entity = GetComponent<BaseVehicle>();
                bool isMini = entity is MiniCopter;
                bool isHorse = entity is RidableHorse;
                Vector3 emptyVector = new Vector3(0, 0, 0);
                if (isMini) {
                    _instance.LogDebug("Minicopter detected");
                }
                if (isHorse) {
                    _instance.LogDebug("Horse detected");
                }

                if (entity == null) { Destroy(this); return; }

                BaseVehicle.MountPointInfo pilot = entity.mountPoints[0];
                //entity.mountPoints.Clear();

                if (entity is RidableHorse) {
                    _instance.LogDebug("Adding passenger seat");
                    Vector3 horseVector = new Vector3(0f, -0.32f, -0.5f);
                    BaseVehicle.MountPointInfo horseBack = _instance.CreateMount(horseVector, pilot, emptyVector);
                    //entity.mountPoints.Add(pilot);
                    entity.mountPoints.Add(horseBack);
                    entity.SendNetworkUpdateImmediate();
                }

                if (entity is MiniCopter) {
                    BaseVehicle.MountPointInfo pFront = entity.mountPoints[1];
                    Vector3 leftVector = new Vector3(0.6f, 0.2f, -0.2f);
                    Vector3 rightVector = new Vector3(-0.6f, 0.2f, -0.2f);
                    Vector3 backVector = new Vector3(0.0f, 0.4f, -1.2f);
                    Vector3 backVector2 = new Vector3(0.0f, 0.4f, -1.45f);

                    Vector3 playerOffsetVector = new Vector3(0f, 0f, -0.25f);
                    Quaternion backQuaternion = Quaternion.Euler(0f, 180f, 0f);

                    if (_instance.config.EnableMiniSideSeats) {
                        _instance.LogDebug("Adding side seats");
                        BaseVehicle.MountPointInfo pLeftSide = _instance.CreateMount(leftVector, pFront, emptyVector);
                        BaseVehicle.MountPointInfo pRightSide = _instance.CreateMount(rightVector, pFront, emptyVector);
                        entity.mountPoints.Add(pLeftSide);
                        entity.mountPoints.Add(pRightSide);
                        _instance.AddSeat(entity, leftVector + playerOffsetVector, new Quaternion());
                        _instance.AddSeat(entity, rightVector + playerOffsetVector, new Quaternion());
                    }

                    if (_instance.config.EnableMiniBackSeat) {
                        _instance.LogDebug("Adding back/rotor seat");
                        BaseVehicle.MountPointInfo pBackReverse = _instance.CreateMount(backVector2, pFront, new Vector3(0f, 180f, 0f));
                        entity.mountPoints.Add(pBackReverse);
                        _instance.AddSeat(entity, backVector, backQuaternion);
                    }
                }

            }
        }
        #endregion
    }
}


// --- End of file: ExtraSeating.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/IQGradeRemove.cs ---
// --- Original Local Path: IQGradeRemove.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("IQGradeRemove", "Mercury", "0.1.5")]
    [Description("Умный Grade Remove")]
    class IQGradeRemove : RustPlugin
    {
        /// <summary> 
        /// Обновление 0.1.3
        /// - Изменен метод проверки на объекты при постройке
        /// Обновление 0.1.4
        /// - Поправлена проверка на ресурсы при улучшении всех объектов
        /// - Исправлен интерфейс
        /// - Добавлена проверка на null в хуке OnHammerHit
        /// </summary>
        /// Обновление 0.1.5
        /// - Исправлено возврат лестницы/сетки при удалении
        /// - Исправлено возврат стен и ворот при удалениие
        /// - Исправлен возврат карьера при удалении
        /// - Исправлена возможность забиндить команд на улучшение и удаление
        /// - Исправлено удаление объектов на РТ
        /// - Исправлен метод с запретом на удаление
        /// - Исправлен метод с запретом на возврат предмета после удаления
        /// - Добавлена возможность скрывать меню после истечения времени улучшения/удаления (Настраивается в конфигурации)
        /// - Добавлена возможность заменить символ на кнопке закрыть
        /// - Добавлена возможность скрыть кнопку закрыть
        /// - Добавлена возможность скрыть уровни улучшения в интерфейсе

        #region Vars
        public static String PermissionGRMenu = "iqgraderemove.gruse";
        public static String PermissionGRNoResource = "iqgraderemove.grusenorecource";
        public readonly Dictionary<Int32, String> StatusLevels = new Dictionary<Int32, String>
        {
            [0] = "ОТКЛЮЧЕНО",
            [1] = "ДЕРЕВА",
            [2] = "КАМНЯ",
            [3] = "МЕТАЛЛА",
            [4] = "МВК",
            [5] = "УДАЛЕНИЕ",
            [6] = "УДАЛЕНИЕ ВСЕГО",
            [7] = "УЛУЧШЕНИЕ ВСЕГО",
        };

        public readonly Dictionary<Int32, String> StatusLevelsAllGrades = new Dictionary<Int32, String>
        {
            [0] = "В СОЛОМУ",
            [1] = "В ДЕРЕВО",
            [2] = "В КАМЕНЬ",
            [3] = "В МЕТАЛЛ",
            [4] = "В МВК",
        };
        public readonly Dictionary<Int32, String> SoundLevelsGrade = new Dictionary<Int32, String>
        {
            [0] = "ОТКЛЮЧЕНО",
            [1] = "assets/bundled/prefabs/fx/build/frame_place.prefab",
            [2] = "assets/bundled/prefabs/fx/build/promote_stone.prefab",
            [3] = "assets/bundled/prefabs/fx/build/promote_metal.prefab",
            [4] = "assets/bundled/prefabs/fx/build/promote_toptier.prefab",
            [5] = "УДАЛЕНИЕ"
        };
        public static readonly Dictionary<Int32, String> PermissionsLevel = new Dictionary<Int32, String>
        {
            [0] = "",
            [1] = "iqgraderemove.upwood",
            [2] = "iqgraderemove.upstones",
            [3] = "iqgraderemove.upmetal",
            [4] = "iqgraderemove.uphmetal",
            [5] = "iqgraderemove.removeuse",
        };



        #region Format Time
        static Int32 CurrentTime() => Facepunch.Math.Epoch.Current;
        public static String FormatTime(TimeSpan time)
        {
            String result = String.Empty;
            if (time.Days != 0)
                result += $"{Format(time.Days, "д", "д", "д")} ";

            if (time.Hours != 0)
                result += $"{Format(time.Hours, "ч", "ч", "ч")} ";

            if (time.Minutes != 0)
                result += $"{Format(time.Minutes, "м", "м", "м")} ";

            if (time.Seconds != 0)
                result += $"{Format(time.Seconds, "с", "с", "с")} ";

            return result;
        }
        private static String Format(Int32 units, String form1, String form2, String form3)
        {
            var tmp = units % 10;

            if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                return $"{units} {form1}";

            if (tmp >= 2 && tmp <= 4)
                return $"{units} {form2}";

            return $"{units} {form3}";
        }
        #endregion

        #endregion

        #region Reference
        [PluginReference] Plugin Friends;
        public Boolean IsRaidBlocked(BasePlayer player)
        {
            var ret = Interface.Call("CanTeleport", player) as String;
            if (ret != null)
                return true;
            else return false;
        }
        public Boolean IsFriends(UInt64 userID, UInt64 targetID)
        {
            if (Friends)
                return (Boolean)Friends?.Call("HasFriend", userID, targetID);
            else return false;
        }

        void RegisteredPermissions()
        {
            var RemoveTimed = config.RemoveSetting.TimedSetting;

            foreach (var PermsBlockTimed in RemoveTimed.ItemsTimesAllPermissions)
                if (!permission.PermissionExists(PermsBlockTimed.Key, this))
                    permission.RegisterPermission(PermsBlockTimed.Key, this);

            foreach (var PermsBlockTimed in RemoveTimed.ItemsTimesPermissions)
                if (!permission.PermissionExists(PermsBlockTimed.Key, this))
                    permission.RegisterPermission(PermsBlockTimed.Key, this);

            if (!permission.PermissionExists(PermissionGRMenu, this))
                permission.RegisterPermission(PermissionGRMenu, this);

            if (!permission.PermissionExists(PermissionGRNoResource, this))
                permission.RegisterPermission(PermissionGRNoResource, this);

            foreach (string Permissions in PermissionsLevel.Values)
                if (!permission.PermissionExists(Permissions, this))
                    permission.RegisterPermission(Permissions, this);
        }

        #endregion

        #region Configuration

        private static Configuration config = new Configuration();
        private class Configuration
        {
            [JsonProperty("Настройка удаления объектов")]
            public RemoveSettings RemoveSetting = new RemoveSettings();
            [JsonProperty("Настройка улучшения объектов")]
            public GradeSettings GradeSetting = new GradeSettings();
            [JsonProperty("Настройка интерфейса")]
            public InterfaceSettings InterfaceSetting = new InterfaceSettings();
            [JsonProperty("Использовать пермишенсы для включения определенного UP или ремува(смотрите в описании плагина, там указаны права)")]
            public bool UsePermission;

            #region Remove Configuration
            internal class RemoveSettings
            {
                [JsonProperty("Настройка возврата предметов после удаления")]
                public ReturnedSettings ReturnedSetting = new ReturnedSettings();
                [JsonProperty("Настройка удаления через время")]
                public TimedSettings TimedSetting = new TimedSettings();
                [JsonProperty("Настройка запретов")]
                public SettingsBlocks SettingsBlock = new SettingsBlocks();
                [JsonProperty("Время действия удаления")]
                public int RemoveTime;

                internal class ReturnedSettings
                {
                    [JsonProperty("Возвращать ресурсы за удаление строений?(true- да/false - нет)")]
                    public bool UseReturnedResource;
                    [JsonProperty("Процент возврата ресурсов за удаление строений?(true- да/false - нет)")]
                    public int PercentReturnRecource;
                    [JsonProperty("Возвращать все предметы при удалении?(true- да/false - нет)")]
                    public bool UseAllowedReturned;
                    [JsonProperty("Снижать состояние предмета при возврате?Эффект будто он поднял его через RUST систему")]
                    public bool UseDamageReturned;
                    [JsonProperty("Предметы,которые не возвращаются при удалении(Shortname)")]
                    public List<string> ShortnameNoteReturned = new List<string>();
                }
                internal class TimedSettings
                {
                    [JsonProperty("Включить полный запрет на удаление объекта через N время(Пример : Через 3 часа после постройки,его нельзя будет удалить вообще)")]
                    public bool UseAllBlock;
                    [JsonProperty("Через сколько нельзя будет удалять постройку вообще")]
                    public int TimeAllBlock;
                    [JsonProperty("Кастомный список предметов,которые нельзя будет удалить через время по правам. [[IQGradeRemove.NAME]] - Время(в сек)")]
                    public Dictionary<string, int> ItemsTimesAllPermissions = new Dictionary<string, int>();
                    [JsonProperty("Использовать запрет на удаление постройки на время(После постройки объекта,его N количество времени нельзя будет удалить)")]
                    public bool UseTimesBlock;
                    [JsonProperty("Через сколько можно будет удалять постройку(если включено)")]
                    public int TimesBlock;
                    [JsonProperty("Кастомный список предметов,которые можно будет удалить через время по правам. [[IQGradeRemove.NAME]] - Время(в сек)")]
                    public Dictionary<string, int> ItemsTimesPermissions = new Dictionary<string, int>();
                }
                internal class SettingsBlocks
                {
                    [JsonProperty("[NoEscape] Запретить удаление во время рейдблока(true - да/false - нет)")]
                    public bool NoEscape;
                    [JsonProperty("[Friends] Удалять постройки могут только друзья(Иначе все,кто есть в шкафу)(true - да/false - нет)")]
                    public bool Friends;
                    [JsonProperty("Предметы,которые нельзя удалить(Shortname)")]
                    public List<string> ShortnameNoteReturned = new List<string>();
                }
            }
            #endregion

            #region Grade Configuration
            internal class GradeSettings
            {
                [JsonProperty("Время действия улучшения")]
                public int GradeTime;
                [JsonProperty("Разрешить обратное улучшение?(Пример : МВК стенку откатить в деревянную)(true - да/false - нет)")]
                public bool UseBackUp;
                [JsonProperty("Настройка запретов")]
                public SettingsBlocks SettingsBlock = new SettingsBlocks();
                internal class SettingsBlocks
                {
                    [JsonProperty("[NoEscape] Запретить улучшение во время рейдблока(true - да/false - нет)")]
                    public bool NoEscape;
                }
            }
            #endregion 

            #region Interface
            internal class InterfaceSettings
            {
                [JsonProperty("Настройка интерфейса")]
                public MainInterface MainInterfaces = new MainInterface();

                internal class MainInterface
                {
                    [JsonProperty("Скрывать интерфейс по истечению таймера")]
                    public Boolean HideMenuTimer;
                    [JsonProperty("Отображать уровни улучшений в интерфейсе")]
                    public Boolean ShowLevelUp;
                    [JsonProperty("Отображать кнопку закрыть в меню")]
                    public Boolean ShowCloseButton;
                    [JsonProperty("Символ для кнопки закрыть")]
                    public String SymbolCloseButton;
                    [JsonProperty("Цвет панели(HEX)")]
                    public string ColorPanel;
                    [JsonProperty("Цвет текста(HEX)")]
                    public string ColorText;
                }
            }
            #endregion

            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    UsePermission = false,

                    #region Remove Configuration
                    RemoveSetting = new RemoveSettings
                    {
                        RemoveTime = 30,
                        ReturnedSetting = new RemoveSettings.ReturnedSettings
                        {
                            UseReturnedResource = true,
                            PercentReturnRecource = 50,
                            UseDamageReturned = true,
                            UseAllowedReturned = true,
                            ShortnameNoteReturned = new List<string>
                            {
                                "campfire",
                            }
                        },
                        TimedSetting = new RemoveSettings.TimedSettings
                        {
                            UseAllBlock = false,
                            TimeAllBlock = 60,
                            ItemsTimesAllPermissions = new Dictionary<string, int>
                            {
                                ["iqgraderemove.vip"] = 200,
                                ["iqgraderemove.prem"] = 250,
                                ["iqgraderemove.gold"] = 300,
                            },
                            UseTimesBlock = false,
                            TimesBlock = 100,
                            ItemsTimesPermissions = new Dictionary<string, int>
                            {
                                ["iqgraderemove.vip"] = 150,
                                ["iqgraderemove.prem"] = 200,
                                ["iqgraderemove.gold"] = 300,
                            },
                        },
                        SettingsBlock = new RemoveSettings.SettingsBlocks
                        {
                            Friends = true,
                            NoEscape = true,
                            ShortnameNoteReturned = new List<string>
                            {
                                "campfire",
                            }
                        }
                    },
                    #endregion

                    #region Grade Configuration
                    GradeSetting = new GradeSettings
                    {
                        GradeTime = 30,
                        UseBackUp = false,
                        SettingsBlock = new GradeSettings.SettingsBlocks
                        {
                            NoEscape = true,
                        }
                    },
                    #endregion

                    #region Interface
                    InterfaceSetting = new InterfaceSettings
                    {
                        MainInterfaces = new InterfaceSettings.MainInterface
                        {
                            ColorPanel = "#525252",
                            ColorText = "#C9C0B9FF",
                            SymbolCloseButton = "<",
                            ShowCloseButton = true,
                            ShowLevelUp = true,
                            HideMenuTimer = true,
                        },
                    },
                    #endregion
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning("Ошибка #132" + $"чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }
            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region Data
        public Dictionary<ulong, GradeRemove> DataPlayer = new Dictionary<ulong, GradeRemove>();
        public Dictionary<uint, int> BuildingRemoveTimers = new Dictionary<uint, int>();
        public Dictionary<uint, int> BuildingRemoveBlock = new Dictionary<uint, int>();
        void ReadData() {
            BuildingRemoveTimers = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<uint, int>>("IQGradeRemove/BlockBuilding");
            BuildingRemoveBlock = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<uint, int>>("IQGradeRemove/BuildingRemoveBlock");
        }
        void WriteData() {
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQGradeRemove/BlockBuilding", BuildingRemoveTimers);
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQGradeRemove/BuildingRemoveBlock", BuildingRemoveBlock);
        }
        ///0 - солома
        ///1 - дерево
        ///2 - камень
        ///3 - металл
        ///4 - мвк
        public class GradeRemove
        {
            public int ActiveTime;
            public int GradeLevel;
            public Boolean GradeAllObject;
            public Timer TimerEvent = null;
            public void GradeUP(BasePlayer player, bool UseMyGrade = false, int CustomGrade = 0)
            {
                if (config.UsePermission)
                    foreach (var Perm in PermissionsLevel.Where(p => inst.permission.UserHasPermission(player.UserIDString, p.Value)))
                    {
                        if (!UseMyGrade)
                        {
                            if (GradeLevel == 5) GradeLevel = 0;
                            if (GradeLevel >= Perm.Key) continue;
                            GradeLevel = Perm.Key;
                        }
                        else if (String.IsNullOrWhiteSpace(PermissionsLevel[CustomGrade]) || inst.permission.UserHasPermission(player.UserIDString, PermissionsLevel[CustomGrade]))
                        {
                            GradeLevel = CustomGrade;
                            return;
                        }
                        else inst.Interface_Error(player, inst.GetLang("NO_PERM_GRADE_REMOVE", player.UserIDString));
                        break;
                    }
                else
                {
                    if (!UseMyGrade)
                    {
                        if (GradeLevel > 4)
                            GradeLevel = 0;
                        else GradeLevel++;
                    }
                    else GradeLevel = CustomGrade;
                }

                RebootTimer();
                int TimeActive = CustomGrade != 0 & CustomGrade != 5 ? config.GradeSetting.GradeTime : config.RemoveSetting.RemoveTime;
                ActiveTime = Convert.ToInt32(TimeActive + CurrentTime());
            }
            public void RebootTimer()
            {
                if (TimerEvent != null)
                    TimerEvent.Destroy();
            }
        }
        void RegisteredUser(BasePlayer player)
        {
            if (!DataPlayer.ContainsKey(player.userID))
                DataPlayer.Add(player.userID, new GradeRemove { ActiveTime = 0, GradeLevel = 0 });

            if (player.HasFlag(BaseEntity.Flags.Reserved10))
                player.SetFlag(BaseEntity.Flags.Reserved10, false);
        }
        #endregion

        #region Grade Core
        public String GradeErrorParse(BasePlayer player, BuildingBlock buildingBlock, BuildingGrade.Enum grade = BuildingGrade.Enum.None)
        {
            var Data = DataPlayer[player.userID];
            var Block = config.GradeSetting.SettingsBlock;

            if (DeployVolume.Check(buildingBlock.transform.position, buildingBlock.transform.rotation, PrefabAttribute.server.FindAll<DeployVolume>(buildingBlock.prefabID), ~(5 << buildingBlock.gameObject.layer)))
                return GetLang("GRADE_NO_THIS_USER", player.UserIDString);

            if (Block.NoEscape && IsRaidBlocked(player))
                return GetLang("GRADE_NO_ESCAPE", player.UserIDString);

            if (buildingBlock.SecondsSinceAttacked < 30)
                return GetLang("GRADE_ATTACKED_BLOCK", player.UserIDString, FormatTime(TimeSpan.FromSeconds(30 - (int)buildingBlock.SecondsSinceAttacked)));

            if (!player.CanBuild())
                return GetLang("GRADE_NO_AUTH", player.UserIDString);

            if (!permission.UserHasPermission(player.UserIDString, PermissionGRNoResource))
            {
                Int32 Grade = grade == BuildingGrade.Enum.None ? Data.GradeLevel : (Int32)grade;
                if (!buildingBlock.CanAffordUpgrade((BuildingGrade.Enum)Grade, player))
                    return GetLang("GRADE_NO_RESOURCE", player.UserIDString);
            }

            return "";
        }

        public void GradeBuilding(BasePlayer player, BuildingBlock buildingBlock)
        {
            var Data = DataPlayer[player.userID];
            String AlertGrrade = GradeErrorParse(player, buildingBlock);
            if (!String.IsNullOrWhiteSpace(AlertGrrade))
            {
                Interface_Error(player, AlertGrrade);
                return;
            }
            if (!config.GradeSetting.UseBackUp)
                if (buildingBlock.grade > (BuildingGrade.Enum)Data.GradeLevel) return;

            if (!permission.UserHasPermission(player.UserIDString, PermissionGRNoResource))
                buildingBlock.PayForUpgrade(buildingBlock.GetGrade((BuildingGrade.Enum)Data.GradeLevel), player);

            buildingBlock.SetGrade((BuildingGrade.Enum)Data.GradeLevel);
            buildingBlock.SetHealthToMax();
            buildingBlock.UpdateSkin();

            Effect.server.Run(SoundLevelsGrade[Data.GradeLevel], player.GetNetworkPosition());
            DataPlayer[player.userID].ActiveTime = (Int32)(config.GradeSetting.GradeTime + CurrentTime());
        }


        public void GradeAll(BasePlayer player, BuildingBlock buildingBlock)
        {
            if (buildingBlock.GetBuildingPrivilege() == null)
            {
                Interface_Error(player, GetLang("GRADE_ALL_NO_AUTH",player.UserIDString));
                return;
            }
            if (!player.IsBuildingAuthed())
            {
                Interface_Error(player, GetLang("GRADE_NO_AUTH", player.UserIDString));
                return;
            }

            foreach (var Block in buildingBlock.GetBuildingPrivilege().GetBuilding().buildingBlocks.Where(x => x.grade != (BuildingGrade.Enum)DataPlayer[player.userID].GradeLevel))
            {
                if (!permission.UserHasPermission(player.UserIDString, PermissionGRNoResource))
                {
                    if (!Block.CanAffordUpgrade(((BuildingGrade.Enum)DataPlayer[player.userID].GradeLevel), player))
                    {
                        Interface_Error(player, GetLang("GRADE_NO_RESOURCE", player.UserIDString));
                        return;
                    }
                    else
                    {
                        Block.PayForUpgrade(buildingBlock.GetGrade((BuildingGrade.Enum)DataPlayer[player.userID].GradeLevel), player);
                        Block.SetGrade((BuildingGrade.Enum)DataPlayer[player.userID].GradeLevel);
                        Block.SetHealthToMax();
                        Block.UpdateSkin();
                    }
                }
                else
                {
                    Block.SetGrade((BuildingGrade.Enum)DataPlayer[player.userID].GradeLevel);
                    Block.SetHealthToMax();
                    Block.UpdateSkin();
                }
            }
        }
        #endregion

        #region Remove Core

        #region Permanent Block
        private void AddRemoveBlockBuild(UInt32 netID, UInt64 userID)
        {
            var RemoveTime = config.RemoveSetting.TimedSetting;
            if (!RemoveTime.UseAllBlock) return;
            if (IsBlockAvailablePermanent(netID)) return;
            Int32 Time = GetTimeBlockPermanent(userID);
            BuildingRemoveBlock.Add(netID, Time);
        }
        private Boolean IsBlockAvailablePermanent(UInt32 netID)
        {
            if (BuildingRemoveBlock.ContainsKey(netID))
                return true;
            else return false;
        }
        private Boolean IsBlockBuildPemanent(UInt32 netID)
        {
            if (IsBlockAvailablePermanent(netID))
                if (BuildingRemoveBlock[netID] <= CurrentTime())
                    return true;
                else return false;
            else return false;
        }
        private Int32 GetTimeBlockPermanent(UInt64 userID)
        {
            var RemoveTime = config.RemoveSetting.TimedSetting;
            Int32 Time = Convert.ToInt32(CurrentTime() + RemoveTime.TimeAllBlock);

            foreach (var Perms in RemoveTime.ItemsTimesAllPermissions)
                if (permission.UserHasPermission(userID.ToString(), Perms.Key))
                {
                    Time = Convert.ToInt32(CurrentTime() + Perms.Value);
                    return Time;
                }

            return Time;
        }
        #endregion

        #region Temporally Block
        private void AddBlockBuild(UInt32 netID, UInt64 userID)
        {
            var RemoveTime = config.RemoveSetting.TimedSetting;
            if (!RemoveTime.UseTimesBlock) return;
            if (IsBlockAvailable(netID)) return;
            Int32 Time = GetTimeBlock(userID);

            BuildingRemoveTimers.Add(netID, Time);
        }
        private Boolean IsBlockAvailable(UInt32 netID)
        {
            if (BuildingRemoveTimers.ContainsKey(netID))
                return true;
            else return false;
        }
        private Boolean IsBlockBuild(UInt32 netID)
        {
            if (IsBlockAvailable(netID))
                if (BuildingRemoveTimers[netID] > CurrentTime())
                    return true;
                else return false;
            else return false;
        }
        private Int32 GetTimeBlock(UInt64 userID = 0)
        {
            var RemoveTime = config.RemoveSetting.TimedSetting;
            Int32 Time = Convert.ToInt32(CurrentTime() + RemoveTime.TimesBlock);
            if (!userID.IsSteamId()) return Time;

            foreach (var Perms in RemoveTime.ItemsTimesPermissions)
                if (permission.UserHasPermission(userID.ToString(), Perms.Key))
                {
                    Time = Convert.ToInt32(CurrentTime() + Perms.Value);
                    return Time;
                }

            return Time;
        }
        private Int32 GetTimerBlock(UInt32 netID)
        {
            Int32 Time = 0;
            if (IsBlockAvailable(netID))
                Time = Convert.ToInt32(BuildingRemoveTimers[netID] - CurrentTime());
            return Time;
        }
        #endregion

        void ReturnedRemoveItems(BasePlayer player, BaseEntity buildingBlock)
        {
            var Remove = config.RemoveSetting.ReturnedSetting;
            if(Remove.ShortnameNoteReturned.Contains(Regex.Replace(buildingBlock.ShortPrefabName.Replace("mining_quarry", "mining.quarry"), "\\.deployed|_deployed", ""))) return;

            if (Remove.UseAllowedReturned)
            {
                Item ItemReturned = buildingBlock is BaseOven || buildingBlock is MiningQuarry || buildingBlock is BaseLadder || buildingBlock.GetComponent<BaseCombatEntity>().pickup.itemTarget == null ?
                                    ItemManager.CreateByName(Regex.Replace(buildingBlock.ShortPrefabName.Replace("mining_quarry", "mining.quarry"), "\\.deployed|_deployed", ""), 1) : ItemManager.Create(buildingBlock.GetComponent<BaseCombatEntity>().pickup.itemTarget, 1);

                if (ItemReturned != null)
                {
                    if (Remove.UseDamageReturned)
                    {
                        Single healthFraction = buildingBlock.GetComponent<BaseCombatEntity>().Health() / buildingBlock.GetComponent<BaseCombatEntity>().MaxHealth();
                        ItemReturned.conditionNormalized = Mathf.Clamp01(healthFraction - buildingBlock.GetComponent<BaseCombatEntity>().pickup.subtractCondition);
                    }
                    player.GiveItem(ItemReturned);
                    return;
                }
            }
            if (Remove.UseReturnedResource)
                if (buildingBlock is StabilityEntity)
                {
                    Single PercentResource = (Single)((Single)(Remove.PercentReturnRecource) / (Single)(100));
                    foreach (var CostReturned in (buildingBlock as StabilityEntity).BuildCost())
                        player.GiveItem(ItemManager.Create(CostReturned.itemDef, Mathf.FloorToInt((Single)CostReturned.amount * PercentResource)));
                    return;
                }
        }

        public void RemoveAll(BasePlayer player, BaseEntity buildingBlock)
        {
            if (buildingBlock.GetBuildingPrivilege() == null)
            {
                Interface_Error(player, GetLang("REMOVE_ALL_NO_AUTH", player.UserIDString));
                return;
            }
            ListHashSet<BuildingBlock> BlocksRemoveAll = new ListHashSet<BuildingBlock>();
            foreach (var Block in buildingBlock.GetBuildingPrivilege().GetBuilding().buildingBlocks)
                if (!BlocksRemoveAll.Contains(Block))
                     BlocksRemoveAll.Add(Block);


            NextTick(() =>
            {
                foreach (var Block in BlocksRemoveAll)
                    Block.Kill();
            });
        }

        public string RemoveErrorParseBuilding(BasePlayer player, BaseEntity buildingBlock)
        {
            var Remove = config.RemoveSetting;
            var Block = Remove.SettingsBlock;
            var RemoveTimed = Remove.TimedSetting;

            if(buildingBlock.OwnerID == 0)
                return GetLang("REMOVE_ONLY_FRIENDS", player.UserIDString);

            if (Block.NoEscape && IsRaidBlocked(player))
                return GetLang("REMOVE_NO_ESCAPE", player.UserIDString);

            BuildingBlock buildingBlocks = buildingBlock.GetComponent<BuildingBlock>();
            if (buildingBlocks != null)
            {
                if (buildingBlocks.SecondsSinceAttacked < 30)
                    return GetLang("REMOVE_ATTACKED_BLOCK", player.UserIDString, FormatTime(TimeSpan.FromSeconds(30 - (int)buildingBlocks.SecondsSinceAttacked)));
            }

            if (Block.Friends && player.userID != buildingBlock.OwnerID)
            {
                if (!IsFriends(player.userID, buildingBlock.OwnerID))
                    return GetLang("REMOVE_ONLY_FRIENDS", player.UserIDString);
                else if (player.IsBuildingBlocked())
                    return GetLang("REMOVE_NO_AUTH", player.UserIDString);
            }
            else if (player.IsBuildingBlocked())
                return GetLang("REMOVE_NO_AUTH", player.UserIDString);

            if (RemoveTimed.UseTimesBlock && IsBlockBuild(buildingBlock.net.ID))
                return GetLang("REMOVE_TIME_EXECUTE", player.UserIDString, FormatTime(TimeSpan.FromSeconds(GetTimerBlock(buildingBlock.net.ID))));

            if (RemoveTimed.UseAllBlock && IsBlockBuildPemanent(buildingBlock.net.ID))
                return GetLang("REMOVE_TIME_EXECUTE_UNREMOVE", player.UserIDString);

            if (Block.ShortnameNoteReturned.Contains(Regex.Replace(buildingBlock.ShortPrefabName.Replace("mining_quarry", "mining.quarry"), "\\.deployed|_deployed", "")))
                return GetLang("REMOVE_UNREMOVE", player.UserIDString);

            return "";
        }

        public void RemoveBuilding(BasePlayer player, BaseEntity buildingBlock)
        {
            String Alert = RemoveErrorParseBuilding(player, buildingBlock);
            if (!String.IsNullOrWhiteSpace(Alert))
            {
                Interface_Error(player, Alert);
                return;
            }

            ReturnedRemoveItems(player, buildingBlock);

            NextTick(() => {
                {
                    StorageContainer container = buildingBlock.GetComponent<StorageContainer>();
                    if (container != null) 
                        container.DropItems();

                    buildingBlock.Kill(BaseNetworkable.DestroyMode.Gib);
                }
            });
            DataPlayer[player.userID].ActiveTime = (int)(config.RemoveSetting.RemoveTime + CurrentTime());
        }
        #endregion

        #region Commands

        [ConsoleCommand("up")]
        void UPCommandConsole(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;

            var Data = DataPlayer[player.userID];

            Int32 GradeLevel;
            if (arg?.Args != null && Int32.TryParse(arg.Args[0], out GradeLevel))
            {
                if (GradeLevel < 0 || GradeLevel > 4)
                    return;

                Data.GradeUP(player, true, GradeLevel);
            }
            else Data.GradeUP(player);

            if (!player.HasFlag(BaseEntity.Flags.Reserved10))
                Interface_New_Main(player);

            GradeRemove_Status(player);

            if (Data.GradeLevel != 0)
                UpdateButton_Upgrade(player);
            else CuiHelper.DestroyUi(player, $"UpgradeButtonStatus");
        }

        [ConsoleCommand("building.upgrade")]
        void BUpgradeCommandConsole(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            var Data = DataPlayer[player.userID];

            Int32 GradeLevel;
            if (arg?.Args != null && Int32.TryParse(arg.Args[0], out GradeLevel))
            {
                if (GradeLevel < 0 || GradeLevel > 4)
                    return;

                Data.GradeUP(player, true, GradeLevel);
            }
            else Data.GradeUP(player);

            if (!player.HasFlag(BaseEntity.Flags.Reserved10))
                Interface_New_Main(player);

            GradeRemove_Status(player);

            if (Data.GradeLevel != 0)
                UpdateButton_Upgrade(player);
            else CuiHelper.DestroyUi(player, $"UpgradeButtonStatus");
        }

        [ConsoleCommand("remove")]
        void RemoveCommandConsole(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            var Data = DataPlayer[player.userID];
            if (Data.GradeLevel == 5)
                Data.GradeUP(player, true, 0);
            else Data.GradeUP(player, true, 5);

            if (!player.HasFlag(BaseEntity.Flags.Reserved10))
                Interface_New_Main(player);

            GradeRemove_Status(player);
        }

        [ChatCommand("up")]
        void UPCommand(BasePlayer player, string cmd, string[] arg)
        {
            var Data = DataPlayer[player.userID];
            switch (arg.Length)
            {
                case 0:
                    {
                        Data.GradeUP(player);
                        break;
                    }
                case 1:
                    {
                        Int32 GradeLevel;
                        if (!int.TryParse(arg[0], out GradeLevel) || GradeLevel < 0 || GradeLevel > 4)
                            return;
                        
                        Data.GradeUP(player, true, GradeLevel);
                        break;
                    }
            }
            if (!player.HasFlag(BaseEntity.Flags.Reserved10))
                Interface_New_Main(player);

            GradeRemove_Status(player);

            if (Data.GradeLevel != 0)
                UpdateButton_Upgrade(player);
            else CuiHelper.DestroyUi(player, $"UpgradeButtonStatus");
        }
        
        [ChatCommand("bgrade")]
        void BGradeChatCommand(BasePlayer player, string cmd, string[] arg)
        {
            var Data = DataPlayer[player.userID];
            switch (arg.Length)
            {
                case 0:
                    {
                        Data.GradeUP(player);
                        break;
                    }
                case 1:
                    {
                        int GradeLevel;
                        if (!int.TryParse(arg[0], out GradeLevel) || GradeLevel < 0 || GradeLevel > 4)
                            return;
                        
                        Data.GradeUP(player, true, GradeLevel);
                        break;
                    }
            }
            if (!player.HasFlag(BaseEntity.Flags.Reserved10))
                Interface_New_Main(player);

            GradeRemove_Status(player);

            if (Data.GradeLevel != 0)
                UpdateButton_Upgrade(player);
            else CuiHelper.DestroyUi(player, $"UpgradeButtonStatus");
        }
        [ChatCommand("remove")]
        void RemoveCommand(BasePlayer player, string cmd, string[] arg)
        {
            var Data = DataPlayer[player.userID];
            if (Data.GradeLevel == 5)
                Data.GradeUP(player, true, 0);
            else Data.GradeUP(player, true, 5);

            if (!player.HasFlag(BaseEntity.Flags.Reserved10))
                Interface_New_Main(player);

            GradeRemove_Status(player);
        }
   

        [ConsoleCommand("gr.func.turned")] 
        void UI_ConsoleCommandAdminMenu(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            var Data = DataPlayer[player.userID];

            if (Data.GradeAllObject)
                Data.GradeAllObject = false;
            else Data.GradeAllObject = true;

            GradeRemove_AllObject_Turned(player);
        }
        #endregion

        #region Hooks
        void OnHammerHit(BasePlayer player, HitInfo info)
        {
            if (info == null || player == null || info.HitEntity == null) return;
            var Data = DataPlayer[player.userID];

            if (Data.GradeLevel == 5)
                if (info.HitEntity is BaseEntity)
                    RemoveBuilding(player, info.HitEntity);

            BuildingBlock buildingBlock = info.HitEntity as BuildingBlock;
            if (buildingBlock == null) return;

            if (Data.GradeAllObject && Data.GradeLevel > 0 && Data.GradeLevel != 5)
            {
                GradeAll(player, buildingBlock);
                return;
            }
            if(Data.GradeAllObject && Data.GradeLevel == 5)
            {
                RemoveAll(player, buildingBlock);
                return;
            }

            if (Data.GradeLevel != 0 && Data.GradeLevel != 5)
            {
                if (buildingBlock.grade == (BuildingGrade.Enum)Data.GradeLevel)
                    return;
                
                GradeBuilding(player, buildingBlock);
            }
        }
        object OnStructureUpgrade(BaseCombatEntity entity, BasePlayer player, BuildingGrade.Enum grade)
        {
            String Alert = GradeErrorParse(player, entity.GetComponent<BuildingBlock>(), grade);
            if (!String.IsNullOrWhiteSpace(Alert)) // grade
            {
                Interface_Error(player, Alert);
                return false;
            }
            return null;
        }
        private void OnEntityBuilt(Planner plan, GameObject go)
        {
            BasePlayer player = plan?.GetOwnerPlayer();
            if (player == null || go == null) return;

            if (go.ToBaseEntity() is BuildingBlock || go.ToBaseEntity() is BaseEntity)
            {
                AddRemoveBlockBuild(go.ToBaseEntity().net.ID, player.userID);
                AddBlockBuild(go.ToBaseEntity().net.ID, player.userID);
            }

            BuildingBlock buildingBlock = go.ToBaseEntity().GetComponent<BuildingBlock>();
            if (buildingBlock == null) return;
            var Data = DataPlayer[player.userID];
            if (Data == null) return;
           // if (Data.GradeLevel == 6 || Data.GradeLevel == 7) return;

            if (Data.GradeLevel != 0 && Data.GradeLevel != 5)
                GradeBuilding(player, buildingBlock);
        }
        void OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            if (player == null || info == null || player.userID < 2147483647) return;
            CuiHelper.DestroyUi(player, GradeRemoveOverlay);
        }
        #region Server Hooks
        public static IQGradeRemove inst;
        void Init() => ReadData();
        private void OnServerInitialized()
        {
            inst = this;
            foreach (var p in BasePlayer.activePlayerList)
                OnPlayerConnected(p);
            RegisteredPermissions();
        }
        void OnPlayerConnected(BasePlayer player) => RegisteredUser(player);
        void Unload()
        {
            WriteData();
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, GradeRemoveOverlay);
                if (player.HasFlag(BaseEntity.Flags.Reserved10))
                    player.SetFlag(BaseEntity.Flags.Reserved10, false);
            }
        }
        void OnNewSave(string filename)
        {
            BuildingRemoveTimers.Clear();
            BuildingRemoveBlock.Clear();
            WriteData();
        }
        #endregion

        #endregion

        #region UI
        public static String GradeRemoveOverlay = "GradeRemoveOverlay";

        [ChatCommand("grade")]
        void Interface_New_Main(BasePlayer player)
        {
            var Data = DataPlayer[player.userID];
            var Interface = config.InterfaceSetting;
            var MainInterface = Interface.MainInterfaces;
            Data.RebootTimer();

            if (player.HasFlag(BaseEntity.Flags.Reserved10))
            {
                Data.GradeLevel = 0;
                CuiHelper.DestroyUi(player, GradeRemoveOverlay);
                player.SetFlag(BaseEntity.Flags.Reserved10, false);
                return;
            }
            player.SetFlag(BaseEntity.Flags.Reserved10, true);

            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = $"0.7075472 0.703154 0.5640352 0" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "16.19 19.273", OffsetMax = "396.002 78.727" }
            }, "Overlay", GradeRemoveOverlay);

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = HexToRustFormat(MainInterface.ColorPanel) },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "0.092 0.274", OffsetMax = "190.02047 30" }  
            }, GradeRemoveOverlay, "InformationPanel");

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = HexToRustFormat(MainInterface.ColorText) },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "159.871 1.976", OffsetMax = "-29.36 -1.9762047" }  
            }, "InformationPanel", "LinePanel");

            if (Interface.MainInterfaces.ShowCloseButton)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = HexToRustFormat(MainInterface.ColorPanel), Command = "chat.say /grade" },
                    Text = { Text = Interface.MainInterfaces.SymbolCloseButton, Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "191.404 -29.453", OffsetMax = "210.07 0.273" }
                }, GradeRemoveOverlay, "CloseUI");
            }

            CuiHelper.DestroyUi(player, "GradeRemoveOverlay");
            CuiHelper.AddUi(player, container);

            GradeRemove_Status(player);
            GradeRemove_AllObject_Turned(player);
        }
        void Update_Take_Button_UP(BasePlayer player)
        {
            if (!player.HasFlag(BaseEntity.Flags.Reserved10))
                return;

            CuiHelper.DestroyUi(player, "ButtonUpgrade");
            var Interface = config.InterfaceSetting;
            var MainInterface = Interface.MainInterfaces;
            var container = new CuiElementContainer();
            var Data = DataPlayer[player.userID];

            String ColorButton = Data.GradeLevel != 0 && Data.GradeLevel <= 4 ? "#373737" : MainInterface.ColorPanel;

            container.Add(new CuiButton
            {
                Button = { Color = HexToRustFormat(ColorButton), Command = "chat.say /up" },
                Text = { Text = GetLang("TITLE_TAKE_UP", player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 12, Align = TextAnchor.MiddleCenter, Color = HexToRustFormat(MainInterface.ColorText) },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "193.415 0.273", OffsetMax = "284.785 29.999" }
            }, "GradeRemoveOverlay", "ButtonUpgrade");

            CuiHelper.AddUi(player, container);
        }
        void Update_Take_Button_REMOVE(BasePlayer player)
        {
            if (!player.HasFlag(BaseEntity.Flags.Reserved10))
                return;
            CuiHelper.DestroyUi(player, "ButtonRemove");
            CuiHelper.DestroyUi(player, $"UpgradeButtonStatus");

            var Interface = config.InterfaceSetting;
            var MainInterface = Interface.MainInterfaces;
            var container = new CuiElementContainer();
            var Data = DataPlayer[player.userID];

            String ColorButton = Data.GradeLevel > 4 ? "#373737" : MainInterface.ColorPanel;

            container.Add(new CuiButton
            {
                Button = { Color = HexToRustFormat(ColorButton), Command = "chat.say /remove" },
                Text = { Text = GetLang("TITLE_TAKE_REMOVE", player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 12, Align = TextAnchor.MiddleCenter, Color = HexToRustFormat(MainInterface.ColorText) },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "288.535 0.273", OffsetMax = "379.905 29.999" }
            }, "GradeRemoveOverlay", "ButtonRemove");

            CuiHelper.AddUi(player, container);
        }

        void GradeRemove_Status(BasePlayer player)
        {
            UpdateLabelStatus(player);
            Update_Take_Button_UP(player);
            Update_Take_Button_REMOVE(player);
        }

        void GradeRemove_AllObject_Turned(BasePlayer player)
        {
            var Interface = config.InterfaceSetting;
            var MainInterface = Interface.MainInterfaces;
            var Data = DataPlayer[player.userID];

            CuiHelper.DestroyUi(player, $"AdminButtonDeleteAll");

            CuiElementContainer container = new CuiElementContainer();

            if (permission.UserHasPermission(player.UserIDString, PermissionGRMenu))
            {
                String ColorButton = Data.GradeAllObject ? "#373737" : MainInterface.ColorPanel;

                container.Add(new CuiButton
                {
                    Button = { Color = HexToRustFormat(ColorButton), Command = "gr.func.turned" },
                    Text = { Text = GetLang("TITLE_GR_ADMIN_ALL_OBJ", player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 12, Align = TextAnchor.MiddleCenter, Color = HexToRustFormat(MainInterface.ColorText) },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "193.415 31.363", OffsetMax = "379.905 59.727" }
                }, "GradeRemoveOverlay", "AdminButtonDeleteAll");
            }

            CuiHelper.AddUi(player, container);
        }
        void UpdateButton_Upgrade(BasePlayer player)
        {
            if (!config.InterfaceSetting.MainInterfaces.ShowLevelUp) return;

            if (!player.HasFlag(BaseEntity.Flags.Reserved10))
                return;

            var Interface = config.InterfaceSetting;
            var MainInterface = Interface.MainInterfaces;
            var Data = DataPlayer[player.userID];
            
            CuiHelper.DestroyUi(player, $"UpgradeButtonStatus");

            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0.2196079 0.2196079 0.2196079 0" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "0.091 31.363", OffsetMax = "190.001 59.727" }
            }, GradeRemoveOverlay, "UpgradeButtonStatus");

            container.Add(new CuiButton
            {
                Button = { Color = HexToRustFormat(MainInterface.ColorPanel), Command = "up 1" },
                Text = { Text = "", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.UpperLeft, Color = "1 1 1 1" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "-145.386 0.364" }
            }, "UpgradeButtonStatus", "ButtonUpgradeLevelOne");

            String HexGradeWood = Data.GradeLevel == 1 ? "#F3F3F3" : "#373737";
            String SpriteCheckWood = config.UsePermission ? permission.UserHasPermission(player.UserIDString, PermissionsLevel[1]) ? "assets/icons/level_wood.png" : "assets/icons/occupied.png" : "assets/icons/level_wood.png";
            String AnchorMinWood = config.UsePermission ? permission.UserHasPermission(player.UserIDString, PermissionsLevel[1]) ? "0.2 0.1" : "0.25 0.15" : "0.2 0.1";
            String AnchorMaxWood = config.UsePermission ? permission.UserHasPermission(player.UserIDString, PermissionsLevel[1]) ? "0.8 0.9" : "0.75 0.85" : "0.8 0.9"; 

            container.Add(new CuiPanel
            {
                Image = { Color = HexToRustFormat(HexGradeWood), Sprite = SpriteCheckWood },
                RectTransform = { AnchorMin = AnchorMinWood, AnchorMax = AnchorMaxWood }
            }, "ButtonUpgradeLevelOne", "SpriteLevelOne");

            container.Add(new CuiButton
            {
                Button = { Color = HexToRustFormat(MainInterface.ColorPanel), Command = "up 2" },
                Text = { Text = "", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.UpperLeft, Color = "1 1 1 1" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "48.993 0", OffsetMax = "-96.393 0.364" }
            }, "UpgradeButtonStatus", "ButtonUpgradeLeveTwo");

            String HexGradeStone = Data.GradeLevel == 2 ? "#F3F3F3" : "#373737";
            String SpriteCheckStone = config.UsePermission ? permission.UserHasPermission(player.UserIDString, PermissionsLevel[2]) ? "assets/icons/level_stone.png" : "assets/icons/occupied.png" : "assets/icons/level_stone.png";
            String AnchorMinStone = config.UsePermission ? permission.UserHasPermission(player.UserIDString, PermissionsLevel[2]) ? "0.2 0.1" : "0.25 0.15" : "0.2 0.1";
            String AnchorMaxStone = config.UsePermission ? permission.UserHasPermission(player.UserIDString, PermissionsLevel[2]) ? "0.8 0.9" : "0.75 0.85" : "0.8 0.9";
            container.Add(new CuiPanel
            {
                Image = { Color = HexToRustFormat(HexGradeStone), Sprite = SpriteCheckStone },
                RectTransform = { AnchorMin = AnchorMinStone, AnchorMax = AnchorMaxStone }
            }, "ButtonUpgradeLeveTwo", "SpriteLevelTwo");

            container.Add(new CuiButton
            {
                Button = { Color = HexToRustFormat(MainInterface.ColorPanel), Command = "up 3" },
                Text = { Text = "", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.UpperLeft, Color = "1 1 1 1" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "96.893 0", OffsetMax = "-48.493 0.364" }
            }, "UpgradeButtonStatus", "ButtonUpgradeLevelThree");

            String HexGradeMetal = Data.GradeLevel == 3 ? "#F3F3F3" : "#373737";
            String SpriteCheckMetal = config.UsePermission ? permission.UserHasPermission(player.UserIDString, PermissionsLevel[3]) ? "assets/icons/level_metal.png" : "assets/icons/occupied.png" : "assets/icons/level_metal.png";
            String AnchorMinMetal = config.UsePermission ? permission.UserHasPermission(player.UserIDString, PermissionsLevel[3]) ? "0.2 0.1" : "0.25 0.15" : "0.2 0.1";
            String AnchorMaxMetal = config.UsePermission ? permission.UserHasPermission(player.UserIDString, PermissionsLevel[3]) ? "0.8 0.9" : "0.75 0.85" : "0.8 0.9";
            container.Add(new CuiPanel
            {
                Image = { Color = HexToRustFormat(HexGradeMetal), Sprite = SpriteCheckMetal },
                RectTransform = { AnchorMin = AnchorMinMetal, AnchorMax = AnchorMaxMetal }
            }, "ButtonUpgradeLevelThree", "SpriteLevelThree");

            container.Add(new CuiButton
            {
                Button = { Color = HexToRustFormat(MainInterface.ColorPanel), Command = "up 4" },
                Text = { Text = "", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.UpperLeft, Color = "1 1 1 1" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "145.386 0", OffsetMax = "0 0.364" }
            }, "UpgradeButtonStatus", "ButtonUpgradeLevelFo");

            String HexGradeTop = Data.GradeLevel == 4 ? "#F3F3F3" : "#373737";
            String SpriteCheckTop = config.UsePermission ? permission.UserHasPermission(player.UserIDString, PermissionsLevel[4]) ? "assets/icons/level_top.png" : "assets /icons/occupied.png" : "assets/icons/level_top.png";
            String AnchorMinTop = config.UsePermission ? permission.UserHasPermission(player.UserIDString, PermissionsLevel[4]) ? "0.2 0.1" : "0.25 0.15" : "0.2 0.1";
            String AnchorMaxTop = config.UsePermission ? permission.UserHasPermission(player.UserIDString, PermissionsLevel[4]) ? "0.8 0.9" : "0.75 0.85" : "0.8 0.9";
            container.Add(new CuiPanel
            {
                Image = { Color = HexToRustFormat(HexGradeTop), Sprite = SpriteCheckTop },
                RectTransform = { AnchorMin = AnchorMinTop, AnchorMax = AnchorMaxTop }
            }, "ButtonUpgradeLevelFo", "SpriteLevelFo");

            CuiHelper.AddUi(player, container);
        }

        void UpdateLabelStatus(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "SpriteStatus");
            CuiHelper.DestroyUi(player, "LabelStatus");
            var Interface = config.InterfaceSetting;
            var MainInterface = Interface.MainInterfaces;
            var Data = DataPlayer[player.userID];

            if (Data.ActiveTime - CurrentTime() <= 1 && Data.GradeLevel != 0)
            {
                Data.GradeLevel = 0;
                if (Interface.MainInterfaces.HideMenuTimer)
                {
                    Data.RebootTimer();
                    CuiHelper.DestroyUi(player, GradeRemoveOverlay);
                    player.SetFlag(BaseEntity.Flags.Reserved10, false);
                }
                else
                {
                    CuiHelper.DestroyUi(player, $"UpgradeButtonStatus");
                    GradeRemove_Status(player);
                }
                return;
            }

            CuiElementContainer container = new CuiElementContainer();
            String SpriteStatus = Data.GradeLevel == 0 ? "assets/icons/loading.png" : Data.GradeLevel != 0 && Data.GradeLevel <= 4 ? "assets/icons/upgrade.png" : "assets/icons/level_stone.png";

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = HexToRustFormat(MainInterface.ColorText), Sprite = SpriteStatus },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "162.344 3.414", OffsetMax = "-4.744 -3.414" }
            }, "InformationPanel", "SpriteStatus");

            String LangStatus = Data.GradeLevel == 0 ? GetLang("TITLE_GR_ADMIN", player.UserIDString) : Data.GradeLevel != 0 && Data.GradeLevel <= 4 ?
            GetLang("GRADE_TITLE", player.UserIDString, StatusLevels[Data.GradeLevel], FormatTime(TimeSpan.FromSeconds(Data.ActiveTime - CurrentTime()))) :
            GetLang("REMOVE_TITLE", player.UserIDString, FormatTime(TimeSpan.FromSeconds(Data.ActiveTime - CurrentTime())));

            container.Add(new CuiElement
            {
                Name = "LabelStatus",
                Parent = "InformationPanel",
                Components = {
                    new CuiTextComponent { Text = LangStatus, Font = "robotocondensed-bold.ttf", FontSize = 12, Align = TextAnchor.MiddleCenter, Color = HexToRustFormat(MainInterface.ColorText) },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0.044 0.137", OffsetMax = "-32.266 -0.136" }
                }
            });

            CuiHelper.AddUi(player, container);

            Data.RebootTimer();
            if (Data.GradeLevel == 0)
                return;
            Data.TimerEvent = timer.Once(1f, () => UpdateLabelStatus(player));
        }

        void Interface_Error(BasePlayer player, String Message)
        {
            player.SendConsoleCommand("gametip.showtoast", new object[] 
            {
                "1",
                Message
            });
            Effect.server.Run("assets/bundled/prefabs/fx/invite_notice.prefab", player.GetNetworkPosition());
        }

        private static string HexToRustFormat(string hex)
        {
            Color color;
            ColorUtility.TryParseHtmlString(hex, out color);
            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }

        public static StringBuilder sb = new StringBuilder();
        public string GetLang(string LangKey, string userID = null, params object[] args)
        {
            sb.Clear();
            if (args != null)
            {
                sb.AppendFormat(lang.GetMessage(LangKey, this, userID), args);
                return sb.ToString();
            }
            return lang.GetMessage(LangKey, this, userID);
        }
        #endregion

        #region Lang

        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["TITLE_GR_ADMIN"] = "<b><size=12>CHOOSE AVAILABLE MODE</size></b>",
                ["TITLE_TAKE_UP"] = "<b><size=12>UPGRADE</size></b>",
                ["TITLE_GR_ADMIN_ALL_OBJ"] = "<b><size=12>ВСЕ ПРИВЯЗАННЫЕ ОБЪЕКТЫ</size></b>",
                ["TITLE_TAKE_REMOVE"] = "<b><size=12>REMOVE</size></b>",
                ["GR_REMOVE_ALL_USE"] = "<b><size=10>REMOVE ALL</size></b>",
                ["GR_UP_ALL_USE"] = "<b><size=10>UP ALL</size></b>",

                ["REMOVE_TITLE"] = "<b><size=10>REMOVE ITEMS : {0}</size></b>",
                ["REMOVE_NO_ESCAPE"] = "<b><size=10>DO NOT REMOVE BUILDINGS DURING THE RAID</size></b>",
                ["REMOVE_NO_AUTH"] = "<b><size=10>DO NOT REMOVE OTHER BUILDINGS</size></b>",
                ["REMOVE_ATTACKED_BLOCK"] = "<b><size=11>CAN BE DELETED THROUG {0}</size></b>",
                ["REMOVE_TIME_EXECUTE"] = "<b><size=10>YOU CAN REMOVE AN OBJECT THROUGH : {0}</size></b>",
                ["REMOVE_TIME_EXECUTE_UNREMOVE"] = "<b><size=10>YOU CAN'T REMOVE IT MORE</size></b>",
                ["REMOVE_UNREMOVE"] = "<b><size=12>YOU CAN'T REMOVE</size></b>",
                ["REMOVE_ALL_UNDO"] = "<b><size=10>UNDO</size></b>",
                ["REMOVE_ONLY_FRIENDS"] = "<b><size=10>YOU CAN REMOVE FRIENDS ONLY</size></b>",

                ["GRADE_TITLE"] = "<b><size=10>UPDATE {0}</size></b>",
                ["GRADE_NO_ESCAPE"] = "<b><size=10>CANNOT IMPROVE BUILDINGS DURING THE RAID</size></b>",
                ["GRADE_NO_AUTH"] = "<b><size=10>DO NOT IMPROVE DEVELOPMENTS IN ANOTHER'S TERRITORY</size></b>",
                ["GRADE_ATTACKED_BLOCK"] = "<b><size=11>YOU CAN IMPROVE THROUGH {0}</size></b>",
                ["GRADE_NO_RESOURCE"] = "<b><size=11>NOT ENOUGH RESOURCES FOR IMPROVEMENT</size></b>",
                ["GRADE_NO_THIS_USER"] = "<b><size=11>A PLAYER IS IN THE CONSTRUCTION</size></b>",
                ["GRADE_ALL_NO_AUTH"] = "<b><size=10>IT IS IMPOSSIBLE TO IMPROVE EVERYTHING WITHOUT A CABINET</size></b>",
                ["REMOVE_ALL_NO_AUTH"] = "<b><size=10>DO NOT REMOVE ALL WITHOUT CABINET</size></b>",

                ["NO_PERM_GRADE_REMOVE"] = "<b><size=10>YOU HAVE NO RIGHT TO DO THIS</size></b>",

            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["TITLE_GR_ADMIN"] = "<b><size=12>ВЫБЕРИТЕ ДОСТУПНЫЙ РЕЖИМ</size></b>",
                ["TITLE_GR_ADMIN_ALL_OBJ"] = "<b><size=12>ВСЕ ПРИВЯЗАННЫЕ ОБЪЕКТЫ</size></b>",
                ["TITLE_TAKE_UP"] = "<b><size=12>УЛУЧШЕНИЕ</size></b>",
                ["TITLE_TAKE_REMOVE"] = "<b><size=12>УДАЛЕНИЕ</size></b>",
                ["GR_UP_ALL_USE"] = "<b><size=10>УЛУЧШЕНИЯ ВСЕХ ОБЪЕКТОВ</size></b>",

                ["REMOVE_TITLE"] = "<b><size=10>УДАЛЕНИЕ ПОСТРОЕК : {0}</size></b>", 
                ["REMOVE_NO_ESCAPE"] = "<b><size=10>НЕЛЬЗЯ УДАЛЯТЬ ПОСТРОЙКИ ВО ВРЕМЯ РЕЙДА</size></b>",
                ["REMOVE_NO_AUTH"] = "<b><size=10>НЕЛЬЗЯ УДАЛЯТЬ ЧУЖИЕ ПОСТРОЙКИ</size></b>",
                ["REMOVE_ATTACKED_BLOCK"] = "<b><size=11>УДАЛИТЬ МОЖНО БУДЕТ ЧЕРЕЗ {0}</size></b>",
                ["REMOVE_TIME_EXECUTE"] = "<b><size=10>ВЫ СМОЖЕТЕ УДАЛИТЬ ОБЪЕКТ ЧЕРЕЗ : {0}</size></b>",
                ["REMOVE_TIME_EXECUTE_UNREMOVE"] = "<b><size=10>ВЫ БОЛЬШЕ НЕ МОЖЕТЕ УДАЛИТЬ ЭТОТ ОБЪЕКТ</size></b>",
                ["REMOVE_UNREMOVE"] = "<b><size=12>ВЫ НЕ МОЖЕТЕ УДАЛИТЬ ЭТОТ ОБЪЕКТ</size></b>",
                ["REMOVE_ALL"] = "<b><size=10>ВКЛЮЧЕНО УДАЛЕНИЯ ВСЕХ ОБЪЕКТОВ</size></b>",
                ["REMOVE_ALL_UNDO"] = "<b><size=10>ВЕРНУТЬ</size></b>",
                ["REMOVE_ALL_NO_AUTH"] = "<b><size=10>НЕЛЬЗЯ УДАЛИТЬ ВСЕ БЕЗ ШКАФА</size></b>",
                ["REMOVE_ONLY_FRIENDS"] = "<b><size=10>ВЫ МОЖЕТЕ УДАЛЯТЬ ТОЛЬКО ПОСТРОЙКИ ДРУЗЕЙ</size></b>",

                ["GRADE_TITLE"] = "<b><size=10>УЛУЧШЕНИЕ ДО {0} : {1}</size></b>",
                ["GRADE_NO_ESCAPE"] = "<b><size=10>НЕЛЬЗЯ УЛУЧШАТЬ ПОСТРОЙКИ ВО ВРЕМЯ РЕЙДА</size></b>",
                ["GRADE_NO_AUTH"] = "<b><size=10>НЕЛЬЗЯ УЛУЧШАТЬ ПОСТРОЙКИ НА ЧУЖОЙ ТЕРРИТОРИИ</size></b>",
                ["GRADE_ATTACKED_BLOCK"] = "<b><size=11>УЛУЧШИТЬ МОЖНО БУДЕТ ЧЕРЕЗ {0}</size></b>",
                ["GRADE_NO_RESOURCE"] = "<b><size=11>НЕДОСТАТОЧНО РЕСУРСОВ ДЛЯ УЛУЧШЕНИЯ</size></b>",
                ["GRADE_NO_THIS_USER"] = "<b><size=11>В ПОСТРОЙКЕ НАХОДИТСЯ ПРЕДМЕТ</size></b>",
                ["GRADE_ALL_NO_AUTH"] = "<b><size=10>НЕЛЬЗЯ УЛУЧШИТЬ ВСЕ БЕЗ ШКАФА</size></b>",

                ["NO_PERM_GRADE_REMOVE"] = "<b><size=10>У ВАС НЕТ ПРАВ ДЛЯ ЭТОГО</size></b>",

            }, this, "ru");
            PrintWarning("Языковой файл загружен успешно");
        }
        #endregion
    }
}


// --- End of file: IQGradeRemove.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BuriedTreasure (1).cs ---
// --- Original Local Path: BuriedTreasure (1).cs ---

using System;
using Rust;
using Oxide.Core;
using Newtonsoft.Json;
using Oxide.Core.Configuration;
using System.Runtime.CompilerServices;
using System.Collections.Generic;
using UnityEngine;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("BuriedTreasure", "Colon Blow", "1.0.10")]
	[Description("Куплено на Oxide Russia")]
	
    class BuriedTreasure : RustPlugin
    {

        // Test fix for possible conflict with plugins using the CanNetworkTo

        #region Load

        [PluginReference] Plugin ServerRewards;
        [PluginReference] Plugin Economics;

        void Loaded()
        {
            permission.RegisterPermission("buriedtreasure.admin", this);
        }

        #endregion

        #region Configuration

        private static PluginConfig config;

        private class PluginConfig
        {
            public GlobalSettings globalSettings { get; set; }

            public class GlobalSettings
            {
                [JsonProperty(PropertyName = "Gold - Enable gold to be sold for Server Reward Points ? ")] public bool UseServerRewards { get; set; }
                [JsonProperty(PropertyName = "Gold - Enable gold to be sold for Economics Bucks ? ")] public bool UseEconomics { get; set; }
                [JsonProperty(PropertyName = "Gold - Player will get this many Server Reward Points when selling 1 gold : ")] public int ServerRewardsGoldExhcange { get; set; }
                [JsonProperty(PropertyName = "Gold - Player will get this many Economics Bucks when selling 1 gold : ")] public int EconomicsGoldExchange { get; set; }

                [JsonProperty(PropertyName = "AutoLoot - Automatically turn in gold coins for rewards when looting ? ")] public bool EnableAutoGoldRewardOnLoot { get; set; }
                [JsonProperty(PropertyName = "AutoLoot - Automatically mark treasure maps when they are looted ? ")] public bool EnableAutoReadMapOnLoot { get; set; }

                [JsonProperty(PropertyName = "Standard Loot - Enable chance for random treasure map in standard loot crates ? ")] public bool EnableMapsInStandardLoot { get; set; }
                [JsonProperty(PropertyName = "Standard Loot - Enable chance for gold to spawn in standard loot crates ? ")] public bool EnableGoldInStandardLoot { get; set; }
                [JsonProperty(PropertyName = "Standard Loot - Random Treasure Map chance (if enabled) : ")] public int StandardLootAddMapChance { get; set; }
                [JsonProperty(PropertyName = "Standard Loot - Gold spawn chance (if enabled) : ")] public int StandardLootAddGoldChance { get; set; }

                [JsonProperty(PropertyName = "Treasure - Spawn - Only spawn Treasure up to this far from players current postion : ")] public float LocalTreasureMaxDistance { get; set; }
                [JsonProperty(PropertyName = "Treasure - Spawn - Use whole map (instead of distance from player) to get random spawn point ? ")] public bool UseWholeMapSpawn { get; set; }
                [JsonProperty(PropertyName = "Treasure - Spawn - When whole map size is used, reduce spawn area by this much offset (closer to land) : ")] public float WholeMapOffset { get; set; }
                [JsonProperty(PropertyName = "Treasure - Despawn - Approx Seconds the Treasure Marker and Location will despawn if not found : ")] public float DespawnTime { get; set; }
                [JsonProperty(PropertyName = "Treasure - Despawn - Approx Seconds the Spawned Chest will despawn if not looted : ")] public float TreasureDespawnTime { get; set; }
                [JsonProperty(PropertyName = "Treasure - Location - When player gets within this distance, treasure will spawn nearby : ")] public float LootDetectionRadius { get; set; }

                [JsonProperty(PropertyName = "Treasure - Chance - to add a Random Map to Treasure Chest : ")] public int AddMapChance { get; set; }
                [JsonProperty(PropertyName = "Treasure - Chance - to add a Gold to Treasure Chest : ")] public int AddGoldChance { get; set; }

                [JsonProperty(PropertyName = "Treasure - Chance - When a random map is added to chest or spawned, chance it will be a Basic Map: ")] public int BasicMapChance { get; set; }
                [JsonProperty(PropertyName = "Treasure - Chance - When a random map is added to chest or spawned, chance it will be a UnCommon Map: ")] public int UnCommonMapChance { get; set; }
                [JsonProperty(PropertyName = "Treasure - Chance - When a random map is added to chest or spawned, chance it will be a Rare Map: ")] public int RareMapChance { get; set; }
                [JsonProperty(PropertyName = "Treasure - Chance - When a random map is added to chest or spawned, chance it will be a Elite Map: ")] public int EliteMapChance { get; set; }

                [JsonProperty(PropertyName = "Map Marker - Prefab - Treasure Chest Map marker prefab (default explosion marker) : ")] public string MapMarkerPrefab { get; set; }
                [JsonProperty(PropertyName = "Treasure - Prefab - Basic Treasure Chest prefab : ")] public string BasicTreasurePrefab { get; set; }
                [JsonProperty(PropertyName = "Treasure - Prefab - UnCommon Treasure Chest prefab : ")] public string UnCommonTreasurePrefab { get; set; }
                [JsonProperty(PropertyName = "Treasure - Prefab - Rare Treasure Chest prefab : ")] public string RareTreasurePrefab { get; set; }
                [JsonProperty(PropertyName = "Treasure - Prefab - Elite Treasure Chest prefab : ")] public string EliteTreasurePrefab { get; set; }

                [JsonProperty(PropertyName = "Text - Basic Map name when inspecting map in inventory")] public string BasicMapTitle { get; set; }
                [JsonProperty(PropertyName = "Text - Uncommon Map name when inspecting map in inventory")] public string UncommonMapTitle { get; set; }
                [JsonProperty(PropertyName = "Text - Rare Map name when inspecting map in inventory")] public string RareMapTitle { get; set; }
                [JsonProperty(PropertyName = "Text - Elite Map name when inspecting map in inventory")] public string EliteMapTitle { get; set; }
                [JsonProperty(PropertyName = "Text - Notes to player when inspecting map in inventory")] public string MapInfomation { get; set; }

                [JsonProperty(PropertyName = "Loot Table - Only Use Loot Table Items ? ")] public bool UseOnlyLootTable { get; set; }
                [JsonProperty(PropertyName = "Loot Table - Basic Treasure Chest")] public Dictionary<int, int> BasicLootTable { get; set; }
                [JsonProperty(PropertyName = "Loot Table - UnCommon Treasure Chest")] public Dictionary<int, int> UnCommonLootTable { get; set; }
                [JsonProperty(PropertyName = "Loot Table - Rare Treasure Chest")] public Dictionary<int, int> RareLootTable { get; set; }
                [JsonProperty(PropertyName = "Loot Table - Elite Treasure Chest")] public Dictionary<int, int> EliteLootTable { get; set; }
            }

            public static PluginConfig DefaultConfig() => new PluginConfig()
            {
                globalSettings = new PluginConfig.GlobalSettings
                {
                    UseServerRewards = true,
                    UseEconomics = true,
                    ServerRewardsGoldExhcange = 100,
                    EconomicsGoldExchange = 100,
                    EnableMapsInStandardLoot = false,
                    EnableGoldInStandardLoot = false,
                    EnableAutoGoldRewardOnLoot = false,
                    EnableAutoReadMapOnLoot = false,
                    StandardLootAddMapChance = 1,
                    StandardLootAddGoldChance = 1,
                    LocalTreasureMaxDistance = 100,
                    UseWholeMapSpawn = false,
                    WholeMapOffset = 500f,
                    DespawnTime = 3600f,
                    TreasureDespawnTime = 3600f,
                    LootDetectionRadius = 8f,
                    AddMapChance = 5,
                    AddGoldChance = 5,
                    BasicMapChance = 50,
                    UnCommonMapChance = 30,
                    RareMapChance = 15,
                    EliteMapChance = 5,
                    MapMarkerPrefab = "assets/prefabs/tools/map/cratemarker.prefab",
                    BasicTreasurePrefab = "assets/bundled/prefabs/radtown/crate_basic.prefab",
                    UnCommonTreasurePrefab = "assets/bundled/prefabs/radtown/crate_normal.prefab",
                    RareTreasurePrefab = "assets/bundled/prefabs/radtown/crate_normal_2.prefab",
                    EliteTreasurePrefab = "assets/bundled/prefabs/radtown/crate_elite.prefab",

                    BasicMapTitle = "Basic Map",
                    UncommonMapTitle = "Uncommon Map",
                    RareMapTitle = "Rare Map",
                    EliteMapTitle = "Elite Map",

                    MapInfomation = "Place map in Quick Slot, then right click on it to mark location.",

                    UseOnlyLootTable = false,
                    BasicLootTable = new Dictionary<int, int>() { { -700591459, 1 }, { 1655979682, 5 } },
                    UnCommonLootTable = new Dictionary<int, int>() { { -1941646328, 1 }, { -1557377697, 5 } },
                    RareLootTable = new Dictionary<int, int>() { { -1848736516, 1 }, { 1973684065, 2 }, { -1440987069, 3 } },
                    EliteLootTable = new Dictionary<int, int>() { { 1545779598, 1 }, { -2139580305, 2 }, { 1099314009, 3 } }
                }
            };
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("New configuration file created!!");
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
            SaveConfig();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion

        #region Commands

        [ConsoleCommand("buymap")]
        void cmdConsoleBuyMap(ConsoleSystem.Arg arg)
        {
            var player = arg.Player() ?? null;
            if (player != null)
            {
                if (!permission.UserHasPermission(player.UserIDString, "buriedtreasure.admin")) return;
                GiveTreasureMap(player);
                return;
            }
            if (arg.Args.Length > 0)
            {
                ulong id = Convert.ToUInt64(arg.Args[0]);
                GiveTreasureMap(BasePlayer.FindByID(id));
            }
        }

        [ConsoleCommand("buyuncommonmap")]
        void cmdConsoleBuyUnCommonMap(ConsoleSystem.Arg arg)
        {
            var player = arg.Player() ?? null;
            if (player != null)
            {
                if (!permission.UserHasPermission(player.UserIDString, "buriedtreasure.admin")) return;
                GiveUnCommonTreasureMap(player);
                return;
            }
            if (arg.Args.Length > 0)
            {
                ulong id = Convert.ToUInt64(arg.Args[0]);
                GiveUnCommonTreasureMap(BasePlayer.FindByID(id));
            }
        }

        [ConsoleCommand("buyraremap")]
        void cmdConsoleBuyRareMap(ConsoleSystem.Arg arg)
        {
            var player = arg.Player() ?? null;
            if (player != null)
            {
                if (!permission.UserHasPermission(player.UserIDString, "buriedtreasure.admin")) return;
                GiveRareTreasureMap(player);
                return;
            }
            if (arg.Args.Length > 0)
            {
                ulong id = Convert.ToUInt64(arg.Args[0]);
                GiveRareTreasureMap(BasePlayer.FindByID(id));
            }
        }

        [ConsoleCommand("givegold")]
        void cmdConsoleGiveGold(ConsoleSystem.Arg arg)
        {
            var player = arg.Player() ?? null;
            if (player != null)
            {
                if (!permission.UserHasPermission(player.UserIDString, "buriedtreasure.admin")) return;
                GiveGold(player);
                return;
            }
        }

        [ConsoleCommand("buyelitemap")]
        void cmdConsoleBuyEliteMap(ConsoleSystem.Arg arg)
        {
            var player = arg.Player() ?? null;
            if (player != null)
            {
                if (!permission.UserHasPermission(player.UserIDString, "buriedtreasure.admin")) return;
                GiveEliteTreasureMap(player);
                return;
            }
            if (arg.Args.Length > 0)
            {
                ulong id = Convert.ToUInt64(arg.Args[0]);
                GiveEliteTreasureMap(BasePlayer.FindByID(id));
            }
        }

        [ConsoleCommand("buyrandommap")]
        void cmdConsoleBuyRandomMap(ConsoleSystem.Arg arg)
        {
            var player = arg.Player() ?? null;
            if (player != null)
            {
                if (!permission.UserHasPermission(player.UserIDString, "buriedtreasure.admin")) return;
                GiveRandomTreasureMap(player);
                return;
            }
            if (arg.Args.Length > 0)
            {
                ulong id = Convert.ToUInt64(arg.Args[0]);
                GiveRandomTreasureMap(BasePlayer.FindByID(id));
            }
        }

        [ChatCommand("markmap")]
        void cmdMarkMap(BasePlayer player, string command, string[] args)
        {
            if (!HoldingMap(player, player.GetActiveItem()))
            {
                SendReply(player, "You are not holding a Treasure Map !!");
            }
        }

        [ChatCommand("treasurehelp")]
        void cmdTreasureHelp(BasePlayer player, string command, string[] args)
        {
            string help1 = "/markmap - while holding a treasure map, will mark the location on ingame map.";
            string help2 = "/sellgold - while holding gold, will sell gold for RP or Economics Bucks.";
            string help3 = "Note: You do have to be holding map or gold to use the commands.";

            SendReply(player, " Treasure Map Commands : \n " + help1 + " \n " + help2 + " \n " + help3);
        }

        [ChatCommand("sellgold")]
        void cmdSellGold(BasePlayer player, string command, string[] args)
        {
            SellGold(player);
        }

        #endregion

        #region Hooks

        object CanStackItem(Item item, Item targetItem)
        {
            if (item == null || targetItem == null) return null;
            if (item.skin == 1376561963) return false;
            if (item.skin == 1389950043) return false;
            if (item.skin == 1390209788) return false;
            if (item.skin == 1390210901) return false;
            if (item.skin == 1390211736) return false;
            return null;
        }

        void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (player == null || input == null) return;
            if (input.IsDown(BUTTON.FIRE_SECONDARY))
            {
                if (!HoldingMap(player))
                    SellGold(player);
            }
        }

        void CanMoveItem(Item item, PlayerInventory playerLoot, uint targetContainer, int targetSlot)
        {
            if (item == null || playerLoot == null || targetContainer == null || targetSlot == null) return;

            var thplayer = playerLoot.GetComponentInParent<BasePlayer>() as BasePlayer;
            if (thplayer == null) return;
            if (config.globalSettings.EnableAutoGoldRewardOnLoot && item.skin == 1376561963) { SellGold(thplayer, item); return; }
            if (config.globalSettings.EnableAutoReadMapOnLoot && HoldingMap(thplayer, item)) return;

            if (targetSlot != -1) return;

            var container = playerLoot.FindContainer(targetContainer) ?? null;
            if (container == null || container != playerLoot.containerMain) return;

            if (HoldingMap(thplayer, item)) return;
            SellGold(thplayer, item);
        }

        bool HoldingMap(BasePlayer player, Item item = null)
        {
            Item activeItem;
            if (item != null) activeItem = item;
            else activeItem = player.GetActiveItem();

            if (activeItem != null)
            {
                if (activeItem.skin == 1389950043)
                {
                    activeItem.Remove(0f);
                    BuryTheTreasure(player, 1);
                    return true;
                }
                if (activeItem.skin == 1390209788)
                {
                    activeItem.Remove(0f);
                    BuryTheTreasure(player, 2);
                    return true;
                }
                if (activeItem.skin == 1390210901)
                {
                    activeItem.Remove(0f);
                    BuryTheTreasure(player, 3);
                    return true;
                }
                if (activeItem.skin == 1390211736)
                {
                    activeItem.Remove(0f);
                    BuryTheTreasure(player, 4);
                    return true;
                }
            }
            return false;
        }

        void GiveTreasureMap(BasePlayer player)
        {
            var item = ItemManager.CreateByItemID(1414245162, 1, 1389950043);
            item.name = config.globalSettings.BasicMapTitle;
            item.text = config.globalSettings.MapInfomation;
            player.inventory.GiveItem(item);
        }

        void GiveUnCommonTreasureMap(BasePlayer player)
        {
            var item = ItemManager.CreateByItemID(1414245162, 1, 1390209788);
            item.name = config.globalSettings.UncommonMapTitle;
            item.text = config.globalSettings.MapInfomation;
            player.inventory.GiveItem(item);
        }

        void GiveRareTreasureMap(BasePlayer player)
        {
            var item = ItemManager.CreateByItemID(1414245162, 1, 1390210901);
            item.name = config.globalSettings.RareMapTitle;
            item.text = config.globalSettings.MapInfomation;
            player.inventory.GiveItem(item);
        }

        void GiveEliteTreasureMap(BasePlayer player)
        {
            var item = ItemManager.CreateByItemID(1414245162, 1, 1390211736);
            item.name = config.globalSettings.EliteMapTitle;
            item.text = config.globalSettings.MapInfomation;
            player.inventory.GiveItem(item);
        }

        void GiveRandomTreasureMap(BasePlayer player)
        {
            ulong skinid = 1389950043;
            var randomroll = UnityEngine.Random.Range(0, (config.globalSettings.BasicMapChance + config.globalSettings.UnCommonMapChance + config.globalSettings.RareMapChance + config.globalSettings.EliteMapChance));
            if (randomroll >= 0 && randomroll <= config.globalSettings.BasicMapChance) skinid = 1389950043;
            if (randomroll >= (config.globalSettings.BasicMapChance + 1) && randomroll <= (config.globalSettings.BasicMapChance + config.globalSettings.UnCommonMapChance)) skinid = 1390209788;
            if (randomroll >= (config.globalSettings.UnCommonMapChance + 1) && randomroll <= (config.globalSettings.UnCommonMapChance + config.globalSettings.RareMapChance)) skinid = 1390210901;
            if (randomroll >= (config.globalSettings.RareMapChance + 1) && randomroll <= (config.globalSettings.RareMapChance + config.globalSettings.EliteMapChance)) skinid = 1390211736;
            var item = ItemManager.CreateByItemID(1414245162, 1, skinid);
            player.inventory.GiveItem(item);
        }

        void GiveContainerRandomTreasureMap(LootContainer container)
        {
            ulong skinid = 1389950043;
            var randomroll = UnityEngine.Random.Range(0, (config.globalSettings.BasicMapChance + config.globalSettings.UnCommonMapChance + config.globalSettings.RareMapChance + config.globalSettings.EliteMapChance));
            if (randomroll >= 0 && randomroll <= config.globalSettings.BasicMapChance) skinid = 1389950043;
            if (randomroll >= (config.globalSettings.BasicMapChance + 1) && randomroll <= (config.globalSettings.BasicMapChance + config.globalSettings.UnCommonMapChance)) skinid = 1390209788;
            if (randomroll >= (config.globalSettings.UnCommonMapChance + 1) && randomroll <= (config.globalSettings.UnCommonMapChance + config.globalSettings.RareMapChance)) skinid = 1390210901;
            if (randomroll >= (config.globalSettings.RareMapChance + 1) && randomroll <= (config.globalSettings.RareMapChance + config.globalSettings.EliteMapChance)) skinid = 1390211736;

            ItemContainer component1 = container.GetComponent<StorageContainer>().inventory;
            Item item = ItemManager.CreateByItemID(1414245162, 1, skinid);
            component1.itemList.Add(item);
            item.parent = component1;
            item.MarkDirty();
        }

        void GiveGold(BasePlayer player)
        {
            var item = ItemManager.CreateByItemID(1414245162, 1, 1376561963);
            player.inventory.GiveItem(item);
        }

        void GiveContainerGold(LootContainer container)
        {
            ItemContainer component1 = container.GetComponent<StorageContainer>().inventory;
            Item item = ItemManager.CreateByItemID(1414245162, 1, 1376561963);
            component1.itemList.Add(item);
            item.parent = component1;
            item.MarkDirty();
        }

        void SellGold(BasePlayer player, Item item = null)
        {
            Item activeItem = new Item();
            if (item != null) activeItem = item;
            else activeItem = player.GetActiveItem();

            if (activeItem != null)
            {
                if (activeItem.skin == 1376561963)
                {
                    if (config.globalSettings.UseServerRewards && ServerRewards != null)
                    {
                        ServerRewards?.Call("AddPoints", new object[] { player.userID, config.globalSettings.ServerRewardsGoldExhcange });
                        SendReply(player, "You Just sold your gold for " + config.globalSettings.ServerRewardsGoldExhcange.ToString() + " Rewards Points !!!");
                    }
                    if (config.globalSettings.UseEconomics && Economics != null)
                    {
                        Economics?.Call("Deposit", new object[] { player.userID, config.globalSettings.EconomicsGoldExchange });
                        SendReply(player, "You Just sold your gold for " + config.globalSettings.EconomicsGoldExchange.ToString() + " Economic Bucks !!!");
                    }
                    activeItem.Remove(0f);
                    return;
                }
            }
        }

        static float GetGroundPosition(Vector3 pos)
        {
            float y = TerrainMeta.HeightMap.GetHeight(pos);
            RaycastHit hit;
            if (Physics.Raycast(new Vector3(pos.x, pos.y + 200f, pos.z), Vector3.down, out hit, Mathf.Infinity, UnityEngine.LayerMask.GetMask("World", "Construction", "Default")))
                return Mathf.Max(hit.point.y, y);

            return y;
        }

        Vector3 GetSpawnLocation(BasePlayer player)
        {
            Vector3 targetPos = new Vector3();
            RaycastHit hitInfo;
            Vector3 randomizer = new Vector3(UnityEngine.Random.Range(-config.globalSettings.LocalTreasureMaxDistance, config.globalSettings.LocalTreasureMaxDistance), 0f, UnityEngine.Random.Range(-config.globalSettings.LocalTreasureMaxDistance, config.globalSettings.LocalTreasureMaxDistance));
            Vector3 newp = (player.transform.position + randomizer);
            var groundy = GetGroundPosition(newp);
            targetPos = new Vector3(newp.x, groundy, newp.z);
            return targetPos;
        }

        Vector3 FindGlobalSpawnPoint()
        {
            Vector3 spawnpoint = new Vector3();
            float mapoffset = config.globalSettings.WholeMapOffset;
            float mapsize = ((ConVar.Server.worldsize) / 2) - mapoffset;
            Vector3 randomizer = new Vector3(UnityEngine.Random.Range(-mapsize, mapsize), 0f, UnityEngine.Random.Range(-mapsize, mapsize));
            Vector3 newp = randomizer;
            var groundy = GetGroundPosition(newp);
            spawnpoint = new Vector3(randomizer.x, groundy, randomizer.z);
            return spawnpoint;
        }

        void BuryTheTreasure(BasePlayer player, int maprarity = 1)
        {
            Vector3 position = GetSpawnLocation(player);
            if (config.globalSettings.UseWholeMapSpawn) position = FindGlobalSpawnPoint();
            GameObject newTreasure = new GameObject();
            newTreasure.transform.position = position;
            var stash = newTreasure.gameObject.AddComponent<BaseEntity>();
            stash.OwnerID = player.userID;
            var addmarker = stash.gameObject.AddComponent<TreasureMarker>();
            addmarker.rarity = maprarity;
            SendReply(player, "Treasure is now marked on ingame map at grid : " + GetGridLocation(position));
        }

        void OnLootSpawn(LootContainer container)
        {
            var getobj = container.GetComponentInParent<BaseEntity>() ?? null;
            if (getobj != null && getobj.skinID == 111) return;
            if (config.globalSettings.EnableMapsInStandardLoot)
            {
                int randomlootroll = UnityEngine.Random.Range(0, 100);
                if (randomlootroll <= config.globalSettings.StandardLootAddMapChance) GiveContainerRandomTreasureMap(container);
            }
            if (config.globalSettings.EnableGoldInStandardLoot)
            {
                int randomgoldlootroll = UnityEngine.Random.Range(0, 100);
                if (randomgoldlootroll <= config.globalSettings.StandardLootAddGoldChance) GiveContainerGold(container);
            }
        }

        string GetGridLocation(Vector3 position)
        {
            Vector2 offsetPos = new Vector2((World.Size / 2 - 6) + position.x, (World.Size / 2 - 56) - position.z);
            string gridstring = $"{Convert.ToChar(65 + (int)offsetPos.x / 146)}{(int)(offsetPos.y / 146)}";
            return gridstring;
        }

        void Unload()
        {
            DestroyAll<TreasureMarker>();
        }

        static void DestroyAll<T>()
        {
            var objects = GameObject.FindObjectsOfType(typeof(T));
            if (objects != null)
                foreach (var gameObj in objects)
                    GameObject.Destroy(gameObj);
        }

        #endregion

        #region TreasureMarker 

        object CanNetworkTo(BaseNetworkable entity, BasePlayer target)
        {
            if (entity is MapMarker && entity.name == "Treasure Marker")
            {
                MapMarker getMarker = entity.GetComponent<MapMarker>();
                if (getMarker)
                {
                    if (target.userID == getMarker.OwnerID) return null;
                    else return false;
                }
            }
            return null;
        }

        class TreasureMarker : BaseEntity
        {
            BaseEntity lootbox;
            BaseEntity treasurechest;
            MapMarker mapmarker;
            SphereCollider sphereCollider;
            public ulong playerid;
            BuriedTreasure instance;
            public int rarity;
            string prefabtreasure;
            Dictionary<int, int> loottable;
            bool isvisible;
            bool didspawnchest;
            float despawncounter;
            float detectionradius;

            void Awake()
            {
                instance = new BuriedTreasure();
                lootbox = GetComponentInParent<BaseEntity>();
                playerid = lootbox.OwnerID;
                rarity = 1;
                despawncounter = 0f;
                isvisible = false;
                didspawnchest = false;
                detectionradius = config.globalSettings.LootDetectionRadius;
                string prefabmarker = config.globalSettings.MapMarkerPrefab;

                mapmarker = GameManager.server.CreateEntity(prefabmarker, lootbox.transform.position, Quaternion.identity, true) as MapMarker;
                mapmarker.OwnerID = lootbox.OwnerID;
                mapmarker.name = "Treasure Marker";
                mapmarker.Spawn();

                sphereCollider = gameObject.AddComponent<SphereCollider>();
                sphereCollider.gameObject.layer = (int)Layer.Reserved1;
                sphereCollider.isTrigger = true;
                sphereCollider.radius = detectionradius;
            }

            private void OnTriggerEnter(Collider col)
            {
                if (didspawnchest) return;
                var target = col.GetComponentInParent<BasePlayer>();
                if (target != null)
                {
                    if (target.userID == lootbox.OwnerID)
                    {
                        SpawnTreasureChest();
                        didspawnchest = true;
                        instance.SendReply(target, "The Treasure is very close !!!!");
                    }
                }
            }

            void SpawnTreasureChest()
            {
                if (rarity == 1) prefabtreasure = config.globalSettings.BasicTreasurePrefab;
                if (rarity == 2) prefabtreasure = config.globalSettings.UnCommonTreasurePrefab;
                if (rarity == 3) prefabtreasure = config.globalSettings.RareTreasurePrefab;
                if (rarity == 4) prefabtreasure = config.globalSettings.EliteTreasurePrefab;
                treasurechest = GameManager.server.CreateEntity(prefabtreasure, lootbox.transform.position, Quaternion.identity, true);
                treasurechest.skinID = 111;
                treasurechest.OwnerID = lootbox.OwnerID;
                treasurechest.Spawn();
                treasurechest.gameObject.AddComponent<TreasureDespawner>();

                ItemContainer storageCont = treasurechest.GetComponent<StorageContainer>().inventory;
                storageCont.capacity = 36;
                if (config.globalSettings.UseOnlyLootTable) storageCont.Clear();

                AddLootTableItems(treasurechest);
                CheckForExtras(treasurechest);
                CheckSpawnVisibility(treasurechest);

                lootbox.Invoke("KillMessage", 0.2f);
            }

            void AddLootTableItems(BaseEntity treasurebox)
            {
                if (rarity == 1) loottable = config.globalSettings.BasicLootTable;
                if (rarity == 2) loottable = config.globalSettings.UnCommonLootTable;
                if (rarity == 3) loottable = config.globalSettings.RareLootTable;
                if (rarity == 4) loottable = config.globalSettings.EliteLootTable;

                foreach (KeyValuePair<int, int> lootlist in loottable)
                {
                    int itemqty = lootlist.Value;
                    int itemid = lootlist.Key;
                    ItemContainer component1 = treasurebox.GetComponent<StorageContainer>().inventory;
                    Item item = ItemManager.CreateByItemID(itemid, itemqty, 0);
                    component1.itemList.Add(item);
                    item.parent = component1;
                    item.MarkDirty();
                }
            }

            void CheckSpawnVisibility(BaseEntity entitybox)
            {
                if (isvisible) return;
                if (entitybox.IsOutside()) { isvisible = true; return; }
                entitybox.transform.position = entitybox.transform.position + new Vector3(0f, 0.2f, 0f);
                entitybox.transform.hasChanged = true;
                entitybox.SendNetworkUpdateImmediate();
                CheckSpawnVisibility(entitybox);
            }

            void CheckForExtras(BaseEntity entitybox)
            {
                int randommaproll = UnityEngine.Random.Range(0, 100);
                if (rarity == 2) randommaproll = randommaproll - 2;
                if (rarity == 3) randommaproll = randommaproll - 4;
                if (rarity == 4) randommaproll = randommaproll - 6;
                if (randommaproll > 100) randommaproll = 100;
                if (randommaproll < 0) randommaproll = 0;
                if (randommaproll <= config.globalSettings.AddMapChance) AddRandomMap(entitybox);

                AddRandomGold(entitybox);
            }

            void AddRandomGold(BaseEntity entitybox)
            {
                int randomgoldroll = UnityEngine.Random.Range(0, 100);
                if (rarity == 2) randomgoldroll = randomgoldroll - 2;
                if (rarity == 3) randomgoldroll = randomgoldroll - 4;
                if (rarity == 4) randomgoldroll = randomgoldroll - 6;
                if (randomgoldroll > 100) randomgoldroll = 100;
                if (randomgoldroll < 0) randomgoldroll = 0;
                if (randomgoldroll <= config.globalSettings.AddGoldChance)
                {
                    ItemContainer component1 = entitybox.GetComponent<StorageContainer>().inventory;
                    Item item = ItemManager.CreateByItemID(1414245162, 1, 1376561963);
                    component1.itemList.Add(item);
                    item.parent = component1;
                    item.MarkDirty();
                }
            }

            void AddRandomMap(BaseEntity entitybox)
            {
                ulong skinid = 1389950043;
                var randomroll = UnityEngine.Random.Range(0, (config.globalSettings.BasicMapChance + config.globalSettings.UnCommonMapChance + config.globalSettings.RareMapChance + config.globalSettings.EliteMapChance));
                if (randomroll >= 0 && randomroll <= config.globalSettings.BasicMapChance) skinid = 1389950043;
                if (randomroll >= (config.globalSettings.BasicMapChance + 1) && randomroll <= (config.globalSettings.BasicMapChance + config.globalSettings.UnCommonMapChance)) skinid = 1390209788;
                if (randomroll >= (config.globalSettings.UnCommonMapChance + 1) && randomroll <= (config.globalSettings.UnCommonMapChance + config.globalSettings.RareMapChance)) skinid = 1390210901;
                if (randomroll >= (config.globalSettings.RareMapChance + 1) && randomroll <= (config.globalSettings.RareMapChance + config.globalSettings.EliteMapChance)) skinid = 1390211736;
                ItemContainer component1 = entitybox.GetComponent<StorageContainer>().inventory;
                Item item = ItemManager.CreateByItemID(1414245162, 1, skinid);
                component1.itemList.Add(item);
                item.parent = component1;
                item.MarkDirty();
            }

            void FixedUpdate()
            {
                if (despawncounter >= (config.globalSettings.DespawnTime * 15) && lootbox != null) { lootbox.Invoke("KillMessage", 0.1f); return; }
                despawncounter = despawncounter + 1f;
            }

            void OnDestroy()
            {
                if (mapmarker != null) mapmarker.Invoke("KillMessage", 0.1f);
                if (lootbox != null) lootbox.Invoke("KillMessage", 0.1f);
            }
        }

        #endregion

        #region TreasureDespawner 

        class TreasureDespawner : BaseEntity
        {
            BaseEntity treasure;
            BuriedTreasure instance;
            float despawncounter;

            void Awake()
            {
                instance = new BuriedTreasure();
                treasure = GetComponentInParent<BaseEntity>();
                despawncounter = 0f;
            }

            void FixedUpdate()
            {
                if (despawncounter >= (config.globalSettings.TreasureDespawnTime * 15) && treasure != null) { treasure.Invoke("KillMessage", 0.1f); return; }
                despawncounter = despawncounter + 1f;
            }

            void OnDestroy()
            {
                if (treasure != null) treasure.Invoke("KillMessage", 0.1f);
            }
        }

        #endregion
    }
}

// --- End of file: BuriedTreasure (1).cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/DVTeleportation.cs ---
// --- Original Local Path: DVTeleportation.cs ---

using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using UnityEngine;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins
{
    [Info("DVTeleportation", "Sempai#3239", "1.5.0")]
    [Description("Спасибо за покупку - by Sempai#3239")]
    class DVTeleportation : RustPlugin
    {
        [PluginReference] Plugin Clans;
        [PluginReference] Plugin Friends;
        Dictionary<ulong, Vector3> lastPositions = new Dictionary<ulong, Vector3>();
        Dictionary<BasePlayer, int> spectatingPlayers = new Dictionary<BasePlayer, int>();
        bool IsClanMember(ulong playerid = 294912, ulong targetID = 0) => (bool)(Clans?.Call("HasFriend", playerid, targetID) ?? false);
        bool IsFriends(ulong playerID = 0, ulong friendId = 0) => (bool)(Friends?.Call("AreFriends", playerID, friendId) ?? false);

        bool IsTeamate(BasePlayer player, ulong targetID)
        {
            if (player.currentTeam == 0) return false;
            var team = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);
            if (team == null) return false;
            var list = RelationshipManager.ServerInstance.FindTeam(player.currentTeam).members.Where(p => p == targetID).ToList();
            return list.Count > 0;
        }

        class TP
        {
            public BasePlayer Player;
            public BasePlayer Player2;
            public Vector3 pos;
            public float totalSeconds;
            public bool EnabledShip;
            public int seconds;
            public bool TPL;
            public TP(BasePlayer player, Vector3 Pos, int Seconds, bool EnabledShip1, bool tpl, BasePlayer player2 = null)
            {    
                Player = player;
                pos = Pos;
                seconds = Seconds;
                totalSeconds = Seconds;
                EnabledShip = EnabledShip1;
                Player2 = player2;
                TPL = tpl;
            }
        }
        const string TPADMIN = "DVTeleportation.admin";
        int homelimitDefault;
        Dictionary<string, int> homelimitPerms;
        int tpkdDefault;
        Dictionary<string, int> tpkdPerms;
        int tpkdhomeDefault;
        Dictionary<string, int> tpkdhomePerms;
        int teleportSecsDefault;
        int resetPendingTime;
        bool restrictCupboard;
        bool enabledTPR;
        bool homecupboard;
        bool homecupboardblock;
        bool adminsLogs;
        bool foundationOwner;
        bool foundationOwnerFC;

        bool restrictTPRCupboard;
        bool foundationEx;
        bool wipedData;
        bool createSleepingBug;
        string EffectPrefab1;
        string EffectPrefab;
        bool EnabledShipTP;
        bool EnabledBallonTP;
        bool CancelTPMetabolism;
        bool CancelTPCold;
        bool CancelTPRadiation;
        bool FriendsEnabled;
        bool CancelTPWounded;
        bool EnabledTPLForPlayers;
        int TPLCooldown;
        int TplPedingTime;
        bool TPLAdmin;
        string AutoTPAPermission;

        static DynamicConfigFile config;
        Dictionary<string, int> teleportSecsPerms;
        void OnNewSave()
        {
            if (wipedData)
            {
                PrintWarning("Обнаружен вайп. Очищаем данные с data/DVTeleportation");
                WipeData();
            }
        }
        void WipeData()
        {
            LoadData();
            tpsave = new List<TPList>();
            homes = new Dictionary<ulong, Dictionary<string, Vector3>>();
            SaveData();
        }
        protected override void LoadDefaultConfig()
        {
            GetVariable(Config, "Запрещать отправлять запрос на телепортацию в зоне действия чужого шкафа", out homecupboard, true);
            GetVariable(Config, "Удалять точку теоепртации если она в билде в какой не авторизован игрок", out homecupboard, true);
            GetVariable(Config, "Звук уведомления при получение запроса на телепорт (пустое поле = звук отключен)", out EffectPrefab1, "assets/prefabs/locks/keypad/effects/lock.code.unlock.prefab");
            GetVariable(Config, "Звук предупреждения (пустое поле = звук отключен)", out EffectPrefab, "assets/prefabs/locks/keypad/effects/lock.code.denied.prefab");
            GetVariable(Config, "Разрешать сохранять местоположение только на фундаменте", out foundationEx, true);
            GetVariable(Config, "Создавать объект при сохранении местоположения в виде Sleeping Bag", out createSleepingBug, true);
            GetVariable(Config, "Автоматический вайп данных при генерации новой карты", out wipedData, true);
            GetVariable(Config, "Запрещать принимать запрос на телепортацию в зоне действия чужого шкафа", out restrictCupboard, true);
            GetVariable(Config, "Запрещать сохранять местоположение если игрок не является владельцем фундамента", out foundationOwner, true);
            GetVariable(Config, "Привилегия на использование автоматического приёма телепорта", out AutoTPAPermission, "DVTeleportation.autotpa");
            GetVariable(Config, "Разрешать сохранять местоположение если игрок является другом или соклановцем или тимейтом владельца фундамента ", out foundationOwnerFC, true);
            GetVariable(Config, "Логировать использование команд для администраторов", out adminsLogs, true);
            GetVariable(Config, "Включить телепортацию (TPR/TPA) только к друзьям, соклановкам или тимейту", out FriendsEnabled, true);
            GetVariable(Config, "Разрешить команду TPR игрокам (false = /tpr не будет работать)", out enabledTPR, true);
            GetVariable(Config, "Разрешить отправку и приём телепорта и телепорт домой на корабле", out EnabledShipTP, true);
            GetVariable(Config, "Разрешить отправку и приём телепорта на воздушном шаре", out EnabledBallonTP, true);
            GetVariable(Config, "Запрещать отправлять запрос на телепортацию в зоне действия чужого шкафа", out restrictTPRCupboard, true);
            GetVariable(Config, "Отмета телепорта игрока (Home/TP) если у него кровотечение", out CancelTPMetabolism, true);
            GetVariable(Config, "Отмета телепорта игрока (Home/TP) если игрок ранен", out CancelTPWounded, true);
            GetVariable(Config, "Отмета телепорта игрока (Home/TP) если ему холодно", out CancelTPCold, true);
            GetVariable(Config, "Отмета телепорта игрока (Home/TP) если он облучен радиацией", out CancelTPRadiation, true);
            GetVariable(Config, "Время ответа на запрос телепортации (в секундах)", out resetPendingTime, 15);
            GetVariable(Config, "Ограничение на количество сохранённых местоположений", out homelimitDefault, 3);
            GetVariable(Config, "[TPL] Разрешить игрокам использовать TPL", out EnabledTPLForPlayers, false);
            GetVariable(Config, "[TPL] Задержка телепортации игрока на TPL", out TplPedingTime, 15);
            GetVariable(Config, "[TPL] Cooldown телепортации игрока на TPL", out TPLCooldown, 15);
            GetVariable(Config, "[TPL] Телепортировать админа без задержки и кулдауна?", out TPLAdmin, true);
            Config["Ограничение на количество сохранённых местоположений с привилегией"] = homelimitPerms = GetConfig("Ограничение на количество сохранённых местоположений с привилегией", new Dictionary<string, object>() {
                    {
                    "DVTeleportation.vip", 5
                }
            }
            ).ToDictionary(p => p.Key, p => Convert.ToInt32(p.Value));
            PermissionService.RegisterPermissions(this, homelimitPerms.Keys.ToList());
            GetVariable(Config, "Длительность задержки перед телепортацией (в секундах)", out teleportSecsDefault, 15);
            Config["Длительность задержки перед телепортацией с привилегией (в секундах)"] = teleportSecsPerms = GetConfig("Длительность задержки перед телепортацией с привилегией (в секундах)", new Dictionary<string, object>() {
                    {
                    "DVTeleportation.vip", 10
                }
            }
            ).ToDictionary(p => p.Key, p => Convert.ToInt32(p.Value));
            PermissionService.RegisterPermissions(this, teleportSecsPerms.Keys.ToList());
            GetVariable(Config, "Длительность перезарядки телепорта (в секундах)", out tpkdDefault, 300);
            Config["Длительность перезарядки телепорта с привилегией (в секундах)"] = tpkdPerms = GetConfig("Длительность перезарядки телепорта с привилегией (в секундах)", new Dictionary<string, object>() {
                    {
                    "DVTeleportation.vip", 150
                }
            }
            ).ToDictionary(p => p.Key, p => Convert.ToInt32(p.Value));
            PermissionService.RegisterPermissions(this, tpkdPerms.Keys.ToList());
            GetVariable(Config, "Длительность перезарядки телепорта домой (в секундах)", out tpkdhomeDefault, 300);
            Config["Длительность перезарядки телепорта домой с привилегией (в секундах)"] = tpkdhomePerms = GetConfig("Длительность перезарядки телепорта домой с привилегией (в секундах)", new Dictionary<string, object>() {
                    {
                    "DVTeleportation.vip", 150
                }
            }
            ).ToDictionary(p => p.Key, p => Convert.ToInt32(p.Value));
            PermissionService.RegisterPermissions(this, tpkdhomePerms.Keys.ToList());
            SaveConfig();
        }
        T GetConfig<T>(string name, T defaultValue) => Config[name] == null ? defaultValue : (T)Convert.ChangeType(Config[name], typeof(T));
        public static void GetVariable<T>(DynamicConfigFile config, string name, out T value, T defaultValue)
        {
            config[name] = value = config[name] == null ? defaultValue : (T)Convert.ChangeType(config[name], typeof(T));
        }
        public static class PermissionService
        {
            public static Permission permission = Interface.GetMod().GetLibrary<Permission>();
            public static bool HasPermission(ulong uid, string permissionName)
            {
                return !string.IsNullOrEmpty(permissionName) && permission.UserHasPermission(uid.ToString(), permissionName);
            }
            public static void RegisterPermissions(Plugin owner, List<string> permissions)
            {
                if (owner == null) throw new ArgumentNullException("owner");
                if (permissions == null) throw new ArgumentNullException("commands");
                foreach (var permissionName in permissions.Where(permissionName => !permission.PermissionExists(permissionName)))
                {
                    permission.RegisterPermission(permissionName, owner);
                }
            }
        }
        public BasePlayer FindBasePlayer(string nameOrUserId)
        {
            nameOrUserId = nameOrUserId.ToLower();
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (player.displayName.ToLower().Contains(nameOrUserId) || player.UserIDString == nameOrUserId) return player;
            }
            foreach (var player in BasePlayer.sleepingPlayerList)
            {
                if (player.displayName.ToLower().Contains(nameOrUserId) || player.UserIDString == nameOrUserId) return player;
            }
            return default(BasePlayer);
        }
        Dictionary<ulong, Dictionary<string, Vector3>> homes;
        List<TPList> tpsave;
        class TPList
        {
            public string Name;
            public Vector3 pos;
        }
        Dictionary<ulong, int> cooldownsTP = new Dictionary<ulong, int>();
        Dictionary<ulong, int> cooldownsHOME = new Dictionary<ulong, int>();
        List<TP> tpQueue = new List<TP>();
        List<TP> pendings = new List<TP>();
        List<ulong> sethomeBlock = new List<ulong>();

        /*[ChatCommand("atp")]
        void cmdAutoTPA(BasePlayer player, string com, string[] args)
        {
            if (!PermissionService.HasPermission(player.userID, AutoTPAPermission))
            {
                SendReply(player, Messages["TPAPerm"]);
                return;
            }

            if (!AutoTPA.ContainsKey(player.userID))
                AutoTPA.Add(player.userID, new AutoTPASettings());


            var data = AutoTPA[player.userID];

            if (args == null || args.Length <= 0)
            {
                if (data.Enabled)
                {
                    data.Enabled = false;
                    SendReply(player, Messages["TPADisable"]);

                }
                else
                {
                    data.Enabled = true;
                    SendReply(player, string.Format(Messages["TPAEnabled"], Messages["TPAEnabledInfo"]));
                }
                return;
            }

            switch (args[0])
            {
                case "add":
                    if (args.Length < 2)
                    {
                        SendReply(player, Messages["TPAEAddError"]);
                        return;
                    }

                    var target = covalence.Players.FindPlayers(args[1]).ToList();

                    if (target == null || target.Count <= 0)
                    {
                        SendReply(player, string.Format(Messages["TPAEAddPlayerNotFound"], "⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠"));
                        return;
                    }

                    if (target.Count > 1)
                    {
                        SendReply(player, string.Format(Messages["TPAEAddPlayers"], string.Join(", ", target.Select(p => p.Name).Take(5))));
                        return;
                    }
                    if (data.PlayersList.ContainsKey(target[0].Name))
                    {
                        SendReply(player, string.Format(Messages["TPAEAddContains"], target[0].Name));
                        return;
                    }

                    data.PlayersList.Add(target[0].Name, ulong.Parse(target[0].Id));

                    SendReply(player, string.Format(Messages["TPAEAddSuccess"], target[0].Name));

                    break;
                case "remove":
                    if (args.Length < 2)
                    {
                        SendReply(player, Messages["TPARemoveError"]);
                        return;
                    }
                    var key = data.PlayersList.FirstOrDefault(p => p.Key.ToLower().Contains(args[1].ToLower())).Key;
                    if (string.IsNullOrEmpty(key))
                    {
                        SendReply(player, string.Format(Messages["TPAEAddPlayerNotFound"], string.Format(Messages["TPAEnabledList"], string.Join(", ", data.PlayersList.Select(p => p.Key)))));
                        return;
                    }

                    data.PlayersList.Remove(key);
                    SendReply(player, string.Format(Messages["TPAERemoveSuccess"], key));

                    break;
                case "list":
                    if (data.PlayersList.Count <= 0)
                        SendReply(player, Messages["TPAEListNotFound"]);
                    else
                        SendReply(player, string.Format(Messages["TPAEnabledList"], string.Join(", ", data.PlayersList.Select(p => p.Key))));
                    break;
            }
        }
        */

        [ChatCommand("sethome")]
        void cmdChatSetHome(BasePlayer player, string command, string[] args)
        {
            var uid = player.userID;
            var pos = player.transform.position;
            var entity = new BaseEntity();

            RaycastHit hitInfo;
            if (!Physics.Raycast(player.transform.position, Vector3.down, out hitInfo, 1f))
            {
                SendReply(player, Messages["buildingBrockmissing"]);
                return;
            }
            if (hitInfo.GetEntity() == null || !(hitInfo.GetEntity() is BuildingBlock))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["buildingBrockmissing"]);
                return;
            }

            if (foundationEx && !hitInfo.GetEntity().ShortPrefabName.Contains("foundation"))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["foundationmissing"]);
                return;
            }
            entity = hitInfo.GetEntity();
            var point = player.transform.position;
            point.y = player.transform.position.y;
            pos = point;
            if (args.Length != 1)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["sethomeArgsError"]);
                return;
            }
            if (CancelTPMetabolism && player.metabolism.bleeding.value > 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (CancelTPRadiation && player.metabolism.radiation_poison.value > 10)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["Radiation"]);
                return;
            }
            if (player.IsWounded() && CancelTPWounded)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (sethomeBlock.Contains(player.userID))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["sethomeBlock"]);
                return;
            }

            if (foundationOwnerFC && foundationOwner)
            {

                if (entity.OwnerID != uid)
                {
                    if (!IsFriends(entity.OwnerID, player.userID) && !IsClanMember(entity.OwnerID, player.userID) && !IsTeamate(player, entity.OwnerID))
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["foundationownerFC"]);
                        return;
                    }
                }
            }
            if (foundationOwner)
            {

                if (entity.OwnerID != uid && foundationOwnerFC == (!IsFriends(entity.OwnerID, player.userID) && !IsClanMember(entity.OwnerID, player.userID) && IsTeamate(player, entity.OwnerID)))
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["foundationowner"]);
                    return;
                }
            }
            var name = args[0];
            SetHome(player, name, pos);
        }

        [ChatCommand("removehome")]
        void cmdChatRemoveHome(BasePlayer player, string command, string[] args)
        {
            if (args.Length != 1)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["removehomeArgsError"]);
                return;
            }
            if (!homes.ContainsKey(player.userID))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["homesmissing"]);
                return;
            }
            var name = args[0];
            var playerHomes = homes[player.userID];
            if (!playerHomes.ContainsKey(name))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["homenotexist"]);
                return;
            }
            foreach (var sleepingBag in SleepingBag.FindForPlayer(player.userID, true))
            {
                if (Vector3.Distance(sleepingBag.transform.position, playerHomes[name]) < 1)
                {
                    sleepingBag.Kill();
                    break;
                }
            }
            Effect.server.Run(EffectPrefab1, player, 0, Vector3.zero, Vector3.forward);
            playerHomes.Remove(name);
            SendReply(player, Messages["removehomesuccess"], name);
        }
        [ConsoleCommand("home")]
        void cmdHome(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            if (arg.Args == null || arg.Args.Length < 1) return;
            cmdChatHome(player, "", new[] { arg.Args[0] });
        }
        [ChatCommand("homelist")]
        private void cmdHomeList(BasePlayer player, string command, string[] args)
        {
            if (!homes.ContainsKey(player.userID) || homes[player.userID].Count == 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["homesmissing"]);
                return;
            }
            var playerHomes = homes[player.userID];
            var time = (GetHomeLimit(player.userID) - playerHomes.Count);
            var homelist = playerHomes.Select(x => GetSleepingBag(x.Key, x.Value) != null ? $"{x.Key} {x.Value}" : $"Дом: {x.Key} {x.Value}");

            foreach (var home in playerHomes.ToList())
            {
                if (createSleepingBug)
                    if (!GetSleepingBag(home.Key, home.Value)) playerHomes.Remove(home.Key);
            }
            SendReply(player, Messages["homeslist"], time, string.Join("\n", homelist.ToArray()));
        }
        [ChatCommand("home")]
        void cmdChatHome(BasePlayer player, string command, string[] args)
        {
            if (args.Length != 1)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["homeArgsError"]);
                return;
            }
            var ret = Interface.Call("CanTeleport", player) as string;
            if (ret != null)
            {
                SendReply(player, ret);
                return;
            }
            if (!EnabledShipTP && player.GetParentEntity() is CargoShip)
            {
                SendReply(player, Messages["PlayerIsOnCargoShip"]);
                return;
            }
            if (!EnabledBallonTP && player.GetParentEntity() is HotAirBalloon)
            {
                SendReply(player, Messages["PlayerIsOnHotAirBalloon"]);
                return;
            }
            if (player.IsWounded() && CancelTPWounded)
            {
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (player.metabolism.bleeding.value > 0 && CancelTPMetabolism)
            {
                SendReply(player, Messages["woundedAction"]);
                return;
            }

            if (CancelTPRadiation && player.metabolism.radiation_poison.value > 10)
            {
                SendReply(player, Messages["Radiation"]);
                return;
            }
            int seconds;
            if (cooldownsHOME.TryGetValue(player.userID, out seconds) && seconds > 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, string.Format(Messages["tpkd"], TimeToString(seconds)));
                return;
            }
            if (homecupboard)
            {
                var privilege = player.GetBuildingPrivilege(player.WorldSpaceBounds());
                if (privilege != null && !player.IsBuildingAuthed())
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["tphomecupboard"]);
                    return;
                }
            }
            if (!homes.ContainsKey(player.userID))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["homesmissing"]);
                return;
            }
            var name = args[0];
            var playerHomes = homes[player.userID];
            if (!playerHomes.ContainsKey(name))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["homenotexist"]);
                return;
            }
            var time = GetTeleportTime(player.userID);
            var pos = playerHomes[name];
            SleepingBag bag = GetSleepingBag(name, pos);
            if (createSleepingBug)
            {
                if (bag == null)
                {
                    foreach (var sleepingBag in SleepingBag.FindForPlayer(player.userID, true))
                    {
                        if (Vector3.Distance(sleepingBag.transform.position, playerHomes[name]) < 1)
                        {
                            sleepingBag.Kill();
                            break;
                        }
                    }
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["sleepingbagmissing"]);
                    playerHomes.Remove(name);
                    return;
                }

                if (bag.GetBuildingPrivilege() != null && !bag.GetBuildingPrivilege().IsAuthed(player))
                {
                    foreach (var sleepingBag in SleepingBag.FindForPlayer(player.userID, true))
                    {
                        if (Vector3.Distance(sleepingBag.transform.position, playerHomes[name]) < 1)
                        {
                            sleepingBag.Kill();
                            break;
                        }
                    }
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["sleepingbugbuildblock"]);
                    playerHomes.Remove(name);
                    return;
                }
            }
            else
            {
                var bulds = GetBuldings(pos);
                if (bulds == null)
                {
                    foreach (var sleepingBag in SleepingBag.FindForPlayer(player.userID, true))
                    {
                        if (Vector3.Distance(sleepingBag.transform.position, playerHomes[name]) < 1)
                        {
                            sleepingBag.Kill();
                            break;
                        }
                    }
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["buildingBrockmissingR"]);
                    playerHomes.Remove(name);
                    return;
                }

                if (bulds.GetBuildingPrivilege() != null && !bulds.GetBuildingPrivilege().IsAuthed(player))
                {
                    foreach (var sleepingBag in SleepingBag.FindForPlayer(player.userID, true))
                    {
                        if (Vector3.Distance(sleepingBag.transform.position, playerHomes[name]) < 1)
                        {
                            sleepingBag.Kill();
                            break;
                        }
                    }
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["sleepingbugbuildblock"]);
                    playerHomes.Remove(name);

                    return;
                }
            }
            if (CancelTPCold && player.metabolism.temperature.value < 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["coldplayer"]);
                return;
            }
            if (tpQueue.Any(p => p.Player == player) || pendings.Any(p => p.Player2 == player))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tpError"]);
                return;
            }
            var lastTp = tpQueue.Find(p => p.Player == player);
            if (lastTp != null)
            {
                tpQueue.Remove(lastTp);
            }
            tpQueue.Add(new TP(player, pos, time, false, false));
            Effect.server.Run(EffectPrefab1, player, 0, Vector3.zero, Vector3.forward);
            SendReply(player, String.Format(Messages["homequeue"], name, TimeToString(time)));
        }
        [ChatCommand("tpr")]
        void cmdChatTpr(BasePlayer player, string command, string[] args)
        {
            if (!enabledTPR) return;
            if (args.Length != 1)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tprArgsError"]);
                return;
            }
            var ret = Interface.Call("CanTeleport", player) as string;
            if (ret != null)
            {
                SendReply(player, ret);
                return;
            }
            if (!EnabledShipTP && player.GetParentEntity() is CargoShip)
            {
                SendReply(player, Messages["PlayerIsOnCargoShip"]);
                return;
            }
            if (!EnabledBallonTP && player.GetParentEntity() is HotAirBalloon)
            {
                SendReply(player, Messages["PlayerIsOnHotAirBalloon"]);
                return;
            }
            if (player.IsWounded() && CancelTPWounded)
            {
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (player.metabolism.bleeding.value > 0 && CancelTPMetabolism)
            {
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (CancelTPRadiation && player.metabolism.radiation_poison.value > 10)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["Radiation"]);
                return;
            }
            if (restrictTPRCupboard)
            {
                var privilege = player.GetBuildingPrivilege(player.WorldSpaceBounds());
                if (privilege != null && !player.IsBuildingAuthed())
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["tpcupboard"]);
                    return;
                }
            }
            var name = args[0];
            var target = FindBasePlayer(name);
            if (target == null || !target.IsConnected)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["playermissing"]);
                return;
            }
            if (target == player)
            {
                SendReply(player, Messages["playerisyou"]);
                return;
            }
            if (FriendsEnabled)
                if (!IsFriends(target.userID, player.userID) && !IsTeamate(player, target.userID) && !IsClanMember(player.userID, target.userID))
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["PlayerNotFriend"]);
                    return;
                }
            int seconds = 0;
            if (restrictCupboard && player.GetBuildingPrivilege(player.WorldSpaceBounds()) != null && !player.GetBuildingPrivilege(player.WorldSpaceBounds()).authorizedPlayers.Select(p => p.userid).Contains(player.userID))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tpcupboard"]);
                return;
            }

            if (cooldownsTP.TryGetValue(player.userID, out seconds) && seconds > 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, string.Format(Messages["tpkd"], TimeToString(seconds)));
                return;
            }
            if (CancelTPCold && player.metabolism.temperature.value < 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["coldplayer"]);
                return;
            }
            if (tpQueue.Any(p => p.Player == player) || pendings.Any(p => p.Player2 == player))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tpError"]);
                return;
            }

            if (tpQueue.Any(p => p.Player == target) || pendings.Any(p => p.Player2 == target))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tpError"]);
                return;
            }
            SendReply(player, string.Format(Messages["tprrequestsuccess"], target.displayName));
            SendReply(target, string.Format(Messages["tprpending"], player.displayName));
            Effect.server.Run(EffectPrefab1, target, 0, Vector3.zero, Vector3.forward);

            DVTeleportationAcceptUI(target, player.displayName);
            pendings.Add(new TP(target, Vector3.zero, 15, false, false, player));
            if (!IsFriends(target.userID, player.userID) && !IsClanMember(player.userID, target.userID) && !player.Team.members.Contains(target.userID)) return;
            cmdChatTpa(target, command, new string[] { "atp" });
            SendReply(target, Messages["TPASuccess"]);
        }
        [ChatCommand("tpa")]
        void cmdChatTpa(BasePlayer player, string command, string[] args)
        {
            if (!enabledTPR) return;
            var tp = pendings.Find(p => p.Player == player);
            if (tp == null)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tpanotexist"]);
                return;
            }
            BasePlayer pendingPlayer = tp.Player2;
            if (pendingPlayer == null)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tpanotexist"]);
                return;
            }
            if (!EnabledBallonTP && player.GetParentEntity() is HotAirBalloon)
            {
                SendReply(player, Messages["PlayerIsOnHotAirBalloon"]);
                return;
            }
            if (!EnabledShipTP && player.GetParentEntity() is CargoShip)
            {
                SendReply(player, Messages["PlayerIsOnCargoShip"]);
                return;
            }
            if (CancelTPCold && player.metabolism.temperature.value < 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["coldplayer"]);
                return;
            }
            if (player.IsWounded() && CancelTPWounded)
            {
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (player.metabolism.bleeding.value > 0 && CancelTPMetabolism)
            {
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (CancelTPRadiation && player.metabolism.radiation_poison.value > 10)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["Radiation"]);
                return;
            }
            if (restrictCupboard && player.GetBuildingPrivilege(player.WorldSpaceBounds()) != null && !player.GetBuildingPrivilege(player.WorldSpaceBounds()).authorizedPlayers.Select(p => p.userid).Contains(player.userID))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tpacupboard"]);
                return;
            }
            var ret = Interface.Call("CanTeleport", player) as string;
            if (ret != null)
            {
                SendReply(player, ret);
                return;
            }
            if (FriendsEnabled)
                if (!IsFriends(pendingPlayer.userID, player.userID) && !IsTeamate(player, pendingPlayer.userID) && !IsClanMember(player.userID, pendingPlayer.userID))
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["PlayerNotFriend"]);
                    return;
                }
            var time = GetTeleportTime(pendingPlayer.userID);
            pendings.Remove(tp);
            var lastTp = tpQueue.Find(p => p.Player == pendingPlayer);
            if (lastTp != null)
            {
                tpQueue.Remove(lastTp);
            }
            var Enabled = player.GetParentEntity() is CargoShip || player.GetParentEntity() is HotAirBalloon;
            tpQueue.Add(new TP(pendingPlayer, player.transform.position, time, Enabled, false, player));
            Effect.server.Run(EffectPrefab1, player, 0, Vector3.zero, Vector3.forward);
            SendReply(pendingPlayer, string.Format(Messages["tpqueue"], player.displayName, TimeToString(time)));
            if (args.Length <= 0) SendReply(player, String.Format(Messages["tpasuccess"], pendingPlayer.displayName, TimeToString(time)));
            CuiHelper.DestroyUi(player, PARENT_TELEPORT);
        }
        
        [ChatCommand("tpc")]
        void cmdChatTpc(BasePlayer player, string command, string[] args)
        {
            var tp = pendings.Find(p => p.Player == player);
            BasePlayer target = tp?.Player2;
            if (target != null)
            {
                pendings.Remove(tp);
                SendReply(player, Messages["tpc"]);
                SendReply(target, string.Format(Messages["tpctarget"], player.displayName));
                CuiHelper.DestroyUi(player, "Teleport");
                CuiHelper.DestroyUi(target, "Teleport");
                CuiHelper.DestroyUi(target, PARENT_TELEPORT);
                return;
            }
            if (player.IsWounded() && CancelTPWounded)
            {
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (player.metabolism.bleeding.value > 0 && CancelTPMetabolism)
            {
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (CancelTPRadiation && player.metabolism.radiation_poison.value > 10)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["Radiation"]);
                return;
            }
            if (CancelTPCold && player.metabolism.temperature.value < 0)
            {
                SendReply(player, Messages["coldplayer"]);
                return;
            }
            foreach (var pend in pendings)
            {
                if (pend.Player2 == player)
                {
                    SendReply(player, Messages["tpc"]);
                    SendReply(pend.Player, string.Format(Messages["tpctarget"], player.displayName));
                    pendings.Remove(pend);
                    return;
                }
            }
            foreach (var tpQ in tpQueue)
            {
                if (tpQ.Player2 != null && tpQ.Player2 == player)
                {
                    SendReply(player, Messages["tpc"]);
                    SendReply(tpQ.Player, string.Format(Messages["tpctarget"], player.displayName));
                    tpQueue.Remove(tpQ);
                    CuiHelper.DestroyUi(player, "Teleport");
                    CuiHelper.DestroyUi(tpQ.Player, "Teleport");
                    return;
                }
                if (tpQ.Player == player)
                {
                    SendReply(player, Messages["tpc"]);
                    if (tpQ.Player2 != null)
                    {
                        SendReply(tpQ.Player2, string.Format(Messages["tpctarget"], player.displayName));
                        CuiHelper.DestroyUi(tpQ.Player2, "Teleport");
                    }
                    tpQueue.Remove(tpQ);
                    CuiHelper.DestroyUi(player, "Teleport");

                    return;
                }
            }
        }
        void SpectateFinish(BasePlayer player)
        {
            player.Command("camoffset", "0,1,0");
            player.StopSpectating();
            player.SetParent(null);
            player.gameObject.SetLayerRecursive(17);
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Spectating, false);
            player.SetPlayerFlag(BasePlayer.PlayerFlags.ThirdPersonViewmode, false);
            player.SendNetworkUpdateImmediate();
            player.metabolism.Reset();
            player.InvokeRepeating("InventoryUpdate", 1f, 0.1f * UnityEngine.Random.Range(0.99f, 1.01f));
            if (player.net?.connection != null) player.ClientRPCPlayer(null, player, "StartLoading");
            player.StartSleeping();
            if (lastPositions.ContainsKey(player.userID))
            {
                Vector3 lastPosition = lastPositions[player.userID] + Vector3.up;
                player.MovePosition(lastPosition);
                if (player.net?.connection != null) player.ClientRPCPlayer(null, player, "ForcePositionTo", lastPosition);
                lastPositions.Remove(player.userID);

            }

            if (player.net?.connection != null) player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
            player.UpdateNetworkGroup();
            player.SendNetworkUpdateImmediate(false);
            if (player.net?.connection == null) return;
            try
            {
                player.ClearEntityQueue(null);
            }
            catch { }
            player.SendFullSnapshot();

            SendReply(player, "Слежка закончена!");
        }


        private void OnUserConnected(IPlayer player) => ResetSpectate(player);

        private void OnUserDisconnected(IPlayer player) => ResetSpectate(player);

        private void ResetSpectate(IPlayer player)
        {
            player.Command("camoffset 0,1,0");

            if (lastPositions.ContainsKey(ulong.Parse(player.Id)))
            {
                lastPositions.Remove(ulong.Parse(player.Id));
            }
        }

        object OnPlayerSpectateEnd(BasePlayer player, string spectateFilter)
        {
            player.Command("camoffset", "0,1,0");
            return null;
        }

        [ChatCommand("tpl")]
        void cmdChattpGo(BasePlayer player, string command, string[] args)
        {
            if (!EnabledTPLForPlayers && !player.IsAdmin && !PermissionService.HasPermission(player.userID, "DVTeleportation.admin")) return;
            if (args == null || args.Length == 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tpArgsError"]);
                return;
            }
            switch (args[0])
            {
                default:
                    if (tpsave.Count <= 0)
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["homesmissing"]);
                        return;
                    }
                    var nametp = args[0];
                    var tp = tpsave.Find(p => p.Name == nametp);
                    if (tp == null)
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["homenotexist"]);
                        return;
                    }
                    var position = tp.pos;
                    var ret = Interface.Call("CanTeleport", player) as string;
                    if (ret != null)
                    {
                        SendReply(player, ret);
                        return;
                    }
                    int seconds;
                    if (cooldownsHOME.TryGetValue(player.userID, out seconds) && seconds > 0)
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, string.Format(Messages["tpkd"], TimeToString(seconds)));
                        return;
                    }
                    var lastTp = tpQueue.Find(p => p.Player == player);
                    if (lastTp != null) tpQueue.Remove(lastTp);
                    Effect.server.Run(EffectPrefab1, player, 0, Vector3.zero, Vector3.forward);
                    if (TPLAdmin && player.IsAdmin || PermissionService.HasPermission(player.userID, "DVTeleportation.admin")) Teleport(player, position);
                    else
                    {
                        tpQueue.Add(new TP(player, position, TplPedingTime, false, true));
                        SendReply(player, String.Format(Messages["homequeue"], nametp, TimeToString(TplPedingTime)));
                    }
                    return;
                case "add":
                    if (!player.IsAdmin && !PermissionService.HasPermission(player.userID, "DVTeleportation.admin")) return;
                    if (args == null || args.Length == 1)
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["settpArgsError"]);
                        return;
                    }
                    var nameAdd = args[1];
                    SetTpSave(player, nameAdd);
                    return;
                case "remove":
                    if (!player.IsAdmin && !PermissionService.HasPermission(player.userID, "DVTeleportation.admin")) return;
                    if (args == null || args.Length == 1)
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["removetpArgsError"]);
                        return;
                    }
                    nametp = args[1];
                    if (tpsave.Count > 0)
                    {
                        tp = tpsave.Find(p => p.Name == nametp);
                        if (tp == null)
                        {
                            Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                            SendReply(player, Messages["homesmissing"]);
                            return;
                        }
                        Effect.server.Run(EffectPrefab1, player, 0, Vector3.zero, Vector3.forward);
                        tpsave.Remove(tp);
                        SendReply(player, Messages["removehomesuccess"], nametp);
                    }
                    return;
                case "list":
                    if (tpsave.Count <= 0)
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["TPLmissing"]);
                        return;
                    }
                    var tplist = tpsave.Select(x => $"{x.Name} {x.pos}");
                    SendReply(player, Messages["TPLList"], string.Join("\n", tplist.ToArray()));
                    return;
            }
        }
        [ChatCommand("tpspec")]
        void cmdTPSpec(BasePlayer player, string command, string[] args)
        {
            if (!PermissionService.HasPermission(player.userID, "DVTeleportation.admin")) return;
            if (!player.IsSpectating())
            {
                if (args.Length == 0 || args.Length != 1)
                {
                    SendReply(player, Messages["tpspecError"]);
                    return;
                }
                string name = args[0];
                BasePlayer target = FindBasePlayer(name);
                if (target == null)
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["playermissing"]);
                    return;
                }
                switch (args.Length)
                {
                    case 1:
                        if (!target.IsConnected)
                        {
                            SendReply(player, Messages["playermissingOff"]);
                            return;
                        }
                        if (target.IsDead())
                        {
                            SendReply(player, Messages["playermissingOrDeath"]);
                            return;
                        }
                        if (ReferenceEquals(target, player))
                        {
                            SendReply(player, Messages["playerItsYou"]);
                            return;
                        }
                        if (target.IsSpectating())
                        {
                            SendReply(player, Messages["playerItsSpec"]);
                            return;
                        }
                        spectatingPlayers.Remove(target);
                        lastPositions[player.userID] = player.transform.position;
                        HeldEntity heldEntity = player.GetActiveItem()?.GetHeldEntity() as HeldEntity;
                        heldEntity?.SetHeld(false);
                        player.SetPlayerFlag(BasePlayer.PlayerFlags.Spectating, true);
                        player.gameObject.SetLayerRecursive(10);
                        player.CancelInvoke("MetabolismUpdate");
                        player.CancelInvoke("InventoryUpdate");
                        player.ClearEntityQueue();
                        player.SendEntitySnapshot(target);
                        player.gameObject.Identity();
                        player.SetParent(target);
                        player.SetPlayerFlag(BasePlayer.PlayerFlags.ThirdPersonViewmode, true);
                        player.Command("camoffset", "0, 1.3, 0");
                        SendReply(player, $"Вы наблюдаете за игроком {target}! Что бы переключаться между игроками, нажимайте: Пробел\nЧтобы выйти с режима наблюдения, введите: /tpspec");
                        break;
                }
            }
            else SpectateFinish(player);
        }
        [ChatCommand("tp")]
        void cmdTP(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin && !PermissionService.HasPermission(player.userID, "DVTeleportation.admin")) return;
            switch (args.Length)
            {
                case 1:
                    string name = args[0];
                    BasePlayer target = FindBasePlayer(name);
                    if (target == null)
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["playermissing"]);
                        return;
                    }
                    if (adminsLogs)
                    {
                        LogToFile("admin", $"[{DateTime.Now.ToShortTimeString()}] {player} телепортировался к {target}", this, true);
                    }
                    Teleport(player, target);
                    break;
                case 2:
                    string name1 = args[0];
                    string name2 = args[1];
                    BasePlayer target1 = FindBasePlayer(name1);
                    BasePlayer target2 = FindBasePlayer(name2);
                    if (target1 == null || target2 == null)
                    {
                        SendReply(player, Messages["playermissing"]);
                        return;
                    }
                    if (adminsLogs)
                    {
                        LogToFile("admin", $"[{DateTime.Now.ToShortTimeString()}] Игрок {player} телепортировал {target1} к {target2}", this, true);
                    }
                    Teleport(target1, target2);
                    break;
                case 3:
                    float x = float.Parse(args[0].Replace(",", ""));
                    float y = float.Parse(args[1].Replace(",", ""));
                    float z = float.Parse(args[2]);
                    if (adminsLogs)
                    {
                        LogToFile("admin", $"[{DateTime.Now.ToShortTimeString()}] Игрок {player} телепортировался на координаты: ({x} / {y} / {z})", this, true);
                    }
                    Teleport(player, x, y, z);
                    break;
            }
        }
        [ConsoleCommand("home.wipe")]
        private void CmdTest(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null) return;
            PrintWarning("Запущен ручной вайп. Очищаем данные с data/DVTeleportation");
            WipeData();
        }
        public string TimeToString(double time)
        {
            TimeSpan elapsedTime = TimeSpan.FromSeconds(time);
            int hours = elapsedTime.Hours;
            int minutes = elapsedTime.Minutes;
            int seconds = elapsedTime.Seconds;
            int days = Mathf.FloorToInt((float)elapsedTime.TotalDays);
            string s = "";
            if (days > 0) s += $"{days} дн.";
            if (hours > 0) s += $"{hours} ч. ";
            if (minutes > 0) s += $"{minutes} мин. ";
            if (seconds > 0) s += $"{seconds} сек.";
            else s = s.TrimEnd(' ');
            return s;
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            pendings.RemoveAll(p => p.Player == player || p.Player2 == player);
            tpQueue.RemoveAll(p => p.Player == player || p.Player2 == player);
        }

        void Loaded()
        {
            lang.RegisterMessages(Messages, this, "en");
            Messages = lang.GetMessages("en", this);
            LoadDefaultConfig();
        }

        void OnServerInitialized()
        {
            LoadData();
            permission.RegisterPermission(TPADMIN, this);
            permission.RegisterPermission(AutoTPAPermission, this);
            timer.Every(1f, DVTeleportationTimerHandle);
        }

        void OnServerSave()
        => SaveData();

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, PARENT_TELEPORT);
                CuiHelper.DestroyUi(player, "Teleport");
            }
            SaveData();
        }

        void OnEntityBuilt(Planner planner, GameObject gameobject)
        {
            if (planner == null || gameobject == null) return;
            var player = planner.GetOwnerPlayer();
            BaseEntity entity = gameobject.ToBaseEntity();
            if (entity == null) return;
            if (gameobject.name.Contains("foundation"))
            {
                var pos = gameobject.transform.position;
                foreach (var pending in tpQueue)
                {
                    if (Vector3.Distance(pending.pos, pos) < 3)
                    {
                        entity.Kill();
                        SendReply(planner.GetOwnerPlayer(), "Нельзя, тут телепортируется игрок!");
                        return;
                    }
                }
            }
        }

        object OnEntityTakeDamage(BasePlayer player, HitInfo info)
        {
            if (player == null || info == null) return null;
            var tp = tpQueue.Find(p => p.Player == player);
            if (tp != null)
            {
                SendReply(tp.Player, Messages["tpwounded"]);
                tpQueue.Remove(tp);
            }
            return null;
        }

        [PluginReference] Plugin Duel;
        bool InDuel(BasePlayer player) => Duel?.Call<bool>("IsPlayerOnActiveDuel", player) ?? false;

        void DVTeleportationTimerHandle()
        {
            List<ulong> tpkdToRemove = new List<ulong>();
            foreach (var uid in cooldownsTP.Keys.ToList())
            {
                if (--cooldownsTP[uid] <= 0)
                {
                    tpkdToRemove.Add(uid);
                }
            }
            tpkdToRemove.ForEach(p => cooldownsTP.Remove(p));
            List<ulong> tpkdHomeToRemove = new List<ulong>();
            foreach (var uid in cooldownsHOME.Keys.ToList())
            {
                if (--cooldownsHOME[uid] <= 0) tpkdHomeToRemove.Add(uid);
            }
            tpkdHomeToRemove.ForEach(p => cooldownsHOME.Remove(p));
            for (int i = pendings.Count - 1;
            i >= 0;
            i--)
            {
                var pend = pendings[i];
                if (pend.Player != null && pend.Player.IsConnected && pend.Player.IsWounded())
                {
                    SendReply(pend.Player, Messages["tpwounded"]);

                    if (pend.Player2 != null && pend.Player2.IsConnected)
                    {
                        CuiHelper.DestroyUi(pend.Player2, "Teleport");
                        CuiHelper.DestroyUi(pend.Player2, PARENT_TELEPORT);
                    }
                    if (pend.Player != null && pend.Player.IsConnected)
                    {
                        CuiHelper.DestroyUi(pend.Player, "Teleport");
                        CuiHelper.DestroyUi(pend.Player, PARENT_TELEPORT);
                    }
                    pendings.RemoveAt(i);
                    continue;
                }
                if (--pend.seconds <= 0)
                {
                    pendings.RemoveAt(i);
                    if (pend.Player2 != null && pend.Player2.IsConnected)
                    {
                        SendReply(pend.Player2, Messages["tppendingcanceled"]);
                        CuiHelper.DestroyUi(pend.Player2, "Teleport");
                        CuiHelper.DestroyUi(pend.Player2, PARENT_TELEPORT);
                    }
                    if (pend.Player != null && pend.Player.IsConnected)
                    {
                        SendReply(pend.Player, Messages["tpacanceled"]);
                        CuiHelper.DestroyUi(pend.Player, "Teleport");
                        CuiHelper.DestroyUi(pend.Player, PARENT_TELEPORT);
                    }
                }
                else
                {
                    if (pend.Player != null && pend.Player.IsConnected)
                    {
                        CreateUpdateUI(pend.Player, pend, "PendingTextPlayer2");
                    }
                    if (pend.Player2 != null && pend.Player2.IsConnected)
                    {
                        CreateUpdateUI(pend.Player2, pend, "PendingTextPlayer1");
                    }
                }
            }
            for (int i = tpQueue.Count - 1;
            i >= 0;
            i--)
            {
                var reply = 288;
                if (reply == 0) { }
                var tp = tpQueue[i];
                if (tp.Player != null)
                {

                    if (tp.Player.IsDead())
                    {
                        if (tp.Player2 != null && tp.Player2.IsConnected)
                        {
                            CuiHelper.DestroyUi(tp.Player2, "Teleport");
                            CuiHelper.DestroyUi(tp.Player2, PARENT_TELEPORT);
                        }
                        CuiHelper.DestroyUi(tp.Player, "Teleport");
                        CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                        tpQueue.RemoveAt(i);
                        continue;
                    }
                    if (tp.Player.IsConnected && (CancelTPWounded && tp.Player.IsWounded()) || (tp.Player.metabolism.bleeding.value > 0 && CancelTPMetabolism) || (CancelTPRadiation && tp.Player.metabolism.radiation_poison.value > 10))
                    {
                        SendReply(tp.Player, Messages["tpwounded"]);
                        if (tp.Player2 != null && tp.Player2.IsConnected)
                        {
                            SendReply(tp.Player2, Messages["tpWoundedTarget"]);
                            CuiHelper.DestroyUi(tp.Player2, "Teleport");
                            CuiHelper.DestroyUi(tp.Player2, PARENT_TELEPORT);
                        }
                        CuiHelper.DestroyUi(tp.Player, "Teleport");
                        CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                        tpQueue.RemoveAt(i);
                        continue;
                    }
                    if (InDuel(tp.Player))
                    {
                        SendReply(tp.Player, Messages["InDuel"]);
                        if (tp.Player2 != null && tp.Player2.IsConnected)
                        {
                            SendReply(tp.Player2, Messages["InDuelTarget"]);
                            CuiHelper.DestroyUi(tp.Player2, "Teleport");
                            CuiHelper.DestroyUi(tp.Player2, PARENT_TELEPORT);
                        }
                        CuiHelper.DestroyUi(tp.Player, "Teleport");
                        CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                        tpQueue.RemoveAt(i);
                        continue;
                    }
                    if (restrictTPRCupboard)
                    {
                        var privilege = tp.Player.GetBuildingPrivilege(tp.Player.WorldSpaceBounds());
                        if (privilege != null && !tp.Player.IsBuildingAuthed())
                        {
                            Effect.server.Run(EffectPrefab, tp.Player, 0, Vector3.zero, Vector3.forward);

                            SendReply(tp.Player, Messages["tpcupboard"]);
                            if (tp.Player2 != null && tp.Player2.IsConnected)
                            {
                                SendReply(tp.Player2, Messages["tpcupboardTarget"]);
                                CuiHelper.DestroyUi(tp.Player2, "Teleport");
                                CuiHelper.DestroyUi(tp.Player2, PARENT_TELEPORT);
                            }
                            CuiHelper.DestroyUi(tp.Player, "Teleport");
                            CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                            tpQueue.RemoveAt(i);
                            return;
                        }
                    }
                }

                if (tp.Player2 != null)
                {
                    if (tp.Player2.IsConnected && (tp.Player2.IsWounded() && CancelTPWounded) || (tp.Player2.metabolism.bleeding.value > 0 && CancelTPMetabolism) || (CancelTPRadiation && tp.Player2.radiationLevel > 10))
                    {
                        SendReply(tp.Player2, Messages["tpwounded"]);
                        if (tp.Player != null && tp.Player.IsConnected)
                        {
                            SendReply(tp.Player, Messages["tpWoundedTarget"]);
                            CuiHelper.DestroyUi(tp.Player, "Teleport");
                            CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                        }
                        CuiHelper.DestroyUi(tp.Player2, "Teleport");
                        CuiHelper.DestroyUi(tp.Player2, PARENT_TELEPORT);
                        tpQueue.RemoveAt(i);
                        continue;
                    }
                    if (InDuel(tp.Player2))
                    {
                        SendReply(tp.Player2, Messages["InDuel"]);
                        if (tp.Player != null && tp.Player.IsConnected)
                        {
                            SendReply(tp.Player, Messages["InDuelTarget"]);
                            CuiHelper.DestroyUi(tp.Player, "Teleport");
                            CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                        }
                        CuiHelper.DestroyUi(tp.Player2, "Teleport");
                        CuiHelper.DestroyUi(tp.Player2, PARENT_TELEPORT);
                        tpQueue.RemoveAt(i);
                        continue;
                    }
                    if (restrictTPRCupboard)
                    {
                        var privilege = tp.Player2.GetBuildingPrivilege(tp.Player2.WorldSpaceBounds());
                        if (privilege != null && !tp.Player2.IsBuildingAuthed())
                        {
                            Effect.server.Run(EffectPrefab, tp.Player2, 0, Vector3.zero, Vector3.forward);
                            if (tp.Player != null && tp.Player.IsConnected)
                            {
                                SendReply(tp.Player, Messages["tpcupboardTarget"]);
                                CuiHelper.DestroyUi(tp.Player, "Teleport");
                                CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                            }

                            SendReply(tp.Player2, Messages["tpcupboard"]);
                            CuiHelper.DestroyUi(tp.Player2, "Teleport");
                            CuiHelper.DestroyUi(tp.Player2, PARENT_TELEPORT);
                            return;
                        }
                    }
                }
                if (--tp.seconds <= 0)
                {
                    tpQueue.RemoveAt(i);
                    var ret = Interface.CallHook("CanTeleport", tp.Player) as string;
                    if (ret != null)
                    {
                        SendReply(tp.Player, ret);
                        CuiHelper.DestroyUi(tp.Player, "Teleport");
                        CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                        continue;
                    }
                    if (CheckInsideInFoundation(tp.pos))
                    {
                        SendReply(tp.Player, Messages["InsideInFoundationTP"]);
                        CuiHelper.DestroyUi(tp.Player, "Teleport");
                        CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                        continue;
                    }
                    if (tp.Player2 != null)
                    {

                        if (tp.Player.GetMountedVehicle() is ScrapTransportHelicopter || tp.Player.GetMountedVehicle() is MiniCopter || tp.Player2.GetMountedVehicle() is ScrapTransportHelicopter || tp.Player2.GetMountedVehicle() is MiniCopter || tp.Player.GetComponentInParent<ScrapTransportHelicopter>() || tp.Player2.GetComponentInParent<ScrapTransportHelicopter>())
                        {
                            SendReply(tp.Player, Messages["TeleportaCancelHeli"]);
                            SendReply(tp.Player2, Messages["TeleportaCancelHeli"]);
                            CuiHelper.DestroyUi(tp.Player, "Teleport");
                            CuiHelper.DestroyUi(tp.Player2, "Teleport");
                            CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                            continue;
                        }
                        tp.Player.SetParent(tp.Player2.GetParentEntity());
                        if (tp.EnabledShip) tp.pos = tp.Player2.transform.position;
                    }
                    if (tp.Player2 != null && tp.Player != null && tp.Player.IsConnected && tp.Player2.IsConnected)
                    {
                        var seconds = GetKD(tp.Player.userID);
                        cooldownsTP[tp.Player.userID] = seconds;
                        SendReply(tp.Player, string.Format(Messages["tpplayersuccess"], tp.Player2.displayName));
                        CuiHelper.DestroyUi(tp.Player, "Teleport");
                        CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                        CuiHelper.DestroyUi(tp.Player2, "Teleport");
                    }
                    else if (tp.Player != null && tp.Player.IsConnected)
                    {
                        tp.Player.SetParent(null);
                        if (tp.TPL)
                        {
                            var seconds = TPLCooldown;
                            cooldownsHOME[tp.Player.userID] = seconds;
                            SendReply(tp.Player, Messages["tplsuccess"]);
                            CuiHelper.DestroyUi(tp.Player, "Teleport");
                            CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                        }
                        else
                        {
                            var seconds = GetKDHome(tp.Player.userID);
                            cooldownsHOME[tp.Player.userID] = seconds;
                            SendReply(tp.Player, Messages["tphomesuccess"]);
                            CuiHelper.DestroyUi(tp.Player, "Teleport");
                            CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                        }
                    }
                    if (tp.Player.IsDead())
                        continue;
                    Teleport(tp.Player, tp.pos);
                    NextTick(() => Interface.CallHook("OnPlayerTeleported", tp.Player));
                }
                else
                {
                    CreateUpdateUI(tp.Player, tp, "TimerTextPlayer1");
                    if (tp.Player2 != null && tp.Player2.IsConnected)
                    {
                        CreateUpdateUI(tp.Player2, tp, "TimerTextPlayer2");
                    }
                }
            }
        }

        void SetTpSave(BasePlayer player, string name)
        {
            var position = player.transform.position;
            if (tpsave.Count > 0)
            {
                var tp = tpsave.Find(p => p.Name == name);
                if (tp != null)
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["homeexist"]);
                    return;
                }
            }
            tpsave.Add(new TPList()
            {
                Name = name,
                pos = position
            }
            );

            Effect.server.Run(EffectPrefab1, player, 0, Vector3.zero, Vector3.forward);
            SendReply(player, Messages["homesucces"], name);
            timer.Once(10f, () => sethomeBlock.Remove(player.userID));
        }

        private readonly int blockLayer = LayerMask.GetMask("Construction");

        private bool ValidBlock(BaseEntity entity, Vector3 position)
        {
            Vector3 center = entity.CenterPoint();

            List<BaseEntity> ents = new List<BaseEntity>();
            Vis.Entities<BaseEntity>(center, 1.5f, ents);
            foreach (BaseEntity wall in ents)
            {
                if (wall.name.Contains("external.high"))
                    return false;
            }
            if (entity.PrefabName.Contains("triangle.prefab"))
            {
                if (Math.Abs(center.x - position.x) < 0.45f && Math.Abs(center.z - position.z) < 0.45f)
                    return true;
            }
            else if (entity.PrefabName.Contains("foundation.prefab") || entity.PrefabName.Contains("floor.prefab"))
            {
                if (Math.Abs(center.x - position.x) < 0.7f && Math.Abs(center.z - position.z) < 0.7f)
                    return true;
            }
            return false;
        }

        private List<BuildingBlock> GetFoundation(Vector3 position)
        {
            RaycastHit hitinfo;
            var entities = new List<BuildingBlock>();

            if (Physics.Raycast(position, Vector3.down, out hitinfo, 2.5f, blockLayer) && hitinfo.GetEntity().IsValid())
            {
                var entity = hitinfo.GetEntity();
                if (entity.PrefabName.Contains("foundation") || position.y < entity.WorldSpaceBounds().ToBounds().max.y)
                {
                    if (ValidBlock(entity, position))
                    {
                        entities.Add(entity as BuildingBlock);
                    }
                }
            }
            return entities;
        }


        void SetHome(BasePlayer player, string name, Vector3 pos)
        {
            var uid = player.userID;
            if (player.GetBuildingPrivilege(player.WorldSpaceBounds()) != null && !player.GetBuildingPrivilege(player.WorldSpaceBounds()).authorizedPlayers.Select(p => p.userid).Contains(player.userID))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["sethomecupboard"]);
                return;
            }
            Dictionary<string, Vector3> playerHomes;
            if (!homes.TryGetValue(uid, out playerHomes)) playerHomes = (homes[uid] = new Dictionary<string, Vector3>());
            if (GetHomeLimit(uid) == playerHomes.Count)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["maxhomes"]);
                return;
            }
            if (playerHomes.ContainsKey(name))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["homeexist"]);
                return;
            }
            List<BuildingBlock> foundation = GetFoundation(pos);
            foundation.RemoveAll(x => !x.IsValid() || x.IsDestroyed);

            if (foundation.Count <= 0)
            {
                SendReply(player, Messages["foundationmissing"]);
                return;
            }

            if (CheckInsideInFoundation(player.transform.position))
            {
                SendReply(player, Messages["InsideInFoundation"]);
                return;
            }
            playerHomes.Add(name, pos);
            if (createSleepingBug)
            {
                CreateSleepingBag(player, pos, name);
            }
            Effect.server.Run(EffectPrefab1, player, 0, Vector3.zero, Vector3.forward);
            SendReply(player, Messages["homesucces"], name);
            sethomeBlock.Add(player.userID);
            timer.Once(10f, () => sethomeBlock.Remove(player.userID));
        }


        private bool CheckInsideInFoundation(Vector3 position)
        {
            foreach (var hit in Physics.RaycastAll(position, Vector3.up, 2f, LayerMask.GetMask("Terrain", "World", "Construction", "Deployed")))
            {
                if (!foundationEx && hit.GetCollider().name.Contains("foundation")) return true;
                else
                if (hit.GetCollider().name.Contains("foundation")) return true;
            }
            foreach (var hit in Physics.RaycastAll(position + Vector3.up + Vector3.up + Vector3.up + Vector3.up, Vector3.down, 2f, LayerMask.GetMask("Terrain", "World", "Construction", "Deployed")))
            {
                if (hit.GetCollider().name.Contains("foundation")) return true;
            }
            return false;
        }
        int GetKDHome(ulong uid)
        {
            int min = tpkdhomeDefault;
            foreach (var privilege in tpkdhomePerms) if (PermissionService.HasPermission(uid, privilege.Key)) min = Mathf.Min(min, privilege.Value);
            return min;
        }
        int GetKD(ulong uid)
        {
            int min = tpkdDefault;
            foreach (var privilege in tpkdPerms) if (PermissionService.HasPermission(uid, privilege.Key)) min = Mathf.Min(min, privilege.Value);
            return min;
        }
        int GetHomeLimit(ulong uid)
        {
            int max = homelimitDefault;
            foreach (var privilege in homelimitPerms) if (PermissionService.HasPermission(uid, privilege.Key)) max = Mathf.Max(max, privilege.Value);
            return max;
        }
        int GetTeleportTime(ulong uid)
        {
            int min = teleportSecsDefault;
            foreach (var privilege in teleportSecsPerms) if (PermissionService.HasPermission(uid, privilege.Key)) min = Mathf.Min(min, privilege.Value);
            return min;
        }
        BaseEntity GetBuldings(Vector3 pos)
        {
            RaycastHit hit;
            if (Physics.Raycast(new Ray(pos, Vector3.down), out hit, 0.2f))
            {
                var entity = hit.GetEntity();
                if (entity != null)
                {
                    if (entity.GetComponent<BuildingBlock>() == null) return null;
                    return entity;
                }
                else return null;
            }
            return null;
        }

        SleepingBag GetSleepingBag(string name, Vector3 pos)
        {
            List<SleepingBag> sleepingBags = new List<SleepingBag>();
            Vis.Components(pos, .1f, sleepingBags);
            return sleepingBags.Count > 0 ? sleepingBags[0] : null;
        }
        void CreateSleepingBag(BasePlayer player, Vector3 pos, string name)
        {
            SleepingBag sleepingBag = GameManager.server.CreateEntity("assets/prefabs/deployable/sleeping bag/sleepingbag_leather_deployed.prefab", pos, Quaternion.identity) as SleepingBag;
            if (sleepingBag == null) return;
            sleepingBag.skinID = 2597355840;
            sleepingBag.deployerUserID = player.userID;
            sleepingBag.niceName = name;
            sleepingBag.OwnerID = player.userID;
            sleepingBag.Spawn();
            sleepingBag.SendNetworkUpdate();
        }
        Dictionary<string, Vector3> GetHomes(ulong uid)
        {
            Dictionary<string, Vector3> positions;
            if (!homes.TryGetValue(uid, out positions)) return null;
            return positions.ToDictionary(p => p.Key, p => p.Value);
        }

        public void Teleport(BasePlayer player, BasePlayer target) => Teleport(player, target.transform.position);
        public void Teleport(BasePlayer player, float x, float y, float z) => Teleport(player, new Vector3(x, y, z));
        public void Teleport(BasePlayer player, Vector3 position)
        {
            player.RemoveFromTriggers();
            if (player.GetParentEntity() != null)
                player.SetParent(null);
            if (player.IsDead() && player.IsConnected)
            {
                player.RespawnAt(position, Quaternion.identity);
                return;
            }
            var ret = Interface.Call("CanTeleport", player) as string;
            if (ret != null)
            {
                SendReply(player, ret);
                return;
            }
            BaseMountable mount = player.GetMounted();
            if (mount != null) mount.DismountPlayer(player);
            if (player.net?.connection != null) player.ClientRPCPlayer(null, player, "StartLoading");
            player.StartSleeping();
            player.Teleport(position);
            player.SendFullSnapshot();
            if (player.net?.connection != null) player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
            player.SendNetworkUpdateImmediate();
            player.UpdateNetworkGroup();

        }
        DynamicConfigFile homesFile = Interface.Oxide.DataFileSystem.GetFile("DVTeleportation/Homes");
        DynamicConfigFile tpsaveFile = Interface.Oxide.DataFileSystem.GetFile("DVTeleportation/AdminTpSave");
        public Dictionary<ulong, AutoTPASettings> AutoTPA = new Dictionary<ulong, AutoTPASettings>();

        public class AutoTPASettings
        {
            public bool Enabled;
            public Dictionary<string, ulong> PlayersList = new Dictionary<string, ulong>();
        }


        void LoadData()
        {
            try
            {
                tpsave = tpsaveFile.ReadObject<List<TPList>>();
                if (tpsave == null)
                {
                    PrintError("File AdminTpSave is null! Create new data files");
                    tpsave = new List<TPList>();
                }
                homes = homesFile.ReadObject<Dictionary<ulong, Dictionary<string, Vector3>>>();
                if (homes == null)
                {
                    PrintError("File Homes is null! Create new data files");
                    homes = new Dictionary<ulong, Dictionary<string, Vector3>>();
                }
                AutoTPA = Interface.GetMod().DataFileSystem.ReadObject<Dictionary<ulong, AutoTPASettings>>($"DVTeleportation/AutoTPA");

            }
            catch
            {
                tpsave = new List<TPList>();
                homes = new Dictionary<ulong, Dictionary<string, Vector3>>();
                AutoTPA = new Dictionary<ulong, AutoTPASettings>();
            }
        }
        void SaveData()
        {
            if (tpsave != null) tpsaveFile.WriteObject(tpsave);
            if (homes != null) homesFile.WriteObject(homes);
            if (AutoTPA != null) Interface.Oxide.DataFileSystem.WriteObject($"DVTeleportation/AutoTPA", AutoTPA);

        }
        Dictionary<string, string> Messages = new Dictionary<string, string>() {
                {
                "foundationmissing", "Фундамент не найден!"
            },


                {
                "buildingBrockmissing", "Создание местоположение разрешено только на строительных блоках"
            }
            ,
            {
                "InDuel", "Вы на Дуэли. Телепорт запрещен!"
            },
            {
                "InDuelTarget", "Игрок на Дуэли. Телепорт запрещен!"
            }
            ,
            {
                "foundationmissingR", "Фундамент не найден, местоположение было удалено!"
            }
            ,
            {
                "buildingBrockmissingR", "Строительный блок не найден, местоположение было удалено!"
            }
            ,
            {
                "playerisyou", "Нельзя отправлять телепорт самому себе!"
            }
            , {
                "maxhomes", "У вас максимальное кол-во местоположений!"
            }
            , {
                "homeexist", "Такое местоположение уже существует!"
            }
            , {
                "homesucces", "Местоположение {0} успешно установлено!"
            }
            , {
                "sethomeArgsError", "Для установки местоположения используйте /sethome ИМЯ"
            }
            , {
                "settpArgsError", "Для установки местоположения используйте /tpl add ИМЯ"
            }
            , {
                "homeArgsError", "Для телепортации на местоположение используйте /home ИМЯ"
            }
            , {
                "tpArgsError", "Для телепортации на местоположение используйте /tpl ИМЯ"
            }
            , {
                "tpError", "Запрещено! Вы в очереди на телепортацию"
            }
            , {
                "homenotexist", "Местоположение с таким названием не найдено!"
            }
            , {
                "homequeue", "Телепортация на {0} будет через {1}"
            }
            , {
                "tpwounded", "Вы получили ранение! Телепортация отменена!"
            }
            , {
                "tphomesuccess", "Вы телепортированы домой!"
            }
            , {
                "tplsuccess", "Вы успешно телепортированы!"
            }
            , {
                "tptpsuccess", "Вы телепортированы на указаное место!"
            }
            , {
                "homesmissing", "У вас нет доступных местоположений!"
            }
            , {
                "TPLmissing", "Для вас нет доступных местоположений!"
            }
            , {
                "TPLList", "Доступные точки местоположения:\n{0}"
            }
            , {
                "removehomeArgsError", "Для удаления местоположения используйте /removehome ИМЯ"
            }
            , {
                "removetpArgsError", "Для удаления местоположения используйте /tpl remove ИМЯ"
            }
            , {
                "removehomesuccess", "Местоположение {0} успешно удалено"
            }
            , {
                "sleepingbagmissing", "Спальный мешок не найден, местоположение удалено!"
            },
            {
                "sleepingbugbuildblock", "Вы не авторизованы в билде точки телепортации, местоположение удалено!"
            }
            , {
                "tprArgsError", "Для отправки запроса на телепортация используйте /tpr НИК"
            }
            , {
                "playermissing", "Игрок не найден"
            }
            , {
                "PlayerNotFriend", "Игрок не являеться Вашим другом! Телепорт запрещен!"
            }
            , {
                "tpspecError", "Не правильно введена команда. Используйте: /tpspec НИК"
            }
            , {
                "playermissingOff", "Игрок не в сети"
            }
            , {
                "playermissingOrDeath", "Игрок не найден, или он мёртв"
            }
            , {
                "playerItsYou", "Нельзя следить за самым собой"
            }
            , {
                " playerItsSpec", "Игрок уже за кем то наблюдает"
            }
            , {
                "tprrequestsuccess", "Запрос {0} успешно отправлен"
            }
            , {
                "tprpending", "{0} отправил вам запрос на телепортацию\nЧтобы принять используйте /tpa\nЧтобы отказаться используйте /tpc"
            }
            , {
                "tpanotexist", "У вас нет активных запросов на телепортацию!"
            }
            , {
                "tpqueue", "{0} принял ваш запрос на телепортацию\nВы будете телепортированы через {1}"
            }
            , {
                "tpc", "Телепортация успешно отменена!"
            }
            , {
                "tpctarget", "{0} отменил телепортацию!"
            }
            , {
                "tpplayersuccess", "Вы успешно телепортировались к {0}"
            }
            , {
                "tpasuccess", "Вы приняли запрос телепортации от {0}\nОн будет телепортирован через {1}"
            }
            , {
                "tppendingcanceled", "Запрос телепортации отменён"
            }
            , {
                "tpcupboard", "Телепортация в зоне действия чужого шкафа запрещена!"
            }, {
                "tpcupboardTarget", "Вы или игрок находитесь в зоне действия чужого шкафа!"
            }
            , {
                "tphomecupboard", "Телепортация домой в зоне действия чужого шкафа запрещена!"
            }
            , {
                "tpacupboard", "Принятие телепортации в зоне действия чужого шкафа запрещена!"
            }
            , {
                "sethomecupboard", "Установка местоположения в зоне действия чужого шкафа запрещена!"
            }
            , {
                "tpacanceled", "Вы не ответили на запрос."
            }
            , {
                "tpkd", "Телепортация на перезарядке!\nОсталось {0}"
            }
            , {
                "tpWoundedTarget", "Игрок ранен. Телепортация отменена!"
            }
            , {
                "woundedAction", "Вы ранены!"
            }
            , {
                "coldplayer", "Вам холодно!"
            }
            , {
                "Radiation", "Вы облучены радиацией!"
            }
            , {
                "sethomeBlock", "Нельзя использовать /sethome слишком часто, попробуйте позже!"
            }
            , {
                "foundationowner", "Нельзя использовать /sethome не на своих строениях!"
            }
            , {
                "foundationownerFC", "Создатель обьекта не являеться вашим соклановцем или другом, /sethome запрещен"
            }
            , {
                "homeslist", "Доступное количество местоположений: {0}\n{1}"
            }
            , {
                "tplist", "Ваши сохраненные метоположения:\n{0}"
            }
            , {
                "PlayerIsOnCargoShip", "Вы не можете телепортироваться на грузовом корабле."
            }
            , {
                "PlayerIsOnHotAirBalloon", "Вы не можете телепортироваться на воздушном шаре."
            }
            , {
                "InsideInFoundation", "Вы не можете устанавливать местоположение находясь в фундаменте"
            }
            , {
                "InsideInFoundationTP", "Телепортация запрещена, местоположение находится в фундаменте"
            }
            ,{
                "TPAPerm", "У Вас нету права использовать эту команду"
            },
            {
                "TPAEnabled", "Вы успешно <color=#FDAE37>включили</color> автопринятие запроса на телепорт\n{0}"
            },
             {
                "TPADisable", "Вы успешно <color=#FDAE37>отключили</color> автопринятие запроса на телепорт"
            },
            {
                "TPAEnabledInfo", "Добавление нового игрока <color=#FDAE37>/atp add Name/SteamID</color>\nУдаление игрока <color=#FDAE37>/atp remove Name</color>\nСписок игроков <color=#FDAE37>/apt list</color>"
            },
            {
                "TPAEnabledList", "Список игроков для каких у Вас включен автоматический приём телепорта:\n{0}"
            },
            {
                "TPAEListNotFound", "Вы пока еще не добавили не одного игрока в список, используйте <color=#FDAE37>/atp add Name/SteamID</color>"
            },
            {
                "TPAEAddError", "Вы не указали игрока, используйте <color=#FDAE37>/atp add Name/SteamID</color>"
            },{
                "TPARemoveError", "Вы не указали игрока, используйте <color=#FDAE37>/atp remove Name</color>"
            },
            {
                "TPARemoveNotFound", "Игрока <color=#FDAE37>{0}</color> нету в списке, используйте <color=#FDAE37>/atp remove Name</color>"
            },
            {
                "TPAEAddPlayerNotFound", "Игрок не найден! Попробуйте уточнить <color=#FDAE37>имя</color>"
            },
            {
                "TPAEAddSuccess", "Игрок <color=#FDAE37>{0}</color> успешно добавлен в список"
            },
            {
                "TPAEAddContains", "Игрок <color=#FDAE37>{0}</color> уже добавлен в список"
            },
            {
                "TPAERemoveSuccess", "Игрок <color=#FDAE37>{0}</color> успешно удален со списка"
            },
            {
                "TPAEAddPlayers", "Найдено <color=#FDAE37>несколько</color> игроков с похожим ником:\n{0}"
            },
            {
                "TPASuccess", "Вы <color=#FDAE37>автоматически</color> приняли запрос на телепортацию так как у вас игрок в списке разрешенных."
            },
            {
                "TeleportaCancelHeli", "Телепорт отменен, кто то из игроков использует транспортное средство."
            },
            {
            "TimerTextPlayer1", "ТЕЛЕПОРТ АКТИВИРОВАН: ОСТАЛОСЬ ЖДАТЬ - <b>{0}</b>"
            },
            {
                "TimerTextPlayer2", "ТЕЛЕПОРТ К ВАМ: ОЖИДАНИЕ ОТВЕТА - <b>{0}</b>"
            },
            {
                "PendingTextPlayer1", "ТЕЛЕПОРТ ОТПРАВЛЕН: ОЖИДАНИЕ ОТВЕТА - <b>{0}</b>"
            },
            {
                "PendingTextPlayer2", "ОСТАЛОСЬ ЖДАТЬ - <b>{0}</b>"
            }
        };
        #region TPAcceptUI
        void CreateUpdateUI(BasePlayer player, DVTeleportation.TP teleport, string langMessage = "PendingTextPlayer1")
        {
            CuiHelper.DestroyUi(player, "Teleport");
            CuiElementContainer container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.3447913 0.112037", AnchorMax = "0.640625 0.1393229", OffsetMax = "0 0" },
                Image = { Color = "1 1 1 0.15" }
            }, "Hud", "Teleport");
            container.Add(new CuiElement
            {
                Parent = "Teleport",
                Name = "Teleport.Update",
                Components =
                {
                    new CuiImageComponent { Color = "0.84 0.25 0.78 0.95" },
                    new CuiRectTransformComponent {AnchorMin = $"0 0", AnchorMax = $"{(float) (teleport.totalSeconds - (teleport.totalSeconds - teleport.seconds)) / teleport.totalSeconds} 1", OffsetMin = "0 0", OffsetMax = "0 0"},
                }
            });
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Text = { Text = string.Format(Messages[langMessage], GetFormatTime(TimeSpan.FromSeconds(teleport.totalSeconds - (teleport.totalSeconds - teleport.seconds)))), Font = "robotocondensed-regular.ttf", Color = "1 1 1 0.9", FontSize = 14, Align = TextAnchor.MiddleCenter }
            }, "Teleport", "Teleport" + ".Info");
            CuiHelper.AddUi(player, container);
        }
        private string GetFormatTime(TimeSpan timespan)
        {
            return string.Format(timespan.TotalHours >= 1 ? "{2:00}:{0:00}:{1:00}" : "{0:00}:{1:00}", timespan.Minutes, timespan.Seconds, System.Math.Floor(timespan.TotalHours));
        }

        public static string PARENT_TELEPORT = "PARENT_DVTeleportation_UI";
        void DVTeleportationAcceptUI(BasePlayer target, string TprName)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(target, PARENT_TELEPORT);

            container.Add(new CuiPanel
            {
                // RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "-400 16", OffsetMax = "-210 98" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "130 18", OffsetMax = "350 98" },
                Image = { Color = HexToRustFormat("#000000"), Material = "assets/content/ui/uibackgroundblur.mat" } //  //"#d02424B1" "#544E44FF"
            }, "Overlay", PARENT_TELEPORT);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.01 0.02", AnchorMax = "0.99 0.75" },
                Image = { Color = HexToRustFormat("#F65050"), Material = "assets/content/ui/uibackgroundblur.mat" } // , #bdb4ab #4b98d0
            }, PARENT_TELEPORT, "TWO_PANEL");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.009999931 0.7777777", AnchorMax = "1 1" },
                Text = { Text = $"<size=12><b>Запрос от {TprName}</b></size>", Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter }
            }, PARENT_TELEPORT);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.5814307", AnchorMax = "1 1" },
                Text = { Text = $"<size=20><b>ПРИНЯТЬ ТЕЛЕПОРТ?</b></size>", Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter, Color = HexToRustFormat("#FFFFFFFF") }
            }, "TWO_PANEL");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.03079109 0.09436831", AnchorMax = "0.4158611 0.4517729" },
                Button = { Close = PARENT_TELEPORT, Command = "chat.say /tpa", Color = HexToRustFormat("#8b3131FF"), Material = "assets/content/ui/uibackgroundblur.mat" },
                Text = { Text = "<color=#FFFFFF><b>☑ ПРИНЯТЬ</b></color>", Align = TextAnchor.MiddleCenter }
            }, "TWO_PANEL");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5857509 0.09436831", AnchorMax = "0.9708213 0.4517729" },
                Button = { Close = PARENT_TELEPORT, Command = "chat.say /tpc", Color = HexToRustFormat("#d02424FF"), Material = "assets/content/ui/uibackgroundblur.mat" },
                Text = { Text = "<color=#FFFFFF><b>☒ ОТМЕНА</b></color>", Align = TextAnchor.MiddleCenter } //#FF1400FF //#FF2E00FF
            }, "TWO_PANEL");

            CuiHelper.AddUi(target, container);
        }
        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            UnityEngine.Color color = new Color32(r, g, b, a);

            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }
        #endregion
    }
}

// --- End of file: DVTeleportation.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Elevators.cs ---
// --- Original Local Path: Elevators.cs ---


using System.Collections.Generic;
using System;
using System.Reflection;
using System.Data;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Logging;
using Oxide.Core.Plugins;
using Rust;

namespace Oxide.Plugins
{
    [Info("Elevators", "Reneb", "1.0.1")]
    class Elevators : RustPlugin
    {
        [PluginReference]
        Plugin Waypoints;

        private static FieldInfo serverinput;
        StoredData storedData;
        static Hash<string, ElevatorInfo> elevators = new Hash<string, ElevatorInfo>();
        static Dictionary<string, string> nameToBlockPrefab = new Dictionary<string, string>();
        static List<Elevator> spawnedElevators = new List<Elevator>();
        static List<BaseCombatEntity> protectedBlock = new List<BaseCombatEntity>();
        public DamageTypeList emptyDamageType;
        // CACHED
        object closestEnt;
        Vector3 closestHitpoint;
        Quaternion currentRot;

        class StoredData
        {
            public HashSet<ElevatorInfo> Elevators = new HashSet<ElevatorInfo>();

            public StoredData()
            {
            }
        }
        void SaveData()
        {
            Interface.GetMod().DataFileSystem.WriteObject("Elevators", storedData);
        }
        void LoadData()
        {
            elevators.Clear();
            try
            {
                storedData = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("Elevators");
            }
            catch
            {
                storedData = new StoredData();
            }
            foreach (var elevator in storedData.Elevators)
                elevators[elevator.Name] = elevator;
        }
        public class ElevatorInfo
        {
            public string Name;
            public string PrefabName;
            public string WaypointsName;
            public string rx;
            public string ry;
            public string rz;
            public string rw;
            public string Grade;

            public ElevatorInfo()
            {

            }
            public ElevatorInfo(BuildingBlock block, string name, string waypoints)
            {
                rx = block.transform.rotation.x.ToString();
                ry = block.transform.rotation.y.ToString();
                rz = block.transform.rotation.z.ToString();
                rw = block.transform.rotation.w.ToString();
                Grade = GradeToNum(block.grade).ToString();
                this.Name = name;
                this.WaypointsName = waypoints;
                this.PrefabName = block.blockDefinition.fullName;
            }
        }
        ////////////////////////////////////////////////////// 
        ///  class WaypointInfo
        ///  Waypoint information, position & speed
        ///  public => will be saved in the data file
        ///  non public => won't be saved in the data file
        //////////////////////////////////////////////////////
        public class WaypointInfo
        {
            public string x;
            public string y;
            public string z;
            public string s;
            Vector3 position;
            float speed;

            public WaypointInfo(Vector3 position, float speed)
            {
                x = position.x.ToString();
                y = position.y.ToString();
                z = position.z.ToString();
                s = speed.ToString();

                this.position = position;
                this.speed = speed;
            }

            public Vector3 GetPosition()
            {
                if (position == Vector3.zero)
                    position = new Vector3(float.Parse(x), float.Parse(y), float.Parse(z));
                return position;
            }
            public float GetSpeed()
            {
                speed = Convert.ToSingle(s);
                return speed;
            }
        }
        /////////////////////////////////////////////////////
        ///  GetGrade(int lvl)
        ///  Convert grade number written by the players into the BuildingGrade.Enum used by rust
        /////////////////////////////////////////////////////
        static BuildingGrade.Enum NumToGrade(int lvl)
        {
            if (lvl == 0)
                return BuildingGrade.Enum.Twigs;
            else if (lvl == 1)
                return BuildingGrade.Enum.Wood;
            else if (lvl == 2)
                return BuildingGrade.Enum.Stone;
            else if (lvl == 3)
                return BuildingGrade.Enum.Metal;
            return BuildingGrade.Enum.TopTier;
        }
        static int GradeToNum(BuildingGrade.Enum lvl)
        {
            if (lvl == BuildingGrade.Enum.Twigs)
                return 0;
            else if (lvl == BuildingGrade.Enum.Wood)
                return 1;
            else if (lvl == BuildingGrade.Enum.Stone)
                return 2;
            else if (lvl == BuildingGrade.Enum.Metal)
                return 3;
            return 4;
        }

        public class Elevator : MonoBehaviour
        {
            public ElevatorInfo info;
            public List<WaypointInfo> waypoints;
            public TriggerBase trigger;
            public BuildingBlock block;
            public UnityEngine.Quaternion rotation;


            public Vector3 StartPos = new Vector3(0f, 0f, 0f);
            public Vector3 EndPos = new Vector3(0f, 0f, 0f);
            public Vector3 nextPos = new Vector3(0f, 0f, 0f);
            public float waypointDone = 0f;
            public float secondsTaken = 0f;
            public float secondsToTake = 0f;
            public float speed = 4f;
            public int currentWaypoint = 0;

            public List<BaseEntity> collidingPlayers = new List<BaseEntity>();

            public Elevator()
            {

            }

            public void SetInfo(ElevatorInfo info)
            {
               
                this.info = info;
                var cwaypoints = Interface.CallHook("GetWaypointsList", this.info.WaypointsName);
                if (cwaypoints == null)
                {
                    Debug.Log(string.Format("{0} was destroyed, informations are invalid. Did you set waypoints? or a PrefabName?", info.Name));
                    GameObject.Destroy(this);
                    return;
                }
                this.waypoints = new List<WaypointInfo>();
                foreach (var cwaypoint in (List<object>)cwaypoints)
                {
                    foreach (KeyValuePair<Vector3, float> pair in (Dictionary<Vector3,float>)cwaypoint)
                    {
                        this.waypoints.Add(new WaypointInfo(pair.Key, pair.Value));
                    }
                }
                if (this.waypoints.Count < 2)
                {
                    Debug.Log(string.Format("{0} waypoints were detected for {1}. Needs at least 2 waypoints. Destroying.", this.waypoints.Count.ToString(), info.Name));
                    GameObject.Destroy(this);
                    return;
                }
                this.rotation = new UnityEngine.Quaternion(Convert.ToSingle(info.rx), Convert.ToSingle(info.ry), Convert.ToSingle(info.rz), Convert.ToSingle(info.rw));
                this.block = CreateBuildingBlock(this.info.PrefabName, this.waypoints[0].GetPosition(), this.rotation, Convert.ToInt32(this.info.Grade));
                if(this.block == null)
                {
                    Debug.Log(string.Format("Something went wrong, couldn't create the BuildingBlock for {0}", info.Name));
                    GameObject.Destroy(this);
                    return;
                }
                protectedBlock.Add(this.block.GetComponent<BaseCombatEntity>());
                trigger = block.GetComponentInChildren<MeshCollider>().gameObject.AddComponent<TriggerBase>();
                trigger.gameObject.name = "Elevator";
                var newlayermask = new UnityEngine.LayerMask();
                newlayermask.value = 133120;   
                trigger.interestLayers = newlayermask;
                trigger.gameObject.layer = UnityEngine.LayerMask.NameToLayer("Trigger");
                spawnedElevators.Add(this);
            }
            void Awake()
            {
                enabled = false;
            } 
            void OnDestroy()
            {
                if (this.block != null)
                {
                    protectedBlock.Remove(this.block.GetComponent<BaseCombatEntity>());
                    this.block.KillMessage();
                }
                if (this.trigger != null) GameObject.Destroy(this.trigger);
            } 
            void FixedUpdate()
            {
                if (secondsTaken == 0f) GetNextPath();
                if (!enabled) return;
                if (StartPos != EndPos) Execute_Move();
                if (waypointDone >= 1f) secondsTaken = 0f;
            }
            void Execute_Move()
            {
                secondsTaken += Time.deltaTime;
                waypointDone = Mathf.InverseLerp(0f, secondsToTake, secondsTaken);
                nextPos = Vector3.Lerp(StartPos, EndPos, waypointDone);
                block.transform.position = nextPos;
                block.SendNetworkUpdate(BasePlayer.NetworkQueue.UpdateDistance);
            }
            void GetNextPath()
            {
                if (currentWaypoint + 1 >= waypoints.Count)
                    currentWaypoint = -1;
                currentWaypoint++;
                if(currentWaypoint == 1 && collidingPlayers.Count==0)
                {
                    currentWaypoint = 0;
                    enabled = false;
                    return;
                }
                SetMovementPoint(block.transform.position, waypoints[currentWaypoint].GetPosition(), waypoints[currentWaypoint].GetSpeed());
                if (block.transform.position == waypoints[currentWaypoint].GetPosition()) { DeactivateMovement(); Invoke("ActivateMovement", waypoints[currentWaypoint].GetSpeed()); return; }
            }
            public void SetMovementPoint(Vector3 startpos, Vector3 endpos, float s)
            { 
                StartPos = startpos;
                EndPos = endpos;
                if (StartPos != EndPos)
                    secondsToTake = Vector3.Distance(EndPos, StartPos) / s;
                secondsTaken = 0f;
                waypointDone = 0f;
            }  
            public void ActivateMovement()
            {
                enabled = true;
            }
            public void DeactivateMovement()
            {
               enabled = false;
            }
        }
        void OnEntityEnter(TriggerBase triggerbase, BaseEntity entity)
        {
            if (triggerbase == null || entity == null) return;
            if (triggerbase.gameObject.name != "Elevator") return;
            foreach (Elevator ele in spawnedElevators)
            {
                if (ele.trigger == triggerbase)
                {
                    if (!ele.collidingPlayers.Contains(entity))
                        ele.collidingPlayers.Add(entity);
                    ele.ActivateMovement();
                } 
            }
        }
        void OnEntityLeave(TriggerBase triggerbase, BaseEntity entity)
        {
            if (triggerbase == null || entity == null) return;
            if (triggerbase.gameObject.name != "Elevator") return;
            foreach (Elevator ele in spawnedElevators)
            {
                if (ele.trigger == triggerbase)
                {
                    if (ele.collidingPlayers.Contains(entity))
                        ele.collidingPlayers.Remove(entity);
                }
            }
        }
        void NewElevator(ElevatorInfo info)
        {
            var objects = GameObject.FindObjectsOfType(typeof(Elevator));
            if (objects != null)
                foreach (Elevator gameObj in objects)
                {
                    if(gameObj.info.Name == info.Name)
                    {
                        GameObject.Destroy(gameObj);
                    }
                }
            GameObject gameobject = new UnityEngine.GameObject();
            gameobject.AddComponent<Elevator>();
            gameobject.GetComponent<Elevator>().SetInfo(info);
        }
        void Loaded()
        {
            emptyDamageType = new DamageTypeList();
            serverinput = typeof(BasePlayer).GetField("serverInput", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            LoadData();
        } 
        void Unload() 
        {
            var objects = GameObject.FindObjectsOfType(typeof(Elevator));
            if (objects != null)
                foreach (Elevator gameObj in objects)
                {
                    GameObject.Destroy(gameObj);
                } 
            foreach (Elevator ele in spawnedElevators)
            {
                if(ele != null) 
                    GameObject.Destroy(ele.gameObject);
            }                    
        }
        void OnServerInitialized()
        {
            foreach (KeyValuePair<string, ElevatorInfo> pair in elevators)
            {
                NewElevator(pair.Value);
            }
        }
        static BuildingBlock CreateBuildingBlock(string prefabname, Vector3 position, Quaternion rotation, int grade)
        {
            UnityEngine.GameObject prefab = GameManager.server.FindPrefab(prefabname);
            if (prefab == null) return null;
            UnityEngine.GameObject build = UnityEngine.Object.Instantiate(prefab);
            if (build == null) return null;
            BuildingBlock block = build.GetComponent<BuildingBlock>();
            if (block == null) return null;
            block.transform.position = position;
            block.transform.rotation = rotation;
            block.gameObject.SetActive(true);
            block.blockDefinition = PrefabAttribute.server.Find<Construction>(block.prefabID);
            block.Spawn(true); 
            block.SetGrade(NumToGrade(grade));
            block.health = block.MaxHealth();
            block.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            return block;
        }
        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if(protectedBlock.Contains(entity))
            {
                CancelDamage(info);
            }
        }
        void CancelDamage(HitInfo hitinfo)
        {
            hitinfo.damageTypes = emptyDamageType;
            hitinfo.DoHitEffects = false;
            hitinfo.HitMaterial = 0;
        }
        bool hasPermission(BasePlayer player)
        {
            if (player.net.connection.authLevel > 1) return true;
            return false;
        }
        static bool TryGetPlayerView(BasePlayer player, out Quaternion viewAngle)
        {
            viewAngle = new Quaternion(0f, 0f, 0f, 0f);
            var input = serverinput.GetValue(player) as InputState;
            if (input == null)
                return false;
            if (input.current == null)
                return false;

            viewAngle = Quaternion.Euler(input.current.aimAngles);
            return true;
        }
        /////////////////////////////////////////////////////
        ///  TryGetClosestRayPoint(Vector3 sourcePos, Quaternion sourceDir, out object closestEnt, out Vector3 closestHitpoint)
        ///  Get the closest entity that the player is looking at
        /////////////////////////////////////////////////////
        bool TryGetClosestRayPoint(Vector3 sourcePos, Quaternion sourceDir, out object closestEnt, out Vector3 closestHitpoint)
        {
            Vector3 sourceEye = sourcePos + new Vector3(0f, 1.5f, 0f);
            UnityEngine.Ray ray = new UnityEngine.Ray(sourceEye, sourceDir * Vector3.forward);

            var hits = UnityEngine.Physics.RaycastAll(ray);
            float closestdist = 999999f;
            closestHitpoint = sourcePos;
            closestEnt = false;
            foreach (var hit in hits)
            {
                if (hit.collider.GetComponentInParent<TriggerBase>() == null)
                {
                    if (hit.distance < closestdist)
                    {
                        closestdist = hit.distance;
                        closestEnt = hit.collider;
                        closestHitpoint = hit.point;
                    }
                }
            }
            if (closestEnt is bool)
                return false;
            return true;
        }
        [ChatCommand("elevator_add")]
        void cmdChatElevatorAdd(BasePlayer player, string command, string[] args)
        {
            if (!hasPermission(player)) { SendReply(player, "You don't have access to this command"); return; }
            if (args.Length < 2)
            { 
                SendReply(player, "/elevator_add NAME WAYPOINTS");
                return;
            } 
            var waypoints = Waypoints.Call("GetWaypointsList", args[1]);
            if(waypoints == null)
            {
                SendReply(player, "No waypoints with this name exist");
                return;
            }
            if( ((List<object>)waypoints).Count < 2)
            {
                SendReply(player, "To create an elevator you need at least 2 waypoints");
                return;
            }
            if (!TryGetPlayerView(player, out currentRot)) return;
            if (!TryGetClosestRayPoint(player.transform.position, currentRot, out closestEnt, out closestHitpoint)) return;
            Debug.Log(closestEnt.ToString());
            BuildingBlock block = ((Collider)closestEnt).GetComponentInParent<BuildingBlock>();
            if (block == null) 
            {
                SendReply(player, "What you are looking at is not a building block");
                return;
            }
            var newelevatorinfo = new ElevatorInfo(block, args[0], args[1]);
            if (elevators[newelevatorinfo.Name] != null) storedData.Elevators.Remove(elevators[newelevatorinfo.Name]);
            elevators[newelevatorinfo.Name] = newelevatorinfo;
            storedData.Elevators.Add(elevators[newelevatorinfo.Name]);
            SaveData(); 
            SendReply(player, "You've successfully created a new elevator");
            NewElevator(elevators[newelevatorinfo.Name]);
        }

        [ChatCommand("elevator_reset")]
        void cmdChatElevatorReset(BasePlayer player, string command, string[] args)
        {
            if (!hasPermission(player)) { SendReply(player, "You don't have access to this command"); return; }
            foreach (KeyValuePair<string, ElevatorInfo> pair in elevators)
            {
                storedData.Elevators.Remove(elevators[pair.Key]);
            }
            elevators.Clear();
            SaveData();
            spawnedElevators.Clear();
            SendReply(player, "All elevators were removed");
            Unload();
        }

        [ChatCommand("elevator_remove")]
        void cmdChatElevatorRemove(BasePlayer player, string command, string[] args)
        {
            if (!hasPermission(player)) { SendReply(player, "You don't have access to this command"); return; }
            if(args.Length == 0)
            {
                SendReply(player, "/elevator_remove NAME"); return;
            }
            if(elevators[args[0]] == null)
            {
                SendReply(player, "This elevator doesn't exist"); return;
            }
            foreach (Elevator ele in spawnedElevators)
            {
                if (ele.info.Name == elevators[args[0]].Name)
                    GameObject.Destroy(ele.gameObject);
            }
            storedData.Elevators.Remove(elevators[args[0]]);
            elevators[args[0]] = null;
            SendReply(player, string.Format("Elevator named {0} was deleted",args[0]));
            SaveData();
        }

        [ChatCommand("elevator_list")]
        void cmdChatElevatorList(BasePlayer player, string command, string[] args)
        {
            if (!hasPermission(player)) { SendReply(player, "You don't have access to this command"); return; }
            if(elevators.Count == 0)
            {
                SendReply(player, "You don't have any elevators");
                return;
            }
            foreach (KeyValuePair<string, ElevatorInfo> pair in elevators)
            {
                SendReply(player, string.Format("{0} - {1}", pair.Key, pair.Value.PrefabName));
            }

        }
    }
}


// --- End of file: Elevators.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Teleportation.cs ---
// --- Original Local Path: Teleportation.cs ---

﻿using Oxide.Core;
using System.Collections.Generic;
using System.Linq;
using System;
using System.Reflection;
using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;
using Oxide.Core.Libraries;
using System.IO;
namespace Oxide.Plugins
{
    [Info("Teleportation", "OxideBro/Ryamkk", "1.2.2")]

    class Teleportation : RustPlugin
    {
        [PluginReference]
        Plugin Clans;
        [PluginReference]
        Plugin Friends;
        readonly MethodInfo entitySnapshot = typeof(BasePlayer).GetMethod("SendEntitySnapshot", BindingFlags.Instance | BindingFlags.NonPublic);
        Dictionary<ulong, Vector3> lastPositions = new Dictionary<ulong, Vector3>();
        Dictionary<BasePlayer, int> spectatingPlayers = new Dictionary<BasePlayer, int>();
        bool IsClanMember(ulong playerID, ulong targetID)
        {
            return (bool)(Clans?.Call("HasFriend", playerID, targetID) ?? false);
        }

        bool IsFriends(ulong playerID, ulong friendId)
        {
            return (bool)(Friends?.Call("AreFriends", playerID, friendId) ?? false);
        }

        #region CLASSES

        class TP
        {
            public BasePlayer Player;
            public BasePlayer Player2;
            public Vector3 pos;
            public int seconds;

            public TP(BasePlayer player, Vector3 pos, int seconds, BasePlayer player2 = null)
            {
                this.Player = player;
                this.pos = pos;
                this.seconds = seconds;
                this.Player2 = player2;
            }
        }

        #endregion
			
        #region CONFIGURATION
        const string TPADMIN = "teleportation.admin";
        Dictionary<string, int> homelimitPerms;
		Dictionary<string, int> teleportSecsPerms;
        Dictionary<string, int> tpkdPerms;
        Dictionary<string, int> tpkdhomePerms;
		int RadiationBlockTP;
	    int ColdBlockTP;
		int BleedingBlockTP;
		int CraftBlockTP;
		int homelimitDefault;
		int tpkdDefault;
		int tpkdhomeDefault;
        int teleportSecsDefault;
        int resetPendingTime;
		int CraftBlockHome;
		int RadiationBlockHome;
		int BleedingBlockHome;
		int ColdBlockHome;
		//int SleepingBagSkin;
	    bool CanSwimmingTP;
		bool CanCraftTP;
		bool CanAliveTP;
		bool CanRadiationTP;
		bool CanBleedingTP;
		bool CanWoundedTP;
		bool CanColdTP;
        bool restrictCupboard;
		bool enabledTP;
		bool enabledHome;
        bool homecupboard;
        bool adminsLogs;
        bool foundationOwner;
        bool foundationOwnerFC;
        bool restrictTPRCupboard;
        bool foundationEx;
        bool wipedData;
        bool createSleepingBug;
	    bool CanWoundedHome;
		bool CanColdHome;
	    bool CanSwimmingHome;
		bool CanCraftHome;
	    bool CanAliveHome;
		bool CanRadiationHome;
		bool CanBleedingHome;
        string EffectPrefab1;
        string EffectPrefab;
		string SleepingBagName;
        static DynamicConfigFile config;

        void WipeData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("Teleportation/Homes", new Dictionary<string, FileInfo>());
            Interface.Oxide.DataFileSystem.WriteObject("Teleportation/AdminTpSave", new Dictionary<string, FileInfo>());
            SaveData();
            Interface.Oxide.ReloadPlugin(Title);
        }

        protected override void LoadDefaultConfig()
        {
			GetVariable(Config, "Общие настройки", "A. Логировать использование команд для администраторов", out adminsLogs, true);
			GetVariable(Config, "Общие настройки", "B. Звук предупреждения (пустое поле = звук отключен)", out EffectPrefab, "assets/prefabs/locks/keypad/effects/lock.code.denied.prefab");
            GetVariable(Config, "Общие настройки", "C. Звук уведомления при получение запроса на телепорт (пустое поле = звук отключен)", out EffectPrefab1, "assets/prefabs/locks/keypad/effects/lock.code.unlock.prefab");
			GetVariable(Config, "Общие настройки", "D. Автоматический вайп данных при генерации новой карты", out wipedData, true);
			
			GetVariable(Config, "Телепортация домой", "A. Разрешить телепортацию", out enabledHome, true);
			GetVariable(Config, "Телепортация домой", "B. Запрещать отправлять запрос на телепортацию в воде", out CanSwimmingHome, true);
			GetVariable(Config, "Телепортация домой", "C. Запрещать отправлять запрос на телепортацию во время крафта", out CanCraftHome, true);
			GetVariable(Config, "Телепортация домой", "D. Разрешённое количество предметов на крафте", out CraftBlockHome, 0);
			GetVariable(Config, "Телепортация домой", "E. Отменять телепортацию при смерте", out CanAliveHome, true);
			GetVariable(Config, "Телепортация домой", "F. Запрещать отправлять запрос на телепортацию во время облечения радиацией", out CanRadiationHome, true);
			GetVariable(Config, "Телепортация домой", "G. Разрешённое радиационное облучения для телепортации", out RadiationBlockHome, 5);
			GetVariable(Config, "Телепортация домой", "H. Запрещать отправлять запрос на телепортацию во время кровотечения", out CanBleedingHome, true);
			GetVariable(Config, "Телепортация домой", "I. Разрешённый процент кровотечения для телепортации", out BleedingBlockHome, 0);
			GetVariable(Config, "Телепортация домой", "J. Отменять телепортацияю если игрок получил ранения", out CanWoundedHome, true);
			GetVariable(Config, "Телепортация домой", "K. Запрещать отправлять запрос на телепортацию если игроку холодно", out CanColdHome, true);
			GetVariable(Config, "Телепортация домой", "L. Разрешённый проект замерзания для телепортации", out ColdBlockHome, 3);
			GetVariable(Config, "Телепортация домой", "M. Запрещать отправлять запрос на телепортацию в зоне действия чужого шкафа", out homecupboard, true);
            GetVariable(Config, "Телепортация домой", "N. Разрешать сохранять местоположение только на фундаменте", out foundationEx, true);
            GetVariable(Config, "Телепортация домой", "O. Создавать объект при сохранении местоположения", out createSleepingBug, true);
			GetVariable(Config, "Телепортация домой", "P. Название создаваемого объекта", out SleepingBagName, "Sleeping Bag");
			//GetVariable(Config, "Телепортация домой", "Q. Скин создаваемого объекта", out SleepingBagName, 1174407153);
            GetVariable(Config, "Телепортация домой", "R. Запрещать сохранять местоположение если игрок не является владельцем фундамента", out foundationOwner, true);
            GetVariable(Config, "Телепортация домой", "S. Разрешать сохранять местоположение если игрок является другом или соклановцем владельца фундамента ", out foundationOwnerFC, true);
			GetVariable(Config, "Телепортация домой", "T. Ограничение на количество сохранённых местоположений", out homelimitDefault, 3);
			GetVariable(Config, "Телепортация домой", "U. Длительность перезарядки телепорта домой (в секундах)", out tpkdhomeDefault, 300);

            GetVariable(Config, "Телепортация к игроку", "A. Разрешить телепортацию", out enabledTP, true);
			GetVariable(Config, "Телепортация к игроку", "B. Время ответа на запрос телепортации (в секундах)", out resetPendingTime, 15);
			GetVariable(Config, "Телепортация к игроку", "C. Запрещать отправлять запрос на телепортацию в воде", out CanSwimmingTP, true);
			GetVariable(Config, "Телепортация к игроку", "D. Запрещать отправлять запрос на телепортацию во время крафта", out CanCraftTP, true);
			GetVariable(Config, "Телепортация к игроку", "E. Разрешённое количество предметов на крафте", out CraftBlockTP, 0);
			GetVariable(Config, "Телепортация к игроку", "F. Отменять телепортацию при смерте", out CanAliveTP, true);
			GetVariable(Config, "Телепортация к игроку", "G. Запрещать отправлять запрос на телепортацию во время облечения радиацией", out CanRadiationTP, true);
			GetVariable(Config, "Телепортация к игроку", "H. Разрешённое радиационное облучения для телепортации", out RadiationBlockTP, 5);
			GetVariable(Config, "Телепортация к игроку", "I. Запрещать отправлять запрос на телепортацию во время кровотечения", out CanBleedingTP, true);
			GetVariable(Config, "Телепортация к игроку", "J. Разрешённый процент кровотечения для телепортации", out BleedingBlockTP, 0);
			GetVariable(Config, "Телепортация к игроку", "K. Отменять телепортацияю если игрок получил ранения", out CanWoundedTP, true);
			GetVariable(Config, "Телепортация к игроку", "L. Запрещать отправлять запрос на телепортацию если игроку холодно", out CanColdTP, true);
			GetVariable(Config, "Телепортация к игроку", "M. Разрешённый проект замерзания для телепортации", out ColdBlockTP, 3);
			GetVariable(Config, "Телепортация к игроку", "N. Запрещать отправлять запрос на телепортацию в зоне действия чужого шкафа", out restrictTPRCupboard, true);
            GetVariable(Config, "Телепортация к игроку", "O. Запрещать принимать запрос на телепортацию в зоне действия чужого шкафа", out restrictCupboard, true);
			GetVariable(Config, "Телепортация к игроку", "P. Длительность задержки перед телепортацией (в секундах)", out teleportSecsDefault, 15);
			GetVariable(Config, "Телепортация к игроку", "Q. Длительность перезарядки телепорта (в секундах)", out tpkdDefault, 300);
			
            Config["Телепортация домой", "V. Ограничение на количество сохранённых местоположений с привилегией"] =
                homelimitPerms =
                    GetConfig("Ограничение на количество сохранённых местоположений с привилегией",
                            new Dictionary<string, object>()
							{
								{ "teleportation.vip", 4 },
								{ "teleportation.god", 5 },
								{ "teleportation.prem", 6 },
								{ "teleportation.elite", 7 },
								{ "teleportation.king", 5 },
								{ "teleportation.none", 999 }
							})
                        .ToDictionary(p => p.Key, p => Convert.ToInt32(p.Value));
            PermissionService.RegisterPermissions(this, homelimitPerms.Keys.ToList());
			
            Config["Телепортация к игроку", "R. Длительность задержки перед телепортацией с привилегией (в секундах)"] =
                teleportSecsPerms =
                    GetConfig("Длительность задержки перед телепортацией с привилегией (в секундах)",
                            new Dictionary<string, object>()
							{
								{ "teleportation.vip", 10 },
								{ "teleportation.god", 9 },
								{ "teleportation.prem", 8 },
								{ "teleportation.elite", 7 },
								{ "teleportation.king", 6 },
								{ "teleportation.none", 1 }
							})
                        .ToDictionary(p => p.Key, p => Convert.ToInt32(p.Value));
            PermissionService.RegisterPermissions(this, teleportSecsPerms.Keys.ToList());

            Config["Телепортация к игроку", "U. Длительность перезарядки телепорта с привилегией (в секундах)"] =
                tpkdPerms =
                    GetConfig("Длительность перезарядки телепорта с привилегией (в секундах)",
                            new Dictionary<string, object>()
							{
								{ "teleportation.vip", 250 },
								{ "teleportation.god", 200 },
								{ "teleportation.prem", 150 },
								{ "teleportation.elite", 100 },
								{ "teleportation.king", 50 },
								{ "teleportation.none", 1 }
							})
                        .ToDictionary(p => p.Key, p => Convert.ToInt32(p.Value));
            PermissionService.RegisterPermissions(this, tpkdPerms.Keys.ToList());
			
            Config["Телепортация домой", "W. Длительность перезарядки телепорта домой с привилегией (в секундах)"] =
                tpkdhomePerms =
                    GetConfig("Длительность перезарядки телепорта домой с привилегией (в секундах)",
                            new Dictionary<string, object>()
							{
								{ "teleportation.vip", 250 },
								{ "teleportation.god", 200 },
								{ "teleportation.prem", 150 },
								{ "teleportation.elite", 100 },
								{ "teleportation.king", 50 },
								{ "teleportation.none", 1 }
							})
                        .ToDictionary(p => p.Key, p => Convert.ToInt32(p.Value));
            PermissionService.RegisterPermissions(this, tpkdhomePerms.Keys.ToList());

            SaveConfig();
        }

        T GetConfig<T>(string name, T defaultValue)
            => Config[name] == null ? defaultValue : (T)Convert.ChangeType(Config[name], typeof(T));

        public static void GetVariable<T>(DynamicConfigFile config, string name, string Key, out T value, T defaultValue)
        {
            config[name, Key] = value = config[name, Key] == null ? defaultValue : (T)Convert.ChangeType(config[name, Key], typeof(T));
        }
        #endregion

        #region Permissions
        public static class PermissionService
        {
            public static Permission permission = Interface.GetMod().GetLibrary<Permission>();

            public static bool HasPermission(ulong uid, string permissionName)
            {
                return !string.IsNullOrEmpty(permissionName) && permission.UserHasPermission(uid.ToString(), permissionName);
            }

            public static void RegisterPermissions(Plugin owner, List<string> permissions)
            {
                if (owner == null) throw new ArgumentNullException("owner");
                if (permissions == null) throw new ArgumentNullException("commands");

                foreach (var permissionName in permissions.Where(permissionName => !permission.PermissionExists(permissionName)))
                {
                    permission.RegisterPermission(permissionName, owner);
                }
            }
        }
        #endregion

        #region FIELDS

        public BasePlayer FindBasePlayer(string nameOrUserId)
        {
            nameOrUserId = nameOrUserId.ToLower();
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (player.displayName.ToLower().Contains(nameOrUserId) || player.UserIDString == nameOrUserId)
                    return player;
            }
            foreach (var player in BasePlayer.sleepingPlayerList)
            {
                if (player.displayName.ToLower().Contains(nameOrUserId) || player.UserIDString == nameOrUserId)
                    return player;
            }
            return default(BasePlayer);
        }

        private FieldInfo SleepingBagUnlockTimeField = typeof(SleepingBag).GetField("unlockTime",
            BindingFlags.Instance | BindingFlags.NonPublic);

        private readonly int groundLayer = LayerMask.GetMask("Terrain", "World");
        private readonly int buildingMask = Rust.Layers.Server.Buildings;
        
        Dictionary<ulong, Dictionary<string, Vector3>> homes;
        Dictionary<ulong, Dictionary<string, Vector3>> tpsave;
        Dictionary<ulong, int> cooldownsTP = new Dictionary<ulong, int>();
        Dictionary<ulong, int> cooldownsHOME = new Dictionary<ulong, int>();
        List<TP> tpQueue = new List<TP>();
        List<TP> pendings = new List<TP>();
        List<ulong> sethomeBlock = new List<ulong>();

        #endregion

        #region COMMANDS

        [ChatCommand("sethome")]
        void cmdChatSetHome(BasePlayer player, string command, string[] args)
        {
			if (!enabledHome) return;
            var uid = player.userID;
            var pos = player.GetNetworkPosition();
            var foundation = GetFoundation(pos);
            var bulds = GetBuldings(pos);
            if (foundationEx)
            {
                if (foundation == null)
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["foundationmissing"]);
                    return;
                }
            }
            if (!foundationEx)
            {
                if (bulds == null)
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["foundationmissing"]);
                    return;
                }
            }
            if (args.Length != 1)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["sethomeArgsError"]);
                return;
            }
			if(CanSwimmingHome)
			{
				if (player.IsSwimming())
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Swimming"]);
                    return;
                }
			}
			if(CanCraftHome)
			{
				if (player.inventory.crafting.queue.Count > CraftBlockHome)
				{
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Craft"]);
                    return;
                }
			}
			if(CanAliveHome)
			{
				if (!player.IsAlive())
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Alive"]);
                    return;
                }
			}
			if(CanRadiationHome)
			{
				if (player.metabolism.radiation_poison.value > RadiationBlockHome)
                {
				    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Radiation"]);
                    return;
                }
			}
			if(CanBleedingHome)
			{
                if (player.metabolism.bleeding.value > BleedingBlockHome)
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Bleeding"]);
                    return;
                }
			}
			if(CanWoundedHome)
			{
                if (player.IsWounded())
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Wounded"]);
                    return;
                }
			}
			if(CanColdHome)
			{
			    if (player.metabolism.temperature.value < ColdBlockHome)
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Cold"]);
                    return;
                }
			}
            if (sethomeBlock.Contains(player.userID))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["sethomeBlock"]);
                return;
            }
            if (foundationOwnerFC && foundationOwner)
            {
                if (!foundationEx && bulds.OwnerID != uid)
                {
                    if (!IsFriends(bulds.OwnerID, player.userID) && !IsClanMember(bulds.OwnerID, player.userID))
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["foundationownerFC"]);
                        return;
                    }
                }
                if (foundationEx && foundation.OwnerID != uid)
                {
                    if (!IsFriends(foundation.OwnerID, player.userID) && !IsClanMember(foundation.OwnerID, player.userID))
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["foundationownerFC"]);
                        return;
                    }
                }

            }
            if (foundationOwner)
            {
                if (foundationEx && foundation.OwnerID != uid && foundationOwnerFC == (!IsFriends(foundation.OwnerID, player.userID) && !IsClanMember(foundation.OwnerID, player.userID)))
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["foundationowner"]);
                    return;
                }
                if (!foundationEx && bulds.OwnerID != uid && foundationOwnerFC == (!IsFriends(bulds.OwnerID, player.userID) && !IsClanMember(bulds.OwnerID, player.userID)))
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["foundationowner"]);
                    return;
                }
            }
            var name = args[0];

            SetHome(player, name);
        }

        [ChatCommand("removehome")]
        void cmdChatRemoveHome(BasePlayer player, string command, string[] args)
        {
			if (!enabledHome) return;
            if (args.Length != 1)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["removehomeArgsError"]);
                return;
            }
            if (!homes.ContainsKey(player.userID))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["homesmissing"]);
                return;
            }
            var name = args[0];
            var playerHomes = homes[player.userID];
            if (!playerHomes.ContainsKey(name))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["homenotexist"]);
                return;
            }
            foreach (var sleepingBag in SleepingBag.FindForPlayer(player.userID, true))
            {
                if (Vector3.Distance(sleepingBag.transform.position, playerHomes[name]) < 1)
                {
                    sleepingBag.Kill();
                    break;
                }
            }
            Effect.server.Run(EffectPrefab1, player, 0, Vector3.zero, Vector3.forward);
            playerHomes.Remove(name);
            SendReply(player, Messages["removehomesuccess"], name);
        }

        [ConsoleCommand("home")]
        void cmdHome(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            if (arg.Args == null || arg.Args.Length < 1) return;
            cmdChatHome(player, "", new[] { arg.Args[0] });
        }

        [ChatCommand("homelist")]
        private void cmdHomeList(BasePlayer player, string command, string[] args)
        {
			if (!enabledHome) return;
            if (!homes.ContainsKey(player.userID) || homes[player.userID].Count == 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["homesmissing"]);
                return;
            }
            var playerHomes = homes[player.userID];
            var time = (GetHomeLimit(player.userID) - playerHomes.Count);
            var homelist = playerHomes.Select(x =>  GetSleepingBag(x.Key, x.Value) != null ? $"{x.Key} {x.Value}" : $"Дом: {x.Key} {x.Value}");
            foreach (var home in playerHomes.ToList())
            {
                if (createSleepingBug)
                {
                    if (!GetSleepingBag(home.Key, home.Value))
                        playerHomes.Remove(home.Key);
                }
            }
            SendReply(player, Messages["homeslist"], time, string.Join("\n", homelist.ToArray()));
        }

        [ChatCommand("home")]
        void cmdChatHome(BasePlayer player, string command, string[] args)
        {
			if (!enabledHome) return;
            if (args.Length != 1)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["homeArgsError"]);
                return;
            }
            var ret = Interface.Call("CanTeleport", player) as string;
            if (ret != null)
            {
                SendReply(player, ret);
                return;
            }
			if(CanSwimmingHome)
			{
				if (player.IsSwimming())
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Swimming"]);
                    return;
                }
			}
			if(CanCraftHome)
			{
				if (player.inventory.crafting.queue.Count > CraftBlockHome)
				{
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Craft"]);
                    return;
                }
			}
			if(CanAliveHome)
			{
				if (!player.IsAlive())
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Alive"]);
                    return;
                }
			}
			if(CanRadiationHome)
			{
				if (player.metabolism.radiation_poison.value > RadiationBlockHome)
                {
				    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Radiation"]);
                    return;
                }
			}
			if(CanBleedingHome)
			{
                if (player.metabolism.bleeding.value > BleedingBlockHome)
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Bleeding"]);
                    return;
                }
			}
			if(CanWoundedHome)
			{
                if (player.IsWounded())
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Wounded"]);
                    return;
                }
			}
			if(CanColdHome)
			{
			    if (player.metabolism.temperature.value < ColdBlockHome)
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Cold"]);
                    return;
                }
			}
            int seconds;
            if (cooldownsHOME.TryGetValue(player.userID, out seconds) && seconds > 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, string.Format(Messages["tpkd"], TimeToString(seconds)));
                return;
            }
            if (homecupboard)
            {
                var privilege = player.GetBuildingPrivilege(player.WorldSpaceBounds());
                if (privilege != null && !player.IsBuildingAuthed())
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["tphomecupboard"]);
                    return;
                }
            }
            if (!homes.ContainsKey(player.userID))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["homesmissing"]);
                return;
            }
            var name = args[0];
            var playerHomes = homes[player.userID];
            if (!playerHomes.ContainsKey(name))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["homenotexist"]);
                return;
            }
            var time = GetTeleportTime(player.userID);
            var pos = playerHomes[name];

            SleepingBag bag = GetSleepingBag(name, pos);
            if (createSleepingBug)
            {
                if (bag == null)
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["sleepingbagmissing"]);
                    playerHomes.Remove(name);
                    return;
                }
            }
            if (!createSleepingBug)
            {
                var bulds = GetBuldings(pos);
                if (bulds == null)
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["foundationmissingR"]);
                    playerHomes.Remove(name);
                    return;
                }
            }
            if (player.metabolism.temperature.value < ColdBlockHome)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["Cold"]);
                return;
            }


            var lastTp = tpQueue.Find(p => p.Player == player);
            if (lastTp != null)
            {
                tpQueue.Remove(lastTp);
            }
            tpQueue.Add(new TP(player, pos, time));
            Effect.server.Run(EffectPrefab1, player, 0, Vector3.zero, Vector3.forward);
            SendReply(player, String.Format(Messages["homequeue"], name, TimeToString(time)));
            SaveData();
        }

        [ChatCommand("tpr")]
        void cmdChatTpr(BasePlayer player, string command, string[] args)
        {
            if (!enabledTP) return;
            if (args.Length != 1)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tprArgsError"]);
                return;
            }
            var ret = Interface.Call("CanTeleport", player) as string;
            if (ret != null)
            {
                SendReply(player, ret);
                return;
            }
			if(CanSwimmingTP)
			{
				if (player.IsSwimming())
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Swimming"]);
                    return;
                }
			}
			if(CanCraftTP)
			{
				if (player.inventory.crafting.queue.Count > CraftBlockTP)
				{
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Craft"]);
                    return;
                }
			}
			if(CanAliveTP)
			{
				if (!player.IsAlive())
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Alive"]);
                    return;
                }
			}
			if(CanRadiationTP)
			{
				if (player.metabolism.radiation_poison.value > RadiationBlockTP)
                {
				    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Radiation"]);
                    return;
                }
			}
			if(CanBleedingTP)
			{
                if (player.metabolism.bleeding.value > BleedingBlockTP)
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Bleeding"]);
                    return;
                }
			}
			if(CanWoundedTP)
			{
                if (player.IsWounded())
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Wounded"]);
                    return;
                }
			}
			if(CanColdTP)
			{
			    if (player.metabolism.temperature.value < ColdBlockTP)
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Cold"]);
                    return;
                }
			}
            if (restrictTPRCupboard)
            {
                var privilege = player.GetBuildingPrivilege(player.WorldSpaceBounds());
                if (privilege != null && !player.IsBuildingAuthed())
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["tpcupboard"]);
                    return;
                }
            }

            var name = args[0];
            var target = FindBasePlayer(name);
            if (target == null)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["playermissing"]);
                return;
            }
            if (target == player)
            {
                SendReply(player, Messages["playerisyou"]);
                return;
            }
            int seconds = 0;
            if (restrictCupboard && tpQueue.Any(p => p.Player == player && p.Player2 != null) &&
                player.GetBuildingPrivilege(player.WorldSpaceBounds()) != null &&
                !player.GetBuildingPrivilege(player.WorldSpaceBounds()).authorizedPlayers.Select(p => p.userid).Contains(player.userID))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tpcupboard"]);
                return;
            }
            if (cooldownsTP.TryGetValue(player.userID, out seconds) && seconds > 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, string.Format(Messages["tpkd"], TimeToString(seconds)));
                return;
            }

			if(CanSwimmingTP)
			{
				if (player.IsSwimming())
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Swimming"]);
                    return;
                }
			}
			if(CanCraftTP)
			{
				if (player.inventory.crafting.queue.Count > CraftBlockTP)
				{
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Craft"]);
                    return;
                }
			}
			if(CanAliveTP)
			{
				if (!player.IsAlive())
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Alive"]);
                    return;
                }
			}
			if(CanRadiationTP)
			{
				if (player.metabolism.radiation_poison.value > RadiationBlockTP)
                {
				    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Radiation"]);
                    return;
                }
			}
			if(CanBleedingTP)
			{
                if (player.metabolism.bleeding.value > BleedingBlockTP)
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Bleeding"]);
                    return;
                }
			}
			if(CanWoundedTP)
			{
                if (player.IsWounded())
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Wounded"]);
                    return;
                }
			}
			if(CanColdTP)
			{
			    if (player.metabolism.temperature.value < ColdBlockTP)
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Cold"]);
                    return;
                }
			}

            if (tpQueue.Any(p => p.Player == player) ||
                pendings.Any(p => p.Player2 == player))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tpError"]);
                return;
            }


            SendReply(player, string.Format(Messages["tprrequestsuccess"], target.displayName));
            SendReply(target, string.Format(Messages["tprpending"], player.displayName));
            Effect.server.Run(EffectPrefab1, target, 0, Vector3.zero, Vector3.forward);
            pendings.Add(new TP(target, Vector3.zero, 15, player));
        }

        [ChatCommand("tpa")]
        void cmdChatTpa(BasePlayer player, string command, string[] args)
        {
            if (!enabledTP) return;
            var tp = pendings.Find(p => p.Player == player);
            BasePlayer pendingPlayer = tp?.Player2;
            if (pendingPlayer == null)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tpanotexist"]);
                return;
            }

			if(CanSwimmingTP)
			{
				if (player.IsSwimming())
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Swimming"]);
                    return;
                }
			}
			if(CanCraftTP)
			{
				if (player.inventory.crafting.queue.Count > CraftBlockTP)
				{
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Craft"]);
                    return;
                }
			}
			if(CanAliveTP)
			{
				if (!player.IsAlive())
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Alive"]);
                    return;
                }
			}
			if(CanRadiationTP)
			{
				if (player.metabolism.radiation_poison.value > RadiationBlockTP)
                {
				    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Radiation"]);
                    return;
                }
			}
			if(CanBleedingTP)
			{
                if (player.metabolism.bleeding.value > BleedingBlockTP)
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Bleeding"]);
                    return;
                }
			}
			if(CanWoundedTP)
			{
                if (player.IsWounded())
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Wounded"]);
                    return;
                }
			}
			if(CanColdTP)
			{
			    if (player.metabolism.temperature.value < ColdBlockTP)
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Cold"]);
                    return;
                }
			}
			
            if (restrictCupboard && player.GetBuildingPrivilege(player.WorldSpaceBounds()) != null &&
                !player.GetBuildingPrivilege(player.WorldSpaceBounds()).authorizedPlayers.Select(p => p.userid).Contains(player.userID))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tpacupboard"]); return;
            }


            var ret = Interface.Call("CanTeleport", player) as string;
            if (ret != null)
            {
                SendReply(player, ret);
                return;
            }

            var time = GetTeleportTime(pendingPlayer.userID);
            pendings.Remove(tp);

            var lastTp = tpQueue.Find(p => p.Player == pendingPlayer);
            if (lastTp != null)
            {
                tpQueue.Remove(lastTp);
            }

            tpQueue.Add(new TP(pendingPlayer, player.GetNetworkPosition(), time, player));
            Effect.server.Run(EffectPrefab1, player, 0, Vector3.zero, Vector3.forward);
            SendReply(pendingPlayer, string.Format(Messages["tpqueue"], player.displayName, TimeToString(time)));
            SendReply(player, String.Format(Messages["tpasuccess"], pendingPlayer.displayName, TimeToString(time)));
        }


        [ChatCommand("tpc")]
        void cmdChatTpc(BasePlayer player, string command, string[] args)
        {
            var tp = pendings.Find(p => p.Player == player);
            BasePlayer target = tp?.Player2;
            if (target != null)
            {
                pendings.Remove(tp);
                SendReply(player, Messages["tpc"]);
                SendReply(target, string.Format(Messages["tpctarget"], player.displayName));
                return;
            }
			
			if(CanSwimmingTP)
			{
				if (player.IsSwimming())
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Swimming"]);
                    return;
                }
			}
			if(CanCraftTP)
			{
				if (player.inventory.crafting.queue.Count > CraftBlockTP)
				{
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Craft"]);
                    return;
                }
			}
			if(CanAliveTP)
			{
				if (!player.IsAlive())
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Alive"]);
                    return;
                }
			}
			if(CanRadiationTP)
			{
				if (player.metabolism.radiation_poison.value > RadiationBlockTP)
                {
				    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Radiation"]);
                    return;
                }
			}
			if(CanBleedingTP)
			{
                if (player.metabolism.bleeding.value > BleedingBlockTP)
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Bleeding"]);
                    return;
                }
			}
			if(CanWoundedTP)
			{
                if (player.IsWounded())
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Wounded"]);
                    return;
                }
			}
			if(CanColdTP)
			{
			    if (player.metabolism.temperature.value < ColdBlockTP)
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["Cold"]);
                    return;
                }
			}
			
            foreach (var pend in pendings)
            {
                if (pend.Player2 == player)
                {
                    SendReply(player, Messages["tpc"]);
                    SendReply(pend.Player, string.Format(Messages["tpctarget"], player.displayName));
                    pendings.Remove(pend);
                    return;
                }
            }
            foreach (var tpQ in tpQueue)
            {
                if (tpQ.Player2 != null && tpQ.Player2 == player)
                {
                    SendReply(player, Messages["tpc"]);
                    SendReply(tpQ.Player, string.Format(Messages["tpctarget"], player.displayName));
                    tpQueue.Remove(tpQ);
                    return;
                }
                if (tpQ.Player == player)
                {
                    SendReply(player, Messages["tpc"]);
                    if (tpQ.Player2 != null)
                        SendReply(tpQ.Player2, string.Format(Messages["tpctarget"], player.displayName));
                    tpQueue.Remove(tpQ);
                    return;
                }
            }
        }

        #region ADMIN COMMANDS
        void SpectateFinish(BasePlayer player)
        {
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Spectating, false);
            player.SetPlayerFlag(BasePlayer.PlayerFlags.ThirdPersonViewmode, false);
            player.Command("camoffset", "0,1,0");
            player.SetParent(null);
            player.gameObject.SetLayerRecursive(17);
            player.metabolism.Reset();
            player.InvokeRepeating("InventoryUpdate", 1f, 0.1f * UnityEngine.Random.Range(0.99f, 1.01f));
            var heldEntity = player.GetActiveItem()?.GetHeldEntity() as HeldEntity;
            heldEntity?.SetHeld(true);

            // Teleport to original location after spectating
            if (lastPositions.ContainsKey(player.userID))
            {
                var lastPosition = lastPositions[player.userID];
                Teleport(player, new Vector3(lastPosition.x, lastPosition.y, lastPosition.z));
                lastPositions.Remove(player.userID);
            }

            player.StopSpectating();
            SendReply(player, "Слежка закончена!");
        }

        [ChatCommand("tpl")]
        void cmdChattpGo(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin && !PermissionService.HasPermission(player.userID, "teleportation.admin")) return;
            if (args == null || args.Length == 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tpArgsError"]);
                return;
            }
            switch (args[0])
            {
                default:
                    if (!tpsave.ContainsKey(player.userID))
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["homesmissing"]);
                        return;
                    }
                    var nametp = args[0];
                    var playerTP = tpsave[player.userID];
                    if (!playerTP.ContainsKey(nametp))
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["homenotexist"]);
                        return;
                    }
                    var position = playerTP[nametp];
                    var ret = Interface.Call("CanTeleport", player) as string;
                    if (ret != null)
                    {
                        SendReply(player, ret);
                        return;
                    }
                    var lastTp = tpQueue.Find(p => p.Player == player);
                    if (lastTp != null)
                    {
                        tpQueue.Remove(lastTp);
                    }
                    tpQueue.Add(new TP(player, position, 0));
                    Effect.server.Run(EffectPrefab1, player, 0, Vector3.zero, Vector3.forward);
                    SaveData();
                    return;
                case "add":
                    if (args == null || args.Length == 1)
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["settpArgsError"]);
                        return;
                    }
                    var nameAdd = args[1];
                    SetTpSave(player, nameAdd);
                    return;

                case "remove":
                    if (args == null || args.Length == 1)
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["removetpArgsError"]);
                        return;
                    }
                    if (!tpsave.ContainsKey(player.userID))
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["homesmissing"]);
                        return;
                    }
                    var playertp = tpsave[player.userID];
                    var name = args[1];
                    if (!playertp.ContainsKey(name))
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["homenotexist"]);
                        return;
                    }

                    Effect.server.Run(EffectPrefab1, player, 0, Vector3.zero, Vector3.forward);
                    playertp.Remove(name);
                    SaveData();
                    SendReply(player, Messages["removehomesuccess"], name);
                    return;
                case "list":
                    if (!tpsave.ContainsKey(player.userID) || tpsave[player.userID].Count == 0)
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["homesmissing"]);
                        return;
                    }
                    var playerTPList = tpsave[player.userID];
                    var tplist = playerTPList.Select(x => GetSleepingBag(x.Key, x.Value) != null ? $"{x.Key} ({x.Value})" : $"{x.Key} {x.Value}");

                    SendReply(player, Messages["tplist"], string.Join("\n", tplist.ToArray()));
                    return;



            }
        }

        [ChatCommand("tpspec")]
        void cmdTPSpec(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin && !PermissionService.HasPermission(player.userID, "teleportation.admin")) return;
            if (args.Length == null || args.Length != 1)
            {
                SendReply(player, Messages["tpspecError"]);
                return;
            }
            string name = args[0];
            BasePlayer target = FindBasePlayer(name);
            if (target == null)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["playermissing"]);
                return;
            }
            if (!player.IsSpectating())
            {
                switch (args.Length)
                {
                    case 1:
                        if (!target.IsConnected)
                        {
                            SendReply(player, Messages["playermissingOff"]);
                            return;
                        }

                        if (target.IsDead())
                        {
                            SendReply(player, Messages["playermissingOrDeath"]);
                            return;
                        }

                        if (ReferenceEquals(target, player))
                        {
                            SendReply(player, Messages["playerItsYou"]);
                            return;
                        }

                        if (target.IsSpectating())
                        {
                            SendReply(player, Messages["playerItsSpec"]);
                            return;
                        }
                        spectatingPlayers.Remove(target);
                        lastPositions[player.userID] = player.GetNetworkPosition();
                        var heldEntity = player.GetActiveItem()?.GetHeldEntity() as HeldEntity;
                        heldEntity?.SetHeld(false);
                        player.SetPlayerFlag(BasePlayer.PlayerFlags.Spectating, true);
                        player.gameObject.SetLayerRecursive(10);
                        player.CancelInvoke("MetabolismUpdate");
                        player.CancelInvoke("InventoryUpdate");
                        player.ClearEntityQueue();
                        entitySnapshot.Invoke(player, new object[] { target });
                        player.gameObject.Identity();
                        player.SetParent(target);
                        player.SetPlayerFlag(BasePlayer.PlayerFlags.ThirdPersonViewmode, true);
                        player.Command("camoffset 0,1.3,0");
                        SendReply(player, $"Вы наблюдаете за игроком {target}! Что бы переключаться между игроками, нажимайте: Пробел");
                        break;
                }
            }
            else
            {
                SpectateFinish(player);
            }
        }

        [ChatCommand("tp")]
        void cmdTP(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin && !PermissionService.HasPermission(player.userID, "teleportation.admin")) return;
            switch (args.Length)
            {
                case 1:
                    string name = args[0];
                    BasePlayer target = FindBasePlayer(name);
                    if (target == null)
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["playermissing"]);
                        return;
                    }
                    if (adminsLogs)
                    {
                        LogToFile("admin", $"[{DateTime.Now.ToShortTimeString()}] {player} телепортировался к {target}", this, true);
                    }
                    Teleport(player, target);
                    break;
                case 2:
                    string name1 = args[0];
                    string name2 = args[1];
                    BasePlayer target1 = FindBasePlayer(name1);
                    BasePlayer target2 = FindBasePlayer(name2);

                    if (target1 == null || target2 == null)
                    {
                        SendReply(player, Messages["playermissing"]);
                        return;
                    }
                    if (adminsLogs)
                    {
                        LogToFile("admin", $"[{DateTime.Now.ToShortTimeString()}] Игрок {player} телепортировал {target1} к {target2}", this, true);
                    }
                    Teleport(target1, target2);
                    break;
                case 3:

                    float x = float.Parse(args[0]);
                    float y = float.Parse(args[1]);
                    float z = float.Parse(args[2]);
                    if (adminsLogs)
                    {
                        LogToFile("admin", $"[{DateTime.Now.ToShortTimeString()}] Игрок {player} телепортировался на координаты: ({x} / {y} / {z})", this, true);
                    }
                    Teleport(player, x, y, z);
                    break;

            }
        }

        [ConsoleCommand("home.wipe")]
        private void CmdTest(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null) return;
            WipeData();
        }


        #endregion

        #endregion

        #region OXIDE HOOKS

        public string TimeToString(double time)
        {
            TimeSpan elapsedTime = TimeSpan.FromSeconds(time);
            int hours = elapsedTime.Hours;
            int minutes = elapsedTime.Minutes;
            int seconds = elapsedTime.Seconds;
            int days = Mathf.FloorToInt((float)elapsedTime.TotalDays);
            string s = "";

            if (days > 0) s += $"{days} дн.";
            if (hours > 0) s += $"{hours} ч. ";
            if (minutes > 0) s += $"{minutes} мин. ";
            if (seconds > 0) s += $"{seconds} сек.";
            else s = s.TrimEnd(' ');
            return s;
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            pendings.RemoveAll(p => p.Player == player || p.Player2 == player);
            tpQueue.RemoveAll(p => p.Player == player || p.Player2 == player);
        }

        void OnNewSave()
        {
            if (wipedData)
            {
                PrintWarning("Обнаружен вайп. Очищаем данные с data/Teleportation");

                Interface.Oxide.DataFileSystem.WriteObject("Teleportation/Homes", new Dictionary<string, FileInfo>());
                Interface.Oxide.DataFileSystem.WriteObject("Teleportation/AdminTpSave", new Dictionary<string, FileInfo>());
                LoadData();
                Interface.Oxide.ReloadPlugin(Title);
            }
        }

        void OnServerInitialized()
        {
            LoadDefaultConfig();
            lang.RegisterMessages(Messages, this, "en");
            Messages = lang.GetMessages("en", this);
            PermissionService.RegisterPermissions(this, new List<string>() { TPADMIN });
            LoadData();
            timer.Every(1f, TeleportationTimerHandle);
        }

        void Unload()
        {
            SaveData();
        }

        void OnEntityBuilt(Planner planner, GameObject gameobject)
        {
            if (planner == null || gameobject == null) return;
            var player = planner.GetOwnerPlayer();
            BaseEntity entity = gameobject.ToBaseEntity();
            if (entity == null) return;
            if (gameobject.name.Contains("foundation"))
            {
                var pos = gameobject.transform.position;
                foreach (var pending in tpQueue)
                {
                    if (Vector3.Distance(pending.pos, pos) < 3)
                    {
                        entity.Kill();
                        SendReply(planner.GetOwnerPlayer(), "Нельзя, тут телепортируется игрок!");
                        return;
                    }
                }
            }
        }

        #endregion

        #region CORE

        void TeleportationTimerHandle()
        {
            List<ulong> tpkdToRemove = new List<ulong>();
            foreach (var uid in cooldownsTP.Keys.ToList())
            {
                if (--cooldownsTP[uid] <= 0)
                {
                    tpkdToRemove.Add(uid);
                }
            }
            tpkdToRemove.ForEach(p => cooldownsTP.Remove(p));

            List<ulong> tpkdHomeToRemove = new List<ulong>();
            foreach (var uid in cooldownsHOME.Keys.ToList())
            {
                if (--cooldownsHOME[uid] <= 0)
                {
                    tpkdHomeToRemove.Add(uid);
                }
            }
            tpkdHomeToRemove.ForEach(p => cooldownsHOME.Remove(p));

            for (int i = pendings.Count - 1; i >= 0; i--)
            {
                var pend = pendings[i];
                if (pend.Player2 != null && pend.Player2.IsConnected && pend.Player2.IsWounded())
                {
                    SendReply(pend.Player2, Messages["tpwounded"]);
                    pendings.RemoveAt(i);
                    continue;
                }
                if (--pend.seconds <= 0)
                {
                    pendings.RemoveAt(i);
                    if (pend.Player2 != null && pend.Player2.IsConnected) SendReply(pend.Player2, Messages["tppendingcanceled"]);
                    if (pend.Player != null && pend.Player.IsConnected) SendReply(pend.Player, Messages["tpacanceled"]);
                }
            }
            for (int i = tpQueue.Count - 1; i >= 0; i--)
            {
                var reply = 229;
                var tp = tpQueue[i];
                if (tp.Player != null && tp.Player.IsConnected && (tp.Player.metabolism.bleeding.value > 0 || tp.Player.IsWounded()))
                {
                    SendReply(tp.Player, Messages["tpwounded"]);
                    if (tp.Player2 != null && tp.Player.IsConnected)
                        SendReply(tp.Player2, Messages["tpWoundedTarget"]);
                    tpQueue.RemoveAt(i);
                    continue;
                }
                if (--tp.seconds <= 0)
                {
                    tpQueue.RemoveAt(i);
                    var ret = Interface.CallHook("CanTeleport", tp.Player) as string;
                    if (ret != null)
                    {
                        SendReply(tp.Player, ret);
                        continue;
                    }
                    Teleport(tp.Player, tp.pos);

                    if (tp.Player2 != null && tp.Player != null && tp.Player.IsConnected && tp.Player2.IsConnected)
                    {
                        var seconds = GetKD(tp.Player.userID);
                        SetCooldown(tp.Player, "tp", seconds);
                        cooldownsTP[tp.Player.userID] = seconds;
                        SendReply(tp.Player, string.Format(Messages["tpplayersuccess"], tp.Player2.displayName));
                    }
                    else
                    if (tp.Player != null && tp.Player.IsConnected)
                    {
                        var seconds = GetKDHome(tp.Player.userID);
                        SetCooldown(tp.Player, "home", seconds);
                        cooldownsHOME[tp.Player.userID] = seconds;
                        SendReply(tp.Player, Messages["tphomesuccess"]);
                    }
                    NextTick(() => Interface.CallHook("OnPlayerTeleported", tp.Player));
                }
            }
        }

        void SetTpSave(BasePlayer player, string name)
        {
            var uid = player.userID;
            var pos = player.GetNetworkPosition();


            Dictionary<string, Vector3> adminTP;
            if (!tpsave.TryGetValue(uid, out adminTP))
                adminTP = (tpsave[uid] = new Dictionary<string, Vector3>());

            if (adminTP.ContainsKey(name))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["homeexist"]);
                return;
            }
            adminTP.Add(name, pos);
            Effect.server.Run(EffectPrefab1, player, 0, Vector3.zero, Vector3.forward);
            SendReply(player, Messages["homesucces"], name);
            SaveData();
            timer.Once(10f, () => sethomeBlock.Remove(player.userID));
        }

        void SetHome(BasePlayer player, string name)
        {
            var uid = player.userID;
            var pos = player.GetNetworkPosition();

            if (player.GetBuildingPrivilege(player.WorldSpaceBounds()) != null &&
                !player.GetBuildingPrivilege(player.WorldSpaceBounds()).authorizedPlayers.Select(p => p.userid).Contains(player.userID))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["sethomecupboard"]);
                return;
            }
            Dictionary<string, Vector3> playerHomes;
            if (!homes.TryGetValue(uid, out playerHomes))
                playerHomes = (homes[uid] = new Dictionary<string, Vector3>());
            if (GetHomeLimit(uid) == playerHomes.Count)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["maxhomes"]);
                return;
            }

            if (playerHomes.ContainsKey(name))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["homeexist"]);
                return;
            }
            playerHomes.Add(name, pos);

            if (createSleepingBug)
            {
                CreateSleepingBag(player, pos, name);
            }

            Effect.server.Run(EffectPrefab1, player, 0, Vector3.zero, Vector3.forward);
            SendReply(player, Messages["homesucces"], name);
            sethomeBlock.Add(player.userID);
            SaveData();
            timer.Once(10f, () => sethomeBlock.Remove(player.userID));
        }

        int GetKDHome(ulong uid)
        {
            int min = tpkdhomeDefault;
            foreach (var privilege in tpkdhomePerms)
                if (PermissionService.HasPermission(uid, privilege.Key))
                    min = Mathf.Min(min, privilege.Value);
            return min;
        }

        int GetKD(ulong uid)
        {
            int min = tpkdDefault;
            foreach (var privilege in tpkdPerms)
                if (PermissionService.HasPermission(uid, privilege.Key))
                    min = Mathf.Min(min, privilege.Value);
            return min;
        }
        int GetHomeLimit(ulong uid)
        {
            int max = homelimitDefault;
            foreach (var privilege in homelimitPerms)
                if (PermissionService.HasPermission(uid, privilege.Key))
                    max = Mathf.Max(max, privilege.Value);
            return max;
        }
        int GetTeleportTime(ulong uid)
        {
            int min = teleportSecsDefault;
            foreach (var privilege in teleportSecsPerms)
                if (PermissionService.HasPermission(uid, privilege.Key))
                    min = Mathf.Min(min, privilege.Value);
            return min;
        }
        BaseEntity GetBuldings(Vector3 pos)
        {
            RaycastHit hit;
            if (Physics.Raycast(new Ray(pos, Vector3.down), out hit, 0.1f))
            {
                var entity = hit.GetEntity();
                if (entity != null && entity.ShortPrefabName.Contains("floor"))
                    return entity;
                if (entity != null && entity.ShortPrefabName.Contains("foundation"))
                    return entity;
            }
            return null;
        }
        BaseEntity GetFoundation(Vector3 pos)
        {
            RaycastHit hit;
            if (Physics.Raycast(new Ray(pos, Vector3.down), out hit, 0.1f))
            {
                var entity = hit.GetEntity();
                if (entity != null && entity.ShortPrefabName.Contains("foundation"))
                    return entity;
            }
            return null;
        }


        SleepingBag GetSleepingBag(string name, Vector3 pos)
        {
            List<SleepingBag> sleepingBags = new List<SleepingBag>();
            Vis.Components(pos, .1f, sleepingBags);
            return sleepingBags.Count > 0 ? sleepingBags[0] : null;
        }

        void CreateSleepingBag(BasePlayer player, Vector3 pos, string name)
        {
            SleepingBag sleepingBag =
                GameManager.server.CreateEntity("assets/prefabs/deployable/sleeping bag/sleepingbag_leather_deployed.prefab", pos,
                    Quaternion.identity) as SleepingBag;
            if (sleepingBag == null) return;
            sleepingBag.skinID = 1174407153;
            sleepingBag.deployerUserID = player.userID;
            sleepingBag.niceName = SleepingBagName;
            sleepingBag.OwnerID = player.userID;
            //SleepingBagUnlockTimeField.SetValue(sleepingBag, Time.realtimeSinceStartup + 300f);
            sleepingBag.Spawn();
        }

        #endregion

        #region API

        Dictionary<string, Vector3> GetHomes(ulong uid)
        {
            Dictionary<string, Vector3> positions;
            if (!homes.TryGetValue(uid, out positions))
                return null;
            return positions.ToDictionary(p => p.Key, p => p.Value);
        }

        #endregion

        #region TELEPORTATION

        public void Teleport(BasePlayer player, BasePlayer target) => Teleport(player, target.transform.position);

        public void Teleport(BasePlayer player, float x, float y, float z) => Teleport(player, new Vector3(x, y, z));

        public void Teleport(BasePlayer player, Vector3 position)
        {
            if (player.IsDead() && player.IsConnected)
            {
                player.RespawnAt(position, Quaternion.identity);
                return;
            }
            var ret = Interface.Call("CanTeleport", player) as string;
            if (ret != null)
            {
                SendReply(player, ret);
                return;
            }
            if (player.net?.connection != null)
                player.ClientRPCPlayer(null, player, "StartLoading");

            player.StartSleeping();
            player.MovePosition(position);
            if (player.net?.connection != null)
                player.ClientRPCPlayer(null, player, "ForcePositionTo", position);
            if (player.net?.connection != null)
                player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
            player.UpdateNetworkGroup();
            //player.UpdatePlayerCollider(true, false);
            player.SendNetworkUpdateImmediate(false);
            if (player.net?.connection == null) return;
            //TODO temporary for potential rust bug
            try { player.ClearEntityQueue(null); } catch { }
            player.SendFullSnapshot();
        }

        #endregion

        #region Cooldown
        DynamicConfigFile cooldownsFile = Interface.Oxide.DataFileSystem.GetFile("Teleportation/Cooldowns");

        private class Cooldown
        {
            public ulong UserId;
            public double Expired;
            [JsonIgnore]
            public Action OnExpired;
        }
        private static Dictionary<string, List<Cooldown>> cooldowns;

        internal static void Service()
        {
            var time = GrabCurrentTime();
            List<string> toRemove = new List<string>();
            foreach (var cd in cooldowns)
            {
                var keyCooldowns = cd.Value;
                List<string> toRemoveCooldowns = new List<string>();
                for (var i = keyCooldowns.Count - 1; i >= 0; i--)
                {
                    var cooldown = keyCooldowns[i];
                    if (cooldown.Expired < time)
                    {
                        cooldown.OnExpired?.Invoke();
                        keyCooldowns.RemoveAt(i); ;
                    }
                }
                if (keyCooldowns.Count == 0) toRemove.Add(cd.Key);
            }
            toRemove.ForEach(p => cooldowns.Remove(p));
        }

        public static void SetCooldown(BasePlayer player, string key, int seconds, Action onExpired = null)
        {
            List<Cooldown> cooldownList;
            if (!cooldowns.TryGetValue(key, out cooldownList))
                cooldowns[key] = cooldownList = new List<Cooldown>();
            cooldownList.Add(new Cooldown()
            {
                UserId = player.userID,
                Expired = GrabCurrentTime() + (double)seconds,
                OnExpired = onExpired
            });
        }

        public static int GetCooldown(BasePlayer player, string key)
        {
            List<Cooldown> source = new List<Cooldown>();
            if (cooldowns.TryGetValue(key, out source))
            {
                Cooldown cooldown = source.FirstOrDefault<Cooldown>((Func<Cooldown, bool>)(p => (long)p.UserId == (long)player.userID));
                if (cooldown != null)
                    return (int)(cooldown.Expired - GrabCurrentTime());
            }
            return 0;
        }
		
        static double GrabCurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;

        #endregion

        #region DATA

        DynamicConfigFile homesFile = Interface.Oxide.DataFileSystem.GetFile("Teleportation/Homes");
        DynamicConfigFile tpsaveFile = Interface.Oxide.DataFileSystem.GetFile("Teleportation/AdminTpSave");

        void OnServerSave()
        {
            SaveData();
        }

        void LoadData()
        {
            tpsaveFile.Settings.Converters.Add(converter);
            tpsave = tpsaveFile.ReadObject<Dictionary<ulong, Dictionary<string, Vector3>>>();

            homesFile.Settings.Converters.Add(converter);
            homes = homesFile.ReadObject<Dictionary<ulong, Dictionary<string, Vector3>>>();
            cooldowns = cooldownsFile.ReadObject<Dictionary<string, List<Cooldown>>>() ??
                        new Dictionary<string, List<Cooldown>>();
        }

        void SaveData()
        {
            tpsaveFile.WriteObject(tpsave);
            homesFile.WriteObject(homes);
            cooldownsFile.WriteObject(cooldowns);
        }

        #endregion

        #region LOCALIZATION

        Dictionary<string, string> Messages = new Dictionary<string, string>()
        {
            {"foundationmissing", "Фундамент не найден!" },
            {"foundationmissingR", "Фундамент не найден, местоположение было удалено!" },
            {"playerisyou", "Нельзя отправлять телепорт самому себе!" },
            {"maxhomes", "У вас максимальное кол-во местоположений!" },
            {"homeexist", "Такое местоположение уже существует!" },
            {"homesucces", "Местоположение {0} успешно установлено!" },
            {"sethomeArgsError", "Для установки местоположения используйте /sethome ИМЯ" },
            {"settpArgsError", "Для установки местоположения используйте /tpl add ИМЯ" },
            {"homeArgsError", "Для телепортации на местоположение используйте /home ИМЯ" },
            {"tpArgsError", "Для телепортации на местоположение используйте /tpl ИМЯ" },
            {"tpError", "Запрещено! Вы в очереди на телепортацию" },
            {"homenotexist", "Местоположение с таким названием не найдено!" },
            {"homequeue", "Телепортация на {0} будет через {1}" },
            {"tpwounded", "Вы получили ранение, телепортация отменена!" },
            {"tphomesuccess", "Вы телепортированы домой!" },
            {"tptpsuccess", "Вы телепортированы на указаное место!" },
            {"homesmissing", "У вас нет доступных местоположений!" },
            {"removehomeArgsError", "Для удаления местоположения используйте /removehome ИМЯ" },
            {"removetpArgsError", "Для удаления местоположения используйте /tpl remove ИМЯ" },
            {"removehomesuccess", "Местоположение {0} успешно удалено" },
            {"sleepingbagmissing", "Спальный мешок не найден, местоположение удалено!" },
            {"tprArgsError", "Для отправки запроса на телепортация используйте /tpr НИК" },
            {"playermissing", "Игрок не найден" },
            {"tpspecError", "Не правильно введена команда. Используйте: /tpspec НИК" },
            {"playermissingOff", "Игрок не в сети" },
            {"playermissingOrDeath", "Игрок не найден, или он мёртв" },
            {"playerItsYou", "Нельзя следить за самым собой" },
            {"playerItsSpec", "Игрок уже за кем то наблюдает" },
            {"tprrequestsuccess", "Запрос {0} успешно отправлен" },
            {"tprpending", "{0} отправил вам запрос на телепортацию\nЧтобы принять используйте /tpa\nЧтобы отказаться используйте /tpc" },
            {"tpanotexist", "У вас нет активных запросов на телепортацию!" },
            {"tpqueue", "{0} принял ваш запрос на телепортацию\nВы будете телепортированы через {1}" },
            {"tpc", "Телепортация успешно отменена!" },
            {"tpctarget", "{0} отменил телепортацию!" },
            {"tpplayersuccess", "Вы успешно телепортировались к {0}" },
            {"tpasuccess", "Вы приняли запрос телепортации от {0}\nОн будет телепортирован через {1}" },
            {"tppendingcanceled", "Запрос телепортации отменён" },
            {"tpcupboard", "Телепортация в зоне действия чужого шкафа запрещена!" },
            {"tphomecupboard", "Телепортация домой в зоне действия чужого шкафа запрещена!" },
            {"tpacupboard", "Принятие телепортации в зоне действия чужого шкафа запрещена!" },
            {"sethomecupboard", "Установка местоположения в зоне действия чужого шкафа запрещена!" },
            {"tpacanceled", "Вы не ответили на запрос." },
            {"tpkd", "Телепортация на перезарядке!\nОсталось {0}" },
            {"tpWoundedTarget", "Игрок ранен, телепортация отменена!" },
			{"Radiation", "Телепортация во время радиационного облучения запрещена!\nТелепорт отменён." },
            {"Bleeding", "Телепортация во время кровотечения запрещена!\nТелепорт отменён." },
			{"Swimming", "Телепортация в воде запрещена!\nТелепорт отменён."},
			{"Craft", "Телепортация во время крафта запрещена!\nТелепорт отменён."},
			{"Alive", "Вы погибли!\nТелепорт отменён."},
            {"Cold", "Вам холодно, телепортация отменена!" },
			{"Wounded", "Вы получили ранения, телепорт отменён!" },
            {"sethomeBlock", "Нельзя использовать /sethome слишком часто, попробуйте позже!" },
            {"foundationowner", "Нельзя использовать /sethome не на своих строениях!" },
            {"foundationownerFC", "Создатель обьекта не являеться вашим соклановцем или другом, /sethome запрещен" },
            {"homeslist", "Доступное количество местоположений: {0}\n{1}" },
            {"tplist", "Ваши сохраненные метоположения:\n{0}" }


        };

        #endregion

        #region VECTOR CONVERTER

        static UnityVector3Converter converter = new UnityVector3Converter();
        private class UnityVector3Converter : JsonConverter
        {
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                var vector = (Vector3)value;
                writer.WriteValue($"{vector.x} {vector.y} {vector.z}");
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                if (reader.TokenType == JsonToken.String)
                {
                    var values = reader.Value.ToString().Trim().Split(' ');
                    return new Vector3(Convert.ToSingle(values[0]), Convert.ToSingle(values[1]), Convert.ToSingle(values[2]));
                }
                var o = JObject.Load(reader);
                return new Vector3(Convert.ToSingle(o["x"]), Convert.ToSingle(o["y"]), Convert.ToSingle(o["z"]));
            }

            public override bool CanConvert(Type objectType)
            {
                return objectType == typeof(Vector3);
            }
        }

        #endregion

    }
}

                   

// --- End of file: Teleportation.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AbsolutMarket.cs ---
// --- Original Local Path: AbsolutMarket.cs ---

using System.Collections.Generic;
using System;
using System.Linq;
using UnityEngine;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using Oxide.Core;
using System.Collections;
using System.IO;

namespace Oxide.Plugins
{
    [Info("AbsolutMarket", "Absolut", "1.3.0", ResourceId = 2118)]

    class AbsolutMarket : RustPlugin
    {

        [PluginReference]
        Plugin ServerRewards;

        static GameObject webObject;
        static UnityImages uImage;
        static UnityBackgrounds uBackground;

        MarketData mData;
        private DynamicConfigFile MData;

        AMImages imgData;
        private DynamicConfigFile IMGData;

        Backgrounds bkData;
        private DynamicConfigFile BKData;

        class Backgrounds
        {
            public Dictionary<string, string> PendingBackgrounds = new Dictionary<string, string>();
        }

        string TitleColor = "<color=orange>";
        string MsgColor = "<color=#A9A9A9>";

        private List<ulong> MenuState = new List<ulong>();
        private List<ulong> SettingBox = new List<ulong>();
        private Dictionary<string, Timer> timers = new Dictionary<string, Timer>();
        private Dictionary<ulong, List<AMItem>> PlayerBoxContents = new Dictionary<ulong, List<AMItem>>();
        private Dictionary<ulong, AMItem> SalesItemPrep = new Dictionary<ulong, AMItem>();
        private Dictionary<ulong, List<Item>> PlayerInventory = new Dictionary<ulong, List<Item>>();
        private Dictionary<ulong, List<Item>> TransferableItems = new Dictionary<ulong, List<Item>>();
        private Dictionary<ulong, List<Item>> ItemsToTransfer = new Dictionary<ulong, List<Item>>();
        private Dictionary<ulong, bool> PlayerPurchaseApproval = new Dictionary<ulong, bool>();
        private Dictionary<ulong, AMItem> SaleProcessing = new Dictionary<ulong, AMItem>();

        #region Server Hooks

        void Loaded()
        {
            MData = Interface.Oxide.DataFileSystem.GetFile("AbsolutMarket_Data");
            IMGData = Interface.Oxide.DataFileSystem.GetFile("AbsolutMarket_Images");
            BKData = Interface.Oxide.DataFileSystem.GetFile("AbsolutMarket_AddBackgrounds");
            lang.RegisterMessages(messages, this);
        }

        void Unload()
        {
            foreach (var entry in timers)
                entry.Value.Destroy();
            MenuState.Clear();
            timers.Clear();
            PlayerBoxContents.Clear();
            SalesItemPrep.Clear();
            foreach (BasePlayer p in BasePlayer.activePlayerList)
            {
                DestroyMarketPanel(p);
                DestroyPurchaseScreen(p);
            }
            SaveData();
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            if (MenuState.Contains(player.userID))
                MenuState.Remove(player.userID);
        }

        private void OnPlayerInit(BasePlayer player)
        {
            if (player != null)
            {
                player.Command($"bind {configData.MarketMenuKeyBinding} \"UI_ToggleMarketScreen\"");
                GetSendMSG(player, "AMInfo", configData.MarketMenuKeyBinding);
                if (!mData.names.ContainsKey(player.userID))
                    mData.names.Add(player.userID, player.displayName);
                else
                {
                    var length = player.displayName.Count();
                    if (length > 30)
                    {
                        mData.names[player.userID] = player.displayName.Substring(0, 30);
                    }
                    else mData.names[player.userID] = player.displayName;
                }
                SendMessages(player);
            }
        }

        void OnServerInitialized()
        {
            webObject = new GameObject("WebObject");
            uImage = webObject.AddComponent<UnityImages>();
            uImage.SetDataDir(this);
            uBackground = webObject.AddComponent<UnityBackgrounds>();
            uBackground.SetDataDir(this);
            LoadVariables();
            LoadData();
            timers.Add("info", timer.Once(configData.InfoInterval, () => InfoLoop()));
            timers.Add("save", timer.Once(600, () => SaveLoop()));
            SaveData();
            if (imgData.SavedImages == null || imgData.SavedImages.Count == 0)
                Getimages();
            else Refreshimages();
            //if (imgData.SavedBackgrounds == null || imgData.SavedBackgrounds.Count == 0)
                //GetBackgrounds();
           // else
            RefreshBackgrounds();
            foreach (BasePlayer p in BasePlayer.activePlayerList)
                OnPlayerInit(p);
        }

        #endregion

        #region Player Hooks

        void OnEntityBuilt(Planner planner, GameObject gameobject)
        {
            if (planner == null) return;
            if (gameobject.GetComponent<BaseEntity>() != null)
            {
                BaseEntity element = gameobject.GetComponent<BaseEntity>();
                var entityowner = element.OwnerID;
                var ID = element.net.ID;
                if (!SettingBox.Contains(entityowner)) return;
                if (element.PrefabName == "assets/prefabs/deployable/large wood storage/box.wooden.large.prefab" || element.PrefabName == "assets/prefabs/deployable/woodenbox/woodbox_deployed.prefab")
                {
                    BasePlayer player = BasePlayer.FindByID(entityowner);
                    TradeBoxConfirmation(player, ID);
                }
            }
        }

        private void OnEntityDeath(BaseEntity entity, HitInfo hitInfo)
        {
            if (entity is StorageContainer)
            {
                uint ID = entity.net.ID;
                if (mData.TradeBox.ContainsKey(entity.OwnerID))
                {
                    if (ID == mData.TradeBox[entity.OwnerID])
                    {
                        Dictionary<uint, string> listings = new Dictionary<uint, string>();
                        foreach (var entry in mData.MarketListings.Where(kvp => kvp.Value.seller == entity.OwnerID))
                            listings.Add(entry.Key, entry.Value.shortname);
                        foreach (var entry in listings)
                            RemoveListing(entity.OwnerID, entry.Value, entry.Key, "TradeBoxDestroyed");
                        listings.Clear();
                        mData.TradeBox.Remove(entity.OwnerID);
                        BasePlayer owner = BasePlayer.FindByID(entity.OwnerID);
                        if (BasePlayer.activePlayerList.Contains(owner))
                            GetSendMSG(owner, "TradeBoxDestroyed");
                    }
                    SaveData();
                }
                return;
            }
        }

        private object OnPlayerChat(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return null;
            bool isPreping = false;
            AMItem item;
            var args = string.Join(" ", arg.Args);
            if (SalesItemPrep.ContainsKey(player.userID))
            {
                isPreping = true;
            }
            if (SettingBox.Contains(player.userID))
            {
                if (args.Contains("quit"))
                {
                    SettingBox.Remove(player.userID);
                    GetSendMSG(player, "ExitedBoxMode");
                    return true;
                }
            }
            if (isPreping)
            {
                item = SalesItemPrep[player.userID];
                if (args.Contains("quit"))
                {
                    CancelListing(player);
                    return true;
                }
                switch (item.stepNum)
                {
                    case 0:
                        var name = string.Join(" ", arg.Args);
                        item.name = name;
                        item.stepNum = 99;
                        SellItems(player, 1);
                        return true;
                }
            }
            return null;
        }



        #endregion

        #region Functions

        private StorageContainer GetTradeBox(ulong Buyer)
        {
            List<StorageContainer> Containers = new List<StorageContainer>();
            if (mData.TradeBox.ContainsKey(Buyer))
            {
                uint ID = mData.TradeBox[Buyer];
                foreach (StorageContainer Cont in StorageContainer.FindObjectsOfType<StorageContainer>())
                {
                    if (Cont.net.ID == ID)
                        return Cont;
                }
            }
            return null;
        }

        private bool GetTradeBoxContents(BasePlayer player)
        {
            if (player == null) return false;
            ulong seller = player.userID;
            if (GetTradeBox(seller) != null)
            {
                StorageContainer box = GetTradeBox(seller);
                if (GetItems(box.inventory).Count() == 0)
                {
                    if (!ServerRewards || !configData.ServerRewards || mData.Blacklist.Contains("SR"))
                    {
                        GetSendMSG(player, "TradeBoxEmpty");
                        return false;
                    }
                    else
                        if (CheckPoints(player.userID) is int)
                        if ((int)CheckPoints(player.userID) < 1)
                        {
                            GetSendMSG(player, "TradeBoxEmptyNoSR");
                            return false;
                        }
                }
                if (PlayerBoxContents.ContainsKey(seller)) PlayerBoxContents.Remove(seller);
                PlayerBoxContents.Add(seller, new List<AMItem>());
                PlayerBoxContents[seller].AddRange(GetItems(box.inventory));
                var bl = 0;
                var c = 0;
                var listed = 0;
                foreach (var entry in PlayerBoxContents[seller])
                {
                    c++;
                    if (mData.Blacklist.Contains(entry.shortname))
                        bl++;
                    if (mData.MarketListings.ContainsKey(entry.ID))
                        listed++;
                    foreach (var cat in imgData.SavedImages)
                        foreach (var item in cat.Value)
                        {
                            if (item.Key == entry.shortname)
                            {
                                entry.cat = cat.Key;
                                break;
                            }
                        }
                }
                if (bl == c)
                {
                    if (!ServerRewards || !configData.ServerRewards || mData.Blacklist.Contains("SR"))
                    {
                        GetSendMSG(player, "AllItemsAreBL");
                        return false;
                    }
                    else
                    if (CheckPoints(player.userID) is int)
                        if ((int)CheckPoints(player.userID) < 1)
                        {
                            GetSendMSG(player, "AllItemsAreBLNoSR");
                            return false;
                        }
                }
                if (c == listed)
                {
                    if (!ServerRewards || !configData.ServerRewards || mData.Blacklist.Contains("SR"))
                    {
                        GetSendMSG(player, "AllItemsAreListed");
                        return false;
                    }
                    else
                    if (CheckPoints(player.userID) is int)
                        if ((int)CheckPoints(player.userID) < 1)
                        {
                            GetSendMSG(player, "AllItemsAreListedNoSR");
                            return false;
                        }
                }
                return true;
            }
            else GetSendMSG(player, "NoTradeBox"); return false;
        }

        private bool BoxCheck(BasePlayer player, uint item)
        {
            if (player == null) return false;
            ulong seller = player.userID;
            if (GetTradeBox(seller) != null)
            {
                StorageContainer box = GetTradeBox(seller);
                if (GetItems(box.inventory).Count() == 0)
                {
                    GetSendMSG(player, "TradeBoxEmpty");
                    return false;
                }
                foreach (var entry in box.inventory.itemList)
                {
                    if (entry.uid == item)
                        return true;
                }
                return false;
            }
            else GetSendMSG(player, "NoTradeBox"); return false;
        }

        private void AddMessages(ulong player, string message, string arg1 = "", string arg2 = "", string arg3 = "", string arg4 = "")
        {
            try
            {
                BasePlayer Online = BasePlayer.FindByID(player);
                if (BasePlayer.activePlayerList.Contains(Online))
                    GetSendMSG(Online, message, GetLang(arg1), GetLang(arg2), GetLang(arg3), GetLang(arg4));
            }
            catch
            {
                if (!mData.OutstandingMessages.ContainsKey(player))
                    mData.OutstandingMessages.Add(player, new List<Unsent>());
                mData.OutstandingMessages[player].Add(new Unsent { message = message, arg1 = arg1, arg2 = arg2, arg3 = arg3, arg4 = arg4 });
                SaveData();
            }
        }

        private void SendMessages(BasePlayer player)
        {
            if (mData.OutstandingMessages.ContainsKey(player.userID))
            {
                foreach (var entry in mData.OutstandingMessages[player.userID])
                {
                    GetSendMSG(player, entry.message, GetLang(entry.arg1), GetLang(entry.arg2), GetLang(entry.arg3), GetLang(entry.arg4));
                }
                mData.OutstandingMessages.Remove(player.userID);
            }
        }

        private IEnumerable<AMItem> GetItems(ItemContainer container)
        {
            return container.itemList.Select(item => new AMItem
            {
                amount = item.amount,
                skin = item.skin,
                cat = Category.None,
                pricecat = Category.None,
                shortname = item.info.shortname,
                condition = item.condition,
                ID = item.uid,
            });
        }

        private IEnumerable<Item> GetItemsOnly(ItemContainer container)
        {
            return container.itemList;
        }

        private void XferPurchase(ulong buyer, uint ID, ItemContainer from, ItemContainer to)
        {
            foreach (Item item in from.itemList.Where(kvp => kvp.uid == ID))
                ItemsToTransfer[buyer].Add(item);
            //item.MoveToContainer(to);
        }

        private void XferCost(Item item, BasePlayer player, uint Listing)
        {
            //Puts("Starting");
            ItemContainer from = player.inventory.containerMain;
            if (player.inventory.containerBelt.itemList.Contains(item))
            {
                from = player.inventory.containerBelt;
                //Puts($"{from} belt");
            }
            else if (player.inventory.containerWear.itemList.Contains(item))
            {
                from = player.inventory.containerWear;
                //Puts($"{from} wear");
            }
            else
                //Puts($"{from} main");
            if (mData.MarketListings[Listing].priceAmount > 0)
            {
                //Puts("TRying");
                foreach (Item item1 in from.itemList.Where(kvp => kvp == item))
                {
                    //Puts("Item found)");
                    if (mData.MarketListings[Listing].priceAmount >= item1.amount)
                    {
                        //Puts("1");
                        ItemsToTransfer[player.userID].Add(item1);
                        mData.MarketListings[Listing].priceAmount -= item1.amount;
                        //Puts($"{item1} moved... price amount: {mData.MarketListings[Listing].priceAmount} item amount:{item1.amount}");
                    }
                    else
                    {
                        Item item2 = item1.SplitItem(mData.MarketListings[Listing].priceAmount);
                        ItemsToTransfer[player.userID].Add(item2);
                        mData.MarketListings[Listing].priceAmount = 0;
                        //Puts($"SPLITTING: {item2} moved... price amount: {mData.MarketListings[Listing].priceAmount} item amount:{item2.amount}");
                    }
                    break;
                }
            }
        }

        private Item BuildCostItems(string shortname, int amount)
        {
            var definition = ItemManager.FindItemDefinition(shortname);
            if (definition != null)
            {
                var item1 = ItemManager.Create(definition, amount, 0);
                if (item1 != null)
                    return item1;
            }
            Puts("Error making purchase cost item(s)");
            return null;
        }

        void OnItemRemovedFromContainer(ItemContainer cont, Item item)
        {
            if (cont.entityOwner != null)
                if (mData.TradeBox.ContainsValue(cont.entityOwner.net.ID))
                    if (mData.TradeBox.ContainsKey(cont.entityOwner.OwnerID))
                        if (mData.TradeBox[cont.entityOwner.OwnerID] == cont.entityOwner.net.ID)
                            if (mData.MarketListings.ContainsKey(item.uid))
                            {
                                var name = "";
                                if (configData.UseUniqueNames && item.name != "")
                                    name = mData.MarketListings[item.uid].name;
                                else name = mData.MarketListings[item.uid].shortname;
                                RemoveListing(cont.entityOwner.OwnerID, name, item.uid, "FromBox");
                                mData.MarketListings.Remove(item.uid);
                            }
        }

        private void RemoveListing(ulong seller, string name, uint ID, string reason = "")
        {
            AddMessages(seller, "ItemRemoved", name.ToUpper(), reason);
            mData.MarketListings.Remove(ID);
        }

        private void CancelListing(BasePlayer player)
        {
            DestroyMarketPanel(player);
            if (SalesItemPrep.ContainsKey(player.userID))
                SalesItemPrep.Remove(player.userID);
            if (PlayerBoxContents.ContainsKey(player.userID))
                PlayerBoxContents.Remove(player.userID);
            GetSendMSG(player, "ItemListingCanceled");
        }

        private void SRAction(ulong ID, int amount, string action)
        {
            if (action == "ADD")
                ServerRewards?.Call("AddPoints", new object[] { ID, amount });
            if (action == "REMOVE")
                ServerRewards?.Call("TakePoints", new object[] { ID, amount });
        }

        private object CheckPoints(ulong ID) => ServerRewards?.Call("CheckPoints", ID);

        private void NumberPad(BasePlayer player, string cmd)
        {
            CuiHelper.DestroyUi(player, PanelMarket);
            var element = UI.CreateElementContainer(PanelMarket, UIColors["dark"], "0.35 0.3", "0.65 0.7", true);
            UI.CreatePanel(ref element, PanelMarket, UIColors["light"], "0.01 0.02", "0.99 0.98");
            UI.CreateLabel(ref element, PanelMarket, UIColors["limegreen"], GetLang("Select Amount"), 20, "0.1 0.85", "0.9 .98", TextAnchor.UpperCenter);
            var n = 1;
            var i = 0;
            while (n < 10)
            {
                CreateNumberPadButton(ref element, PanelMarket, i, n, cmd); i++; n++;
            }
            while (n >= 10 && n < 25)
            {
                CreateNumberPadButton(ref element, PanelMarket, i, n, cmd); i++; n += 5;
            }
            while (n >= 25 && n < 200)
            {
                CreateNumberPadButton(ref element, PanelMarket, i, n, cmd); i++; n += 25;
            }
            while (n >= 200 && n <= 950)
            {
                CreateNumberPadButton(ref element, PanelMarket, i, n, cmd); i++; n += 50;
            }
            while (n >= 1000 && n <= 10000)
            {
                CreateNumberPadButton(ref element, PanelMarket, i, n, cmd); i++; n += 500;
            }
            UI.CreateButton(ref element, PanelMarket, UIColors["buttonred"], GetLang("Quit"), 10, "0.03 0.02", "0.13 0.075", $"UI_MarketMainScreen {0} {Enum.GetName(typeof(Category), Category.All)}");
            CuiHelper.AddUi(player, element);
        }

        private void CreateNumberPadButton(ref CuiElementContainer container, string panelName, int i, int number, string command)
        {
            var pos = CalcNumButtonPos(i);
            UI.CreateButton(ref container, panelName, UIColors["buttonbg"], number.ToString(), 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"{command} {number}");
        }

        private string GetLang(string msg)
        {
            if (messages.ContainsKey(msg))
                return lang.GetMessage(msg, this);
            else return msg;
        }

        private void GetSendMSG(BasePlayer player, string message, string arg1 = "", string arg2 = "", string arg3 = "", string arg4 = "")
        {
            string msg = string.Format(lang.GetMessage(message, this), arg1, arg2, arg3, arg4);
            SendReply(player, TitleColor + lang.GetMessage("title", this, player.UserIDString) + "</color>" + MsgColor + msg + "</color>");
        }

        private string GetMSG(string message, string arg1 = "", string arg2 = "", string arg3 = "", string arg4 = "")
        {
            string msg = string.Format(lang.GetMessage(message, this), arg1, arg2, arg3, arg4);
            return msg;
        }

        public void DestroyMarketPanel(BasePlayer player)
        {
            if (MenuState.Contains(player.userID))
                MenuState.Remove(player.userID);
            CuiHelper.DestroyUi(player, PanelMarket);
        }

        public void DestroyPurchaseScreen(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelPurchase);
        }

        private void ToggleMarketScreen(BasePlayer player)
        {
            if (MenuState.Contains(player.userID))
            {
                MenuState.Remove(player.userID);
                DestroyMarketPanel(player);
                DestroyPurchaseScreen(player);
                return;
            }
            MenuState.Add(player.userID);
            MarketMainScreen(player, 0, Category.All);
        }

        bool isAuth(BasePlayer player)
        {
            if (player.net.connection != null)
                if (player.net.connection.authLevel < 1)
                    return false;
            return true;
        }

        #endregion

        #region UI Creation

        private string PanelMarket = "PanelMarket";
        private string PanelPurchase = "PanelPurchase";

        public class UI
        {
            static public CuiElementContainer CreateElementContainer(string panel, string color, string aMin, string aMax, bool cursor = false)
            {
                var NewElement = new CuiElementContainer()
            {
                {
                    new CuiPanel
                    {
                        Image = {Color = color},
                        RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                        CursorEnabled = cursor
                    },
                    new CuiElement().Parent,
                    panel
                }
            };
                return NewElement;
            }
            static public void CreatePanel(ref CuiElementContainer element, string panel, string color, string aMin, string aMax, bool cursor = false)
            {
                element.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    CursorEnabled = cursor
                },
                panel);
            }
            static public void CreateLabel(ref CuiElementContainer element, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                element.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, FadeIn = 1.0f, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);
            }

            static public void CreateButton(ref CuiElementContainer element, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align = TextAnchor.MiddleCenter)
            {
                element.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = 1.0f },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    Text = { Text = text, FontSize = size, Align = align }
                },
                panel);
            }

            static public void LoadImage(ref CuiElementContainer element, string panel, string png, string aMin, string aMax)
            {
                element.Add(new CuiElement
                {
                    Parent = panel,
                    Components =
                    {
                        new CuiRawImageComponent {Png = png },
                        new CuiRectTransformComponent {AnchorMin = aMin, AnchorMax = aMax }
                    }
                });
            }
            static public void CreateTextOverlay(ref CuiElementContainer element, string panel, string text, string color, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter, float fadein = 1.0f)
            {
                //if (configdata.DisableUI_FadeIn)
                //    fadein = 0;
                element.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, FadeIn = fadein, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);

            }
        }

        private Dictionary<string, string> UIColors = new Dictionary<string, string>
        {
            {"black", "0 0 0 1.0" },
            {"dark", "0.1 0.1 0.1 0.98" },
            {"header", "1 1 1 0.3" },
            {"light", ".564 .564 .564 1.0" },
            {"grey1", "0.6 0.6 0.6 1.0" },
            {"brown", "0.3 0.16 0.0 1.0" },
            {"yellow", "0.9 0.9 0.0 1.0" },
            {"orange", "1.0 0.65 0.0 1.0" },
            {"limegreen", "0.42 1.0 0 1.0" },
            {"blue", "0.2 0.6 1.0 1.0" },
            {"red", "1.0 0.1 0.1 1.0" },
            {"white", "1 1 1 1" },
            {"green", "0.28 0.82 0.28 1.0" },
            {"grey", "0.85 0.85 0.85 1.0" },
            {"lightblue", "0.6 0.86 1.0 1.0" },
            {"buttonbg", "0.2 0.2 0.2 0.7" },
            {"buttongreen", "0.133 0.965 0.133 0.9" },
            {"buttonred", "0.964 0.133 0.133 0.9" },
            {"buttongrey", "0.8 0.8 0.8 0.9" },
            {"CSorange", "1.0 0.64 0.10 1.0" }
        };

        private Dictionary<string, string> TextColors = new Dictionary<string, string>
        {
            {"limegreen", "<color=#6fff00>" }
        };

        #endregion

        #region UI Panels

        void MarketMainScreen(BasePlayer player, int page = 0, Category cat = Category.All)
        {
            CuiHelper.DestroyUi(player, PanelMarket);
            string purchaseimage = imgData.SavedImages[Category.None]["MISSINGIMG"][0].ToString();
            string priceitemimage = imgData.SavedImages[Category.None]["MISSINGIMG"][0].ToString();
            string Background = imgData.SavedBackgrounds["NEVERDELETE"].ToString();
            if (!mData.mode.ContainsKey(player.userID))
                mData.mode.Add(player.userID, false);
            var i = 0;
            var c = 0;
            bool seller = false;
            double count = 0;
            if (cat == Category.All)
                count = mData.MarketListings.Count();
            else count = mData.MarketListings.Where(kvp => kvp.Value.cat == cat).Count();
            var element = UI.CreateElementContainer(PanelMarket, "0 0 0 0", "0.2 0.15", "0.8 0.85", true);
            UI.CreatePanel(ref element, PanelMarket, "0 0 0 0", "0 0", "1 1");
            int entriesallowed = 9;
            double remainingentries = count - (page * (entriesallowed - 1));
            double totalpages = (Math.Floor(count / (entriesallowed - 1)));
            if (mData.mode[player.userID] == false)
            {
                if (mData.background.ContainsKey(player.userID))
                    if (imgData.SavedBackgrounds.ContainsKey(mData.background[player.userID]))
                        if (imgData.SavedBackgrounds[mData.background[player.userID]].ToString() != mData.background[player.userID])
                            Background = imgData.SavedBackgrounds[mData.background[player.userID]].ToString();
                UI.LoadImage(ref element, PanelMarket, Background, "0 0", "1 1");
                if (page <= totalpages - 1)
                {
                    UI.LoadImage(ref element, PanelMarket, imgData.SavedImages[Category.None]["LAST"][0].ToString(), "0.8 0.02", "0.85 0.075");
                    UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 18, "0.8 0.02", "0.85 0.075", $"UI_MarketMainScreen {totalpages} {Enum.GetName(typeof(Category), cat)}");
                }
                if (remainingentries > entriesallowed)
                {
                    UI.LoadImage(ref element, PanelMarket, imgData.SavedImages[Category.None]["NEXT"][0].ToString(), "0.74 0.02", "0.79 0.075");
                    UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 18, "0.74 0.02", "0.79 0.075", $"UI_MarketMainScreen {page + 1} {Enum.GetName(typeof(Category), cat)}");
                }
                if (page > 0)
                {
                    UI.LoadImage(ref element, PanelMarket, imgData.SavedImages[Category.None]["BACK"][0].ToString(), "0.68 0.02", "0.73 0.075");
                    UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 18, "0.68 0.02", "0.73 0.075", $"UI_MarketMainScreen {page - 1} {Enum.GetName(typeof(Category), cat)}");
                }
                if (page > 1)
                {
                    UI.LoadImage(ref element, PanelMarket, imgData.SavedImages[Category.None]["FIRST"][0].ToString(), "0.62 0.02", "0.67 0.075");
                    UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 18, "0.62 0.02", "0.67 0.075", $"UI_MarketMainScreen {0} {Enum.GetName(typeof(Category), cat)}");
                }

                //UI.CreateLabel(ref element, PanelMarket, UIColors["dark"], GetLang("Filters"), 22, "0.14 0.08", "0.24 0.14");
                foreach (Category ct in Enum.GetValues(typeof(Category)))
                {
                    var loc = FilterButton(c);
                    if (ct != Category.Extra && ct != Category.None)
                    {
                        if (cat == ct)
                        {
                            UI.LoadImage(ref element, PanelMarket, imgData.SavedImages[Category.None]["UFILTER"][0].ToString(), $"{loc[0]} {loc[1]}", $"{loc[2]} {loc[3]}");
                            UI.CreateLabel(ref element, PanelMarket, UIColors["dark"], Enum.GetName(typeof(Category), ct), 12, $"{loc[0]} {loc[1]}", $"{loc[2]} {loc[3]}", TextAnchor.MiddleCenter);
                            UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 12, $"{loc[0]} {loc[1]}", $"{loc[2]} {loc[3]}", $"UI_MarketMainScreen {0} {Enum.GetName(typeof(Category), ct)}");
                            c++;
                        }
                        else
                        {
                            UI.LoadImage(ref element, PanelMarket, imgData.SavedImages[Category.None]["OFILTER"][0].ToString(), $"{loc[0]} {loc[1]}", $"{loc[2]} {loc[3]}");
                            UI.CreateLabel(ref element, PanelMarket, UIColors["dark"], Enum.GetName(typeof(Category), ct), 12, $"{loc[0]} {loc[1]}", $"{loc[2]} {loc[3]}", TextAnchor.MiddleCenter);
                            UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 12, $"{loc[0]} {loc[1]}", $"{loc[2]} {loc[3]}", $"UI_MarketMainScreen {0} {Enum.GetName(typeof(Category), ct)}");
                            c++;
                        }
                    }
                }
                UI.LoadImage(ref element, PanelMarket, imgData.SavedImages[Category.Building]["box.wooden.large"][0].ToString(), $"0.05 0.9", "0.15 1");
                UI.CreateLabel(ref element, PanelMarket, UIColors["dark"], "", 12, $"0.05 0.9", "0.15 1", TextAnchor.MiddleCenter);
                if (!SettingBox.Contains(player.userID))
                    UI.CreateButton(ref element, PanelMarket, "0 0 0 0", GetLang("TradeBoxAssignment"), 12, $"0.05 0.9", "0.15 1", $"UI_SetBoxMode");
                else
                    UI.CreateButton(ref element, PanelMarket, "0 0 0 0", GetLang("TradeBoxAssignment"), 12, $"0.05 0.9", "0.15 1", $"UI_CancelTradeBox");



                UI.LoadImage(ref element, PanelMarket, imgData.SavedImages[Category.None]["SELL"][0].ToString(), $"0.35 0.9", "0.65 1.0");
                UI.CreateLabel(ref element, PanelMarket, UIColors["dark"], GetLang("ListItem"), 12, $"0.35 0.9", "0.65 1.0", TextAnchor.MiddleCenter);
                UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 12, $"0.35 0.9", "0.65 1.0", $"UI_MarketSellScreen {0}");

                if (mData.mode[player.userID] == false)
                {
                    UI.LoadImage(ref element, PanelMarket, imgData.SavedImages[Category.None]["OFILTER"][0].ToString(), "0.66 0.9", "0.75 1");
                    UI.CreateLabel(ref element, PanelMarket, UIColors["dark"], GetLang("ChangeMode"), 12, "0.66 0.9", "0.75 1", TextAnchor.MiddleCenter);
                    UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 12, "0.66 0.9", "0.75 1", $"UI_Mode {1}");
                }
                else
                {
                    UI.LoadImage(ref element, PanelMarket, imgData.SavedImages[Category.None]["UFILTER"][0].ToString(), "0.66 0.9", "0.75 1");
                    UI.CreateLabel(ref element, PanelMarket, UIColors["dark"], GetLang("ChangeMode"), 12, "0.66 0.9", "0.75 1", TextAnchor.MiddleCenter);
                    UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 12, "0.66 0.9", "0.75 1", $"UI_Mode {0}");
                }

                UI.LoadImage(ref element, PanelMarket, imgData.SavedImages[Category.None]["OFILTER"][0].ToString(), "0.76 0.9", "0.86 1");
                UI.CreateLabel(ref element, PanelMarket, UIColors["dark"], GetLang("ChangeTheme"), 12, "0.76 0.9", "0.86 1", TextAnchor.MiddleCenter);
                UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 12, "0.76 0.9", "0.86 1", $"UI_MarketBackgroundMenu {0}");

                if (isAuth(player))
                {
                    UI.LoadImage(ref element, PanelMarket, imgData.SavedImages[Category.None]["UFILTER"][0].ToString(), "0.87 0.9", "0.97 1");
                    UI.CreateLabel(ref element, PanelMarket, UIColors["dark"], GetLang("AdminPanel"), 12, "0.87 0.9", "0.97 1", TextAnchor.MiddleCenter);
                    UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 12, "0.87 0.9", "0.97 1", $"UI_AdminPanel");
                }
                int shownentries = page * entriesallowed;
                int n = 0;
                if (cat == Category.All)
                {
                    foreach (var item in mData.MarketListings)
                    {
                        seller = false;
                        i++;
                        if (i < shownentries + 1) continue;
                        else if (i <= shownentries + entriesallowed)
                        {
                            if (item.Value.cat != Category.None && item.Value.cat != Category.Extra)
                            {
                                if (imgData.SavedImages[item.Value.cat].ContainsKey(item.Value.shortname))
                                {
                                    if (imgData.SavedImages[item.Value.cat][item.Value.shortname].ContainsKey(item.Value.skin))
                                        purchaseimage = imgData.SavedImages[item.Value.cat][item.Value.shortname][item.Value.skin].ToString();
                                    else
                                        purchaseimage = imgData.SavedImages[item.Value.cat][item.Value.shortname][0].ToString();
                                }
                            }
                            if (item.Value.pricecat != Category.None && item.Value.pricecat != Category.Extra)
                            {
                                if (imgData.SavedImages[item.Value.pricecat].ContainsKey(item.Value.priceItemshortname))
                                {
                                    if (imgData.SavedImages[item.Value.pricecat][item.Value.priceItemshortname].ContainsKey(0))
                                        priceitemimage = imgData.SavedImages[item.Value.pricecat][item.Value.priceItemshortname][0].ToString();
                                    else
                                        priceitemimage = imgData.SavedImages[item.Value.pricecat][item.Value.priceItemshortname][0].ToString();
                                }
                            }
                            if (item.Value.seller == player.userID)
                            {
                                seller = true;
                            }
                            CreateMarketListingButton(ref element, PanelMarket, item.Value, purchaseimage, priceitemimage, seller, n);

                            n++;
                        }
                    }
                }
                else
                    foreach (var item in mData.MarketListings.Where(kvp => kvp.Value.cat == cat))
                    {
                        seller = false;
                        i++;
                        if (i < shownentries + 1) continue;
                        else if (i <= shownentries + entriesallowed)
                        {
                            if (item.Value.cat != Category.None && item.Value.cat != Category.Extra)
                            {
                                if (imgData.SavedImages[item.Value.cat].ContainsKey(item.Value.shortname))
                                {
                                    if (imgData.SavedImages[item.Value.cat][item.Value.shortname].ContainsKey(item.Value.skin))
                                        purchaseimage = imgData.SavedImages[item.Value.cat][item.Value.shortname][item.Value.skin].ToString();
                                    else
                                        purchaseimage = imgData.SavedImages[item.Value.cat][item.Value.shortname][0].ToString();
                                }
                            }

                            if (item.Value.pricecat != Category.None && item.Value.pricecat != Category.Extra)
                            {
                                if (imgData.SavedImages[item.Value.pricecat].ContainsKey(item.Value.priceItemshortname))
                                {
                                    if (imgData.SavedImages[item.Value.pricecat][item.Value.priceItemshortname].ContainsKey(0))
                                        priceitemimage = imgData.SavedImages[item.Value.pricecat][item.Value.priceItemshortname][0].ToString();
                                    else
                                        priceitemimage = imgData.SavedImages[item.Value.pricecat][item.Value.priceItemshortname][0].ToString();
                                }
                            }
                            if (item.Value.seller == player.userID)
                            {
                                seller = true;
                            }
                            CreateMarketListingButton(ref element, PanelMarket, item.Value, purchaseimage, priceitemimage, seller, n);
                            n++;
                        }
                    }
            }
            else if (mData.mode[player.userID] == true)
            {
                UI.CreatePanel(ref element, PanelMarket, UIColors["dark"], "0. 0", "1 1");
                if (page <= totalpages - 1)
                {
                    UI.CreateButton(ref element, PanelMarket, UIColors["header"], GetLang("Last"), 18, "0.8 0.02", "0.85 0.075", $"UI_MarketMainScreen {totalpages} {Enum.GetName(typeof(Category), cat)}");
                }
                if (remainingentries > entriesallowed)
                {
                    UI.CreateButton(ref element, PanelMarket, UIColors["header"], GetLang("Next"), 18, "0.74 0.02", "0.79 0.075", $"UI_MarketMainScreen {page + 1} {Enum.GetName(typeof(Category), cat)}");
                }
                if (page > 0)
                {
                    UI.CreateButton(ref element, PanelMarket, UIColors["header"], GetLang("Back"), 18, "0.68 0.02", "0.73 0.075", $"UI_MarketMainScreen {page - 1} {Enum.GetName(typeof(Category), cat)}");
                }
                if (page > 1)
                {
                    UI.CreateButton(ref element, PanelMarket, UIColors["header"], GetLang("First"), 18, "0.62 0.02", "0.67 0.075", $"UI_MarketMainScreen {0} {Enum.GetName(typeof(Category), cat)}");
                }

                foreach (Category ct in Enum.GetValues(typeof(Category)))
                {
                    var loc = FilterButton(c);
                    if (ct != Category.Extra && ct != Category.None)
                    {
                        if (cat == ct)
                        {
                            UI.CreateButton(ref element, PanelMarket, UIColors["red"], Enum.GetName(typeof(Category), ct), 12, $"{loc[0]} {loc[1] + .02f}", $"{loc[2]} {loc[3] + .02f}", $"UI_MarketMainScreen {0} {Enum.GetName(typeof(Category), ct)}");
                            c++;
                        }
                        else
                        {
                            UI.CreateButton(ref element, PanelMarket, UIColors["header"], Enum.GetName(typeof(Category), ct), 12, $"{loc[0]} {loc[1] + .02f}", $"{loc[2]} {loc[3] + .02f}", $"UI_MarketMainScreen {0} {Enum.GetName(typeof(Category), ct)}");
                            c++;
                        }
                    }
                }
                if (!SettingBox.Contains(player.userID))
                    UI.CreateButton(ref element, PanelMarket, UIColors["header"], GetLang("TradeBoxAssignment"), 12, $"0.05 0.92", "0.15 .98", $"UI_SetBoxMode");
                else
                    UI.CreateButton(ref element, PanelMarket, UIColors["red"], GetLang("TradeBoxAssignment"), 12, $"0.05 0.92", "0.15 .98", $"UI_CancelTradeBox");



                UI.CreateButton(ref element, PanelMarket, UIColors["header"], GetLang("ListItem"), 12, $"0.35 0.92", "0.65 .98", $"UI_MarketSellScreen {0}");

                if (mData.mode[player.userID] == false)
                {
                    UI.CreateButton(ref element, PanelMarket, UIColors["header"], GetLang("ChangeMode"), 12, "0.66 0.92", "0.75 .98", $"UI_Mode {1}");
                }
                else
                {
                    UI.CreateButton(ref element, PanelMarket, UIColors["header"], GetLang("ChangeMode"), 12, "0.66 0.92", "0.75 .98", $"UI_Mode {0}");
                }

                UI.CreateButton(ref element, PanelMarket, UIColors["header"], GetLang("ChangeTheme"), 12, "0.76 0.92", "0.86 .98", $"UI_MarketBackgroundMenu {0}");

                if (isAuth(player))
                {
                    UI.CreateButton(ref element, PanelMarket, UIColors["header"], GetLang("AdminPanel"), 12, "0.87 0.92", "0.97 .98", $"UI_AdminPanel");
                }
                int shownentries = page * entriesallowed;
                int n = 0;
                if (cat == Category.All)
                {
                    foreach (var item in mData.MarketListings)
                    {
                        seller = false;
                        i++;
                        if (i < shownentries + 1) continue;
                        else if (i <= shownentries + entriesallowed)
                        {
                            if (item.Value.cat != Category.None && item.Value.cat != Category.Extra)
                            {
                                if (imgData.SavedImages[item.Value.cat].ContainsKey(item.Value.shortname))
                                {
                                    if (imgData.SavedImages[item.Value.cat][item.Value.shortname].ContainsKey(item.Value.skin))
                                        purchaseimage = imgData.SavedImages[item.Value.cat][item.Value.shortname][item.Value.skin].ToString();
                                    else
                                        purchaseimage = imgData.SavedImages[item.Value.cat][item.Value.shortname][0].ToString();
                                }
                            }
                            if (item.Value.pricecat != Category.None && item.Value.pricecat != Category.Extra)
                            {
                                if (imgData.SavedImages[item.Value.pricecat].ContainsKey(item.Value.priceItemshortname))
                                {
                                    if (imgData.SavedImages[item.Value.pricecat][item.Value.priceItemshortname].ContainsKey(0))
                                        priceitemimage = imgData.SavedImages[item.Value.pricecat][item.Value.priceItemshortname][0].ToString();
                                    else
                                        priceitemimage = imgData.SavedImages[item.Value.pricecat][item.Value.priceItemshortname][0].ToString();
                                }
                            }
                            if (item.Value.seller == player.userID)
                            {
                                seller = true;
                            }
                            CreateMarketListingButtonSimple(ref element, PanelMarket, item.Value, purchaseimage, priceitemimage, seller, n);

                            n++;
                        }
                    }
                }
                else
                    foreach (var item in mData.MarketListings.Where(kvp => kvp.Value.cat == cat))
                    {
                        seller = false;
                        i++;
                        if (i < shownentries + 1) continue;
                        else if (i <= shownentries + entriesallowed)
                        {
                            if (item.Value.cat != Category.None && item.Value.cat != Category.Extra)
                            {
                                if (imgData.SavedImages[item.Value.cat].ContainsKey(item.Value.shortname))
                                {
                                    if (imgData.SavedImages[item.Value.cat][item.Value.shortname].ContainsKey(item.Value.skin))
                                        purchaseimage = imgData.SavedImages[item.Value.cat][item.Value.shortname][item.Value.skin].ToString();
                                    else
                                        purchaseimage = imgData.SavedImages[item.Value.cat][item.Value.shortname][0].ToString();
                                }
                            }

                            if (item.Value.pricecat != Category.None && item.Value.pricecat != Category.Extra)
                            {
                                if (imgData.SavedImages[item.Value.pricecat].ContainsKey(item.Value.priceItemshortname))
                                {
                                    if (imgData.SavedImages[item.Value.pricecat][item.Value.priceItemshortname].ContainsKey(0))
                                        priceitemimage = imgData.SavedImages[item.Value.pricecat][item.Value.priceItemshortname][0].ToString();
                                    else
                                        priceitemimage = imgData.SavedImages[item.Value.pricecat][item.Value.priceItemshortname][0].ToString();
                                }
                            }
                            if (item.Value.seller == player.userID)
                            {
                                seller = true;
                            }
                            CreateMarketListingButtonSimple(ref element, PanelMarket, item.Value, purchaseimage, priceitemimage, seller, n);
                            n++;
                        }
                    }
            }
            UI.CreateButton(ref element, PanelMarket, UIColors["buttonred"], GetLang("Close"), 16, "0.87 0.02", "0.97 0.075", $"UI_DestroyMarketPanel");
            CuiHelper.AddUi(player, element);
        }

        private void CreateMarketListingButton(ref CuiElementContainer container, string panelName, AMItem item, string listingimg, string costimg, bool seller, int num)
        {
            var pos = MarketEntryPos(num);
            var name = item.shortname;
            if (configData.UseUniqueNames && item.name != "")
                name = item.name;
            else if (item.shortname == "SR")
                name = "SR Points";
            UI.CreatePanel(ref container, panelName, UIColors["header"], $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");

            //SALE ITEM
            UI.LoadImage(ref container, panelName, listingimg, $"{pos[0] + 0.001f} {pos[3] - 0.125f}", $"{pos[0] + 0.1f} {pos[3] - 0.005f}");
            UI.CreateLabel(ref container, panelName, UIColors["dark"], name, 12, $"{pos[0] + .1f} {pos[3] - .04f}", $"{pos[2] - .001f} {pos[3] - .001f}", TextAnchor.MiddleLeft);
            UI.CreateLabel(ref container, panelName, UIColors["dark"], GetMSG("Amount", item.amount.ToString()), 12, $"{pos[0] + .1f} {pos[3] - .07f}", $"{pos[2] - .001f} {pos[3] - .041f}", TextAnchor.MiddleLeft);

            if (item.cat != Category.Money)
            {
                Item actual = BuildCostItems(item.shortname, 1);
                if (actual.condition != 0)
                {
                    var percent = System.Convert.ToDouble(item.condition / actual.condition);
                    var xMax = (pos[0] + .1f) + (.175f * percent);
                    var ymin = pos[3] - .11f;
                    var ymax = pos[3] - .08f;
                    UI.CreatePanel(ref container, panelName, UIColors["buttonbg"], $"{pos[0] + .1f} {ymin}", $"{pos[0] + .275f} {ymax}");
                    if (percent * 100 > 75)
                        UI.CreatePanel(ref container, panelName, UIColors["green"], $"{pos[0] + .1f} {ymin}", $"{xMax} {ymax}");
                    else if (percent * 100 > 25 && percent * 100 < 76)
                        UI.CreatePanel(ref container, panelName, UIColors["yellow"], $"{pos[0] + .1f} {ymin}", $"{xMax} {ymax}");
                    else if (percent * 100 > 0 && percent * 100 < 26)
                        UI.CreatePanel(ref container, panelName, UIColors["red"], $"{pos[0] + .1f} {ymin}", $"{xMax} {ymax}");
                    UI.CreateLabel(ref container, panelName, "1 1 1 1", GetMSG("ItemCondition", Math.Round(percent * 100).ToString()), 9, $"{pos[0] + .1f} {ymin}", $"{pos[0] + .275f} {ymax}", TextAnchor.MiddleLeft);
                }
            }

            UI.LoadImage(ref container, PanelMarket, imgData.SavedImages[Category.None]["ARROW"][0].ToString(), $"{pos[0] + .08f} {pos[1] + .07f}", $"{pos[0] + .2f} {pos[1] + .135f}");
            UI.CreateLabel(ref container, panelName, UIColors["dark"], GetLang("InExchange"), 14, $"{ pos[0] + .08f} {pos[1] + .07f}", $"{pos[0] + .2f} {pos[1] + .135f}", TextAnchor.UpperCenter);

            //COST ITEM
            if (item.priceItemshortname == "SR")
                name = "SR Points";
            else name = item.priceItemshortname;
            UI.LoadImage(ref container, panelName, costimg, $"{pos[2] - 0.125f} {pos[1] + 0.01f}", $"{pos[2] - 0.005f} {pos[1] + 0.125f}");
            UI.CreateLabel(ref container, panelName, UIColors["dark"], name, 12, $"{pos[0] + 0.005f} {pos[1] + 0.03f}", $"{pos[0] + 0.175f} {pos[1] + 0.06f}", TextAnchor.MiddleRight);
            UI.CreateLabel(ref container, panelName, UIColors["dark"], GetMSG("Amount", item.priceAmount.ToString()), 12, $"{pos[0] + 0.005f} {pos[1] + 0.005f}", $"{pos[0] + 0.175f} {pos[1] + 0.0299f}", TextAnchor.MiddleRight);
            if (mData.names.ContainsKey(item.seller))
                name = mData.names[item.seller];
            else name = "NONE";
            UI.CreateLabel(ref container, panelName, UIColors["dark"], GetMSG("Seller", name), 12, $"{pos[0] + .001f} {pos[3] - .2f}", $"{pos[2] - .1f} {pos[3] - .14f}", TextAnchor.MiddleLeft);

            if (seller == true)
            {
                UI.LoadImage(ref container, PanelMarket, imgData.SavedImages[Category.None]["UFILTER"][0].ToString(), $"{pos[0] + .02f} {pos[3] - .15f}", $"{pos[0] + .08f} {pos[3] - .1f}");
                UI.CreateLabel(ref container, panelName, UIColors["dark"], GetLang("removelisting"), 10, $"{pos[0] + .02f} {pos[3] - .15f}", $"{pos[0] + .08f} {pos[3] - .1f}", TextAnchor.MiddleCenter);
                UI.CreateButton(ref container, panelName, "0 0 0 0", "", 40, $"{pos[0] + .02f} {pos[3] - .15f}", $"{pos[0] + .08f} {pos[3] - .1f}", $"UI_RemoveListing {item.ID}");
            }
            else
            {
                UI.CreateButton(ref container, panelName, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_BuyConfirm {item.ID}");
            }
        }

        private void CreateMarketListingButtonSimple(ref CuiElementContainer container, string panelName, AMItem item, string listingimg, string costimg, bool seller, int num)
        {
            var pos = MarketEntryPos(num);
            var name = item.shortname;
            if (configData.UseUniqueNames && item.name != "")
                name = item.name;
            else if (item.shortname == "SR")
                name = "SR Points";
            UI.CreatePanel(ref container, panelName, UIColors["white"], $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");

            //SALE ITEM
            UI.LoadImage(ref container, panelName, listingimg, $"{pos[0] + 0.001f} {pos[3] - 0.125f}", $"{pos[0] + 0.1f} {pos[3] - 0.005f}");
            UI.CreateLabel(ref container, panelName, UIColors["dark"], name, 12, $"{pos[0] + .1f} {pos[3] - .04f}", $"{pos[2] - .001f} {pos[3] - .001f}", TextAnchor.MiddleLeft);
            UI.CreateLabel(ref container, panelName, UIColors["dark"], GetMSG("Amount", item.amount.ToString()), 12, $"{pos[0] + .1f} {pos[3] - .07f}", $"{pos[2] - .001f} {pos[3] - .041f}", TextAnchor.MiddleLeft);

            if (item.cat != Category.Money)
            {
                Item actual = BuildCostItems(item.shortname, 1);
                if (actual.condition != 0)
                {
                    var percent = System.Convert.ToDouble(item.condition / actual.condition);
                    //var xMax = (pos[0] + .1f) + (.175f * percent);
                    var ymin = pos[3] - .12f;
                    var ymax = pos[3] - .07f;
                    if (percent * 100 > 75)
                    UI.CreateLabel(ref container, panelName, UIColors["green"], GetMSG("ItemCondition", Math.Round(percent * 100).ToString()), 12, $"{pos[0] + .1f} {ymin}", $"{pos[0] + .275f} {ymax}", TextAnchor.MiddleLeft);
                    else if (percent * 100 > 25 && percent * 100 < 76)
                        UI.CreateLabel(ref container, panelName, UIColors["yellow"], GetMSG("ItemCondition", Math.Round(percent * 100).ToString()), 12, $"{pos[0] + .1f} {ymin}", $"{pos[0] + .275f} {ymax}", TextAnchor.MiddleLeft);
                    else if (percent * 100 > 0 && percent * 100 < 26)
                        UI.CreateLabel(ref container, panelName, UIColors["red"], GetMSG("ItemCondition", Math.Round(percent * 100).ToString()), 12, $"{pos[0] + .1f} {ymin}", $"{pos[0] + .275f} {ymax}", TextAnchor.MiddleLeft);
                }
            }

            UI.CreateLabel(ref container, panelName, UIColors["dark"], GetLang("InExchange"), 14, $"{ pos[0] + .08f} {pos[1] + .07f}", $"{pos[0] + .2f} {pos[1] + .135f}", TextAnchor.UpperCenter);

            //COST ITEM
            if (item.priceItemshortname == "SR")
                name = "SR Points";
            else name = item.priceItemshortname;
            UI.LoadImage(ref container, panelName, costimg, $"{pos[2] - 0.125f} {pos[1] + 0.01f}", $"{pos[2] - 0.005f} {pos[1] + 0.125f}");
            UI.CreateLabel(ref container, panelName, UIColors["dark"], name, 12, $"{pos[0] + 0.005f} {pos[1] + 0.03f}", $"{pos[0] + 0.175f} {pos[1] + 0.06f}", TextAnchor.MiddleRight);
            UI.CreateLabel(ref container, panelName, UIColors["dark"], GetMSG("Amount", item.priceAmount.ToString()), 12, $"{pos[0] + 0.005f} {pos[1] + 0.005f}", $"{pos[0] + 0.175f} {pos[1] + 0.0299f}", TextAnchor.MiddleRight);
            if (mData.names.ContainsKey(item.seller))
                name = mData.names[item.seller];
            else name = "NONE";
            UI.CreateLabel(ref container, panelName, UIColors["dark"], GetMSG("Seller", name), 12, $"{pos[0] + .001f} {pos[3] - .2f}", $"{pos[2] - .1f} {pos[3] - .14f}", TextAnchor.MiddleLeft);

            if (seller == true)
            {
                UI.LoadImage(ref container, PanelMarket, imgData.SavedImages[Category.None]["UFILTER"][0].ToString(), $"{pos[0] + .02f} {pos[3] - .15f}", $"{pos[0] + .08f} {pos[3] - .1f}");
                UI.CreateLabel(ref container, panelName, UIColors["dark"], GetLang("removelisting"), 10, $"{pos[0] + .02f} {pos[3] - .15f}", $"{pos[0] + .08f} {pos[3] - .1f}", TextAnchor.MiddleCenter);
                UI.CreateButton(ref container, panelName, "0 0 0 0", "", 40, $"{pos[0] + .02f} {pos[3] - .15f}", $"{pos[0] + .08f} {pos[3] - .1f}", $"UI_RemoveListing {item.ID}");
            }
            else
            {
                UI.CreateButton(ref container, panelName, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_BuyConfirm {item.ID}");
            }
        }

        void MarketSellScreen(BasePlayer player, int page = 0)
        {
            CuiHelper.DestroyUi(player, PanelMarket);
            if (GetTradeBox(player.userID) == null)
            {
                GetSendMSG(player, "YourNoTradeBoxBuying");
                MarketMainScreen(player);
                return;
            }
            if (GetTradeBoxContents(player) == false)
            {
                MarketMainScreen(player);
                return;
            }
            float[] pos;
            var i = 0;
            var image = "";
            var element = UI.CreateElementContainer(PanelMarket, "0 0 0 0", "0.275 0.25", "0.725 0.75", true);
            //var count = PlayerBoxContents[player.userID].Count();
            UI.CreateLabel(ref element, PanelMarket, UIColors["black"], $"{TextColors["limegreen"]} {GetLang("SelectItemToSell")}", 20, "0.05 .9", "1 1", TextAnchor.MiddleCenter);
            if (GetTradeBoxContents(player) != false)
            {
                foreach (AMItem item in PlayerBoxContents[player.userID].Where(bl => !mData.Blacklist.Contains(bl.shortname) && !mData.MarketListings.ContainsKey(bl.ID)))
                {
                    pos = CalcButtonPos(i);
                    if (item.cat != Category.None && item.cat != Category.Extra)
                    {
                        if (imgData.SavedImages[item.cat].ContainsKey(item.shortname))
                        {
                            if (imgData.SavedImages[item.cat][item.shortname].ContainsKey(item.skin))
                            {
                                image = imgData.SavedImages[item.cat][item.shortname][item.skin].ToString();
                                UI.LoadImage(ref element, PanelMarket, image, $"{pos[0] + 0.005f} {pos[1] + 0.005f}", $"{pos[2] - 0.005f} {pos[3] - 0.005f}");
                            }
                        }
                    }
                    else
                    {
                        image = imgData.SavedImages[Category.None]["MISSINGIMG"][0].ToString();
                        UI.LoadImage(ref element, PanelMarket, image, $"{pos[0] + 0.005f} {pos[1] + 0.005f}", $"{pos[2] - 0.005f} {pos[3] - 0.005f}");
                        UI.CreateLabel(ref element, PanelMarket, UIColors["limegreen"], item.shortname.ToUpper(), 16, $"{pos[0] + 0.005f} {pos[1] + 0.005f}", $"{pos[2] - 0.005f} {pos[3] - 0.005f}", TextAnchor.LowerCenter);
                    }
                    if (item.amount > 9999)
                        UI.CreateLabel(ref element, PanelMarket, UIColors["limegreen"], item.amount.ToString(), 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", TextAnchor.MiddleCenter);

                    else if (item.amount > 1)
                        UI.CreateLabel(ref element, PanelMarket, UIColors["limegreen"], item.amount.ToString(), 16, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", TextAnchor.MiddleCenter);
                    UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_SelectSalesItem {item.ID}"); i++;
                }
            }
            if (configData.ServerRewards && ServerRewards)
            {
                if (!mData.Blacklist.Contains("SR"))
                {
                    if (CheckPoints(player.userID) is int)
                        if ((int)CheckPoints(player.userID) > 0)
                        {
                            pos = CalcButtonPos(i);
                            UI.CreatePanel(ref element, PanelMarket, "1 1 1 1", $"{pos[0] + 0.005f} {pos[1] + 0.005f}", $"{pos[2] - 0.005f} {pos[3] - 0.005f}");
                            UI.LoadImage(ref element, PanelMarket, imgData.SavedImages[Category.Money]["SR"][0].ToString(), $"{pos[0] + 0.005f} {pos[1] + 0.005f}", $"{pos[2] - 0.005f} {pos[3] - 0.005f}");
                            UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_SelectSR"); i++;
                        }
                }
            }
            UI.CreateButton(ref element, PanelMarket, UIColors["buttonred"], GetLang("Back"), 16, "0.03 0.02", "0.13 0.075", $"UI_MarketMainScreen {0} {Enum.GetName(typeof(Category), Category.All)}");
            CuiHelper.AddUi(player, element);
        }

        private void SellItems(BasePlayer player, int step = 0, int page = 0)
        {
            AMItem SalesItem;

            var i = 0;
            string image = "";
            var name = "";
            var element = UI.CreateElementContainer(PanelMarket, "0 0 0 0", "0.3 0.3", "0.7 0.9");
            switch (step)
            {
                case 0:
                    CuiHelper.DestroyUi(player, PanelMarket);
                    SalesItem = SalesItemPrep[player.userID];
                    if (SalesItem == null) return;
                    UI.CreateLabel(ref element, PanelMarket, UIColors["black"], $"{TextColors["limegreen"]} {GetMSG("SetName", SalesItem.shortname)}", 20, "0.05 0", ".95 1", TextAnchor.MiddleCenter);
                    break;
                case 1:
                    CuiHelper.DestroyUi(player, PanelMarket);
                    SalesItem = SalesItemPrep[player.userID];
                    if (SalesItem == null) return;
                    if (configData.UseUniqueNames && SalesItem.name != "")
                        name = SalesItem.name;
                    else name = SalesItem.shortname;
                    double count = 0;
                    foreach (var item in ItemManager.itemList.Where(a => !mData.Blacklist.Contains(a.shortname)))
                        count++;
                    UI.CreatePanel(ref element, PanelMarket, "0 0 0 0", $".0001 0.0001", $"0.0002 0.0002", true);
                    UI.CreateLabel(ref element, PanelMarket, UIColors["black"], $"{TextColors["limegreen"]} {GetMSG("SetpriceItemshortname", name)}", 20, "0.05 .95", ".95 1", TextAnchor.MiddleCenter);
                    double entriesallowed = 30;
                    double remainingentries = count - (page * (entriesallowed - 1));
                    double totalpages = (Math.Floor(count / (entriesallowed - 1)));
                    {
                        if (page <= totalpages - 1)
                        {
                            UI.LoadImage(ref element, PanelMarket, imgData.SavedImages[Category.None]["LAST"][0].ToString(), "0.8 0.02", "0.85 0.075");
                            UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 16, "0.8 0.02", "0.85 0.075", $"UI_SellItems {totalpages}");
                        }
                        if (remainingentries > entriesallowed)
                        {
                            UI.LoadImage(ref element, PanelMarket, imgData.SavedImages[Category.None]["NEXT"][0].ToString(), "0.74 0.02", "0.79 0.075");
                            UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 16, "0.74 0.02", "0.79 0.075", $"UI_SellItems {page + 1}");
                        }
                        if (page > 0)
                        {
                            UI.LoadImage(ref element, PanelMarket, imgData.SavedImages[Category.None]["BACK"][0].ToString(), "0.68 0.02", "0.73 0.075");
                            UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 16, "0.68 0.02", "0.73 0.075", $"UI_SellItems {page - 1}");
                        }
                        if (page > 1)
                        {
                            UI.LoadImage(ref element, PanelMarket, imgData.SavedImages[Category.None]["FIRST"][0].ToString(), "0.62 0.02", "0.67 0.075");
                            UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 16, "0.62 0.02", "0.67 0.075", $"UI_SellItems {0}");
                        }
                    }
                    int n = 0;
                    var pos = CalcButtonPos(n);
                    double shownentries = page * entriesallowed;
                    if (page == 0)
                    {
                        if (configData.ServerRewards == true && ServerRewards)
                        {
                            UI.LoadImage(ref element, PanelMarket, imgData.SavedImages[Category.Money]["SR"][0].ToString(), $"{pos[0] + 0.005f} {pos[1] + 0.005f}", $"{pos[2] - 0.005f} {pos[3] - 0.005f}");
                            UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_SelectpriceItemshortname SR");
                            n++;
                            i++;
                        }
                    }
                    foreach (var item in ItemManager.itemList.Where(a => !mData.Blacklist.Contains(a.shortname)))
                    {
                        i++;
                        image = imgData.SavedImages[Category.None]["MISSINGIMG"][0].ToString();
                        if (i < shownentries + 1) continue;
                        else if (i <= shownentries + entriesallowed)
                        {
                            pos = CalcButtonPos(n);
                            foreach (var category in imgData.SavedImages)
                            {
                                if (category.Value.ContainsKey(item.shortname))
                                    foreach (var entry in category.Value.Where(e => e.Key == item.shortname))
                                    {
                                        image = imgData.SavedImages[category.Key][entry.Key][0].ToString();
                                        break;
                                    }
                                else continue;
                            }
                            UI.LoadImage(ref element, PanelMarket, image, $"{pos[0] + 0.005f} {pos[1] + 0.005f}", $"{pos[2] - 0.005f} {pos[3] - 0.005f}");
                            if (image == imgData.SavedImages[Category.None]["MISSINGIMG"][0].ToString()) UI.CreateLabel(ref element, PanelMarket, UIColors["limegreen"], item.shortname, 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", TextAnchor.MiddleCenter);
                            UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_SelectpriceItemshortname {item.shortname}");
                            n++;
                        }
                    }
                    UI.CreateButton(ref element, PanelMarket, UIColors["buttonred"], GetLang("Quit"), 16, "0.03 0.02", "0.13 0.075", $"UI_MarketMainScreen {0} {Enum.GetName(typeof(Category), Category.All)}");
                    break;
                default:
                    CuiHelper.DestroyUi(player, PanelMarket);
                    SalesItem = SalesItemPrep[player.userID];
                    if (SalesItem == null) return;
                    if (configData.UseUniqueNames && SalesItem.name != "")
                        name = SalesItem.name;
                    else name = SalesItem.shortname;
                    UI.CreatePanel(ref element, PanelMarket, "0 0 0 0", $".0001 0.0001", $"0.0002 0.0002", true);
                    UI.CreateLabel(ref element, PanelMarket, UIColors["limegreen"], GetLang("NewItemInfo"), 20, "0.05 .8", ".95 .95");
                    string ItemDetails = GetMSG("ItemDetails", SalesItem.amount.ToString(), name, SalesItem.priceAmount.ToString(), SalesItem.priceItemshortname);
                    UI.CreateLabel(ref element, PanelMarket, UIColors["limegreen"], ItemDetails, 20, "0.1 0.1", "0.9 0.65", TextAnchor.MiddleLeft);
                    UI.CreateButton(ref element, PanelMarket, UIColors["buttonbg"], GetLang("ListItem"), 18, "0.2 0.05", "0.4 0.15", $"UI_ListItem", TextAnchor.MiddleCenter);
                    UI.CreateButton(ref element, PanelMarket, UIColors["buttonred"], GetLang("CancelListing"), 18, "0.6 0.05", "0.8 0.15", $"UI_CancelListing");
                    break;
            }
            CuiHelper.AddUi(player, element);
        }

        private void PurchaseConfirmation(BasePlayer player, uint index)
        {
            CuiHelper.DestroyUi(player, PanelPurchase);
            AMItem purchaseitem = mData.MarketListings[index];
            string purchaseimage = imgData.SavedImages[Category.None]["MISSINGIMG"][0].ToString();
            var name = "";
            if (configData.UseUniqueNames && purchaseitem.name != "")
                name = purchaseitem.name;
            else name = purchaseitem.shortname;
            var element = UI.CreateElementContainer(PanelPurchase, UIColors["dark"], "0.425 0.35", "0.575 0.65", true);
            UI.CreatePanel(ref element, PanelPurchase, UIColors["light"], "0.01 0.02", "0.99 0.98");
            UI.CreateLabel(ref element, PanelPurchase, MsgColor, GetMSG("PurchaseConfirmation", name), 20, "0.05 0.75", "0.95 0.95");
            Vector2 position = new Vector2(0.375f, 0.45f);
            Vector2 dimensions = new Vector2(0.25f, 0.25f);
            Vector2 posMin = position;
            Vector2 posMax = posMin + dimensions;
            if (purchaseitem.cat != Category.None && purchaseitem.cat != Category.Extra)
            {
                if (imgData.SavedImages[purchaseitem.cat].ContainsKey(purchaseitem.shortname))
                {
                    if (imgData.SavedImages[purchaseitem.cat][purchaseitem.shortname].ContainsKey(purchaseitem.skin))
                        purchaseimage = imgData.SavedImages[purchaseitem.cat][purchaseitem.shortname][purchaseitem.skin].ToString();
                    else
                        purchaseimage = imgData.SavedImages[purchaseitem.cat][purchaseitem.shortname][0].ToString();
                }
            }
            else UI.CreateLabel(ref element, PanelPurchase, UIColors["limegreen"], purchaseitem.shortname, 14, $"{posMin.x} {posMin.y}", $"{posMax.x} {posMax.y}", TextAnchor.MiddleCenter);
            UI.LoadImage(ref element, PanelPurchase, purchaseimage, $"{posMin.x} {posMin.y}", $"{posMax.x} {posMax.y}");
            if (purchaseitem.amount > 1)
                UI.CreateLabel(ref element, PanelPurchase, UIColors["limegreen"], $"x {purchaseitem.amount}", 14, $"{posMin.x} {posMin.y}", $"{posMax.x} {posMax.y}", TextAnchor.MiddleCenter);
            if (mData.MarketListings[index].cat != Category.Money)
            {
                Item item = BuildCostItems(mData.MarketListings[index].shortname, mData.MarketListings[index].amount);

                if (item.condition != 0)
                {
                    var percent = System.Convert.ToDouble(purchaseitem.condition / item.condition);
                    var xMax = .1f + (0.8f * percent);
                    var ymin = 0.3;
                    var ymax = 0.4;
                    UI.CreatePanel(ref element, PanelPurchase, UIColors["buttonbg"], $"0.1 {ymin}", $"0.9 {ymax}");
                    UI.CreatePanel(ref element, PanelPurchase, UIColors["green"], $"0.1 {ymin}", $"{xMax} {ymax}");
                    UI.CreateLabel(ref element, PanelPurchase, "1 1 1 1", GetMSG("ItemCondition", Math.Round(percent * 100).ToString()), 20, $"0.1 {ymin}", $"0.9 {ymax}", TextAnchor.MiddleLeft);
                }

                UI.CreateButton(ref element, PanelPurchase, UIColors["buttongreen"], GetLang("Yes"), 14, "0.25 0.05", "0.45 0.2", $"UI_ProcessItem {index}");
            }
            else UI.CreateButton(ref element, PanelPurchase, UIColors["buttongreen"], GetLang("Yes"), 14, "0.25 0.05", "0.45 0.2", $"UI_ProcessMoney {index}");
            UI.CreateButton(ref element, PanelPurchase, UIColors["buttonred"], GetLang("No"), 14, "0.55 0.05", "0.75 0.2", $"UI_DestroyPurchaseScreen");
            CuiHelper.AddUi(player, element);
        }

        private void TradeBoxConfirmation(BasePlayer player, uint ID)
        {
            CuiHelper.DestroyUi(player, PanelMarket);
            var element = UI.CreateElementContainer(PanelMarket, UIColors["dark"], "0.425 0.45", "0.575 0.55", true);
            UI.CreatePanel(ref element, PanelMarket, UIColors["light"], "0.01 0.02", "0.99 0.98");
            UI.CreateLabel(ref element, PanelMarket, MsgColor, GetLang("TradeBoxCreation"), 14, "0.05 0.56", "0.95 0.9");
            UI.CreateButton(ref element, PanelMarket, UIColors["buttongreen"], GetLang("Yes"), 14, "0.05 0.25", "0.475 0.55", $"UI_SaveTradeBox {ID}");
            UI.CreateButton(ref element, PanelMarket, UIColors["buttonred"], GetLang("No"), 14, "0.525 0.25", "0.95 0.55", $"UI_CancelTradeBox");
            CuiHelper.AddUi(player, element);
        }

        private void AdminPanel(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelMarket);
            var i = 0;
            var element = UI.CreateElementContainer(PanelMarket, UIColors["dark"], "0.3 0.3", "0.7 0.9", true);
            UI.CreatePanel(ref element, PanelMarket, UIColors["light"], "0.01 0.02", "0.99 0.98");
            UI.CreateLabel(ref element, PanelMarket, MsgColor, GetLang("AdminPanel"), 75, "0.05 0", "0.95 1");
            var loc = CalcButtonPos(i);
            UI.CreateButton(ref element, PanelMarket, UIColors["CSorange"], GetLang("BlackListingADD"), 12, $"{loc[0]} {loc[1]}", $"{loc[2]} {loc[3]}", $"UI_BlackList {0} add"); i++;
            loc = CalcButtonPos(i);
            UI.CreateButton(ref element, PanelMarket, UIColors["CSorange"], GetLang("BlackListingREMOVE"), 12, $"{loc[0]} {loc[1]}", $"{loc[2]} {loc[3]}", $"UI_BlackList {0} remove"); i++;
            UI.CreateButton(ref element, PanelMarket, UIColors["buttonred"], GetLang("Back"), 16, "0.03 0.02", "0.13 0.075", $"UI_MarketMainScreen {0} {Enum.GetName(typeof(Category), Category.All)}");
            CuiHelper.AddUi(player, element);
        }

        private void MarketBackgroundMenu(BasePlayer player, int page = 0)
        {
            CuiHelper.DestroyUi(player, PanelMarket);
            if (!mData.background.ContainsKey(player.userID))
                mData.background.Add(player.userID, "NONE");
            var i = 0;
            var element = UI.CreateElementContainer(PanelMarket, UIColors["dark"], "0.3 0.3", "0.7 0.9", true);
            UI.CreatePanel(ref element, PanelMarket, UIColors["light"], "0.01 0.02", "0.99 0.98");
            UI.CreateLabel(ref element, PanelMarket, MsgColor, GetLang("SelectTheme"), 20, "0 .9", "1 1");
            var count = imgData.SavedBackgrounds.Count();
            double entriesallowed = 30;
            double remainingentries = count - (page * (entriesallowed - 1));
            double totalpages = (Math.Floor(count / (entriesallowed - 1)));
            {
                if (page <= totalpages - 1)
                {
                    UI.LoadImage(ref element, PanelMarket, imgData.SavedImages[Category.None]["LAST"][0].ToString(), "0.8 0.02", "0.85 0.075");
                    UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 16, "0.8 0.02", "0.85 0.075", $"UI_MarketBackgroundMenu {totalpages}");
                }
                if (remainingentries > entriesallowed)
                {
                    UI.LoadImage(ref element, PanelMarket, imgData.SavedImages[Category.None]["NEXT"][0].ToString(), "0.74 0.02", "0.79 0.075");
                    UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 16, "0.74 0.02", "0.79 0.075", $"UI_MarketBackgroundMenu {page + 1}");
                }
                if (page > 0)
                {
                    UI.LoadImage(ref element, PanelMarket, imgData.SavedImages[Category.None]["BACK"][0].ToString(), "0.68 0.02", "0.73 0.075");
                    UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 16, "0.68 0.02", "0.73 0.075", $"UI_MarketBackgroundMenu {page - 1}");
                }
                if (page > 1)
                {
                    UI.LoadImage(ref element, PanelMarket, imgData.SavedImages[Category.None]["FIRST"][0].ToString(), "0.62 0.02", "0.67 0.075");
                    UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 16, "0.62 0.02", "0.67 0.075", $"UI_MarketBackgroundMenu {0}");
                }
            }

            double shownentries = page * entriesallowed;
            int n = 0;
            foreach (var entry in imgData.SavedBackgrounds)
            {
                i++;
                if (i < shownentries + 1) continue;
                else if (i <= shownentries + entriesallowed)
                {
                    var loc = CalcButtonPos(n);
                    if (mData.background[player.userID] != entry.Key)
                    {
                        UI.LoadImage(ref element, PanelMarket, entry.Value.ToString(), $"{loc[0]} {loc[1]}", $"{loc[2]} {loc[3]}");
                        UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 12, $"{loc[0]} {loc[1]}", $"{loc[2]} {loc[3]}", $"UI_ChangeBackground {entry.Key}");
                        n++;
                    }
                }
            }
            UI.CreateButton(ref element, PanelMarket, UIColors["buttonred"], GetLang("Back"), 16, "0.03 0.02", "0.13 0.075", $"UI_MarketMainScreen {0} {Enum.GetName(typeof(Category), Category.All)}");
            CuiHelper.AddUi(player, element);
        }

        private void BlackListing(BasePlayer player, int page = 0, string action = "add")
        {
            CuiHelper.DestroyUi(player, PanelMarket);
            var i = 0;
            string image = "";
            double count = 0;
            var element = UI.CreateElementContainer(PanelMarket, UIColors["dark"], "0.3 0.3", "0.7 0.9", true);
            UI.CreatePanel(ref element, PanelMarket, UIColors["light"], "0.01 0.02", "0.99 0.98");
            int entriesallowed = 30;
            int shownentries = page * entriesallowed;
            int n = 0;
            if (action == "add")
            {
                foreach (var cat in imgData.SavedImages)
                    foreach (var entry in cat.Value)
                        count++;
                UI.CreateLabel(ref element, PanelMarket, UIColors["black"], $"{TextColors["limegreen"]} {GetLang("SelectItemToBlacklist")}", 75, "0.05 0", ".95 1", TextAnchor.MiddleCenter);
                foreach (var category in imgData.SavedImages.Where(kvp => kvp.Key != Category.Extra && kvp.Key != Category.None))
                    foreach (var entry in category.Value.Where(bl => !mData.Blacklist.Contains(bl.Key)).OrderBy(kvp => kvp.Key))
                    {
                        i++;
                        if (i < shownentries + 1) continue;
                        else if (i <= shownentries + entriesallowed)
                        {
                            var pos = CalcButtonPos(n);
                            image = imgData.SavedImages[category.Key][entry.Key][0].ToString();
                            UI.LoadImage(ref element, PanelMarket, image, $"{pos[0] + 0.005f} {pos[1] + 0.005f}", $"{pos[2] - 0.005f} {pos[3] - 0.005f}");
                            UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_BackListItem add {entry.Key}");
                            n++;
                        }
                    }
            }
            else if (action == "remove")
            {
                count = mData.Blacklist.Count();
                UI.CreateLabel(ref element, PanelMarket, UIColors["black"], $"{TextColors["limegreen"]} {GetLang("SelectItemToUnBlacklist")}", 75, "0.05 0", ".95 1", TextAnchor.MiddleCenter);
                foreach (var category in imgData.SavedImages.Where(kvp => kvp.Key != Category.Extra && kvp.Key != Category.None))
                    foreach (var entry in category.Value.Where(bl => mData.Blacklist.Contains(bl.Key)).OrderBy(kvp => kvp.Key))
                    {
                        i++;
                        if (i < shownentries + 1) continue;
                        else if (i <= shownentries + entriesallowed)
                        {
                            var pos = CalcButtonPos(n);
                            image = imgData.SavedImages[category.Key][entry.Key][0].ToString();
                            UI.LoadImage(ref element, PanelMarket, image, $"{pos[0] + 0.005f} {pos[1] + 0.005f}", $"{pos[2] - 0.005f} {pos[3] - 0.005f}");
                            UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_BackListItem remove {entry.Key}");
                            n++;
                        }
                    }
            }
            double remainingentries = count - (page * (entriesallowed - 1));
            double totalpages = (Math.Floor(count / (entriesallowed - 1)));
            {
                if (page <= totalpages - 1)
                    UI.CreateButton(ref element, PanelMarket, UIColors["buttonbg"], GetLang("Last"), 16, "0.87 0.02", "0.97 0.075", $"UI_BlackList {totalpages} {action}");
                if (remainingentries > entriesallowed)
                    UI.CreateButton(ref element, PanelMarket, UIColors["buttonbg"], GetLang("Next"), 16, "0.73 0.02", "0.83 0.075", $"UI_BlackList {page + 1} {action}");
                if (page > 0)
                    UI.CreateButton(ref element, PanelMarket, UIColors["buttonred"], GetLang("Back"), 16, "0.59 0.02", "0.69 0.075", $"UI_BlackList {page - 1} {action}");
                if (page > 1)
                    UI.CreateButton(ref element, PanelMarket, UIColors["buttonred"], GetLang("First"), 16, "0.45 0.02", "0.55 0.075", $"UI_BlackList {0} {action}");
            }
            UI.CreateButton(ref element, PanelMarket, UIColors["buttonred"], GetLang("Back"), 16, "0.03 0.02", "0.13 0.075", $"UI_AdminPanel");
            CuiHelper.AddUi(player, element);
        }

        #endregion

        #region UI Calculations

        private float[] MarketEntryPos(int number)
        {
            Vector2 position = new Vector2(0.03f, 0.66f);
            Vector2 dimensions = new Vector2(0.3f, 0.25f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 3)
            {
                offsetY = (-0.01f - dimensions.y) * number;
            }
            if (number > 2 && number < 6)
            {
                offsetX = 0.315f;
                offsetY = (-0.01f - dimensions.y) * (number - 3);
            }
            if (number > 5 && number < 9)
            {
                offsetX = 0.315f * 2;
                offsetY = (-0.01f - dimensions.y) * (number - 6);
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private float[] FilterButton(int number)
        {
            Vector2 position = new Vector2(0.01f, 0.0f);
            Vector2 dimensions = new Vector2(0.08f, 0.04f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 2)
            {
                offsetY = (0.005f + dimensions.y) * number;
            }
            if (number > 1 && number < 4)
            {
                offsetX = (0.01f + dimensions.x) * 1;
                offsetY = (0.005f + dimensions.y) * (number - 2);
            }
            if (number > 3 && number < 6)
            {
                offsetX = (0.01f + dimensions.x) * 2;
                offsetY = (0.005f + dimensions.y) * (number - 4);
            }
            if (number > 5 && number < 8)
            {
                offsetX = (0.01f + dimensions.x) * 3;
                offsetY = (0.005f + dimensions.y) * (number - 6);
            }
            if (number > 7 && number < 10)
            {
                offsetX = (0.01f + dimensions.x) * 4;
                offsetY = (0.005f + dimensions.y) * (number - 8);
            }
            if (number > 9 && number < 12)
            {
                offsetX = (0.01f + dimensions.x) * 5;
                offsetY = (0.005f + dimensions.y) * (number - 10);
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private float[] BackgroundButton(int number)
        {
            Vector2 position = new Vector2(0.3f, 0.97f);
            Vector2 dimensions = new Vector2(0.035f, 0.03f);
            float offsetY = 0;
            float offsetX = 0;
            offsetX = (0.005f + dimensions.x) * number;
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private float[] CalcButtonPos(int number)
        {
            Vector2 position = new Vector2(0.02f, 0.78f);
            Vector2 dimensions = new Vector2(0.15f, 0.15f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 6)
            {
                offsetX = (0.01f + dimensions.x) * number;
            }
            if (number > 5 && number < 12)
            {
                offsetX = (0.01f + dimensions.x) * (number - 6);
                offsetY = (-0.025f - dimensions.y) * 1;
            }
            if (number > 11 && number < 18)
            {
                offsetX = (0.01f + dimensions.x) * (number - 12);
                offsetY = (-0.025f - dimensions.y) * 2;
            }
            if (number > 17 && number < 24)
            {
                offsetX = (0.01f + dimensions.x) * (number - 18);
                offsetY = (-0.025f - dimensions.y) * 3;
            }
            if (number > 23 && number < 30)
            {
                offsetX = (0.01f + dimensions.x) * (number - 24);
                offsetY = (-0.025f - dimensions.y) * 4;
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private float[] CalcNumButtonPos(int number)
        {
            Vector2 position = new Vector2(0.05f, 0.75f);
            Vector2 dimensions = new Vector2(0.09f, 0.10f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 9)
            {
                offsetX = (0.01f + dimensions.x) * number;
            }
            if (number > 8 && number < 18)
            {
                offsetX = (0.01f + dimensions.x) * (number - 9);
                offsetY = (-0.02f - dimensions.y) * 1;
            }
            if (number > 17 && number < 27)
            {
                offsetX = (0.01f + dimensions.x) * (number - 18);
                offsetY = (-0.02f - dimensions.y) * 2;
            }
            if (number > 26 && number < 36)
            {
                offsetX = (0.01f + dimensions.x) * (number - 27);
                offsetY = (-0.02f - dimensions.y) * 3;
            }
            if (number > 35 && number < 45)
            {
                offsetX = (0.01f + dimensions.x) * (number - 36);
                offsetY = (-0.02f - dimensions.y) * 4;
            }
            if (number > 44 && number < 54)
            {
                offsetX = (0.01f + dimensions.x) * (number - 45);
                offsetY = (-0.02f - dimensions.y) * 5;
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        #endregion

        #region UI Commands

        [ConsoleCommand("UI_SaveTradeBox")]
        private void cmdUI_SaveTradeBox(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            DestroyMarketPanel(player);
            uint ID;
            if (!uint.TryParse(arg.Args[0], out ID))
            {
                GetSendMSG(player, "NoTradeBox");
                return;
            }
            if (mData.TradeBox.ContainsKey(player.userID))
            {
                Dictionary<uint, string> listings = new Dictionary<uint, string>();
                foreach (var entry in mData.MarketListings.Where(kvp => kvp.Value.seller == player.userID))
                    listings.Add(entry.Key, entry.Value.shortname);
                foreach (var entry in listings)
                    RemoveListing(player.userID, entry.Value, entry.Key, "TradeBoxChanged");
                listings.Clear();
                mData.TradeBox.Remove(player.userID);
            }
            mData.TradeBox.Add(player.userID, ID);
            if (SettingBox.Contains(player.userID)) SettingBox.Remove(player.userID);
            SaveData();
        }

        [ConsoleCommand("UI_CancelTradeBox")]
        private void cmdUI_CancelTradeBox(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            DestroyMarketPanel(player);
            if (SettingBox.Contains(player.userID))
            {
                SettingBox.Remove(player.userID);
                GetSendMSG(player, "ExitedBoxMode");
            }
        }

        [ConsoleCommand("UI_DestroyMarketPanel")]
        private void cmdUI_DestroyBoxConfirmation(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            DestroyMarketPanel(player);
        }

        [ConsoleCommand("UI_DestroyPurchaseScreen")]
        private void cmdUI_DestroyPurchaseScreen(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            DestroyPurchaseScreen(player);
        }

        [ConsoleCommand("UI_ToggleMarketScreen")]
        private void cmdUI_ToggleMarketScreen(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            ToggleMarketScreen(player);
        }

        [ConsoleCommand("UI_SelectSalesItem")]
        private void cmdUI_SelectSalesItem(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            DestroyMarketPanel(player);
            uint ID;
            if (!uint.TryParse(arg.Args[0], out ID))
                GetSendMSG(player, "INVALIDENTRY", arg.Args[0]);
            if (SalesItemPrep.ContainsKey(player.userID))
                SalesItemPrep.Remove(player.userID);
            SalesItemPrep.Add(player.userID, new AMItem());
            foreach (var entry in PlayerBoxContents[player.userID].Where(k => k.ID == ID))
            {
                SalesItemPrep[player.userID] = entry;
            }
            PlayerBoxContents.Remove(player.userID);
            SalesItemPrep[player.userID].seller = player.userID;
            SalesItemPrep[player.userID].stepNum = 0;
            if (configData.UseUniqueNames)
                SellItems(player);
            else
                SellItems(player, 1);
        }

        [ConsoleCommand("UI_SelectSR")]
        private void cmdUI_SelectSR(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            DestroyMarketPanel(player);
            if (SalesItemPrep.ContainsKey(player.userID))
                SalesItemPrep.Remove(player.userID);
            SalesItemPrep.Add(player.userID, new AMItem());
            PlayerBoxContents.Remove(player.userID);
            SalesItemPrep[player.userID].cat = Category.Money;
            SalesItemPrep[player.userID].shortname = "SR";
            SalesItemPrep[player.userID].skin = 0;
            SalesItemPrep[player.userID].ID = GetRandomNumber();
            SalesItemPrep[player.userID].seller = player.userID;
            SalesItemPrep[player.userID].stepNum = 0;
            NumberPad(player, "UI_SRAmount");
        }

        [ConsoleCommand("UI_SRAmount")]
        private void cmdUI_SRAmount(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            int amount = Convert.ToInt32(arg.Args[0]);
            var currentSRlisted = 0;
            if (CheckPoints(player.userID) is int)
                if ((int)CheckPoints(player.userID) >= amount)
                {
                    foreach (var entry in mData.MarketListings.Where(kvp => kvp.Value.seller == player.userID && kvp.Value.shortname == "SR"))
                        currentSRlisted += entry.Value.amount;
                    if ((int)CheckPoints(player.userID) - currentSRlisted >= amount)
                    {
                        SalesItemPrep[player.userID].amount = amount;
                        DestroyMarketPanel(player);
                        if (configData.UseUniqueNames)
                        {
                            SellItems(player);
                            return;
                        }
                        else
                        {
                            SellItems(player, 1);
                            return;
                        }
                    }
                }
            GetSendMSG(player, "NotEnoughSRPoints");
        }


        [ConsoleCommand("UI_SelectpriceItemshortname")]
        private void cmdUI_SelectpriceItemshortname(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            string priceItemshortname = arg.Args[0];
            SalesItemPrep[player.userID].priceItemshortname = priceItemshortname;
            foreach (var cat in imgData.SavedImages)
            {
                if (cat.Value.ContainsKey(priceItemshortname))
                {
                    SalesItemPrep[player.userID].pricecat = cat.Key;
                    break;
                }
                else
                {
                    SalesItemPrep[player.userID].pricecat = Category.None;
                    continue;
                }
            }
            SalesItemPrep[player.userID].stepNum = 1;
            NumberPad(player, "UI_SelectPriceAmount");
        }

        [ConsoleCommand("UI_SelectPriceAmount")]
        private void cmdUI_SelectPriceAmount(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            int amount = Convert.ToInt32(arg.Args[0]);
            SalesItemPrep[player.userID].priceAmount = amount;
            DestroyMarketPanel(player);
            SellItems(player, 99);
        }


        private uint GetRandomNumber()
        {
            var random = new System.Random();
            uint number = (uint)random.Next(0, int.MaxValue);
            return number;
        }

        [ConsoleCommand("UI_ListItem")]
        private void cmdUI_ListItem(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            if (SalesItemPrep[player.userID].cat != Category.Money)
            {
                if (GetTradeBoxContents(player) == false) return;
                if (!mData.MarketListings.ContainsKey(SalesItemPrep[player.userID].ID))
                {
                    if (BoxCheck(player, SalesItemPrep[player.userID].ID))
                    {
                        var solditem = SalesItemPrep[player.userID].shortname;
                        mData.MarketListings.Add(SalesItemPrep[player.userID].ID, SalesItemPrep[player.userID]);
                        if (SalesItemPrep.ContainsKey(player.userID))
                            SalesItemPrep.Remove(player.userID);
                        if (PlayerBoxContents.ContainsKey(player.userID))
                            PlayerBoxContents.Remove(player.userID);
                        GetSendMSG(player, "NewItemListed", solditem);
                        DestroyMarketPanel(player);
                        MarketMainScreen(player);
                        return;
                    }
                    GetSendMSG(player, "ItemNotInBox");
                }
                GetSendMSG(player, "ItemAlreadyListed");
                CancelListing(player);
            }
            else
            {
                var money = "";
                mData.MarketListings.Add(SalesItemPrep[player.userID].ID, SalesItemPrep[player.userID]);
                if (SalesItemPrep[player.userID].shortname == "SR")
                    money = "Server Rewards Points";
                GetSendMSG(player, "NewMoneyListed", money, SalesItemPrep[player.userID].amount.ToString());
                if (SalesItemPrep.ContainsKey(player.userID))
                    SalesItemPrep.Remove(player.userID);
                if (PlayerBoxContents.ContainsKey(player.userID))
                    PlayerBoxContents.Remove(player.userID);
                DestroyMarketPanel(player);
                MarketMainScreen(player);
            }
        }

        [ConsoleCommand("UI_CancelListing")]
        private void cmdUI_CancelListing(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            CancelListing(player);
        }

        [ConsoleCommand("UI_ChangeBackground")]
        private void cmdUI_ChangeBackground(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            mData.background[player.userID] = arg.Args[0];
            MarketMainScreen(player);
        }

        [ConsoleCommand("UI_MarketMainScreen")]
        private void cmdUI_MainMarketScreen(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            int page;
            if (!int.TryParse(arg.Args[0], out page)) return;
            Category cat;
            cat = (Category)Enum.Parse(typeof(Category), arg.Args[1]);
            MarketMainScreen(player, page, cat);
        }

        [ConsoleCommand("UI_MarketBackgroundMenu")]
        private void cmdUI_MarketBackgroundMenu(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            int page;
            if (!int.TryParse(arg.Args[0], out page)) return;
            MarketBackgroundMenu(player, page);
        }

        [ConsoleCommand("UI_BlackList")]
        private void cmdUI_BlackList(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            int page;
            if (!int.TryParse(arg.Args[0], out page)) return;
            var action = arg.Args[1];
            BlackListing(player, page, action);
        }

        [ConsoleCommand("UI_AdminPanel")]
        private void cmdUI_AdminPanel(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            AdminPanel(player);
        }

        [ConsoleCommand("UI_MarketSellScreen")]
        private void cmdUI_MarketSellScreen(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            int page;
            if (!int.TryParse(arg.Args[0], out page)) return;
            MarketSellScreen(player, page);
        }

        [ConsoleCommand("UI_Mode")]
        private void cmdUI_Mode(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            int action;
            if (!int.TryParse(arg.Args[0], out action)) return;
            if (action == 0)
                mData.mode[player.userID] = false;
            if (action == 1)
                mData.mode[player.userID] = true;
            MarketMainScreen(player);
        }



        [ConsoleCommand("UI_SetBoxMode")]
        private void cmdUI_SetBoxMode(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            if (!SettingBox.Contains(player.userID)) SettingBox.Add(player.userID);
            DestroyMarketPanel(player);
            GetSendMSG(player, "TradeBoxMode");
        }


        [ConsoleCommand("UI_BuyConfirm")]
        private void cmdUI_BuyConfirm(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            DestroyPurchaseScreen(player);
            uint ID;
            if (!uint.TryParse(arg.Args[0], out ID)) return;
            AMItem purchaseitem = mData.MarketListings[ID];
            var name = "";
            if (configData.UseUniqueNames && purchaseitem.name != "")
                name = purchaseitem.name;
            else name = purchaseitem.shortname;
            ulong buyer = player.userID;
            ulong seller = mData.MarketListings[ID].seller;
            if (PlayerInventory.ContainsKey(buyer))
                PlayerInventory.Remove(buyer);
            PlayerInventory.Add(buyer, new List<Item>());
            if (GetTradeBox(seller) != null && GetTradeBox(buyer) != null)
            {
                StorageContainer buyerbox = GetTradeBox(buyer);
                StorageContainer sellerbox = GetTradeBox(seller);
                if (!buyerbox.inventory.IsFull() && !sellerbox.inventory.IsFull())
                {
                    if (mData.MarketListings[ID].cat != Category.Money)
                    {
                        var c = 0;
                        foreach (Item item in sellerbox.inventory.itemList.Where(kvp => kvp.uid == ID))
                        {
                            c += item.amount;
                            if (item.condition != purchaseitem.condition)
                            {
                                RemoveListing(seller, name, purchaseitem.ID, "ItemCondChange");
                                MarketMainScreen(player);
                                return;
                            }
                            if (item.amount != purchaseitem.amount)
                            {
                                RemoveListing(seller, name, purchaseitem.ID, "ItemQuantityChange");
                                MarketMainScreen(player);
                                return;
                            }
                            if (c < purchaseitem.amount)
                            {
                                RemoveListing(seller, name, purchaseitem.ID, "ItemGoneChange");
                                MarketMainScreen(player);
                                return;
                            }
                        }
                    }
                    else
                    {
                        if (purchaseitem.shortname == "SR")
                            if ((int)CheckPoints(purchaseitem.seller) < purchaseitem.amount)
                            {
                                RemoveListing(seller, name, purchaseitem.ID, "NotEnoughSRPoints");
                                MarketMainScreen(player);
                                return;
                            }
                    }
                    if (mData.MarketListings[ID].pricecat != Category.Money)
                    {
                        var amount = 0;
                        PlayerInventory[buyer].AddRange(GetItemsOnly(player.inventory.containerWear));
                        PlayerInventory[buyer].AddRange(GetItemsOnly(player.inventory.containerMain));
                        PlayerInventory[buyer].AddRange(GetItemsOnly(player.inventory.containerBelt));
                        foreach (var entry in PlayerInventory[buyer].Where(kvp => kvp.info.shortname == purchaseitem.priceItemshortname))
                        {
                            amount += entry.amount;
                            if (amount >= purchaseitem.priceAmount)
                            {
                                PurchaseConfirmation(player, ID);
                                return;
                            }
                        }
                        GetSendMSG(player, "NotEnoughPurchaseItem", purchaseitem.priceItemshortname, purchaseitem.priceAmount.ToString());
                        return;
                    }
                    else
                    {
                        if (purchaseitem.priceItemshortname == "SR")
                            if ((int)CheckPoints(player.userID) >= purchaseitem.priceAmount)
                            {
                                PurchaseConfirmation(player, ID);
                                return;
                            }
                            else
                            {
                                GetSendMSG(player, "NotEnoughPurchaseItem", purchaseitem.priceItemshortname, purchaseitem.priceAmount.ToString());
                                return;
                            }
                    }
                }
                else
                {
                    if (buyerbox.inventory.IsFull())
                        GetSendMSG(player, "YourTradeBoxFullBuying");
                    else if (sellerbox.inventory.IsFull())
                        GetSendMSG(player, "SellerTradeBoxFullBuying");
                }
            }
            else
            {
                if (GetTradeBox(buyer) == null)
                    GetSendMSG(player, "YourNoTradeBoxBuying");
                else if (GetTradeBox(seller) == null)
                    GetSendMSG(player, "SellerNoTradeBoxBuying");
            }
        }


        [ConsoleCommand("UI_ProcessMoney")]
        private void cmdUI_ProcessMoney(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            DestroyPurchaseScreen(player);
        }

        [ConsoleCommand("UI_ProcessItem")]
        private void cmdUI_ProcessItem(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            DestroyPurchaseScreen(player);
            uint ID;
            if (!uint.TryParse(arg.Args[0], out ID)) return;
            AMItem purchaseitem = mData.MarketListings[ID];
            ulong buyer = player.userID;
            ulong seller = mData.MarketListings[ID].seller;
            if (PlayerInventory.ContainsKey(buyer))
                PlayerInventory.Remove(buyer);
            if (TransferableItems.ContainsKey(buyer))
                TransferableItems.Remove(buyer);
            if (PlayerPurchaseApproval.ContainsKey(buyer))
                PlayerPurchaseApproval.Remove(buyer);
            TransferableItems.Add(buyer, new List<Item>());
            PlayerInventory.Add(buyer, new List<Item>());
            PlayerPurchaseApproval.Add(buyer, false);
            if (GetTradeBox(seller) != null && GetTradeBox(buyer) != null)
            {
                StorageContainer buyerbox = GetTradeBox(buyer);
                StorageContainer sellerbox = GetTradeBox(seller);
                if (!buyerbox.inventory.IsFull() && !sellerbox.inventory.IsFull())
                {
                    if (purchaseitem.pricecat != Category.Money)
                    {
                        var amount = 0;
                        PlayerInventory[buyer].AddRange(GetItemsOnly(player.inventory.containerWear));
                        PlayerInventory[buyer].AddRange(GetItemsOnly(player.inventory.containerMain));
                        PlayerInventory[buyer].AddRange(GetItemsOnly(player.inventory.containerBelt));
                        foreach (var entry in PlayerInventory[buyer].Where(kvp => kvp.info.shortname == purchaseitem.priceItemshortname))
                        {
                            amount += entry.amount;
                            TransferableItems[buyer].Add(entry);
                            if (amount >= purchaseitem.priceAmount)
                            {
                                PlayerPurchaseApproval[buyer] = true;
                                break;
                            }
                            else continue;
                        }
                    }
                    else
                    {
                        if (purchaseitem.priceItemshortname == "SR")
                            if ((int)CheckPoints(player.userID) >= purchaseitem.priceAmount)
                            {
                                PlayerPurchaseApproval[buyer] = true;
                            }
                    }
                    if (PlayerPurchaseApproval[buyer] == true)
                    {
                        if (ItemsToTransfer.ContainsKey(buyer))
                            ItemsToTransfer.Remove(buyer);
                        ItemsToTransfer.Add(buyer, new List<Item>());
                        if (purchaseitem.pricecat != Category.Money)
                        {
                            foreach (var entry in TransferableItems[buyer])
                                XferCost(entry, player, ID);
                            foreach (Item item in ItemsToTransfer[buyer])
                                item.MoveToContainer(sellerbox.inventory);
                            ItemsToTransfer[buyer].Clear();
                        }
                        else
                        {
                            SRAction(buyer, purchaseitem.priceAmount, "REMOVE");
                            SRAction(seller, purchaseitem.priceAmount, "ADD");
                        }
                        if (purchaseitem.cat != Category.Money)
                        {
                            XferPurchase(buyer, ID, sellerbox.inventory, buyerbox.inventory);
                        }
                        else
                        {
                            SRAction(seller, purchaseitem.amount, "REMOVE");
                            SRAction(buyer, purchaseitem.amount, "ADD");
                        }
                        GetSendMSG(player, "NewPurchase", purchaseitem.shortname, purchaseitem.amount.ToString());
                        AddMessages(seller, "NewSale", purchaseitem.shortname, purchaseitem.amount.ToString());
                        mData.MarketListings.Remove(ID);
                        if (ItemsToTransfer[buyer].Count > 0)
                            foreach (Item item in ItemsToTransfer[buyer])
                                item.MoveToContainer(buyerbox.inventory);
                        MarketMainScreen(player);
                    }
                    else
                    {
                        GetSendMSG(player, "NotEnoughPurchaseItem", purchaseitem.priceItemshortname, purchaseitem.priceAmount.ToString());
                    }
                }
                else
                {
                    if (buyerbox.inventory.IsFull())
                        GetSendMSG(player, "YourTradeBoxFullBuying");
                    else if (sellerbox.inventory.IsFull())
                        GetSendMSG(player, "SellerTradeBoxFullBuying");
                    MarketMainScreen(player);
                }
            }
            else
            {
                if (GetTradeBox(buyer) == null)
                    GetSendMSG(player, "YourNoTradeBoxBuying");
                else if (GetTradeBox(seller) == null)
                    GetSendMSG(player, "SellerNoTradeBoxBuying");
            }
        }

        [ConsoleCommand("UI_RemoveListing")]
        private void cmdUI_RemoveListing(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            uint ID;
            if (!uint.TryParse(arg.Args[0], out ID)) return;
            var name = "";
            if (configData.UseUniqueNames && mData.MarketListings[ID].name != "")
                name = mData.MarketListings[ID].name;
            else name = mData.MarketListings[ID].shortname;
            RemoveListing(player.userID, name, ID, "SellerRemoval");
            MarketMainScreen(player);
        }

        [ConsoleCommand("UI_SellItems")]
        private void cmdUI_SellItems(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            int page;
            if (!int.TryParse(arg.Args[0], out page)) return;
            SellItems(player, 1, page);
        }

        [ConsoleCommand("UI_BackListItem")]
        private void cmdUI_BackListItem(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            var action = arg.Args[0];
            var item = arg.Args[1];
            if (action == "add")
                mData.Blacklist.Add(item);
            else if (action == "remove")
                mData.Blacklist.Remove(item);
            AdminPanel(player);
        }

        #endregion

        #region Timers

        private void SaveLoop()
        {
            if (timers.ContainsKey("save"))
            {
                timers["save"].Destroy();
                timers.Remove("save");
            }
            SaveData();
            timers.Add("save", timer.Once(600, () => SaveLoop()));
        }

        private void InfoLoop()
        {
            if (timers.ContainsKey("info"))
            {
                timers["info"].Destroy();
                timers.Remove("info");
            }
            if (configData.InfoInterval == 0) return;
            foreach (BasePlayer p in BasePlayer.activePlayerList)
            {
                GetSendMSG(p, "AMInfo", configData.MarketMenuKeyBinding);
            }
            timers.Add("info", timer.Once(configData.InfoInterval * 60, () => InfoLoop()));
        }

        private void SetBoxFullNotification(string ID)
        {
            timers.Add(ID, timer.Once(5 * 60, () => timers.Remove(ID)));
        }

        #endregion

        #region Classes
        class MarketData
        {
            public Dictionary<uint, AMItem> MarketListings = new Dictionary<uint, AMItem>();
            public Dictionary<ulong, uint> TradeBox = new Dictionary<ulong, uint>();
            public Dictionary<ulong, string> background = new Dictionary<ulong, string>();
            public Dictionary<ulong, bool> mode = new Dictionary<ulong, bool>();
            public Dictionary<ulong, List<Unsent>> OutstandingMessages = new Dictionary<ulong, List<Unsent>>();
            public List<string> Blacklist = new List<string>();
            public Dictionary<ulong, string> names = new Dictionary<ulong, string>();
        }

        class AMImages
        {
            public Dictionary<Category, Dictionary<string, Dictionary<ulong, uint>>> SavedImages = new Dictionary<Category, Dictionary<string, Dictionary<ulong, uint>>>();
            public Dictionary<string, uint> SavedBackgrounds = new Dictionary<string, uint>();
        }

        class Unsent
        {
            public string message;
            public string arg1;
            public string arg2;
            public string arg3;
            public string arg4;
        }

        enum Category
        {
            Weapons,
            Armor,
            Attire,
            Ammunition,
            Medical,
            Tools,
            Building,
            Resources,
            Other,
            None,
            All,
            Extra,
            Food,
            Money
        }

        class AMItem
        {
            public string name;
            public string shortname;
            public ulong skin;
            public uint ID;
            public Category cat;
            public bool approved;
            public Category pricecat;
            public string priceItemshortname;
            public int priceItemID;
            public int priceAmount;
            public int amount;
            public int stepNum;
            public ulong seller;
            public float condition;
        }

        #endregion

        #region Unity WWW
        class QueueImage
        {
            public string url;
            public string shortname;
            public ulong skinid;
            public Category cat;
            public QueueImage(string ur, Category ct, string st, ulong sk)
            {
                url = ur;
                shortname = st;
                skinid = sk;
                cat = ct;
            }
        }
        
        class UnityImages : MonoBehaviour
        {
            AbsolutMarket filehandler;
            const int MaxActiveLoads = 3;
            static readonly List<QueueImage> QueueList = new List<QueueImage>();
            static byte activeLoads;
            private MemoryStream stream = new MemoryStream();

            public void SetDataDir(AbsolutMarket am) => filehandler = am;
            public void Add(string url, Category cat, string shortname, ulong skinid)
            {
                QueueList.Add(new QueueImage(url, cat, shortname, skinid));
                if (activeLoads < MaxActiveLoads) Next();
            }

            void Next()
            {
                activeLoads++;
                var qi = QueueList[0];
                QueueList.RemoveAt(0);
                var www = new WWW(qi.url);
                StartCoroutine(WaitForRequest(www, qi));
            }

            private void ClearStream()
            {
                stream.Position = 0;
                stream.SetLength(0);
            }

            IEnumerator WaitForRequest(WWW www, QueueImage info)
            {
                yield return www;

                if (www.error == null)
                {
                    if (!filehandler.imgData.SavedImages.ContainsKey(info.cat))
                        filehandler.imgData.SavedImages.Add(info.cat, new Dictionary<string, Dictionary<ulong, uint>>());
                    if (!filehandler.imgData.SavedImages[info.cat].ContainsKey(info.shortname))
                        filehandler.imgData.SavedImages[info.cat].Add(info.shortname, new Dictionary<ulong, uint>());
                    if (!filehandler.imgData.SavedImages[info.cat][info.shortname].ContainsKey(info.skinid))
                    {
                        ClearStream();
                        stream.Write(www.bytes, 0, www.bytes.Length);
                        uint textureID = FileStorage.server.Store(stream, FileStorage.Type.png, uint.MaxValue);
                        ClearStream();
                        filehandler.imgData.SavedImages[info.cat][info.shortname].Add(info.skinid, textureID);
                    }
                }
                activeLoads--;
                if (QueueList.Count > 0) Next();
                else filehandler.SaveData();
            }
        }

        class QueueBackground
        {
            public string url;
            public string name;
            public QueueBackground(string ur, string nm)
            {
                url = ur;
                name = nm;
            }
        }

        class UnityBackgrounds : MonoBehaviour
        {
            AbsolutMarket filehandler;
            const int MaxActiveLoads = 3;
            static readonly List<QueueBackground> QueueList = new List<QueueBackground>();
            static byte activeLoads;
            private MemoryStream stream = new MemoryStream();

            public void SetDataDir(AbsolutMarket am) => filehandler = am;
            public void Add(string url, string name)
            {
                QueueList.Add(new QueueBackground(url, name));
                if (activeLoads < MaxActiveLoads) Next();
            }

            void Next()
            {
                activeLoads++;
                var qi = QueueList[0];
                QueueList.RemoveAt(0);
                var www = new WWW(qi.url);
                StartCoroutine(WaitForRequest(www, qi));
            }

            private void ClearStream()
            {
                stream.Position = 0;
                stream.SetLength(0);
            }

            IEnumerator WaitForRequest(WWW www, QueueBackground info)
            {
                yield return www;

                if (www.error == null)
                {
                    if (!filehandler.imgData.SavedBackgrounds.ContainsKey(name))
                    {
                        ClearStream();
                        stream.Write(www.bytes, 0, www.bytes.Length);
                        uint textureID = FileStorage.server.Store(stream, FileStorage.Type.png, uint.MaxValue);
                        ClearStream();
                        filehandler.imgData.SavedBackgrounds.Add(info.name, textureID);
                    }
                }
                activeLoads--;
                if (QueueList.Count > 0) Next();
                else filehandler.SaveData();
            }
        }

        [ConsoleCommand("getimages")]
        private void cmdgetimages(ConsoleSystem.Arg arg)
        {
            if (arg.connection == null)
            {
                Getimages();
            }
        }

        private void Getimages()
        {
            imgData.SavedImages.Clear();
            foreach (var category in urls)
                foreach (var entry in category.Value)
                    foreach (var item in entry.Value)
                    {
                        if (!string.IsNullOrEmpty(item.Value))
                        {
                            uImage.Add(item.Value, category.Key, entry.Key, item.Key);
                        }
                    }
            Puts(GetLang("ImgReload"));
        }

        [ConsoleCommand("refreshimages")]
        private void cmdrefreshimages(ConsoleSystem.Arg arg)
        {
            if (arg.connection == null)
            {
                Refreshimages();
            }
        }

        private void Refreshimages()
        {
            foreach (var category in urls)
            {
                if (!imgData.SavedImages.ContainsKey(category.Key))
                    imgData.SavedImages.Add(category.Key, new Dictionary<string, Dictionary<ulong, uint>>());
                foreach (var entry in category.Value)
                {
                    if (!imgData.SavedImages[category.Key].ContainsKey(entry.Key))
                        imgData.SavedImages[category.Key].Add(entry.Key, new Dictionary<ulong, uint>());
                    foreach (var item in entry.Value)
                    {
                        if (!string.IsNullOrEmpty(item.Value))
                        {
                            uImage.Add(item.Value, category.Key, entry.Key, item.Key);
                        }
                    }
                }
            }
            Puts(GetLang("ImgRefresh"));
        }

        [ConsoleCommand("getbackgrounds")]
        private void cmdgetbackgrounds(ConsoleSystem.Arg arg)
        {
            if (arg.connection == null)
            {
                GetBackgrounds();
            }
        }

        private void GetBackgrounds()
        {
            imgData.SavedBackgrounds.Clear();
            foreach (var entry in defaultBackgrounds)
                    uBackground.Add(entry.Value, entry.Key);
            timer.Once(10, () =>
            {

                SaveBackgrounds();
                Puts(GetLang("BckReload"));
                RefreshBackgrounds();
            });
        }

        [ConsoleCommand("refreshbackgrounds")]
        private void cmdrefreshbackgrounds(ConsoleSystem.Arg arg)
        {
            if (arg.connection == null)
            {
                RefreshBackgrounds();
            }
        }

        private void RefreshBackgrounds()
        {
            try
            {
                imgData = IMGData.ReadObject<AMImages>();
            }
            catch
            {
                Puts("Couldn't load the Absolut Market Image File, creating a new datafile");
                imgData = new AMImages();
            }
            try
            {
                bkData = BKData.ReadObject<Backgrounds>();
            }
            catch
            {
                Puts("Couldn't Find Pending Background File , creating a new File");
                bkData = new Backgrounds();
                bkData.PendingBackgrounds = defaultBackgrounds;
                BKData.WriteObject(bkData);
            }
            var i = 0;
            foreach (var entry in bkData.PendingBackgrounds)
                if (!imgData.SavedBackgrounds.ContainsKey(entry.Key))
                {
                    uBackground.Add(entry.Value, entry.Key);
                    i++;
                }
            //bkData.PendingBackgrounds.Clear();
            //BKData.WriteObject(bkData);
            timer.Once(10, () =>
            {
                SaveBackgrounds();
                Puts(GetMSG("BckRefresh", i.ToString()));
            });
            //IMGData.WriteObject(imgData);
            
        }

        private void SaveBackgrounds()
        {
            IMGData.WriteObject(imgData);
        }

        #endregion

        #region Absolut Market Data Management

        private Dictionary<Category, Dictionary<string, Dictionary<ulong, string>>> urls = new Dictionary<Category, Dictionary<string, Dictionary<ulong, string>>>
        {
            {Category.Money, new Dictionary<string, Dictionary<ulong, string>>
            {
                {"SR", new Dictionary<ulong, string>
                {
                {0, "http://oxidemod.org/data/resource_icons/1/1751.jpg?1456924271" },
                }
                },
            }
            },

            {Category.None, new Dictionary<string, Dictionary<ulong, string>>
            {
                {"MISSINGIMG", new Dictionary<ulong, string>
                {
                {0, "http://www.hngu.net/Images/College_Logo/28/b894b451_c203_4c08_922c_ebc95077c157.png" },
                }
                },
                {"ARROW", new Dictionary<ulong, string>
                {
                {0, "http://www.freeiconspng.com/uploads/red-arrow-curved-5.png" },
                }
                },
                {"FIRST", new Dictionary<ulong, string>
                {
                {0, "http://cdn.mysitemyway.com/etc-mysitemyway/icons/legacy-previews/icons/simple-black-square-icons-arrows/126517-simple-black-square-icon-arrows-double-arrowhead-left.png" },
                }
                },
                {"BACK", new Dictionary<ulong, string>
                {
                {0, "https://image.freepik.com/free-icon/back-left-arrow-in-square-button_318-76403.png" },
                }
                },
                {"NEXT", new Dictionary<ulong, string>
                {
                {0, "https://image.freepik.com/free-icon/right-arrow-square-button-outline_318-76302.png"},
                }
                },
                {"LAST", new Dictionary<ulong, string>
                {
                {0, "http://cdn.mysitemyway.com/etc-mysitemyway/icons/legacy-previews/icons/matte-white-square-icons-arrows/124577-matte-white-square-icon-arrows-double-arrowhead-right.png" },
                }
                },
                {"OFILTER", new Dictionary<ulong, string>
                {
                {0, "https://pixabay.com/static/uploads/photo/2016/01/23/11/41/button-1157299_960_720.png" },
                }
                },
                {"UFILTER", new Dictionary<ulong, string>
                {
                {0, "https://pixabay.com/static/uploads/photo/2016/01/23/11/42/button-1157301_960_720.png" },
                }
                },
                {"ADMIN", new Dictionary<ulong, string>
                {
                {0, "https://pixabay.com/static/uploads/photo/2016/01/23/11/26/button-1157269_960_720.png" },
                }
                },
                {"MISC", new Dictionary<ulong, string>
                {
                {0, "https://pixabay.com/static/uploads/photo/2015/07/25/07/55/the-button-859343_960_720.png" },
                }
                },            
                {"SELL", new Dictionary<ulong, string>
                {
                {0, "https://pixabay.com/static/uploads/photo/2015/07/25/08/03/the-button-859350_960_720.png" },
                }
                },
              
                }
            },
            {Category.Attire, new Dictionary<string, Dictionary<ulong, string>>
            {
                { "tshirt", new Dictionary<ulong, string>
                {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/6/62/T-Shirt_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200547" },
                {10130, "http://vignette2.wikia.nocookie.net/play-rust/images/c/c6/Argyle_Scavenger_icon.png/revision/latest/scale-to-width-down/100?cb=20160211204436"},
                {10033, "http://vignette2.wikia.nocookie.net/play-rust/images/4/44/Baseball_Tshirt_icon.png/revision/latest/scale-to-width-down/100?cb=20151106053725" },
                {10003, "http://vignette1.wikia.nocookie.net/play-rust/images/b/bb/Black_Tshirt_icon.png/revision/latest/scale-to-width-down/100?cb=20151106054123"},
                {14177, "http://vignette1.wikia.nocookie.net/play-rust/images/1/1e/Blue_Tshirt_icon.png/revision/latest/scale-to-width-down/100?cb=20151106053931" },
                {10056, "http://vignette3.wikia.nocookie.net/play-rust/images/9/98/Facepunch_TShirt_icon.png/revision/latest/scale-to-width-down/100?cb=20151106053603"},
                {14181, "http://vignette2.wikia.nocookie.net/play-rust/images/a/a2/Forest_Camo_Tshirt_icon.png/revision/latest/scale-to-width-down/100?cb=20151106053948" },
                {10024, "http://vignette3.wikia.nocookie.net/play-rust/images/1/19/German_Tshirt_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200140"},
                {10035, "http://vignette3.wikia.nocookie.net/play-rust/images/c/c0/Hacker_Valley_Veteran_icon.png/revision/latest/scale-to-width-down/100?cb=20151106053826" },
                {10046, "http://vignette2.wikia.nocookie.net/play-rust/images/4/4d/Missing_Textures_TShirt_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200051"},
                {10038, "http://vignette3.wikia.nocookie.net/play-rust/images/4/4c/Murderer_T-Shirt_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195600" },
                {101, "http://vignette1.wikia.nocookie.net/play-rust/images/f/f3/Red_Tshirt_icon.png/revision/latest/scale-to-width-down/100?cb=20151106053820" },
                {10025, "http://vignette1.wikia.nocookie.net/play-rust/images/b/bd/Russia_Tshirt_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195447" },
                {10002, "http://vignette4.wikia.nocookie.net/play-rust/images/5/59/Sandbox_Game_Shirt_icon.png/revision/latest/scale-to-width-down/100?cb=20151106054255"},
                {10134, "http://vignette1.wikia.nocookie.net/play-rust/images/6/61/Ser_Winter_TShirt_icon.png/revision/latest/scale-to-width-down/100?cb=20160214234909" },
                {10131, "http://vignette2.wikia.nocookie.net/play-rust/images/7/70/Shadowfrax_TShirt_icon.png/revision/latest/scale-to-width-down/100?cb=20160214234921"},
                {10041, "http://vignette1.wikia.nocookie.net/play-rust/images/4/43/Skull_%26_Bones_TShirt_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195506" },
                {10053, "http://vignette4.wikia.nocookie.net/play-rust/images/5/5b/Smile_T-Shirt_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195652"},
                {10039, "http://vignette1.wikia.nocookie.net/play-rust/images/6/6d/Target_Practice_T-Shirt_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200031" },
                {584379, "http://vignette1.wikia.nocookie.net/play-rust/images/1/1f/Urban_Camo_icon.png/revision/latest/scale-to-width-down/100?cb=20151106054016"},
                {10043, "http://vignette2.wikia.nocookie.net/play-rust/images/d/d8/Vyshyvanka_Shirt_icon.png/revision/latest/scale-to-width-down/100?cb=20151106053755" },
                }
            },
            {"pants", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/3/3f/Pants_icon.png/revision/latest/scale-to-width-down/100?cb=20150821195647" },
                {10001, "http://vignette2.wikia.nocookie.net/play-rust/images/1/1d/Blue_Jeans_icon.png/revision/latest/scale-to-width-down/100?cb=20151106053716"},
                {10049, "http://vignette3.wikia.nocookie.net/play-rust/images/d/de/Blue_Track_Pants_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200133" },
                {10019, "http://vignette2.wikia.nocookie.net/play-rust/images/1/17/Forest_Camo_Pants_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195731"},
                {10078, "http://vignette2.wikia.nocookie.net/play-rust/images/3/30/Old_Prisoner_Pants_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200717" },
                {10048, "http://vignette1.wikia.nocookie.net/play-rust/images/4/4d/Punk_Rock_Pants_icon.png/revision/latest/scale-to-width-down/100?cb=20151106053631"},
                {10021, "http://vignette2.wikia.nocookie.net/play-rust/images/d/de/Snow_Camo_Pants_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195500" },
                {10020, "http://vignette4.wikia.nocookie.net/play-rust/images/5/54/Urban_Camo_Pants_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195400" },
            }
            },
            {"shoes.boots", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/b/b3/Boots_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200326" },
                {10080, "http://vignette1.wikia.nocookie.net/play-rust/images/f/f1/Army_Boots_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200800"},
                {10023, "http://vignette3.wikia.nocookie.net/play-rust/images/c/c5/Black_Boots_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195749" },
                {10088, "http://vignette4.wikia.nocookie.net/play-rust/images/a/af/Bloody_Boots_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200836"},
                {10034, "http://vignette4.wikia.nocookie.net/play-rust/images/a/a9/Punk_Boots_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195937" },
                {10044, "http://vignette2.wikia.nocookie.net/play-rust/images/5/5b/Scavenged_Sneaker_Boots_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195530"},
                {10022, "http://vignette1.wikia.nocookie.net/play-rust/images/c/cf/Tan_Boots_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195755" },
            }
            },
             {"tshirt.long", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/5/57/Longsleeve_T-Shirt_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200605" },
                {10047, "http://vignette4.wikia.nocookie.net/play-rust/images/e/e1/Aztec_Long_T-Shirt_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195354"},
                {10004, "http://vignette3.wikia.nocookie.net/play-rust/images/e/e2/Black_Longsleeve_T-Shirt_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195617" },
                {10089, "http://vignette2.wikia.nocookie.net/play-rust/images/8/83/Christmas_Jumper_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200701"},
                {10106, "http://vignette4.wikia.nocookie.net/play-rust/images/5/57/Creepy_Jack_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201059" },
                {10050, "http://vignette2.wikia.nocookie.net/play-rust/images/c/c2/Frankensteins_Sweater_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195302"},
                {10032, "http://vignette1.wikia.nocookie.net/play-rust/images/0/04/Green_Checkered_Shirt_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195518" },
                {10005, "http://vignette4.wikia.nocookie.net/play-rust/images/5/53/Grey_Longsleeve_T-Shirt_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195329"},
                {10125, "http://vignette1.wikia.nocookie.net/play-rust/images/2/2c/Lawman_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201508" },
                {10118, "http://vignette4.wikia.nocookie.net/play-rust/images/9/96/Merry_Reindeer_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201444"},
                {10051, "http://vignette1.wikia.nocookie.net/play-rust/images/4/4b/Nightmare_Sweater_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195419" },
                {10006, "http://vignette1.wikia.nocookie.net/play-rust/images/f/f6/Orange_Longsleeve_T-Shirt_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195658"},
                {10036, "http://vignette4.wikia.nocookie.net/play-rust/images/8/8a/Sign_Painter_icon.png/revision/latest/scale-to-width-down/100?cb=20151106054215" },
                {10042, "http://vignette1.wikia.nocookie.net/play-rust/images/1/1d/Varsity_Jacket_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195536" },
                {10007, "http://vignette2.wikia.nocookie.net/play-rust/images/a/ad/Yellow_Longsleeve_T-Shirt_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195949"},
            }
            },
             {"mask.bandana", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/9/9f/Bandana_Mask_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200526" },
                {10061, "http://vignette4.wikia.nocookie.net/play-rust/images/b/bf/Black_Bandana_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200233"},
                {10060, "http://vignette2.wikia.nocookie.net/play-rust/images/1/1d/Blue_Bandana_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200057" },
                {10067, "http://vignette1.wikia.nocookie.net/play-rust/images/1/13/Checkered_Bandana_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195703"},
                {10104, "http://vignette1.wikia.nocookie.net/play-rust/images/6/64/Creepy_Clown_Bandana_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201043" },
                {10066, "http://vignette2.wikia.nocookie.net/play-rust/images/e/ee/Desert_Camo_Bandana_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200208"},
                {10063, "http://vignette2.wikia.nocookie.net/play-rust/images/3/3f/Forest_Camo_Bandana_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195310" },
                {10059, "http://vignette4.wikia.nocookie.net/play-rust/images/5/53/Green_Bandana_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195442"},
                {10065, "http://vignette1.wikia.nocookie.net/play-rust/images/9/9c/Red_Skull_Bandana_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195511" },
                {10064, "http://vignette4.wikia.nocookie.net/play-rust/images/a/af/Skull_Bandana_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195334"},
                {10062, "http://vignette2.wikia.nocookie.net/play-rust/images/a/a4/Snow_Camo_Bandana_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195425" },
                {10079, "http://vignette1.wikia.nocookie.net/play-rust/images/4/49/Wizard_Bandana_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200841"},
            }
            },
             {"mask.balaclava", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/5/52/Improvised_Balaclava_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200410" },
                {10105, "http://vignette2.wikia.nocookie.net/play-rust/images/0/01/Burlap_Brains_Balaclava_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201020"},
                {10069, "http://vignette1.wikia.nocookie.net/play-rust/images/e/e8/Desert_Camo_Balaclava_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200044"},
                {10071, "http://vignette3.wikia.nocookie.net/play-rust/images/7/70/Double_Yellow_Balaclava_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195931" },
                {10068, "http://vignette2.wikia.nocookie.net/play-rust/images/a/a6/Forest_Camo_Balaclava_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200221"},
                {10057, "http://vignette4.wikia.nocookie.net/play-rust/images/2/2c/Murica_Balaclava_icon.png/revision/latest/scale-to-width-down/100?cb=20151106053748" },
                {10075, "http://vignette2.wikia.nocookie.net/play-rust/images/2/2b/Nightmare_Balaclava_icon.png/revision/latest/scale-to-width-down/100?cb=20151106062050"},
                {10070, "http://vignette2.wikia.nocookie.net/play-rust/images/8/86/Red_Check_Balaclava_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195709" },
                {10054, "http://vignette1.wikia.nocookie.net/play-rust/images/f/f1/Rorschach_Skull_icon.png/revision/latest/scale-to-width-down/100?cb=20151106053839"},
                {10090, "http://vignette2.wikia.nocookie.net/play-rust/images/0/09/Skin_Balaclava_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200829" },
                {10110, "http://vignette1.wikia.nocookie.net/play-rust/images/c/ce/Stitched_Skin_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201026"},
                {10084, "http://vignette2.wikia.nocookie.net/play-rust/images/2/27/The_Rust_Knight_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200811" },
                {10139, "http://vignette2.wikia.nocookie.net/play-rust/images/e/e7/Valentine_Balaclava_icon.png/revision/latest/scale-to-width-down/100?cb=20160211204423"},
                {10111, "http://vignette2.wikia.nocookie.net/play-rust/images/9/9c/Zipper_Face_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201014" },
            }
            },
             {"jacket.snow", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/0/04/Snow_Jacket_-_Red_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200536" },
                {10082, "http://vignette3.wikia.nocookie.net/play-rust/images/7/75/60%27s_Army_Jacket_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200741"},
                {10113, "http://vignette2.wikia.nocookie.net/play-rust/images/e/ed/Black_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201110" },
                {10083, "http://vignette4.wikia.nocookie.net/play-rust/images/8/89/Salvaged_Shirt%2C_Coat_and_Tie_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200642"},
                {10112, "http://vignette2.wikia.nocookie.net/play-rust/images/c/c9/Woodland_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201105" },
            }
            },
             {"jacket", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/8/8b/Jacket_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200520" },
                {10011, "http://vignette1.wikia.nocookie.net/play-rust/images/6/65/Blue_Jacket_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200113"},
                {10012, "http://vignette2.wikia.nocookie.net/play-rust/images/f/f0/Desert_Jacket_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195737" },
                {10009, "http://vignette4.wikia.nocookie.net/play-rust/images/4/4c/Green_Jacket_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200156"},
                {10015, "http://vignette3.wikia.nocookie.net/play-rust/images/f/fd/Hunting_Jacket_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195956" },
                {10013, "http://vignette3.wikia.nocookie.net/play-rust/images/d/db/Multicam_Jacket_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200127"},
                {10072, "http://vignette2.wikia.nocookie.net/play-rust/images/b/b5/Provocateur_Jacket_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200817" },
                {10010, "http://vignette2.wikia.nocookie.net/play-rust/images/7/7c/Red_Jacket_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195323" },
                {10008, "http://vignette2.wikia.nocookie.net/play-rust/images/f/fc/Snowcamo_Jacket_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200105"},
                {10014, "http://vignette2.wikia.nocookie.net/play-rust/images/9/94/Urban_Camo_Jacket_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200215" },
            }
            },
            {"hoodie", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/b/b5/Hoodie_icon.png/revision/latest/scale-to-width-down/100?cb=20160310205713" },
                {10142, "http://vignette3.wikia.nocookie.net/play-rust/images/c/c7/BCHILLZ%21_Hoodie_icon.png/revision/latest/scale-to-width-down/100?cb=20160313225348"},
                {14179, "http://vignette3.wikia.nocookie.net/play-rust/images/9/97/Black_Hoodie_icon.png/revision/latest/scale-to-width-down/100?cb=20160310205706" },
                {10052, "http://vignette1.wikia.nocookie.net/play-rust/images/9/95/Bloody_Hoodie_icon.png/revision/latest/scale-to-width-down/100?cb=20160310205645"},
                {14178, "http://vignette3.wikia.nocookie.net/play-rust/images/5/5a/Blue_Hoodie_icon.png/revision/latest/scale-to-width-down/100?cb=20160310205700" },
                {10133, "http://vignette2.wikia.nocookie.net/play-rust/images/2/27/Cuda87_Hoodie_icon.png/revision/latest/scale-to-width-down/100?cb=20160310205750"},
                {14072, "http://vignette2.wikia.nocookie.net/play-rust/images/2/21/Green_Hoodie_icon.png/revision/latest/scale-to-width-down/100?cb=20160310205654" },
                {10132, "http://vignette2.wikia.nocookie.net/play-rust/images/4/4c/Rhinocrunch_Hoodie_icon.png/revision/latest/scale-to-width-down/100?cb=20160310205744"},
                {10129, "http://vignette1.wikia.nocookie.net/play-rust/images/0/0c/Safety_Crew_icon.png/revision/latest/scale-to-width-down/100?cb=20160310205756" },
                {10086, "http://vignette1.wikia.nocookie.net/play-rust/images/c/c2/Skeleton_Hoodie_icon.png/revision/latest/scale-to-width-down/100?cb=20160310205737"},
            }
            },
            {"hat.cap", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/7/77/Baseball_Cap_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200434" },
                {10029, "http://vignette4.wikia.nocookie.net/play-rust/images/5/56/Blue_Cap_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195645"},
                {10027, "http://vignette1.wikia.nocookie.net/play-rust/images/2/29/Forest_Camo_Cap_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200024" },
                {10055, "http://vignette2.wikia.nocookie.net/play-rust/images/4/4e/Friendly_Cap_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195606"},
                {10030, "http://vignette3.wikia.nocookie.net/play-rust/images/4/4a/Green_Cap_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195925" },
                {10026, "http://vignette3.wikia.nocookie.net/play-rust/images/7/70/Grey_Cap_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195714"},
                {10028, "http://vignette1.wikia.nocookie.net/play-rust/images/2/29/Red_Cap_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195742" },
                {10045, "http://vignette1.wikia.nocookie.net/play-rust/images/2/2d/Rescue_Cap_icon.png/revision/latest/scale-to-width-down/100?cb=20151106053620" },
            }
            },
            {"hat.beenie", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/c/c1/Beenie_Hat_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200552" },
                {14180, "http://vignette2.wikia.nocookie.net/play-rust/images/5/58/Black_Beenie_Hat_icon.png/revision/latest/scale-to-width-down/100?cb=20151106053801"},
                {10018, "http://vignette1.wikia.nocookie.net/play-rust/images/4/43/Blue_Beenie_Hat_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200238" },
                {10017, "http://vignette4.wikia.nocookie.net/play-rust/images/b/b8/Green_Beenie_Hat_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195919"},
                {10040, "http://vignette1.wikia.nocookie.net/play-rust/images/7/71/Rasta_Beenie_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195430" },
                {10016, "http://vignette3.wikia.nocookie.net/play-rust/images/4/4e/Red_Beenie_Hat_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195554"},
                {10085, "http://vignette1.wikia.nocookie.net/play-rust/images/e/e3/Winter_Deers_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200706" },
            }
            },
            {"burlap.gloves", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/a/a1/Leather_Gloves_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200306" },
                {10128, "http://vignette4.wikia.nocookie.net/play-rust/images/b/b5/Boxer%27s_Bandages_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201502"},
            }
            },
            {"burlap.shirt", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/d/d7/Burlap_Shirt_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200455" },
                {10136, "http://vignette1.wikia.nocookie.net/play-rust/images/7/77/Pirate_Vest_%26_Shirt_icon.png/revision/latest/scale-to-width-down/100?cb=20160211204350"},
            }
            },
            {"hat.boonie", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/8/88/Boonie_Hat_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200347" },
                {10058, "http://vignette4.wikia.nocookie.net/play-rust/images/1/12/Farmer_Hat_icon.png/revision/latest/scale-to-width-down/100?cb=20160211195725"},
            }
            },
            {"santahat", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/4/4f/Santa_Hat_icon.png/revision/latest/scale-to-width-down/100?cb=20151217230743" },
            }
            },
            {"hazmat.pants", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/6/6a/Hazmat_Pants_icon.png/revision/latest/scale-to-width-down/100?cb=20151106060831" },
            }
            },
            {"hazmat.jacket", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/2/23/Hazmat_Jacket_icon.png/revision/latest/scale-to-width-down/100?cb=20151106054359" },
            }
            },
            {"hazmat.helmet", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/5/53/Hazmat_Helmet_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061437" },
            }
            },
            {"hazmat.gloves", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/a/aa/Hazmat_Gloves_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061629" },
            }
            },
            {"hazmat.boots", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/8/8a/Hazmat_Boots_icon.png/revision/latest/scale-to-width-down/100?cb=20151106060906" },
            }
            },
            {"hat.miner", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/1/1b/Miners_Hat_icon.png/revision/latest/scale-to-width-down/100?cb=20151106060851" },
            }
            },
            {"hat.candle", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/a/ad/Candle_Hat_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061731" },
            }
            },

            {"burlap.trousers", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/e/e5/Burlap_Trousers_icon.png/revision/latest/scale-to-width-down/100?cb=20151106054430" },
            }
            },
            {"burlap.shoes", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/1/10/Burlap_Shoes_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061222" },
            }
            },
            {"burlap.headwrap", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/c/c4/Burlap_Headwrap_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061044" },
            }
            },
            {"shirt.tanktop", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/1/1e/Tank_Top_icon.png/revision/latest/scale-to-width-down/100?cb=20161102190317" },
            }
            },
            {"shirt.collared", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/8/8c/Shirt_icon.png/revision/latest/scale-to-width-down/100?cb=20161102193325" },
            }
            },
            {"pants.shorts", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/4/46/Shorts_icon.png/revision/latest/scale-to-width-down/100?cb=20161102194514" },
            }
            },

            }
            },
            {Category.Armor, new Dictionary<string, Dictionary<ulong, string>>
            {
            {"bucket.helmet", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/a/a5/Bucket_Helmet_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200541" },
                {10127, "http://vignette1.wikia.nocookie.net/play-rust/images/1/1c/Medic_Helmet_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201521"},
                {10126, "http://vignette2.wikia.nocookie.net/play-rust/images/c/c4/Wooden_Bucket_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201438" },
            }
            },
            {"wood.armor.pants", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/6/68/Wood_Armor_Pants_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061716" },
            }
            },
            {"wood.armor.jacket", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/4/4f/Wood_Chestplate_icon.png/revision/latest/scale-to-width-down/100?cb=20151106060921" },
            }
            },
            {"roadsign.kilt", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/3/31/Road_Sign_Kilt_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200530" },
            }
            },
            {"roadsign.jacket", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/8/84/Road_Sign_Jacket_icon.png/revision/latest/scale-to-width-down/100?cb=20151106054408" },
            }
            },
            {"riot.helmet", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/4/4e/Riot_Helmet_icon.png/revision/latest/scale-to-width-down/100?cb=20151106060949" },
            }
            },
            {"metal.plate.torso", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/9/9d/Metal_Chest_Plate_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061201" },
            }
            },
            {"metal.facemask", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/1/1f/Metal_Facemask_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061432" },
            }
 