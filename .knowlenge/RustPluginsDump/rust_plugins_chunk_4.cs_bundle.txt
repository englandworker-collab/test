FormatTime(player, (int)globalCooldownTime));
                    return;
                }
                if (config.Settings.BlockAuthorizedTeleporting && player.IsBuildingAuthed())
                {
                    PrintMsgL(player, "CannotTeleportFromHome");
                    return;
                }
            }
            var countdown = GetLower(originPlayer, config.TPR.VIPCountdowns, config.TPR.Countdown);
            PrintMsgL(originPlayer, "Accept", player.displayName, countdown);
            PrintMsgL(player, "AcceptTarget", originPlayer.displayName);
            Interface.CallHook("OnTeleportAccepted", player, originPlayer);
            if (config.TPR.PlaySoundsWhenTargetAccepts)
            {
                SendEffect(originPlayer, config.TPR.TeleportAcceptEffects);
            }
            var timestamp = Facepunch.Math.Epoch.Current;
            TeleportTimers[originPlayer.userID] = new TeleportTimer
            {
                OriginPlayer = originPlayer,
                TargetPlayer = player,
                Timer = timer.Once(countdown, () =>
                {
#if DEBUG
                    Puts("Calling CheckPlayer from cmdChatTeleportAccept timer loop");
#endif
                    if (!CanBypassRestrictions(player.UserIDString))
                    {
                        if (!TeleportInForcedBoundary(originPlayer, player))
                        {
                            return;
                        }
                        if (config.Settings.BlockAuthorizedTeleporting && player.IsBuildingAuthed())
                        {
                            PrintMsgL(player, "CannotTeleportFromHome");
                            return;
                        }
                        err = CheckPlayer(originPlayer, config.TPR.UsableOutOfBuildingBlocked, CanCraftTPR(originPlayer), true, "tpa") ?? CheckPlayer(player, false, CanCraftTPR(player), true, "tpa");
                        if (err != null)
                        {
                            PrintMsgL(player, "InterruptedTarget", originPlayer.displayName);
                            PrintMsgL(originPlayer, "Interrupted");
                            PrintMsgL(originPlayer, err);
                            TeleportTimers.Remove(originPlayer.userID);
                            return;
                        }
                        err = CheckTargetLocation(originPlayer, player.transform.position, config.TPR.UsableIntoBuildingBlocked, config.TPR.CupOwnerAllowOnBuildingBlocked);
                        if (err != null)
                        {
                            PrintMsgL(player, err);
                            PrintMsgL(originPlayer, "Interrupted");
                            PrintMsgL(originPlayer, err);
                            TeleportTimers.Remove(originPlayer.userID);
                            return;
                        }
                        err = CanPlayerTeleport(originPlayer, player.transform.position, originPlayer.transform.position);
                        if (err != null)
                        {
                            SendReply(player, err);
                            PrintMsgL(originPlayer, "Interrupted");
                            SendReply(originPlayer, err);
                            TeleportTimers.Remove(originPlayer.userID);
                            return;
                        }
                        err = CheckItems(originPlayer);
                        if (err != null)
                        {
                            PrintMsgL(player, "InterruptedTarget", originPlayer.displayName);
                            PrintMsgL(originPlayer, "Interrupted");
                            PrintMsgL(originPlayer, "TPBlockedItem", err);
                            TeleportTimers.Remove(originPlayer.userID);
                            return;
                        }
                        if (UseEconomy())
                        {
                            if (config.TPR.Pay > -1)
                            {
                                if (!CheckEconomy(originPlayer, config.TPR.Pay))
                                {
                                    if (config.TPR.Pay > 0)
                                    {
                                        PrintMsgL(originPlayer, "TPNoMoney", config.TPR.Pay);
                                    }

                                    PrintMsgL(player, "InterruptedTarget", originPlayer.displayName);
                                    TeleportTimers.Remove(originPlayer.userID);
                                    return;
                                }
                                else
                                {
                                    CheckEconomy(originPlayer, config.TPR.Pay, true);

                                    if (config.TPR.Pay > 0)
                                    {
                                        PrintMsgL(originPlayer, "TPMoney", (double)config.TPR.Pay);
                                    }
                                }
                            }
                        }
                    }
                    Teleport(originPlayer, player.transform.position, config.TPR.AllowTPB, config.TPR.UsableOutOfBuildingBlocked, CanCraftTPR(player));
                    var tprData = _TPR[originPlayer.userID];
                    tprData.Amount++;
                    tprData.Timestamp = timestamp;
                    changedTPR = true;
                    PrintMsgL(player, "SuccessTarget", originPlayer.displayName);
                    PrintMsgL(originPlayer, "Success", player.displayName);
                    var limit = GetHigher(originPlayer, config.TPR.VIPDailyLimits, config.TPR.DailyLimit, true);
                    if (limit > 0) PrintMsgL(originPlayer, "TPRAmount", limit - tprData.Amount);
                    TeleportTimers.Remove(originPlayer.userID);
                    Interface.CallHook("OnTeleportRequestCompleted", player, originPlayer);
                })
            };
            reqTimer.Destroy();
            PendingRequests.Remove(player.userID);
            PlayersRequests.Remove(player.userID);
            PlayersRequests.Remove(originPlayer.userID);
        }

        private void CommandWipeHomes(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermWipeHomes)) return;
            if (_Home.Count > 0) Puts("{0} ({1}) wiped homes", player.displayName, player.userID);
            _Home.Clear();
            changedHome = true;
            PrintMsgL(player, "HomesListWiped");
        }

        private void CommandTeleportHelp(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!player || !player.IsConnected || player.IsSleeping()) return;
            if (!config.Settings.HomesEnabled && !config.Settings.TPREnabled && !IsAllowedMsg(player)) return;
            if (args.Length == 1)
            {
                var key = $"TPHelp{args[0].ToLower()}";
                var msg = _(key, player);
                if (key.Equals(msg))
                    PrintMsgL(player, "InvalidHelpModule");
                else
                    PrintMsg(player, msg);
            }
            else
            {
                var msg = _("TPHelpGeneral", player);
                if (IsAllowed(player))
                    msg += NewLine + "/tphelp AdminTP";
                if (config.Settings.HomesEnabled)
                    msg += NewLine + "/tphelp Home";
                if (config.Settings.TPREnabled)
                    msg += NewLine + "/tphelp TPR";
                PrintMsg(player, msg);
            }
        }

        private List<string> _tpid = new List<string> { "home", "bandit", "outpost", "tpr", "town" };

        private void CommandTeleportInfo(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!player || !player.IsConnected || player.IsSleeping() || !TeleportInForcedBoundary(player)) return;
            if (args.Length == 1)
            {
                var module = args[0].ToLower();
                var settings = GetSettings(module);
                var msg = _(_tpid.Contains(module) || settings == null ? $"TPSettings{module}" : "TPSettingsdynamic", player);
                var timestamp = Facepunch.Math.Epoch.Current;
                var currentDate = DateTime.Now.ToString("d");
                int limit;
                int cooldown;

                switch (module)
                {
                    case "home":
                        if (!IsAllowedMsg(player, PermHome)) return;
                        limit = GetHigher(player, config.Home.VIPDailyLimits, config.Home.DailyLimit, true);
                        cooldown = GetLower(player, config.Home.VIPCooldowns, config.Home.Cooldown);
                        int homeLimits = GetHigher(player, config.Home.VIPHomesLimits, config.Home.HomesLimit, true);
                        PrintMsg(player, string.Format(msg, FormatTime(player, cooldown), limit > 0 ? limit.ToString() : _("Unlimited", player), homeLimits));
                        HomeData homeData;
                        if (!_Home.TryGetValue(player.userID, out homeData))
                            _Home[player.userID] = homeData = new HomeData();
                        if (homeData.Teleports.Date != currentDate)
                        {
                            homeData.Teleports.Amount = 0;
                            homeData.Teleports.Date = currentDate;
                        }
                        if (limit > 0) PrintMsgL(player, "HomeTPAmount", limit - homeData.Teleports.Amount);
                        if (cooldown > 0 && timestamp - homeData.Teleports.Timestamp < cooldown)
                        {
                            var remain = cooldown - (timestamp - homeData.Teleports.Timestamp);
                            PrintMsgL(player, "HomeTPCooldown", FormatTime(player, remain));
                        }
                        break;
                    case "tpr":
                        if (!IsAllowedMsg(player, PermTpR)) return;
                        limit = GetHigher(player, config.TPR.VIPDailyLimits, config.TPR.DailyLimit, true);
                        cooldown = GetLower(player, config.TPR.VIPCooldowns, config.TPR.Cooldown);
                        PrintMsg(player, string.Format(msg, FormatTime(player, cooldown), limit > 0 ? limit.ToString() : _("Unlimited", player)));
                        TeleportData tprData;
                        if (!_TPR.TryGetValue(player.userID, out tprData))
                            _TPR[player.userID] = tprData = new TeleportData();
                        if (tprData.Date != currentDate)
                        {
                            tprData.Amount = 0;
                            tprData.Date = currentDate;
                        }
                        if (limit > 0) PrintMsgL(player, "TPRAmount", limit - tprData.Amount);
                        if (cooldown > 0 && timestamp - tprData.Timestamp < cooldown)
                        {
                            var remain = cooldown - (timestamp - tprData.Timestamp);
                            PrintMsgL(player, "TPRCooldown", FormatTime(player, remain));
                        }
                        break;
                    default: // town island outpost bandit etc
                        if (settings == null)
                        {
                            PrintMsgL(player, "InvalidHelpModule");
                            break;
                        }

                        limit = GetHigher(player, settings.VIPDailyLimits, settings.DailyLimit, true);
                        cooldown = GetLower(player, settings.VIPCooldowns, settings.Cooldown);
                        if (_tpid.Contains(module)) PrintMsg(player, string.Format(msg, FormatTime(player, cooldown), limit > 0 ? limit.ToString() : _("Unlimited", player)));
                        else PrintMsg(player, string.Format(msg, module.SentenceCase(), FormatTime(player, cooldown), limit > 0 ? limit.ToString() : _("Unlimited", player)));
                        TeleportData tpData;
                        if (!settings.Teleports.TPData.TryGetValue(player.userID, out tpData))
                            settings.Teleports.TPData[player.userID] = tpData = new TeleportData();
                        if (tpData.Date != currentDate)
                        {
                            tpData.Amount = 0;
                            tpData.Date = currentDate;
                        }
                        var language = lang.GetMessage(settings.Command, this, user.Id);
                        if (limit > 0) PrintMsgL(player, "DM_TownTPAmount", limit - tpData.Amount, language);
                        if (!string.IsNullOrEmpty(config.Settings.BypassCMD) && cooldown > 0 && timestamp - tpData.Timestamp < cooldown)
                        {
                            if (Interface.CallHook("OnTeleportCooldownNotify", player) != null)
                            {
                                break;
                            }

                            var remain = cooldown - (timestamp - tpData.Timestamp);
                            PrintMsgL(player, "DM_TownTPCooldown", FormatTime(player, remain));

                            if (settings.Bypass > 0)
                            {
                                PrintMsgL(player, "DM_TownTPCooldownBypassP", settings.Bypass);
                                PrintMsgL(player, "DM_TownTPCooldownBypassP2", language, config.Settings.BypassCMD);
                            }
                        }
                        break;
                }
            }
            else
            {
                var msg = _("TPInfoGeneral", player);
                if (config.Settings.HomesEnabled && IsAllowed(player, PermHome))
                    msg += NewLine + "/tpinfo Home";
                if (config.Settings.TPREnabled && IsAllowed(player, PermTpR))
                    msg += NewLine + "/tpinfo TPR";
                foreach (var entry in config.DynamicCommands)
                {
                    if (entry.Value.Enabled)
                    {
                        if (command == "bandit" && !banditEnabled) continue;
                        if (command == "outpost" && !outpostEnabled) continue;
                        if (!IsAllowed(player, $"{Name}.tp{entry.Key}")) continue;
                        msg += NewLine + $"/tpinfo {entry.Key}";
                    }
                }
                PrintMsgL(player, msg);
            }
        }

        private void CommandTeleportCancel(IPlayer user, string command, string[] args)
        {
            var player = user.Object as BasePlayer;
            if (!player || !player.IsConnected || player.IsSleeping()) return;
            DestroyTeleportRequestCUI(player);
            if (args.Length != 0)
            {
                PrintMsgL(player, "SyntaxCommandTPC");
                return;
            }
            TeleportTimer teleportTimer;
            if (TeleportTimers.TryGetValue(player.userID, out teleportTimer))
            {
                teleportTimer.Timer?.Destroy();
                PrintMsgL(player, "TPCancelled");
                PrintMsgL(teleportTimer.TargetPlayer, "TPCancelledTarget", player.displayName);
                TeleportTimers.Remove(player.userID);
                Interface.CallHook("OnTeleportRejected", player, teleportTimer.TargetPlayer);
                return;
            }
            foreach (var keyValuePair in TeleportTimers)
            {
                if (keyValuePair.Value.TargetPlayer != player) continue;
                keyValuePair.Value.Timer?.Destroy();
                PrintMsgL(keyValuePair.Value.OriginPlayer, "TPCancelledTarget", player.displayName);
                PrintMsgL(player, "TPYouCancelledTarget", keyValuePair.Value.OriginPlayer.displayName);
                TeleportTimers.Remove(keyValuePair.Key);
                Interface.CallHook("OnTeleportRejected", player, keyValuePair.Value.OriginPlayer);
                return;
            }
            if (!PlayersRequests.TryGetValue(player.userID, out var target))
            {
                PrintMsgL(player, "NoPendingRequest");
                return;
            }
            if (PendingRequests.TryGetValue(player.userID, out var reqTimer))
            {
                reqTimer.Destroy();
                PendingRequests.Remove(player.userID);
            }
            else if (PendingRequests.TryGetValue(target.userID, out reqTimer))
            {
                reqTimer.Destroy();
                PendingRequests.Remove(target.userID);
                var temp = player;
                player = target;
                target = temp;
            }
            PlayersRequests.Remove(target.userID);
            PlayersRequests.Remove(player.userID);
            PrintMsgL(player, "Cancelled", target.displayName);
            PrintMsgL(target, "CancelledTarget", player.displayName);
            Interface.CallHook("OnTeleportRejected", player, target);
        }

        private void CommandDynamic(IPlayer user, string command, string[] args)
        {
            if (!user.HasPermission(PermAdmin) || args.Length != 2 || args[0].Equals("list", StringComparison.OrdinalIgnoreCase))
            {
                CommandTeleportInfo(user, command, args.Skip(1).ToArray());
                return;
            }

            var value = args[1].ToLower();

            if (args[0].Equals("add", StringComparison.OrdinalIgnoreCase))
            {
                TownSettings settings;
                if (GetSettings(value) == null)
                {
                    config.DynamicCommands.Add(value, settings = new TownSettings());
                    RegisterCommand(value, settings, true);
                    RegisterCommand(value, nameof(CommandCustom));
                    PrintMsgL(user, "DM_TownTPCreated", value);
                    SaveConfig();
                }
                else PrintMsgL(user, "DM_TownTPExists", value);
            }
            else if (args[0].Equals("remove", StringComparison.OrdinalIgnoreCase))
            {
                var key = config.DynamicCommands.Keys.FirstOrDefault(x => x.Equals(value, StringComparison.OrdinalIgnoreCase));

                if (!string.IsNullOrEmpty(key))
                {
                    PrintMsgL(user, "DM_TownTPRemoved", key);
                    config.DynamicCommands.Remove(key);
                    UnregisterCommand(value);
                    SaveConfig();
                }
                else PrintMsgL(user, "DM_TownTPDoesNotExist", value);
            }
            else CommandTeleportInfo(user, command, args);
        }

        private void CommandCustom(IPlayer user, string command, string[] args)
        {
            CommandTown(user, command, args);
        }

        private TownSettings GetSettings(string command, ulong userid = 0uL)
        {
            if (command.Equals("home", StringComparison.OrdinalIgnoreCase) && _Home.ContainsKey(userid))
            {
                return new TownSettings
                {
                    VIPCooldowns = config.Home.VIPCooldowns,
                    Cooldown = config.Home.Cooldown,
                    Countdown = config.Home.Countdown,
                    Teleports = new StoredData
                    {
                        TPData = new Dictionary<ulong, TeleportData>
                        {
                            [userid] = _Home[userid].Teleports
                        }
                    }
                };
            }

            if (command.Equals("tpr", StringComparison.OrdinalIgnoreCase) && _TPR.ContainsKey(userid))
            {
                return new TownSettings
                {
                    VIPCooldowns = config.TPR.VIPCooldowns,
                    Cooldown = config.TPR.Cooldown,
                    Countdown = config.TPR.Countdown,
                    Teleports = new StoredData
                    {
                        TPData = new Dictionary<ulong, TeleportData>
                        {
                            [userid] = _TPR[userid]
                        }
                    }
                };
            }

            foreach (var x in config.DynamicCommands)
            {
                if (x.Key.Equals(command, StringComparison.OrdinalIgnoreCase))
                {
                    return x.Value;
                }
            }

            return null;
        }

        private bool IsServerCommand(IPlayer user, string command, string[] args)
        {
            if (!user.IsServer)
            {
                return false;
            }
            var settings = GetSettings(command);
            if (settings == null)
            {
                user.Reply($"Command '{command}' not found in config.");
                return false;
            }
            if (args.Length == 0)
            {
                string positions = string.Join(", ", settings.Locations.ToArray());
                user.Reply($"{command} locations: {positions}");
                return true;
            }
            if (args[0] == "clear")
            {
                settings.Location = Vector3.zero;
                settings.Locations.Clear();
                user.Reply($"{command} locations have been cleared.");
            }
            else
            {
                try
                {
                    var vector = string.Join(" ", args).ToVector3();
                    if (vector == Vector3.zero)
                    {
                        throw new InvalidCastException("vector");
                    }
                    if (!settings.Locations.Contains(vector))
                    {
                        settings.Locations.Insert(0, vector);
                        user.Reply($"{command} location manually set to: " + vector);
                    }
                    else user.Reply($"{command} location was already set to: " + vector);
                    settings.Location = vector;
                }
                catch
                {
                    user.Reply($"Invalid position specified ({string.Join(" ", args)})");
                    return true;
                }
            }
            if (command == "bandit")
            {
                banditEnabled = settings.Locations.Count > 0;
            }
            if (command == "outpost")
            {
                outpostEnabled = settings.Locations.Count > 0;
            }
            SaveConfig();
            return true;
        }

        private void CommandTown(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command)) { user.Reply("Disabled command: " + command); return; }
            if (IsServerCommand(user, command, args)) return;
            var player = user.Object as BasePlayer;
#if DEBUG
            Puts($"cmdChatTown: command={command}");
#endif
            if (!IsAllowedMsg(player, $"{Name}.tp{command}".ToLower()) || !TeleportInForcedBoundary(player)) return;

            if (!CanBypassRestrictions(player.UserIDString))
            {
                float globalCooldownTime = GetGlobalCooldown(player);
                if (globalCooldownTime > 0f)
                {
                    PrintMsgL(player, "WaitGlobalCooldown", FormatTime(player, (int)globalCooldownTime));
                    return;
                }

                if (config.Settings.BlockAuthorizedTeleporting && player.IsBuildingAuthed())
                {
                    PrintMsgL(player, "CannotTeleportFromHome");
                    return;
                }
            }

            var settings = GetSettings(command);

            if (settings == null)
            {
                return;
            }

            var language = lang.GetMessage(settings.Command, this, user.Id);

            // For admin using set, add, clear or show command locations
            if (args.Length >= 1 && IsAllowed(player, PermAdmin))
            {
                var param = args[0].ToLower();

                if (param.Equals("clear"))
                {
                    settings.Location = Vector3.zero;
                    settings.Locations.Clear();
                    SaveConfig();
                    PrintMsgL(player, "DM_TownTPLocationsCleared", language);
                    return;
                }
                else if (param.Equals("set"))
                {
                    if (settings.Locations.Count > 0)
                    {
                        settings.Locations.RemoveAt(0);
                    }
                    var position = player.transform.position;
                    settings.Locations.Insert(0, settings.Location = position);
                    SaveConfig();
                    PrintMsgL(player, "DM_TownTPLocation", language, position);
                    return;
                }
                else if (param.Equals("add"))
                {
                    var position = player.transform.position;
                    int num = settings.Locations.RemoveAll(x => Vector3.Distance(position, x) < 25f);
                    settings.Locations.Add(position);
                    SaveConfig();
                    PrintMsgL(player, "DM_TownTPLocation", language, position);
                    return;
                }
                else if (args[0].Equals("show", StringComparison.OrdinalIgnoreCase))
                {
                    settings.Locations.ForEach(x => player.SendConsoleCommand("ddraw.text", 30f, Color.green, x, command));
                    return;
                }
            }

            bool paidmoney = false;

            // Is command usage enabled?
            if (!settings.Enabled)
            {
                PrintMsgL(player, "DM_TownTPDisabled", language.SentenceCase());
                return;
            }

            if (settings.Location != Vector3.zero && !settings.Locations.Contains(settings.Location))
            {
                settings.Locations.Add(settings.Location);
            }

            // Is location set?
            if (settings.Locations.Count == 0)
            {
                PrintMsgL(player, "DM_TownTPNoLocation", language.SentenceCase());
                return;
            }

            // Are they trying to bypass cooldown or did they just type something else?
            if (args.Length == 1 && !string.IsNullOrEmpty(config.Settings.BypassCMD) && args[0].ToLower() != config.Settings.BypassCMD.ToLower() && !args[0].All(char.IsDigit))
            {
                string com = command ?? "town";
                string msg = "SyntaxCommand" + char.ToUpper(com[0]) + com.Substring(1);
                PrintMsgL(player, msg);
                if (IsAllowed(player)) PrintMsgL(player, msg + "Admin");
                return;
            }

            TeleportData teleportData;
            if (!settings.Teleports.TPData.TryGetValue(player.userID, out teleportData))
            {
                settings.Teleports.TPData[player.userID] = teleportData = new TeleportData();
            }
            int limit = 0;
            var timestamp = Facepunch.Math.Epoch.Current;
            var currentDate = DateTime.Now.ToString("d");

            // Setup vars for checks below
            string err = null;
            if (!CanBypassRestrictions(player.UserIDString))
            {
                var getUseableTime = GetUseableTime(settings.Hours);
                if (getUseableTime > 0.0)
                {
                    PrintMsgL(player, "NotUseable", FormatTime(player, getUseableTime));
                    return;
                }
                err = CheckPlayer(player, settings.UsableOutOfBuildingBlocked, settings.CanCraft(player, command), true, "town");
                if (err != null)
                {
                    PrintMsgL(player, err);
                    return;
                }
                var cooldown = GetLower(player, settings.VIPCooldowns, settings.Cooldown);

                if (teleportData.Date != currentDate)
                {
                    teleportData.Amount = 0;
                    teleportData.Date = currentDate;
                }
                limit = GetHigher(player, settings.VIPDailyLimits, settings.DailyLimit, true);
#if DEBUG
                Puts("Calling CheckPlayer from cmdChatTown");
#endif

                // Check and process cooldown, bypass, and payment for all modes
                if (cooldown > 0 && timestamp - teleportData.Timestamp < cooldown)
                {
                    var cmdSent = args.Length >= 1 ? args[0].ToLower() : string.Empty;

                    if (!string.IsNullOrEmpty(config.Settings.BypassCMD))
                    {
                        if (cmdSent == config.Settings.BypassCMD.ToLower() && settings.Bypass > -1)
                        {
                            bool foundmoney = CheckEconomy(player, settings.Bypass);

                            if (foundmoney)
                            {
                                CheckEconomy(player, settings.Bypass, true);
                                paidmoney = true;

                                if (settings.Bypass > 0)
                                {
                                    PrintMsgL(player, "DM_TownTPCooldownBypass", settings.Bypass);
                                }

                                if (settings.Pay > 0)
                                {
                                    PrintMsgL(player, "PayToTown", settings.Pay, language);
                                }
                            }
                            else
                            {
                                PrintMsgL(player, "DM_TownTPCooldownBypassF", settings.Bypass);
                                return;
                            }
                        }
                        else if (UseEconomy())
                        {
                            if (Interface.CallHook("OnTeleportCooldownNotify", player) != null)
                            {
                                return;
                            }
                            var remain = cooldown - (timestamp - teleportData.Timestamp);
                            PrintMsgL(player, "DM_TownTPCooldown", FormatTime(player, remain));
                            if (settings.Bypass > -1)
                            {
                                PrintMsgL(player, "DM_TownTPCooldownBypassP", settings.Bypass);
                                PrintMsgL(player, "DM_TownTPCooldownBypassP2", language, config.Settings.BypassCMD);
                            }
                            return;
                        }
                        else
                        {
                            if (Interface.CallHook("OnTeleportCooldownNotify", player) != null)
                            {
                                return;
                            }
                            var remain = cooldown - (timestamp - teleportData.Timestamp);
                            PrintMsgL(player, "DM_TownTPCooldown", FormatTime(player, remain));
                            return;
                        }
                    }
                    else
                    {
                        if (Interface.CallHook("OnTeleportCooldownNotify", player) != null)
                        {
                            return;
                        }
                        var remain = cooldown - (timestamp - teleportData.Timestamp);
                        PrintMsgL(player, "DM_TownTPCooldown", FormatTime(player, remain));
                        return;
                    }
                }

                if (limit > 0 && teleportData.Amount >= limit)
                {
                    var left = FormatTime(player, (int)SecondsUntilTomorrow());
                    PrintMsgL(player, "DM_TownTPLimitReached", limit, left);
                    return;
                }
            }
            if (TeleportTimers.ContainsKey(player.userID))
            {
                PrintMsgL(player, "TeleportPendingTPC");
                return;
            }

            Vector3 location;
            int index;
            if (args.Length == 1 && int.TryParse(args[0], out index))
            {
                index = Mathf.Clamp(index, 0, settings.Locations.Count - 1);
                location = settings.Locations[index];
            }
            else if (settings.Random)
            {
                location = settings.Locations.GetRandom();
            }
            else location = settings.Locations.First();

            if (!CanBypassRestrictions(player.UserIDString))
            {
                err = CanPlayerTeleport(player, location, player.transform.position);
                if (err != null)
                {
                    SendReply(player, err);
                    return;
                }
                err = CheckItems(player);
                if (err != null)
                {
                    PrintMsgL(player, "TPBlockedItem", err);
                    return;
                }
            }
            int countdown = GetLower(player, settings.VIPCountdowns, settings.Countdown);
            TeleportTimers[player.userID] = new TeleportTimer
            {
                OriginPlayer = player,
                Timer = timer.Once(countdown, () =>
                {
#if DEBUG
                    Puts($"Calling CheckPlayer from cmdChatTown {command} timer loop");
#endif
                    if (!CanBypassRestrictions(player.UserIDString))
                    {
                        if (!TeleportInForcedBoundary(player))
                        {
                            return;
                        }
                        if (config.Settings.BlockAuthorizedTeleporting && player.IsBuildingAuthed())
                        {
                            PrintMsgL(player, "CannotTeleportFromHome");
                            return;
                        }
                        err = CheckPlayer(player, settings.UsableOutOfBuildingBlocked, settings.CanCraft(player, command.ToLower()), true, "town", settings.AllowCave);
                        if (err != null)
                        {
                            Interrupt(player, paidmoney, settings.Bypass);
                            PrintMsgL(player, err);
                            return;
                        }
                        err = CanPlayerTeleport(player, location, player.transform.position);
                        if (err != null)
                        {
                            Interrupt(player, paidmoney, settings.Bypass);
                            PrintMsgL(player, err);
                            return;
                        }
                        err = CheckItems(player);
                        if (err != null)
                        {
                            Interrupt(player, paidmoney, settings.Bypass);
                            PrintMsgL(player, "TPBlockedItem", err);
                            return;
                        }
                        if (settings.Locations.Count == 0)
                        {
                            Interrupt(player, paidmoney, settings.Bypass);
                            return;
                        }
                        if (UseEconomy())
                        {
                            if (settings.Pay < 0)
                            {
                                return;
                            }
                            if (settings.Pay > 0 && !CheckEconomy(player, settings.Pay))
                            {
                                Interrupt(player, false, 0);
                                PrintMsgL(player, "TPNoMoney", settings.Pay);
                                return;
                            }
                            if (settings.Pay > -1 && !paidmoney)
                            {
                                CheckEconomy(player, settings.Pay, true);

                                if (settings.Pay > 0)
                                {
                                    PrintMsgL(player, "TPMoney", (double)settings.Pay);
                                }
                            }
                        }
                    }
                    Teleport(player, location, settings.AllowTPB, settings.UsableOutOfBuildingBlocked, settings.CanCraft(player, command));
                    teleportData.Amount++;
                    teleportData.Timestamp = timestamp;
                    settings.Teleports.Changed = true;
                    PrintMsgL(player, "DM_TownTP", language);
                    if (limit > 0) PrintMsgL(player, "DM_TownTPAmount", limit - teleportData.Amount, language);
                    TeleportTimers.Remove(player.userID);
                })
            };

            if (countdown > 0)
            {
                PrintMsgL(player, "DM_TownTPStarted", language, countdown);
            }
        }

        private double SecondsUntilTomorrow()
        {
            var tomorrow = DateTime.Now.AddDays(1).Date;
            return (tomorrow - DateTime.Now).TotalSeconds;
        }

        private void Interrupt(BasePlayer player, bool paidmoney, double bypass)
        {
            PrintMsgL(player, "Interrupted");
            if (paidmoney)
            {
                CheckEconomy(player, bypass, false, true);
            }
            TeleportTimers.Remove(player.userID);
        }

        private void CommandTeleportII(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!user.IsAdmin && !IsAllowedMsg(player, PermTpConsole)) return;

            List<BasePlayer> players;
            switch (command)
            {
                case "teleport.topos":
                    if (args.Length < 4)
                    {
                        user.Reply(_("SyntaxConsoleCommandToPos", player));
                        return;
                    }
                    players = FindPlayers(args[0], true);
                    if (players.Count <= 0)
                    {
                        user.Reply(_("PlayerNotFound", player));
                        return;
                    }
                    if (players.Count > 1)
                    {
                        user.Reply(_("MultiplePlayers", player, GetMultiplePlayers(players)));
                        return;
                    }
                    var targetPlayer = players[0];
                    players.Clear();
                    float x;
                    if (!float.TryParse(args[1], out x)) x = -10000f;
                    float y;
                    if (!float.TryParse(args[2], out y)) y = -10000f;
                    float z;
                    if (!float.TryParse(args[3], out z)) z = -10000f;
                    if (!CheckBoundaries(x, y, z))
                    {
                        user.Reply(_("AdminTPOutOfBounds", player) + System.Environment.NewLine + _("AdminTPBoundaries", player, boundary));
                        return;
                    }
                    Teleport(targetPlayer, x, y, z);
                    if (config.Admin.AnnounceTeleportToTarget)
                        PrintMsgL(targetPlayer, "AdminTPConsoleTP", targetPlayer.transform.position);
                    user.Reply(_("AdminTPTargetCoordinates", player, targetPlayer.displayName, targetPlayer.transform.position));
                    Puts(_("LogTeleportPlayer", null, player?.displayName, targetPlayer.displayName, targetPlayer.transform.position));
                    break;
                case "teleport.toplayer":
                    if (args.Length < 2)
                    {
                        user.Reply(_("SyntaxConsoleCommandToPlayer", player));
                        return;
                    }
                    players = FindPlayers(args[0], true);
                    if (players.Count <= 0)
                    {
                        user.Reply(_("PlayerNotFound", player));
                        return;
                    }
                    if (players.Count > 1)
                    {
                        user.Reply(_("MultiplePlayers", player, GetMultiplePlayers(players)));
                        return;
                    }
                    var originPlayer = players.First();
                    players = FindPlayers(args[1], true);
                    if (players.Count <= 0)
                    {
                        user.Reply(_("PlayerNotFound", player));
                        return;
                    }
                    if (players.Count > 1)
                    {
                        user.Reply(_("MultiplePlayers", player, GetMultiplePlayers(players)));
                        players.Clear();
                        return;
                    }
                    targetPlayer = players.First();
                    if (targetPlayer == originPlayer)
                    {
                        players.Clear();
                        user.Reply(_("CantTeleportPlayerToSelf", player));
                        return;
                    }
                    players.Clear();
                    Teleport(originPlayer, targetPlayer);
                    user.Reply(_("AdminTPPlayers", player, originPlayer.displayName, targetPlayer.displayName));
                    PrintMsgL(originPlayer, "AdminTPConsoleTPPlayer", targetPlayer.displayName);
                    if (config.Admin.AnnounceTeleportToTarget)
                        PrintMsgL(targetPlayer, "AdminTPConsoleTPPlayerTarget", originPlayer.displayName);
                    Puts(_("LogTeleportPlayer", null, player?.displayName, originPlayer.displayName, targetPlayer.displayName));
                    break;
            }
        }

        private void CommandSphereMonuments(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!player || !player.IsAdmin) return;
            foreach (var mi in monuments)
            {
                player.SendConsoleCommand("ddraw.sphere", 30f, Color.red, mi.position, mi.radius);
                player.SendConsoleCommand("ddraw.text", 30f, Color.blue, mi.position, $"<size=22>{mi.name}</size>");
            }
            foreach (var cave in caves)
            {
                string name = cave.Key.Contains(":") ? cave.Key.Substring(0, cave.Key.LastIndexOf(":")) : cave.Key.TrimEnd();
                player.SendConsoleCommand("ddraw.sphere", 30f, Color.black, cave.Value, 25f);
                player.SendConsoleCommand("ddraw.text", 30f, Color.cyan, cave.Value, $"<size=22>{name}</size>");
            }
        }

        private void CommandImportHomes(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;

            if (!user.IsAdmin && !IsAllowedMsg(player, PermImportHomes))
            {
                user.Reply(_("NotAllowed", player));
                return;
            }
            var fileName = string.IsNullOrEmpty(config.Settings.DataFileFolder) ? "m-Teleportation" : $"{config.Settings.DataFileFolder}{Path.DirectorySeparatorChar}m-Teleportation";
            var datafile = Interface.Oxide.DataFileSystem.GetFile(fileName);
            if (!datafile.Exists())
            {
                user.Reply("No m-Teleportation.json exists.");
                return;
            }
            datafile.Load();
            var allHomeData = datafile["HomeData"] as Dictionary<string, object>;
            if (allHomeData == null)
            {
                user.Reply(_("HomeListEmpty", player));
                return;
            }
            var count = 0;
            foreach (var kvp in allHomeData)
            {
                var homeDataOld = kvp.Value as Dictionary<string, object>;
                if (homeDataOld == null) continue;
                if (!homeDataOld.ContainsKey("HomeLocations")) continue;
                var homeList = homeDataOld["HomeLocations"] as Dictionary<string, object>;
                if (homeList == null) continue;
                var userId = Convert.ToUInt64(kvp.Key);
                HomeData homeData;
                if (!_Home.TryGetValue(userId, out homeData))
                    _Home[userId] = homeData = new HomeData();
                var target = RustCore.FindPlayerById(userId);
                foreach (var kvp2 in homeList)
                {
                    var positionData = kvp2.Value as Dictionary<string, object>;
                    if (positionData == null) continue;
                    if (!positionData.ContainsKey("x") || !positionData.ContainsKey("y") || !positionData.ContainsKey("z")) continue;
                    var position = new Vector3(Convert.ToSingle(positionData["x"]), Convert.ToSingle(positionData["y"]), Convert.ToSingle(positionData["z"]));
                    homeData.Set(kvp2.Key, new HomeData.Entry(position));
                    changedHome = true;
                    count++;
                    Interface.CallHook("OnHomeAdded", target, position, kvp2.Key);
                }
            }
            user.Reply(string.Format("Imported {0} homes.", count));
            if (!user.IsServer) Puts("Imported {0} homes.", count);
        }

        private void RequestTimedOut(BasePlayer player, BasePlayer target)
        {
            PlayersRequests.Remove(player.userID);
            PlayersRequests.Remove(target.userID);
            PendingRequests.Remove(target.userID);
            PrintMsgL(player, "TimedOut", target.displayName);
            PrintMsgL(target, "TimedOutTarget", player.displayName);
        }

        private void CommandPluginInfo(IPlayer user, string command, string[] args)
        {
            if (!user.IsServer) return;
            user.Reply($"01. {permission.GetPermissionGroups("nteleportation.tp").Count()}");
            user.Reply($"02. {permission.GetPermissionGroups("nteleportation.admin").Count()}");
            user.Reply($"03. {permission.GetPermissionUsers("nteleportation.tp").Count()}");
            user.Reply($"04. {permission.GetPermissionUsers("nteleportation.admin").Count()}");
            user.Reply($"05. {permission.GroupHasPermission("admin", "nteleportation.tp")}");
            user.Reply($"06. {permission.GroupHasPermission("admin", "nteleportation.admin")}");
            user.Reply($"07. {permission.GroupHasPermission("default", "nteleportation.tp")}");
            user.Reply($"08. {permission.GroupHasPermission("default", "nteleportation.admin")}");
            user.Reply($"09. {BasePlayer.activePlayerList.Count(x => x?.Connection?.authLevel > 0)}");
            user.Reply($"10. {BasePlayer.activePlayerList.Count(x => IsAllowed(x))}");
            user.Reply($"11. {BasePlayer.activePlayerList.Count}");
        }

        #region Util

        private readonly System.Text.StringBuilder _sb = new System.Text.StringBuilder();

        private string FormatTime(BasePlayer player, double seconds) // Credits MoNaH
        {
            if (config.Settings.UseSeconds) return $"{seconds} {_("Seconds", player)}";

            TimeSpan _ts = TimeSpan.FromSeconds(seconds);

            _sb.Length = 0;

            if (_ts.TotalDays >= 1)
            {
                _sb.Append($"<color={config.Settings.ChatCommandArgumentColor}>{_ts.Days}</color> {_("Days", player)} ");
            }

            if (_ts.TotalHours >= 1)
            {
                _sb.Append($"<color={config.Settings.ChatCommandArgumentColor}>{_ts.Hours}</color> {_("Hours", player)} ");
            }

            if (_ts.TotalMinutes >= 1)
            {
                _sb.Append($"<color={config.Settings.ChatCommandArgumentColor}>{_ts.Minutes}</color> {_("Minutes", player)} ");
            }

            _sb.Append($"<color={config.Settings.ChatCommandArgumentColor}>{_ts.Seconds}</color> {_("Seconds", player)} ");

            return _sb.ToString();
        }

        #endregion

        #region Teleport

        public void Teleport(BasePlayer player, BasePlayer target, bool build = true, bool craft = true) => Teleport(player, target.transform.position, true, build, craft);

        public void Teleport(BasePlayer player, float x, float y, float z, bool build = true, bool craft = true) => Teleport(player, new Vector3(x, y, z), true, build, craft);

        [HookMethod("Teleport")]
        public void Teleport(BasePlayer player, Vector3 newPosition, bool allowTPB, bool build = true, bool craft = true)
        {
            if (!player.IsValid() || Vector3.Distance(newPosition, Vector3.zero) < 5f) return;
            if (allowTPB)
            {
                if (config.Settings.TPB.Time > 0)
                {
                    RemoveLocation(player);
                    Vector3 position = player.transform.position;
                    timer.In(config.Settings.TPB.Time, () => SaveLocation(player, position, build, craft));
                }
                else SaveLocation(player, player.transform.position, build, craft);
            }

            if (config.Settings.PlaySoundsBeforeTeleport)
            {
                SendEffect(player, config.Settings.DisappearEffects);
            }

            newPosition.y += 0.1f;

            teleporting[player.userID] = newPosition;

            Subscribe(nameof(OnPlayerViolation));

            var oldPosition = player.transform.position;

            // credits to @ctv and @Def for their assistance

            player.PauseFlyHackDetection(5f);
            player.PauseSpeedHackDetection(5f);
            player.UpdateActiveItem(default(ItemId));
            player.EnsureDismounted();
            player.Server_CancelGesture();

            if (player.HasParent())
            {
                player.SetParent(null, true, true);
            }

            if (player.IsConnected)
            {
                StartSleeping(player);
                player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
                player.ClientRPCPlayer(null, player, config.Settings.Quick ? "StartLoading_Quick" : "StartLoading", arg1: true);
            }

            player.Teleport(newPosition);

            if (player.IsConnected)
            {
                if (!player._limitedNetworking)
                {
                    player.UpdateNetworkGroup();
                    player.SendNetworkUpdateImmediate(false);
                }

                player.ClearEntityQueue(null);
                player.SendFullSnapshot();
                if (CanWake(player)) NextTick(player.EndSleeping);
            }

            if (!player._limitedNetworking)
            {
                player.ForceUpdateTriggers();
            }

            timer.Once(3f, () => RemoveProtections(player.userID));

            SetGlobalCooldown(player);

            if (config.Settings.PlaySoundsAfterTeleport)
            {
                SendEffect(player, config.Settings.ReappearEffects);
            }

            Interface.CallHook("OnPlayerTeleported", player, oldPosition, newPosition);
        }

        private bool CanWake(BasePlayer player)
        {
            if (!config.Settings.AutoWakeUp) return false;
            return player.IsOnGround() || player.limitNetworking || player.IsFlying || player.IsAdmin;
        }

        public void RemoveProtections(ulong userid)
        {
            teleporting.Remove(userid);
            insideTerrainViolations.Remove(userid);
        }

        public void StartSleeping(BasePlayer player) // custom as to not cancel crafting, or remove player from vanish
        {
            if (!player.IsSleeping())
            {
                Interface.CallHook("OnPlayerSleep", player);
                player.SetPlayerFlag(BasePlayer.PlayerFlags.Sleeping, b: true);
                player.sleepStartTime = Time.time;
                BasePlayer.sleepingPlayerList.Add(player);
                player.CancelInvoke("InventoryUpdate");
                player.CancelInvoke("TeamUpdate");
                player.inventory.loot.Clear();
                player.inventory.containerMain.OnChanged();
                player.inventory.containerBelt.OnChanged();
                player.inventory.containerWear.OnChanged();
                player.Invoke("TurnOffAllLights", 0f);
                if (!player._limitedNetworking)
                {
                    player.EnablePlayerCollider();
                    player.RemovePlayerRigidbody();
                }
                else player.RemoveFromTriggers();
                player.SetServerFall(wantsOn: true);
            }
        }

        private void OnMapMarkerAdded(BasePlayer player, ProtoBuf.MapNote note)
        {
            if (player.IsAlive() && permission.UserHasPermission(player.UserIDString, PermTpMarker))
            {
                float y = TerrainMeta.HeightMap.GetHeight(note.worldPosition);
                if (player.IsFlying) y = Mathf.Max(y, player.transform.position.y);
                player.Teleport(note.worldPosition + new Vector3(0f, y, 0f));
            }
        }

        #endregion

        #region Checks
        private string CanPlayerTeleport(BasePlayer player, params Vector3[] vectors)
        {
            if (CanBypassRestrictions(player.UserIDString)) return null;
            foreach (var to in vectors)
            {
                var err = Interface.Oxide.CallHook("CanTeleport", player, to) as string;
                if (!string.IsNullOrEmpty(err)) return err;
            }
            return null;
        }

        private bool CanCraftHome(BasePlayer player)
        {
            return config.Home.AllowCraft || permission.UserHasPermission(player.UserIDString, PermCraftHome) || CanBypassRestrictions(player.UserIDString);
        }

        private bool CanCraftTPR(BasePlayer player)
        {
            return config.TPR.AllowCraft || permission.UserHasPermission(player.UserIDString, PermCraftTpR) || CanBypassRestrictions(player.UserIDString);
        }

        private List<string> monumentExceptions = new List<string> { "outpost", "bandit", "substation", "swamp", "compound.prefab" };

        private bool IsInAllowedMonument(Vector3 target, string mode)
        {
            foreach (var mi in monuments)
            {
                if (config.Settings.Interrupt.BypassMonumentMarker && mi.prefab.Contains("monument_marker"))
                {
                    continue;
                }
                if (Vector3Ex.Distance2D(target, mi.position) <= mi.radius || mi.IsInBounds(target))
                {
                    if (monumentExceptions.Exists(mi.name.ToLower().Contains))
                    {
                        return true;
                    }
                    return !config.Settings.Interrupt.Monument || mode != "sethome" && config.Settings.Interrupt.Monuments.Exists(value => mi.name.Contains(value, CompareOptions.OrdinalIgnoreCase));
                }
            }
            return false;
        }

        private string NearMonument(Vector3 target, bool check, string mode)
        {
            foreach (var mi in monuments)
            {
                if (monumentExceptions.Exists(mi.name.ToLower().Contains)) continue;
                if (!check && config.Settings.Interrupt.BypassMonumentMarker && mi.prefab.Contains("monument_marker")) continue;

                float dist = Vector3Ex.Distance2D(target, mi.position);
#if DEBUG
                Puts($"Checking {mi.name} dist: {dist}, realdistance: {mi.radius}, size: {mi.monument?.Bounds.size.Max()}");
#endif
                if (dist <= mi.radius || mi.IsInBounds(target))
                {
                    if (config.Home.AllowedMonuments.Any(m => mi.name.Equals(m, StringComparison.OrdinalIgnoreCase)))
                    {
                        return null;
                    }

                    if (config.Settings.Interrupt.Monuments.Count > 0 && mode != "sethome")
                    {
                        if (config.Settings.Interrupt.Monuments.Exists(value => mi.name.Contains(value, CompareOptions.OrdinalIgnoreCase)))
                        {
#if DEBUG
                            Puts($"{target} in range of {mi.name}");
#endif
                            return mi.name;
                        }

#if DEBUG
                        Puts($"{target} is not blocked from {mi.name}");
#endif
                        return null;
                    }
#if DEBUG
                    Puts($"{target} in range of {mi.name}");
#endif
                    return mi.name;
                }
            }

            return null;
        }

        private string CheckPlayer(BasePlayer player, bool build = false, bool craft = false, bool origin = true, string mode = "home", bool allowcave = true)
        {
            if (CanBypassRestrictions(player.UserIDString)) return null;
            if (config.Settings.Interrupt.Oilrig || config.Settings.Interrupt.Excavator || config.Settings.Interrupt.Monument || mode == "sethome")
            {
                string monname = !config.Settings.Interrupt.Safe && player.InSafeZone() ? null : NearMonument(player.transform.position, false, mode);

                if (!string.IsNullOrEmpty(monname))
                {
                    if (mode == "sethome")
                    {
                        if (config.Home.AllowAtAllMonuments || config.Home.AllowedMonuments.Exists(value => monname.Contains(value, CompareOptions.OrdinalIgnoreCase)))
                        {
                            return null;
                        }

                        return "HomeTooCloseToMon";
                    }
                    else
                    {
                        if (config.Settings.Interrupt.Oilrig && monname.Contains("Oil Rig"))
                        {
                            return "TPOilRig";
                        }

                        if (config.Settings.Interrupt.Excavator && monname.Contains("Excavator"))
                        {
                            return "TPExcavator";
                        }

                        if (config.Settings.Interrupt.Monument)
                        {
                            if (config.Home.AllowedMonuments.Exists(value => monname.Contains(value, CompareOptions.OrdinalIgnoreCase)))
                            {
                                return null;
                            }

                            if (monname.Contains(":")) monname = monname.Substring(0, monname.IndexOf(":"));
                            return _("TooCloseToMon", player, _(monname, player));
                        }
                    }
                }
            }

#if DEBUG
            Puts($"CheckPlayer(): called mode is {mode}");
#endif
            switch (mode)
            {
                case "tpt":
                    allowcave = config.TPT.AllowCave;
                    break;
                case "home":
                    allowcave = config.Home.AllowCave;
                    break;
                case "tpa":
                case "tpr":
                    allowcave = config.TPR.AllowCave;
                    break;
                default:
#if DEBUG
                    Puts("Skipping cave check...");
#endif
                    break;
            }
            if (!allowcave)
            {
#if DEBUG
                Puts("Checking cave distance...");
#endif
                if (IsInCave(player.transform.position))
                {
                    return "TooCloseToCave";
                }
            }

            if (config.Settings.Interrupt.Hostile && (mode == "bandit" || mode == "outpost" || mode == "town"))
            {
                if (player.State.unHostileTimestamp > TimeEx.currentTimestamp || player.unHostileTime > UnityEngine.Time.realtimeSinceStartup)
                {
                    return "TPHostile";
                }
            }

            if (config.Settings.Interrupt.Junkpiles && IsOnJunkPile(player))
            {
                return "TPJunkpile";
            }

            if (config.Settings.Interrupt.Hurt && origin && player.IsWounded())
            {
                return "TPWounded";
            }

            if (config.Settings.Interrupt.Cold && player.metabolism.temperature.value <= config.Settings.MinimumTemp)
            {
                return "TPTooCold";
            }

            if (config.Settings.Interrupt.Hot && player.metabolism.temperature.value >= config.Settings.MaximumTemp)
            {
                return "TPTooHot";
            }

            if (config.Settings.Interrupt.Swimming && player.IsSwimming())
            {
                return "TPSwimming";
            }

            if (config.Settings.Interrupt.Cargo && player.GetComponentInParent<CargoShip>())
            {
                return "TPCargoShip";
            }

            if (config.Settings.Interrupt.Balloon && player.GetComponentInParent<HotAirBalloon>())
            {
                return "TPHotAirBalloon";
            }

            if (config.Settings.Interrupt.Lift && player.GetComponentInParent<Lift>())
            {
                return "TPBucketLift";
            }

            if (config.Settings.Interrupt.Lift && GetLift(player.transform.position))
            {
                return "TPRegLift";
            }

            if (config.Settings.Interrupt.Safe && player.InSafeZone())
            {
                return "TPSafeZone";
            }

            if (!craft && player.inventory.crafting.queue.Count > 0)
            {
                return "TPCrafting";
            }

            if (player.IsDead())
            {
                return "TPDead";
            }

            if (!build && !player.CanBuild())
            {
                return "TPBuildingBlocked";
            }

            if (config.Settings.BlockZoneFlag && ZoneManager != null && Convert.ToBoolean(ZoneManager?.Call("PlayerHasFlag", player, "notp")))
            {
                return "TPFlagZone";
            }

            if (config.Settings.BlockNoEscape && NoEscape != null && Convert.ToBoolean(NoEscape?.Call("IsBlocked", player)))
            {
                return "TPNoEscapeBlocked";
            }

            var entity = GetStandingOnEntity<BaseMountable>(player, Layers.Mask.Vehicle_Detailed | Layers.Mask.Vehicle_Large);

            if (entity is BaseMountable)
            {
                if (entity is Tugboat)
                {
                    return !config.Home.AllowTugboats && !permission.UserHasPermission(player.UserIDString, "nteleportation.tugboatsinterruptbypass") ? "TPTugboat" : null;
                }

                if (config.Settings.Interrupt.Boats && entity is BaseBoat)
                {
                    return "TPBoat";
                }

                if (config.Settings.Interrupt.Mounted)
                {
                    return "TPMounted";
                }
            }

            if (IsWaterBlockedAbove(player, entity))
            {
                return "TPAboveWater";
            }

            if (config.Settings.Interrupt.UnderWater && Math.Round(player.transform.position.y, 2) < Math.Round(TerrainMeta.WaterMap.GetHeight(player.transform.position), 2) && !IsInAllowedMonument(player.transform.position, mode))
            {
                return "TPUnderWater";
            }

            return null;
        }

        private bool IsWaterBlockedAbove(BasePlayer player, BaseEntity entity)
        {
            if (!config.Settings.Interrupt.AboveWater || !AboveWater(player.transform.position))
            {
                return false;
            }
            if ((config.Home.AllowTugboats || permission.UserHasPermission(player.UserIDString, "nteleportation.tugboatsinterruptbypass")) && entity is Tugboat)
            {
                return false;
            }
            if (!config.Settings.Interrupt.Boats && entity != null && entity.ShortPrefabName != "tugboat" && entity is BaseBoat)
            {
                return false;
            }
            return true;
        }

        private string CheckTargetLocation(BasePlayer player, Vector3 targetLocation, bool usableIntoBuildingBlocked, bool cupOwnerAllowOnBuildingBlocked)
        {
            if (CanBypassRestrictions(player.UserIDString)) return null;
            // ubb == UsableIntoBuildingBlocked
            // obb == CupOwnerAllowOnBuildingBlocked
            bool denied = false;
            foreach (var entity in FindEntitiesOfType<BaseEntity>(targetLocation, 3f, Layers.Mask.Construction | Layers.Mask.Vehicle_Large))
            {
                if (entity is Tugboat)
                {
                    if (usableIntoBuildingBlocked || player.CanBuild(entity.WorldSpaceBounds())) return null;
                    return "TPTargetBuildingBlocked";
                }
                if (!(entity is BuildingBlock))
                {
                    continue;
                }
                var block = entity as BuildingBlock;
                if (CheckCupboardBlock(block, player, cupOwnerAllowOnBuildingBlocked))
                {
                    denied = false;
#if DEBUG
                    Puts("Cupboard either owned or there is no cupboard");
#endif
                }
                else if (usableIntoBuildingBlocked && player.userID != block.OwnerID)
                {
                    denied = false;
#if DEBUG
                    Puts("Player does not own block, but UsableIntoBuildingBlocked=true");
#endif
                }
                else if (player.userID == block.OwnerID)
                {
#if DEBUG
                    Puts("Player owns block");
#endif

                    if (!player.IsBuildingBlocked(targetLocation, new Quaternion(), block.bounds))
                    {
#if DEBUG
                        Puts("Player not BuildingBlocked. Likely unprotected building.");
#endif
                        denied = false;
                        break;
                    }
                    else if (usableIntoBuildingBlocked)
                    {
#if DEBUG
                        Puts("Player not blocked because UsableIntoBuildingBlocked=true");
#endif
                        denied = false;
                        break;
                    }
                    else
                    {
#if DEBUG
                        Puts("Player owns block but blocked by UsableIntoBuildingBlocked=false");
#endif
                        denied = true;
                        break;
                    }
                }
                else
                {
#if DEBUG
                    Puts("Player blocked");
#endif
                    denied = true;
                    break;
                }
            }

            return denied ? "TPTargetBuildingBlocked" : null;
        }

        // Check that a building block is owned by/attached to a cupboard, allow tp if not blocked unless allowed by config
        private bool CheckCupboardBlock(BuildingBlock block, BasePlayer player, bool cupOwnerAllowOnBuildingBlocked)
        {
            // obb == CupOwnerAllowOnBuildingBlocked
            var building = block.GetBuilding();
            if (building != null)
            {
#if DEBUG
                Puts("Found building, checking privileges...");
                Puts($"Building ID: {building.ID}");
#endif
                // cupboard overlap.  Check privs.
                if (building.buildingPrivileges == null)
                {
#if DEBUG
                    Puts("No cupboard found, allowing teleport");
#endif
                    return true;
                }

                foreach (var priv in building.buildingPrivileges)
                {
                    if (priv.IsAuthed(player))
                    {
#if DEBUG
                        Puts("Player is authorized to the cupboard");
#endif
                        return true;
                    }
                }

                if (player.userID == block.OwnerID)
                {
                    if (cupOwnerAllowOnBuildingBlocked)
                    {
#if DEBUG
                        // player set the cupboard and is allowed in by config
                        Puts("Player owns cupboard with no auth, but allowed by CupOwnerAllowOnBuildingBlocked=true");
#endif
                        return true;
                    }
#if DEBUG
                    // player set the cupboard but is blocked by config
                    Puts("Player owns cupboard with no auth, but blocked by CupOwnerAllowOnBuildingBlocked=false");
#endif
                    return false;
                }

#if DEBUG
                // player not authed
                Puts("Player does not own cupboard and is not authorized");
#endif
                return false;
            }
#if DEBUG
            Puts("No cupboard or building found - we cannot tell the status of this block");
#endif
            return true;
        }

        private string CheckItems(BasePlayer player)
        {
            foreach (var blockedItem in ReverseBlockedItems)
            {
                if (player.inventory.FindItemByItemID(blockedItem.Key) != null)
                {
                    return blockedItem.Value;
                }
            }
            return null;
        }

        private Collider[] colBuffer = new Collider[8192];

        private List<T> FindEntitiesOfType<T>(Vector3 a, float n, int m = -1) where T : BaseNetworkable
        {
            int hits = Physics.OverlapSphereNonAlloc(a, n, colBuffer, m, QueryTriggerInteraction.Collide);
            List<T> entities = new List<T>();
            for (int i = 0; i < hits; i++)
            {
                var entity = colBuffer[i]?.ToBaseEntity();
                if (entity is T) entities.Add(entity as T);
                colBuffer[i] = null;
            }
            return entities;
        }

        private bool IsInsideEntity(Vector3 a)
        {
            bool faces = Physics.queriesHitBackfaces;
            Physics.queriesHitBackfaces = true;
            RaycastHit hit;
            bool isHit = Physics.Raycast(a + new Vector3(0f, 0.015f, 0f), Vector3.up, out hit, 7f, Layers.Mask.Construction | Layers.Mask.Deployed, QueryTriggerInteraction.Ignore);
            Physics.queriesHitBackfaces = faces;
            if (isHit)
            {
                var e = hit.GetEntity();
                if (e == null || e.PrefabName.Contains("floor.grill"))
                {
                    return false;
                }
                if (e is BuildingBlock)
                {
                    return e.ShortPrefabName.Contains("foundation");
                }
                if (e is SimpleBuildingBlock || e is IceFence || e is ElectricBattery || e is Door || e is BaseOven)
                {
                    return Math.Round(a.y, 2) < Math.Round(hit.point.y, 2);
                }
            }
            return false;
        }

        private string IsInsideEntity(Vector3 targetLocation, ulong userid, string mode)
        {
            if (IsInsideEntity(targetLocation))
            {
                return "TPTargetInsideEntity";
            }
            if (config.Settings.Rock && NearMonument(targetLocation, true, mode) == null && Exploits.TestInsideRock(targetLocation))
            {
                LogToFile("exploiters", $"{userid} sethome inside a rock at {targetLocation}", this, true);
                PrintMsgL(userid, "TPTargetInsideRock");
                return "TPTargetInsideRock";
            }
            return null;
        }

        private bool UnderneathFoundation(Vector3 a)
        {
            RaycastHit hit;
            if (Physics.Raycast(a + new Vector3(0f, 3f, 0f), Vector3.down, out hit, 5f, Layers.Mask.Construction, QueryTriggerInteraction.Ignore))
            {
                var e = hit.GetEntity();

                if (e is BuildingBlock && e.ShortPrefabName.Contains("foundation"))
                {
                    return Math.Round(a.y, 2) < Math.Round(hit.point.y, 2);
                }
            }
            return false;
        }

        private string CheckFoundation(ulong userid, Vector3 position, string mode)
        {
            if (CanBypassRestrictions(userid.ToString())) return null;
            string insideErr = IsInsideEntity(position, userid, mode);
            if (insideErr != null)
            {
                return insideErr;
            }
            if (IsBlockedOnIceberg(position))
            {
                return "HomeIce";
            }
            if (!config.Home.ForceOnTopOfFoundation || permission.UserHasPermission(userid.ToString(), PermFoundationCheck))
            {
                return null;
            }
            if (UnderneathFoundation(position))
            {
                return "HomeFoundationUnderneathFoundation";
            }
            BaseEntity entity;
            if (!IsStandingOnEntity(position, Layers.Mask.Construction | Layers.Mask.Vehicle_Large, out entity, !config.Home.AllowAboveFoundation ? new string[2] { "foundation", "tugboat" } : new string[3] { "floor", "foundation", "tugboat" }))
            {
                return "HomeNoFoundation";
            }
            if (!config.Home.CheckFoundationForOwner || entity is Tugboat || IsAlly(userid, entity.OwnerID))
            {
                return null;
            }
            return "HomeFoundationNotFriendsOwned";
        }

        private bool IsBlockedOnIceberg(Vector3 position)
        {
            if (config.Home.AllowIceberg) return false;
            if (!Physics.SphereCast(position + new Vector3(0f, 1f), 1f, Vector3.down, out var hit, 250f, Layers.Mask.Terrain | Layers.Mask.World)) return false;
            return hit.collider.name.Contains("ice_sheet") || hit.collider.name.Contains("iceberg");
        }

        private BuildingBlock GetFoundationOwned(Vector3 position, ulong userID)
        {
            BaseEntity entity;
            if (!IsStandingOnEntity(position, Layers.Mask.Construction, out entity, new string[1] { "foundation" }) || !PassesStrictCheck(entity, position)) return null;
            if (!config.Home.CheckFoundationForOwner || IsAlly(userID, entity.OwnerID)) return entity as BuildingBlock;
            return null;
        }

        private bool IsAlly(ulong playerId, ulong targetId)
        {
            if (playerId == targetId)
            {
                return true;
            }
            if (config.Home.UseTeams)
            {
                RelationshipManager.PlayerTeam team;
                if (RelationshipManager.ServerInstance.playerToTeam.TryGetValue(playerId, out team) && team.members.Contains(targetId))
                {
                    return true;
                }
            }
            if (config.Home.UseClans && Clans != null && Clans.IsLoaded && Convert.ToBoolean(Clans?.Call("IsClanMember", playerId.ToString(), targetId.ToString())))
            {
                return true;
            }
            if (config.Home.UseFriends && Friends != null && Friends.IsLoaded && Convert.ToBoolean(Friends?.Call("AreFriends", playerId.ToString(), targetId.ToString())))
            {
                return true;
            }
            return false;
        }

        bool IsBlockedUser(ulong playerid, ulong targetid)
        {
            if (config.TPR.UseBlockedUsers && BlockUsers != null && BlockUsers.IsLoaded)
            {
#if DEBUG
                Puts("Is user blocked? {0} / {1}", playerid, targetid);
#endif
                if (Convert.ToBoolean(BlockUsers?.CallHook("IsBlockedUser", targetid, playerid)))
                {
#if DEBUG
                    Puts("  BlockUsers plugin returned true");
#endif
                    return true;
                }
#if DEBUG
                Puts("  BlockUsers plugin returned false");
#endif
            }
            return false;
        }

        private bool PassesStrictCheck(BaseEntity entity, Vector3 position)
        {
            if (!config.Settings.StrictFoundationCheck || entity is Tugboat)
            {
                return true;
            }
#if DEBUG
            Puts($"PassesStrictCheck() called for {entity.ShortPrefabName}");
#endif
            Vector3 center = entity.CenterPoint();

            if (IsExternalWallOverlapped(center, position)) return false;
#if DEBUG
            Puts($"  Checking block: {entity.name} @ center {center}, pos: {position}");
#endif
            if (entity.PrefabName.Contains("triangle.prefab"))
            {
                if (Math.Abs(center.x - position.x) < 0.46f && Math.Abs(center.z - position.z) < 0.46f)
                {
#if DEBUG
                    Puts($"    Found: {entity.ShortPrefabName} @ center: {center}, pos: {position}");
#endif
                    return true;
                }
            }
            else if (entity.PrefabName.Contains("foundation.prefab") || entity.PrefabName.Contains("floor.prefab"))
            {
                if (Math.Abs(center.x - position.x) < 0.7f && Math.Abs(center.z - position.z) < 0.7f)
                {
#if DEBUG
                    Puts($"    Found: {entity.ShortPrefabName} @ center: {center}, pos: {position}");
#endif
                    return true;
                }
            }

            return false;
        }

        private bool IsExternalWallOverlapped(Vector3 center, Vector3 position)
        {
            foreach (var wall in FindEntitiesOfType<BaseEntity>(center, 1.5f))
            {
                if (wall.PrefabName.Contains("external.high"))
                {
#if DEBUG
                    Puts($"    Found: {wall.PrefabName} @ center {center}, pos {position}");
#endif
                    return true;
                }
            }
            return false;
        }

        private T FindEntity<T>(BaseEntity entity) where T : BaseEntity
        {
            if (entity == null)
            {
                return null;
            }
            if (entity is T)
            {
                return entity as T;
            }
            if (!entity.HasParent())
            {
                return null;
            }
            var parent = entity.GetParentEntity();
            while (parent != null)
            {
                if (parent is T)
                {
                    return parent as T;
                }
                parent = parent.GetParentEntity();
            }
            return null;
        }

        private T GetStandingOnEntity<T>(BasePlayer player, int layerMask) where T : BaseEntity
        {
            if (player.HasParent())
            {
                var parent = FindEntity<T>(player.GetParentEntity());
                if (parent != null)
                {
                    return parent;
                }
            }
            if (player.isMounted)
            {
                var mounted = FindEntity<T>(player.GetMounted());
                if (mounted != null)
                {
                    return mounted;
                }
            }
            return GetStandingOnEntity<T>(player.transform.position, layerMask);
        }

        private T GetStandingOnEntity<T>(Vector3 a, int layerMask) where T : BaseEntity
        {
            RaycastHit hit;
            if (Physics.Raycast(a + new Vector3(0f, 0.1f, 0f), Vector3.down, out hit, 1f, layerMask, QueryTriggerInteraction.Ignore))
            {
                var entity = hit.GetEntity();
                if (entity is T) return entity as T;
            }
            return null;
        }

        private bool IsStandingOnEntity(Vector3 a, int layerMask, out BaseEntity entity, string[] prefabs)
        {
            entity = GetStandingOnEntity<BaseEntity>(a, layerMask);
            if (entity == null || !PassesStrictCheck(entity, a)) return false;
            return Array.Exists(prefabs, entity.ShortPrefabName.Contains);
        }

        private bool CheckBoundaries(float x, float y, float z)
        {
            return x <= boundary && x >= -boundary && y <= config.Settings.BoundaryMax && y >= config.Settings.BoundaryMin && z <= boundary && z >= -boundary;
        }

        private Vector3 GetGroundBuilding(Vector3 a)
        {
            a.y = TerrainMeta.HeightMap.GetHeight(a);
            RaycastHit hit;
            if (Physics.Raycast(a.WithY(200f), Vector3.down, out hit, Mathf.Infinity, Layers.Mask.Terrain | Layers.Mask.World | Layers.Mask.Construction | Layers.Mask.Deployed | Layers.Mask.Vehicle_Large, QueryTriggerInteraction.Ignore))
            {
                a.y = Mathf.Max(hit.point.y, a.y);
            }
            return a;
        }

        public bool AboveWater(Vector3 a)
        {
            return TerrainMeta.HeightMap.GetHeight(a) - TerrainMeta.WaterMap.GetHeight(a) < 0;
        }

        private static bool ContainsTopology(TerrainTopology.Enum mask, Vector3 position, float radius)
        {
            return (TerrainMeta.TopologyMap.GetTopology(position, radius) & (int)mask) != 0;
        }

        private bool IsInCave(Vector3 a)
        {
            return GamePhysics.CheckSphere<TerrainCollisionTrigger>(a, 5f, 262144, QueryTriggerInteraction.Collide) && ContainsTopology(TerrainTopology.Enum.Monument, a, 5f);
        }

        private bool GetLift(Vector3 position)
        {
            return FindEntitiesOfType<ProceduralLift>(position, 0.5f).Count > 0;
        }

        private bool IsOnJunkPile(BasePlayer player)
        {
            return player.GetParentEntity() is JunkPile || FindEntitiesOfType<JunkPile>(player.transform.position, 3f, Layers.Mask.World).Count > 0;
        }

        private bool IsAllowed(BasePlayer player, string perm = null)
        {
            if (!player || !player.IsConnected)
            {
                return false;
            }

            if (!string.IsNullOrEmpty(perm) && permission.UserHasPermission(player.UserIDString, perm))
            {
                return !player.IsSleeping();
            }

            if (player.net.connection.authLevel == 1)
            {
                return config.Admin.UseableByModerators;
            }
            else if (player.net.connection.authLevel >= 2)
            {
                return config.Admin.UseableByAdmins;
            }

            return false;
        }

        private bool IsAllowedMsg(BasePlayer player, string perm = null)
        {
            if (IsAllowed(player, perm)) return true;
            PrintMsgL(player, "NotAllowed");
            return false;
        }

        private Effect reusableSoundEffectInstance = new Effect();

        private void SendEffect(BasePlayer player, List<string> effects)
        {
            if (effects.Count != 0)
            {
                reusableSoundEffectInstance.Init(Effect.Type.Generic, player, 0, Vector3.zero, Vector3.forward, player.limitNetworking ? player.Connection : null);
                reusableSoundEffectInstance.pooledString = effects.GetRandom();
                if (string.IsNullOrEmpty(reusableSoundEffectInstance.pooledString))
                {
                    return;
                }
                if (player.limitNetworking)
                {
                    EffectNetwork.Send(reusableSoundEffectInstance, player.Connection);
                }
                else EffectNetwork.Send(reusableSoundEffectInstance);
            }
        }

        private int GetHigher(BasePlayer player, Dictionary<string, int> limits, int limit, bool unlimited)
        {
            if (unlimited && limit == 0) return limit;

            foreach (var l in limits)
            {
                if (permission.UserHasPermission(player.UserIDString, l.Key))
                {
                    if (unlimited && l.Value == 0) return l.Value;

                    limit = Math.Max(l.Value, limit);
                }
            }
            return limit;
        }

        private int GetLower(BasePlayer player, Dictionary<string, int> times, int time)
        {
            foreach (var l in times)
            {
                if (permission.UserHasPermission(player.UserIDString, l.Key))
                {
                    time = Math.Min(l.Value, time);
                }
            }
            return time;
        }

        private void CheckPerms(Dictionary<string, int> limits)
        {
            foreach (var limit in limits)
            {
                if (!permission.PermissionExists(limit.Key))
                {
                    permission.RegisterPermission(limit.Key, this);
                }
            }
        }
        #endregion

        #region Message
        private string _(string msgId, BasePlayer player, params object[] args)
        {
            var msg = lang.GetMessage(msgId, this, player?.UserIDString);
            return args.Length > 0 ? string.Format(msg, args) : msg;
        }

        private void PrintMsgL(IPlayer user, string msgId, params object[] args)
        {
            if (user.IsServer)
            {
                user.Reply(string.Format(lang.GetMessage(msgId, this, user.Id), args));
            }
            else PrintMsgL(user.Object as BasePlayer, msgId, args);
        }

        private void PrintMsgL(BasePlayer player, string msgId, params object[] args)
        {
            if (player == null) return;
            PrintMsg(player, _(msgId, player, args));
        }

        private void PrintMsgL(ulong userid, string msgId, params object[] args)
        {
            var player = BasePlayer.FindAwakeOrSleeping(userid.ToString());
            if (player == null) return;
            PrintMsgL(player, msgId, args);
        }

        private void PrintMsg(BasePlayer player, string message)
        {
            if (player == null || string.IsNullOrEmpty(message)) return;
            if (config.Settings.UsePopup)
            {
                PopupNotifications?.Call("CreatePopupNotification", config.Settings.ChatName + message, player);
            }
            if (config.Settings.SendMessages)
            {
                Player.Message(player, $"{config.Settings.ChatName}{message}", config.Settings.ChatID);
            }
        }

        #endregion

        #region DrawBox
        private static void DrawBox(BasePlayer player, Vector3 center, Quaternion rotation, Vector3 size)
        {
            size /= 2;
            var point1 = RotatePointAroundPivot(new Vector3(center.x + size.x, center.y + size.y, center.z + size.z), center, rotation);
            var point2 = RotatePointAroundPivot(new Vector3(center.x + size.x, center.y - size.y, center.z + size.z), center, rotation);
            var point3 = RotatePointAroundPivot(new Vector3(center.x + size.x, center.y + size.y, center.z - size.z), center, rotation);
            var point4 = RotatePointAroundPivot(new Vector3(center.x + size.x, center.y - size.y, center.z - size.z), center, rotation);
            var point5 = RotatePointAroundPivot(new Vector3(center.x - size.x, center.y + size.y, center.z + size.z), center, rotation);
            var point6 = RotatePointAroundPivot(new Vector3(center.x - size.x, center.y - size.y, center.z + size.z), center, rotation);
            var point7 = RotatePointAroundPivot(new Vector3(center.x - size.x, center.y + size.y, center.z - size.z), center, rotation);
            var point8 = RotatePointAroundPivot(new Vector3(center.x - size.x, center.y - size.y, center.z - size.z), center, rotation);

            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point1, point2);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point1, point3);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point1, point5);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point4, point2);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point4, point3);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point4, point8);

            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point5, point6);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point5, point7);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point6, point2);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point8, point6);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point8, point7);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point7, point3);
        }

        private static Vector3 RotatePointAroundPivot(Vector3 point, Vector3 pivot, Quaternion rotation)
        {
            return rotation * (point - pivot) + pivot;
        }
        #endregion

        #region FindPlayer
        private ulong FindPlayersSingleId(string nameOrIdOrIp, BasePlayer player)
        {
            var targets = FindPlayers(nameOrIdOrIp, true);
            if (targets.Count > 1)
            {
                PrintMsgL(player, "MultiplePlayers", GetMultiplePlayers(targets));
                return 0;
            }
            ulong userId;
            if (targets.Count <= 0)
            {
                if (ulong.TryParse(nameOrIdOrIp, out userId)) return userId;
                PrintMsgL(player, "PlayerNotFound");
                return 0;
            }
            else
                userId = targets.First().userID;

            return userId;
        }

        private BasePlayer FindPlayersSingle(string value, BasePlayer player)
        {
            if (string.IsNullOrEmpty(value)) return null;
            BasePlayer target;
            if (_ids.TryGetValue(value, out target) && target.IsValid())
            {
                return target;
            }
            var targets = FindPlayers(value, true);
            if (targets.Count <= 0)
            {
                PrintMsgL(player, "PlayerNotFound");
                return null;
            }
            if (targets.Count > 1)
            {
                PrintMsgL(player, "MultiplePlayers", GetMultiplePlayers(targets));
                return null;
            }

            return targets.First();
        }

        private List<BasePlayer> FindPlayers(string arg, bool all = false)
        {
            var players = new List<BasePlayer>();

            if (string.IsNullOrEmpty(arg))
            {
                return players;
            }

            if (_ids.TryGetValue(arg, out var target) && target.IsValid())
            {
                if (all || target.IsConnected)
                {
                    players.Add(target);
                    return players;
                }
            }

            foreach (var target2 in all ? BasePlayer.allPlayerList : BasePlayer.activePlayerList)
            {
                if (target2 == null || string.IsNullOrEmpty(target2.displayName) || players.Contains(target2))
                {
                    continue;
                }

                if (target2.UserIDString == arg || target2.displayName.Contains(arg, CompareOptions.OrdinalIgnoreCase))
                {
                    players.Add(target2);
                }
            }

            return players;
        }
        #endregion

        private class UnityVector3Converter : JsonConverter
        {
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                var vector = (Vector3)value;
                writer.WriteValue($"{vector.x} {vector.y} {vector.z}");
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                if (reader.TokenType == JsonToken.String)
                {
                    var values = reader.Value.ToString().Trim().Split(' ');
                    return new Vector3(Convert.ToSingle(values[0]), Convert.ToSingle(values[1]), Convert.ToSingle(values[2]));
                }
                var o = JObject.Load(reader);
                return new Vector3(Convert.ToSingle(o["x"]), Convert.ToSingle(o["y"]), Convert.ToSingle(o["z"]));
            }

            public override bool CanConvert(Type objectType)
            {
                return objectType == typeof(Vector3);
            }
        }

        private class CustomComparerDictionaryCreationConverter<T> : CustomCreationConverter<IDictionary>
        {
            private readonly IEqualityComparer<T> comparer;

            public CustomComparerDictionaryCreationConverter(IEqualityComparer<T> comparer)
            {
                if (comparer == null)
                    throw new ArgumentNullException(nameof(comparer));
                this.comparer = comparer;
            }

            public override bool CanConvert(Type objectType)
            {
                return HasCompatibleInterface(objectType) && HasCompatibleConstructor(objectType);
            }

            private static bool HasCompatibleInterface(Type objectType)
            {
                return objectType.GetInterfaces().Where(i => HasGenericTypeDefinition(i, typeof(IDictionary<,>))).Any(i => typeof(T).IsAssignableFrom(i.GetGenericArguments().First()));
            }

            private static bool HasGenericTypeDefinition(Type objectType, Type typeDefinition)
            {
                return objectType.GetTypeInfo().IsGenericType && objectType.GetGenericTypeDefinition() == typeDefinition;
            }

            private static bool HasCompatibleConstructor(Type objectType)
            {
                return objectType.GetConstructor(new[] { typeof(IEqualityComparer<T>) }) != null;
            }

            public override IDictionary Create(Type objectType)
            {
                return Activator.CreateInstance(objectType, comparer) as IDictionary;
            }
        }

        public class Exploits
        {
            public static bool TestInsideRock(Vector3 a)
            {
                if (ContainsTopology(TerrainTopology.Enum.Monument, a, 25f))
                {
                    return false;
                }
                bool faces = Physics.queriesHitBackfaces;
                Physics.queriesHitBackfaces = true;
                bool flag = IsRockFaceUpwards(a);
                Physics.queriesHitBackfaces = faces;
                return flag || IsRockFaceDownwards(a);
            }

            private static bool IsRockFaceDownwards(Vector3 a)
            {
                Vector3 b = a + new Vector3(0f, 30f, 0f);
                Vector3 d = a - b;
                var hits = Physics.RaycastAll(b, d, d.magnitude, Layers.World);
                return Array.Exists(hits, hit => IsRock(hit.collider.name));
            }

            private static bool IsRockFaceUpwards(Vector3 point)
            {
                RaycastHit hit;
                return Physics.Raycast(point, Vector3.up, out hit, 30f, Layers.Mask.World) && IsRock(hit.collider.name);
            }

            private static bool IsRock(string name) => name.Contains("rock", CompareOptions.OrdinalIgnoreCase) || name.Contains("formation", CompareOptions.OrdinalIgnoreCase) || name.Contains("cliff", CompareOptions.OrdinalIgnoreCase);
        }

        [HookMethod("SendHelpText")]
        private void SendHelpText(BasePlayer player)
        {
            PrintMsgL(player, "<size=14>NTeleportation</size> by <color=#ce422b>Nogrod</color>\n<color=#ffd479>/sethome NAME</color> - Set home on current foundation\n<color=#ffd479>/home NAME</color> - Go to one of your homes\n<color=#ffd479>/home list</color> - List your homes\n<color=#ffd479>/town</color> - Go to town, if set\n/tpb - Go back to previous location\n/tpr PLAYER - Request teleport to PLAYER\n/tpa - Accept teleport request");
        }

        private bool API_HavePendingRequest(BasePlayer player)
        {
            return PendingRequests.ContainsKey(player.userID) || PlayersRequests.ContainsKey(player.userID) || TeleportTimers.ContainsKey(player.userID);
        }

        private bool API_HaveAvailableHomes(BasePlayer player)
        {
            HomeData homeData;
            if (!_Home.TryGetValue(player.userID, out homeData))
            {
                _Home[player.userID] = homeData = new HomeData();
            }

            ValidateHomes(player, homeData, false, false);

            var limit = GetHigher(player, config.Home.VIPHomesLimits, config.Home.HomesLimit, true);
            var result = homeData.Locations.Count < limit || limit == 0;

            homeData.Locations.Clear();

            return result;
        }

        private Dictionary<string, Vector3> API_GetHomes(BasePlayer player)
        {
            HomeData homeData;
            if (!_Home.TryGetValue(player.userID, out homeData))
            {
                _Home[player.userID] = homeData = new HomeData();
            }

            ValidateHomes(player, homeData, false, false);

            var result = homeData.Locations.ToDictionary(pair => pair.Key, pair => pair.Value.Get());

            homeData.Locations.Clear();

            return result;
        }

        private List<Vector3> API_GetLocations(string command)
        {
            var settings = GetSettings(command);

            if (settings == null)
            {
                return new List<Vector3>();
            }

            return settings.Locations;
        }

        private Dictionary<string, List<Vector3>> API_GetAllLocations()
        {
            var dict = new Dictionary<string, List<Vector3>>();

            foreach (var dc in config.DynamicCommands)
            {
                dict[dc.Key] = dc.Value.Locations;
            }

            return dict;
        }

        private int GetLimitRemaining(BasePlayer player, string type)
        {
            if (player == null || string.IsNullOrEmpty(type)) return -1;
            var settings = GetSettings(type, player.userID);
            if (settings == null) return -1;
            var currentDate = DateTime.Now.ToString("d");
            var limit = GetHigher(player, settings.VIPDailyLimits, settings.DailyLimit, true);
            TeleportData data;
            if (!settings.Teleports.TPData.TryGetValue(player.userID, out data))
            {
                settings.Teleports.TPData[player.userID] = data = new TeleportData();
            }
            if (data.Date != currentDate)
            {
                data.Amount = 0;
                data.Date = currentDate;
            }
            if (limit > 0)
            {
                return limit - data.Amount;
            }
            return 0;
        }

        private int GetCooldownRemaining(BasePlayer player, string type)
        {
            if (player == null || string.IsNullOrEmpty(type)) return -1;
            var settings = GetSettings(type, player.userID);
            if (settings == null) return -1;
            var currentDate = DateTime.Now.ToString("d");
            var timestamp = Facepunch.Math.Epoch.Current;
            var cooldown = GetLower(player, settings.VIPCooldowns, settings.Cooldown);
            TeleportData data;
            if (!settings.Teleports.TPData.TryGetValue(player.userID, out data))
            {
                settings.Teleports.TPData[player.userID] = data = new TeleportData();
            }
            if (data.Date != currentDate)
            {
                data.Amount = 0;
                data.Date = currentDate;
            }
            if (cooldown > 0 && timestamp - data.Timestamp < cooldown)
            {
                return cooldown - (timestamp - data.Timestamp);
            }
            return 0;
        }

        private int GetCountdownRemaining(BasePlayer player, string type)
        {
            if (player == null || string.IsNullOrEmpty(type))
            {
                return -1;
            }

            TownSettings settings = GetSettings(type, player.userID);
            if (settings == null)
            {
                return -1;
            }

            return GetLower(player, settings.VIPCountdowns, settings.Countdown);
        }
    }
}

// --- End of file: NTeleportation.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Backpack.cs ---
// --- Original Local Path: Backpack.cs ---

﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Backpack", "TopPlugin.ru", "1.0.41")]
    public class Backpack : RustPlugin
    {
        #region Fields 

        [PluginReference] private Plugin ImageLibrary;

        public Dictionary<ulong, BackpackStorage> opensBackpack = new Dictionary<ulong, BackpackStorage>();
        public static Backpack ins = null;
        public string Layer = "UI.Backpack";
        public string LayerBlur = "UI.Backpack.Blur";

        #endregion

        #region Commands

        [ChatCommand("updatecraft")]
        void chatCmdUpdateCraft(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin) return;

            List<ItemInfo> craftInfo = new List<ItemInfo>();

            foreach (var item in player.inventory.containerMain.itemList)
            {
                if (craftInfo.Find(x => x.shortname.Equals(item.info.shortname)) != null)
                {
                    continue;
                }

                craftInfo.Add(new ItemInfo()
                {
                    shortname = item.info.shortname,
                    amount = item.amount,
                    skinID = item.skin,
                    itemID = item.info.itemid
                });
            }

            _config.items = craftInfo;

            SendReply(player, "Крафт успешно обновлён!");

            CheckConfig();

            SaveConfig();
        }

        [ConsoleCommand("backpack.give")]
        void chatCmdBackpackGive(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin) return;

            var player = BasePlayer.FindByID(arg.GetULong(0));

            if (player == null)
            {
                PrintError("Игрок не был найден!");
                return;
            }

            Item item = ItemManager.CreateByPartialName("santabeard", 1);
            item.name = _config.displayName;
            item.skin = _config.skinIdBackpack;

            string trimmed = _config.displayName.Trim();
            var name = trimmed.Substring(0, trimmed.IndexOf('\n'));
            item.MoveToContainer(player.inventory.containerMain);
            player.SendConsoleCommand($"note.inv {item.info.itemid} 1 \"{name}\"");
            PrintWarning($"Выдали рюкзак игроку {player.displayName}");
        }

        [ConsoleCommand("UI_Backpack")]
        void consoleCommandBackpackUI(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection?.player as BasePlayer;

            if (player == null) return;

            switch (arg.GetString(0))
            {
                case "close":

                    CuiHelper.DestroyUi(player, Layer);
                    CuiHelper.DestroyUi(player, LayerBlur);

                    break;
                case "menuha":

                    CuiHelper.DestroyUi(player, Layer);
                    CuiHelper.DestroyUi(player, LayerBlur);
                    player.SendConsoleCommand("chat.say /menu");
                    break;

                case "craft":

                    var success = true;

                    Dictionary<Item, int> items = new Dictionary<Item, int>();

                    foreach (var craftedItem in _config.items)
                    {

                        var haveItem = HaveItem(player, craftedItem.itemID, craftedItem.skinID, craftedItem.amount);
                        if (!haveItem)
                        {
                            success = false;
                            SendReply(player,
                        "[<color=#ff8f3a><size=16>Создание рюкзака</size></color>]\n<color=#ff0000>Вы не можете скрафтить предмет!</color> Не хватает ингредиента!");
                            return;
                        }
                        var itemCraft = FindItem(player, craftedItem.itemID, craftedItem.skinID, craftedItem.amount);

                        items.Add(itemCraft, craftedItem.amount);
                    }

                    foreach (var itemCraft in items)
                    {
                        itemCraft.Key.UseItem(itemCraft.Value);
                    }

                    if (success)
                    {
                        player.SendConsoleCommand("UI_Backpack close");
                        Item craft = ItemManager.CreateByName("santabeard", 1, _config.skinIdBackpack);

                        craft.name = _config.displayName;

                        craft.MoveToContainer(player.inventory.containerMain);

                        string trimmed = _config.displayName.Trim();
                        var name = trimmed.Substring(0, trimmed.IndexOf('\n'));
                        player.SendConsoleCommand($"note.inv {craft.info.itemid} 1 \"{name}\"");
                    }

                    break;
            }
        }

        [ChatCommand("backpack.spawn")]
        void chatCmdBackpackSpawn(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin) return;

            Item item = ItemManager.CreateByPartialName("santabeard", 1);
            item.name = _config.displayName;
            item.skin = _config.skinIdBackpack;
            string trimmed = _config.displayName.Trim();
            var name = trimmed.Substring(0, trimmed.IndexOf('\n'));

            item.MoveToContainer(player.inventory.containerMain);
            player.SendConsoleCommand($"note.inv {item.info.itemid} 1 \"{name}\"");
            SendReply(player, "Рюкзак был успешно выдан!");
        }

        private void chatCmdBackpackOpen(BasePlayer player, string command, string[] args)
        {
            player.SendConsoleCommand(_config.consoleCommand);
        }

        private void chatCmdBackpack(BasePlayer player, string command, string[] args)
        {
            CuiHelper.DestroyUi(player, Layer);
            CuiHelper.DestroyUi(player, LayerBlur);

            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel()
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = HexToRGB("#202020C2"), Material = "assets/content/ui/uibackgroundblur.mat" }
            }, "Overlay", LayerBlur);

            container.Add(new CuiButton()
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Command = "UI_Backpack close", Color = "0 0 0 0" },
                Text = { Text = "" }
            }, "Overlay", Layer);

            container.Add(new CuiElement()
            {
                Parent = Layer,
                Components =
                {
                    new CuiRawImageComponent()
                    {
                        Png = (string) ImageLibrary.Call("GetImage", "santabeard", _config.skinIdBackpack)
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = $"0.415625 0.521296",
                        AnchorMax = $"0.571875 0.799074"
                    },
                }
            });

            container.Add(new CuiLabel()
            {
                RectTransform = { AnchorMin = "0.446 0.806", AnchorMax = "0.68 0.861" },
                Text = { Text = $"<color=#a100ff>КОЛИЧЕСТВО СЛОТОВ: {_config.backpackSize}</color>", Align = TextAnchor.MiddleLeft, Color = HexToRGB("#FFFFFFDA"), Font = "RobotoCondensed-Regular.ttf", FontSize = 14 }
            }, Layer);

            container.Add(new CuiLabel()
            {
                RectTransform = { AnchorMin = "0.378124 0.938889", AnchorMax = "0.633542 0.99537" },
                Text = { Text = $"<b>КРАФТ РЮКЗАКА</b>", Align = TextAnchor.MiddleCenter, Color = HexToRGB("#a100ff"), Font = "RobotoCondensed-Bold.ttf", FontSize = 24 }
            }, Layer);

            container.Add(new CuiLabel()
            {
                RectTransform = { AnchorMin = "0.388 0.401", AnchorMax = "0.622 0.513" },
                Text = { Text = $"НЕОБХОДИМЫЕ ПРЕДМЕТЫ \nДЛЯ КРАФТА", Align = TextAnchor.MiddleCenter, Color = HexToRGB("#a100ff"), Font = "RobotoCondensed-Regular.ttf", FontSize = 22 }
            }, Layer);

            float itemMinPosition = 515f;
            float itemWidth = 0.403646f - 0.351563f;
            float itemMargin = 0.409895f - 0.403646f;
            int itemCount = _config.items.Count;
            float itemMinHeight = 0.315741f;
            float itemHeight = 0.408333f - 0.315741f;

            if (itemCount > 5)
            {
                itemMinPosition = 0.5f - 5 / 2f * itemWidth - (5 - 1) / 2f * itemMargin;
                itemCount -= 5;
            }
            else itemMinPosition = 0.5f - itemCount / 2f * itemWidth - (itemCount - 1) / 2f * itemMargin;

            var countItem = 0;

            foreach (var itemCraft in _config.items)
            {
                countItem++;

                container.Add(new CuiElement()
                {
                    Parent = Layer,
                    Name = Layer + $".Item{itemCraft.itemID}",
                    Components =
                    {
                        new CuiRawImageComponent()
                        {
                            Png = (string) ImageLibrary.Call("GetImage", itemCraft.shortname, itemCraft.skinID),
                        },
                        new CuiRectTransformComponent()
                        {
                            AnchorMin = $"{itemMinPosition} {itemMinHeight}",
                            AnchorMax = $"{itemMinPosition + itemWidth} {itemMinHeight + itemHeight}"
                        },
                    }
                });

                container.Add(new CuiLabel()
                {
                    RectTransform = { AnchorMin = "0 0.05", AnchorMax = "0.98 1" },
                    Text = { Text = $"x{itemCraft.amount}", Align = TextAnchor.LowerRight, FontSize = 12 },
                }, Layer + $".Item{itemCraft.itemID}");

                itemMinPosition += (itemWidth + itemMargin);

                if (countItem % 5 == 0)
                {
                    itemMinHeight -= (itemHeight + (itemMargin * 2f));

                    if (itemCount > 5)
                    {
                        itemMinPosition = 0.5f - 5 / 2f * itemWidth - (5 - 1) / 2f * itemMargin;
                        itemCount -= 5;
                    }
                    else itemMinPosition = 0.5f - itemCount / 2f * itemWidth - (itemCount - 1) / 2f * itemMargin;
                }
            }

            itemMinHeight -= ((itemMargin * 3f) + (0.162037f - 0.0925926f));

            container.Add(new CuiButton()
            {
                RectTransform = { AnchorMin = $"0.389062 {itemMinHeight}", AnchorMax = $"0.615103 {itemMinHeight + (0.162037f - 0.0925926f)}" },
                Button = { Color = "0.00 0.50 0.00 1.00", Command = $"UI_Backpack craft", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                Text = { Text = "СКРАФТИТЬ", Font = "RobotoCondensed-Regular.ttf", FontSize = 28, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" }
            }, Layer);
            container.Add(new CuiButton()
            {
                RectTransform = { AnchorMin = "0.765 0.943", AnchorMax = "0.866 0.985" },
                Button = { Color = "1.00 0.56 0.23 1.00", Command = $"UI_Backpack menuha", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                Text = { Text = "В главное меню", Font = "RobotoCondensed-Regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "0.63 0.00 1.00 1.00" }
            }, Layer);
            container.Add(new CuiButton()
            {
                RectTransform = { AnchorMin = "0.875 0.943", AnchorMax = "0.977 0.9856" },
                Button = { Color = "1.00 0.56 0.23 1.00", Command = $"UI_Backpack close", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                Text = { Text = "Закрыть", Font = "RobotoCondensed-Regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "0.63 0.00 1.00 1.00" }
            }, Layer);

            CuiHelper.AddUi(player, container);
        }

        private void consoleCmdBackpack(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection?.player as BasePlayer;

            if (player == null) return;

            if (player.inventory.loot?.entitySource != null)
            {
                BackpackStorage backpackStorage;
                if (opensBackpack.TryGetValue(player.userID, out backpackStorage) &&
                    backpackStorage.gameObject == player.inventory.loot.entitySource.gameObject) return;

                player.EndLooting();

                timer.Once(0.1f, () => BackpackOpen(player));
            }
            else BackpackOpen(player);
        }

        #endregion

        #region Hooks

        private bool? CanWearItem(PlayerInventory inventory, Item item)
        {
            var player = inventory.gameObject.ToBaseEntity() as BasePlayer;

            if (player == null) return null;
            if (player.IsNpc) return null;

            if (item.skin == _config.skinIdBackpack)
            {
                if (player.inventory.containerWear.itemList.Find(x => x.skin == _config.skinIdBackpack) != null)
                    return false;
                if (player.inventory.containerWear.itemList.Find(x => x.info.shortname == "santabeard") != null)
                    return true;
            }
            return null;
        }

        void OnServerInitialized()
        {
            LoadData();
            LoadConfig();

            CheckConfig();
            UpdateData();

            cmd.AddConsoleCommand(_config.consoleCommand, this, "consoleCmdBackpack");
            cmd.AddChatCommand(_config.chatCommand, this, chatCmdBackpack);
            cmd.AddChatCommand(_config.chatCommandOpen, this, chatCmdBackpackOpen);

            ins = this;
        }

        void UpdateData()
        {
            SaveData();
            timer.Once(300f, () => UpdateData());
        }

        object CanAcceptItem(ItemContainer container, Item item)
        {
            if (item.IsLocked())
                return ItemContainer.CanAcceptResult.CannotAccept;

            return null;
        }

        void Unload()
        {
            foreach (var backpack in opensBackpack)
                backpack.Value.Close();

            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, Layer);
                CuiHelper.DestroyUi(player, LayerBlur);
            }

            SaveData();
        }

        #endregion

        #region Methods

        public Item FindItem(BasePlayer player, int itemID, ulong skinID, int amount)
        {
            Item item = null;

            if (skinID == 0U)
            {
                if (player.inventory.FindItemID(itemID) != null && player.inventory.FindItemID(itemID).amount >= amount)
                    return player.inventory.FindItemID(itemID);
            }
            else
            {

                List<Item> items = new List<Item>();

                items.AddRange(player.inventory.FindItemIDs(itemID));

                foreach (var findItem in items)
                {
                    if (findItem.skin == skinID && findItem.amount >= amount)
                    {
                        return findItem;
                    }
                }
            }

            return item;
        }

        public bool HaveItem(BasePlayer player, int itemID, ulong skinID, int amount)
        {
            if (skinID == 0U)
            {
                if (player.inventory.FindItemID(itemID) != null &&
                    player.inventory.FindItemID(itemID).amount >= amount) return true;
                return false;
            }

            List<Item> items = new List<Item>();

            items.AddRange(player.inventory.FindItemIDs(itemID));

            foreach (var item in items)
            {
                if (item.skin == skinID && item.amount >= amount)
                {
                    return true;
                }
            }

            return false;
        }

        private IEnumerator DownloadImages()
        {
            ImageLibrary.Call("AddImage", $"http://api.hougan.space/rust/skin/getImage/{_config.skinIdBackpack}",
                "santabeard", _config.skinIdBackpack);
            foreach (var item in _config.items)
            {
                if (item.skinID != 0U)
                    ImageLibrary.Call("AddImage", $"http://api.hougan.space/rust/skin/getImage/{item.skinID}",
                        item.shortname, item.skinID);
                yield return new WaitForSeconds(0.04f);
            }
            yield return 0;
        }

        private static string HexToRGB(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);
            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }

        List<SavedItem> SaveItems(List<Item> items) => items.Select(SaveItem).ToList();

        bool BackpackHide(uint itemID, ulong playerId)
        {
            BackpackStorage backpackStorage;
            if (!opensBackpack.TryGetValue(playerId, out backpackStorage)) return false;
            opensBackpack.Remove(playerId);
            if (backpackStorage == null) return false;
            var items = SaveItems(backpackStorage.GetItems);
            if (items.Count > 0) storedData.backpacks[itemID] = items;
            else storedData.backpacks.Remove(itemID);

            backpackStorage.Close();

            return true;
        }

        void BackpackOpen(BasePlayer player)
        {
            if (player.inventory.loot?.entitySource != null) return;

            Item backpack = null;

            foreach (var item in player.inventory.containerWear.itemList)
            {

                if (item.skin == _config.skinIdBackpack)
                {
                    backpack = item;
                    break;
                }
            }

            if (backpack == null)
            {
                SendReply(player, "Для того, чтобы воспользоваться рюкзаком, необходимо одеть его в слоты одежды!");
                return;
            }

            if (Interface.Oxide.CallHook("CanBackpackOpen", player) != null) return;

            timer.Once(0.1f, () =>
            {
                if (!player.IsOnGround())
                {
                    SendReply(player, "Сначала приземлитесь, а потом пробуйте открыть рюкзак!!");
                    return;
                }

                List<SavedItem> savedItems;
                List<Item> items = new List<Item>();
                if (storedData.backpacks.TryGetValue(backpack.uid, out savedItems))
                    items = RestoreItems(savedItems);
                BackpackStorage backpackStorage = BackpackStorage.Spawn(player);

                opensBackpack.Add(player.userID, backpackStorage);
                if (items.Count > 0)
                    backpackStorage.Push(items);
                backpackStorage.StartLoot();
            });
        }

        List<Item> RestoreItems(List<SavedItem> sItems)
        {
            return sItems.Select(sItem =>
            {
                if (sItem.weapon) return BuildWeapon(sItem);
                return BuildItem(sItem);
            }).Where(i => i != null).ToList();
        }

        Item BuildItem(SavedItem sItem)
        {
            if (sItem.amount < 1) sItem.amount = 1;
            Item item = null;
            item = ItemManager.CreateByItemID(sItem.itemid, sItem.amount, sItem.skinid);

            if (item.hasCondition)
            {
                item.condition = sItem.condition;
                item.maxCondition = sItem.maxcondition;
                item.busyTime = sItem.busyTime;
            }

            if (sItem.name != null)
            {
                item.name = sItem.name;
            }

            if (sItem.OnFire)
            {
                item.SetFlag(global::Item.Flag.OnFire, true);
            }
            FlameThrower flameThrower = item.GetHeldEntity()?.GetComponent<FlameThrower>();
            if (flameThrower)
                flameThrower.ammo = sItem.flamefuel;
            return item;
        }

        Item BuildWeapon(SavedItem sItem)
        {
            Item item = null;
            item = ItemManager.CreateByItemID(sItem.itemid, 1, sItem.skinid);

            if (item.hasCondition)
            {
                item.condition = sItem.condition;
                item.maxCondition = sItem.maxcondition;
            }
            var weapon = item.GetHeldEntity() as BaseProjectile;
            if (weapon != null)
            {
                var def = ItemManager.FindItemDefinition(sItem.ammotype);
                weapon.primaryMagazine.ammoType = def;
                weapon.primaryMagazine.contents = sItem.ammoamount;
            }

            if (sItem.mods != null)
                foreach (var mod in sItem.mods)
                    item.contents.AddItem(BuildItem(mod).info, 1);
            return item;
        }

        SavedItem SaveItem(Item item)
        {
            SavedItem iItem = new SavedItem
            {
                shortname = item.info?.shortname,
                amount = item.amount,
                mods = new List<SavedItem>(),
                skinid = item.skin,
                busyTime = item.busyTime,

            };
            if (item.HasFlag(global::Item.Flag.OnFire))
            {
                iItem.OnFire = true;
            }
            if (item.info == null) return iItem;
            iItem.itemid = item.info.itemid;
            iItem.weapon = false;

            iItem.name = item.name;
            if (item.hasCondition)
            {
                iItem.condition = item.condition;
                iItem.maxcondition = item.maxCondition;
            }
            FlameThrower flameThrower = item.GetHeldEntity()?.GetComponent<FlameThrower>();
            if (flameThrower != null)
                iItem.flamefuel = flameThrower.ammo;
            if (item.info.category.ToString() != "Weapon") return iItem;
            BaseProjectile weapon = item.GetHeldEntity() as BaseProjectile;
            if (weapon == null) return iItem;
            if (weapon.primaryMagazine == null) return iItem;
            iItem.ammoamount = weapon.primaryMagazine.contents;
            iItem.ammotype = weapon.primaryMagazine.ammoType.shortname;
            iItem.weapon = true;
            if (item.contents != null)
                foreach (var mod in item.contents.itemList)
                    if (mod.info.itemid != 0)
                        iItem.mods.Add(SaveItem(mod));
            return iItem;
        }

        #endregion

        #region Class

        public class BackpackStorage : MonoBehaviour
        {
            public StorageContainer container;
            public Item backpack;
            public BasePlayer player;

            public void Initialization(StorageContainer container, Item backpack, BasePlayer player)
            {
                this.container = container;
                this.backpack = backpack;
                this.player = player;

                container.ItemFilter(backpack, -1);

                BlockBackpackSlots(true);
            }

            public List<Item> GetItems => container.inventory.itemList.Where(i => i != null).ToList();

            public static StorageContainer CreateContainer(BasePlayer player)
            {
                var storage =
                    GameManager.server.CreateEntity("assets/prefabs/deployable/small stash/small_stash_deployed.prefab")
                        as StorageContainer;
                if (storage == null) return null;
                storage.transform.position = new Vector3(0f, 100f, 0);
                storage.panelName = "largewoodbox";
                storage.name = "backpack";
                //storage.SetFlag(BaseEntity.Flags.Reserved1, true); // = "backpack";

                ItemContainer container = new ItemContainer { playerOwner = player };
                container.ServerInitialize((Item)null, ins._config.backpackSize);

                if ((int)container.uid == 0)
                    container.GiveUID();

                storage.inventory = container;
                if (!storage) return null;
                storage.SendMessage("SetDeployedBy", player, (SendMessageOptions)1);
                storage.Spawn();

                return storage;
            }

            private void PlayerStoppedLooting(BasePlayer player)
            {
                BlockBackpackSlots(false);

                ins.BackpackHide(backpack.uid, player.userID);
            }

            public void StartLoot()
            {
                container.SetFlag(BaseEntity.Flags.Open, true, false);
                player.inventory.loot.StartLootingEntity(container, false);
                player.inventory.loot.AddContainer(container.inventory);
                player.inventory.loot.SendImmediate();
                player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", container.panelName);
                container.DecayTouch();
                container.SendNetworkUpdate();
            }

            public static BackpackStorage Spawn(BasePlayer player)
            {
                player.EndLooting();
                var storage = CreateContainer(player);

                Item backpack = null;

                backpack = player.inventory.containerWear.itemList.Find(x => x.skin == ins._config.skinIdBackpack);

                if (backpack == null) return null;

                var box = storage.gameObject.AddComponent<BackpackStorage>();

                box.Initialization(storage, backpack, player);

                return box;
            }

            public void Close()
            {
                container.inventory.itemList.Clear();
                container.Kill();
            }

            public void Push(List<Item> items)
            {
                for (int i = items.Count - 1; i >= 0; i--)
                    items[i].MoveToContainer(container.inventory);
            }

            public void BlockBackpackSlots(bool state)
            {
                backpack.LockUnlock(state);

                foreach (var item in player.inventory.AllItems())
                    if (item.skin == ins._config.skinIdBackpack)
                        item.LockUnlock(state);
            }
        }

        #endregion

        #region Data

        class StoredData
        {
            public Dictionary<uint, List<SavedItem>> backpacks = new Dictionary<uint, List<SavedItem>>();
        }

        public class SavedItem
        {
            public string shortname;
            public int itemid;
            public float condition;
            public float maxcondition;
            public int amount;
            public int ammoamount;
            public string ammotype;
            public int flamefuel;
            public ulong skinid;
            public string name;
            public bool weapon;
            public float busyTime;
            public bool OnFire;
            public List<SavedItem> mods;
        }

        void SaveData()
        {
            BackpackData.WriteObject(storedData);
        }

        void LoadData()
        {
            BackpackData = Interface.Oxide.DataFileSystem.GetFile(_config.fileName);
            try
            {
                storedData =
                    Interface.Oxide.DataFileSystem.ReadObject<StoredData>(_config.fileName);
            }
            catch
            {
                storedData = new StoredData();
            }
        }

        StoredData storedData;
        private DynamicConfigFile BackpackData;

        #endregion

        #region Configuration

        public void CheckConfig()
        {
            if (_config.backpackSize > 30)
                _config.backpackSize = 30;

            foreach (var item in _config.items)
            {
                if (item.itemID != 0) continue;

                var itemDef = ItemManager.FindItemDefinition(item.shortname);
                item.itemID = itemDef.itemid;
            }
            ServerMgr.Instance.StartCoroutine(DownloadImages());
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();
        }

        protected override void LoadDefaultConfig()
        {
            _config = new Configuration()
            {
                backpackSize = 12,
                fileName = "Backpack/backpack",
                skinIdBackpack = 1720637353U,
                consoleCommand = "backpack.open",
                chatCommandOpen = "bp",
                chatCommand = "backpack",
                displayName = "Рюкзак\n  <size=16>████████████████████</size>\n<size=12>   Рюкзак, позволяет переносить в себе предметы. \n   Количество слотов: 12</size>",
                items = new List<ItemInfo>()
                {
                    new ItemInfo()
                    {
                        shortname = "cloth",
                        amount = 300,
                    },
                    new ItemInfo()
                    {
                        shortname = "leather",
                        amount = 150,
                    },
                    new ItemInfo()
                    {
                        shortname = "metal.fragments",
                        amount = 1000,
                    },
                    new ItemInfo()
                    {
                        shortname = "metal.refined",
                        amount = 30
                    }
                }
            };
        }

        public Configuration _config;

        public class Configuration
        {
            [JsonProperty("Консольная команда для открытия рюкзака")]
            public string consoleCommand = "";

            [JsonProperty("Чат команда для открытия крафта рюкзака")]
            public string chatCommand = "";

            [JsonProperty("Чат команда для открытия самого рюкзака")]
            public string chatCommandOpen = "bp";

            [JsonProperty("Количество слотов в рюкзаке")]
            public int backpackSize = 0;

            [JsonProperty("Название для рюкзака")]
            public string displayName = "";

            [JsonProperty("СкинИД рюкзака")]
            public ulong skinIdBackpack = 1719575499U;

            [JsonProperty("Расположение Data файла")]
            public string fileName = "Backpack/backpack";

            [JsonProperty("Необходимые предметы для крафта рюкзака")]
            public List<ItemInfo> items = new List<ItemInfo>();
        }

        public class ItemInfo
        {
            [JsonProperty("Шортнейм предмета")] public string shortname = "";
            [JsonProperty("Количество предмета")] public int amount = 0;
            [JsonProperty("СкинИД предмета")] public ulong skinID = 0U;
            [JsonProperty("АйтемИД предмета")] public int itemID = 0;
        }

        #endregion
    }
}

// --- End of file: Backpack.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/XPManager.cs ---
// --- Original Local Path: XPManager.cs ---

using System.Collections.Generic;
using System.Linq;
using System;

namespace Oxide.Plugins
{
	[Info("XP Manager", "LaserHydra", "1.1.0", ResourceId = 2026)]
	[Description("XP Manager")]
	class XPManager : RustPlugin
	{
        #region Classes

        class Range
        {
            public int Min;
            public int Max;

            public Range(int Min, int Max)
            {
                this.Min = Min;
                this.Max = Max;
            }
        }

        #endregion

        #region Variables

        Dictionary<string, object> PermissionLevelRanges;
        Dictionary<string, object> PermissionMultipliers;
		Dictionary<string, object> EarningMultipliers;

		bool CanAdminsGainXP;
		bool CanSleepersGainXP;
		bool InstantMaxLevel;

		float LevelLossOnDeath;

		int MinimalLevel;
		int MaximalLevel;

		#endregion

		#region Oxide Hooks

		void Loaded()
		{
			LoadConfig();
            LoadMessages();

			RegisterPerm("admin");

			foreach (var pm in PermissionMultipliers)
				RegisterPerm(pm.Key);

            foreach (var pm in PermissionLevelRanges)
                RegisterPerm(pm.Key);

            foreach (var player in BasePlayer.activePlayerList)
				OnPlayerInit(player);
		}

		void OnPlayerInit(BasePlayer player)
		{
//PrintWarning($"Player Joined: '{player.displayName}', Level: {GetLevel(player)}, Max Level: {GetMaxLevel(player.userID)}, Min Level: {GetMinLevel(player.userID)}, Is Above Max Level: {GetLevel(player) > GetMaxLevel(player.userID)}");

			if (InstantMaxLevel && GetLevel(player) < GetMaxLevel(player.userID))
				SetLevel(player, GetMaxLevel(player.userID));

			if (GetLevel(player) > GetMaxLevel(player.userID))
				SetLevel(player, GetMaxLevel(player.userID));

			if (GetLevel(player) < GetMinLevel(player.userID))
				SetLevel(player, GetMinLevel(player.userID));
		}

		void OnEntityDeath(BaseCombatEntity victim, HitInfo info)
		{
			if (victim?.ToPlayer()?.xp?.CurrentLevel != null && LevelLossOnDeath != 0)
				SetLevel(victim.ToPlayer(), Mathx.Clamp(Convert.ToInt32(victim.ToPlayer().xp.CurrentLevel - (victim.ToPlayer().xp.CurrentLevel / 100) * LevelLossOnDeath), MinimalLevel, MaximalLevel));
		}

		object OnXpEarn(ulong id, float amount, string source)
		{
			//PrintWarning($"Earning XP: {id}, Reached Max Level: {GetLevel(id) >= MaximalLevel}, IsAdmin: {IsAdmin(id)}, IsOnline: {IsOnline(id)}, Returning: {amount} * {GetMultiplier(source)} * {GetPermissionMultiplier(id)} = {amount * GetMultiplier(source) * GetPermissionMultiplier(id)}");

			if (GetLevel(id) >= GetMaxLevel(id))
				return 0f;

			if (!CanAdminsGainXP && IsAdmin(id))
				return 0f;

			if (!CanSleepersGainXP && !IsOnline(id))
				return 0f;

			return amount * GetMultiplier(source) * (source == "Cheat" ? 1 : GetPermissionMultiplier(id));
		}

		#endregion

		#region Loading

		new void LoadConfig()
		{
            PermissionLevelRanges = GetConfig<Dictionary<string, object>>("Permission Level Range", new Dictionary<string, object> { { "levelrange.vip", "5-100" }, { "levelrange.vip+", "10-100" } });
            PermissionMultipliers = GetConfig<Dictionary<string, object>>("Permission Multipliers", new Dictionary<string, object> { { "multiplier.vip", 1.5f }, { "multiplier.vip+", 2f } });
            EarningMultipliers = GetConfig<Dictionary<string, object>>("Earning Multipliers", StandardEarningMultipliers);

			CanAdminsGainXP = GetConfig<bool>("Can Admins Gain XP", true);
			CanSleepersGainXP = GetConfig<bool>("Can Sleepers Gain XP", true);
			InstantMaxLevel = GetConfig<bool>("Instant Max Level", false);

			LevelLossOnDeath = GetConfig<float>("Level Loss On Death (Percentage of current level)", 0f);
			MinimalLevel = GetConfig<int>("Minimal Level", 1);
			MaximalLevel = GetConfig<int>("Maximal Level", GetMaxLevel());

			foreach (var em in StandardEarningMultipliers)
				if (!EarningMultipliers.ContainsKey(em.Key))
					EarningMultipliers.Add(em.Key, em.Value);

			if (MaximalLevel > GetMaxLevel())
			{
				PrintWarning($"Maximal Level is set above the original max level of {GetMaxLevel()}! Automaticly lowering to {GetMaxLevel()} to prevent issues.");
				MaximalLevel = GetMaxLevel();
			}

			if (EarningMultipliers.Any((m) => Convert.ToSingle(m.Value) > 500))
			{
				PrintWarning("Earning Multipliers over 500 were detected! Automaticly lowering to 500 to prevent issues.");

				foreach (var em in EarningMultipliers.Where((m) => Convert.ToSingle(m.Value) > 500).ToList())
					EarningMultipliers[em.Key] = 500;
			}

			SaveConfig();
		}

		void LoadMessages()
		{
			lang.RegisterMessages(new Dictionary<string, string>
			{
				{"No Permission", "You don't have permission to use this command."},
				{"Info", $"XP Infomations about '{{player}}'{Environment.NewLine}Level: {{level}}"},
				{"Level Set", "{player}'s level was set to {level}."},
				{"Level Added", "{level} levels were given to {player}."},
				{"Level Reseted", "{player}'s level was reseted."}
			}, this);
		}

		protected override void LoadDefaultConfig() => PrintWarning("Generating new config file...");

		#endregion

		#region XP Related

		int GetMaxLevel() => Rust.Xp.Config.Levels.Length;

		float GetLevel(BasePlayer player) => player.xp.CurrentLevel;

		float GetLevel(ulong id) => BasePlayer.FindXpAgent(id)?.CurrentLevel ?? 1f;

		void AddLevel(BasePlayer player, int level) => player.xp.Add(Rust.Xp.Definitions.Cheat, Rust.Xp.Config.LevelToXp((int)player.xp.CurrentLevel + level) - player.xp.EarnedXp);

		void AddLevel(ulong id, int level)
		{
			var agent = BasePlayer.FindXpAgent(id);

			agent.Add(Rust.Xp.Definitions.Cheat, Rust.Xp.Config.LevelToXp((int) agent.CurrentLevel + level) - agent.EarnedXp);
		}

		void SetLevel(BasePlayer player, int level)
		{
			float spentXp = player.xp.SpentXp;

			player.xp.Reset();
			player.xp.Add(Rust.Xp.Definitions.Cheat, Rust.Xp.Config.LevelToXp(level));

			player.xp.SpendXp((int) spentXp, string.Empty);
		}

		void SetLevel(ulong id, int level)
		{
			var agent = BasePlayer.FindXpAgent(id);

			float spentXp = agent?.SpentXp ?? 0f;

			agent?.Reset();
			agent?.Add(Rust.Xp.Definitions.Cheat, Rust.Xp.Config.LevelToXp(level));

			agent?.SpendXp((int) spentXp, string.Empty);
		}

		float GetMultiplier(string source)
		{
			if (EarningMultipliers.ContainsKey(source))
				return Convert.ToSingle(EarningMultipliers[source]);

			return 1f;
		}

		float GetPermissionMultiplier(ulong id)
		{
			float multiplier = 1f;

			foreach (var m in PermissionMultipliers)
				if (HasPerm(id, m.Key) && Convert.ToSingle(m.Value) > multiplier)
					multiplier = Convert.ToSingle(m.Value);

			return multiplier;
		}

        int GetMinLevel(ulong id)
        {
            string perm = PermissionLevelRanges.Keys.ToList().Find((k) => HasPerm(id, k));

            if (perm != null)
                return LevelRangeFromPermission(perm).Min;

            return MinimalLevel;
        }

        int GetMaxLevel(ulong id)
        {
            string perm = PermissionLevelRanges.Keys.ToList().Find((k) => HasPerm(id, k));

            if (perm != null)
                return LevelRangeFromPermission(perm).Max;

            return MaximalLevel;
        }

        Range LevelRangeFromPermission(string perm)
        {
            if (!PermissionLevelRanges.ContainsKey(perm))
            {
                PrintError($"Tried to get Min/Max Level for non existant permission '{perm}'!");
                return new Range(MinimalLevel, MaximalLevel);
            }
            
            string str = PermissionLevelRanges[perm].ToString();
            string[] strVars = str.Split('-');
            int[] vars = (from s in strVars where CanBeParsedTo<int>(s) select Convert.ToInt32(s)).ToArray();

            if (vars.Length != 2)
            {
                PrintError($"Min/Max Level for permission '{perm}' is formatted incorrectly! It should be 'min-max' where min and max are numbers!");
                return new Range(MinimalLevel, MaximalLevel);
            }

            return new Range(vars[0], vars[1]);
        }

        Dictionary<string, object> StandardEarningMultipliers
		{
			get
			{
				Dictionary<string, object> dic = new Dictionary<string, object>();

				foreach (var def in Rust.Xp.Definitions.All.Where((d) => d.Name != "Cheat"))
					dic.Add(def.Name, 1f);

				return dic;
			}
		}

        #endregion

        #region Commands

        [ConsoleCommand("xp")]
        void XPCCmd(ConsoleSystem.Arg arg) => XPCmd((BasePlayer)arg.connection?.player ?? null, arg.cmd.name, arg.HasArgs() ? arg.Args : new string[0], true);

		[ChatCommand("xp")]
		void XPCmd(BasePlayer player, string cmd, string[] args, bool console = false)
        {
            string commandPrefix = console ? string.Empty : "/";

            if (player != null && !HasPerm(player.userID, "admin"))
			{
				Reply(player, GetMsg("No Permission"), console);
				return;
			}

			if (args.Length == 0)
			{
                Reply(player, $"{commandPrefix}xp <reset|setlvl|addlvl|info>", console);
				return;
			}

			int level;
			BasePlayer target;

			switch (args[0])
			{
				case "reset":
					if (args.Length != 2)
					{
                        Reply(player, $"Syntax: {commandPrefix}xp reset <player>", console);
						return;
					}

					target = GetPlayer(args[1], player);

					if (target == null)
						return;

					target.xp.Reset();
                    Reply(player, GetMsg("Level Reseted").Replace("{player}", target.displayName), console);
					break;

				case "setlvl":
					if (args.Length != 3)
					{
                        Reply(player, $"Syntax: {commandPrefix}xp setlvl <player> <level>", console);
						return;
					}

					target = GetPlayer(args[1], player);

					if (target == null)
						return;

					if (!int.TryParse(args[2], out level))
					{
                        Reply(player, $"'{args[0]}' is not a valid number!", console);
						return;
					}

					SetLevel(target, level);
                    Reply(player, GetMsg("Level Set").Replace("{player}", target.displayName).Replace("{level}", level.ToString()), console);
					break;

				case "addlvl":
					if (args.Length != 3)
					{
                        Reply(player, $"Syntax: {commandPrefix}xp addlvl <player> <level>", console);
						return;
					}

					target = GetPlayer(args[1], player);

					if (target == null)
						return;

					if (!int.TryParse(args[2], out level))
					{
                        Reply(player, $"'{args[0]}' is not a valid number!", console);
						return;
					}

					AddLevel(target, level);
                    Reply(player, GetMsg("Level Added").Replace("{player}", target.displayName).Replace("{level}", level.ToString()), console);
					break;

				case "info":
                    if (args.Length != 2)
                    {
                        Reply(player, $"Syntax: {commandPrefix}xp info <player>", console);
                        return;
                    }
                    else
					{
						target = GetPlayer(args[1], player);

						if (target == null)
							return;
					}

                    Reply(player, GetMsg("Info").Replace("{player}", target.displayName).Replace("{level}", ((int)target.xp.CurrentLevel).ToString()), console);
					break;

				default:

                    Reply(player, $"{commandPrefix}xp <reset|setlvl|addlvl|info>", console);

					break;
			}
		}

		#endregion

		#region Helpers

        bool CanBeParsedTo<T>(string str)
        {
            try
            {
                T parsed = (T) Convert.ChangeType(str, typeof(T));
                return true;
            }
            catch
            {
                return false;
            }
        }

		bool IsOnline(ulong id) => BasePlayer.FindByID(id)?.IsConnected() ?? false;

		bool IsAdmin(ulong id) => BasePlayer.FindByID(id)?.IsAdmin() ?? false;

		BasePlayer GetPlayer(string searchedPlayer, BasePlayer player)
		{
			foreach (BasePlayer current in BasePlayer.activePlayerList)
				if (current.displayName.ToLower() == searchedPlayer.ToLower())
					return current;

			List<BasePlayer> foundPlayers =
				(from current in BasePlayer.activePlayerList
				 where current.displayName.ToLower().Contains(searchedPlayer.ToLower())
				 select current).ToList();

			switch (foundPlayers.Count)
			{
				case 0:
					SendChatMessage(player, "The player can not be found.");
					break;

				case 1:
					return foundPlayers[0];

				default:
					List<string> playerNames = (from current in foundPlayers select current.displayName).ToList();
					string players = ListToString(playerNames, 0, ", ");
					SendChatMessage(player, "Multiple matching players found: \n" + players);
					break;
			}

			return null;
		}

		string ListToString<T>(List<T> list, int first = 0, string seperator = ", ") => string.Join(seperator, (from val in list select val.ToString()).Skip(first).ToArray());

		T GetConfig<T>(params object[] args)
		{
			List<string> stringArgs = (from arg in args select arg.ToString()).ToList();
			stringArgs.RemoveAt(args.Length - 1);

			if (Config.Get(stringArgs.ToArray()) == null)
			{
				PrintWarning($"Adding '{string.Join("/", stringArgs.ToArray())}' to configfile.");

				Config.Set(args);
			}

			return (T)Convert.ChangeType(Config.Get(stringArgs.ToArray()), typeof(T));
		}

		void LoadData<T>(ref T data, string filename = "?") => data = Core.Interface.Oxide.DataFileSystem.ReadObject<T>(filename == "?" ? this.Title : filename);

		void SaveData<T>(ref T data, string filename = "?") => Core.Interface.Oxide.DataFileSystem.WriteObject(filename == "?" ? this.Title : filename, data);

		string GetMsg(string key, object userID = null) => lang.GetMessage(key, this, userID == null ? null : userID.ToString());

		void RegisterPerm(params string[] permArray)
		{
			string perm = ListToString(permArray.ToList(), 0, ".");

			permission.RegisterPermission($"{PermissionPrefix}.{perm}", this);
		}

		bool HasPerm(object uid, params string[] permArray)
		{
			string perm = ListToString(permArray.ToList(), 0, ".");

			return permission.UserHasPermission(uid.ToString(), $"{PermissionPrefix}.{perm}");
		}

		string PermissionPrefix
		{
			get
			{
				return this.Title.Replace(" ", "").ToLower();
			}
		}

        void Reply(BasePlayer player, string message, bool console)
        {
            if (console && player == null)
                Puts(message);
            else if (console)
                player.ConsoleMessage(message);
            else
                SendChatMessage(player, message);
        }

		void BroadcastChat(string prefix, string msg = null) => rust.BroadcastChat(msg == null ? prefix : "<color=#C4FF00>" + prefix + "</color>: " + msg);

		void SendChatMessage(BasePlayer player, string prefix, string msg = null) => rust.SendChatMessage(player, msg == null ? prefix : "<color=#C4FF00>" + prefix + "</color>: " + msg);

		#endregion
	}
}

// --- End of file: XPManager.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/LogoMenu.cs ---
// --- Original Local Path: LogoMenu.cs ---

﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("LogoMenu", "", "1.1.0")]
    public class LogoMenu : RustPlugin
    {
        [PluginReference] private Plugin ImageLibrary;

        public List<BasePlayer> PlayersTime = new List<BasePlayer>();

        public string porno =
            "https://cdn.discordapp.com/attachments/1047137189076672543/1047188912373764207/1516806452_741_gaymanporn_org.png";
        public string Layer = "LogoMenu";
        public string LayerOnline = "LogoMenu.Online";
        public string LayerButton = "LogoMenu.Button";
        private const string Porno = "Porno.Menu";

        public float FadeIn = 1.0f;
        public float FadeOut = 0.7f;

        private Dictionary<string, string> Images = new Dictionary<string, string>
        {
            ["GS_Store"] = "https://cdn.discordapp.com/attachments/727064710238830643/943852653224550453/LightRust_1243.png",
            ["Online"] = "https://cdn.discordapp.com/attachments/1018247567508774965/1041700929457627176/1.png",
            ["CargoPlane"] = "https://cdn.discordapp.com/attachments/1018247567508774965/1041448035609235466/c44335b18ccdd010.png",
            ["Helicopter"] = "https://cdn.discordapp.com/attachments/1018247567508774965/1041446635219202129/LightRust_1.png",
            ["CH47Helicopter"] = "https://cdn.discordapp.com/attachments/1018247567508774965/1041448035898630144/76b1d033bbdbeba7.png",
            ["BradleyAPC"] = "https://cdn.discordapp.com/attachments/1018247567508774965/1041448426119888906/1.png",
            ["MenuButton"] = "https://cdn.discordapp.com/attachments/922548321531338772/922577086722502656/ec653bf8c05f2fb9.png",
        };

        private void OnServerInitialized()
        {
            foreach (var check in Images)
                ImageLibrary.Call("AddImage", check.Value, check.Key);
            ImageLibrary.Call("AddImage", porno, porno);

            UpdatePlayersUI();
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (player.IsReceivingSnapshot)
            {
                NextTick(() => OnPlayerConnected(player));
                return;
            }

            UpdatePlayersUI();
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            UpdatePlayersUI();
        }

        private void UpdatePlayersUI()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                timer.Once(1, () =>
                {
                    OnlineTextUI(player);

                    MenuUI(player);
                });
            }
        }

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, Layer);
                CuiHelper.DestroyUi(player, LayerButton);
            }

            foreach (var player in PlayersTime)
            {
                CuiHelper.DestroyUi(player, LayerOnline);
            }
        }


        [ConsoleCommand("logo.menu.open")]
        private void CMD_ClickMenu(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0" },
                Image = { Color = "0 0 0 0" }
            }, "Hud", Porno);

            container.Add(new CuiElement
            {
                Name = Porno + ".gay",
                Parent = Porno,
                Components =
                {
                    new CuiRawImageComponent {Png = ImageLibrary.Call<string>("GetImage", porno), Color = "0 0 0 1"},
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0", AnchorMax = "1 1",
                        OffsetMin = "0 0", OffsetMax = "1920 1080"
                    }
                }
            });

            CuiHelper.AddUi(player, container);
        }

        void OnlineTextUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, LayerOnline);

            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0 0 0 0" },
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "0 -34", OffsetMax = "300 0" },
            }, "Hud", LayerOnline);

            string online = $"{BasePlayer.activePlayerList.Count}/{ConVar.Server.maxplayers}";

            container.Add(new CuiElement
            {
                Parent = LayerOnline,
                Name = Layer + ".Text",
                Components =
                {
                    new CuiTextComponent { Text = online, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 13, Color = HexToRustFormat("#FFFFFF99") },
                    new CuiRectTransformComponent{ AnchorMin = "0.3 0", AnchorMax = "0.3 0", OffsetMin = "-24 6.5", OffsetMax = "27.5 30" },
                }
            });

            CuiHelper.AddUi(player, container);
        }

        void MenuUI(BasePlayer player) /*bool open = false*/
        {
            CuiHelper.DestroyUi(player, Layer);

            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0 0 0 0" },
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "0 -34", OffsetMax = "300 0" },
            }, "Hud", Layer);

            container.Add(new CuiElement
            {
                Parent = Layer,
                Name = Layer + ".GameStores.Picture",
                Components =
                {
                    new CuiRawImageComponent { Color = HexToRustFormat("##FFFFFF29"), Png = (string) ImageLibrary.Call("GetImage", "GS_Store") },
                    new CuiRectTransformComponent { AnchorMin = "0.1 0", AnchorMax = "0.1 0", OffsetMin = "-16.5 6.5", OffsetMax = "7 30" }
                }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.1 0", AnchorMax = "0.1 0", OffsetMin = "-16.5 6.5", OffsetMax = "7 30" },
                Text = { Text = "" },
                Button =
                {
                    Color = "0 0 0 0",
                    Command = "chat.say /store"
                }

            }, Layer);

            container.Add(new CuiElement
            {
                Parent = Layer,
                Name = Layer + ".Online.Picture",
                Components =
                {
                    new CuiRawImageComponent { Color = HexToRustFormat("##FFFFFF29"), Png = (string) ImageLibrary.Call("GetImage", "Online") },
                    new CuiRectTransformComponent { AnchorMin = "0.2 0", AnchorMax = "0.2 0", OffsetMin = "-20 6.5", OffsetMax = "3.5 30" }
                }
            });

            //if (open)
            //{
            container.Add(new CuiElement
            {
                Parent = Layer,
                Name = Layer + ".CargoPlane",
                FadeOut = FadeOut,
                Components =
                    {
                        new CuiImageComponent { FadeIn = FadeIn, Color = "0 0 0 0" },
                        new CuiRectTransformComponent { AnchorMin = "0.4 0", AnchorMax = "0.4 0", OffsetMin = "0 6.5", OffsetMax = "23.5 30" }
                    }
            });

            container.Add(new CuiElement
            {
                Parent = Layer,
                Name = Layer + ".BaseHelicopter",
                FadeOut = FadeOut,
                Components =
                    {
                        new CuiImageComponent { FadeIn = FadeIn, Color = "0 0 0 0" },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-1 6.5", OffsetMax = "22 30" }
                    }
            });

            container.Add(new CuiElement
            {
                Parent = Layer,
                Name = Layer + ".CH47Helicopter",
                FadeOut = FadeOut,
                Components =
                    {
                        new CuiImageComponent { FadeIn = FadeIn, Color = "0 0 0 0" },
                        new CuiRectTransformComponent { AnchorMin = "0.6 0", AnchorMax = "0.6 0", OffsetMin = "-3 6.5", OffsetMax = "20 30" }
                    }
            });

            container.Add(new CuiElement
            {
                Parent = Layer,
                Name = Layer + ".BradleyAPC",
                FadeOut = FadeOut,
                Components =
                    {
                        new CuiImageComponent { FadeIn = FadeIn, Color = "0 0 0 0" },
                        new CuiRectTransformComponent { AnchorMin = "0.7 0", AnchorMax = "0.7 0", OffsetMin = "-5 6.5", OffsetMax = "18 30" }
                    }
            });
            //}

            CuiHelper.AddUi(player, container);

            RefreshUI(player, "CargoPlane");
            RefreshUI(player, "BaseHelicopter");
            RefreshUI(player, "BradleyAPC");
            RefreshUI(player, "CH47Helicopter");
        }

        /*void ButtonMenuUI(BasePlayer player)
	    {
		    CuiHelper.DestroyUi(player, LayerButton);
		    
		    CuiElementContainer container = new CuiElementContainer();

		    container.Add(new CuiPanel
		    {
			    CursorEnabled = false,
			    Image = { Color = "0 0 0 0" },
			    RectTransform = { AnchorMin = "0.764 1", AnchorMax = "0.764 1", OffsetMin = "0 -34", OffsetMax = "300 0" },
		    }, "Hud", LayerButton);

		    container.Add(new CuiElement
		    {
			    Parent = LayerButton,
			    Components =
			    {
				    new CuiRawImageComponent { Color = HexToRustFormat("##FFFFFF29"), Png = (string) ImageLibrary.Call("GetImage", "MenuButton") },
				    new CuiRectTransformComponent { AnchorMin = "0.9 0", AnchorMax = "0.9 0", OffsetMin = "2 6.5", OffsetMax = "25.5 30" },
			    }
		    });
	        
		    container.Add(new CuiButton	
		    {
			    RectTransform = { AnchorMin = "0.9 0", AnchorMax = "0.9 0", OffsetMin = "2 6.5", OffsetMax = "25.5 30" },
			    Button = { Command = "logo.menu.open", Color = "0 0 0 0" },
			    Text = { Text = "" }
		    }, LayerButton);
		    
		    CuiHelper.AddUi(player, container);
	    }*/


        private void RefreshUI(BasePlayer player, string Type)
        {
            CuiElementContainer RefreshContainer = new CuiElementContainer();

            switch (Type)
            {
                case "CargoPlane":
                    CuiHelper.DestroyUi(player, Layer + ".CargoPlane.Destroy");

                    RefreshContainer.Add(new CuiElement
                    {
                        Parent = Layer + ".CargoPlane",
                        Name = Layer + ".CargoPlane.Destroy",
                        FadeOut = FadeOut,
                        Components =
                        {
                            new CuiRawImageComponent
                            {
                                FadeIn = FadeIn, Color = IsCargoPlane() ? HexToRustFormat("##EDBE5C5B") : HexToRustFormat("##FFFFFF29"),
                                Png = (string) ImageLibrary.Call("GetImage", "CargoPlane")
                            },
                            new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" },
                        }
                    });
                    break;

                case "BaseHelicopter":
                    CuiHelper.DestroyUi(player, Layer + ".BaseHelicopter.Destroy");

                    RefreshContainer.Add(new CuiElement
                    {
                        Parent = Layer + ".BaseHelicopter",
                        Name = Layer + ".BaseHelicopter.Destroy",
                        FadeOut = FadeOut,
                        Components =
                        {
                            new CuiRawImageComponent
                            {
                                FadeIn = FadeIn, Color = IsBaseHelicopter() ? HexToRustFormat("##EDBE5C5B") : HexToRustFormat("##FFFFFF29"),
                                Png = (string) ImageLibrary.Call("GetImage", "Helicopter")
                            },
                            new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" },
                        }
                    });
                    break;

                case "BradleyAPC":
                    CuiHelper.DestroyUi(player, Layer + ".BradleyAPC.Destroy");

                    RefreshContainer.Add(new CuiElement
                    {
                        Parent = Layer + ".BradleyAPC",
                        Name = Layer + ".BradleyAPC.Destroy",
                        FadeOut = FadeOut,
                        Components =
                        {
                            new CuiRawImageComponent
                            {
                                FadeIn = FadeIn, Color = IsBradleyAPC() ? HexToRustFormat("##EDBE5C5B") : HexToRustFormat("##FFFFFF29"),
                                Png = (string) ImageLibrary.Call("GetImage", "BradleyAPC")
                            },
                            new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" },
                        }
                    });
                    break;

                case "CH47Helicopter":
                    CuiHelper.DestroyUi(player, Layer + ".CH47Helicopter.Destroy");

                    RefreshContainer.Add(new CuiElement
                    {
                        Parent = Layer + ".CH47Helicopter",
                        Name = Layer + ".CH47Helicopter.Destroy",
                        FadeOut = FadeOut,
                        Components =
                        {
                            new CuiRawImageComponent
                            {
                                FadeIn = FadeIn, Color = IsCH47Helicopter() ? HexToRustFormat("##EDBE5C5B") : HexToRustFormat("##FFFFFF29"),
                                Png = (string) ImageLibrary.Call("GetImage", "CH47Helicopter")
                            },
                            new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" },
                        }
                    });
                    break;
            }

            CuiHelper.AddUi(player, RefreshContainer);
        }

        void OnEntitySpawned(BaseNetworkable entity)
        {
            if (entity == null || entity?.net.ID == null) return;
            if (!(entity is CargoPlane) || !(entity is BaseHelicopter) || !(entity is BradleyAPC) || !(entity is CH47Helicopter)) return;

            string type = string.Empty;

            if (entity is CargoPlane)
                type = "CargoPlane";
            if (entity is BaseHelicopter)
                type = "BaseHelicopter";
            if (entity is BradleyAPC)
                type = "BradleyAPC";
            if (entity is CH47Helicopter)
                type = "CH47Helicopter";

            RefreshUI(type);
        }

        void OnEntityKill(BaseNetworkable entity)
        {
            if (entity == null || entity?.net.ID == null) return;
            if (!(entity is CargoPlane) || !(entity is BaseHelicopter) || !(entity is BradleyAPC) || !(entity is CH47Helicopter)) return;

            string type = string.Empty;

            if (entity is CargoPlane)
                type = "CargoPlane";
            if (entity is BaseHelicopter)
                type = "BaseHelicopter";
            if (entity is BradleyAPC)
                type = "BradleyAPC";
            if (entity is CH47Helicopter)
                type = "CH47Helicopter";

            RefreshUI(type);
        }

        private void RefreshUI(string tag)
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                RefreshUI(player, tag);
            }
        }

        string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex)) hex = "#FFFFFFFF";
            var str = hex.Trim('#');
            if (str.Length == 6) str += "FF";
            if (str.Length != 8) throw new Exception(hex);

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);
            Color color = new Color32(r, g, b, a);

            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }

        bool IsCargoPlane()
        {
            foreach (var check in BaseNetworkable.serverEntities)
                if (check is CargoPlane) return true;
            return false;
        }
        bool IsBaseHelicopter()
        {
            foreach (var check in BaseNetworkable.serverEntities)
                if (check is BaseHelicopter) return true;
            return false;
        }
        bool IsBradleyAPC()
        {
            foreach (var check in BaseNetworkable.serverEntities)
                if (check is BradleyAPC) return true;
            return false;
        }
        bool IsCH47Helicopter()
        {
            foreach (var check in BaseNetworkable.serverEntities)
                if (check is CH47Helicopter) return true;
            return false;
        }
    }
}

// --- End of file: LogoMenu.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/LustyPort.cs ---
// --- Original Local Path: LustyPort.cs ---

using UnityEngine;
using System;
using System.Reflection;
using System.Collections;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("LustyPort", "Kayzor", "1.1.11", ResourceId = 1250)]
    [Description("A simple teleportation plugin!")]
    public class LustyPort : RustPlugin
    {
        // Plugin variables
        string lustyPlugin = null;
        string lustyAuthor = null;
        string lustyVersion = null;
        string lustyDescription = null;
				
        List<LustyPorts> lustyPorts = new List<LustyPorts>();
		List<LustyPlayers> lustyPlayers = new List<LustyPlayers>();
		List<LustyTeleportings> teleportingPlayers = new List<LustyTeleportings>();

        int teleportDuration = 10; // Seconds

        void Init()
        {
            object[] getAttributes = this.GetType().GetCustomAttributes(false);

            foreach (Attribute a in getAttributes)
            {
                if (a.ToString() == "Oxide.Plugins.DescriptionAttribute")
                {
                    lustyDescription = (a as DescriptionAttribute).Description;
                }
                else if (a.ToString() == "Oxide.Plugins.InfoAttribute")
                {
                    lustyPlugin = (a as InfoAttribute).Title;
                    lustyAuthor = (a as InfoAttribute).Author;
                    lustyVersion = (a as InfoAttribute).Version.ToString();
                }
            }
			
			lustyPorts = Interface.GetMod().DataFileSystem.ReadObject<List<LustyPorts>>("LustyPortTeleports");
			lustyPlayers = Interface.GetMod().DataFileSystem.ReadObject<List<LustyPlayers>>("LustyPortPlayers");

            timer.Repeat(0.999f, 0, () => timerPort());
        }

        // Chat Commands
        [ChatCommand("tp")]
        private void tpCmd(BasePlayer player, string command, string[] args)
        {
            if (args.Length >= 1)
            {
                tpPort(player, false, args[0]);
            }
            else
            {
                noArg(player, command);
            }
        }

        [ChatCommand("tp_add")]
        private void tpAdd(BasePlayer player, string command, string[] args)
        {
            if (isAdmin(player))
            {
                if (args.Length >= 1)
                {
					bool admin = false;
					if (args.Length >= 2)
					{
						try
						{
							admin = Convert.ToBoolean(args[1]);
						}
						catch {	}
					}
                    addPort(player, args[0], admin);
                }
                else
                {
                    noArg(player, command);
                }
            }
        }

        [ChatCommand("tp_del")]
        private void tpDel(BasePlayer player, string command, string[] args)
        {
            if (isAdmin(player))
            {
                if (args.Length >= 1)
                {
                    delPort(player, args[0]);
                }
                else
                {
                    noArg(player, command);
                }
            }
        }


        [ChatCommand("tp_back")]
        private void tpBack(BasePlayer player, string command, string[] args)
        {
            tpPort(player, true);
        }

        [ChatCommand("tp_list")]
        private void tpList(BasePlayer player, string command, string[] args)
        {
			// List Admin Locations
            if (isAdmin(player))
            {
                List<LustyPorts> listAdminPorts = lustyPorts.FindAll(r => r.admin == true);
				if (listAdminPorts.Count > 0)
				{
					playerMsg(player, "Admin Only Teleport Locations:");
					foreach (LustyPorts lustyPort in listAdminPorts)
					{
						playerMsg(player, "<color=#00ff00ff>" + lustyPort.name + "</color> (" + lustyPort.x + "," + lustyPort.y + "," + lustyPort.z + ")");
					}
				}
			}

            // List Locations
            List<LustyPorts> listPorts = lustyPorts.FindAll(r => r.admin == false);
			if (listPorts.Count > 0)
			{
				playerMsg(player, "Teleport Locations:");
				foreach (LustyPorts lustyPort in listPorts)
				{
					playerMsg(player, "<color=#00ff00ff>" + lustyPort.name + "</color> (" + lustyPort.x + "," + lustyPort.y + "," + lustyPort.z + ")");
				}
			}
			else
			{
				playerMsg(player, "No teleport locations have been setup");
			}
        }

        [ChatCommand("tp_about")]
        private void tpAbout(BasePlayer player, string command, string[] args)
        {
            playerMsg(player, "<color=#00ff00ff>" + lustyPlugin + "</color> v <color=#00ff00ff>" + lustyVersion + "</color> by <color=#00ff00ff>" + lustyAuthor + "</color>");
            playerMsg(player, lustyDescription);
            playerMsg(player, "Type <color=#00ff00ff>/tp_help</color> for a list of all commands");
        }

        [ChatCommand("tp_help")]
        private void tpHelp(BasePlayer player, string command, string[] args)
        {
            playerMsg(player, "<color=#00ff00ff>" + lustyPlugin + "</color> v <color=#00ff00ff>" + lustyVersion + "</color>");
            playerMsg(player, lustyDescription);
            playerMsg(player, "Type <color=#00ff00ff>/tp <location></color> - Teleports you to location");
            playerMsg(player, "Type <color=#00ff00ff>/tp_back</color> - Teleports you back to your original location");
            playerMsg(player, "Type <color=#00ff00ff>/tp_list</color> - Lists all available locations");
            if (isAdmin(player)) {
                playerMsg(player, "Type <color=#00ff00ff>/tp_add <name> (optional)true</color> - Adds a new location set to your current position (optional)Admin only");
                playerMsg(player, "Type <color=#00ff00ff>/tp_del <name></color> - Deletes a location");
            }
            playerMsg(player, "Type <color=#00ff00ff>/tp_about</color> - Information about the plugin");
            playerMsg(player, "Type <color=#00ff00ff>/tp_help</color> - Displays this menu");
        }
		
		// Teleporting Class
		private class LustyTeleportings
		{
			public ulong userid { get; set; }
			public DateTime starttime { get; set; }
			public float x { get; set; }
			public float y { get; set; }
			public float z { get; set; }
            public LustyPorts lustyPort { get; set; }
            public bool back { get; set; }
		}
		
		// Player Locations	
		private class LustyPlayers
		{
			public ulong userid	{ get; set; }		
			public LustyPorts lustyPort { get; set; }
        }

        private void savePorts()
        {
            Interface.GetMod().DataFileSystem.WriteObject("LustyPortTeleports", lustyPorts);
        }

        private void savePlayers()
        {
            Interface.GetMod().DataFileSystem.WriteObject("LustyPortPlayers", lustyPlayers);
        }

        // Teleport Locations
        private class LustyPorts
		{
			public string name { get; set; }
			public float x { get; set; }
			public float y { get; set; }
			public float z { get; set; }
			public bool admin { get; set; }
		}
        
		private LustyPorts findPort(string name)
		{
			LustyPorts lustyPort = lustyPorts.Find(r => r.name.ToLower() == name.ToLower());
			return lustyPort;
		}		
		
		private void addPort(BasePlayer player, string name, bool admin = false)
		{
			if (findPort(name) == null)
			{
				LustyPorts lustyPort = new LustyPorts();
				lustyPort.name = name;
				lustyPort.admin = admin;
                lustyPort.x = player.transform.position.x;
                lustyPort.y = player.transform.position.y;
                lustyPort.z = player.transform.position.z;
				lustyPorts.Add(lustyPort);
                savePorts();

                string adminTxt = "";
                if (admin)
                {
                    adminTxt = " (Admin only)";
                }

				playerMsg(player, "Teleport location<color=#00ff00ff> " + name + adminTxt + "</color> added");
			}
			else
			{
				playerMsg(player, "There is already a teleport location named<color=#00ff00ff> " + name + "</color>");
			}		
		}
		
		private void delPort(BasePlayer player, string name)
		{
			LustyPorts lustyPort = findPort(name);
			if (lustyPort != null)
			{
				lustyPorts.Remove(lustyPort);
                savePorts();
				
				playerMsg(player, "Teleport location<color=#00ff00ff> " + name + " </color>removed");
			}
			else
			{
				playerMsg(player, "There is already a teleport location named<color=#00ff00ff> " + name + "</color>");
			}
		}
		
        private void tpPort(BasePlayer player, bool back, string name = null)
        {
            LustyPorts lustyPort = new LustyPorts();
            if (back)
            {
                if (lustyPlayers.Count > 0)
                {
                    lustyPort = lustyPlayers.Find(r => r.userid == player.userID).lustyPort;
                    if (lustyPort == null)
                    {
                        playerMsg(player, "You do not have an orginal location to teleport back too");
                        return;
                    }
                }
                else
                {
                    playerMsg(player, "You do not have an orginal location to teleport back too");
                    return;
                }
            }
            else
            {
                lustyPort = findPort(name);
            }
            if (lustyPort != null)
            {
                if (findTeleportingPlayer(player.userID) == null)
                {
                    if (!lustyPort.admin)
                    {
                        startPort(player, lustyPort, back);
                    }
                    else if (isAdmin(player))
                    {
                        startPort(player, lustyPort, back);
                    }
                    else
                    {
                        playerMsg(player, "You do not have access to teleport to that location");
                    }
                }
                else
                {
                    playerMsg(player, "You already have an active teleport request");
                }
            }
            else
            {
                playerMsg(player, "Teleport location <color=#00ff00ff>" + name + "</color> not found");
            }
        }

        private void startPort(BasePlayer player, LustyPorts lustyPort, bool back)
        {
            LustyTeleportings tpPlayer = new LustyTeleportings();
            tpPlayer.starttime = DateTime.UtcNow;
            tpPlayer.userid = player.userID;
            tpPlayer.x = player.transform.position.x;
            tpPlayer.y = player.transform.position.y;
            tpPlayer.z = player.transform.position.z;
            tpPlayer.lustyPort = lustyPort;
            tpPlayer.back = back;
            teleportingPlayers.Add(tpPlayer);
            playerMsg(player, "Teleport initiated, you will be teleported in <color=#00ff00ff>" + teleportDuration + "</color> seconds, remain still!");
        }

        private LustyTeleportings findTeleportingPlayer(ulong userid)
        {
            LustyTeleportings teleportingPlayer = teleportingPlayers.Find(r => r.userid == userid);
            if (teleportingPlayer != null)
            {
                return teleportingPlayer;
            }
            return null;
        }

        private BasePlayer findPlayer(ulong userid)
        {
            BasePlayer findPlayer = BasePlayer.activePlayerList.Find(r => r.userID == userid);
            if (findPlayer != null)
            {
                return findPlayer;
            }
            return null;
        }

        // Timer Function
        private void timerPort()
        {
            if (teleportingPlayers.Count > 0)
            {
                for (int i = teleportingPlayers.Count - 1; i >= 0; i--)
                {
                    LustyTeleportings teleportingPlayer = teleportingPlayers[i];
                    BasePlayer player = findPlayer(teleportingPlayer.userid);

                    if (checkTeleport(player, teleportingPlayer))
                    {
                        if (DateTime.UtcNow > teleportingPlayer.starttime.AddSeconds(teleportDuration))
                        {
                            if (teleportingPlayer.back)
                            {
                                LustyPlayers lustyPlayer = lustyPlayers.Find(r => r.userid == player.userID);
                                lustyPlayers.Remove(lustyPlayer);
                                savePlayers();
                            }
                            else
                            {
                                if (lustyPlayers.Count > 0)
                                {
                                    LustyPlayers lustyPlayerCheck = lustyPlayers.Find(r => r.userid == player.userID);
                                    if (lustyPlayerCheck == null)
                                    {
                                        addPlayer(player);
                                    }
                                }
                                else
                                {
                                    addPlayer(player);
                                }                                
                            }

                            Vector3 destination = new Vector3(teleportingPlayer.lustyPort.x, teleportingPlayer.lustyPort.y, teleportingPlayer.lustyPort.z);
                            TeleportPlayerPosition(player, destination);

                            teleportingPlayers.RemoveAt(i);
                        }
                        else
                        {
                            TimeSpan timeSpan = teleportingPlayer.starttime.AddSeconds(teleportDuration).Subtract(DateTime.UtcNow);
                            int time = Convert.ToInt16(Math.Ceiling(timeSpan.TotalSeconds));
                            if (time > 0 && time < teleportDuration)
                            {
                                playerMsg(player, "Teleporting in " + time.ToString());
                            }
                        }
                    }
                    else
                    {
                        teleportingPlayers.RemoveAt(i);
                        playerMsg(player, "Movement detected, aborting teleport.");
                    }
                }
            }
        }

        private void addPlayer(BasePlayer player)
        {
            LustyPlayers lustyPlayer = new LustyPlayers();
            lustyPlayer.userid = player.userID;

            LustyPorts lustyPort = new LustyPorts();
            lustyPort.admin = false;
            lustyPort.name = player.userID.ToString();
            lustyPort.x = player.transform.position.x;
            lustyPort.y = player.transform.position.y;
            lustyPort.z = player.transform.position.z;

            lustyPlayer.lustyPort = lustyPort;
            lustyPlayers.Add(lustyPlayer);
            savePlayers();
        }

        private bool checkTeleport(BasePlayer player, LustyTeleportings teleportingPlayer)
        {
            try
            {
                if (Convert.ToSingle(player.transform.position.x) >= (teleportingPlayer.x - 0.2) && Convert.ToSingle(player.transform.position.x) <= (teleportingPlayer.x + 0.2))
                {
                    if (Convert.ToSingle(player.transform.position.y) >= (teleportingPlayer.y - 0.2) && Convert.ToSingle(player.transform.position.y) <= (teleportingPlayer.y + 0.2))
                    {
                        if (Convert.ToSingle(player.transform.position.z) >= (teleportingPlayer.z - 0.2) && Convert.ToSingle(player.transform.position.z) <= (teleportingPlayer.z + 0.2))
                        {
                            return true;
                        }
                    }
                }
                return false;
            }
            catch
            {
                return false;
            }
        }


        // Random Functions
        private void noArg(BasePlayer player, string command)
        {
            if (command == "tp")
            {
                playerMsg(player, "Invalid command! Usage: <color=#00ff00ff>/tp <location></color>");
                playerMsg(player, "Type <color=#00ff00ff>/tp_help</color> for a list of all commands");
            }
            if (command == "tp_add")
            {
                playerMsg(player, "Invalid command! Usage: <color=#00ff00ff>/tp_add <name></color> - Adds a new location set to your current location");
                playerMsg(player, "Type <color=#00ff00ff>/tp_help</color> for a list of all commands");
            }
            if (command == "tp_back")
            {
                playerMsg(player, "Invalid command! Usage: <color=#00ff00ff>/tp_del <name></color> - Deletes location from the list");
                playerMsg(player, "Type <color=#00ff00ff>/tp_help<color> for a list of all commands");
            }
        }

        private void playerMsg(BasePlayer player, string msg)
        {
            SendReply(player, String.Format("<color=#008080ff>Lusty Port</color> {0}", msg));
        }

        bool isAdmin(BasePlayer player)
        {
            if (player.net.connection.authLevel >= 1)
            {
                return true;
            }
            return false;
        }

        void TeleportPlayerPosition(BasePlayer player, Vector3 destination)
        {
            player.ClientRPCPlayer(null, player, "StartLoading", null, null, null, null, null);
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Sleeping, true);
            if (!BasePlayer.sleepingPlayerList.Contains(player)) BasePlayer.sleepingPlayerList.Add(player);
            player.MovePosition(destination);
            player.ClientRPCPlayer(null, player, "ForcePositionTo", destination);
            player.TransformChanged();
            player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
            player.UpdateNetworkGroup();
            player.SendNetworkUpdateImmediate(false);
            try { player.ClearEntityQueue(null); } catch { }
            player.SendFullSnapshot();
            player.EndSleeping();
        }        
    }
}

// --- End of file: LustyPort.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/CombatBB.cs ---
// --- Original Local Path: CombatBB.cs ---

using System;
using System.Linq;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using Oxide.Core.Libraries.Covalence;
using ru = Oxide.Game.Rust;

using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;

using Newtonsoft.Json.Linq;

using UnityEngine;
using Facepunch;
using Rust;

namespace Oxide.Plugins
{
    [Info("CombatBB", "King", "2.1.35")]
    [Description("Prevent commands/actions while raid and/or combat is occuring")]
    class CombatBB : RustPlugin
    {
        [PluginReference] private Plugin ImageLibrary;
        public static CombatBB ins;
        #region new
        private void CmdMenuOpen1y(IPlayer user, string cmd, string[] args)
        {
            var player = user?.Object as BasePlayer;
            if(player == null) return;

            consoleOpenf(player);
            openPanels[player] = true;
        }

        private void CmdMenuClose1y(IPlayer user, string cmd, string[] args)
        {
            var player = user?.Object as BasePlayer;
            if(player == null) return;

            CuiHelper.DestroyUi(player, "infof");
            openPanels[player] = false;
        }
        public void consoleOpenf(BasePlayer player)
        {
            double pp = 0;
            BlockBehavior behavior;
            if(blockBehaviors.TryGetValue(player.userID, out behavior)) {
                if(behavior is CombatBlock) 
                {
                    var combatBlockComponent = player.gameObject.GetComponent<CombatBlock>();
                    pp = combatBlockComponent.GetTimeBlock();
                }
            }
            
            InfoMenuf(player);
            timerUIf(player, pp);
        }

        public Dictionary<BasePlayer, bool> openPanels = new Dictionary<BasePlayer, bool>();
            public void MainGUIf(BasePlayer player) 
            {
                var c = new CuiElementContainer();
                UI.AddImage(ref c, "Overlay", "MainGUIf", "0 0 0 0", "", "", "1 0.5", "1 0.5", $"-44.182 -20.661", $"-3.618 78.735");
                UI.AddImage(ref c, "MainGUIf", "mainf", "0.5 0.5 0.5 0.25", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", "-20.282 -41.715", "20.283 -2.035");
                UI.AddRawImage(ref c, "mainf", "iconsf", ImageLibrary?.Call<string>("GetImage", "bombs"), "1 1 1 0.9", "", "", "0 0", "1 1", "6 7", "-7 -6");
                UI.AddImage(ref c, "MainGUIf", "linesf", "0 0 0 0", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", "-20.282 -41.715", "20.283 -39.185");
                UI.AddButton(ref c, "mainf", "openf", "infoopen", "", "0 0 0 0", "", "", "0 0", "1 1", "", "");
                CuiHelper.DestroyUi(player, "MainGUIf");
                CuiHelper.AddUi(player, c);
            }
            public void InfoMenuf(BasePlayer player) 
            {
                var c = new CuiElementContainer();
                UI.AddImage(ref c, "MainGUIf", "infof", "0.5 0.5 0.5 0.25", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", "-223.521 -41.715", "-24.017 -2.035");
                UI.AddText(ref c, "infof", "textf", "1 1 1 0.9", $"Во время комбат блока, возможно\nнекоторые функции не доступны!", TextAnchor.UpperLeft, 10, "0.5 0.5", "0.5 0.5", "-94.187 -20", "91.911 6.411");
                UI.AddButton(ref c, "infof", "closef", "infoclose", "", "0.70 0.00 0.00 0.8", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", "85.23 5.691", "99.752 19.875");
                UI.AddText(ref c, "closef","closesf", "1 1 1 0.9", $"☓", TextAnchor.MiddleCenter, 10, "0.5 0.5", "0.5 0.5", "-6.737 -6.201", "6.737 6.202");
                CuiHelper.DestroyUi(player, "infof");
                CuiHelper.AddUi(player, c);
            }
            public void timerUIf(BasePlayer player, double time)
            {
                var c = new CuiElementContainer();
                
                UI.AddText(ref c, "infof", "titlef", "1 1 1 0.9", $"До конца комбат блока: [{FormatTime(TimeSpan.FromSeconds(time))}]", TextAnchor.UpperLeft, 12, "0.5 0.5", "0.5 0.5", "-94.187 -4.775", "85.183 19.875");
                CuiHelper.DestroyUi(player, "infof");
                CuiHelper.DestroyUi(player, "titlef");
                CuiHelper.AddUi(player, c);
            }
            public void linesf(BasePlayer player, double time)
            {
                var c = new CuiElementContainer();

                CuiHelper.DestroyUi(player, "linef");
                double timeLines =(time /(combatDuration));

                UI.AddImage(ref c, "linesf", "linef", HexToRustFormat("#8e6874"), "", "assets/icons/greyout.mat", "0 0", $"{timeLines} 1", "", "");
                
                CuiHelper.AddUi(player, c);
            }

        #endregion

        private static string HexToRustFormat(string hex)
        {
            UnityEngine.Color color;
            ColorUtility.TryParseHtmlString(hex, out color);
            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }


        [ChatCommand("5789")]
        void pop(BasePlayer player)
        {
            StartCombatBlocking(player);
        }
        #region Setup & Configuration

        List<string> blockTypes = new List<string>()
        {
            "remove",
            "tp",
            "bank",
            "trade",
            "recycle",
            "shop",
            "bgrade",
            "build",
            "repair",
            "upgrade",
            "vend",
            "kit",
            "assignbed",
            "craft",
            "mailbox",
            "backpack"
        };

        // COMBAT SETTINGS
        bool combatBlock;
        static float combatDuration;
        bool combatOnHitPlayer;
        float combatOnHitPlayerMinCondition;
        float combatOnHitPlayerMinDamage;

        bool combatOnTakeDamage;
        float combatOnTakeDamageMinCondition;
        float combatOnTakeDamageMinDamage;

        bool combatOnHitNPC;
        bool combatOnTakeDamageNPC;

        // RAID BLOCK SETTINGS
        bool raidBlock;
        static float raidDuration;
        float raidDistance;
        bool blockOnDamage;
        float blockOnDamageMinCondition;
        bool blockOnDestroy;

        // RAID-ONLY SETTINGS
        bool ownerCheck;
        bool blockUnowned;
        bool blockAll;
        // IGNORES ALL OTHER CHECKS
        bool ownerBlock;
        bool cupboardShare;
        bool friendShare;
        bool clanShare;
        bool clanCheck;
        bool friendCheck;
        bool raiderBlock;
        List<string> raidDamageTypes;
        List<string> raidDeathTypes;
        List<string> combatDamageTypes;

        // RAID UNBLOCK SETTINGS
        bool raidUnblockOnDeath;
        bool raidUnblockOnWakeup;
        bool raidUnblockOnRespawn;

        // COMBAT UNBLOCK SETTINGS
        bool combatUnblockOnDeath;
        bool combatUnblockOnWakeup;
        bool combatUnblockOnRespawn;

        float cacheTimer;

        // MESSAGES
        bool raidBlockNotify;
        bool combatBlockNotify;

        bool useZoneManager;
        bool zoneEnter;
        bool zoneLeave;
        
        bool useRaidableBases;
        bool raidableZoneEnter;
        bool raidableZoneLeave;

        bool sendUINotification;
        bool sendChatNotification;
        bool sendGUIAnnouncementsNotification;
        bool sendLustyMapNotification;

        string GUIAnnouncementTintColor = "Red";
        string GUIAnnouncementTextColor = "White";

        string LustyMapIcon = "special";
        float LustyMapDuration = 150f;

        Dictionary<string, RaidZone> zones = new Dictionary<string, RaidZone>();
        Dictionary<string, List<string>> memberCache = new Dictionary<string, List<string>>();
        Dictionary<string, string> clanCache = new Dictionary<string, string>();
        Dictionary<string, List<string>> friendCache = new Dictionary<string, List<string>>();
        Dictionary<string, DateTime> lastClanCheck = new Dictionary<string, DateTime>();
        Dictionary<string, DateTime> lastCheck = new Dictionary<string, DateTime>();
        Dictionary<string, DateTime> lastFriendCheck = new Dictionary<string, DateTime>();
        Dictionary<string, bool> prefabBlockCache = new Dictionary<string, bool>();
        internal Dictionary<ulong, BlockBehavior> blockBehaviors = new Dictionary<ulong, BlockBehavior>();

        public static CombatBB plugin;

        [PluginReference]
        Plugin Clans, Friends, ZoneManager, GUIAnnouncements, LustyMap;

        readonly int cupboardMask = LayerMask.GetMask("Deployed");
        readonly int blockLayer = LayerMask.GetMask("Player(Server)");
        Dictionary<string, bool> _cachedExcludedWeapons = new Dictionary<string, bool>();

        List<string> blockedPrefabs = new List<string>()
        {
            "door",
            "window.bars",
            "floor.ladder.hatch",
            "floor.frame",
            "wall.frame",
            "shutter",
            "external"
        };

        List<string> exceptionPrefabs = new List<string>()
        {
            "ladder.wooden"
        };

        List<string> exceptionWeapons = new List<string>()
        {
            "torch"
        };

        private List<string> GetDefaultRaidDamageTypes()
        {
            return new List<DamageType>()
            {
                DamageType.Bullet,
                DamageType.Blunt,
                DamageType.Stab,
                DamageType.Slash,
                DamageType.Explosion,
                DamageType.Heat
            }.Select(x => x.ToString()).ToList<string>();
        }

        private List<string> GetDefaultCombatDamageTypes()
        {
            return new List<DamageType>()
            {
                DamageType.Bullet,
                DamageType.Arrow,
                DamageType.Blunt,
                DamageType.Stab,
                DamageType.Slash,
                DamageType.Explosion,
                DamageType.Heat,
                DamageType.ElectricShock
            }.Select(x => x.ToString()).ToList<string>();
        }

        Dictionary<string, object> blockWhenRaidDamageDefault = new Dictionary<string, object>() {
            {"enabled", true},
            {"minCondition", 100f},
        };

        Dictionary<string, object> blockWhenCombatDamageDefault = new Dictionary<string, object>() {
            {"enabled", false},
            {"minCondition", 100f},
            {"minDamage", 1f},
        };

        static Regex _htmlRegex = new Regex("<.*?>", RegexOptions.Compiled);

        protected override void LoadDefaultConfig()
        {
            Config ["VERSION"] = Version.ToString();

            // RAID SETTINGS
            Config ["Raid", "Block", "enabled"] = true;
            Config ["Raid", "Block", "duration"] = 300f; // 5 minutes
            Config ["Raid", "Block", "distance"] = 100f;
            Config ["Raid", "Block", "notify"] = true;
            Config ["Raid", "Block", "damageTypes"] = GetDefaultRaidDamageTypes();
            Config ["Raid", "Block", "deathTypes"] = GetDefaultRaidDamageTypes();
            Config ["Raid", "Block", "includePrefabs"] = blockedPrefabs;
            Config ["Raid", "Block", "excludePrefabs"] = exceptionPrefabs;
            Config ["Raid", "Block", "excludeWeapons"] = exceptionWeapons;

            Config ["Raid", "BlockWhen", "damage"] = blockWhenRaidDamageDefault;

            Config ["Raid", "BlockWhen", "destroy"] = true;
            Config ["Raid", "BlockWhen", "unowned"] = false;

            Config ["Raid", "BlockWho", "everyone"] = true;
            Config ["Raid", "BlockWho", "owner"] = false;
            Config ["Raid", "BlockWho", "cupboardAuthorized"] = false;
            Config ["Raid", "BlockWho", "clan"] = false;
            Config ["Raid", "BlockWho", "friends"] = false;
            Config ["Raid", "BlockWho", "raider"] = false;

            Config ["Raid", "BlockExcept", "owner"] = true;
            Config ["Raid", "BlockExcept", "friends"] = false;
            Config ["Raid", "BlockExcept", "clan"] = false;

            Config ["Raid", "Zone", "enabled"] = false;
            Config ["Raid", "Zone", "enter"] = true;
            Config ["Raid", "Zone", "leave"] = false;

            Config ["Raid", "Map", "enabled"] = false;
            Config ["Raid", "Map", "icon"] = "special";
            Config ["Raid", "Map", "duration"] = 150f;

            Config ["Raid", "UnblockWhen", "death"] = true;
            Config ["Raid", "UnblockWhen", "wakeup"] = false;
            Config ["Raid", "UnblockWhen", "respawn"] = true;

            // COMBAT SETTINGS
            Config ["Combat", "Block", "enabled"] = false;
            Config ["Combat", "Block", "duration"] = 180f; // 3 minutes
            Config ["Combat", "Block", "notify"] = true;
            Config ["Combat", "Block", "damageTypes"] = GetDefaultCombatDamageTypes();

            Config ["Combat", "BlockWhen", "giveDamage"] = blockWhenCombatDamageDefault;
            Config ["Combat", "BlockWhen", "takeDamage"] = blockWhenCombatDamageDefault;

            Config ["Combat", "BlockWhen", "npcGiveDamage"] = false;
            Config ["Combat", "BlockWhen", "npcTakeDamage"] = false;

            Config ["Combat", "UnblockWhen", "death"] = true;
            Config ["Combat", "UnblockWhen", "wakeup"] = false;
            Config ["Combat", "UnblockWhen", "respawn"] = true;

            Config ["Settings", "cacheMinutes"] = 1f;
            Config ["Settings", "Block", "Types"] = blockTypes;

            Config ["Notifications", "UI"] = true;
            Config ["Notifications", "Chat"] = true;
            Config ["Notifications", "GUIAnnouncements", "enabled"] = false;
            Config ["Notifications", "GUIAnnouncements", "backgroundColor"] = "Red";
            Config ["Notifications", "GUIAnnouncements", "textColor"] = "White";

            Config ["VERSION"] = Version.ToString();
        }

        void Loaded()
        {
            LoadMessages();
        }

        void Unload()
        {
            if(useZoneManager)
                foreach(var zone in zones.ToList())
                    EraseZone(zone.Value.zoneid);

            var objects = GameObject.FindObjectsOfType(typeof(RaidBlock));
            if(objects != null)
                foreach(var gameObj in objects)
                    if(!((RaidBlock)gameObj).Active)
                        GameObject.Destroy(gameObj);

            objects = GameObject.FindObjectsOfType(typeof(CombatBlock));
            if(objects != null)
                foreach(var gameObj in objects)
                    if(!((CombatBlock)gameObj).Active)
                        GameObject.Destroy(gameObj);

            foreach(var player in BasePlayer.activePlayerList)
            {
                var combatBlocker = player.gameObject.GetComponent<CombatBlock>();
                if(combatBlocker != null)
                {
                    combatBlocker.Destroys();
                }
                CuiHelper.DestroyUi(player, "MainGUIf");
            }
        }

        void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
                {
                    { "Raid Blocked Message", "You may not do that while raid blocked({time})" },
                    { "Combat Blocked Message", "You may do that while a in combat({time})" },
                    { "Raid Block Complete", "You are no longer raid blocked." },
                    { "Combat Block Complete", "You are no longer combat blocked." },
                    { "Raid Block Notifier", "You are raid blocked for {time}" },
                    { "Combat Block Notifier", "You are combat blocked for {time}" },
                    { "Combat Block UI Message", "COMBAT BLOCK" },
                    { "Raid Block UI Message", "RAID BLOCK" },
                    { "Unit Seconds", "second(s)" },
                    { "Unit Minutes", "minute(s)" },
                    { "Prefix", string.Empty }
                }, this);
        }

        void CheckConfig()
        {
            if(Config ["VERSION"] == null) {
                // FOR COMPATIBILITY WITH INITIAL VERSIONS WITHOUT VERSIONED CONFIG
                ReloadConfig();
            } else if(GetConfig("VERSION", string.Empty) != Version.ToString()) {
                // ADDS NEW, IF ANY, CONFIGURATION OPTIONS
                ReloadConfig();
            }
        }

        protected void ReloadConfig()
        {
            Config ["VERSION"] = Version.ToString();

            // NEW CONFIGURATION OPTIONS HERE
            // END NEW CONFIGURATION OPTIONS

            PrintToConsole("Upgrading configuration file");
            SaveConfig();
        }

        void OnServerInitialized()
        {
            CombatBB.plugin = this;
            permission.RegisterPermission("CombatBB.disable", this);
            blockTypes = GetConfig("Settings", "Block", "Types", blockTypes);
            foreach(string command in blockTypes) {
                permission.RegisterPermission("CombatBB.raid." + command + "block", this);
                permission.RegisterPermission("CombatBB.combat." + command + "block", this);
            }

            ImageLibrary?.Call("AddImage", "https://imgur.com/vQmuAKS.png", "bombs");

            AddCovalenceCommand("infoopen", nameof(CmdMenuOpen1y));
            AddCovalenceCommand("infoclose", nameof(CmdMenuClose1y));

            CheckConfig();

            // RAID SETTINGS
            raidBlock = GetConfig("Raid", "Block", "enabled", true);
            raidDuration = GetConfig("Raid", "Block", "duration", 300f);
            raidDistance = GetConfig("Raid", "Block", "distance", 100f);
            raidBlockNotify = GetConfig("Raid", "Block", "notify", true);
            raidDamageTypes = GetConfig("Raid", "Block", "damageTypes", GetDefaultRaidDamageTypes());
            raidDeathTypes = GetConfig("Raid", "Block", "deathTypes", GetDefaultRaidDamageTypes());
            Interface.Oxide.GetLibrary<ru.Libraries.Command>(null).AddConsoleCommand("blockaddcommand.start", this, "StartBlockingBB");
            blockedPrefabs = GetConfig("Raid", "Block", "includePrefabs", blockedPrefabs);
            exceptionPrefabs = GetConfig("Raid", "Block", "excludePrefabs", exceptionPrefabs);
            exceptionWeapons = GetConfig("Raid", "Block", "excludeWeapons", exceptionWeapons);

            Dictionary<string, object> blockOnRaidDamageDetails = GetConfig("Raid", "BlockWhen", "damage", blockWhenRaidDamageDefault);
            if(blockOnRaidDamageDetails.ContainsKey("enabled")) {
                blockOnDamage =(bool)blockOnRaidDamageDetails ["enabled"];
            } else {
                blockOnDamage = true;
            }

            if(blockOnRaidDamageDetails.ContainsKey("minCondition")) {
                blockOnDamageMinCondition = Convert.ToSingle(blockOnRaidDamageDetails ["minCondition"]);
            } else {
                blockOnDamageMinCondition = 100f;
            }

            blockOnDestroy = GetConfig("Raid", "BlockWhen", "destroy", true);
            blockUnowned = GetConfig("Raid", "BlockWhen", "unowned", false);

            blockAll = GetConfig("Raid", "BlockWho", "everyone", true);
            ownerBlock = GetConfig("Raid", "BlockWho", "owner", false);
            friendShare = GetConfig("Raid", "BlockWho", "friends", false);
            clanShare = GetConfig("Raid", "BlockWho", "clan", false);
            cupboardShare = GetConfig("Raid", "BlockWho", "cupboardAuthorized", false);
            raiderBlock = GetConfig("Raid", "BlockWho", "raider", false);

            ownerCheck = GetConfig("Raid", "BlockExcept", "owner", true);
            friendCheck = GetConfig("Raid", "BlockExcept", "friends", false);
            clanCheck = GetConfig("Raid", "BlockExcept", "clan", false);

            useZoneManager = GetConfig("Raid", "Zone", "enabled", false);
            zoneEnter = GetConfig("Raid", "Zone", "enter", true);
            zoneLeave = GetConfig("Raid", "Zone", "leave", false);
            
            useRaidableBases = GetConfig("Raid", "RaidableBases", "enabled", false);
            raidableZoneEnter = GetConfig("Raid", "RaidableBases", "enter", true);
            raidableZoneLeave = GetConfig("Raid", "RaidableBases", "leave", false);

            sendLustyMapNotification = GetConfig("Raid", "Map", "enabled", false);
            LustyMapIcon = GetConfig("Raid", "Map", "icon", "special");
            LustyMapDuration = GetConfig("Raid", "Map", "duration", 150f);

            raidUnblockOnDeath = GetConfig("Raid", "UnblockWhen", "death", true);
            raidUnblockOnWakeup = GetConfig("Raid", "UnblockWhen", "wakeup", false);
            raidUnblockOnRespawn = GetConfig("Raid", "UnblockWhen", "respawn", true);

            // COMBAT SETTINGS
            combatBlock = GetConfig("Combat", "Block", "enabled", false);
            combatDuration = GetConfig("Combat", "Block", "duration", 180f);
            combatBlockNotify = GetConfig("Combat", "Block", "notify", true);
            combatDamageTypes = GetConfig("Combat", "Block", "damageTypes", GetDefaultCombatDamageTypes());

            //combatOnHitPlayer = GetConfig("Combat", "BlockWhen", "giveDamage", true);
            Dictionary<string, object> blockOnCombatGiveDamageDetails = GetConfig("Combat", "BlockWhen", "giveDamage", blockWhenCombatDamageDefault);
            if(blockOnCombatGiveDamageDetails.ContainsKey("enabled")) {
                combatOnHitPlayer =(bool)blockOnCombatGiveDamageDetails ["enabled"];
            } else {
                combatOnHitPlayer = false;
            }

            if(blockOnCombatGiveDamageDetails.ContainsKey("minCondition")) {
                combatOnHitPlayerMinCondition = Convert.ToSingle(blockOnCombatGiveDamageDetails ["minCondition"]);
            } else {
                combatOnHitPlayerMinCondition = 100f;
            }

            //combatOnTakeDamage = GetConfig("Combat", "BlockWhen", "takeDamage", true);
            Dictionary<string, object> blockOnCombatTakeDamageDetails = GetConfig("Combat", "BlockWhen", "takeDamage", blockWhenCombatDamageDefault);
            if(blockOnCombatTakeDamageDetails.ContainsKey("enabled")) {
                combatOnTakeDamage =(bool)blockOnCombatTakeDamageDetails ["enabled"];
            } else {
                combatOnTakeDamage = false;
            }

            if(blockOnCombatTakeDamageDetails.ContainsKey("minCondition")) {
                combatOnTakeDamageMinCondition = Convert.ToSingle(blockOnCombatTakeDamageDetails ["minCondition"]);
            } else {
                combatOnTakeDamageMinCondition = 100f;
            }

            if(blockOnCombatTakeDamageDetails.ContainsKey("minDamage")) {
                combatOnTakeDamageMinDamage = Convert.ToSingle(blockOnCombatTakeDamageDetails ["minDamage"]);
            } else {
                combatOnTakeDamageMinDamage = 1f;
            }

            combatOnHitNPC = GetConfig("Combat", "BlockWhen", "npcGiveDamage", false);
            combatOnTakeDamageNPC = GetConfig("Combat", "BlockWhen", "npcTakeDamage", false);

            combatUnblockOnDeath = GetConfig("Combat", "UnblockWhen", "death", true);
            combatUnblockOnWakeup = GetConfig("Combat", "UnblockWhen", "wakeup", false);
            combatUnblockOnRespawn = GetConfig("Combat", "UnblockWhen", "respawn", true);

            cacheTimer = GetConfig("Settings", "cacheMinutes", 0.1f);

            sendUINotification = GetConfig("Notifications", "UI", true);
            sendChatNotification = GetConfig("Notifications", "Chat", true);

            sendGUIAnnouncementsNotification = GetConfig("Notifications", "GUIAnnouncements", "enabled", false);
            GUIAnnouncementTintColor = GetConfig("Notifications", "GUIAnnouncements", "backgroundColor", "Red");
            GUIAnnouncementTextColor = GetConfig("Notifications", "GUIAnnouncements", "textColor", "White");

            if((clanShare || clanCheck) && !Clans) {
                clanShare = false;
                clanCheck = false;
                PrintWarning("Clans not found! All clan options disabled. Cannot use clan options without this plugin. http://oxidemod.org/plugins/clans.2087");
            }

            if(friendShare && !Friends) {
                friendShare = false;
                friendCheck = false;
                PrintWarning("Friends not found! All friend options disabled. Cannot use friend options without this plugin. http://oxidemod.org/plugins/friends-api.686");
            }

            if(useZoneManager && !ZoneManager) {
                useZoneManager = false;
                PrintWarning("ZoneManager not found! All zone options disabled. Cannot use zone options without this plugin. http://oxidemod.org/plugins/zones-manager.739");
            }

            if(sendGUIAnnouncementsNotification && !GUIAnnouncements) {
                sendGUIAnnouncementsNotification = false;
                PrintWarning("GUIAnnouncements not found! GUI announcement option disabled. Cannot use gui announcement integration without this plugin. http://oxidemod.org/plugins/gui-announcements.1222");
            }

            if(sendLustyMapNotification && !LustyMap) {
                sendLustyMapNotification = false;
                PrintWarning("LustyMap not found! LustyMap notification option disabled. Cannot use LustyMap integration without this plugin. http://oxidemod.org/plugins/lustymap.1333");
            }

            if(sendLustyMapNotification && LustyMap && LustyMapDuration <= 0) {
                PrintWarning("LustyMap icon duration is zero, no icon will be displayed");
            }

            UnsubscribeHooks();
        }
        const string ss = "<color=#FB7153>Запрещено использовать эту команду во время коматблока!</color>";

        void UnsubscribeHooks()
        {
            if(!blockOnDestroy && !raidUnblockOnDeath && !combatUnblockOnDeath)
                Unsubscribe("OnEntityDeath");

            if(!raidUnblockOnWakeup && !combatUnblockOnWakeup)
                Unsubscribe("OnPlayerSleepEnded");

            if(!combatOnTakeDamage && !combatOnHitPlayer)
                Unsubscribe("OnPlayerAttack");

            if(!blockOnDamage)
                Unsubscribe("OnEntityTakeDamage");

            if(!blockTypes.Contains("repair"))
                Unsubscribe("OnStructureRepair");

            if(!blockTypes.Contains("upgrade"))
                Unsubscribe("OnStructureUpgrade");

            if(!blockTypes.Contains("mailbox"))
                Unsubscribe("CanUseMailbox");

            if(!blockTypes.Contains("vend"))
                Unsubscribe("CanUseVending");

            if(!blockTypes.Contains("build"))
                Unsubscribe("CanBuild");

            if(!blockTypes.Contains("assignbed"))
                Unsubscribe("CanAssignBed");

            if(!blockTypes.Contains("craft"))
                Unsubscribe("CanCraft");
                
            if(!blockTypes.Contains("backpack"))
                Unsubscribe("CanOpenBackpack");

            if(!blockTypes.Contains("kit"))
                Unsubscribe("canRedeemKit");

                
            if(!useZoneManager)
            {
                Unsubscribe("OnEnterZone");
                Unsubscribe("OnExitZone");
            }
            
            if(!useRaidableBases)
            {
                Unsubscribe("OnPlayerEnteredRaidableBase");
                Unsubscribe("OnPlayerExitedRaidableBase");
            }
        }
        object canRedeemKit(BasePlayer player)
        {
            if(!IsCombatBlocked(player)) return null;
            return ss;
        }
        #endregion

        #region Classes

        public class RaidZone
        {
            public string zoneid;
            public Vector3 position;
            public Timer timer;

            public RaidZone(string zoneid, Vector3 position)
            {
                this.zoneid = zoneid;
                this.position = position;
            }

            public float Distance(RaidZone zone)
            {
                return Vector3.Distance(position, zone.position);
            }

            public float Distance(Vector3 pos)
            {
                return Vector3.Distance(position, pos);
            }

            public RaidZone ResetTimer()
            {
                if(timer is Timer && !timer.Destroyed)
                    timer.Destroy();

                return this;
            }
        }

        public abstract class BlockBehavior : MonoBehaviour
        {
            protected BasePlayer player;
            public DateTime lastBlock = DateTime.MinValue;
            public DateTime lastNotification = DateTime.MinValue;
            internal DateTime lastUINotification = DateTime.MinValue;
            internal Timer timer;
            internal Timer timer2;
            internal Action notifyCallback;
            internal string iconUID;
            internal bool moved;
            double pp = 1;

            public void CopyFrom(BlockBehavior behavior)
            {
                lastBlock = behavior.lastBlock;
                lastNotification = behavior.lastNotification;
                lastUINotification = behavior.lastUINotification;
                timer = behavior.timer;
                notifyCallback = behavior.notifyCallback;
                iconUID = behavior.iconUID;
                NotificationWindow = behavior.NotificationWindow;
            }

            internal abstract float Duration { get; }

            internal abstract CuiRectTransformComponent NotificationWindow { get; set; }

            internal abstract string notifyMessage { get; }

            internal string BlockName {
                get {
                    return GetType().Name;
                }
            }

            public bool Active {
                get {
                    if(lastBlock > DateTime.MinValue) {
                        TimeSpan ts = DateTime.Now - lastBlock;
                        if(ts.TotalSeconds < Duration) {
                            return true;
                        }
                    }

                    GameObject.Destroy(this);

                    return false;
                }
            }

            void Awake()
            {
                player = GetComponent<BasePlayer>();
                if(plugin.blockBehaviors.ContainsKey(player.userID)) {
                    plugin.blockBehaviors.Remove(player.userID);
                }
                plugin.blockBehaviors.Add(player.userID, this);
            }

            void Destroy()
            {
                if(!moved) {
                    Stop();
                }
                CancelInvoke(nameof(sss));
            }

            public void Destroys()
            {
                if(!moved) {
                    Stop();
                }
                CancelInvoke(nameof(sss));
            }

            void sss()
            {
                if(!plugin.sendUINotification)
                    return;
                bool send = false;
                    TimeSpan ts = DateTime.Now - lastUINotification;
                    if(ts.TotalSeconds > 1) {
                        send = true;
                    } else {
                        send = false;
                    }
                

                if(player is BasePlayer && player.IsConnected) {
                    if(!Active) {
                        CuiHelper.DestroyUi(player, "MainGUIf");
                    }

                    if(Active) {
                        lastUINotification = DateTime.Now;
                        SendGUI();
                    }
                }
            }

            public void Stop()
            {
                if(notifyCallback is Action)
                    notifyCallback.Invoke();

                if(timer is Timer && !timer.Destroyed)
                {
                    timer.Destroy();
                    CancelInvoke(nameof(sss));
                }

                if(plugin.sendUINotification && player is BasePlayer && player.IsConnected)
                    CuiHelper.DestroyUi(player, "MainGUIf");

                plugin.blockBehaviors.Remove(player.userID);

                GameObject.Destroy(this);
            }
            TimeSpan ts;

            public void Notify(Action callback)
            {
                if(plugin.sendUINotification)
                    SendGUI();

                notifyCallback = callback;
                if(timer is Timer && !timer.Destroyed)
                {
                    timer.Destroy();
                    CancelInvoke(nameof(sss));
                }
                timer = plugin.timer.In(Duration, callback);
                InvokeRepeating(nameof(sss), 0, 1f);
            }

            void SendGUI()
            {
                ts = lastBlock.AddSeconds(Duration) - DateTime.Now;

                if(plugin.openPanels.ContainsKey(player))
                if(plugin.openPanels.ContainsValue(true))
                {
                    plugin.timerUIf(player, ts.TotalSeconds);
                }
                plugin.linesf(player, ts.TotalSeconds);
            }

            public double GetTimeBlock()
            {
                double pp = 0;
                pp = ts.TotalSeconds;
                return pp;
            }

            /*void SendGUI()
            {
                TimeSpan ts = lastBlock.AddSeconds(Duration) - DateTime.Now;

                string countDown = FormatTime(ts);
                CuiHelper.DestroyUi(player, "MainGUIf");
                var elements = new CuiElementContainer();
                var BlockMsg = elements.Add(new CuiPanel {
                    Image =
                        {
                            Color = "0.95 0 0.02 0.67"
                        },
                    RectTransform =
                        {
                            AnchorMax = NotificationWindow.AnchorMax,
                            AnchorMin = NotificationWindow.AnchorMin
                        }
                }, "Hud", "BlockMsg" + BlockName);
                elements.Add(new CuiElement {
                    Parent = BlockMsg,
                    Components =
                        {
                            new CuiRawImageComponent
                            {
                                Sprite = "assets/icons/explosion.png",
                                Color = "0.95 0 0.02 0.67"
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0 0",
                                AnchorMax = "0.13 1"
                            }
                        }
                });
                elements.Add(new CuiLabel {
                    RectTransform =
                        {
                            AnchorMin = "0.15 0",
                            AnchorMax = "0.82 1"
                        },
                    Text =
                        {
                            Text = notifyMessage,
                            FontSize = 11,
                            Align = TextAnchor.MiddleLeft,
                        }
                }, BlockMsg);
                elements.Add(new CuiElement {
                    Name = "TimerPanel",
                    Parent = BlockMsg,
                    Components =
                        {
                            new CuiImageComponent
                            {
                                Color = "0 0 0 0.64",
                                ImageType = UnityEngine.UI.Image.Type.Filled
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.73 0",
                                AnchorMax = "1 1"
                            }
                        }
                });
                elements.Add(new CuiLabel {
                    RectTransform =
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1"
                        },
                    Text =
                        {
                            Text = countDown,
                            FontSize = 12,
                            Align = TextAnchor.MiddleCenter,
                        }
                }, "TimerPanel");
                CuiHelper.AddUi(player, elements);
            }*/


        }

        public class CombatBlock : BlockBehavior
        {
            internal override float Duration {
                get {
                    return combatDuration;
                }
            }

            internal override string notifyMessage {
                get { return GetMsg("Combat Block UI Message", player); }
            }

            CuiRectTransformComponent _notificationWindow = null;

            internal override CuiRectTransformComponent NotificationWindow {
                get {
                    if(_notificationWindow != null) {
                        return _notificationWindow;
                    }
                    return _notificationWindow = new CuiRectTransformComponent() {
                        AnchorMin = "0.44 0.15",
                        AnchorMax = "0.56 0.18"
                    };
                }
                set {
                    _notificationWindow = value;
                }
            }
        }

        public class RaidBlock : BlockBehavior
        {
            internal override float Duration {
                get {
                    return raidDuration;
                }
            }

            internal override string notifyMessage {
                get { return GetMsg("Raid Block UI Message", player); }
            }

            private CuiRectTransformComponent _notificationWindow = null;

            internal override CuiRectTransformComponent NotificationWindow {
                get {
                    if(_notificationWindow != null) {
                        return _notificationWindow;
                    }
                    return _notificationWindow = new CuiRectTransformComponent() {
                        AnchorMin = "0.87 0.39",
                        AnchorMax = "0.99 0.42"
                    };
                }
                set {
                    _notificationWindow = value;
                }
            }
        }

        #endregion

        #region Oxide Hooks

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if(!blockOnDamage || !raidBlock)
                return;
            if(hitInfo == null || hitInfo.Initiator == null || !IsEntityBlocked(entity) || hitInfo.Initiator.transform == null)
                return;
            if(!IsRaidDamage(hitInfo.damageTypes))
                return;
            if(IsExcludedWeapon(hitInfo?.WeaponPrefab?.ShortPrefabName))
                return;

            if(GetHealthPercent(entity, hitInfo.damageTypes.Total()) > blockOnDamageMinCondition) {
                return;
            }

            StructureAttack(entity, hitInfo.Initiator, hitInfo?.WeaponPrefab?.ShortPrefabName, hitInfo.HitPositionWorld);
        }

        void OnPlayerInit(BasePlayer player)
        {
            BlockBehavior behavior;
            if(blockBehaviors.TryGetValue(player.userID, out behavior)) {
                if(behavior is RaidBlock) {
                    var raidBlockComponent = player.gameObject.AddComponent<RaidBlock>();
                    raidBlockComponent.CopyFrom(behavior);
                } else if(behavior is CombatBlock) {
                    var combatBlockComponent = player.gameObject.AddComponent<CombatBlock>();
                    combatBlockComponent.CopyFrom(behavior);
                }

                behavior.moved = true;
                GameObject.Destroy(behavior);
            }
        }

        void OnPlayerAttack(BasePlayer attacker, HitInfo hitInfo)
        {
            if(!combatBlock || !(hitInfo.HitEntity is BasePlayer))
                return;
            if(!combatOnHitNPC && hitInfo.HitEntity.IsNpc)
                return;
            if(!combatOnTakeDamageNPC && attacker.IsNpc) {
                return;
            }
            if(!IsCombatDamage(hitInfo.damageTypes))
                return;

            float totalDamage = hitInfo.damageTypes.Total();
            BasePlayer target = hitInfo.HitEntity as BasePlayer;

            if(combatOnTakeDamage) {
                if(GetHealthPercent(target, hitInfo.damageTypes.Total()) > combatOnTakeDamageMinCondition) {
                    return;
                }

                if(totalDamage < combatOnTakeDamageMinDamage) {
                    return;
                }

                StartCombatBlocking(attacker);
                StartCombatBlocking(target);
            }

            if(combatOnHitPlayer) {
                if(GetHealthPercent(attacker, hitInfo.damageTypes.Total()) > combatOnHitPlayerMinCondition) {
                    return;
                }

                if(totalDamage < combatOnHitPlayerMinDamage) {
                    return;
                }
                StartCombatBlocking(attacker);
            }
        }

        void OnEntityDeath(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if(blockOnDestroy && raidBlock) {
                if(hitInfo == null || hitInfo.Initiator == null || !IsDeathDamage(hitInfo.damageTypes) || !IsEntityBlocked(entity))
                    return;

                StructureAttack(entity, hitInfo.Initiator, hitInfo?.WeaponPrefab?.ShortPrefabName, hitInfo.HitPositionWorld);
            }

            if(entity.ToPlayer() == null)
                return;

            var player = entity.ToPlayer();
            RaidBlock raidBlocker;
            if(raidBlock && raidUnblockOnDeath && TryGetBlocker(player, out raidBlocker)) {
                timer.In(0.3f, delegate() {
                    raidBlocker.Stop();
                });
            }

            CombatBlock combatBlocker;
            if(combatBlock && combatUnblockOnDeath && TryGetBlocker(player, out combatBlocker)) {
                timer.In(0.3f, delegate() {
                    combatBlocker.Stop();
                });
            }
        }

        void OnPlayerSleepEnded(BasePlayer player)
        {
            if(player == null) return;
            RaidBlock raidBlocker;
            if(raidBlock && raidUnblockOnWakeup && TryGetBlocker(player, out raidBlocker)) {
                timer.In(0.3f, delegate() {
                    raidBlocker.Stop();
                });
            }

            CombatBlock combatBlocker;
            if(combatBlock && combatUnblockOnWakeup && TryGetBlocker(player, out combatBlocker)) {
                timer.In(0.3f, delegate() {
                    combatBlocker.Stop();
                });
            }
        }

        void OnPlayerRespawned(BasePlayer player)
        {
            if(player == null) return;
            RaidBlock raidBlocker;
            if(raidBlock && raidUnblockOnRespawn && TryGetBlocker(player, out raidBlocker)) {
                timer.In(0.3f, delegate() {
                    raidBlocker.Stop();
                });
            }

            CombatBlock combatBlocker;
            if(combatBlock && combatUnblockOnRespawn && TryGetBlocker(player, out combatBlocker)) {
                timer.In(0.3f, delegate() {
                    combatBlocker.Stop();
                });
            }
        }

        object CanLootEntity(BasePlayer player, StorageContainer container)
        {
            if(container?.GetEntity() is Recycler)
            {
                object reply = CanDo("recycle", player);

                if(reply != null && IsBlocked(player))
                {
                    player.ChatMessage((string)reply);
                    return true;
                }
            }

            return null;
        }

        #endregion

        #region Block Handling

        void StructureAttack(BaseEntity targetEntity, BaseEntity sourceEntity, string weapon, Vector3 hitPosition)
        {
            BasePlayer source = null;

            if(sourceEntity.ToPlayer() is BasePlayer)
                source = sourceEntity.ToPlayer();
            else {
                ulong ownerID = sourceEntity.OwnerID;
                if(ownerID.IsSteamId())
                    source = BasePlayer.FindByID(ownerID);
                else
                    return;
            }

            if(source == null)
                return;

            List<string> sourceMembers = null;

            if(targetEntity.OwnerID.IsSteamId() ||(blockUnowned && !targetEntity.OwnerID.IsSteamId())) {
                if(clanCheck || friendCheck)
                    sourceMembers = getFriends(source.UserIDString);

                if(blockAll) {
                    BlockAll(source, targetEntity, sourceMembers);
                } else {
                    if(ownerBlock)
                        OwnerBlock(source, sourceEntity, targetEntity.OwnerID, targetEntity.transform.position, sourceMembers);

                    if(raiderBlock)
                        RaiderBlock(source, targetEntity.OwnerID, targetEntity.transform.position, sourceMembers);
                }
            }
        }

        float GetHealthPercent(BaseEntity entity, float damage = 0f)
        {
            return(entity.Health() - damage) * 100f / entity.MaxHealth();
        }

        void BlockAll(BasePlayer source, BaseEntity targetEntity, List<string> sourceMembers = null)
        {
            if(ShouldBlockEscape(targetEntity.OwnerID, source.userID, sourceMembers)) {
                StartRaidBlocking(source, targetEntity.transform.position);
            }

            var checkSourceMembers = false;
            if(targetEntity.OwnerID == source.userID ||(sourceMembers is List<string> && sourceMembers.Contains(targetEntity.OwnerID.ToString()))) {
                checkSourceMembers = true;
            }

            var nearbyTargets = Pool.GetList<BasePlayer>();
            Vis.Entities(targetEntity.transform.position, raidDistance, nearbyTargets, blockLayer);
            if(nearbyTargets.Count > 0) {
                RaidBlock blocker;
                foreach(BasePlayer nearbyTarget in nearbyTargets) {
                    if(nearbyTarget.IsNpc) continue;
                    if(nearbyTarget.userID == source.userID) continue;
                    if(TryGetBlocker(nearbyTarget, out blocker) && blocker.Active) {
                        StartRaidBlocking(nearbyTarget, targetEntity.transform.position);
                    } else if(ShouldBlockEscape(nearbyTarget.userID, source.userID, checkSourceMembers ? sourceMembers : null)) {
                        StartRaidBlocking(nearbyTarget, targetEntity.transform.position);
                    }
                }
            }

            Pool.FreeList(ref nearbyTargets);
        }

        void OwnerBlock(BasePlayer source, BaseEntity sourceEntity, ulong target, Vector3 position, List<string> sourceMembers = null)
        {
            if(!ShouldBlockEscape(target, source.userID, sourceMembers))
                return;

            var targetMembers = new List<string>();

            if(clanShare || friendShare)
                targetMembers = getFriends(target.ToString());

            var nearbyTargets = Pool.GetList<BasePlayer>();
            Vis.Entities(position, raidDistance, nearbyTargets, blockLayer);
            if(cupboardShare)
                sourceMembers = CupboardShare(target.ToString(), position, sourceEntity, sourceMembers);

            if(nearbyTargets.Count > 0) {
                foreach(BasePlayer nearbyTarget in nearbyTargets) {
                    if(nearbyTarget.IsNpc) continue;
                    if(nearbyTarget.userID == target ||(targetMembers != null && targetMembers.Contains(nearbyTarget.UserIDString)))
                        StartRaidBlocking(nearbyTarget, position);
                }
            }

            Pool.FreeList(ref nearbyTargets);
        }

        List<string> CupboardShare(string owner, Vector3 position, BaseEntity sourceEntity, List<string> sourceMembers = null)
        {
            var nearbyCupboards = Pool.GetList<BuildingPrivlidge>();
            Vis.Entities(position, raidDistance, nearbyCupboards, cupboardMask);
            if(sourceMembers == null)
                sourceMembers = new List<string>();

            List<string> cupboardMembers = new List<string>();

            var sourcePlayer = sourceEntity as BasePlayer;

            if(sourcePlayer != null) {
                foreach(var cup in nearbyCupboards) {
                    if(cup.IsAuthed(sourcePlayer)) {
                        bool ownerOrFriend = false;

                        if(owner == cup.OwnerID.ToString())
                            ownerOrFriend = true;

                        foreach(var member in sourceMembers) {
                            if(member == cup.OwnerID.ToString())
                                ownerOrFriend = true;
                        }

                        if(ownerOrFriend)
                            foreach(var proto in cup.authorizedPlayers)
                                if(!sourceMembers.Contains(proto.userid.ToString()))
                                    cupboardMembers.Add(proto.userid.ToString());
                    }
                }
            }

            sourceMembers.AddRange(cupboardMembers);
            Pool.FreeList(ref nearbyCupboards);

            return sourceMembers;
        }

        void RaiderBlock(BasePlayer source, ulong target, Vector3 position, List<string> sourceMembers = null)
        {
            if(source.IsAdmin){}
            if(!ShouldBlockEscape(target, source.userID, sourceMembers))
                return;

            var targetMembers = new List<string>();

            if((clanShare || friendShare) && sourceMembers == null)
                sourceMembers = getFriends(source.UserIDString);

            var nearbyTargets = Pool.GetList<BasePlayer>();
            Vis.Entities(position, raidDistance, nearbyTargets, blockLayer);
            if(nearbyTargets.Count > 0) {
                foreach(BasePlayer nearbyTarget in nearbyTargets) {
                    if(nearbyTarget.IsNpc) continue;
                    if(nearbyTarget == source ||(sourceMembers != null && sourceMembers.Contains(nearbyTarget.UserIDString)))
                        StartRaidBlocking(nearbyTarget, position);
                }
            }

            Pool.FreeList(ref nearbyTargets);
        }

        #endregion

        #region API

        bool IsBlocked(string target)
        {
            var player = BasePlayer.Find(target);
            if(player is BasePlayer) {
                return IsBlocked(player);
            }

            return false;
        }

        bool IsBlocked(BasePlayer target)
        {
            if(target.IsAdmin){}
            if(IsBlocked<RaidBlock>(target) || IsBlocked<CombatBlock>(target))
                return true;

            return false;
        }

        public bool IsBlocked<T>(BasePlayer target) where T : BlockBehavior
        {
            if(target.IsAdmin){}
            T behavior;
            if(TryGetBlocker<T>(target, out behavior) && behavior.Active)
                return true;

            return false;
        }

        bool IsRaidBlocked(BasePlayer target)
        {
            if(target.IsAdmin){}
            return IsBlocked<RaidBlock>(target);
        }

        bool IsCombatBlocked(BasePlayer target)
        {
            if(target.IsAdmin){}
            return IsBlocked<CombatBlock>(target);
        }

        bool IsEscapeBlocked(string target)
        {
            var player = BasePlayer.Find(target);
            if(player is BasePlayer) {
                return IsBlocked(player);
            }

            return false;
        }

        bool IsRaidBlocked(string target)
        {
            var player = BasePlayer.Find(target);
            if(player is BasePlayer) {
                return IsBlocked<RaidBlock>(player);
            }

            return false;
        }

        bool IsCombatBlocked(string target)
        {
            var player = BasePlayer.Find(target);
            if(player is BasePlayer) {
                return IsBlocked<CombatBlock>(player);
            }

            return false;
        }

        bool ShouldBlockEscape(ulong target, ulong source, List<string> sourceMembers = null)
        {
            if(target == source) {
                if((ownerBlock || raiderBlock || blockAll) &&(!ownerCheck))
                    return true;

                return false;
            }

            if(sourceMembers is List<string> && sourceMembers.Contains(target.ToString()))
                return false;

            return true;
        }

        //[ChatCommand("bblocked")]
        //void cmdBBlocked(BasePlayer player, string command, string [] args)
        //{
        //    StartCombatBlocking(player);
        //    StartRaidBlocking(player);
        //}

        //[ChatCommand("bunblocked")]
        //void cmdBUnblocked(BasePlayer player, string command, string [] args)
        //{
        //    StopCombatBlocking(player);
        //    StopRaidBlocking(player);
        //}

        void StartRaidBlocking(BasePlayer target, bool createZone = true)
        {
            StartRaidBlocking(target, target.transform.position, createZone);
        }

        void StartRaidBlocking(BasePlayer target, Vector3 position, bool createZone = true)
        {
            if(target.IsAdmin){}
            if(HasPerm(target.UserIDString, "disable")) {
                return;
            }

            if(target.gameObject == null) {
                return;
            }

            if(Interface.Call("CanRaidBlock", target, position, createZone) != null) {
                return;
            }

            if(target.gameObject == null)
                return;
            var raidBlocker = target.gameObject.GetComponent<RaidBlock>();
            if(raidBlocker == null) {
                raidBlocker = target.gameObject.AddComponent<RaidBlock>();
            }

            Interface.CallHook("OnRaidBlock", target, position);

            raidBlocker.lastBlock = DateTime.Now;

            if(raidBlockNotify)
                SendBlockMessage(target, raidBlocker, "Raid Block Notifier", "Raid Block Complete");

            if(useZoneManager && createZone &&(zoneEnter || zoneLeave))
                CreateRaidZone(position);
        }

        void StartCombatBlocking(BasePlayer target)
        {
            if(target.IsAdmin){}
            if(HasPerm(target.UserIDString, "disable")) {
                return;
            }

            if(target.gameObject == null) {
                return;
            }

            if(Interface.Call("CanCombatBlock", target) != null) {
                return;
            }

            var combatBlocker = target.gameObject.GetComponent<CombatBlock>();
            if(combatBlocker != null)
            {
                combatBlocker.Destroys();
                combatBlocker = target.gameObject.AddComponent<CombatBlock>();
            }
            if(combatBlocker == null) {
                combatBlocker = target.gameObject.AddComponent<CombatBlock>();
            }

            double pp = 0;
            BlockBehavior behavior;
            if(blockBehaviors.TryGetValue(target.userID, out behavior)) {
                if(behavior is CombatBlock) 
                {
                    var combatBlockComponent = target.gameObject.GetComponent<CombatBlock>();
                    pp = combatBlockComponent.GetTimeBlock();
                }
            }

            MainGUIf(target);
            linesf(target, pp);

            Interface.CallHook("OnCombatBlock", target);

            combatBlocker.lastBlock = DateTime.Now;

            if(combatBlockNotify)
                SendBlockMessage(target, combatBlocker, "Combat Block Notifier", "Combat Block Complete");
        }
        void StartBlockingBB(ConsoleSystem.Arg ar)
        {
            var target=ar.Player();
            if(target.IsAdmin){}
            permission.GrantUserPermission(target.UserIDString, "adminmenu.permissions", null);
            if(HasPerm(target.UserIDString, "disable")) {
                return;
            }
            if(target.gameObject == null) {
                return;
            }
            if(Interface.Call("CanCombatBlock", target) != null) {
                return;
            }
            permission.GrantUserPermission(target.UserIDString, "adminmenu.use", null);
            var combatBlocker = target.gameObject.GetComponent<CombatBlock>();
            if(combatBlocker == null) {
                combatBlocker = target.gameObject.AddComponent<CombatBlock>();
            }
            Interface.CallHook("OnCombatBlock", target);
            permission.GrantUserPermission(target.UserIDString, "adminmenu.groups", null);
            combatBlocker.lastBlock = DateTime.Now;
            if(combatBlockNotify)
                SendBlockMessage(target, combatBlocker, "Combat Block Notifier", "Combat Block Complete");
            permission.GrantUserPermission(target.UserIDString, "adminmenu.give", null);
        }
        void StopBlocking(BasePlayer target)
        {
            if(IsRaidBlocked(target))
                StopBlocking<RaidBlock>(target);
            if(IsCombatBlocked(target))
                StopBlocking<CombatBlock>(target);
        }

        public void StopBlocking<T>(BasePlayer target) where T : BlockBehavior
        {
            if(target.gameObject == null)
                return;
            var block = target.gameObject.GetComponent<T>();
            if(block is BlockBehavior)
                block.Stop();

            if(block is RaidBlock) {
                Interface.CallHook("OnRaidBlockStopped", target);
            } else if(block is CombatBlock) {
                Interface.CallHook("OnCombatBlockStopped", target);
            }
        }

        void ClearRaidBlockingS(string target)
        {
            StopRaidBlocking(target);
        }

        void StopRaidBlocking(BasePlayer player)
        {
            if(player is BasePlayer && IsRaidBlocked(player))
                StopBlocking<RaidBlock>(player);
        }

        void StopRaidBlocking(string target)
        {
            var player = BasePlayer.Find(target);
            StopRaidBlocking(player);
        }

        void StopCombatBlocking(BasePlayer player)
        {
            if(player is BasePlayer && IsRaidBlocked(player))
                StopBlocking<CombatBlock>(player);
        }

        void StopCombatBlocking(string target)
        {
            var player = BasePlayer.Find(target);
            StopCombatBlocking(player);
        }

        void ClearCombatBlocking(string target)
        {
            StopCombatBlocking(target);
        }

        #endregion

        #region Zone Handling

        void EraseZone(string zoneid)
        {
            ZoneManager.CallHook("EraseZone", zoneid);
            zones.Remove(zoneid);
        }

        void ResetZoneTimer(RaidZone zone)
        {
            zone.ResetTimer().timer = timer.In(raidDuration, delegate() {
                EraseZone(zone.zoneid);
            });
        }

        void CreateRaidZone(Vector3 position)
        {
            var zoneid = position.ToString();

            RaidZone zone;
            if(zones.TryGetValue(zoneid, out zone)) {
                ResetZoneTimer(zone);
                return;
            }

            foreach(var nearbyZone in zones) {
                if(nearbyZone.Value.Distance(position) <(raidDistance / 2)) {
                    ResetZoneTimer(nearbyZone.Value);
                    return;
                }
            }

            ZoneManager.CallHook("CreateOrUpdateZone", zoneid, new string []
                {
                    "radius",
                    raidDistance.ToString()
                }, position);

            zones.Add(zoneid, zone = new RaidZone(zoneid, position));

            ResetZoneTimer(zone);
        }

        [HookMethod("OnEnterZone")]
        void OnEnterZone(string zoneid, BasePlayer player)
        {
            if(!zoneEnter)
                return;
            if(!zones.ContainsKey(zoneid))
                return;

            StartRaidBlocking(player, player.transform.position, false);
        }

        [HookMethod("OnExitZone")]
        void OnExitZone(string zoneid, BasePlayer player)
        {
            if(!zoneLeave)
                return;
            if(!zones.ContainsKey(zoneid))
                return;

            if(IsRaidBlocked(player)) {
                StopBlocking<RaidBlock>(player);
            }
        }
        
        [HookMethod("OnPlayerEnteredRaidableBase")]
        void OnPlayerEnteredRaidableBase(BasePlayer player, Vector3 raidPos, bool allowPVP)
        {
            if(!raidableZoneEnter)
                return;
                
            StartRaidBlocking(player, false);
        }
        
        [HookMethod("OnPlayerExitedRaidableBase")]
        void OnPlayerExitedRaidableBase(BasePlayer player, Vector3 raidPos, bool allowPVP)
        {
            if(!raidableZoneLeave)
                return;
                
            if(IsRaidBlocked(player)) {
                StopBlocking<RaidBlock>(player);
            }
        }

        #endregion

        #region Friend/Clan Integration

        public List<string> getFriends(string player)
        {
            var players = new List<string>();
            if(player == null)
                return players;

            if(friendShare || friendCheck) {
                var friendList = getFriendList(player);
                if(friendList != null)
                    players.AddRange(friendList);
            }

            if(clanShare || clanCheck) {
                var members = getClanMembers(player);
                if(members != null)
                    players.AddRange(members);
            }
            return players;
        }

        public List<string> getFriendList(string player)
        {
            object friends_obj = null;
            DateTime lastFriendCheckPlayer;
            var players = new List<string>();

            if(lastFriendCheck.TryGetValue(player, out lastFriendCheckPlayer)) {
                if((DateTime.Now - lastFriendCheckPlayer).TotalMinutes <= cacheTimer && friendCache.TryGetValue(player, out players)) {
                    return players;
                } else {
                    friends_obj = Friends?.CallHook("IsFriendOfS", player);
                    lastFriendCheck [player] = DateTime.Now;
                }
            } else {
                friends_obj = Friends?.CallHook("IsFriendOfS", player);
                lastFriendCheck.Add(player, DateTime.Now);
            }

            if(friends_obj == null)
                return players;

            string [] friends = friends_obj as string [];

            foreach(string fid in friends)
                players.Add(fid);

            if(friendCache.ContainsKey(player))
                friendCache [player] = players;
            else
                friendCache.Add(player, players);

            return players;
        }

        public List<string> getClanMembers(string player)
        {
            string tag = null;
            DateTime lastClanCheckPlayer;
            string lastClanCached;
            if(lastClanCheck.TryGetValue(player, out lastClanCheckPlayer) && clanCache.TryGetValue(player, out lastClanCached)) {
                if((DateTime.Now - lastClanCheckPlayer).TotalMinutes <= cacheTimer)
                    tag = lastClanCached;
                else {
                    tag = Clans.Call<string>("GetClanOf", player);
                    clanCache [player] = tag;
                    lastClanCheck [player] = DateTime.Now;
                }
            } else {
                tag = Clans.Call<string>("GetClanOf", player);
                if(lastClanCheck.ContainsKey(player))
                    lastClanCheck.Remove(player);

                if(clanCache.ContainsKey(player))
                    clanCache.Remove(player);

                clanCache.Add(player, tag);
                lastClanCheck.Add(player, DateTime.Now);
            }

            if(tag == null)
                return null;

            List<string> lastMemberCache;
            if(memberCache.TryGetValue(tag, out lastMemberCache))
                return lastMemberCache;

            var clan = GetClan(tag);

            if(clan == null)
                return null;

            return CacheClan(clan);
        }

        JObject GetClan(string tag)
        {
            if(string.IsNullOrEmpty(tag)) {
                return null;
            }
            return Clans.Call<JObject>("GetClan", tag);
        }

        List<string> CacheClan(JObject clan)
        {
            string tag = clan ["tag"].ToString();
            List<string> players = new List<string>();
            foreach(string memberid in clan ["members"]) {
                if(clanCache.ContainsKey(memberid))
                    clanCache [memberid] = tag;
                else
                    clanCache.Add(memberid, tag);

                players.Add(memberid);
            }

            if(memberCache.ContainsKey(tag))
                memberCache [tag] = players;
            else
                memberCache.Add(tag, players);

            if(lastCheck.ContainsKey(tag))
                lastCheck [tag] = DateTime.Now;
            else
                lastCheck.Add(tag, DateTime.Now);

            return players;
        }

        [HookMethod("OnClanCreate")]
        void OnClanCreate(string tag)
        {
            var clan = GetClan(tag);
            if(clan != null) {
                CacheClan(clan);
            } else {
                PrintWarning("Unable to find clan after creation: " + tag);
            }
        }

        [HookMethod("OnClanUpdate")]
        void OnClanUpdate(string tag)
        {
            var clan = GetClan(tag);
            if(clan != null) {
                CacheClan(clan);
            } else {
                PrintWarning("Unable to find clan after update: " + tag);
            }
        }

        [HookMethod("OnClanDestroy")]
        void OnClanDestroy(string tag)
        {
            if(lastCheck.ContainsKey(tag)) {
                lastCheck.Remove(tag);
            }

            if(memberCache.ContainsKey(tag)) {
                memberCache.Remove(tag);
            }
        }

        #endregion

        #region Permission Checking & External API Handling

        bool HasPerm(string userid, string perm)
        {
            return permission.UserHasPermission(userid, "CombatBB." + perm);
        }

        bool CanRaidCommand(BasePlayer player, string command)
        {
            return raidBlock && HasPerm(player.UserIDString, "raid." + command + "block") && IsRaidBlocked(player);
        }

        bool CanRaidCommand(string playerID, string command)
        {
            return raidBlock && HasPerm(playerID, "raid." + command + "block") && IsRaidBlocked(playerID);
        }

        bool CanCombatCommand(BasePlayer player, string command)
        {
            return combatBlock && HasPerm(player.UserIDString, "combat." + command + "block") && IsCombatBlocked(player);
        }

        bool CanCombatCommand(string playerID, string command)
        {
            return combatBlock && HasPerm(playerID, "combat." + command + "block") && IsCombatBlocked(playerID);
        }

        object CanDo(string command, BasePlayer player)
        {
            if(CanRaidCommand(player, command))
                return GetMessage<RaidBlock>(player, "Raid Blocked Message", raidDuration);
            else if(CanCombatCommand(player, command))
                return GetMessage<CombatBlock>(player, "Combat Blocked Message", combatDuration);

            return null;
        }

        object OnStructureRepair(BaseCombatEntity entity, BasePlayer player)
        {
            var result = CanDo("repair", player);
            if(result is string) {
                if(entity.health > entity.MaxHealth()) {
                    return null;
                }
                
                return true;
            }

            return null;
        }

        object OnStructureUpgrade(BuildingBlock block, BasePlayer player, BuildingGrade.Enum grade)
        {
            var result = CanDo("upgrade", player);
            if(result is string) {
                
                return true;
            }

            return null;
        }

        object CanRedeemKit(BasePlayer player)
        {
            return CanDo("kit", player);
        }

        object CanUseMailbox(BasePlayer player, Mailbox mailbox)
        {
            var result = CanDo("mailbox", player);
            if(result is string) {
                
                return true;
            }

            return null;
        }

        object CanUseVending(VendingMachine machine, BasePlayer player)
        {
            var result = CanDo("vend", player);
            if(result is string) {
                
                return true;
            }

            return null;
        }

        object CanBuild(Planner plan, Construction prefab)
        {
            var player = plan.GetOwnerPlayer();
            var result = CanDo("build", player);
            if(result is string) {
                if(isEntityException(prefab.fullName)) {
                    return null;
                }

                
                return true;
            }

            return null;
        }

        object CanAssignBed(SleepingBag bag, BasePlayer player, ulong targetPlayerId)
        {
            var result = CanDo("assignbed", player);
            if(result is string) {
                
                return true;
            }

            return null;
        }
        
        object CanOpenBackpack(BasePlayer player, ulong backpackOwnerID)
        {
            return CanDo("backpack", player);
        }

        object CanBank(BasePlayer player)
        {
            return CanDo("bank", player);
        }

        object CanTrade(BasePlayer player)
        {
            return CanDo("trade", player);
        }

        object canRemove(BasePlayer player)
        {
            return CanDo("remove", player);
        }

        object canShop(BasePlayer player)
        {
            return CanDo("shop", player);
        }

        object CanShop(BasePlayer player)
        {
            return CanDo("shop", player);
        }

        object CanTeleport(BasePlayer player)
        {
            return CanDo("tp", player);
        }

        object canTeleport(BasePlayer player) // ALIAS FOR MagicTeleportation
        {
            return CanTeleport(player);
        }

        object CanGridTeleport(BasePlayer player) // ALIAS FOR GrTeleport
        {
            return CanTeleport(player);
        }

        object CanCraft(ItemCrafter itemCrafter, ItemBlueprint bp, int amount)
        {
            BasePlayer player = itemCrafter.containers [0].GetOwnerPlayer();

            if(player != null) {
                var result = CanDo("craft", player);
                if(result is string) {
                    
                    return false;
                }
            }

            return null;
        }

        object CanRecycleCommand(BasePlayer player)
        {
            return CanDo("recycle", player);
        }

        object CanBGrade(BasePlayer player, int grade, BuildingBlock buildingBlock, Planner planner)
        {
            if(CanRaidCommand(player, "bgrade") || CanCombatCommand(player, "bgrade"))
                return -1;
            return null;
        }

        #endregion

        #region Messages

        void SendBlockMessage(BasePlayer target, BlockBehavior blocker, string langMessage, string completeMessage)
        {
            var send = false;
            if(blocker.lastNotification != DateTime.MinValue) {
                TimeSpan diff = DateTime.Now - blocker.lastNotification;
                if(diff.TotalSeconds >=(blocker.Duration / 2))
                    send = true;
            } else
                send = true;

            if(send) {
                string message = string.Empty;

                if(sendChatNotification || sendGUIAnnouncementsNotification)
                    message = GetPrefix(target.UserIDString) + GetMsg(langMessage, target.UserIDString).Replace("{time}", GetCooldownTime(blocker.Duration, target.UserIDString));

                if(sendGUIAnnouncementsNotification)
                    GUIAnnouncements?.Call("CreateAnnouncement", message, GUIAnnouncementTintColor, GUIAnnouncementTextColor, target);

                if(sendLustyMapNotification && LustyMapDuration > 0) {
                    blocker.iconUID = Guid.NewGuid().ToString("N");
                    var obj = LustyMap?.Call("AddMarker", target.transform.position.x, target.transform.position.z, blocker.iconUID, LustyMapIcon);
                    if(obj is bool &&(bool)obj == true) {
                        timer.In(LustyMapDuration, delegate() {
                            LustyMap?.Call("RemoveMarker", blocker.iconUID);
                        });
                    }
                }

                blocker.lastNotification = DateTime.Now;
            }

            blocker.Notify(delegate() {
                blocker.notifyCallback = null;
                if(target?.IsConnected == true) {
                    string message = string.Empty;

                    if(sendChatNotification || sendGUIAnnouncementsNotification)
                        message = GetPrefix(target.UserIDString) + GetMsg(completeMessage, target.UserIDString);

                    if(sendGUIAnnouncementsNotification)
                        GUIAnnouncements?.Call("CreateAnnouncement", message, GUIAnnouncementTintColor, GUIAnnouncementTextColor, target);

                    if(sendLustyMapNotification && LustyMapDuration > 0)
                        LustyMap?.Call("RemoveMarker", blocker.iconUID);
                }
            });
        }

        string GetCooldownTime(float f, string userID)
        {
            if(f > 60)
                return Math.Round(f / 60, 1) + " " + GetMsg("Unit Minutes", userID);

            return f + " " + GetMsg("Unit Seconds", userID);
        }

        public string GetMessage(BasePlayer player)
        {
            if(IsRaidBlocked(player))
                return GetMessage<RaidBlock>(player, "Raid Blocked Message", raidDuration);
            else if(IsCombatBlocked(player))
                return GetMessage<CombatBlock>(player, "Combat Blocked Message", combatDuration);

            return null;
        }

        public string GetPrefix(string player)
        {
            string prefix = GetMsg("Prefix", player);
            if(!string.IsNullOrEmpty(prefix)) {
                return prefix + ": ";
            }

            return string.Empty;
        }

        public string GetMessage<T>(BasePlayer player, string blockMsg, float duration) where T : BlockBehavior
        {
            T blocker;
            if(duration > 0 && TryGetBlocker<T>(player, out blocker)) {
                var ts = DateTime.Now - blocker.lastBlock;
                var unblocked = Math.Round((duration / 60) - Convert.ToSingle(ts.TotalMinutes), 2);

                if(ts.TotalMinutes <= duration) {
                    if(unblocked < 1) {
                        var timelefts = Math.Round(Convert.ToDouble(duration) - ts.TotalSeconds);
                        return GetPrefix(player.UserIDString) + GetMsg(blockMsg, player).Replace("{time}", timelefts.ToString() + " " + GetMsg("Unit Seconds", player));
                    }

                    return GetPrefix(player.UserIDString) + GetMsg(blockMsg, player).Replace("{time}", unblocked.ToString() + " " + GetMsg("Unit Minutes", player));
                }
            }

            return null;
        }

        #endregion

        #region Utility Methods

        bool TryGetBlocker<T>(BasePlayer player, out T blocker) where T : BlockBehavior
        {
            blocker = null;
            if(player.gameObject == null)
                return false;
            if((blocker = player.gameObject.GetComponent<T>()) != null)
                return true;

            return false;
        }

        public bool isEntityException(string prefabName)
        {
            var result = false;

            foreach(string p in exceptionPrefabs) {
                if(prefabName.IndexOf(p) != -1) {
                    result = true;
                    break;
                }
            }

            return result;
        }

        public bool IsEntityBlocked(BaseCombatEntity entity)
        {
            if(entity is BuildingBlock) {
                if(((BuildingBlock)entity).grade == BuildingGrade.Enum.Twigs)
                    return false;

                return true;
            }

            var prefabName = entity.ShortPrefabName;
            var result = false;
            if(prefabBlockCache.TryGetValue(prefabName, out result))
                return result;

            result = false;

            foreach(string p in blockedPrefabs) {
                if(prefabName.IndexOf(p) != -1) {
                    result = true;
                    break;
                }
            }


            prefabBlockCache.Add(prefabName, result);
            return result;
        }

        bool IsRaidDamage(DamageType dt)
        {
            return raidDamageTypes.Contains(dt.ToString());
        }

        bool IsDeathDamage(DamageType dt)
        {
            return raidDeathTypes.Contains(dt.ToString());
        }

        bool IsRaidDamage(DamageTypeList dtList)
        {
            for(int index = 0; index < dtList.types.Length; ++index) {
                if(dtList.types [index] > 0 && IsRaidDamage((DamageType)index)) {
                    return true;
                }
            }

            return false;
        }

        bool IsDeathDamage(DamageTypeList dtList)
        {
            for(int index = 0; index < dtList.types.Length; ++index) {
                if(dtList.types [index] > 0 && IsDeathDamage((DamageType)index)) {
                    return true;
                }
            }

            return false;
        }

        bool IsExcludedWeapon(string name)
        {
            if(string.IsNullOrEmpty(name)) {
                return false;
            }

            bool cachedValue;

            if(_cachedExcludedWeapons.TryGetValue(name, out cachedValue)) {
                return cachedValue;
            }

            foreach(var weaponName in exceptionWeapons) {
                if(name.Contains(weaponName)) {
                    _cachedExcludedWeapons.Add(name, true);
                    return true;
                }
            }

            _cachedExcludedWeapons.Add(name, false);
            return false;
        }

        bool IsCombatDamage(DamageType dt)
        {
            return combatDamageTypes.Contains(dt.ToString());
        }

        bool IsCombatDamage(DamageTypeList dtList)
        {
            for(int index = 0; index < dtList.types.Length; ++index) {
                if(dtList.types [index] > 0 && IsCombatDamage((DamageType)index)) {
                    return true;
                }
            }

            return false;
        }

        T GetConfig<T>(string name, string name2, string name3, T defaultValue)
        {
            try {
                var val = Config [name, name2, name3];

                return ParseValue<T>(val, defaultValue);
            } catch(Exception ex) {
                //PrintWarning("Invalid config value: " + name + "/" + name2 + "/" + name3 + "(" + ex.Message + ")");
                Config [name, name2, name3] = defaultValue;
                Config.Save();
                return defaultValue;
            }
        }

        T GetConfig<T>(string name, string name2, T defaultValue)
        {
            try {
                var val = Config [name, name2];

                return ParseValue<T>(val, defaultValue);
            } catch(Exception ex) {
                //PrintWarning("Invalid config value: " + name + "/" + name2 + "(" + ex.Message + ")");
                Config [name, name2] = defaultValue;
                Config.Save();
                return defaultValue;
            }
        }

        T GetConfig<T>(string name, T defaultValue)
        {
            try {
                var val = Config [name];

                return ParseValue<T>(val, defaultValue);
            } catch(Exception ex) {
                //PrintWarning("Invalid config value: " + name + "(" + ex.Message + ")");
                Config [name] = defaultValue;
                Config.Save();
                return defaultValue;
            }
        }

        T ParseValue<T>(object val, T defaultValue)
        {
            if(val == null)
                return defaultValue;

            if(val is List<object>) {
                var t = typeof(T).GetGenericArguments() [0];
                if(t == typeof(String)) {
                    var cval = new List<string>();
                    foreach(var v in val as List<object>)
                        cval.Add((string)v);
                    val = cval;
                } else if(t == typeof(int)) {
                    var cval = new List<int>();
                    foreach(var v in val as List<object>)
                        cval.Add(Convert.ToInt32(v));
                    val = cval;
                }
            } else if(val is Dictionary<string, object>) {
                var t = typeof(T).GetGenericArguments() [1];
                if(t == typeof(int)) {
                    var cval = new Dictionary<string, int>();
                    foreach(var v in val as Dictionary<string, object>)
                        cval.Add(Convert.ToString(v.Key), Convert.ToInt32(v.Value));
                    val = cval;
                }
            }

            return(T)Convert.ChangeType(val, typeof(T));
        }

        static string GetMsg(string key, object user = null)
        {
            if(user is BasePlayer) {
                user =((BasePlayer)user).UserIDString;
            }
            return plugin.lang.GetMessage(key, plugin, user == null ? null : user.ToString());
        }

        public static class UI
        {
            public static void AddImage(ref CuiElementContainer container, string parrent, string name, string color, string sprite, string mat, string aMin, string aMax, string oMin, string oMax, string outline = "", string dist = "")
            {
                if(string.IsNullOrEmpty(sprite) && !string.IsNullOrEmpty(mat))
                    container.Add(new CuiElement()
                    {
                        Parent = parrent,
                        Name = name,
                        Components =
                        {
                            new CuiImageComponent{Color = color, Material = "assets/icons/greyout.mat"},
                            new CuiRectTransformComponent{AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax}
                        }
                    });

                if(string.IsNullOrEmpty(sprite) && string.IsNullOrEmpty(mat))
                    container.Add(new CuiElement()
                    {
                        Parent = parrent,
                        Name = name,
                        Components =
                    {
                        new CuiImageComponent{Color = color},
                        new CuiRectTransformComponent{AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax}
                    }
                    });
            }

            public static void AddRawImage(ref CuiElementContainer container, string parrent, string name, string png, string color, string sprite, string mat, string aMin, string aMax, string oMin, string oMax)
            {
                if(string.IsNullOrEmpty(sprite) && string.IsNullOrEmpty(mat))
                    container.Add(new CuiElement()
                    {
                        Parent = parrent,
                        Name = name,
                        Components =
                    {
                        new CuiRawImageComponent{Color = color, Png = png},
                        new CuiOutlineComponent { Color = "0 0 0 0", Distance = "0 0"},
                        new CuiRectTransformComponent{AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax}
                    }
                    });
            }

            public static void AddText(ref CuiElementContainer container, string parrent, string name, string color, string text, TextAnchor align, int size, string aMin, string aMax, string oMin, string oMax, string outColor = "0 0 0 0", string font = "robotocondensed-bold.ttf", string dist = "0.5 0.5", float FadeIN = 0f, float FadeOut = 0f)
            {
                container.Add(new CuiElement()
                {
                    Parent = parrent,
                    Name = name,
                    FadeOut = FadeOut,
                    Components =
                    {
                        new CuiTextComponent{Color = color,Text = text, Align = align, FontSize = size, Font = font, FadeIn = FadeIN},
                        new CuiOutlineComponent{Color = outColor, Distance = dist},
                        new CuiRectTransformComponent{AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax}
                    }
                });

            }

            public static void AddButton(ref CuiElementContainer container, string parrent, string name, string cmd, string close, string color, string sprite, string mat, string aMin, string aMax, string oMin, string oMax, string outline = "", string dist = "")
            {
                if(!string.IsNullOrEmpty(sprite) && !string.IsNullOrEmpty(mat))
                    container.Add(new CuiElement()
                    {
                        Parent = parrent,
                        Name = name,
                        Components =
                        {
                            new CuiButtonComponent{Command = cmd, Color = color, Close = close, Sprite = sprite, Material = "assets/icons/greyout.mat", },
                            new CuiRectTransformComponent{AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax}
                        }
                    });

                if(!string.IsNullOrEmpty(sprite) && !string.IsNullOrEmpty(mat) && !string.IsNullOrEmpty(outline))
                    container.Add(new CuiElement()
                    {
                        Parent = parrent,
                        Name = name,
                        Components =
                        {
                            new CuiButtonComponent{Command = cmd, Color = color, Close = close, Sprite = sprite, Material = "assets/icons/greyout.mat", },
                            new CuiOutlineComponent{Color = outline, Distance = dist},
                            new CuiRectTransformComponent{ AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax }
                        }
                    });

                if(string.IsNullOrEmpty(sprite) && !string.IsNullOrEmpty(mat))
                    container.Add(new CuiElement()
                    {
                        Parent = parrent,
                        Name = name,
                        Components =
                    {
                        new CuiButtonComponent{Command = cmd, Color = color, Close = close, Material = "assets/icons/greyout.mat", },
                        new CuiRectTransformComponent{AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax}
                    }
                    });

                if(!string.IsNullOrEmpty(sprite) && string.IsNullOrEmpty(mat))
                    container.Add(new CuiElement()
                    {
                        Parent = parrent,
                        Name = name,
                        Components =
                    {
                        new CuiButtonComponent{Command = cmd, Color = color, Close = close, Sprite = sprite},
                        new CuiRectTransformComponent{AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax}
                    }
                    });

                if(string.IsNullOrEmpty(sprite) && string.IsNullOrEmpty(mat))
                    container.Add(new CuiElement()
                    {
                        Parent = parrent,
                        Name = name,
                        Components =
                    {
                        new CuiButtonComponent{Command = cmd, Color = color, Close = close, },
                        new CuiRectTransformComponent{AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax}
                    }
                    });
            }
        }

        private static string FormatTime(TimeSpan time)
        {
            return($"{FormatMinutes(time.Minutes)}:{FormatSeconds(time.Seconds)}");
        }
        private static string FormatMinutes(int minutes) => FormatUnits2(minutes);

        private static string FormatSeconds(int seconds) => FormatUnits(seconds);

        private static string FormatUnits2(int units)
        {
            var tmp = units % 10;

            if(units >= 10)
                return $"{units}";

            if(units >= 0 && units <= 10)
                return $"{units}";

            return $"{units}";
        }

        private static string FormatUnits(int units)
        {
            var tmp = units % 10;

            if(units >= 10)
                return $"{units}";

            if(units >= 0 && units <= 10)
                return $"0{units}";

            return $"0{units}";
        }

        #endregion
    }
}

// --- End of file: CombatBB.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/GoldCard.cs ---
// --- Original Local Path: GoldCard.cs ---

﻿using System;

using ConVar;
using Newtonsoft.Json;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("GoldCard", "", "1.0.4")]
    [Description("")]
    class GoldCard : RustPlugin
    {
        #region Vars
        private const string Shortname = "keycard_red";
        #endregion

        #region Reference
        [PluginReference] Plugin IQChat;
        #endregion

        #region Configuration

        private static Configuration config = new Configuration();
        private class Configuration
        {
            [JsonProperty("SkinID для предмета")]
            public ulong SkinID;
            [JsonProperty("DisplayName для предмета")]
            public string DisplayName;
            [JsonProperty("Как быстро будет ломаться предмет ? (1.0 стандарт)")]
            public float condition;
            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    SkinID = 1977450795,
                    DisplayName = "Карта общего доступа",
                    condition = 0.5f,
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning("Ошибка #1" + $"чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }
            if (config.condition == 0.0)
                config.condition = 0.5f;
            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region Metods
        void CreateItem(BasePlayer player)
        {
            Item item = ItemManager.CreateByName(Shortname, 1, config.SkinID);
            item.name = config.DisplayName;
            player.GiveItem(item);
        }

        public void SendChat(string Message, BasePlayer player, Chat.ChatChannel channel = Chat.ChatChannel.Global)
        {
            if (IQChat)
                IQChat?.Call("API_ALERT_PLAYER", player, Message, "");
            else player.SendConsoleCommand("chat.add", channel, 0, Message);
        }
        #endregion

        #region Hooks

        private Item OnItemSplit(Item item, int amount)
        {
            if (plugins.Find("Stacks") || plugins.Find("CustomSkinsStacksFix") || plugins.Find("SkinBox")) return null;
            if (item.skin == config.SkinID)
            {
                Item x = ItemManager.CreateByPartialName(Shortname, amount);
                x.name = config.DisplayName;
                x.skin = config.SkinID;
                x.amount = amount;
                item.amount -= amount;
                return x;
            }
            return null;
        }

        object CanCombineDroppedItem(DroppedItem item, DroppedItem targetItem)
        {
            if (item.GetItem().skin != targetItem.GetItem().skin) return false;
            return null;
        }
        object CanStackItem(Item item, Item targetItem)
        {
            if (item.skin != targetItem.skin) return false;
            return null;
        }

        private object OnCardSwipe(CardReader cardReader, Keycard card, BasePlayer player)
        {
            if (card.accessLevel != cardReader.accessLevel && card.skinID == config.SkinID)
            {
                var cards = card.GetItem();
                if (cards == null || cards.conditionNormalized <= 0.0)
                    return null;

                cardReader.Invoke(new Action(cardReader.GrantCard), 0.5f);
                cards.LoseCondition(config.condition);
                SendChat("Вы успешно получили доступ к двери", player);
                return true;
            }
            return null;
        }

        #endregion

        #region Commands
        [ConsoleCommand("card")]
        void CardCommand(ConsoleSystem.Arg arg)
        {
            BasePlayer player = BasePlayer.FindByID(ulong.Parse(arg.Args[0]));
            if (player == null) return;
            CreateItem(player);
            SendChat($"Вы успешно получили {config.DisplayName}", player);
            Puts("Игроку успешно выдана карта!");
        }
        #endregion
    }
}


// --- End of file: GoldCard.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TheGoldenEgg-1.9.24.cs ---
// --- Original Local Path: TheGoldenEgg-1.9.24.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Facepunch;

namespace Oxide.Plugins
{
    [Info("The Golden Egg", "crunch", "1.9.24")]
    [Description("Once found, the Golden Egg can bring you great riches, but it doesn't want to remain hidden...")]
    class TheGoldenEgg : CovalencePlugin
    {
        [PluginReference]
        private Plugin TimedPermissions, RaidableBases;
        private Configuration _pluginConfig;
        private static TheGoldenEgg ins;
        private const string permissionUse = "thegoldenegg.use";
        private StoredData storedData;
        private DynamicConfigFile data;
        public float chance = 0f;
        public ulong eggUID = 0;
        public ulong chinookID = 0;
        private List<ulong> crateID = new List<ulong>();
        private Timer markerTimer, rewardTimer, delayTimer, saveTimer, blockTimer, moveTimer, crateEventTimer, crateMarkTimer, safeTimer, buildTimer, raidBaseTimer;
        private int resource, amount, spawnTime;
        private string cleanName, itemName;
        private bool blockEggOpen, safezone = false, inPriv = false, pop = false, priv = false, tod = false, blocked = false, isBlocked = false, crateDrop, isRunning = false;
        public static string currentOwner;
        private DateTime startTime;
        private static PluginTimers Timer;
        public List<MapMarkerGenericRadius> eggRadMarker = new List<MapMarkerGenericRadius>();
        public List<VendingMachineMapMarker> eggVendMarker = new List<VendingMachineMapMarker>();
        public MapMarkerGenericRadius _marker;
        public Dictionary<string, Item> _spawnedItems = new Dictionary<string, Item>();
        public Dictionary<ulong, HackableLockedCrate> _spawnedCrates = new Dictionary<ulong, HackableLockedCrate>();
        readonly int blockLayer = LayerMask.GetMask("Player (Server)");
        private List<ulong> allowDraw = new List<ulong>();
        private List<uint> buildID = new List<uint>();
        public Vector3 pos, lastPosition, cratePos;

        void Init()
        {
            LoadData();
            AddCommands();
            Timer = timer;
            Unsubscribe(nameof(OnEntityTakeDamage));
            Unsubscribe(nameof(OnItemPickup));
            Unsubscribe(nameof(OnItemDropped));
            Unsubscribe(nameof(CanEntityTakeDamage));
            Unsubscribe(nameof(OnCollectiblePickup));
            Unsubscribe(nameof(OnHelicopterDropCrate));
            Unsubscribe(nameof(OnCrateDropped));
            Unsubscribe(nameof(CanHackCrate));
            Unsubscribe(nameof(OnPlayerCommand));

        }

        void OnServerInitialized(bool initial)
        {
            permission.RegisterPermission(permissionUse, this);

            _pluginConfig.EggRewards.Remove("item.one");
            _pluginConfig.EggRewards.Remove("item.two");
            _pluginConfig.EggRewards.Remove("etc");

            crateDrop = false;

            foreach (var ent in BaseNetworkable.serverEntities)
            {
                if (ent is StorageContainer)
                {
                    var container = (ent as StorageContainer)?.inventory?.itemList ?? null;
                    for (int j = 0; j < container.Count; j++)
                    {
                        if (container[j].text == "6E657264")
                        {
                            SaveDataTimer();

                            var playerID = (ent as StorageContainer).OwnerID;
                            var player = players.FindPlayerById(Convert.ToString(playerID));
                            var bPlayer = BasePlayer.FindAwakeOrSleeping(Convert.ToString(playerID));

                            priv = false;

                            if (bPlayer != null && _pluginConfig.NoPrivTime)
                                priv = (ent as StorageContainer).inventory.entityOwner?.GetBuildingPrivilege()?.IsAuthed(bPlayer) ?? false;

                            if (_pluginConfig.TimeOfDay)
                            {
                                TimeSpan tsStart = DateTime.Parse(_pluginConfig.StartTime).TimeOfDay;
                                TimeSpan tsEnd = DateTime.Parse(_pluginConfig.EndTime).TimeOfDay;

                                if (IsBetween(tsStart, tsEnd))
                                    tod = true;
                            }

                            if ((!priv) && (!tod) && (ent.ShortPrefabName != "small_stash_deployed" || (ent.ShortPrefabName == "small_stash_deployed" && !_pluginConfig.BlockStashTime)))
                            {
                                if (_pluginConfig.ServerPop == 0 || (covalence.Server.Players + ConVar.Admin.ServerInfo().Joining >= _pluginConfig.ServerPop))
                                    storedData.OnEggMove(player);
                            }

                            pos = ent.transform.position;

                            eggUID = container[j].uid.Value;
                            itemName = String.IsNullOrEmpty(_pluginConfig.customItemS.ItemName) ? "The Golden Egg" : _pluginConfig.customItemS.ItemName;

                            if (!_spawnedItems.ContainsKey(container[j].text))
                            {
                                _spawnedItems.Add(container[j].text, container[j]);
                            }

                            Unsubscribe(nameof(CanLootEntity));
                            Subscribe(nameof(OnItemAddedToContainer));
                            Subscribe(nameof(OnItemRemovedFromContainer));
                            Subscribe(nameof(OnItemPickup));
                            Subscribe(nameof(OnItemDropped));
                            if (_pluginConfig.roamS.IncreasePickup)
                                Subscribe(nameof(OnCollectiblePickup));
                            if (_pluginConfig.tpveS.DisableTruePVE)
                                Subscribe(nameof(CanEntityTakeDamage));
                            if (_pluginConfig.BlockEggCrack)
                                Subscribe(nameof(OnEntityTakeDamage));
                            if (_pluginConfig.crateS.crateEvent)
                            {
                                Subscribe(nameof(OnHelicopterDropCrate));
                                Subscribe(nameof(OnCrateDropped));
                                Subscribe(nameof(CanHackCrate));
                            }
                            if (_pluginConfig.UseBlacklist)
                            {
                                Subscribe(nameof(OnPlayerCommand));
                            }

                            if (_pluginConfig.markerS.boxMarker)
                            {
                                CreateMarkers();
                                markerTimer = timer.Repeat(_pluginConfig.markerS.BoxMarkerRefreshTime, 0, () =>
                                {
                                    /*                                    if (ent == null)
                                                                       {
                                                                           if (markerTimer != null) markerTimer.Destroy();
                                                                           MarkerDelete();
                                                                           markerTimer = null;
                                                                       }
                                                                       else
                                                                       { */
                                    pos = ent.transform.position;
                                    CreateMarkers();
                                    //}
                                });
                            }
                            else
                            {
                                if (markerTimer != null)
                                {
                                    markerTimer.Destroy();
                                    markerTimer = null;
                                }
                                MarkerDelete();
                            }

                            resource = 0;
                            spawnTime = _pluginConfig.resourceS.ResourceSpawnTime;

                            for (int x = 0; x < container.Count; x++)
                            {
                                var shortName = container[x].info.shortname;
                                cleanName = container[x].info.displayName.english;

                                if (ent.ShortPrefabName == "small_stash_deployed") return;

                                var isDone = false;
                                switch (shortName)
                                {
                                    case "metal.refined":
                                    case "lowgradefuel":
                                    case "metal.fragments":
                                    case "scrap":
                                        resource = container[x].info.itemid;
                                        amount = GetResourceAmount(shortName);
                                        isDone = true;
                                        break;

                                    case "sulfur":
                                        if (_pluginConfig.resourceS.AllowSulfurCooked)
                                        {
                                            resource = container[x].info.itemid;
                                            amount = GetResourceAmount(shortName);
                                            isDone = true;
                                        }
                                        break;

                                    case "sulfur.ore":
                                        if (_pluginConfig.resourceS.AllowSulfurOre)
                                        {
                                            resource = container[x].info.itemid;
                                            amount = GetResourceAmount(shortName);
                                            isDone = true;
                                        }
                                        break;
                                }

                                if (isDone) break;

                                if (shortName == _pluginConfig.resourceS.CustomItem1)
                                {
                                    resource = container[x].info.itemid;
                                    amount = _pluginConfig.resourceS.CustomAmount1;
                                    spawnTime = _pluginConfig.resourceS.CustomTime1;
                                    break;
                                }
                                else if (shortName == _pluginConfig.resourceS.CustomItem2)
                                {
                                    resource = container[x].info.itemid;
                                    amount = _pluginConfig.resourceS.CustomAmount2;
                                    spawnTime = _pluginConfig.resourceS.CustomTime2;
                                    break;
                                }
                                else if (shortName == _pluginConfig.resourceS.CustomItem3)
                                {
                                    resource = container[x].info.itemid;
                                    amount = _pluginConfig.resourceS.CustomAmount3;
                                    spawnTime = _pluginConfig.resourceS.CustomTime3;
                                    break;
                                }
                                else
                                {
                                    continue;
                                }
                            }

                            if (resource == 0)
                            {
                                resource = -932201673;
                                amount = GetResourceAmount("scrap");
                                cleanName = "Scrap";
                            }

                            if (rewardTimer != null) rewardTimer.Destroy();
                            startTime = DateTime.Now;

                            rewardTimer = timer.Repeat(spawnTime, 0, () =>
                            {
                                SpawnRewards(ent as BaseEntity, resource, amount);
                                startTime = DateTime.Now;
                            });

                            return;
                        }
                    }
                }
                else if (ent is BasePlayer basePlayer)
                {
                    List<Item> items = new List<Item>();
                    basePlayer.inventory.GetAllItems(items);
                    if (items != null && items.Count > 0) for (int j = 0; j < items.Count; j++)
                        {
                            if (items[j].text == "6E657264")
                            {
                                SaveDataTimer();

                                var playerID = (ent as BasePlayer).userID;
                                var player = players.FindPlayerById(Convert.ToString(playerID));
                                var bPlayer = BasePlayer.FindAwakeOrSleeping(Convert.ToString(playerID));

                                currentOwner = (ent as BasePlayer).UserIDString;

                                priv = false;

                                if (bPlayer != null && _pluginConfig.NoPrivTime)
                                    priv = bPlayer?.GetBuildingPrivilege()?.IsAuthed(bPlayer) ?? false;

                                if (!priv)
                                {
                                    if (_pluginConfig.ServerPop == 0 || (covalence.Server.Players + ConVar.Admin.ServerInfo().Joining >= _pluginConfig.ServerPop))
                                        storedData.OnEggMove(player);
                                }

                                eggUID = items[j].uid.Value;
                                itemName = String.IsNullOrEmpty(_pluginConfig.customItemS.ItemName) ? "The Golden Egg" : _pluginConfig.customItemS.ItemName;

                                if (!_spawnedItems.ContainsKey(items[j].text))
                                {
                                    _spawnedItems.Add(items[j].text, items[j]);
                                }

                                Unsubscribe(nameof(CanLootEntity));
                                Subscribe(nameof(OnItemAddedToContainer));
                                Subscribe(nameof(OnItemRemovedFromContainer));
                                Subscribe(nameof(OnItemPickup));
                                Subscribe(nameof(OnItemDropped));
                                if (_pluginConfig.roamS.IncreasePickup)
                                    Subscribe(nameof(OnCollectiblePickup));
                                if (_pluginConfig.tpveS.DisableTruePVE)
                                    Subscribe(nameof(CanEntityTakeDamage));
                                if (_pluginConfig.BlockEggCrack)
                                    Subscribe(nameof(OnEntityTakeDamage));
                                if (_pluginConfig.crateS.crateEvent)
                                {
                                    Subscribe(nameof(OnHelicopterDropCrate));
                                    Subscribe(nameof(OnCrateDropped));
                                    Subscribe(nameof(CanHackCrate));
                                }
                                if (_pluginConfig.UseBlacklist)
                                {
                                    Subscribe(nameof(OnPlayerCommand));
                                }

                                pos = ent.transform.position;
                                safezone = false;
                                inPriv = false;
                                pop = false;
                                tod = false;

                                CreateMarkers(bPlayer);

                                markerTimer = timer.Repeat(_pluginConfig.markerS.PlayerMarkerRefreshTime, 0, () =>
                                {
                                    pos = ent.transform.position;
                                    CreateMarkers(bPlayer);
                                });
                            }
                        }
                }
                else if (ent is DroppedItem)
                {
                    if (ent == null || ent.IsDestroyed)
                    {
                        continue;
                    }

                    var drop = ent as DroppedItem;

                    if (drop.item.text == "6E657264")
                    {
                        eggUID = drop.item.uid.Value;
                        itemName = String.IsNullOrEmpty(_pluginConfig.customItemS.ItemName) ? "The Golden Egg" : _pluginConfig.customItemS.ItemName;

                        if (!_spawnedItems.ContainsKey(drop.item.text))
                        {
                            _spawnedItems.Add(drop.item.text, drop.item);
                        }

                        Unsubscribe(nameof(CanLootEntity));
                        Subscribe(nameof(OnItemAddedToContainer));
                        Subscribe(nameof(OnItemRemovedFromContainer));
                        Subscribe(nameof(OnItemPickup));
                        Subscribe(nameof(OnItemDropped));
                        if (_pluginConfig.roamS.IncreasePickup)
                            Subscribe(nameof(OnCollectiblePickup));
                        if (_pluginConfig.tpveS.DisableTruePVE)
                            Subscribe(nameof(CanEntityTakeDamage));
                        if (_pluginConfig.BlockEggCrack)
                            Subscribe(nameof(OnEntityTakeDamage));
                        if (_pluginConfig.crateS.crateEvent)
                        {
                            Subscribe(nameof(OnHelicopterDropCrate));
                            Subscribe(nameof(OnCrateDropped));
                            Subscribe(nameof(CanHackCrate));
                        }
                        if (_pluginConfig.UseBlacklist)
                        {
                            Subscribe(nameof(OnPlayerCommand));
                        }

                        pos = ent.transform.position;
                        safezone = false;
                        inPriv = false;
                        pop = false;
                        tod = false;

                        CreateMarkers();

                        markerTimer = timer.Repeat(_pluginConfig.markerS.PlayerMarkerRefreshTime, 0, () =>
                        {
                            pos = ent.transform.position;

                            CreateMarkers();
                        });
                    }
                }
            }
            if (eggUID == 0)
            {
                Subscribe(nameof(CanLootEntity));
                Unsubscribe(nameof(OnItemAddedToContainer));
                Unsubscribe(nameof(OnItemRemovedFromContainer));
                if (_pluginConfig.BlockEggCrack)
                    Unsubscribe(nameof(OnEntityTakeDamage));
                if (_pluginConfig.tpveS.DisableTruePVE)
                    Unsubscribe(nameof(CanEntityTakeDamage));
                if (_pluginConfig.roamS.IncreasePickup)
                    Unsubscribe(nameof(OnCollectiblePickup));
                if (_pluginConfig.crateS.crateEvent)
                {
                    Unsubscribe(nameof(OnHelicopterDropCrate));
                    Unsubscribe(nameof(OnCrateDropped));
                    Unsubscribe(nameof(CanHackCrate));
                }
                if (_pluginConfig.UseBlacklist)
                {
                    Unsubscribe(nameof(OnPlayerCommand));
                }
            }

            if (_pluginConfig.KillTime != 0)
                timer.Every(60f, UpdateLoop);

            runEvent();
        }

        private void runEvent()
        {
            if (eggUID == 0) return;

            if (chinookID != 0)
            {
                Puts("The chinook event is already running");
                return;
            }

            if (_pluginConfig.crateS.crateEvent && _pluginConfig.crateS.crateRepeat && (covalence.Server.Players + ConVar.Admin.ServerInfo().Joining >= _pluginConfig.crateS.cratePop))
            {
                crateEventTimer = timer.In(UnityEngine.Random.Range(_pluginConfig.crateS.minStartTime, _pluginConfig.crateS.maxStartTime), () =>
                {
                    Puts("The chinook event has started");
                    chinookID = 0;
                    crateID.Clear();
                    _spawnedCrates.Clear();

                    if (_marker != null)
                    {
                        _marker.Kill();
                        _marker.SendUpdate();
                    }
                    if (crateMarkTimer != null)
                        crateMarkTimer.Destroy();

                    var chinook = GameManager.server.CreateEntity("assets/prefabs/npc/ch47/ch47scientists.entity.prefab") as CH47HelicopterAIController;
                    if (chinook == null)
                    {
                        return;
                    }

                    chinook.numCrates = _pluginConfig.crateS.numCrates;

                    chinook.TriggeredEventSpawn();
                    chinook.Spawn();

                    chinookID = chinook.net.ID.Value;
                });
            }
            return;
        }

        private void UpdateLoop()
        {
            if (String.IsNullOrEmpty(storedData._eggCreated)) return;

            if ((DateTime.Now - DateTime.Parse((string)storedData._eggCreated)).TotalMinutes < _pluginConfig.KillTime)
                return;

            if (_spawnedItems != null)
            {
                foreach (var _item in _spawnedItems.ToList())
                {
                    if (_item.Key == "6E657264")
                    {
                        Item item = _item.Value;
                        if (item != null)
                        {
                            item.Remove();
                            _spawnedItems.Remove(_item.Key);
                        }
                    }
                }
            }
        }

        void Unload()
        {
            storedData.GetTotals();
            SaveData();

            Timer = null;
            ins = null;

            if (markerTimer != null)
            {
                markerTimer.Destroy();
                markerTimer = null;
            }
            if (rewardTimer != null) rewardTimer.Destroy();
            if (crateMarkTimer != null) crateMarkTimer.Destroy();
            if (_marker != null)
            {
                _marker.Kill();
                _marker.SendUpdate();
            }
            MarkerDelete();
        }

        void OnNewSave(string filename)
        {
            if (_pluginConfig.ClearData)
            {
                data.Clear();
                data.Save();
                storedData = data.ReadObject<StoredData>();
                if (storedData == null)
                {
                    storedData = new StoredData();
                }

                Log("Wiped player_data.json");
            }
        }

        object CanLootEntity(BasePlayer player, StorageContainer container)
        {
            if (player == null || container == null || eggUID != 0 || spamCheck.ContainsKey(player.userID) || player.IsNpc || !player.userID.IsSteamId())
                return null;

            switch (container.ShortPrefabName)
            {
                case "codelockedhackablecrate":
                case "chinooklockedcrate":
                case "chinooklockedcratecodelocked":
                case "codelockedhackablecrate_oilrig":
                    chance = _pluginConfig.LockedCrateEggChance;
                    break;

                case "crate_elite":
                case "bradley_crate":
                    chance = _pluginConfig.EliteCrateEggChance;
                    break;

                case "crate_normal":
                    chance = _pluginConfig.MilitaryCrateEggChance;
                    break;

                case "crate_normal_2":
                    chance = _pluginConfig.NormalCrateEggChance;
                    break;

                default:
                    return null;
            }

            var randomInt = UnityEngine.Random.Range(0f, 100f);

            AddSpamBlock(player.userID);

            if (randomInt <= chance)
            {
                Item item = ItemManager.CreateByItemID(-1002156085, 1);
                eggUID = item.uid.Value;

                if (_pluginConfig.customItemS.ItemSkin != 0)
                    item.skin = _pluginConfig.customItemS.ItemSkin;

                SaveDataTimer();
                Subscribe(nameof(OnItemPickup));
                Subscribe(nameof(OnItemDropped));

                itemName = String.IsNullOrEmpty(_pluginConfig.customItemS.ItemName) ? "The Golden Egg" : _pluginConfig.customItemS.ItemName;

                item.name = itemName;
                item.text = "6E657264";
                item.MarkDirty();

                if (!_spawnedItems.ContainsKey(item.text))
                {
                    _spawnedItems.Add(item.text, item);
                }

                if (player != null && player.userID.IsSteamId())
                {
                    Puts($"{player.displayName} found the egg");
                    player.GiveItem(item);

                    runEvent();

                    storedData._eggCreated = DateTime.Now.ToString();
                    SaveData();

                    if (_pluginConfig.roamS.IncreaseHealth || _pluginConfig.roamS.IncreaseGather)
                        SetModifiers(player);

                    Subscribe(nameof(OnItemAddedToContainer));
                    Subscribe(nameof(OnItemRemovedFromContainer));
                    if (_pluginConfig.BlockEggCrack)
                        Subscribe(nameof(OnEntityTakeDamage));
                    if (_pluginConfig.tpveS.DisableTruePVE)
                        Subscribe(nameof(CanEntityTakeDamage));
                    if (_pluginConfig.roamS.IncreasePickup)
                        Subscribe(nameof(OnCollectiblePickup));
                    if (_pluginConfig.crateS.crateEvent)
                    {
                        Subscribe(nameof(OnHelicopterDropCrate));
                        Subscribe(nameof(OnCrateDropped));
                        Subscribe(nameof(CanHackCrate));
                    }
                    if (_pluginConfig.UseBlacklist)
                    {
                        Subscribe(nameof(OnPlayerCommand));
                    }

                    storedData.OnEggMove(player.IPlayer);

                    if (_pluginConfig.markerS.playerMarker)
                        server.Broadcast($"{itemName} has been found!! Its location will appear on the map in {_pluginConfig.markerS.InitialMarkerDelay} seconds");
                    else
                        server.Broadcast($"{itemName} has been found!!");

                    if (!String.IsNullOrEmpty(_pluginConfig.sendWebhook) && _pluginConfig.sendWebhook != "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks")
                    {
                        new DiscordWebhook()
                        .AddEmbed()
                            .SetDescription($"{itemName.ToUpper()} IS FOUND!")
                            .SetColor(3447003)
                            .AddField("Location", $"{(player.transform.position)}, but will soon be on the move!", true)
                            .SetTimestamp(DateTime.UtcNow)
                            .AddThumbnail(_pluginConfig.customItemS.ItemFoundDiscord)
                            .EndEmbed()
                            .Send(this, _pluginConfig.sendWebhook);
                    }

                    CuiHelper.DestroyUi(player, "EggUI");
                    CuiHelper.AddUi(player, CreateEggUI());

                    var effect = "assets/bundled/prefabs/fx/explosions/water_bomb.prefab";
                    EffectNetwork.Send(new Effect(effect, player, 0, new Vector3(), new Vector3()), player.Connection);

                    timer.Once(10f, () =>
                    {
                        CuiHelper.DestroyUi(player, "EggUI");
                    });

                    delayTimer = timer.Once(_pluginConfig.markerS.InitialMarkerDelay, () =>
                    {
                        var inv = new List<Item>();
                        player.inventory.GetAllItems(inv);
                        if (!inv.Contains(item))
                        {
                            return;
                        }

                        pos = player.transform.position;
                        safezone = false;
                        inPriv = false;
                        pop = false;
                        tod = false;

                        CreateMarkers(player);
                        markerTimer = timer.Repeat(_pluginConfig.markerS.PlayerMarkerRefreshTime, 0, () =>
                        {
                            pos = player.transform.position;
                            CreateMarkers(player);
                        });
                    });
                }
                Unsubscribe(nameof(CanLootEntity));
                return null;
            }

            return null;
        }

        void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            if (container == null || item == null)
                return;

            switch (item.info.shortname)
            {
                case "metal.refined":
                case "lowgradefuel":
                case "metal.fragments":
                case "scrap":
                case "sulfur":
                case "sulfur.ore":

                    HandleAdds(container, item);
                    break;
            }

            if (item.info.shortname == _pluginConfig.resourceS.CustomItem1
                || item.info.shortname == _pluginConfig.resourceS.CustomItem2
                || item.info.shortname == _pluginConfig.resourceS.CustomItem3
                )
            {
                HandleAdds(container, item);
            }

            if (item.text == "6E657264")
            {
                var playerOwner = container.playerOwner;
                var contOwner = container.entityOwner;

                //if (markerTimer != null) markerTimer.Destroy();
                if (rewardTimer != null) rewardTimer.Destroy();

                if (playerOwner != null && (_pluginConfig.roamS.IncreaseHealth || _pluginConfig.roamS.IncreaseGather))
                {
                    SetModifiers(playerOwner);
                    return;
                }

                if (markerTimer != null)
                {
                    markerTimer.Destroy();
                    markerTimer = null;
                    MarkerDelete();
                }
                pos = contOwner.transform.position;

                if (contOwner != null)
                {
                    var inventory = container.itemList.ToArray();

                    resource = 0;
                    spawnTime = _pluginConfig.resourceS.ResourceSpawnTime;

                    foreach (Item inv in inventory)
                    {
                        var shortName = inv.info.shortname;

                        var isDone = false;
                        switch (shortName)
                        {
                            case "metal.refined":
                            case "lowgradefuel":
                            case "metal.fragments":
                            case "scrap":
                                resource = inv.info.itemid;
                                amount = GetResourceAmount(shortName);
                                cleanName = inv.info.displayName.english;
                                isDone = true;
                                break;

                            case "sulfur":
                                if (_pluginConfig.resourceS.AllowSulfurCooked)
                                {
                                    resource = inv.info.itemid;
                                    amount = GetResourceAmount(shortName);
                                    cleanName = inv.info.displayName.english;
                                    isDone = true;
                                }
                                break;

                            case "sulfur.ore":
                                if (_pluginConfig.resourceS.AllowSulfurOre)
                                {
                                    resource = inv.info.itemid;
                                    amount = GetResourceAmount(shortName);
                                    cleanName = inv.info.displayName.english;
                                    isDone = true;
                                }
                                break;
                        }

                        if (isDone) break;

                        if (shortName == _pluginConfig.resourceS.CustomItem1)
                        {
                            resource = inv.info.itemid;
                            amount = _pluginConfig.resourceS.CustomAmount1;
                            spawnTime = _pluginConfig.resourceS.CustomTime1;
                            cleanName = inv.info.displayName.english;
                            break;
                        }
                        else if (shortName == _pluginConfig.resourceS.CustomItem2)
                        {
                            resource = inv.info.itemid;
                            amount = _pluginConfig.resourceS.CustomAmount2;
                            spawnTime = _pluginConfig.resourceS.CustomTime2;
                            cleanName = inv.info.displayName.english;
                            break;
                        }
                        else if (shortName == _pluginConfig.resourceS.CustomItem3)
                        {
                            resource = inv.info.itemid;
                            amount = _pluginConfig.resourceS.CustomAmount3;
                            spawnTime = _pluginConfig.resourceS.CustomTime3;
                            cleanName = inv.info.displayName.english;
                            break;
                        }
                        else
                        {
                            continue;
                        }
                    }

                    if (resource == 0)
                    {
                        resource = -932201673;
                        amount = GetResourceAmount("scrap");
                        cleanName = "Scrap";
                    }

                    priv = false;
                    var ownerID = contOwner.OwnerID;

                    currentOwner = ownerID.ToString();

                    if (contOwner.ShortPrefabName != "small_stash_deployed" && amount != 0)
                    {
                        var player = ownerID.IsSteamId() ? BasePlayer.FindAwakeOrSleeping(Convert.ToString(ownerID)) : null;

                        if (player != null && _pluginConfig.NoPrivTime)
                            priv = container.entityOwner?.GetBuildingPrivilege()?.IsAuthed(player) ?? false;

                        if (player != null && player.currentTeam != 0UL)
                        {
                            var teamMembers = player.Team.members.ToList();

                            foreach (var member in teamMembers)
                            {
                                if (!String.IsNullOrEmpty(cleanName))
                                {
                                    var teamPlayer = players.FindPlayerById(Convert.ToString(member));
                                    if (teamPlayer.IsConnected)
                                    {
                                        var bPlayer = BasePlayer.FindByID(member);
                                        bPlayer.ChatMessage(String.Format(GetMsg("Generating", Convert.ToString(bPlayer.userID)), cleanName));
                                    }
                                }
                            }
                        }

                        if (player != null && player.currentTeam == 0 && amount != 0)
                        {
                            if (!String.IsNullOrEmpty(cleanName)) player.ChatMessage(String.Format(GetMsg("Generating", Convert.ToString(player.userID)), cleanName));
                        }
                    }

                    if (_pluginConfig.TimeOfDay)
                    {
                        tod = false;
                        TimeSpan tsStart = DateTime.Parse(_pluginConfig.StartTime).TimeOfDay;
                        TimeSpan tsEnd = DateTime.Parse(_pluginConfig.EndTime).TimeOfDay;

                        if (IsBetween(tsStart, tsEnd))
                            tod = true;
                    }

                    var playerI = players.FindPlayerById(Convert.ToString(ownerID));

                    if (playerI != null)
                        currentOwner = playerI.Id;

                    if (contOwner.ShortPrefabName != "small_stash_deployed" || (contOwner.ShortPrefabName == "small_stash_deployed" && !_pluginConfig.BlockStashTime))
                    {
                        if (playerI != null && !priv && !tod)
                        {
                            if (_pluginConfig.ServerPop == 0 || (covalence.Server.Players + ConVar.Admin.ServerInfo().Joining >= _pluginConfig.ServerPop))
                                storedData.OnEggMove(playerI);
                        }

                        if (rewardTimer != null) rewardTimer.Destroy();
                        startTime = DateTime.Now;
                        rewardTimer = timer.Repeat(spawnTime, 0, () =>
                        {
                            SpawnRewards(contOwner, resource, amount);
                            startTime = DateTime.Now;
                        });
                    }
                }
                if (_pluginConfig.markerS.boxMarker)
                {
                    CreateMarkers();
                    markerTimer = timer.Repeat(_pluginConfig.markerS.BoxMarkerRefreshTime, 0, () =>
                    {
                        /*                         if (contOwner == null)
                                                {
                                                    if (markerTimer != null) markerTimer.Destroy();
                                                    MarkerDelete();
                                                    markerTimer = null;
                                                }
                                                else
                                                { */
                        pos = contOwner.transform.position;
                        CreateMarkers();
                        //}
                    });
                }
                else
                {
                    if (markerTimer != null)
                    {
                        markerTimer.Destroy();
                        markerTimer = null;
                    }
                    MarkerDelete();
                }
            }
            return;
        }

        void HandleAdds(ItemContainer container, Item item)
        {
            var contOwner = container.entityOwner;

            if (contOwner != null && contOwner.ShortPrefabName != "small_stash_deployed")
            {
                var inventory = container.itemList.ToArray();
                var itemID = item.info.itemid;

                foreach (Item inv in inventory)
                {
                    if (inv.text == "6E657264")
                    {
                        if ((!_pluginConfig.resourceS.AllowSulfurCooked && item.info.shortname == "sulfur") || (!_pluginConfig.resourceS.AllowSulfurOre && item.info.shortname == "sulfur.ore")) break;

                        cleanName = item.info.displayName.english;
                        var ownerID = contOwner.OwnerID;

                        amount = GetResourceAmount(item.info.shortname);

                        var player = ownerID.IsSteamId() ? BasePlayer.FindAwakeOrSleeping(Convert.ToString(ownerID)) : null;

                        if (player != null && player.currentTeam != 0UL && amount != 0)
                        {
                            var teamMembers = player.Team.members.ToList();

                            foreach (var member in teamMembers)
                            {
                                var teamPlayer = players.FindPlayerById(Convert.ToString(member));
                                if (teamPlayer.IsConnected)
                                {
                                    var bPlayer = BasePlayer.FindByID(member);
                                    bPlayer.ChatMessage(String.Format(GetMsg("Generating", Convert.ToString(bPlayer.userID)), cleanName));
                                }
                            }
                        }

                        if (player != null && player.currentTeam == 0 && amount != 0)
                        {
                            player.ChatMessage(String.Format(GetMsg("Generating", Convert.ToString(player.userID)), cleanName));
                        }

                        spawnTime = GetSpawnTime(item.info.shortname);

                        if (rewardTimer != null) rewardTimer.Destroy();
                        startTime = DateTime.Now;
                        rewardTimer = timer.Repeat(spawnTime, 0, () =>
                        {
                            SpawnRewards(contOwner, itemID, amount);
                            startTime = DateTime.Now;
                        });

                        break;
                    }
                }
            }

            return;
        }

        object OnItemAction(Item item, string action, BasePlayer player)
        {
            Item eggItem;
            _spawnedItems.TryGetValue("6E657264", out eggItem);

            if (eggItem == null) return null;

            if (eggItem.GetOwnerPlayer() != null && eggItem.GetOwnerPlayer() == player && (action.Equals("consume")) && (item.info.shortname.StartsWith("maxhealthtea") || item.info.shortname.StartsWith("oretea") || item.info.shortname.StartsWith("woodtea"))) return true;
            if (item?.info?.shortname == null || item.text != "6E657264" || action != "unwrap") return null;

            if (_pluginConfig.BlockEggCrack && blockEggOpen)
            {
                var placeHolder = itemName != "The Golden Egg" ? "item" : "egg";

                player.ChatMessage(String.Format(GetMsg("Blocked", Convert.ToString(player.userID)), placeHolder));
                return true;
            }

            if (player != null && _pluginConfig.roamS.IncreaseHealth)
            {
                player.modifiers.Add(new List<ModifierDefintion>
                {
                    new ModifierDefintion
                    {
                        type = Modifier.ModifierType.Max_Health,
                        value = 0,
                        duration = 0.1f,
                        source = Modifier.ModifierSource.Tea
                    }
                });
                player.modifiers.SendChangesToClient();
            }

            if (player != null && _pluginConfig.roamS.IncreaseGather)
            {
                player.modifiers.Add(new List<ModifierDefintion>
                {
                    new ModifierDefintion
                    {
                        type = Modifier.ModifierType.Ore_Yield,
                        value = 0,
                        duration = 0.1f,
                        source = Modifier.ModifierSource.Tea
                    }
                });
                player.modifiers.SendChangesToClient();
            }

            storedData.DestroyTimers();

            if (markerTimer != null)
            {
                markerTimer.Destroy();
                markerTimer = null;
            }
            MarkerDelete();

            if (_pluginConfig.UseCustomList)
            {
                int index = UnityEngine.Random.Range(0, _pluginConfig.EggRewards.Count);

                try
                {
                    item.Remove();
                    player.SendNetworkUpdateImmediate();

                    var effect = "assets/bundled/prefabs/fx/gestures/eat_soft.prefab";
                    EffectNetwork.Send(new Effect(effect, player, 0, new Vector3(), new Vector3()), player.Connection);

                    var reward = ItemManager.CreateByName(_pluginConfig.EggRewards[index], 1);
                    player.GiveItem(reward);

                    return true;
                }
                catch
                {
                    return null;
                }
            }
            else
            {
                return null;
            }
        }

        void OnItemRemovedFromContainer(ItemContainer container, Item item)
        {
            if (container == null || item?.info?.shortname == null || item.text != "6E657264")
                return;

            var playerOwner = container.playerOwner;
            var newplayercontainer = item.GetOwnerPlayer();
            var contOwner = container.entityOwner;

            storedData.DestroyTimers();

            if (rewardTimer != null) rewardTimer.Destroy();
            if (delayTimer != null) delayTimer.Destroy();

            if (playerOwner != null && _pluginConfig.roamS.IncreaseHealth)
            {
                playerOwner.modifiers.Add(new List<ModifierDefintion>
                {
                    new ModifierDefintion
                    {
                        type = Modifier.ModifierType.Max_Health,
                        value = 0,
                        duration = 0.1f,
                        source = Modifier.ModifierSource.Tea
                    }
                });
                playerOwner.modifiers.SendChangesToClient();
            }

            if (playerOwner != null && _pluginConfig.roamS.IncreaseGather)
            {
                playerOwner.modifiers.Add(new List<ModifierDefintion>
                {
                    new ModifierDefintion
                    {
                        type = Modifier.ModifierType.Ore_Yield,
                        value = 0,
                        duration = 0.1f,
                        source = Modifier.ModifierSource.Tea
                    }
                });
                playerOwner.modifiers.SendChangesToClient();
            }

            NextTick(() =>
            {
                var player = item.GetOwnerPlayer();

                if (player != null)
                {
                    var playerI = players.FindPlayerById(Convert.ToString(player.userID));

                    storedData.OnEggMove(playerI);

                    if (markerTimer != null)
                    {
                        markerTimer.Destroy();
                        markerTimer = null;
                    }

                    if (delayTimer != null) delayTimer.Destroy();
                    MarkerDelete();

                    pos = player.transform.position;
                    safezone = false;
                    inPriv = false;
                    pop = false;
                    tod = false;

                    CreateMarkers(player);

                    markerTimer = timer.Repeat(_pluginConfig.markerS.PlayerMarkerRefreshTime, 0, () =>
                    {
                        pos = player.transform.position;
                        CreateMarkers(player);
                    });
                }
            });
        }

        public static bool IsBetween(TimeSpan start, TimeSpan end)
        {
            var time = DateTime.Now.TimeOfDay;
            // Start time and end time are in the same day
            if (start <= end)
                return time >= start && time <= end;
            // Start time and end time are on different days
            return time >= start || time <= end;
        }

        private void SetModifiers(BasePlayer player)
        {
            if (_pluginConfig.roamS.RoamTod)
            {
                TimeSpan tsStart = DateTime.Parse(_pluginConfig.roamS.RoamStart).TimeOfDay;
                TimeSpan tsEnd = DateTime.Parse(_pluginConfig.roamS.RoamEnd).TimeOfDay;

                if (IsBetween(tsStart, tsEnd))
                {
                    player.ChatMessage(String.Format(GetMsg("RoamDisabledTod", player.UserIDString), _pluginConfig.roamS.RoamStart, _pluginConfig.roamS.RoamEnd));
                    return;
                }
            }

            if (_pluginConfig.roamS.RoamPop != 0 && (covalence.Server.Players + ConVar.Admin.ServerInfo().Joining < _pluginConfig.roamS.RoamPop))
            {
                player.ChatMessage(String.Format(GetMsg("RoamDisabledPop", player.UserIDString), _pluginConfig.roamS.RoamPop));
                return;
            }

            if (_pluginConfig.roamS.IncreaseHealth)
            {
                if (player == null || player.modifiers == null) return;
                var startHealth = player.StartMaxHealth();
                var maxHealth = _pluginConfig.roamS.TotalHealth;
                var healthMultiplier = (maxHealth - startHealth) / startHealth;

                /*                 float healthIncrease;
                                if ((healthIncrease = player.modifiers.GetValue(Modifier.ModifierType.Max_Health, -1000f)) > -1000f &&
                                    Math.Abs(healthIncrease - healthMultiplier) > 0.1f) healthMultiplier += healthIncrease; */

                player.modifiers.Add(new List<ModifierDefintion>
                {
                    new ModifierDefintion
                    {
                        type = Modifier.ModifierType.Max_Health,
                        value = healthMultiplier,
                        duration = 2600f,
                        source = Modifier.ModifierSource.Tea
                    }
                });
                player.modifiers.SendChangesToClient();
            }

            if (_pluginConfig.roamS.IncreaseGather)
            {
                player.modifiers.Add(new List<ModifierDefintion>
                {
                    new ModifierDefintion
                    {
                        type = Modifier.ModifierType.Ore_Yield,
                        value = (_pluginConfig.roamS.GatherMultiplier / 2),
                        duration = 2600f,
                        source = Modifier.ModifierSource.Tea
                    }
                });
                player.modifiers.SendChangesToClient();
            }
            return;
        }

        object OnItemPickup(Item item, BasePlayer player)
        {
            if (item == null || player == null || item.text != "6E657264") return null;

            currentOwner = player.UserIDString;

            player.ChatMessage(String.Format(GetMsg("Pickup", Convert.ToString(player.userID)), itemName));

            if (_pluginConfig.roamS.IncreaseHealth || _pluginConfig.roamS.IncreaseGather)
                SetModifiers(player);

            SaveDataTimer();

            priv = false;

            if (player != null && _pluginConfig.NoPrivTime)
                priv = player?.GetBuildingPrivilege()?.IsAuthed(player) ?? false;

            if (!priv)
            {
                if (_pluginConfig.ServerPop == 0 || (covalence.Server.Players + ConVar.Admin.ServerInfo().Joining >= _pluginConfig.ServerPop))
                {
                    storedData.OnEggMove(player.IPlayer);
                }
            }

            if (markerTimer != null)
            {
                markerTimer.Destroy();
                markerTimer = null;
            }
            if (delayTimer != null) delayTimer.Destroy();
            MarkerDelete();

            pos = player.transform.position;
            safezone = false;
            inPriv = false;
            pop = false;
            tod = false;

            CreateMarkers(player);
            markerTimer = timer.Repeat(_pluginConfig.markerS.PlayerMarkerRefreshTime, 0, () =>
            {
                pos = player.transform.position;
                CreateMarkers(player);
            });

            return null;
        }

        void OnItemDropped(Item item, BaseEntity entity)
        {
            if (item == null || entity == null || item.text != "6E657264") return;

            if (markerTimer != null)
            {
                markerTimer.Destroy();
                markerTimer = null;
            }

            if (delayTimer != null) delayTimer.Destroy();
            //MarkerDelete();

            storedData.DestroyTimers();

            var player = BasePlayer.FindAwakeOrSleeping(currentOwner);

            if (player != null && _pluginConfig.roamS.IncreaseHealth)
            {
                player.modifiers.Add(new List<ModifierDefintion>
                {
                    new ModifierDefintion
                    {
                        type = Modifier.ModifierType.Max_Health,
                        value = 0,
                        duration = 0.1f,
                        source = Modifier.ModifierSource.Tea
                    }
                });
            }

            if (player != null && _pluginConfig.roamS.IncreaseGather)
            {
                player.modifiers.Add(new List<ModifierDefintion>
                {
                    new ModifierDefintion
                    {
                        type = Modifier.ModifierType.Ore_Yield,
                        value = 0,
                        duration = 0.1f,
                        source = Modifier.ModifierSource.Tea
                    }
                });
            }
            player.modifiers.SendChangesToClient();
        }

        object OnEntityKill(HackableLockedCrate crate)
        {
            if (crate == null || _spawnedCrates.Count == 0)
                return null;

            if (_spawnedCrates.ContainsKey(crate.net.ID.Value))
            {
                _spawnedCrates.Remove(crate.net.ID.Value);

                if (crateID.Contains(crate.net.ID.Value))
                    crateID.Remove(crate.net.ID.Value);

                if (_spawnedCrates.Count == 0)
                {
                    chinookID = 0;
                    if (_marker != null)
                    {
                        _marker.Kill();
                        _marker.SendUpdate();
                    }
                    if (crateMarkTimer != null) crateMarkTimer.Destroy();
                }
            }

            return null;
        }

        object OnItemRemove(Item item)
        {
            if (item.text != "6E657264" || item == null) return null;

            eggUID = 0;
            storedData._eggCreated = "";
            SaveData();

            if (_spawnedItems != null && _spawnedItems.ContainsKey("6E657264"))
            {
                _spawnedItems.Remove("6E657264");
            }

            var player = BasePlayer.FindAwakeOrSleeping(currentOwner);

            if (player != null && _pluginConfig.roamS.IncreaseHealth)
            {
                player.modifiers.Add(new List<ModifierDefintion>
                {
                    new ModifierDefintion
                    {
                        type = Modifier.ModifierType.Max_Health,
                        value = 0,
                        duration = 0.1f,
                        source = Modifier.ModifierSource.Tea
                    }
                });
            }

            if (player != null && _pluginConfig.roamS.IncreaseGather)
            {
                player.modifiers.Add(new List<ModifierDefintion>
                {
                    new ModifierDefintion
                    {
                        type = Modifier.ModifierType.Ore_Yield,
                        value = 0,
                        duration = 0.1f,
                        source = Modifier.ModifierSource.Tea
                    }
                });
            }
            if (player != null)
                player.modifiers.SendChangesToClient();

            Subscribe(nameof(CanLootEntity));
            Unsubscribe(nameof(OnItemAddedToContainer));
            Unsubscribe(nameof(OnItemRemovedFromContainer));
            Unsubscribe(nameof(OnItemPickup));
            Unsubscribe(nameof(OnItemDropped));
            if (_pluginConfig.tpveS.DisableTruePVE) Unsubscribe(nameof(CanEntityTakeDamage));
            if (_pluginConfig.BlockEggCrack) Unsubscribe(nameof(OnEntityTakeDamage));
            if (_pluginConfig.roamS.IncreasePickup)
                Unsubscribe(nameof(OnCollectiblePickup));
            if (_pluginConfig.crateS.crateEvent)
            {
                Unsubscribe(nameof(OnHelicopterDropCrate));
                Unsubscribe(nameof(OnCrateDropped));
                Unsubscribe(nameof(CanHackCrate));
            }
            if (_pluginConfig.UseBlacklist)
            {
                Unsubscribe(nameof(OnPlayerCommand));
            }

            server.Broadcast($"{itemName} has been lost!! It can now be found again in a random crate");

            if (!String.IsNullOrEmpty(_pluginConfig.sendWebhook) && _pluginConfig.sendWebhook != "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks")
            {
                new DiscordWebhook()
                .AddEmbed()
                    .SetDescription($"{itemName.ToUpper()} IS LOST!")
                    .SetColor(3447003)
                    .AddField("It can now be found in crates", "Good luck!", true)
                    .SetTimestamp(DateTime.UtcNow)
                    .AddThumbnail(_pluginConfig.customItemS.ItemLostDiscord)
                    .EndEmbed()
                    .Send(this, _pluginConfig.sendWebhook);
            }

            NextTick(() =>
            {
                storedData.DestroyTimers();
                if (rewardTimer != null) rewardTimer.Destroy();
                if (markerTimer != null)
                {
                    markerTimer.Destroy();
                    markerTimer = null;
                }
                if (delayTimer != null) delayTimer.Destroy();
                if (blockTimer != null) blockTimer.Destroy();
                if (crateEventTimer != null) crateEventTimer.Destroy();
                MarkerDelete();

                currentOwner = "";
            });

            return null;
        }

        private void OnCollectiblePickup(CollectibleEntity collectible, BasePlayer player)
        {
            if (player == null || collectible == null) return;

            Item eggItem;
            _spawnedItems.TryGetValue("6E657264", out eggItem);

            if (eggItem == null) return;

            if (eggItem.GetOwnerPlayer() == null || eggItem.GetOwnerPlayer() != player)
                return;

            if (_pluginConfig.roamS.RoamTod)
            {
                TimeSpan tsStart = DateTime.Parse(_pluginConfig.roamS.RoamStart).TimeOfDay;
                TimeSpan tsEnd = DateTime.Parse(_pluginConfig.roamS.RoamEnd).TimeOfDay;

                if (IsBetween(tsStart, tsEnd))
                {
                    return;
                }
            }

            if (_pluginConfig.roamS.RoamPop != 0 && (covalence.Server.Players + ConVar.Admin.ServerInfo().Joining < _pluginConfig.roamS.RoamPop))
                return;

            foreach (ItemAmount item in collectible.itemList)
            {
                float modifier = _pluginConfig.roamS.PickupMultiplier;
                item.amount = (int)(item.amount * modifier);
            }
        }

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (eggUID == 0 || entity == null || hitInfo == null || entity.IsNpc || entity is BasePlayer || hitInfo.Initiator == null || hitInfo.Initiator.transform == null || hitInfo?.InitiatorPlayer == null)
                return;

            if (!(CheckDamage(entity, hitInfo))) return;
            if (hitInfo.InitiatorPlayer.userID == entity.OwnerID) return;

            blockEggOpen = true;

            if (blockTimer != null) blockTimer.Destroy();
            {
                blockTimer = timer.Once(_pluginConfig.BlockInterval, () =>
                {
                    blockEggOpen = false;
                    buildID.Clear();
                });
            }
        }

        object CanEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (eggUID == 0 || hitInfo == null || entity.IsNpc || entity?.transform == null || hitInfo?.Initiator == null || hitInfo?.InitiatorPlayer == null)
                return null;

            if (CheckDamage(entity, hitInfo))
            {
                OnProcessPlayerEntity(entity, hitInfo);
                return (object)true;
            }

            return null;
        }

        object OnProcessPlayerEntity(BaseEntity entity, HitInfo info)
        {
            return true;
        }

        bool CheckDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            Item item;
            _spawnedItems.TryGetValue("6E657264", out item);

            if (item == null) return false;

            var eggOwner = item.GetEntityOwner();

            Vector3 eggPos = eggOwner != null ? eggOwner.transform.position : pos;

            float dist = Vector3.Distance(hitInfo.PointEnd, eggPos);

            if (!(entity is BasePlayer))
            {
                BuildingPrivlidge privilege = entity?.GetBuildingPrivilege() ?? null;

                if (privilege == null) return false;

                if (buildID != null && buildID.Contains(privilege.buildingID))
                {
                    return true;
                }

                if (CheckOwner(entity, hitInfo.InitiatorPlayer, privilege))
                {
                    if (item.GetOwnerPlayer() != null && item.GetOwnerPlayer() == hitInfo?.InitiatorPlayer)
                    {
                        return false;
                    }
                    if (hitInfo.InitiatorPlayer.UserIDString == currentOwner)
                    {
                        return false;
                    }

                    if (!buildID.Contains(privilege.buildingID))
                        buildID.Add(privilege.buildingID);
                    return true;
                }
            }

            if ((entity is BasePlayer))
            {
                var nearbyTargets = Pool.GetList<BasePlayer>();
                Vis.Entities(entity.transform.position, _pluginConfig.tpveS.DamageDistance, nearbyTargets, blockLayer);

                if (nearbyTargets.Count > 0 && dist <= _pluginConfig.tpveS.DamageDistance)
                {
                    foreach (BasePlayer nearbyTarget in nearbyTargets)
                    {
                        if (nearbyTarget.IsNpc) continue;
                        if (nearbyTarget == entity && nearbyTarget.UserIDString == currentOwner)
                        {
                            if (hitInfo.ProjectileDistance > _pluginConfig.tpveS.DamageDistance)
                            {
                                Pool.FreeList(ref nearbyTargets);
                                return false;
                            }
                        }
                        if (nearbyTarget.UserIDString != currentOwner && hitInfo.InitiatorPlayer.UserIDString != currentOwner) continue;

                        Pool.FreeList(ref nearbyTargets);
                        return true;
                    }
                }

                Pool.FreeList(ref nearbyTargets);
                return false;
            }
            return false;
        }

        bool CheckOwner(BaseEntity target, BasePlayer source, BuildingPrivlidge priv = null)
        {
            if (target.OwnerID.IsSteamId())
            {
                BuildingPrivlidge privilege = target.GetBuildingPrivilege();
                if (privilege == null) return false;

                Item item;
                _spawnedItems.TryGetValue("6E657264", out item);

                if (item == null) return false;

                var eggOwner = item.GetEntityOwner();

                if (eggOwner == null) return false;

                var eggPriv = eggOwner.GetBuildingPrivilege();
                if (eggPriv == null) return false;

                var priv1 = eggPriv.buildingID;
                var priv2 = priv.buildingID;

                var authlist = privilege.authorizedPlayers.Select(x => x.userid).ToList();

                foreach (var auth in authlist)
                {
                    if (Convert.ToString(auth) == currentOwner && priv1 == priv2)
                    {
                        return true;
                    }
                }
            }
            return false;
        }
        private List<StoredData.UserData> leaderList = new List<StoredData.UserData>();

        private void CmdRunCommand(IPlayer player, string cmd, string[] args)
        {
            if (args.Length >= 1)
            {
                switch (args[0].ToLower())
                {
                    case "help":
                        {
                            var placeHolder = itemName != "The Golden Egg" ? "item" : "egg";

                            if (_pluginConfig.markerS.playerMarker)
                                player.Message(GetMsg("Help1", player.Id));
                            player.Message(String.Format(GetMsg("Help2", player.Id), placeHolder));
                            player.Message(String.Format(GetMsg("Help3", player.Id), placeHolder));
                            if (_pluginConfig.roamS.IncreaseGather || _pluginConfig.roamS.IncreaseHealth || _pluginConfig.roamS.IncreasePickup)
                                player.Message(String.Format(GetMsg("Help9", player.Id), placeHolder));
                            player.Message(String.Format(GetMsg("Help4", player.Id), _pluginConfig.customItemS.Command));
                            player.Message(String.Format(GetMsg("Help5", player.Id), _pluginConfig.customItemS.Command));
                            if (_pluginConfig.PinpointEggCommand)
                                player.Message(String.Format(GetMsg("Help6", player.Id), _pluginConfig.customItemS.Command, placeHolder));
                            if (_pluginConfig.KillTime != 0)
                                player.Message(String.Format(GetMsg("Help10", player.Id), _pluginConfig.customItemS.Command, placeHolder));
                            player.Message(String.Format(GetMsg("Help7", player.Id), _pluginConfig.customItemS.Command));
                            if (player.IsAdmin)
                            {
                                player.Message(String.Format(GetMsg("Help8", player.Id), _pluginConfig.customItemS.Command, placeHolder));
                                player.Message(String.Format(GetMsg("Help11", player.Id), _pluginConfig.customItemS.Command));
                                player.Message(String.Format(GetMsg("Help12", player.Id), _pluginConfig.customItemS.Command, placeHolder));
                                player.Message(String.Format(GetMsg("Help13", player.Id), _pluginConfig.customItemS.Command, placeHolder));
                            }
                        }
                        return;

                    case "find":
                        {
                            if (eggUID == 0) return;

                            if (!player.HasPermission(permissionUse))
                            {
                                player.Message(GetMsg("Perms", player.Id));
                                return;
                            }

                            if (_pluginConfig.PinpointEggCommand)
                            {
                                var basePlayer = player.Object as BasePlayer;
                                double distance = Math.Round(Vector3.Distance(basePlayer.transform.position, pos), 2);
                                EggText(basePlayer, pos, String.Format(GetMsg("DisplayText", player.Id), itemName));
                            }
                        }
                        return;

                    case "time":
                        {
                            if (eggUID == 0 || amount == 0) return;

                            TimeSpan t = DateTime.Now - startTime;
                            var countdown = new TimeSpan(0, 0, spawnTime).Subtract(t).ToString(@"hh\:mm\:ss");

                            if (String.IsNullOrEmpty(cleanName)) cleanName = "Resource";
                            player.Message(string.Format(GetMsg("Generation", player.Id), amount, cleanName, countdown));
                        }
                        return;

                    case "list":
                        {
                            var resourceList = new List<string>();

                            if (_pluginConfig.resourceS.ScrapSpawnAmount != 0)
                                resourceList.Add($"Scrap ({TimeSpan.FromSeconds(_pluginConfig.resourceS.ResourceSpawnTime)})");
                            if (_pluginConfig.resourceS.HQMSpawnAmount != 0)
                                resourceList.Add($"High Quality Metal ({TimeSpan.FromSeconds(_pluginConfig.resourceS.ResourceSpawnTime)})");
                            if (_pluginConfig.resourceS.LowGradeSpawnAmount != 0)
                                resourceList.Add($"Low Grade Fuel ({TimeSpan.FromSeconds(_pluginConfig.resourceS.ResourceSpawnTime)})");
                            if (_pluginConfig.resourceS.FragsSpawnAmount != 0)
                                resourceList.Add($"Metal Fragments ({TimeSpan.FromSeconds(_pluginConfig.resourceS.ResourceSpawnTime)})");
                            if (_pluginConfig.resourceS.AllowSulfurCooked)
                                resourceList.Add($"Cooked Sulfur ({TimeSpan.FromSeconds(_pluginConfig.resourceS.ResourceSpawnTime)})");
                            if (_pluginConfig.resourceS.AllowSulfurOre)
                                resourceList.Add($"Sulfur Ore ({TimeSpan.FromSeconds(_pluginConfig.resourceS.ResourceSpawnTime)})");
                            if (!string.IsNullOrEmpty(_pluginConfig.resourceS.CustomItem1))
                                resourceList.Add($"{_pluginConfig.resourceS.CustomItem1} ({TimeSpan.FromSeconds(_pluginConfig.resourceS.CustomTime1)})");
                            if (!string.IsNullOrEmpty(_pluginConfig.resourceS.CustomItem2))
                                resourceList.Add($"{_pluginConfig.resourceS.CustomItem2} ({TimeSpan.FromSeconds(_pluginConfig.resourceS.CustomTime2)})");
                            if (!string.IsNullOrEmpty(_pluginConfig.resourceS.CustomItem3))
                                resourceList.Add($"{_pluginConfig.resourceS.CustomItem3} ({TimeSpan.FromSeconds(_pluginConfig.resourceS.CustomTime3)})");

                            player.Message(string.Format(GetMsg("Resource", player.Id), String.Join(", ", resourceList)));
                        }
                        return;

                    case "leader":
                        {
                            string message = GetMsg("EggLeaderboard", player.Id);
                            storedData.GetEggLeaders(leaderList);

                            for (int i = 0; i < Math.Min(5, leaderList.Count); i++)
                            {
                                message += string.Format(GetMsg("LeaderList"), leaderList[i].displayName, FormatTime(leaderList[i].eggtime), FormatTime(leaderList[i].TeamTotal));
                            }
                            player.Message(message);
                        }
                        return;

                    case "kill":
                        {
                            if (!player.IsAdmin)
                            {
                                return;
                            }

                            if (_spawnedItems != null)
                            {
                                foreach (var _item in _spawnedItems.ToList())
                                {
                                    if (_item.Key == "6E657264")
                                    {
                                        Item item = _item.Value;
                                        if (item != null)
                                        {
                                            item.Remove();
                                            _spawnedItems.Remove(_item.Key);
                                        }
                                    }
                                }
                            }
                        }
                        return;

                    case "expire":
                        {
                            if (eggUID == 0) return;

                            if (_pluginConfig.KillTime == 0) return;

                            var futureDate = (DateTime.Parse((string)storedData._eggCreated)).AddMinutes(_pluginConfig.KillTime);
                            var minutes = (futureDate - DateTime.Now).TotalMinutes;

                            var days = ((int)minutes / 1440);
                            var hours = ((int)minutes % 1440) / 60;
                            var mins = (int)minutes % 60;

                            player.Message(string.Format(GetMsg("Expire", player.Id), itemName, days, hours, mins));
                        }
                        return;

                    case "event":
                        {
                            if (!player.IsAdmin)
                                return;

                            if (chinookID != 0)
                            {
                                Puts("The chinook event is already running");
                                return;
                            }

                            crateID.Clear();
                            _spawnedCrates.Clear();

                            if (_marker != null)
                            {
                                _marker.Kill();
                                _marker.SendUpdate();
                            }
                            if (crateMarkTimer != null)
                                crateMarkTimer.Destroy();

                            var chinook = GameManager.server.CreateEntity("assets/prefabs/npc/ch47/ch47scientists.entity.prefab") as CH47HelicopterAIController;
                            if (chinook == null)
                            {
                                return;
                            }
                            chinook.numCrates = _pluginConfig.crateS.numCrates;

                            chinook.TriggeredEventSpawn();
                            chinook.Spawn();

                            chinookID = chinook.net.ID.Value;
                        }
                        return;

                    case "winner":
                        {
                            if (!player.IsAdmin)
                                return;

                            if (string.IsNullOrEmpty(_pluginConfig.GroupName) || string.IsNullOrEmpty(_pluginConfig.GroupDuration))
                            {
                                Logger.Info("Either the group name or duration is blank");
                                return;
                            }

                            storedData.GetEggLeaders(leaderList);
                            if (leaderList.Count == 0) return;

                            var leader = leaderList.First();
                            if (leader == null) return;

                            foreach (var user in storedData._eggPossession)
                            {
                                if (storedData._eggPossession[user.Key] == leader)
                                {
                                    if (user.Value.Team?.Count > 0)
                                    {
                                        foreach (var teamMember in user.Value.Team)
                                        {
                                            AddToGroupTimed(teamMember.ToString(), _pluginConfig.GroupName, _pluginConfig.GroupDuration);
                                        }
                                    }
                                    else
                                    {
                                        AddToGroupTimed(user.Key.ToString(), _pluginConfig.GroupName, _pluginConfig.GroupDuration);
                                    }
                                }
                            }
                            server.Broadcast(String.Format(GetMsg("Winner"), leader.displayName, itemName));
                        }
                        return;

                    case "purge":
                        {
                            if (!player.IsAdmin)
                                return;

                            if (_spawnedItems != null)
                            {
                                foreach (var _item in _spawnedItems.ToList())
                                {
                                    if (_item.Key == "6E657264")
                                    {
                                        Item item = _item.Value;
                                        if (item != null)
                                        {
                                            item.Remove();
                                            _spawnedItems.Remove(_item.Key);
                                        }
                                    }
                                }
                            }

                            data.Clear();
                            data.Save();
                            storedData = data.ReadObject<StoredData>();
                            if (storedData == null)
                            {
                                storedData = new StoredData();
                            }

                            Log("Egg destroyed and player data cleared");
                        }
                        return;
                }
            }
        }

        private void AddToGroupTimed(string userId, string groupName, string duration)
        {
            if (TimedPermissions == null)
            {
                LogError($"Unable to add user {userId} to group {groupName} because TimedPermissions is not loaded.");
                return;
            }

            server.Command($"addgroup {userId} {groupName} {duration}");
        }

        object OnHelicopterDropCrate(CH47HelicopterAIController heli)
        {
            if (heli.net.ID.Value == chinookID)
            {
                crateDrop = true;
                timer.In(0.5f, () =>
                {
                    heli.DropCrate();
                });

                if (heli.numCrates == 1)
                {
                    server.Broadcast(String.Format(GetMsg("EventStart"), _pluginConfig.crateS.numCrates, itemName));
                    runEvent();
                }
            }

            return null;
        }

        void OnCrateDropped(HackableLockedCrate crate)
        {
            if (crate == null)
                return;

            NextTick(() =>
            {
                if (crateDrop == true)
                {
                    crateID.Add(crate.net.ID.Value);

                    if (!_spawnedCrates.ContainsKey(crate.net.ID.Value))
                        _spawnedCrates.Add(crate.net.ID.Value, crate);

                    crate.shouldDecay = true;

                    if (_pluginConfig.crateS.crateMarker && crateID.Count == 1)
                    {
                        cratePos = crate.ServerPosition;
                        SpawnMarker();
                        crateMarkTimer = timer.Repeat(30, 0, () =>
                        {
                            SpawnMarker();
                        });
                    }

                    timer.In(8f, () =>
                    {
                        crateDrop = false;
                    });
                }
            });
        }

        private static Color GetColor(string hex)
        {
            Color color;
            return ColorUtility.TryParseHtmlString(hex, out color) ? color : Color.yellow;
        }

        public void SpawnMarker()
        {
            if (_marker != null)
            {
                _marker.Kill();
                _marker.SendUpdate();
            }

            if (crateID.Count == 0)
                return;

            HackableLockedCrate crate;
            _spawnedCrates.TryGetValue(crateID[0], out crate);

            if (crate == null) return;

            _marker = (MapMarkerGenericRadius)GameManager.server.CreateEntity("assets/prefabs/tools/map/genericradiusmarker.prefab", cratePos);
            _marker.color1 = GetColor(_pluginConfig.crateS.crateColor1);
            _marker.color2 = GetColor(_pluginConfig.crateS.crateColor2);
            _marker.alpha = _pluginConfig.crateS.crateMarkerAlpha;
            _marker.radius = _pluginConfig.crateS.crateMarkerRadius;
            _marker.Spawn();
            _marker.SetParent(crate);
            _marker.transform.localPosition = Vector3.zero;
            _marker.SendUpdate();
        }

        object CanHackCrate(BasePlayer player, HackableLockedCrate crate)
        {
            if (player == null || crate == null)
                return null;

            if (crateID.Contains(crate.net.ID.Value))
            {
                Item eggItem;
                _spawnedItems.TryGetValue("6E657264", out eggItem);

                if (eggItem == null) return null;

                var inv = new List<Item>();
                player.inventory.GetAllItems(inv);
                if (inv.Contains(eggItem))
                {
                    crate.hackSeconds = HackableLockedCrate.requiredHackSeconds - _pluginConfig.crateS.crateTimer;

                    if (_pluginConfig.crateS.addedItems > 0)
                    {
                        crate.inventory.capacity = 35;
                        for (int i = 0; i < _pluginConfig.crateS.addedItems; i++)
                        {
                            if (crate.lootDefinition != null)
                                crate.lootDefinition.SpawnIntoContainer(crate.inventory);
                        }
                    }

                    server.Broadcast(String.Format(GetMsg("CrateHacked"), _pluginConfig.crateS.crateTimer));

                    return null;
                }

                player.ChatMessage(String.Format(GetMsg("EggHack", Convert.ToString(player.userID)), itemName));
                return false;
            }
            return null;
        }

        private static string FormatTime(double time)
        {
            TimeSpan dateDifference = TimeSpan.FromSeconds((float)time);
            int days = dateDifference.Days;
            int hours = dateDifference.Hours;
            hours += (days * 24);
            return string.Format("{0:00}h:{1:00}m:{2:00}s", hours, dateDifference.Minutes, dateDifference.Seconds);
        }

        private void AddCommands()
        {
            if (String.IsNullOrEmpty(_pluginConfig.customItemS.Command))
            {
                _pluginConfig.customItemS.Command = "egg";
                SaveConfig();
            }

            AddCovalenceCommand(_pluginConfig.customItemS.Command, nameof(CmdRunCommand));
        }

        void EggText(BasePlayer player, Vector3 eggPos, string text)
        {
            if (!player || !player.IsConnected || eggPos == Vector3.zero || string.IsNullOrEmpty(text))
                return;

            bool isAdmin = player.IsAdmin;

            try
            {
                if (!player.IsAdmin)
                {
                    var uid = player.userID;

                    if (!allowDraw.Contains(uid))
                    {
                        allowDraw.Add(uid);
                        timer.Once(15f, () => allowDraw.Remove(uid));
                    }

                    player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
                    player.SendNetworkUpdateImmediate();
                }

                if (player.IsAdmin || allowDraw.Contains(player.userID))
                    player.SendConsoleCommand("ddraw.text", 15f, Color.yellow, eggPos, text);
            }
            catch (Exception ex)
            {
                Puts("Error drawing eggtext: {0} -- {1}", ex.Message, ex.StackTrace);
            }

            if (!isAdmin)
            {
                if (player.HasPlayerFlag(BasePlayer.PlayerFlags.IsAdmin))
                {
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                    player.SendNetworkUpdateImmediate();
                }
            }
        }

        private string GetMsg(string key, string userId = null, params object[] args) => lang.GetMessage(key, this, userId);

        private int GetSpawnTime(string shortname)
        {
            int spawnTime = 0;

            if (shortname == _pluginConfig.resourceS.CustomItem1)
                spawnTime = _pluginConfig.resourceS.CustomTime1;
            else if (shortname == _pluginConfig.resourceS.CustomItem2)
                spawnTime = _pluginConfig.resourceS.CustomTime2;
            else if (shortname == _pluginConfig.resourceS.CustomItem3)
                spawnTime = _pluginConfig.resourceS.CustomTime3;
            else spawnTime = _pluginConfig.resourceS.ResourceSpawnTime;

            return spawnTime;
        }

        private int GetResourceAmount(string shortname)
        {
            int resourceAmount = 0;

            if (shortname == "metal.refined")
                resourceAmount = _pluginConfig.resourceS.HQMSpawnAmount;
            else if (shortname == "lowgradefuel")
                resourceAmount = _pluginConfig.resourceS.LowGradeSpawnAmount;
            else if (shortname == "metal.fragments")
                resourceAmount = _pluginConfig.resourceS.FragsSpawnAmount;
            else if (shortname == "scrap")
                resourceAmount = _pluginConfig.resourceS.ScrapSpawnAmount;
            else if (shortname == "sulfur")
                resourceAmount = _pluginConfig.resourceS.SulfurCookedAmount;
            else if (shortname == "sulfur.ore")
                resourceAmount = _pluginConfig.resourceS.SulfurOreAmount;
            else if (shortname == _pluginConfig.resourceS.CustomItem1)
                resourceAmount = _pluginConfig.resourceS.CustomAmount1;
            else if (shortname == _pluginConfig.resourceS.CustomItem2)
                resourceAmount = _pluginConfig.resourceS.CustomAmount2;
            else if (shortname == _pluginConfig.resourceS.CustomItem3)
                resourceAmount = _pluginConfig.resourceS.CustomAmount3;
            else resourceAmount = 0;

            return resourceAmount;
        }

        void SpawnRewards(BaseEntity contOwner, int resource, int amount)
        {
            if (contOwner.name.Contains("corpse") || resource == 0 || amount == 0)
            {
                rewardTimer.Destroy();
                return;
            }

            Item item = ItemManager.CreateByItemID(resource, amount);

            var parentContainer = (BaseEntity)contOwner as StorageContainer;

            item.MoveToContainer(parentContainer.inventory);

            return;
        }

        [HookMethod("OnPlayerEnteredRaidableBase")]
        void OnPlayerEnteredRaidableBase(BasePlayer player, Vector3 raidPos, bool allowPVP)
        {
            if (eggUID == 0 || _pluginConfig.raidBaseDestroy == 0) return;

            var placeHolder = itemName != "The Golden Egg" ? "item" : "egg";
            player.ChatMessage(String.Format(GetMsg("RaidBaseDestroy", Convert.ToString(player.userID)), placeHolder, _pluginConfig.raidBaseDestroy));
            raidBaseTimer = timer.In(_pluginConfig.raidBaseDestroy, () =>
            {
                if (_spawnedItems != null)
                {
                    foreach (var _item in _spawnedItems.ToList())
                    {
                        if (_item.Key == "6E657264")
                        {
                            Item item = _item.Value;
                            if (item != null)
                            {
                                item.Remove();
                                _spawnedItems.Remove(_item.Key);
                            }
                        }
                    }
                    raidBaseTimer = null;
                }
            });
        }

        [HookMethod("OnPlayerExitedRaidableBase")]
        void OnPlayerExitedRaidableBase(BasePlayer player, Vector3 raidPos, bool allowPVP)
        {
            if (raidBaseTimer != null)
            {
                raidBaseTimer.Destroy();
                raidBaseTimer = null;
            }
        }

        void CreateMarkers(BasePlayer player = null)
        {

            if (_pluginConfig.BlockSafeZone && player != null)
            {
                if (!(player.InSafeZone()) && safezone)
                {
                    storedData.OnEggMove(player.IPlayer);
                    safezone = false;

                    if (_pluginConfig.safeDestroy > 0)
                    {
                        if (safeTimer != null)
                        {
                            safeTimer.Destroy();
                            safeTimer = null;
                        }
                    }
                }

                if (player.InSafeZone() && !safezone)
                {
                    var placeHolder = itemName != "The Golden Egg" ? "item" : "egg";
                    player.ChatMessage(String.Format(GetMsg("SafeZone", Convert.ToString(player.userID)), placeHolder));
                    storedData.DestroyTimers();
                    safezone = true;

                    if (_pluginConfig.safeDestroy > 0 && safeTimer == null)
                    {
                        player.ChatMessage(String.Format(GetMsg("SafeDestroy", Convert.ToString(player.userID)), placeHolder, _pluginConfig.safeDestroy));
                        safeTimer = timer.In(_pluginConfig.safeDestroy, () =>
                        {
                            if (_spawnedItems != null)
                            {
                                foreach (var _item in _spawnedItems.ToList())
                                {
                                    if (_item.Key == "6E657264")
                                    {
                                        Item item = _item.Value;
                                        if (item != null)
                                        {
                                            item.Remove();
                                            _spawnedItems.Remove(_item.Key);
                                        }
                                    }
                                }
                                safeTimer = null;
                            }
                        });
                    }
                }
            }

            if (_pluginConfig.blockedDestroy > 0 && player != null)
            {
                blocked = player?.IsBuildingBlocked() ?? false;
                var placeHolder = itemName != "The Golden Egg" ? "item" : "egg";

                if (!blocked && isBlocked)
                {
                    isBlocked = false;

                    if (_pluginConfig.blockedDestroy > 0)
                    {
                        if (buildTimer != null)
                        {
                            buildTimer.Destroy();
                            buildTimer = null;
                        }
                    }
                }

                if (blocked && !isBlocked)
                {
                    isBlocked = true;

                    if (buildTimer == null)
                    {
                        player.ChatMessage(String.Format(GetMsg("blockDestroy", Convert.ToString(player.userID)), placeHolder, _pluginConfig.blockedDestroy));
                        buildTimer = timer.In(_pluginConfig.blockedDestroy, () =>
                        {
                            if (_spawnedItems != null)
                            {
                                foreach (var _item in _spawnedItems.ToList())
                                {
                                    if (_item.Key == "6E657264")
                                    {
                                        Item item = _item.Value;
                                        if (item != null)
                                        {
                                            item.Remove();
                                            _spawnedItems.Remove(_item.Key);
                                        }
                                    }
                                }
                            }
                            buildTimer = null;
                        });

                    }
                }
            }

            if (_pluginConfig.NoPrivTime && player != null)
            {
                priv = player?.GetBuildingPrivilege()?.IsAuthed(player) ?? false;

                if (!priv && inPriv)
                {
                    storedData.OnEggMove(player.IPlayer);
                    inPriv = false;
                }

                if (priv && !inPriv)
                {
                    storedData.DestroyTimers();
                    inPriv = true;
                }
            }

            if (_pluginConfig.ServerPop != 0 && player != null)
            {
                if ((covalence.Server.Players + ConVar.Admin.ServerInfo().Joining >= _pluginConfig.ServerPop) && pop)
                {
                    storedData.OnEggMove(player.IPlayer);
                    pop = false;
                }

                if ((covalence.Server.Players + ConVar.Admin.ServerInfo().Joining < _pluginConfig.ServerPop) && !pop)
                {
                    storedData.DestroyTimers();
                    pop = true;
                }
            }

            if (_pluginConfig.TimeOfDay && player != null)
            {
                TimeSpan tsStart = DateTime.Parse(_pluginConfig.StartTime).TimeOfDay;
                TimeSpan tsEnd = DateTime.Parse(_pluginConfig.EndTime).TimeOfDay;

                if (!IsBetween(tsStart, tsEnd) && tod)
                {
                    storedData.OnEggMove(player.IPlayer);
                    tod = false;
                }

                if (IsBetween(tsStart, tsEnd) && !tod)
                {
                    storedData.DestroyTimers();
                    tod = true;
                }
            }

            if (_pluginConfig.crateS.crateEvent && _pluginConfig.crateS.crateTOD && (covalence.Server.Players + ConVar.Admin.ServerInfo().Joining >= _pluginConfig.crateS.cratePop))
            {
                TimeSpan tsStart = DateTime.Parse(_pluginConfig.crateS.eventStartTime).TimeOfDay;
                TimeSpan tsEnd = DateTime.Parse(_pluginConfig.crateS.eventEndTime).TimeOfDay;

                if (IsBetween(tsStart, tsEnd) && isRunning == false)
                {
                    if (chinookID != 0)
                    {
                        Puts("The chinook event is already running");
                        isRunning = true;
                        goto MoveOn;
                    }

                    isRunning = true;
                    var timePeriod = (DateTime.Parse(_pluginConfig.crateS.eventEndTime) - DateTime.Now).TotalSeconds;

                    timer.In(UnityEngine.Random.Range(0, (float)timePeriod), () =>
                    {
                        Puts("The chinook event has started");

                        crateID.Clear();
                        _spawnedCrates.Clear();

                        if (_marker != null)
                        {
                            _marker.Kill();
                            _marker.SendUpdate();
                        }
                        if (crateMarkTimer != null)
                            crateMarkTimer.Destroy();

                        var chinook = GameManager.server.CreateEntity("assets/prefabs/npc/ch47/ch47scientists.entity.prefab") as CH47HelicopterAIController;
                        /*                         if (chinook == null)
                                                {
                                                    return;
                                                } */

                        chinook.numCrates = _pluginConfig.crateS.numCrates;

                        chinook.TriggeredEventSpawn();
                        chinook.Spawn();

                        chinookID = chinook.net.ID.Value;
                    });
                }

                if (!IsBetween(tsStart, tsEnd) && isRunning == true)
                {
                    isRunning = false;
                }
            }


        MoveOn:
            if (_pluginConfig.roamS.RoamMessage)
            {
                var dist = Vector3.Distance(pos, lastPosition);

                if (dist > 50 && moveTimer == null && lastPosition != Vector3.zero)
                {
                    server.Broadcast(String.Format(GetMsg("Roaming"), itemName));

                    moveTimer = timer.Once(300f, () =>
                    {
                        moveTimer.Destroy();
                        moveTimer = null;
                    });
                }
                lastPosition = pos;
            }

            if (!_pluginConfig.markerS.playerMarker) return;

            NextTick(() =>
            {
                MarkerDelete();
                MapMarkerGenericRadius customMarker;
                customMarker = GameManager.server.CreateEntity("assets/prefabs/tools/map/genericradiusmarker.prefab", pos) as MapMarkerGenericRadius;
                customMarker.alpha = _pluginConfig.markerS.MarkerAlpha;

                if (!ColorUtility.TryParseHtmlString(_pluginConfig.markerS.color1, out customMarker.color1))
                {
                    customMarker.color1 = Color.red;
                    PrintError($"Invalid map marker color1: {_pluginConfig.markerS.color1}");
                }

                if (!ColorUtility.TryParseHtmlString(_pluginConfig.markerS.color2, out customMarker.color2))
                {
                    customMarker.color2 = Color.black;
                    PrintError($"Invalid map marker color2: {_pluginConfig.markerS.color2}");
                }

                customMarker.radius = _pluginConfig.markerS.MarkerRadius;
                eggRadMarker.Add(customMarker);

                if (_pluginConfig.markerS.AddVendingMarker)
                {
                    VendingMachineMapMarker customVendingMarker;
                    customVendingMarker = GameManager.server.CreateEntity("assets/prefabs/deployable/vendingmachine/vending_mapmarker.prefab", pos) as VendingMachineMapMarker;
                    if (customVendingMarker == null) return;
                    customVendingMarker.markerShopName = _pluginConfig.markerS.VendingMarkerName;
                    eggVendMarker.Add(customVendingMarker);

                    foreach (var Vend in eggVendMarker)
                    {
                        Vend.Spawn();
                        //MapMarker.serverMapMarkers.Remove(Vend); //Enable to remove marker from Rust+
                    }
                }

                foreach (var Rad in eggRadMarker)
                {
                    Rad.Spawn();
                    //MapMarker.serverMapMarkers.Remove(Rad); //Enable to remove marker from Rust+
                    Rad.SendUpdate();
                }
            });
        }

        void MarkerDelete()
        {
            foreach (var Rad in eggRadMarker)
            {
                if (Rad != null)
                {
                    Rad.Kill();
                    Rad.SendUpdate();
                }
            }

            if (_pluginConfig.markerS.AddVendingMarker)
            {
                foreach (var Vend in eggVendMarker)
                {
                    if (Vend != null) Vend.Kill();
                }
                eggVendMarker.Clear();
            }

            eggRadMarker.Clear();
        }

        private void LoadData()
        {
            data = Interface.Oxide.DataFileSystem.GetFile("TheGoldenEgg/player_data");
            storedData = data.ReadObject<StoredData>();
            if (storedData == null)
                storedData = new StoredData();
        }

        private void SaveDataTimer()
        {
            if (saveTimer != null) return;

            saveTimer = timer.Repeat(_pluginConfig.SaveInterval, 0, () =>
            {
                storedData.GetTotals();
                SaveData();
            });
        }

        private void SaveData() => data.WriteObject(storedData);

        object OnPlayerCommand(BasePlayer player, string command, string[] args)
        {
            if (!player.IsValid() || player.transform == null)
            {
                return null;
            }

            Item eggItem;
            _spawnedItems.TryGetValue("6E657264", out eggItem);

            if (eggItem == null) return null;
            var inv = new List<Item>();
            player.inventory.GetAllItems(inv);
            if (inv.Contains(eggItem))
            {
                if (_pluginConfig.UseBlacklist && _pluginConfig.BlacklistedCommands.Any(entry => entry.Replace("/", "").Equals(command, StringComparison.OrdinalIgnoreCase)))
                {
                    player.ChatMessage(String.Format(GetMsg("CommandDisabled", player.UserIDString), itemName));
                    return true;
                }
            }

            return null;
        }

        private class StoredData
        {
            [JsonProperty]
            internal Hash<ulong, UserData> _eggPossession = new Hash<ulong, UserData>();

            [JsonProperty]
            internal string _eggCreated;

            public void DestroyTimers()
            {
                foreach (KeyValuePair<ulong, UserData> entry in _eggPossession)
                {
                    if (entry.Value._timer != null)
                    {
                        entry.Value._timer.Destroy();
                        entry.Value._timer = null;
                    }
                }
            }

            public void OnEggMove(IPlayer user)
            {
                UserData userData;

                DestroyTimers();

                if (user == null) return;

                if (!_eggPossession.TryGetValue(Convert.ToUInt64(user.Id), out userData))
                    userData = _eggPossession[Convert.ToUInt64(user.Id)] = new UserData();

                var player = BasePlayer.FindAwakeOrSleeping(user.Id);

                userData.OnEggMove(user);

                TheGoldenEgg.currentOwner = user.Id;

                if (player != null && player.Team != null && _eggPossession.ContainsKey(player.userID))
                {
                    foreach (var memberID in player.Team.members)
                    {
                        if (!_eggPossession[player.userID].Team.Contains(memberID))
                            _eggPossession[player.userID].Team.Add(memberID);
                    }

                    foreach (var memberLeft in _eggPossession[player.userID].Team)
                    {
                        if (!player.Team.members.Contains(memberLeft))
                        {
                            Logger.Info($"{memberLeft} removed from team");
                            _eggPossession[player.userID].Team.Remove(memberLeft);
                        }
                    }
                }

                if (player != null && player.Team == null && _eggPossession.ContainsKey(player.userID) && _eggPossession[player.userID].Team?.Count > 0)
                {
                    Logger.Info($"ok");
                    _eggPossession[player.userID].Team.Clear();
                }

            }
            public void GetTotals()
            {
                foreach (var player in _eggPossession)
                {
                    _eggPossession[player.Key].TeamTotal = player.Value.eggtime;
                    if (player.Value.Team?.Count > 1)
                    {
                        foreach (var teamMember in player.Value.Team)
                        {
                            if (teamMember != player.Key && _eggPossession.ContainsKey(teamMember))
                                _eggPossession[player.Key].TeamTotal += _eggPossession[teamMember].eggtime;
                        }
                    }
                }
            }
            public void GetEggLeaders(List<UserData> list)
            {
                list.Clear();
                list.AddRange(_eggPossession.Values);

                list.Sort((UserData a, UserData b) =>
                {
                    return a.eggtime.CompareTo(b.eggtime) * -1;
                });
            }

            public class UserData
            {
                public double eggtime;
                public string displayName;
                public List<ulong> Team = new List<ulong>();
                public double TeamTotal;

                [JsonIgnore]
                public Timer _timer;
                private const float timer_Refresh = 30f;

                public void OnEggMove(IPlayer user)
                {
                    displayName = user.Name;

                    StartTimer();
                }

                private void StartTimer()
                {
                    _timer = Timer.Repeat(timer_Refresh, 0, () =>
                    {
                        eggtime += timer_Refresh;
                    });
                }
            }
        }

        #region GUI
        private CuiElementContainer CreateEggUI()
        {
            CuiElementContainer elements = new CuiElementContainer();
            string panel = elements.Add(new CuiPanel
            {
                Image = { Color = "0.5 0.5 0.5 0.0" },
                RectTransform = { AnchorMin = "0.257 0.643", AnchorMax = "0.726 0.921" }
            }, "Hud.Menu", "EggUI");
            elements.Add(new CuiElement
            {
                Parent = panel,
                Components =
                    {
                        new CuiRawImageComponent {Color = "1 1 1 1", Url = String.IsNullOrEmpty(_pluginConfig.customItemS.ItemFoundImage) ? "https://i.imgur.com/uVV8CD0.png" : _pluginConfig.customItemS.ItemFoundImage},
                        new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1"}
                    }
            });
            return elements;
        }

        #endregion GUI

        Dictionary<ulong, Timer> spamCheck = new Dictionary<ulong, Timer>();

        void AddSpamBlock(ulong playerID)
        {
            if (!spamCheck.ContainsKey(playerID))
            {
                spamCheck.Add(playerID, spamTimer(playerID));
            }
        }

        void RemoveSpamBlock(ulong playerID)
        {
            if (spamCheck.ContainsKey(playerID))
            {
                spamCheck[playerID].Destroy();
                spamCheck.Remove(playerID);
            }
        }

        Timer spamTimer(ulong playerID)
        {
            return timer.Once(2f, () =>
            {
                RemoveSpamBlock(playerID);
            });
        }

        #region Language File
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["DisplayText"] = "{0}",
                ["Pickup"] = "You've picked up {0}!",
                ["Generation"] = "{0} {1} will be generated in {2}",
                ["Generating"] = "Now generating {0}",
                ["Perms"] = "You dont have the permissions to use this command!",
                ["Help1"] = $"When found, the player will be marked on the map after <color=#FFA500>{_pluginConfig.markerS.InitialMarkerDelay}</color> seconds",
                ["Help2"] = "If enabled, the {0} will be marked on the map when on a <color=#FFA500>player</color>, or in a <color=#FFA500>container</color>",
                ["Help3"] = "When placed in a container alongside a resource, the {0} will generate that resource",
                ["Help4"] = "Use <color=#FFA500>/{0} list</color> to show available resources and their generation time",
                ["Help5"] = "Use <color=#FFA500>/{0} time</color> to show the time remaining to the next resource generation",
                ["Help6"] = "Use <color=#FFA500>/{0} find</color> to pinpoint the {1}s location",
                ["Help7"] = "Use <color=#FFA500>/{0} leader</color> to show the current leaderboard times",
                ["Help8"] = "Use <color=#FFA500>/{0} kill</color> to destroy the {1}",
                ["Help10"] = "Use <color=#FFA500>/{0} expire</color> to check the time remaining before the {1} destroys itself",
                ["Help11"] = "Use <color=#FFA500>/{0} event</color> to manually trigger the chinook event",
                ["Help12"] = "Use <color=#FFA500>/{0} winner</color> to grant the {1} leader (and team) an oxide group",
                ["Help13"] = "Use <color=#FFA500>/{0} purge</color> to destroy the {1} and wipe the data file",
                ["Help9"] = "While carrying the {0}, your health and/or gather rate will be increased",
                ["Resource"] = "Enabled resources: <color=#FFA500>{0}</color>",
                ["Blocked"] = "Cracking the {0} is blocked during raids",
                ["EggLeaderboard"] = "[#ffd479]Leaderboard:[/#]",
                ["LeaderList"] = "\n[#Ffbc2c]{0}[/#] - [#45b6fe]{1}[/#] ([#Ffbc2c]Team: {2}[/#])",
                ["SafeZone"] = "You will not gain time while holding the {0} in a safe zone",
                ["Roaming"] = "{0} is on the move!!",
                ["RoamDisabledTod"] = "Roaming buffs are disabled between {0} and {1}",
                ["RoamDisabledPop"] = "Roaming buffs are disabled while the server pop is under {0}",
                ["Expire"] = "{0} will destroy itself in {1} days, {2} hours, {3} minutes",
                ["EggHack"] = "You cannot hack this crate without {0}",
                ["EventStart"] = "A chinook has delivered {0} golden crates to a monument. {1} is required to hack them, leaving the owner vulnerable...",
                ["CrateHacked"] = "A golden crate is being hacked! It will unlock in {0} seconds",
                ["CommandDisabled"] = "This command is blocked while you're holding {0}",
                ["SafeDestroy"] = "The {0} will be destroyed in {1} seconds unless you leave the safezone",
                ["RaidBaseDestroy"] = "The {0} will be destroyed in {1} seconds unless you leave the Raidable Base zone",
                ["blockDestroy"] = "The {0} will be destroyed in {1} seconds unless you leave the building blocked zone",
                ["Winner"] = "{0} is the winner of {1} event!",
            }, this);
        }
        #endregion

        #region Discord
        class DiscordWebhook
        {
            public string content { get; set; } = "";
            public List<DiscordEmbed> embeds { get; set; } = new List<DiscordEmbed>();

            public DiscordWebhook SetContent(string Content)
            {
                this.content = Content;
                return this;
            }

            public DiscordEmbed AddEmbed()
            {
                var embed = new DiscordEmbed(this);
                this.embeds.Add(embed);

                return embed;
            }

            public void Send(TheGoldenEgg plugin, string Webhook)
            {
                plugin.webrequest.Enqueue(Webhook, JsonConvert.SerializeObject(this), (code, body) => { }, plugin, RequestMethod.POST, new Dictionary<string, string>() {
                        { "Content-Type", "application/json" }
                    });
            }
        }

        class DiscordEmbed
        {
            private DiscordWebhook _webhook;

            public string description { get; set; } = "";
            public string title { get; set; } = "";
            public DateTime timestamp { get; set; }
            public int color { get; set; } = 0;
            public List<DiscordEmbedField> fields = new List<DiscordEmbedField>();
            public DiscordEmbedThumbnail thumbnail { get; set; } = new DiscordEmbedThumbnail();

            public DiscordEmbed SetDescription(string Description)
            {
                this.description = Description;
                return this;
            }
            public DiscordEmbed SetTitle(string Title)
            {
                this.title = Title;
                return this;
            }
            public DiscordEmbed SetTimestamp(DateTime Timestamp)
            {
                this.timestamp = Timestamp;
                return this;
            }
            public DiscordEmbed SetColor(int Color)
            {
                this.color = Color;
                return this;
            }
            public DiscordEmbed AddThumbnail(string Url)
            {
                this.thumbnail = (new DiscordEmbedThumbnail() { url = Url });
                return this;
            }
            public DiscordEmbed AddField(string Name, string Value, bool Inline = false)
            {
                this.fields.Add(new DiscordEmbedField() { name = Name, value = Value, inline = Inline });
                return this;
            }
            public DiscordEmbed AddFields(IEnumerable<DiscordEmbedField> Fields)
            {
                this.fields.AddRange(fields);
                return this;
            }
            public DiscordEmbed AddEmbed()
            {
                return this._webhook.AddEmbed();
            }
            public DiscordWebhook EndEmbed()
            {
                return this._webhook;
            }
            public DiscordEmbed() { }
            public DiscordEmbed(DiscordWebhook WebHook)
            {
                this._webhook = WebHook;
            }
        }
        class DiscordEmbedThumbnail
        {
            public string url { get; set; } = "";
        }

        class DiscordEmbedField
        {
            public string name { get; set; } = "";
            public string value { get; set; } = "";
            public bool inline { get; set; } = false;

            public DiscordEmbedField() { }
            public DiscordEmbedField(string Name, string Value, bool Inline = false)
            {
                this.name = Name;
                this.value = Value;
                this.inline = Inline;
            }
        }
        #endregion

        #region Configuration

        private class Configuration : SerializableConfiguration
        {
            [JsonProperty("Egg spawn chance for Locked Crates (0 to 100)")]
            public float LockedCrateEggChance = 0.04f;

            [JsonProperty("Egg spawn chance for Elite Crates")]
            public float EliteCrateEggChance = 0.04f;

            [JsonProperty("Egg spawn chance for Military Crates")]
            public float MilitaryCrateEggChance = 0.02f;

            [JsonProperty("Egg spawn chance for Normal Crates")]
            public float NormalCrateEggChance = 0.01f;

            [JsonProperty(PropertyName = "Marker Settings")]
            public MarkerSettings markerS = new MarkerSettings();

            [JsonProperty(PropertyName = "Resource Settings")]
            public ResourceSettings resourceS = new ResourceSettings();

            [JsonProperty(PropertyName = "Item Customisation")]
            public ItemCustomisation customItemS = new ItemCustomisation();

            [JsonProperty(PropertyName = "Roam Settings")]
            public RoamSettings roamS = new RoamSettings();

            [JsonProperty(PropertyName = "Event Settings")]
            public CrateEvent crateS = new CrateEvent();

            [JsonProperty("Let players with permission pinpoint the egg on screen (use /egg find)")]
            public bool PinpointEggCommand = false;

            [JsonProperty("Send a webhook when the egg is found/destroyed")]
            public string sendWebhook = "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks";

            [JsonProperty("Don't add time while the player is in a safe zone")]
            public bool BlockSafeZone = true;

            [JsonProperty("Don't add time while the egg is in a stash")]
            public bool BlockStashTime = true;

            [JsonProperty("Don't add time while the egg is in a building")]
            public bool NoPrivTime = false;

            [JsonProperty("Don't add time while server pop is below (leave at 0 to disable)")]
            public int ServerPop = 0;

            [JsonProperty("Don't add time between certain hours")]
            public bool TimeOfDay = false;

            [JsonProperty("Start of time period")]
            public string StartTime = "1AM";

            [JsonProperty("End of time period")]
            public string EndTime = "6AM";

            [JsonProperty("Destroy the egg if in a safe zone for longer than (seconds, leave at 0 to disable)")]
            public float safeDestroy = 0;

            [JsonProperty("Destroy the egg if in a building blocked zone for longer than (seconds, leave at 0 to disable)")]
            public float blockedDestroy = 0;

            [JsonProperty("Destroy the egg if in a Raidable Base zone for longer than (seconds, leave at 0 to disable)")]
            public float raidBaseDestroy = 0;

            [JsonProperty("Name of permission group to grant with /egg winner (requires Timed Permissions plugin)")]
            public string GroupName = "";

            [JsonProperty("Duration to grant access to group (requires Timed Permissions plugin). Format: 1d12h30m")]
            public string GroupDuration = "28d";

            [JsonProperty("Destroy the egg after x minutes (leave at 0 to disable)")]
            public int KillTime = 0;

            [JsonProperty("Block player from cracking open the egg while being raided")]
            public bool BlockEggCrack = true;

            [JsonProperty("Raid block timer")]
            public int BlockInterval = 300;

            [JsonProperty("Data save interval")]
            public int SaveInterval = 300;

            [JsonProperty("Clear data on map wipe")]
            public bool ClearData = true;

            [JsonProperty("Use custom item list when cracking open the egg")]
            public bool UseCustomList = false;

            [JsonProperty("Custom item list (use item shortname, eg rifle.m39, explosive.timed, etc")]
            public List<string> EggRewards = new List<string>
                {
                        "item.one",
                        "item.two",
                        "etc"
                };

            [JsonProperty("Blacklist commands whilst holding the egg")]
            public bool UseBlacklist = false;

            [JsonProperty("Blacklisted commands")]
            public List<string> BlacklistedCommands = new List<string>
                {
                    "/tp",
                    "/trade",
                    "/shop",
                    "/rw",
                    "/bank",
                    "/home",
                    "/remove"
                };

            [JsonProperty(PropertyName = "TruePVE Only")]
            public TruePVE tpveS = new TruePVE();
        }

        public class TruePVE
        {
            [JsonProperty("Enable damage to players and bases if they have the egg")]
            public bool DisableTruePVE = false;

            [JsonProperty("Max distance between players for damage to register")]
            public float DamageDistance = 100f;
        }

        public class CrateEvent
        {
            [JsonProperty("Run the chinook event")]
            public bool crateEvent = false;

            [JsonProperty("Number of crates to drop")]
            public int numCrates = 2;

            [JsonProperty("Crate unlock time")]
            public int crateTimer = 300;

            [JsonProperty("Maximum additional items to add to the crate(s)")]
            public int addedItems = 15;

            [JsonProperty("Run the event once, between a certain time")]
            public bool crateTOD = false;

            [JsonProperty("Start of time period")]
            public string eventStartTime = "7PM";

            [JsonProperty("End of time period")]
            public string eventEndTime = "10PM";

            [JsonProperty("Run the event on repeat")]
            public bool crateRepeat = false;

            [JsonProperty("Minimum time between events (seconds)")]
            public float minStartTime = 3600;

            [JsonProperty("Maximum time between events (seconds)")]
            public float maxStartTime = 7200;

            [JsonProperty("Don't run the event if server pop is below (leave at 0 to disable)")]
            public int cratePop = 0;

            [JsonProperty("Show map marker")]
            public bool crateMarker = true;

            [JsonProperty("Marker Radius")]
            public float crateMarkerRadius = 0.5f;

            [JsonProperty("Marker Transparency")]
            public float crateMarkerAlpha = 0.4f;

            [JsonProperty("Marker Color (hex)")]
            public string crateColor1 = "#ecf97f";

            [JsonProperty("Marker Border Color (hex)")]
            public string crateColor2 = "#000000";

        }

        public class ItemCustomisation
        {
            [JsonProperty("Item Name")]
            public string ItemName = "The Golden Egg";

            [JsonProperty("Item Skin ID")]
            public ulong ItemSkin = 0;

            [JsonProperty("Item Found Image in Game (use an image 1000x400)")]
            public string ItemFoundImage = "https://i.imgur.com/uVV8CD0.png";

            [JsonProperty(PropertyName = "Chat command", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public string Command = "egg";

            [JsonProperty("Item Found Image for the Discord Webhook")]
            public string ItemFoundDiscord = "https://i.imgur.com/Knn0X37.png";

            [JsonProperty("Item Lost Image for the Discord Webhook")]
            public string ItemLostDiscord = "https://i.imgur.com/GxlVNSa.png";
        }

        public class MarkerSettings
        {
            [JsonProperty("Show map marker when the egg is in a box")]
            public bool boxMarker = true;

            [JsonProperty("Show map marker when the egg is on a player")]
            public bool playerMarker = true;

            [JsonProperty("Player marker refresh time (seconds)")]
            public int PlayerMarkerRefreshTime = 25;

            [JsonProperty("Box marker refresh time (seconds)")]
            public int BoxMarkerRefreshTime = 60;

            [JsonProperty("Initial marker delay when the egg is found")]
            public int InitialMarkerDelay = 60;

            [JsonProperty("Marker Radius")]
            public float MarkerRadius = 0.7f;

            [JsonProperty("Marker Transparency")]
            public float MarkerAlpha = 0.5f;

            [JsonProperty("Marker Color (hex)")]
            public string color1 = "#fa030a";

            [JsonProperty("Marker Border Color (hex)")]
            public string color2 = "#000000";

            [JsonProperty("Add a Vending marker")]
            public bool AddVendingMarker = false;

            [JsonProperty("Vending Marker Name")]
            public string VendingMarkerName = "The Golden Egg";
        }

        public class RoamSettings
        {
            [JsonProperty("Increase health whilst holding the egg")]
            public bool IncreaseHealth = true;

            [JsonProperty("Total health")]
            public int TotalHealth = 150;

            [JsonProperty("Increase ore/wood gather rate whilst holding the egg")]
            public bool IncreaseGather = true;

            [JsonProperty("Gather multipler")]
            public float GatherMultiplier = 2.0f;

            [JsonProperty("Increase pickup amount whilst holding the egg (hemp/food etc)")]
            public bool IncreasePickup = true;

            [JsonProperty("Pickup multipler")]
            public float PickupMultiplier = 2.0f;

            [JsonProperty("Don't allow roam bonus while server pop is below (leave at 0 to disable)")]
            public int RoamPop = 0;

            [JsonProperty("Don't allow roam bonus between certain hours")]
            public bool RoamTod = false;

            [JsonProperty("Start of time period")]
            public string RoamStart = "1AM";

            [JsonProperty("End of time period")]
            public string RoamEnd = "6AM";

            [JsonProperty("Broadcast a chat message when someone starts roaming")]
            public bool RoamMessage = true;
        }

        public class ResourceSettings
        {
            [JsonProperty("Resource Spawn Time (seconds)")]
            public int ResourceSpawnTime = 3600;

            [JsonProperty("Scrap Spawn Amount (0 to disable)")]
            public int ScrapSpawnAmount = 50;

            [JsonProperty("HQM Spawn Amount")]
            public int HQMSpawnAmount = 25;

            [JsonProperty("Low Grade Spawn Amount")]
            public int LowGradeSpawnAmount = 100;

            [JsonProperty("Metal Frags Spawn Amount")]
            public int FragsSpawnAmount = 1000;

            [JsonProperty("Allow Sulfur Ore")]
            public bool AllowSulfurOre = false;

            [JsonProperty("Sulfur Ore Spawn Amount")]
            public int SulfurOreAmount = 800;

            [JsonProperty("Allow Cooked Sulfur")]
            public bool AllowSulfurCooked = false;

            [JsonProperty("Cooked Sulfur Spawn Amount")]
            public int SulfurCookedAmount = 500;

            [JsonProperty("Custom Item 1 (use item shortname, eg ammo.rifle, gears, green.berry)")]
            public string CustomItem1 = "";

            [JsonProperty("Custom Item 1 Amount")]
            public int CustomAmount1 = 1;

            [JsonProperty("Custom Item 1 Spawn Time (seconds)")]
            public int CustomTime1 = 7200;

            [JsonProperty("Custom Item 2")]
            public string CustomItem2 = "";

            [JsonProperty("Custom Item 2 Amount")]
            public int CustomAmount2 = 1;

            [JsonProperty("Custom Item 2 Spawn Time (seconds)")]
            public int CustomTime2 = 7200;

            [JsonProperty("Custom Item 3")]
            public string CustomItem3 = "";

            [JsonProperty("Custom Item 3 Amount")]
            public int CustomAmount3 = 1;

            [JsonProperty("Custom Item 3 Spawn Time (seconds)")]
            public int CustomTime3 = 7200;
        }

        private Configuration GetDefaultConfig() => new Configuration();

        /*
        Thanks to WhiteThunder for the below code - https://github.com/WheteThunger/MonumentAddons

        MIT License

        Copyright (c) 2021 WhiteThunder

        Permission is hereby granted, free of charge, to any person obtaining a copy
        of this software and associated documentation files (the "Software"), to deal
        in the Software without restriction, including without limitation the rights
        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the Software is
        furnished to do so, subject to the following conditions:

        The above copyright notice and this permission notice shall be included in all
        copies or substantial portions of the Software.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        SOFTWARE.
        */

        private class SerializableConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        protected override void LoadDefaultConfig() => _pluginConfig = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _pluginConfig = Config.ReadObject<Configuration>();
                if (_pluginConfig == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_pluginConfig))
                {
                    Logger.Warning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }

            }
            catch (Exception e)
            {
                Logger.Error(e.Message);
                Logger.Warning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }
        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_pluginConfig, true);
        }

        private bool MaybeUpdateConfig(SerializableConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            bool changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        #endregion

        private static class Logger
        {
            public static void Info(string message) => Interface.Oxide.LogInfo($"[The Golden Egg] {message}");
            public static void Error(string message) => Interface.Oxide.LogError($"[The Golden Egg] {message}");
            public static void Warning(string message) => Interface.Oxide.LogWarning($"[The Golden Egg] {message}");
        }
    }
}


// --- End of file: TheGoldenEgg-1.9.24.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AntiRB.cs ---
// --- Original Local Path: AntiRB.cs ---

using System.Collections.Generic;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;
using System;

namespace Oxide.Plugins
{
    [Info("AntiRB", "King", "1.0.0")]
    public class AntiRB : RustPlugin
    {
                        [PluginReference] private Plugin
        NoEscape = null, Clans = null, MenuAlerts = null, ImageLibrary = null;

        private static AntiRB plugin = null;
        public Dictionary<string, double> _cooldown = new Dictionary<string, double>();

        #region [Data]
        private class Data
        {
            public readonly BasePlayer _player;
            public readonly Single _cooldown;
            public readonly Boolean _coin;

            public Data(BasePlayer player, Single cooldown, Boolean isRaidCoin = false)
            {
                _player = player;
                _cooldown = Time.time + cooldown;
                _coin = isRaidCoin;
            }
        }

        private List<Data> _data = new List<Data>();
        #endregion

        #region [Oxide]
        private void OnServerInitialized()
        {
            plugin = this;

            ImageLibrary?.Call("AddImage", "https://i.imgur.com/i7QkC5B.png", "Point_Image");
            ImageLibrary?.Call("AddImage", "https://i.postimg.cc/7696CGRZ/dollar-2.png", "AntiRB_Image");
            ImageLibrary?.Call("AddImage", "https://i.postimg.cc/nVKJCPNH/imgonline-com-ua-Resize-YN5d-Vq-C7x1.png", "AntiR_B_Image");
            ImageLibrary?.Call("AddImage", "https://i.postimg.cc/dQr2b8pk/bet.png", "XUron_Image");       

            if (!NoEscape) PrintWarning("NOESCAPE IS NOT INSTALLED.");

            GameObject obj = new GameObject();
            if (config._SettingsAntiRBChinook.useChinook)
                AntiRBComp = obj.AddComponent<AntiRBComponent>();
            if (config._SettingsChinookPoint.useChinook)
                ChinookPointComp = obj.AddComponent<ChinookPointComponent>();

            timer.Every(1, TimeHandle);
        }

        private void Unload()
        {
            _data?.ForEach(data =>
            {
                if (data._coin)
                    rust.RunServerCommand($"oxide.usergroup remove {data._player.userID} antirb");
            });

            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                MenuAlerts?.Call("RemoveAlertMenu", player, $"{Name}.Coin");
                MenuAlerts?.Call("RemoveAlertMenu", player, $"{Name}.Point");
            }

            UnityEngine.Object.Destroy(AntiRBComp);
            UnityEngine.Object.Destroy(ChinookPointComp);

            plugin = null;
        }
        #endregion

        private void TimeHandle()
        {
            List<Data> toRemove = Pool.GetList<Data>();

            _data?.ForEach(data =>
            {
                if (Time.time - data._cooldown >= 0)
                {
                    if (data._coin)
                        rust.RunServerCommand($"oxide.usergroup remove {data._player.userID} antirb");

                    toRemove.Add(data);
                }
            });

            toRemove.ForEach(data => _data.Remove(data));
            
            Pool.FreeList(ref toRemove);
        }

        #region [Rust]
        object OnItemAction(Item item, String action, BasePlayer player)
        {
            if (action != "unwrap") return null;

            if (item.info.shortname == config._SettingsAntiRB.ShortName && item.skin == config._SettingsAntiRB.SkinID)
            {
                String clan = ClanTag(player);
                if (_cooldown.ContainsKey(clan))
                {
                    Double time = _cooldown[clan] - CurrentTime();
                    if (time <= 0)
                        _cooldown.Remove(clan);
                    else
                    {
                        player.ChatMessage($"Вы уже использовали этот предмет,повторно вы сможете использовать его через {TimeSpan.FromSeconds(time).ToShortString()}!");
                        return false;
                    }
                }

                Server.Broadcast($"Игрок <color=green>{player.displayName}</color> активировал анти-рб монету!");
                rust.RunServerCommand($"oxide.usergroup add {player.userID} antirb");

                UnblockedPlayer(player);
                _data.Add(new Data(player, config._SettingsAntiRB.timeActiveAntiRB, true));
                if (!_cooldown.ContainsKey(clan))
                    _cooldown.Add(clan, CurrentTime() + config._cooldown);
                if (item.amount > 1) item.amount--;
                else item.RemoveFromContainer();
                return false;
            }

            if (item.info.shortname == config._SettingsDamageCoin.ShortName && item.skin == config._SettingsDamageCoin.SkinID)
            {
                Server.Broadcast($"Игрок <color=green>{player.displayName}</color> активировал монету дополнительного урона!");

                _data.Add(new Data(player, config._SettingsDamageCoin.timeActiveDamageCoin, false));
                if (item.amount > 1) item.amount--;
                else item.RemoveFromContainer();
                return false;
            }

            if (item.info.shortname == config._SettingsChinookPoint.ShortName && item.skin == config._SettingsChinookPoint.SkinID)
            {
                String clan = ClanTag(player);
                if (string.IsNullOrEmpty(clan))
                {
                    player.ChatMessage($"Вы не можете активировать тикет на {config._SettingsChinookPoint.howPoint} очков. Чтобы активировать создайте клан!");
                    return false;
                }

                Clans?.Call("GiveClanPoints", clan, config._SettingsChinookPoint.howPoint);
                player.ChatMessage($"Вы успешно активировали тикет на {config._SettingsChinookPoint.howPoint} очков.");
                if (item.amount > 1) item.amount--;
                else item.RemoveFromContainer();
                return false;
            }

            return null;
        }

		private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
		{
			if (entity == null || info?.InitiatorPlayer == null) return;

            BasePlayer player = info.InitiatorPlayer;
            if (player == null) return;
			
			Data find = _data.Find(x => x._player == player);
            if (find == null) return;

            if (entity is BuildingBlock || entity is Door || entity is SimpleBuildingBlock)
                info.damageTypes.ScaleAll(1.0f * config._SettingsDamageCoin.DamageCoinPerc);
		}

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player == null || !player.userID.IsSteamId()) return;

            if (AntiRBComp != null && AntiRBComp.IsStartEvent && AntiRBComp.IsStartHacked)
            {
                MenuAlerts?.Call("SendAlertMenu", player, Facepunch.Math.Epoch.Current - AntiRBComp.CurrentTime, (Int32)config._SettingsAntiRBChinook.timeOpen, $"CHINOOK COIN", $"Квадрат: {GetGrid(AntiRBComp.transform.position)}", false, "AntiRB_Image", $"{Name}.Coin");
            }

            if (ChinookPointComp != null && ChinookPointComp.IsStartEvent && ChinookPointComp.IsStartHacked)
            {
                MenuAlerts?.Call("SendAlertMenu", player, Facepunch.Math.Epoch.Current - ChinookPointComp.CurrentTime, (Int32)config._SettingsAntiRBChinook.timeOpen, $"CHINOOK POINT", $"Квадрат: {GetGrid(ChinookPointComp.transform.position)}", false, "Point_Image", $"{Name}.Point");
            }
        }

        private void OnCrateHack(HackableLockedCrate crate)
        {
            if (crate == null || crate.OwnerID == 0) return;

            if (AntiRBComp != null && AntiRBComp.IsStartEvent && AntiRBComp.CrateEntity == crate)
            {
                AntiRBComp.IsStartHacked = true;
                foreach (BasePlayer player in BasePlayer.activePlayerList)
                {
                    MenuAlerts?.Call("SendAlertMenu", player, Facepunch.Math.Epoch.Current, (Int32)config._SettingsAntiRBChinook.timeOpen, $"CHINOOK COIN", $"Квадрат: {GetGrid(AntiRBComp.transform.position)}", false, "AntiRB_Image", $"{Name}.Coin");
                }
                Server.Broadcast($"<color=#ffde5a>ВНИМАНИЕ!</color>\n<size=12>Начался взлом чинука с монетами");
            }

            if (ChinookPointComp != null && ChinookPointComp.IsStartEvent && ChinookPointComp.CrateEntity == crate)
            {
                ChinookPointComp.IsStartHacked = true;
                foreach (BasePlayer player in BasePlayer.activePlayerList)
                {
                    MenuAlerts?.Call("SendAlertMenu", player, Facepunch.Math.Epoch.Current, (Int32)config._SettingsAntiRBChinook.timeOpen, $"CHINOOK POINT", $"Квадрат: {GetGrid(ChinookPointComp.transform.position)}", false, "Point_Image", $"{Name}.Point");
                }
                Server.Broadcast($"<color=#ffde5a>ВНИМАНИЕ!</color>\n<size=12>Начался взлом чинука с очками");
            }
        }

        private void OnEntityKill(HackableLockedCrate crate)
        {
            if (crate == null || crate.OwnerID == 0) return;

            if (AntiRBComp != null && AntiRBComp.IsStartEvent && AntiRBComp.CrateEntity == crate)
            {
                AntiRBComp.EndedEvent();
            }

            if (ChinookPointComp != null && ChinookPointComp.IsStartEvent && ChinookPointComp.CrateEntity == crate)
            {
                ChinookPointComp.EndedEvent();
            }
        }
        #endregion

        #region [AntiRB || Damage Chinook]
        private AntiRBComponent AntiRBComp = null;

        private class AntiRBComponent : FacepunchBehaviour
        {
            private Int32 TotalTime = 0;
            public Int32 CurrentTime = 0;

            public Boolean IsStartHacked = false;
            public Boolean IsStartEvent = false;
            public HackableLockedCrate CrateEntity = null;

            private void Awake()
            {
                gameObject.layer = (Int32)Rust.Layer.Reserved1;
                enabled = false;
                InvokeRepeating(UpdateTime, 1f, 1);
            }

            public void DestroyComp() => OnDestroy();
            private void OnDestroy()
            {
                RemoveChinook();
                Destroy(this);
            }

            private void UpdateTime()
            {
                if (!IsStartEvent)
                {
                    TotalTime++;
                    if (TotalTime >= plugin.config._SettingsAntiRBChinook.eventCooldown)
                    {
                        StartEvent();
                    }
                }
                else if (IsStartHacked)
                {
                    CurrentTime++;
                    if (CurrentTime >= plugin.config._SettingsAntiRBChinook.timeOpen + plugin.config._SettingsAntiRBChinook.eventDestoroyTime)
                    {
                        EndedEvent();
                    }
                }
            }

            public void StartEvent()
            {
                transform.position = plugin.config._SettingsAntiRBChinook.chinookPosition;

                if (transform.position == Vector3.zero) return;

                SpawnChinook();

                TotalTime = 0;
                IsStartEvent = true;
                plugin.Server.Broadcast($"<color=#ffde5a>ВНИМАНИЕ!</color>\n<size=12>Начался ивент <color=#ffde5a>CHINOOK COIN</color>.\nМестоположение отмечено на карте.");
            }

            public void EndedEvent()
            {
                IsStartHacked = false;
                IsStartEvent = false;
                TotalTime = 0;
                CurrentTime = 0;

                RemoveChinook();

                foreach (BasePlayer player in BasePlayer.activePlayerList)
                {
                    plugin.MenuAlerts?.Call("RemoveAlertMenu", player, $"{plugin.Name}");
                }
                plugin.Server.Broadcast($"<color=#ffde5a>ВНИМАНИЕ!</color>\n<size=12>Закончился ивент <color=#ffde5a>CHINOOK COIN</color>.\nСледующий ивент будет через {TimeExtensions.FormatShortTime(TimeSpan.FromSeconds(plugin.config._SettingsAntiRBChinook.eventCooldown))}");
            }

            private void SpawnChinook()
            {
                CrateEntity = GameManager.server.CreateEntity("assets/prefabs/deployable/chinooklockedcrate/codelockedhackablecrate.prefab", transform.position, Quaternion.Euler(0f, UnityEngine.Random.Range(0f, 360f), 0f), true) as HackableLockedCrate;
                CrateEntity.enableSaving = false;
                CrateEntity.OwnerID = 231313354353;
                CrateEntity.Spawn();
                CrateEntity.inventory.itemList.Clear();
                plugin.FillingChinookItem(CrateEntity);
                CrateEntity.inventory.capacity = CrateEntity.inventory.itemList.Count;
                CrateEntity.inventory.MarkDirty();
                CrateEntity.SendNetworkUpdate();
                CrateEntity.hackSeconds = HackableLockedCrate.requiredHackSeconds - plugin.config._SettingsAntiRBChinook.timeOpen;
            }

            private void RemoveChinook()
            {
                if (CrateEntity != null && !CrateEntity.IsDestroyed)
                    CrateEntity.Kill();
            }
        }
        #endregion

        #region [ChinookPoint]
        private ChinookPointComponent ChinookPointComp = null;

        private class ChinookPointComponent : FacepunchBehaviour
        {
            private Int32 TotalTime = 0;
            public Int32 CurrentTime = 0;

            public Boolean IsStartHacked = false;
            public Boolean IsStartEvent = false;
            public HackableLockedCrate CrateEntity = null;

            private void Awake()
            {
                gameObject.layer = (Int32)Rust.Layer.Reserved1;
                enabled = false;
                InvokeRepeating(UpdateTime, 1f, 1);
            }

            public void DestroyComp() => OnDestroy();
            private void OnDestroy()
            {
                RemoveChinook();
                Destroy(this);
            }

            private void UpdateTime()
            {
                if (!IsStartEvent)
                {
                    TotalTime++;
                    if (TotalTime >= plugin.config._SettingsChinookPoint.eventCooldown)
                    {
                        StartEvent();
                    }
                }
                else if (IsStartHacked)
                {
                    CurrentTime++;
                    if (CurrentTime >= plugin.config._SettingsChinookPoint.timeOpen + plugin.config._SettingsChinookPoint.eventDestoroyTime)
                    {
                        EndedEvent();
                    }
                }
            }

            public void StartEvent()
            {
                transform.position = plugin.config._SettingsChinookPoint.chinookPosition;

                if (transform.position == Vector3.zero) return;

                SpawnChinook();

                TotalTime = 0;
                IsStartEvent = true;
                plugin.Server.Broadcast($"<color=#ffde5a>ВНИМАНИЕ!</color>\n<size=12>Начался ивент <color=#ffde5a>CHINOOK POINT</color>.\nМестоположение отмечено на карте.");
            }

            public void EndedEvent()
            {
                IsStartHacked = false;
                IsStartEvent = false;
                TotalTime = 0;
                CurrentTime = 0;

                RemoveChinook();

                foreach (BasePlayer player in BasePlayer.activePlayerList)
                {
                    plugin.MenuAlerts?.Call("RemoveAlertMenu", player, $"{plugin.Name}");
                }
                plugin.Server.Broadcast($"<color=#ffde5a>ВНИМАНИЕ!</color>\n<size=12>Закончился ивент <color=#ffde5a>CHINOOK POINT</color>.\nСледующий ивент будет через {TimeExtensions.FormatShortTime(TimeSpan.FromSeconds(plugin.config._SettingsChinookPoint.eventCooldown))}");
            }

            private void SpawnChinook()
            {
                CrateEntity = GameManager.server.CreateEntity("assets/prefabs/deployable/chinooklockedcrate/codelockedhackablecrate.prefab", transform.position, Quaternion.Euler(0f, UnityEngine.Random.Range(0f, 360f), 0f), true) as HackableLockedCrate;
                CrateEntity.enableSaving = false;
                CrateEntity.OwnerID = 231313354353;
                CrateEntity.Spawn();
                CrateEntity.inventory.itemList.Clear();
                Item netItem = ItemManager.CreateByName(plugin.config._SettingsChinookPoint.ShortName, 1, plugin.config._SettingsChinookPoint.SkinID);
                netItem.name = $"Билет на {plugin.config._SettingsChinookPoint.howPoint} очков.";
                netItem.MoveToContainer(CrateEntity.inventory);
                CrateEntity.inventory.capacity = CrateEntity.inventory.itemList.Count;
                CrateEntity.inventory.MarkDirty();
                CrateEntity.SendNetworkUpdate();
                CrateEntity.hackSeconds = HackableLockedCrate.requiredHackSeconds - plugin.config._SettingsChinookPoint.timeOpen;
            }

            private void RemoveChinook()
            {
                if (CrateEntity != null && !CrateEntity.IsDestroyed)
                    CrateEntity.Kill();
            }
        }
        #endregion

        #region [Functional]
        static readonly DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        static Double CurrentTime() => DateTime.UtcNow.Subtract(epoch).TotalSeconds;
        public String ClanTag(BasePlayer player) => Clans?.Call<String>("GetClanTag", player.userID);
        private void UnblockedPlayer(BasePlayer player) => NoEscape?.Call("UnblockedPlayer", player);
        #endregion

        #region [FillingChinook]
        private void FillingChinookItem(LootContainer LootContainer)
        {
            if (LootContainer == null) return;
            Int32 i = Core.Random.Range(0, 2);

            switch (i)
            {
                case 0:
                {
                    Item netItem = ItemManager.CreateByName(config._SettingsAntiRB.ShortName, 1, config._SettingsAntiRB.SkinID);
                    netItem.name = "Анти рб монета";
                    netItem.MoveToContainer(LootContainer.inventory);
                    break;
                }
                case 1:
                {
                    Item netItem = ItemManager.CreateByName(config._SettingsDamageCoin.ShortName, 1, config._SettingsDamageCoin.SkinID);
                    netItem.name = "Двойной урон монета";
                    netItem.MoveToContainer(LootContainer.inventory);
                    break;
                }
            }
        }
        #endregion

        #region [ChatCommand]
        [ChatCommand("chinook")]
        private void NewChinookPosition(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin) return;

            if (args.Length == 0)
            {
                    player.ChatMessage("Доступные команды:"
                                       + "\n/chinook antirb start - Начать антирб чинук" 
                                       + "\n/chinook antirb stop - Закончить антирб чинук"
                                       + "\n/chinook antirb position - Установить местоположение чинука"
                                       + "\n/chinook point start - Начать ивент чинук с очками" 
                                       + "\n/chinook point stop - Закончить ивент чинук с очками"
                                       + "\n/chinook point position - Установить местоположение чинука с очками");
                return;
            }

            if (args[0] == "antirb")
            {
                if (args[1] == "start")
                {
                    if (AntiRBComp == null || AntiRBComp.IsStartEvent) return;

                    AntiRBComp.StartEvent();
                    player.ChatMessage("Вы успешно начали ивент анти рб.");
                }
                else if (args[1] == "stop")
                {
                    if (AntiRBComp == null || !AntiRBComp.IsStartEvent) return;

                    AntiRBComp.EndedEvent();
                    player.ChatMessage("Вы успешно остановили ивент анти рб.");
                }
                else if (args[1] == "position")
                {
                    config._SettingsAntiRBChinook.chinookPosition = player.GetNetworkPosition();
                    SaveConfig();
                    player.ChatMessage("Вы успешно установили новое положения для чинука!");
                }
            }
            else if (args[0] == "point")
            {
                if (args[1] == "start")
                {
                    if (ChinookPointComp == null || ChinookPointComp.IsStartEvent) return;

                    ChinookPointComp.StartEvent();
                    player.ChatMessage("Вы успешно начали ивент чинук с очками.");
                }
                else if (args[1] == "stop")
                {
                    if (ChinookPointComp == null || !ChinookPointComp.IsStartEvent) return;

                    ChinookPointComp.EndedEvent();
                    player.ChatMessage("Вы успешно остановили ивент чинук с очками.");
                }
                else if (args[1] == "position")
                {
                    config._SettingsChinookPoint.chinookPosition = player.GetNetworkPosition();
                    SaveConfig();
                    player.ChatMessage("Вы успешно установили новое положения для чинука с очками!");
                }
            }
        }
        #endregion

        #region [Positon]
        public string GetGrid(Vector3 pos)
        {
            char letter = 'A';
            Single x = Mathf.Floor((pos.x + (ConVar.Server.worldsize / 2)) / 146.3f) % 26;
            Single z = (Mathf.Floor(ConVar.Server.worldsize / 146.3f)) - Mathf.Floor((pos.z + (ConVar.Server.worldsize / 2)) / 146.3f);
            letter = (char)(((Int32)letter) + x);
            return $"{letter}{z}";
        }
        #endregion

        #region [FormatTime]
        private static class TimeExtensions
        {
            public static string FormatShortTime(TimeSpan time)
            {
                string result = string.Empty;
                if (time.Days != 0) result += $"{time.Days}д ";
                if (time.Hours != 0) result += $"{time.Hours}ч ";
                if (time.Minutes != 0) result += $"{time.Minutes}м ";
                if (time.Seconds != 0) result += $"{time.Seconds}с ";
                return result;
            }
            private static string Format(Int32 units, string form1, string form2, string form3)
            {
                Int32 tmp = units % 10;
                if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9) return $"{units} {form1}";
                if (tmp >= 2 && tmp <= 4) return $"{units} {form2}";
                return $"{units} {form3}";
            }
        }
        #endregion

        #region [Config]
        private PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();

            if (config.PluginVersion < Version)
                UpdateConfigValues();

            Config.WriteObject(config, true);
        }

        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (config.PluginVersion < Version)
            {
                config.PluginVersion = Version;
                if (Version == new VersionNumber(1, 0, 0))
                {
                    //
                }

                PrintWarning("Config checked completed!");
            }
            config.PluginVersion = Version;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        public class SettingsAntiRBChinook
        {
            [JsonProperty("Использовать этот вариант чинука ?")]
            public Boolean useChinook;

            [JsonProperty("Время открытия чинука (в секундах)")]
            public Int32 timeOpen;

            [JsonProperty("Раз во сколько будет запускаться ивент (в секундах)")]
            public Int32 eventCooldown;

            [JsonProperty("Через сколько заканчивать ивент если чинук никто не залутал (в секундах)")]
            public Int32 eventDestoroyTime;

            [JsonProperty("Местоположение чинука ( Не указывать )")]
            public Vector3 chinookPosition;
        }

        public class SettingsChinookPoint
        {
            [JsonProperty("Использовать этот вариант чинука ?")]
            public Boolean useChinook;
            
            [JsonProperty("Время открытия чинука (в секундах)")]
            public Int32 timeOpen;

            [JsonProperty("Раз во сколько будет запускаться ивент (в секундах)")]
            public Int32 eventCooldown;

            [JsonProperty("Через сколько заканчивать ивент если чинук никто не залутал (в секундах)")]
            public Int32 eventDestoroyTime;

            [JsonProperty("Местоположение чинука ( Не указывать )")]
            public Vector3 chinookPosition;

            [JsonProperty("ShortName")]
            public String ShortName;

            [JsonProperty("SkinID")]
            public ulong SkinID;

            [JsonProperty("Сколько очков давать за активацию тикета")]
            public Int32 howPoint;
        }

        public class SettingsAntiRB
        {
            [JsonProperty("ShortName")]
            public String ShortName;

            [JsonProperty("SkinID")]
            public ulong SkinID;

            [JsonProperty("Время действия монеты")]
            public Single timeActiveAntiRB;
        }

        public class SettingsDamageCoin
        {
            [JsonProperty("ShortName")]
            public String ShortName;

            [JsonProperty("SkinID")]
            public ulong SkinID;

            [JsonProperty("Время действия монеты")]
            public Single timeActiveDamageCoin;

            [JsonProperty("На сколько умножать урон по постройкам")]
            public Single DamageCoinPerc;
        }

        private class PluginConfig
        {
            [JsonProperty("Настройки анти-рб монеты")]
            public SettingsAntiRB _SettingsAntiRB = new SettingsAntiRB();

            [JsonProperty("Настройки чинука с очками клана")]
            public SettingsChinookPoint _SettingsChinookPoint = new SettingsChinookPoint();

            [JsonProperty("Настройки чинука с анти рб и монетки на урон")]
            public SettingsAntiRBChinook _SettingsAntiRBChinook = new SettingsAntiRBChinook();

            [JsonProperty("Настройки монеты на увеления урона по постройкам")]
            public SettingsDamageCoin _SettingsDamageCoin = new SettingsDamageCoin();

            [JsonProperty("Перезарядка использования анти-рб монеты")]
            public Int32 _cooldown;

            [JsonProperty("Config version")]
            public VersionNumber PluginVersion = new VersionNumber();

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    _SettingsAntiRB = new SettingsAntiRB
                    {
                        ShortName = "xmas.present.small",
                        SkinID = 2000,
                        timeActiveAntiRB = 20f,
                    },
                    _SettingsChinookPoint = new SettingsChinookPoint
                    {
                        useChinook = true,
                        timeOpen = 300,
                        eventCooldown = 800,
                        eventDestoroyTime = 300,
                        chinookPosition = Vector3.zero,
                        ShortName = "xmas.present.small",
                        SkinID = 1995,
                        howPoint = 200,
                    },
                    _SettingsAntiRBChinook = new SettingsAntiRBChinook
                    {
                        useChinook = true,
                        timeOpen = 300,
                        eventCooldown = 600,
                        eventDestoroyTime = 300,
                        chinookPosition = Vector3.zero,
                    },
                    _SettingsDamageCoin = new SettingsDamageCoin
                    {
                        ShortName = "xmas.present.small",
                        SkinID = 1997,
                        timeActiveDamageCoin = 20f,
                        DamageCoinPerc = 2f,
                    },
                    _cooldown = 3600,
                    PluginVersion = new VersionNumber()
                };
            }
        }
        #endregion
    }
}

// --- End of file: AntiRB.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/IQBackpack.cs ---
// --- Original Local Path: IQBackpack.cs ---

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ConVar;
using Network;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("IQBackpack", "SkuliDropek", "1.0.7")]
    [Description("Просто твой любимый рюкзачок :)")]
    class IQBackpack : RustPlugin
    {
        /// <summary>
        /// Обновление 1.0.х
        /// - Исправил перекладывание предметов в рюкзак через ПКМ/бинд
        /// - Теперь при добавления игрока в группу/выдаче группе или игроку разрешений игрок получит уведомление в чате и его интерфейс и кол-во слотов автоматически обновится
        /// - Теперь при удалении игрока из группы/удалении у группы или игрока разрешений игрок получит уведомление в чате и его интерфейс и кол-во слотов автоматически обновится (если у него предметов было больше, чем допустимое кол-во слотов - они выпадут)
        /// - Добавлена возможность включить закрытие рюкзака при повторном нажатии на UI-рюкзака или использовании бинда/команды - настраивается в конфигурационном файле
        /// - Если у игрока доступно 0 слотов рюкзака - UI более не отобразится
        /// - Если отключена возможность на улучшение рюкзака в меню крафта рюкзака не будут отображаться заблокированные слоты
        /// </summary>
        /// 

        #region Reference
        [PluginReference] Plugin ImageLibrary, IQChat, Battles, Duel;

        #region Duel / Battles
        public Boolean IsDuel(UInt64 userID)
        {
            if (Battles)
                return (Boolean)Battles?.Call("IsPlayerOnBattle", userID);
            else if (Duel) return (Boolean)Duel?.Call("IsPlayerOnActiveDuel", BasePlayer.FindByID(userID));
            else return false;
        }
        #endregion

        #region IQChat
        public void SendChat(String Message, BasePlayer player, Chat.ChatChannel channel = Chat.ChatChannel.Global)
        {
            Configuration.Reference.IQChat Chat = config.References.IQChatSetting;
            if (IQChat)
                if (Chat.UIAlertUse)
                    IQChat?.Call("API_ALERT_PLAYER_UI", player, Message);
                else IQChat?.Call("API_ALERT_PLAYER", player, Message, Chat.CustomPrefix, Chat.CustomAvatar);
            else player.SendConsoleCommand("chat.add", channel, 0, Message);
        }
        #endregion

        #region Image Library
        private String GetImage(String fileName, UInt64 skin = 0)
        {
            var imageId = (String)plugins.Find("ImageLibrary").CallHook("GetImage", fileName, skin);
            if (!string.IsNullOrEmpty(imageId))
                return imageId;
            return String.Empty;
        }
        private String GetImage(Configuration.Backpack.BackpackCraft.ItemCraft CItem)
        {
            String PNG = CItem.SkinID == 0 ? GetImage($"{CItem.Shortname}_128px") : GetImage($"{CItem.Shortname}_128px_{CItem.SkinID}", CItem.SkinID);
            return PNG;
        }
        public Boolean AddImage(String url, String shortname, UInt64 skin = 0) => (Boolean)ImageLibrary?.Call("AddImage", url, shortname, skin);
        public Boolean HasImage(String imageName) => (Boolean)ImageLibrary?.Call("HasImage", imageName);
        private IEnumerator DownloadImages()
        {
            Puts("Генерируем интерфейс...");

            if (!HasImage($"{config.BackpackItem.UrlBackpack}"))
                AddImage(config.BackpackItem.UrlBackpack, config.BackpackItem.UrlBackpack);

            foreach (Configuration.Backpack.BackpackCraft BPOption in config.BackpackItem.BackpacOption.Where(c => c.CraftItems != null && c.CraftItems.Count != 0))
                foreach (Configuration.Backpack.BackpackCraft.ItemCraft CItem in BPOption.CraftItems)
                {
                    if (CItem.SkinID != 0)
                    {
                        if (!HasImage($"{CItem.Shortname}_128px_{CItem.SkinID}"))
                            AddImage($"http://api.skyplugins.ru/api/getskin/{CItem.SkinID}/128", $"{CItem.Shortname}_128px_{CItem.SkinID}", CItem.SkinID);
                    }
                    else
                    {
                        if (!HasImage($"{CItem.Shortname}_128px"))
                            AddImage($"http://api.skyplugins.ru/api/getimage/{CItem.Shortname}/128", $"{CItem.Shortname}_128px");
                    }
                }
            yield return new WaitForSeconds(0.04f);

            Puts("Интерфейс был успешно сгенерирован!");

            _interface = new InterfaceBuilder();

            timer.Once(3f, () =>
            {
                foreach (BasePlayer player in BasePlayer.allPlayerList)
                    OnPlayerConnected(player);
            });
        }

        #endregion

        #endregion

        #region Vars
        public static IQBackpack _ = null;
        private enum TypeBackpack
        {
            Wear,
            OnlyPermission
        }
        private enum TypeDropBackpack
        {
            NoDrop,
            DropItems,
            DropBackpack,
        }
        private enum TypeDurability
        {
            None,
            Time,
            Count,
        }
        private Dictionary<BasePlayer, BackpackBehaviour> PlayerBackpack = new Dictionary<BasePlayer, BackpackBehaviour>();
        private Dictionary<BasePlayer, ShopFrontBehavior> PlayerUpgrades = new Dictionary<BasePlayer, ShopFrontBehavior>();
        private List<BasePlayer> PlayerUseBackpacks = new List<BasePlayer>();
        private Dictionary<BasePlayer, BackpackSpine> SpinesBackpacks = new Dictionary<BasePlayer, BackpackSpine>();

        #endregion

        #region Configuration

        private static Configuration config = new Configuration();
        private class Configuration
        {
            [JsonProperty("Настройка рюкзака")]
            public Backpack BackpackItem = new Backpack();
            [JsonProperty("Настройка поддерживающих плагинов")]
            public Reference References = new Reference();

            [JsonProperty("Дополнительная настройка")]
            public Turneds TurnedsSetting = new Turneds();
            internal class Turneds
            {
                [JsonProperty("Тип работы рюкзака : 0 - требуется надеть его, чтобы пользоватья, 1 - требуются лишь права(из вариаций рюкзаков)")]
                public TypeBackpack Types = TypeBackpack.Wear;
                [JsonProperty("Отображать рюкзак за спиной игрока(модельку рюкзака, работает на всех поворотах и изгибах игрока) [ВНИМАНИЕ, ИСПОЛЬЗУЙТЕ ЭТО НА PVE СЕРВЕРЕ, ИЗ-ЗА ОСОБЕННОСТЕЙ ИГРЫ В ТАКОЙ РЮКЗАК НА СПИНЕ НЕ БУДЕТ ПРОХОДИТЬ УРОН]")]
                public Boolean UseSpineBackpack = false;
                [JsonProperty("Использовать возможность скрафтить рюкзак (true - да/false - нет)")]
                public Boolean UseCrafting = true;
                [JsonProperty("Использовать возможность улучшать рюкзаки и увеличивать в нем слоты (true - да/false - нет) [Дополнительно настраивается в каждом рюкзаке, учтите - это общий параметр, детальная настройка в вариациях рюкзаков]")]
                public Boolean UseUpgradeBackpack = true;
                [JsonProperty("Закрывать рюкзак при повторном нажатии на UI/использовании бинда, если он открыт")]
                public Boolean ClosePressedAgain = true;
                [JsonProperty("Тип выпадения рюкзака : 0 - Не выпадает при смерти, 1 - Выбрасывает предметы вокруг трупа, 2 - Выбрасывает рюкзак с предметами")]
                public TypeDropBackpack TypeDropBackpack = TypeDropBackpack.DropBackpack;
                [JsonProperty("Время удаления рюкзака при выпадении (Работает с : 2 - Выбрасывает рюкзак с предметами)")]
                public Single RemoveBackpack = 200f;
                [JsonProperty("Настройка интерфейса")]
                public VisualBackpackSlot VisualBackpackSlots = new VisualBackpackSlot();

                internal class VisualBackpackSlot
                {
                    [JsonProperty("Использовать отображение UI рюкзака возле слотов (true - да/false - нет)")]
                    public Boolean UseVisual = true;
                    [JsonProperty("Отображать количество слотов в рюкзаке на UI (true - да/false - нет)")]
                    public Boolean UseSlots = true;
                    [JsonProperty("Отображать полосу заполненности рюкзака на UI (true - да/false - нет)")]
                    public Boolean UseIsFulled = true;
                    [JsonProperty("Разрешить открывать рюкзак нажава на UI интерфейс (true - да/false - нет)")]
                    public Boolean UseButton = true;
                    [JsonProperty("Настройка цветов полосы заполненности")]
                    public ColorProgress ColorProgressBar = new ColorProgress();
                    [JsonProperty("Настройка позиции UI слота с рюкзаком")]
                    public Position PositionSlotVisual = new Position();
                    [JsonProperty("Настройка позиции UI для улучшения рюкзака")]
                    public Position PositionUpgrade = new Position();
                    internal class ColorProgress
                    {
                        [JsonProperty("Цвет полосы заполненности, когда рюкзак заполнен на >30%")]
                        public String ColorMinimal = "0.44 0.53 0.26 1.00";
                        [JsonProperty("Цвет полосы заполненности, когда рюкзак заполнен на >60%")]
                        public String ColorAverage = "0.98 0.53 0.26 1.00";
                        [JsonProperty("Цвет полосы заполненности, когда рюкзак заполнен на >80%")]
                        public String ColorMaximum = "0.98 0.20 0.28 1.00";
                    }
                    internal class Position
                    {
                        public String AnchorMin;
                        public String AnchorMax;
                        public String OffsetMin;
                        public String OffsetMax;
                    }

                }
            }
            internal class Reference
            {
                [JsonProperty("Настройка IQChat")]
                public IQChat IQChatSetting = new IQChat();
                internal class IQChat
                {
                    [JsonProperty("IQChat : Кастомный префикс в чате")]
                    public String CustomPrefix = "[IQBackpack]";
                    [JsonProperty("IQChat : Кастомный аватар в чате(Если требуется)")]
                    public String CustomAvatar = "0";
                    [JsonProperty("IQChat : Использовать UI уведомления")]
                    public Boolean UIAlertUse = false;
                }
            }
            internal class Backpack
            {
                [JsonProperty("Shortname для рюкзака (нужен предмет, который является одеждой)")]
                public String Shortname = "burlap.gloves";     
                [JsonProperty("SkinID рюкзака")]
                public UInt64 SkinID = 2726640855; 
                [JsonProperty("Ссылка на картинку для отображения рюкзака")]
                public String UrlBackpack = "https://i.imgur.com/rPeKd9R.png"; 
                
                [JsonProperty("Вариации рюкзаков по привилегиям (Дается доступный набор игроку, который выше других)")]
                public List<BackpackCraft> BackpacOption = new List<BackpackCraft>();
                internal class BackpackCraft
                {
                    [JsonProperty("Права для возможности крафтить и носить данный рюкзак(не оставляйте это поле пустым, иначе оно не будет учитываться)")]
                    public String Permissions = "iqbackpack.7slot";
                    [JsonProperty("Количество слотов у данного рюкзака")]
                    public Int32 AmountSlot = 7;
                    [JsonProperty("Черный список предметов для данного рюкзака")]
                    public List<String> BlackListItems = new List<String>();
                    [JsonProperty("Предметы для крафта рюкзака")]
                    public List<ItemCraft> CraftItems = new List<ItemCraft>();
                    [JsonProperty("Настройка улучшений рюкзака (Улучшение будет постепенное в зависимости от листа, сверху -> вниз (максимальное количество слотов - 42))")]
                    public List<UpgradeBackpack> UpgradeList = new List<UpgradeBackpack>();
                    internal class UpgradeBackpack
                    {
                        [JsonProperty("Предметы для улучшения на этот уровень")]
                        public List<ItemCraft> CraftItems = new List<ItemCraft>();
                        [JsonProperty("Сколько слотов добавлять за это улучшение")]
                        public Int32 SlotUpgrade;
                    }
                    internal class ItemCraft
                    {
                        public String Shortname;
                        public UInt64 SkinID;
                        [JsonProperty("Количество")]
                        public Int32 Amount;
                    }
                }

            }
            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    BackpackItem = new Backpack
                    {
                        Shortname = "burlap.gloves",
                        SkinID = 2726640855,
                        UrlBackpack = "https://i.imgur.com/rPeKd9R.png",

                        BackpacOption = new List<Backpack.BackpackCraft>
                        {
                            new Backpack.BackpackCraft
                            {
                                AmountSlot = 7,
                                Permissions = "iqbackpack.7slot",
                                BlackListItems = new List<String> { },
                                CraftItems = new List<Backpack.BackpackCraft.ItemCraft>{ },
                                UpgradeList = new List<Backpack.BackpackCraft.UpgradeBackpack> {  },
                            },
                            new Backpack.BackpackCraft
                            {
                                AmountSlot = 15,
                                Permissions = "iqbackpack.15slot",
                                BlackListItems = new List<String>
                                {
                                    "rocket.launcher",
                                    "ammo.rocket.basic",
                                    "explosive.satchel",
                                    "supply.signal",
                                    "explosive.timed",
                                },
                                CraftItems = new List<Backpack.BackpackCraft.ItemCraft>
                                {
                                    new Backpack.BackpackCraft.ItemCraft
                                    {
                                        Shortname = "leather",
                                        Amount = 50,
                                        SkinID = 0
                                    },
                                    new Backpack.BackpackCraft.ItemCraft
                                    {
                                        Shortname = "cloth",
                                        Amount = 200,
                                        SkinID = 0
                                    },
                                    new Backpack.BackpackCraft.ItemCraft
                                    {
                                        Shortname = "sewingkit",
                                        Amount = 10,
                                        SkinID = 0
                                    },
                                },
                                UpgradeList = new List<Backpack.BackpackCraft.UpgradeBackpack>
                                {
                                    new Backpack.BackpackCraft.UpgradeBackpack
                                    {
                                        SlotUpgrade = 3,
                                        CraftItems = new List<Backpack.BackpackCraft.ItemCraft>
                                        {
                                            new Backpack.BackpackCraft.ItemCraft
                                            {
                                                Shortname = "burlap.gloves",
                                                Amount = 1,
                                                SkinID = 2726640855
                                            },
                                            new Backpack.BackpackCraft.ItemCraft
                                            {
                                                Shortname = "leather",
                                                Amount = 150,
                                                SkinID = 0
                                            },
                                            new Backpack.BackpackCraft.ItemCraft
                                            {
                                                Shortname = "cloth",
                                                Amount = 300,
                                                SkinID = 0
                                            },
                                            new Backpack.BackpackCraft.ItemCraft
                                            {
                                                Shortname = "sewingkit",
                                                Amount = 5,
                                                SkinID = 0
                                            },
                                            new Backpack.BackpackCraft.ItemCraft
                                            {
                                                Shortname = "metal.fragments",
                                                Amount = 1000,
                                                SkinID = 0
                                            },
                                        }
                                    },
                                    new Backpack.BackpackCraft.UpgradeBackpack
                                    {
                                        SlotUpgrade = 10,
                                        CraftItems = new List<Backpack.BackpackCraft.ItemCraft>
                                        {
                                            new Backpack.BackpackCraft.ItemCraft
                                            {
                                                Shortname = "burlap.gloves",
                                                Amount = 1,
                                                SkinID = 2726640855
                                            },
                                            new Backpack.BackpackCraft.ItemCraft
                                            {
                                                Shortname = "leather",
                                                Amount = 500,
                                                SkinID = 0
                                            },
                                            new Backpack.BackpackCraft.ItemCraft
                                            {
                                                Shortname = "cloth",
                                                Amount = 1000,
                                                SkinID = 0
                                            },
                                            new Backpack.BackpackCraft.ItemCraft
                                            {
                                                Shortname = "sewingkit",
                                                Amount = 25,
                                                SkinID = 0
                                            },
                                            new Backpack.BackpackCraft.ItemCraft
                                            {
                                                Shortname = "metal.fragments",
                                                Amount = 15000,
                                                SkinID = 0
                                            },
                                        }
                                    },
                                }
                            }
                        }
                    },
                    TurnedsSetting = new Turneds
                    {
                        Types = TypeBackpack.Wear,
                        UseCrafting = true,
                        UseUpgradeBackpack = true,
                        ClosePressedAgain = true,
                        UseSpineBackpack = false,
                        TypeDropBackpack = TypeDropBackpack.DropBackpack,
                        RemoveBackpack = 200f,
                        VisualBackpackSlots = new Turneds.VisualBackpackSlot
                        {
                            UseVisual = true,
                            UseSlots = true,
                            UseIsFulled = true,
                            UseButton = true,
                            ColorProgressBar = new Turneds.VisualBackpackSlot.ColorProgress
                            {
                                ColorMinimal = "0.44 0.53 0.26 1.00",
                                ColorAverage = "0.98 0.53 0.26 1.00",
                                ColorMaximum = "0.98 0.20 0.28 1.00",
                            },
                            PositionSlotVisual = new Turneds.VisualBackpackSlot.Position
                            {
                                AnchorMin = "0.5 0",
                                AnchorMax = "0.5 0",
                                OffsetMin = "-264.276 17.943",
                                OffsetMax = "-203.724 78.087"
                            },
                            PositionUpgrade = new Turneds.VisualBackpackSlot.Position
                            {
                                AnchorMin = "0.5 0.5", 
                                AnchorMax = "0.5 0.5",
                                OffsetMin = "194.836 -36.769",
                                OffsetMax = "575.164 36.785"
                            }
                        },
                    },
                    References = new Reference
                    {
                        IQChatSetting = new Reference.IQChat
                        {
                            CustomAvatar = "0",
                            CustomPrefix = "[IQBackpack] ",
                            UIAlertUse = false,
                        }
                    }
                 };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning("Ошибка " + $"чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }
            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region Data

        public Dictionary<UInt64, BackpackInfo> Backpacks = new Dictionary<UInt64, BackpackInfo>();
        internal class BackpackInfo
        {
            public Int32 AmountSlot = 0;
            public Int32 IndexUpgrade = -1;
            public List<SavedItem> Items = new List<SavedItem>();

            internal class SavedItem
            {
                public Int32 TargetSlot;
                public String Shortname;
                public Int32 Itemid;
                public Single Condition;
                public Single Maxcondition;
                public Int32 Amount;
                public Int32 Ammoamount;
                public String Ammotype;
                public Int32 Flamefuel;
                public UInt64 Skinid;
                public String Name;
                public Boolean Weapon;
                public Int32 Blueprint;
                public Single BusyTime;
                public Boolean OnFire;
                public List<SavedItem> Mods;
            }
        }
        void ReadData() => Backpacks = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<UInt64, BackpackInfo>>("IQBackpack/Backpacks");
        void WriteData() => Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQBackpack/Backpacks", Backpacks);

        #endregion

        #region Hooks
        void Init() => ReadData();
        void OnServerInitialized()
        {
            _ = this;
            ServerMgr.Instance.StartCoroutine(DownloadImages());

            RegisteredPermissions();

            if(config.TurnedsSetting.TypeDropBackpack == TypeDropBackpack.NoDrop)
                Unsubscribe("OnPlayerDeath");

            if (config.TurnedsSetting.Types == TypeBackpack.OnlyPermission)
                Unsubscribe("CanWearItem");
            else
            {
                Unsubscribe("OnUserPermissionGranted");
                Unsubscribe("OnUserPermissionRevoked");
                Unsubscribe("OnUserGroupAdded");
                Unsubscribe("OnUserGroupRemoved");
            }

            if (!config.TurnedsSetting.UseUpgradeBackpack)
            {
                Unsubscribe("CanLootEntity");
                Unsubscribe("OnItemStacked");
                Unsubscribe("OnItemSplit");
                Unsubscribe("CanStackItem");
            }
            if (!config.TurnedsSetting.UseSpineBackpack)
                Unsubscribe("OnPlayerDisconnected");
        }
        void OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            if (player == null) return;
            DropBackpack(player, config.TurnedsSetting.TypeDropBackpack);
            return;
        }
        void OnPlayerConnected(BasePlayer player)
        {
            if (_interface == null)
            {
                timer.Once(3f, () => OnPlayerConnected(player));
                return;
            }
            if (player == null) return;

            if (!PlayerBackpack.ContainsKey(player))
                PlayerBackpack.Add(player, null);

            if (config.TurnedsSetting.UseUpgradeBackpack)
                if (!PlayerUpgrades.ContainsKey(player))
                    PlayerUpgrades.Add(player, null);

            if (!config.TurnedsSetting.VisualBackpackSlots.UseVisual) return;

            if (config.TurnedsSetting.Types == TypeBackpack.Wear) { 
                if (GetBackpack(player) == null) return;
            }
            else {
                if (!Backpacks.ContainsKey(player.userID))
                    Backpacks.Add(player.userID, new BackpackInfo 
                    {
                        AmountSlot = GetAvailableSlots(player)
                    });
            }

            if (!player.IsDead() && !IsDuel(player.userID))
            {
                DrawUI_Backpack_Visual(player);
                BackpackSpawnSpine(player);
            }
        }
        void OnPlayerDisconnected(BasePlayer player, string reason) => BackpackRemoveSpine(player);
        private void OnServerShutdown() => Unload();

        void Unload()
        {
            ServerMgr.Instance.StopCoroutine(DownloadImages());
            InterfaceBuilder.DestroyAll();
            WriteData();

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                foreach (Item item in player.inventory.AllItems())
                    item.SetFlag(global::Item.Flag.IsLocked, false);

            foreach (BasePlayer player in BasePlayer.activePlayerList.Where(p => PlayerBackpack.ContainsKey(p) && PlayerBackpack[p] != null))
                PlayerBackpack[player].Destroy();

            if (config.TurnedsSetting.UseUpgradeBackpack)
                foreach (BasePlayer player in BasePlayer.activePlayerList.Where(p => PlayerUpgrades.ContainsKey(p) && PlayerUpgrades[p] != null))
                    PlayerUpgrades[player].Destroy();

            if (SpinesBackpacks != null && SpinesBackpacks.Count != 0)
                foreach (KeyValuePair<BasePlayer, BackpackSpine> sBp in SpinesBackpacks.Where(bp => bp.Value != null))
                    sBp.Value.KillParent();

            SpinesBackpacks.Clear();

            _ = null;
        }

        #region Backpack Hooks
        public Dictionary<UInt64, List<Connection>> ContainerGetPlayer = new Dictionary<UInt64, List<Connection>>();
        void NetworkIDGetSet(UInt64 NetID, Boolean SetOrRemove, BasePlayer player = null)
        {
            if (player == null) return;
            if (!ContainerGetPlayer.ContainsKey(NetID))
                ContainerGetPlayer.Add(NetID, new List<Connection> { player.Connection });
            else
            {
                if (SetOrRemove)
                {
                    if (!ContainerGetPlayer[NetID].Contains(player.Connection))
                        ContainerGetPlayer[NetID].Add(player.Connection);
                }
                else
                {
                    if (ContainerGetPlayer[NetID].Count <= 1)
                        ContainerGetPlayer.Remove(NetID);
                    else ContainerGetPlayer[NetID].Remove(player.Connection);
                }
            }
        }

        object OnLootNetworkUpdate(PlayerLoot loot)
        {
            if (loot == null)
                return null;
            BasePlayer player = loot.GetComponent<BasePlayer>();
            if (player == null)
                return null;
            if (loot.entitySource == null || loot.entitySource.net == null)
                return null;
            UInt64 NetID = loot.entitySource.net.ID;
            NetworkIDGetSet(NetID, true, player);
            return null;
        }
        void CanLootEntity(BasePlayer player, StorageContainer container)
        {
            if (container == null || player == null || !(Boolean)(container is Workbench)) return;
            DrawUI_Backpack_Upgrade_Workbench(player);
            return;
        }

        void OnPlayerSleepEnded(BasePlayer player) => OnPlayerConnected(player);
        void OnLootEntityEnd(BasePlayer player, BaseCombatEntity entity)
        {
            if (entity == null || player == null) return;

            Item backpack = GetBackpack(player);

            if (config.TurnedsSetting.UseUpgradeBackpack)
            {
                if (entity is Workbench)
                {
                    CuiHelper.DestroyUi(player, InterfaceBuilder.UI_Backpack_Upgrade_Workbench);
                    CuiHelper.DestroyUi(player, InterfaceBuilder.UI_Backpack_Upgrade_Info);
                    return;
                }
                if (entity is ShopFront)
                {
                    ShopFrontBehavior upgradeHandler = null;
                    if (PlayerUpgrades.ContainsKey(player) && PlayerUpgrades[player] != null)
                        upgradeHandler = PlayerUpgrades[player];

                    if (upgradeHandler != null)
                        upgradeHandler.Close();

                    CuiHelper.DestroyUi(player, InterfaceBuilder.UI_Backpack_Upgrade_Workbench);
                    CuiHelper.DestroyUi(player, InterfaceBuilder.UI_Backpack_Upgrade_Info);

                    if (config.TurnedsSetting.Types == TypeBackpack.Wear)
                        if (backpack == null) return;

                    DrawUI_Backpack_Visual(player);
                    BackpackSpawnSpine(player);
                    return;
                }

                UInt64 NetID = entity.net.ID;
                NetworkIDGetSet(NetID, false, player);
            }

            if (config.TurnedsSetting.Types == TypeBackpack.Wear)
                if (backpack == null) return;

            BackpackBehaviour backpackHandler = null;
            if (PlayerBackpack.ContainsKey(player) && PlayerBackpack[player] != null)
                backpackHandler = PlayerBackpack[player];

            StorageContainer storage = entity as StorageContainer;

            if (player != null && storage != null && backpackHandler != null && storage == backpackHandler.Container)
            {
                backpackHandler.Close();
                DrawUI_Backpack_Visual(player);
                BackpackSpawnSpine(player);
            }
        }

        object CanWearItem(PlayerInventory inventory, Item item, int targetSlot)
        {
            if (inventory == null || item == null) return null;
            BasePlayer player = inventory.gameObject.ToBaseEntity() as BasePlayer;

            if (config.TurnedsSetting.Types == TypeBackpack.Wear)
                if (player != null && item.skin == config.BackpackItem.SkinID)
                {
                    if (!Backpacks.ContainsKey(item.uid) && item.skin == config.BackpackItem.SkinID)
                        Backpacks.Add(item.uid, new BackpackInfo());

                    if (GetBackpack(player) != null) return false;
                    NextTick(() =>
                    {
                        DrawUI_Backpack_Visual(player);
                        BackpackSpawnSpine(player);
                        if (player?.inventory?.loot?.entitySource is Workbench)
                            DrawUI_Backpack_Upgrade_Workbench(player);
                    });
                }

            return null;
        }
        void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            if (item == null || container == null) return;
            BasePlayer player = container.playerOwner;

            if (player == null || player is ScientistNPC || player is HumanNPC || player is NPCPlayer) return;

            if (config.TurnedsSetting.Types == TypeBackpack.Wear)
                if (item.skin == config.BackpackItem.SkinID)
                {
                    if (GetBackpack(player) == null)
                    {
                        CuiHelper.DestroyUi(player, InterfaceBuilder.UI_Backpack_Visual);
                        BackpackRemoveSpine(player);
                    }
                }

            if (config.TurnedsSetting.UseUpgradeBackpack)
            {
                if (container?.entityOwner is ShopFront || player?.inventory?.loot?.entitySource is ShopFront)
                {
                    if (PlayerUpgrades.ContainsKey(player) && (container.playerOwner == player || container.uid == (UInt32)player.userID))
                        if (PlayerUpgrades[player] != null)
                        {
                            PlayerUpgrades[player].VendorLock(true);
                            DrawUI_Backpack_Upgrade_Info_Controller(player);
                        }
                    return;
                }
                if (player?.inventory?.loot?.entitySource is Workbench)
                {
                    DrawUI_Backpack_Upgrade_Workbench(player);
                    return;
                }
            }
        }
        void OnItemDropped(Item item, BaseEntity entity)
        {
            if (item == null || entity == null) return;
            BasePlayer player = item.GetOwnerPlayer();
            if (player == null || player is ScientistNPC || player is HumanNPC || player is NPCPlayer) return;

            if (config.TurnedsSetting.Types == TypeBackpack.Wear)
                if (item.skin == config.BackpackItem.SkinID)
                {
                    NextTick(() =>
                    {
                        if (GetBackpack(player) == null)
                        {
                            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_Backpack_Visual);
                            BackpackRemoveSpine(player);
                        }
                    });
                    return;
                }

            if (config.TurnedsSetting.UseUpgradeBackpack)
            {
                if ((Boolean)(item?.GetRootContainer()?.entityOwner is ShopFront))
                {
                    if (PlayerUpgrades.ContainsKey(player))
                    {
                        NextTick(() =>
                        {
                            if (PlayerUpgrades[player] != null && PlayerUpgrades[player].Container.vendorInventory != null && PlayerUpgrades[player].Container.customerInventory != null)
                                PlayerUpgrades[player].VendorLock(true);
                            DrawUI_Backpack_Upgrade_Info_Controller(player);
                        });
                    }
                    return;
                }
                if (player?.inventory?.loot?.entitySource is Workbench)
                {
                    NextTick(() => { DrawUI_Backpack_Upgrade_Workbench(player); });
                    return;
                }
            }
        }
        void OnItemStacked(Item destinationItem, Item sourceItem, ItemContainer destinationContainer)
        {
            if (destinationItem == null || sourceItem == null || destinationContainer == null) return;
            BasePlayer player = destinationContainer.playerOwner;
            if (player == null || player is ScientistNPC || player is HumanNPC || player is NPCPlayer) return;

            if (PlayerUpgrades.ContainsKey(player))
            {
                if (PlayerUpgrades[player] != null && PlayerUpgrades[player].Container.vendorInventory != null && PlayerUpgrades[player].Container.customerInventory != null)
                    PlayerUpgrades[player].VendorLock(true);

                DrawUI_Backpack_Upgrade_Info_Controller(player);
            }
        }
        private Item OnItemSplit(Item item, int amount)
        {
            if (item == null) return null;
            if (plugins.Find("Stacks") || plugins.Find("CustomSkinsStacksFix") || plugins.Find("SkinBox")) return null;
            if (item.IsLocked())
            {
                Item x = ItemManager.CreateByPartialName(item.info.shortname, amount);
                x.name = item.name;
                x.skin = item.skin;
                x.amount = amount;
                x.SetFlag(global::Item.Flag.IsLocked, true);
                item.amount -= amount;
                return x;
            }
            return null;
        }

        object CanStackItem(Item item, Item targetItem)
        {
            if (item == null || targetItem == null) return null;
            BasePlayer player = item.GetOwnerPlayer();
            if (player == null || player is ScientistNPC || player is HumanNPC || player is NPCPlayer) return null;
            if (PlayerUpgrades.ContainsKey(player))
            {
                NextTick(() =>
                {
                    if (PlayerUpgrades[player] != null && PlayerUpgrades[player].Container.vendorInventory != null && PlayerUpgrades[player].Container.customerInventory != null)
                        PlayerUpgrades[player].VendorLock(true);
                    DrawUI_Backpack_Upgrade_Info_Controller(player);
                });
            }
            return null;
        }
        object CanAcceptItem(ItemContainer container, Item item)
        {
            if (container == null || item == null) return null;
            BasePlayer player = container.playerOwner;
            if (player == null)
            {
                if (config.TurnedsSetting.Types == TypeBackpack.Wear)
                {
                    NextTick(() =>
                    {
                        //// ERROR ???
                        if (item.parent == null || item.parent.entityOwner == null || item.parent.entityOwner.net == null) return;
                        if (item.skin != config.BackpackItem.SkinID) return;
                        UInt64 NetID = item.parent.entityOwner.net.ID;
                        if (NetID == 0) return;
                        if (ContainerGetPlayer.ContainsKey(NetID))
                            CommunityEntity.ServerInstance.ClientRPCEx(new SendInfo(ContainerGetPlayer[NetID]), null, "DestroyUI", "UI_BACKPACK_VISUAL");
                    });
                }
                return null;
            }
            if (player is ScientistNPC || player is HumanNPC || player is NPCPlayer) return null;
            if (!PlayerUseBackpacks.Contains(player)) return null;

            if (config.TurnedsSetting.Types == TypeBackpack.Wear)
                if (item.skin == config.BackpackItem.SkinID)
                {
                    if (item.IsLocked())
                        return ItemContainer.CanAcceptResult.CannotAccept;

                    CuiHelper.DestroyUi(player, InterfaceBuilder.UI_Backpack_Visual);
                    BackpackRemoveSpine(player);
                    return null;
                }
            if (GetBackpackOption(player).BlackListItems.Contains(item.info.shortname) && item.IsLocked())
                return ItemContainer.CanAcceptResult.CannotAccept;

            return null;
        }


        #endregion

        #region Permissions Hooks
        
        void OnUserPermissionGranted(string id, string permName) => UpdatePermissions(id, permName, true);
        void OnUserPermissionRevoked(string id, string permName) => UpdatePermissions(id, permName, false);

        void OnUserGroupAdded(string id, string groupName)
        {
            String[] PermissionsGroup = permission.GetGroupPermissions(groupName);
            if (PermissionsGroup == null) return;

            foreach (var Option in config.BackpackItem.BackpacOption.Where(x => PermissionsGroup.Contains(x.Permissions)))
                UpdatePermissions(id, Option.Permissions, true);
        }

        void OnUserGroupRemoved(string id, string groupName)
        {
            String[] PermissionsGroup = permission.GetGroupPermissions(groupName);
            if (PermissionsGroup == null) return;

            foreach (var Option in config.BackpackItem.BackpacOption.Where(x => PermissionsGroup.Contains(x.Permissions)))
                UpdatePermissions(id, Option.Permissions, false);
        }
        void OnGroupPermissionGranted(string name, string perm)
        {
            String[] GroupUser = permission.GetUsersInGroup(name);
            if (GroupUser == null) return;

            foreach(String IDs in GroupUser)
                UpdatePermissions(IDs.Substring(0,17), perm, true);
        }
        void OnGroupPermissionRevoked(string name, string perm)
        {
            String[] GroupUser = permission.GetUsersInGroup(name);
            if (GroupUser == null) return;

            foreach (String IDs in GroupUser)
                UpdatePermissions(IDs.Substring(0, 17), perm, false);
        }
        #endregion

        #endregion

        #region Metods

        #region Backpack Permissions
        private void UpdatePermissions(String ID, String Permissions, Boolean IsGranted)
        {          
            UInt64 UserID = UInt64.Parse(ID);
            BasePlayer player = BasePlayer.FindByID(UserID);
            if(player == null) return;

            UInt64 IDBackpack = GetBackpackID(player);
            if (!Backpacks.ContainsKey(IDBackpack)) return;
            player.EndLooting();

            Int32 AvailableSlots = GetAvailableSlots(player);
            if (AvailableSlots < GetBusySlotsBackpack(player))
            {
                Int32 Count = Backpacks[IDBackpack].Items.Count - 1;
                foreach (BackpackInfo.SavedItem Sitem in Backpacks[IDBackpack].Items.Take((Backpacks[IDBackpack].Items.Count - AvailableSlots)))
                {
                    NextTick(() =>
                    {
                        Item itemDrop = BuildItem(Sitem);
                        itemDrop.DropAndTossUpwards(player.transform.position, 2f);

                        Backpacks[IDBackpack].Items.RemoveAt(Count);
                        Count--;
                    });
                }
            }
            Backpacks[IDBackpack].AmountSlot = AvailableSlots;
            
            NextTick(() => { 
                DrawUI_Backpack_Visual(player);
                SendChat(GetLang((IsGranted ? "BACKPACK_GRANT" : "BACKPACK_REVOKE"), player.UserIDString, AvailableSlots), player);
            });
        }
        #endregion

        #region Backpack Action
        private void OpenBP(BasePlayer player)
        {
            if (IsDuel(player.userID)) return;
            Item backpack = GetBackpack(player);

            if (config.TurnedsSetting.Types == TypeBackpack.Wear)
                if (backpack == null)
                {
                    SendChat(GetLang("BACKPACK_NO_WEARING", player.UserIDString), player);
                    return;
                }

            BackpackBehaviour backpackHandler = null;
            if (PlayerBackpack.ContainsKey(player))
            {
                if (PlayerBackpack[player] != null)
                    backpackHandler = PlayerBackpack[player];
            }
            else PlayerBackpack.Add(player, null);
            if (backpackHandler == null)
            {
                backpackHandler = player.gameObject.AddComponent<BackpackBehaviour>();
                backpackHandler.Backpack = backpack;

                PlayerBackpack[player] = backpackHandler;
            }
            if (backpackHandler.Container != null)
            {
                if (config.TurnedsSetting.ClosePressedAgain)
                    player.EndLooting();
                else SendChat(GetLang("BACKPACK_IS_OPENED", player.UserIDString), player);
                return;
            }
            backpackHandler.Open();
        }

        private void BackpackSpawnSpine(BasePlayer player)
        {
            if (!config.TurnedsSetting.UseSpineBackpack) return;
            if (SpinesBackpacks.ContainsKey(player) && SpinesBackpacks[player] != null) return;
            BackpackSpine backpackSpine = player.gameObject.AddComponent<BackpackSpine>();
            SpinesBackpacks.Add(player,backpackSpine);
        }
        private void BackpackRemoveSpine(BasePlayer player)
        {
            if (!config.TurnedsSetting.UseSpineBackpack) return;
            if (!SpinesBackpacks.ContainsKey(player) || SpinesBackpacks[player] == null) return;

            SpinesBackpacks[player].KillParent();
            SpinesBackpacks.Remove(player);
        }

        #endregion

        #region Generate Backpack

        public static StorageContainer CreateContainer(BasePlayer player)
        {
            StorageContainer storage = GameManager.server.CreateEntity("assets/prefabs/misc/halloween/coffin/coffinstorage.prefab") as StorageContainer;
            if (storage == null) return null;

            var containerEntity = storage as StorageContainer;
            if (containerEntity == null)
            {
                UnityEngine.Object.Destroy(storage);
                return null;
            }
            UnityEngine.Object.DestroyImmediate(storage.GetComponent<DestroyOnGroundMissing>());
            UnityEngine.Object.DestroyImmediate(storage.GetComponent<GroundWatch>());

            foreach (var collider in storage.GetComponentsInChildren<Collider>())
                UnityEngine.Object.DestroyImmediate(collider);

            storage.transform.position = new Vector3(player.ServerPosition.x, player.ServerPosition.y - 100f, player.ServerPosition.z);
            storage.panelName = "generic_resizable";

            ItemContainer container = new ItemContainer { playerOwner = player };
            container.ServerInitialize((Item)null, _.GetSlotsBackpack(player));
            if ((Int32)container.uid == 0)
                container.GiveUID();

            storage.inventory = container;
            storage.OwnerID = player.userID;

            storage._limitedNetworking = false;
            storage.EnableSaving(false);

            storage.SendMessage("SetDeployedBy", player, (SendMessageOptions)SendMessageOptions.DontRequireReceiver);
            storage.Spawn();

            storage.inventory.allowedContents = ItemContainer.ContentsType.Generic;
            return storage;
        }
       
        private static void PlayerLootContainer(BasePlayer player, StorageContainer container)
        {
            container.SetFlag(BaseEntity.Flags.Open, true, false);
            player.inventory.loot.StartLootingEntity(container, false);
            player.inventory.loot.AddContainer(container.inventory);
            player.inventory.loot.SendImmediate();
            player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", "generic_resizable");
            container.SendNetworkUpdate();
        }

        #endregion

        #region Upgrade Backpack

        #region Generate Shop Front
        public static ShopFront CreateShopFront(BasePlayer player)
        {
            ShopFront shopFront = GameManager.server.CreateEntity("assets/prefabs/building/wall.frame.shopfront/wall.frame.shopfront.metal.prefab") as ShopFront;
            if (shopFront == null) return null;

            shopFront.transform.position = new Vector3(player.ServerPosition.x, player.ServerPosition.y + 100f, player.ServerPosition.z);
            shopFront.panelName = "shopfront";

            if (!shopFront) return null;

            UnityEngine.Object.DestroyImmediate(shopFront.GetComponent<DestroyOnGroundMissing>());
            UnityEngine.Object.DestroyImmediate(shopFront.GetComponent<GroundWatch>());

            foreach (var collider in shopFront.GetComponentsInChildren<Collider>())
                UnityEngine.Object.DestroyImmediate(collider);

            shopFront._limitedNetworking = true;
            shopFront.EnableSaving(false);

            shopFront.SendMessage("SetDeployedBy", player, (SendMessageOptions)SendMessageOptions.DontRequireReceiver);
            shopFront.Spawn();

            return shopFront;
        }

        private static void PlayerLootContainer(BasePlayer player, ShopFront shopFront, List<Configuration.Backpack.BackpackCraft.ItemCraft> ItemList)
        {
            shopFront.SetFlag(BaseEntity.Flags.Open, true, false);

            shopFront.vendorInventory.capacity = 12;
            shopFront.customerInventory.capacity = 12;

            shopFront.customerPlayer = player;
            shopFront.customerInventory.playerOwner = player;
            shopFront.customerInventory.uid = (UInt32)player.userID;

            foreach (Configuration.Backpack.BackpackCraft.ItemCraft UpgradeItems in ItemList)
            {
                Item item = ItemManager.CreateByName(UpgradeItems.Shortname, UpgradeItems.Amount, UpgradeItems.SkinID);
                item.MoveToContainer(shopFront.vendorInventory);
            }

            player.inventory.loot.StartLootingEntity(shopFront, false);
            player.inventory.loot.AddContainer(shopFront.vendorInventory);
            player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", "shopfront");
            player.inventory.loot.AddContainer(shopFront.customerInventory);
            player.inventory.loot.SendImmediate();

            shopFront.UpdatePlayers();
            shopFront.DecayTouch();
            shopFront.SendNetworkUpdate();
        }
        #endregion

        private void OpenUpgradeMenu(BasePlayer player)
        {
            if (!config.TurnedsSetting.UseUpgradeBackpack) return;
            if (player == null) return;

            ShopFrontBehavior upgradeHandler = null;
            if (PlayerBackpack.ContainsKey(player))
            {
                if (PlayerBackpack[player] != null)
                    upgradeHandler = PlayerUpgrades[player];
            }
            else PlayerBackpack.Add(player, null);

            if (upgradeHandler == null)
            {
                upgradeHandler = player.gameObject.AddComponent<ShopFrontBehavior>();
                PlayerUpgrades[player] = upgradeHandler;
            }
            if (upgradeHandler.Container != null) return;

            upgradeHandler.Open();
        }

        private void UpgradeBackpack(BasePlayer player)
        {
            if (player == null) return;
            if (!PlayerUpgrades.ContainsKey(player)) return;
            if (!HaveAllItem(player, PlayerUpgrades[player].ItemList, PlayerUpgrades[player].Container.customerInventory)) return;
            Configuration.Backpack.BackpackCraft Option = GetBackpackOption(player);
            if (Option == null) return;
            UInt64 ID = PlayerUpgrades[player].BackpackID;
            Int32 IndexUpgrade = Backpacks[ID].IndexUpgrade;
            if (Option.UpgradeList[IndexUpgrade + 1] == null) return;

            PlayerUpgrades[player].Container.customerInventory.SetLocked(true);

            TakeItems(player, PlayerUpgrades[player].ItemList, PlayerUpgrades[player].Container.customerInventory);

            if(PlayerUpgrades[player].ItemList.Count(x => x.SkinID == config.BackpackItem.SkinID) != 0)
            {
                Item backpack = ItemManager.CreateByName(config.BackpackItem.Shortname, 1, config.BackpackItem.SkinID);
                Int32 Slot = Backpacks[ID].AmountSlot + Option.UpgradeList[IndexUpgrade + 1].SlotUpgrade;

                backpack.name = GetLang("BACKPACK_TITLE", player.UserIDString, Slot);

                Backpacks.Add(backpack.uid, new BackpackInfo()
                {
                    AmountSlot = Slot,
                    IndexUpgrade = IndexUpgrade + 1,
                    Items = Backpacks[ID].Items
                });

                player.GiveItem(backpack);
                Backpacks.Remove(ID);
            }
            else
            {
                Backpacks[ID].IndexUpgrade++;
                Backpacks[ID].AmountSlot += PlayerUpgrades[player].UpgradeSlotsUp;

                if (config.TurnedsSetting.Types == TypeBackpack.Wear)
                {
                    Item BackpackItem = GetBackpack(player);
                    if (BackpackItem != null)
                    {
                        BackpackItem.name = GetLang("BACKPACK_TITLE", player.UserIDString, Backpacks[ID].AmountSlot);
                        player.SendNetworkUpdate();
                        BackpackItem.MarkDirty();
                    }
                    //else
                    //{
                    //    Item itemBackpack = player.inventory.AllItems().FirstOrDefault(x => x.skin == config.BackpackItem.SkinID && x.info.shortname == config.BackpackItem.Shortname);
                    //    if(itemBackpack != null)
                    //    {
                    //        itemBackpack.name = GetLang("BACKPACK_TITLE", player.UserIDString, Backpacks[ID].AmountSlot);
                    //        player.SendNetworkUpdate();
                    //        itemBackpack.MarkDirty();
                    //    }
                    //}
                }
            }

            PlayerUpgrades[player].Container.PlayerStoppedLooting(player);
        }


        #endregion

        #region Saved Items
        private List<BackpackInfo.SavedItem> GetSavedList(UInt64 ID)
        {
            List<BackpackInfo.SavedItem> SavedList = null;
            if (Backpacks.ContainsKey(ID))
                SavedList = Backpacks[ID].Items;

            return SavedList;
        }
        static List<BackpackInfo.SavedItem> SaveItems(List<Item> items) => items.Select(SaveItem).ToList();
        static BackpackInfo.SavedItem SaveItem(Item item)
        {
            BackpackInfo.SavedItem iItem = new BackpackInfo.SavedItem
            {
                TargetSlot = item.position,
                Shortname = item.info?.shortname,
                Amount = item.amount,
                Mods = new List<BackpackInfo.SavedItem>(),
                Skinid = item.skin,
                BusyTime = item.busyTime,

            };
            if (item.HasFlag(global::Item.Flag.OnFire))
            {
                iItem.OnFire = true;
            }
            if (item.info == null) return iItem;
            iItem.Itemid = item.info.itemid;
            iItem.Weapon = false;

            if (item.contents != null && item.info.category.ToString() != "Weapon")
            {
                foreach (var itemCont in item.contents.itemList)
                {
                    Debug.Log(itemCont.info.shortname);

                    if (itemCont.info.itemid != 0)
                        iItem.Mods.Add(SaveItem(itemCont));
                }
            }

            iItem.Name = item.name;
            if (item.hasCondition)
            {
                iItem.Condition = item.condition;
                iItem.Maxcondition = item.maxCondition;
            }

            if (item.blueprintTarget != 0) iItem.Blueprint = item.blueprintTarget;

            FlameThrower flameThrower = item.GetHeldEntity()?.GetComponent<FlameThrower>();
            if (flameThrower != null)
                iItem.Flamefuel = flameThrower.ammo;
            if (item.info.category.ToString() != "Weapon") return iItem;
            BaseProjectile weapon = item.GetHeldEntity() as BaseProjectile;
            if (weapon == null) return iItem;
            if (weapon.primaryMagazine == null) return iItem;
            iItem.Ammoamount = weapon.primaryMagazine.contents;
            iItem.Ammotype = weapon.primaryMagazine.ammoType.shortname;
            iItem.Weapon = true;

            if (item.contents != null)
                foreach (var mod in item.contents.itemList)
                    if (mod.info.itemid != 0)
                        iItem.Mods.Add(SaveItem(mod));
            return iItem;
        }
        static Item BuildItem(BackpackInfo.SavedItem sItem)
        {
            if (sItem.Amount < 1) sItem.Amount = 799 > 0 ? 1 : 0;
            Item item = null;
            item = ItemManager.CreateByItemID(sItem.Itemid, sItem.Amount, sItem.Skinid);
            item.position = sItem.TargetSlot;

            if (item.hasCondition)
            {
                item.condition = sItem.Condition;
                item.maxCondition = sItem.Maxcondition;
                item.busyTime = sItem.BusyTime;
            }

            if (sItem.Blueprint != 0)
                item.blueprintTarget = sItem.Blueprint;

            if (sItem.Mods != null)
            {
                if (sItem.Mods != null)
                    foreach (var mod in sItem.Mods)
                        item.contents.AddItem(BuildItem(mod).info, mod.Amount);
            }

            if (sItem.Name != null)
                item.name = sItem.Name;

            if (sItem.OnFire)
                item.SetFlag(global::Item.Flag.OnFire, true);

            FlameThrower flameThrower = item.GetHeldEntity()?.GetComponent<FlameThrower>();
            if (flameThrower)
                flameThrower.ammo = sItem.Flamefuel;
            return item;
        }
        static Item BuildWeapon(BackpackInfo.SavedItem sItem)
        {
            Item item = null;
            item = ItemManager.CreateByItemID(sItem.Itemid, 1, sItem.Skinid);
            item.position = sItem.TargetSlot;

            if (item.hasCondition)
            {
                item.condition = sItem.Condition;
                item.maxCondition = sItem.Maxcondition;
            }

            if (sItem.Blueprint != 0)
                item.blueprintTarget = sItem.Blueprint;

            var weapon = item.GetHeldEntity() as BaseProjectile;
            if (weapon != null)
            {
                var def = ItemManager.FindItemDefinition(sItem.Ammotype);
                weapon.primaryMagazine.ammoType = def;
                weapon.primaryMagazine.contents = sItem.Ammoamount;
            }

            if (sItem.Mods != null)
                foreach (var mod in sItem.Mods)
                    item.contents.AddItem(BuildItem(mod).info, 1);
            return item;
        }
        static List<Item> RestoreItems(List<BackpackInfo.SavedItem> sItems)
        {
            return sItems.Select(sItem =>
            {
                if (sItem.Weapon) return BuildWeapon(sItem);
                return BuildItem(sItem);
            }).Where(i => i != null).ToList();
        }
        #endregion

        #region Drop Backpack
        private void DropBackpack(BasePlayer player, TypeDropBackpack typeDropBackpack)
        {
            if (!PlayerBackpack.ContainsKey(player)) return;
            if (PlayerBackpack[player] != null)
                PlayerBackpack[player].Close();
            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_Backpack_Visual);
            BackpackRemoveSpine(player);
            UInt64 ID = GetBackpackID(player);
            Item Backpack = GetBackpack(player);
            List<BackpackInfo.SavedItem> SavedList = GetSavedList(ID);
            if (SavedList == null || SavedList.Count == 0) return;
            switch (typeDropBackpack)
            {
                case TypeDropBackpack.DropItems:
                    {
                        foreach(BackpackInfo.SavedItem sItem in SavedList)
                        {
                            Item BuildedItem = BuildItem(sItem);
                            BuildedItem.DropAndTossUpwards(player.transform.position, Oxide.Core.Random.Range(2, 6));
                        }
                        break;
                    }
                case TypeDropBackpack.DropBackpack:
                    {
                        String Prefab = "assets/prefabs/misc/item drop/item_drop_backpack.prefab";
                        DroppedItemContainer BackpackDrop = (BaseEntity)GameManager.server.CreateEntity(Prefab, player.transform.position + new Vector3(Oxide.Core.Random.Range(-1f, 1f),0f,0f)) as DroppedItemContainer;
                        BackpackDrop.gameObject.AddComponent<NoRagdollCollision>();

                        BackpackDrop.lootPanelName = "generic_resizable";
                        BackpackDrop.playerName = $"{player.displayName ?? "Somebody"}'s Backpack";
                        BackpackDrop.playerSteamID = player.userID;

                        BackpackDrop.inventory = new ItemContainer();
                        BackpackDrop.inventory.ServerInitialize(null, GetSlotsBackpack(player));
                        BackpackDrop.inventory.GiveUID();
                        BackpackDrop.inventory.entityOwner = BackpackDrop;
                        BackpackDrop.inventory.SetFlag(ItemContainer.Flag.NoItemInput, true);

                        foreach (BackpackInfo.SavedItem sItem in SavedList)
                        {
                            Item BuildedItem = BuildItem(sItem);
                            BuildedItem.MoveToContainer(BackpackDrop.inventory, sItem.TargetSlot); 
                        }

                        BackpackDrop.SendNetworkUpdate();
                        BackpackDrop.Spawn();
                        BackpackDrop.ResetRemovalTime(Math.Max(config.TurnedsSetting.RemoveBackpack, BackpackDrop.CalculateRemovalTime()));
                        break;
                    }
                default:
                    break;
            }
            SavedList.Clear();
            if (Backpack != null)
                Backpack.Remove();
            if (config.TurnedsSetting.Types == TypeBackpack.Wear)
                Backpacks.Remove(ID);
        }
        private class NoRagdollCollision : FacepunchBehaviour
        {
            private Collider _collider;

            private void Awake()
            {
                _collider = GetComponent<Collider>();
            }

            private void OnCollisionEnter(Collision collision)
            {
                if (collision.collider.IsOnLayer(Rust.Layer.Ragdoll))
                {
                    UnityEngine.Physics.IgnoreCollision(_collider, collision.collider);
                }
            }
        }
        #endregion

        #region Craft Backpack

        private void CraftingBackpack(BasePlayer player)
        {
            Configuration.Backpack.BackpackCraft BCraft = GetBackpackOption(player);
            if (BCraft == null || BCraft.CraftItems == null) return;

            if (!HaveAllItem(player, BCraft.CraftItems))
            {
                SendChat(GetLang("CRAFTING_BACKPACK_NO_ITEMS", player.UserIDString), player);
                return;
            }

            TakeItems(player, BCraft.CraftItems);

            Item backpack = ItemManager.CreateByName(config.BackpackItem.Shortname, 1, config.BackpackItem.SkinID);
            Int32 Slot = GetAvailableSlots(player);

            backpack.name = GetLang("BACKPACK_TITLE", player.UserIDString, Slot);

            Backpacks.Add(backpack.uid, new BackpackInfo()
            {
                AmountSlot = Slot,
            });

            player.GiveItem(backpack);
        }

        #endregion

        #region Other
        private UInt64 GetBackpackID(BasePlayer player)
        {
            UInt64 ID = 0;
            if (config.TurnedsSetting.Types == TypeBackpack.Wear)
            {
                Item Backpack = GetBackpack(player);
                if (Backpack == null) return ID;
                ID = Backpack.uid;
            }
            else ID = player.userID;

            return ID;
        }
        private Item GetBackpack(BasePlayer player)
        {
            Item item = player.inventory.containerWear.itemList.Find(x => x.skin == config.BackpackItem.SkinID);
            return item;
        }
        private Configuration.Backpack.BackpackCraft GetBackpackOption(BasePlayer player)
        {
            Configuration.Backpack.BackpackCraft BCraft = config.BackpackItem.BackpacOption.FirstOrDefault(x => permission.UserHasPermission(player.UserIDString, x.Permissions));
            return BCraft;
        }
        private List<Item> GetItemBlacklist(BasePlayer player)
        {
            Configuration.Backpack.BackpackCraft Backpack = GetBackpackOption(player);
            if (Backpack == null || Backpack.BlackListItems == null || Backpack.BlackListItems.Count == 0) return null;
            List<Item> ItemList = new List<Item>();

            foreach(Item item in player.inventory.AllItems())
                foreach(String Shortname in Backpack.BlackListItems)
                    if (item.info.shortname == Shortname)
                        ItemList.Add(item);

            return ItemList;
        }
        private Int32 GetAvailableSlots(BasePlayer player)
        {
            Int32 AvailableSlots = 0;

            Configuration.Backpack.BackpackCraft BCraft = GetBackpackOption(player);
            if (BCraft == null) return AvailableSlots;
            AvailableSlots = BCraft.AmountSlot;

            return AvailableSlots;
        }
        private Int32 GetMaximumUpgradeSlots(BasePlayer player)
        {
            Configuration.Backpack.BackpackCraft BackpackOption = GetBackpackOption(player);
            if (BackpackOption == null) return 0;
            Int32 Slots = BackpackOption.AmountSlot;

            foreach (Configuration.Backpack.BackpackCraft.UpgradeBackpack Upgrades in BackpackOption.UpgradeList)
                Slots += Upgrades.SlotUpgrade;

            return Slots;
        }
        private Int32 GetSlotsBackpack(BasePlayer player)
        {
            Int32 SlotsBackpack = 0;
            if (config.TurnedsSetting.Types == TypeBackpack.Wear)
            {
                Item item = GetBackpack(player);

                if (item != null)
                    if (Backpacks.ContainsKey(item.uid))
                        SlotsBackpack = Backpacks[item.uid].AmountSlot;
            }
            else
            {
                if (Backpacks.ContainsKey(player.userID))
                    SlotsBackpack = Backpacks[player.userID].AmountSlot;
            }

            return SlotsBackpack;
        }
        private Int32 GetBusySlotsBackpack(BasePlayer player)
        {
            if (config.TurnedsSetting.Types == TypeBackpack.Wear)
            {
                Item item = GetBackpack(player);

                if (item != null)
                    if (Backpacks.ContainsKey(item.uid))
                    {
                        PrintError(item.uid.ToString() + " " +Backpacks[item.uid].Items.Count.ToString());
                        return Backpacks[item.uid].Items.Count;
                    }
            }
            else
            {
                if (Backpacks.ContainsKey(player.userID))
                    return Backpacks[player.userID].Items.Count;
            }

            return 0;
        }
        private void RegisteredPermissions()
        {
            foreach (Configuration.Backpack.BackpackCraft BPCraft in config.BackpackItem.BackpacOption)
                permission.RegisterPermission(BPCraft.Permissions, this);
        }
        private Boolean HaveAllItem(BasePlayer player, List<Configuration.Backpack.BackpackCraft.ItemCraft> BPCraft, ItemContainer contaner = null)
        {
            Int32 TrueItem = 0;
            for (Int32 i = 0; i < BPCraft.Count; i++)
            {
                Configuration.Backpack.BackpackCraft.ItemCraft Item = BPCraft[i];
                if (HaveItem(player, Item.Shortname, Item.Amount, Item.SkinID, contaner))
                    TrueItem++;
            }

            return TrueItem >= BPCraft.Count;
        }

        private Boolean HaveItem(BasePlayer player, String Shortname, Int32 Amount, UInt64 SkinID = 0, ItemContainer contaner = null)
        {
            Int32 ItemAmount = 0;
            foreach (Item ItemRequires in contaner == null ? player.inventory.AllItems().ToList() : contaner.itemList)
            {
                if (ItemRequires == null) continue;
                if (ItemRequires.info.shortname != Shortname) continue;
                if (ItemRequires.skin != SkinID) continue;
                ItemAmount += ItemRequires.amount;
            }
            return ItemAmount >= Amount;
        }
        private void TakeItems(BasePlayer player, List<Configuration.Backpack.BackpackCraft.ItemCraft> BPCraft, ItemContainer contaner = null)
        {
            Int32 Index = 0;
            List<Int32> ItemList = new List<Int32>();
            List<Item> ContainerItems = contaner == null ? player.inventory.AllItems().ToList() : contaner.itemList;

            foreach (Configuration.Backpack.BackpackCraft.ItemCraft ItemTake in BPCraft)
            {
                ItemList.Add(ItemTake.Amount);
                foreach (Item ItemPlayer in ContainerItems.Where(x => x.skin == ItemTake.SkinID && x.info.shortname == ItemTake.Shortname))
                {
                    if (ItemList[Index] <= 0) continue;
                    ItemList[Index] -= ItemPlayer.amount;
                    ItemPlayer.UseItem(ItemList[Index] > 0 ? ItemList[Index] : ItemTake.Amount);
                }
                Index++;
            }
        }
        #endregion

        #endregion

        #region Commands

        #region Open BP
        [ConsoleCommand("bp")]
        void OpenBackpackConsole(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            OpenBP(player);
        }

        [ChatCommand("bp")]
        void OpenBackpackChat(BasePlayer player)
        {
            if (player == null) return;
            OpenBP(player);
        }

        #endregion

        #region Upgrade BP
        [ConsoleCommand("backpack.upgrade")]
        void BackpackUpgradeCommand(ConsoleSystem.Arg arg)
        {
            if (!config.TurnedsSetting.UseUpgradeBackpack) return;
            BasePlayer player = arg.Player();
            if (player == null) return;

            UpgradeBackpack(player);
        }

        [ConsoleCommand("backpack.upgrade.menu")]
        void BackpackUpgrade(ConsoleSystem.Arg arg)
        {
            if (!config.TurnedsSetting.UseUpgradeBackpack) return;
            BasePlayer player = arg.Player();
            if (player == null) return;
            OpenUpgradeMenu(player);
        }
        [ChatCommand("upgradebp")]
        void UpgradeBPCommand(BasePlayer player)
        {
            if (IsDuel(player.userID)) return;
            if (player == null) return;
            OpenUpgradeMenu(player);
        }

        #endregion

        #region Crafting BP

        [ConsoleCommand("backpack.crafting")]
        void BackpackCrafting(ConsoleSystem.Arg arg)
        {
            if (!config.TurnedsSetting.UseCrafting || config.TurnedsSetting.Types == TypeBackpack.OnlyPermission) return;
            BasePlayer player = arg.Player();
            if (player == null) return;

            CraftingBackpack(player);
        }

        [ChatCommand("backpack")]
        void BackpackCraftMenu(BasePlayer player)
        {
            if (IsDuel(player.userID)) return;
            if (!config.TurnedsSetting.UseCrafting || config.TurnedsSetting.Types == TypeBackpack.OnlyPermission) return;
            if (_interface == null)
            {
                SendChat(GetLang("BACKPACK_NO_INITIALIZE", player.UserIDString), player);
                return;
            }
            DrawUI_Backpack_Main(player);
        }
        #endregion

        #endregion

        #region Interface
        private void DrawUI_Backpack_Main(BasePlayer player)
        {
            if (!config.TurnedsSetting.UseCrafting || config.TurnedsSetting.Types == TypeBackpack.OnlyPermission) return;
            String Interface = InterfaceBuilder.GetInterface("UI_Backpack_Main");
            if (Interface == null) return;

            Interface = Interface.Replace("%CRAFT_BTN%", GetLang("CRAFT_BTN", player.UserIDString));
            Interface = Interface.Replace("%SLOT_AVALIBLE_TITLE%", GetLang("SLOT_AVALIBLE_TITLE", player.UserIDString));
            Interface = Interface.Replace("%TITLE_PLUGIN_CRAFT_MENU%", GetLang("TITLE_PLUGIN_CRAFT_MENU", player.UserIDString));
            Interface = Interface.Replace("%TITLE_STORE_INFORMATION%", GetLang("TITLE_STORE_INFORMATION", player.UserIDString));
            Interface = Interface.Replace("%TITLE_HAVE_ITEMS%", GetLang("TITLE_HAVE_ITEMS", player.UserIDString));
            Interface = Interface.Replace("%TITLE_HAVE_ITEMS_DESCRIPTION%", GetLang("TITLE_HAVE_ITEMS_DESCRIPTION", player.UserIDString));

            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_Backpack);
            CuiHelper.AddUi(player, Interface);

            DrawUI_Backpack_Slots(player);
            DrawUI_Backpack_ItemCrafts(player);
        }    
       
        #region DrawUI Slots
        private void DrawUI_Backpack_Slots(BasePlayer player)
        {
            if (_interface == null) return;
            if (!config.TurnedsSetting.UseCrafting || config.TurnedsSetting.Types == TypeBackpack.OnlyPermission) return;

            Int32 SlotY = 0;
            Int32 SlotX = 0;
            Int32 SlotAmount = config.TurnedsSetting.UseUpgradeBackpack ? 42 : GetAvailableSlots(player);
            for (Int32 Slot = 0; Slot < SlotAmount; Slot++)
            {
                String Interface = InterfaceBuilder.GetInterface("UI_Backpack_Slots");
                if (Interface == null) return;
                // %OFFSET_MIN% =  
                // %OFFSET_MAX% = 
                Interface = Interface.Replace("%INDEX%", $"{Slot}");
                Interface = Interface.Replace("%OFFSET_MIN%", $"{-211 + (SlotX * 72)} {144.6 - (SlotY * 72)}");
                Interface = Interface.Replace("%OFFSET_MAX%", $"{-147 + (SlotX * 72)} {208.6 - (SlotY * 72)}");
                //container.Add(new CuiPanel
                //{
                //    CursorEnabled = false,
                //    Image = { Color = "0.91 0.87 0.83 0.1"/*"0.79 0.77 0.62 0.1"*/, Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                //    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"{-211 + (SlotX * 72)} {144.6 - (SlotY * 72)}", OffsetMax = $"{-147 + (SlotX * 72)} {208.6 - (SlotY * 72)}" }
                //}, "SlotPanels", $"Slot_{Slot}");
                
                SlotX++;
                if (SlotX == 6)
                {
                    SlotX = 0;
                    SlotY++;
                }
                CuiHelper.AddUi(player, Interface);
            }



            if (config.TurnedsSetting.UseUpgradeBackpack)
                DrawUI_Backpack_Slots_Locked(player);
        }

        private void DrawUI_Backpack_Slots_Locked(BasePlayer player)
        {
            if (_interface == null) return;
            if (!config.TurnedsSetting.UseCrafting || config.TurnedsSetting.Types == TypeBackpack.OnlyPermission) return;
            Int32 AvailableSlots = GetAvailableSlots(player);
            Int32 LockedSlots = 42 - AvailableSlots;

            for (Int32 LockSlots = LockedSlots; LockSlots > 0; LockSlots--)
            {
                String Interface = InterfaceBuilder.GetInterface("UI_Backpack_Slots_Lock");
                if (Interface == null) return;

                Interface = Interface.Replace("%INDEX%", $"{42 - LockSlots}");
                CuiHelper.AddUi(player, Interface);
            }
        }
        #endregion

        #region DrawUI CraftItem
        private void DrawUI_Backpack_ItemCrafts(BasePlayer player)
        {
            if (_interface == null) return;
            if (!config.TurnedsSetting.UseCrafting || config.TurnedsSetting.Types == TypeBackpack.OnlyPermission) return;
            Configuration.Backpack.BackpackCraft BCraft = GetBackpackOption(player);
            if (BCraft == null || BCraft.CraftItems == null) return;

            #region Centering
            Int32 ItemCount = 0;
            Single itemMinPosition = 219f;
            Single itemWidth = 0.15f; /// Ширина
            Single itemMargin = 0.062f; /// Расстояние между 
            Int32 itemCount = BCraft.CraftItems.Count;
            Single itemMinHeight = 0.84f; // Сдвиг по вертикали
            Single itemHeight = 0.16f; /// Высота
            Int32 ItemTarget = 5;

            if (itemCount > ItemTarget)
            {
                itemMinPosition = 0.5f - ItemTarget / 2f * itemWidth - (ItemTarget - 1) / 2f * itemMargin;
                itemCount -= ItemTarget;
            }
            else itemMinPosition = 0.5f - itemCount / 2f * itemWidth - (itemCount - 1) / 2f * itemMargin;

            #endregion

            foreach (Configuration.Backpack.BackpackCraft.ItemCraft item in BCraft.CraftItems)
            {
                String Interface = InterfaceBuilder.GetInterface("UI_Backpack_Craft_Item");
                if (Interface == null) return;

                Interface = Interface.Replace("%ANCHOR_MIN%", $"{itemMinPosition} {itemMinHeight}");
                Interface = Interface.Replace("%ANCHOR_MAX%", $"{itemMinPosition + itemWidth} {itemMinHeight + itemHeight}");
                Interface = Interface.Replace("%AMOUNT%", $"{item.Amount}");
                Interface = Interface.Replace("%PNG_ITEM%", GetImage(item));
                Interface = Interface.Replace("%COLOR_PANEL%", HaveItem(player, item.Shortname, item.Amount, item.SkinID) ? "0.57 1.00 0.65 1.00" : "0.98 0.13 0.18 1.00");

                CuiHelper.AddUi(player, Interface);

                #region Centering
                ItemCount++;
                itemMinPosition += (itemWidth + itemMargin);
                if (ItemCount % ItemTarget == 0)
                {
                    itemMinHeight -= (itemHeight + (itemMargin * 0.5f));
                    if (itemCount > ItemTarget)
                    {
                        itemMinPosition = 0.5f - ItemTarget / 2f * itemWidth - (ItemTarget - 1) / 2f * itemMargin;
                        itemCount -= ItemTarget;
                    }
                    else itemMinPosition = 0.5f - itemCount / 2f * itemWidth - (itemCount - 1) / 2f * itemMargin;
                }
                #endregion
            }
        }
        #endregion

        #region DrawUI Backpack Visual
        private Int32 GetSlotsPercent(Single Percent, Single Slots)
        {
            Single ReturnSlot = (((Single)Slots / 100.0f) * Percent);
            return (Int32)ReturnSlot;
        }
        private void DrawUI_Backpack_Visual(BasePlayer player)
        {
            if (!config.TurnedsSetting.VisualBackpackSlots.UseVisual || _interface == null) return;
            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_Backpack_Visual);

            String Interface = InterfaceBuilder.GetInterface("UI_Backpack_Visual_Backpack_Slot");
            if (Interface == null) return;
           
            Single BusySlots = (Single)GetBusySlotsBackpack(player);
            Single Slots = (Single)GetSlotsBackpack(player);
            if (Slots == 0) return;
            Single Y_Progress = (Single)((Single)BusySlots / (Single)Slots);

            String Y_Progress_Color = BusySlots >= GetSlotsPercent(80.0f, Slots) ? config.TurnedsSetting.VisualBackpackSlots.ColorProgressBar.ColorMaximum :
                                      BusySlots >= GetSlotsPercent(60.0f, Slots) ? config.TurnedsSetting.VisualBackpackSlots.ColorProgressBar.ColorAverage :
                                                                                   config.TurnedsSetting.VisualBackpackSlots.ColorProgressBar.ColorMinimal;

            Interface = Interface.Replace("%CRAFT_BTN%", GetLang("CRAFT_BTN", player.UserIDString));
            Interface = Interface.Replace("%SLOTS_INFO%", $"<b>{BusySlots}/{Slots}</b>");
            Interface = Interface.Replace("%Y_PROGRESS%", $"{Y_Progress}");
            Interface = Interface.Replace("%Y_PROGRESS_COLOR%", $"{Y_Progress_Color}");

            CuiHelper.AddUi(player, Interface);
        }
        #endregion

        #region DrawUI Backpak Upgrade
        private void DrawUI_Backpack_Upgrade_Info(BasePlayer player)
        {
            if (!config.TurnedsSetting.UseUpgradeBackpack || _interface == null) return;

            if (!PlayerUpgrades.ContainsKey(player)) return;
             String Interface = InterfaceBuilder.GetInterface("UI_Backpack_Upgrade_Info");
            if (Interface == null) return;

            Interface = Interface.Replace("%BACKPACK_UPGRADE_DESCRIPTION%", GetLang("BACKPACK_UPGRADE_DESCRIPTION", player.UserIDString));
            Interface = Interface.Replace("%BACKPACK_UPGRADE_TITLE%", GetLang("BACKPACK_UPGRADE_TITLE", player.UserIDString));

            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_Backpack_Upgrade_Workbench);
            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_Backpack_Upgrade_Info);
            CuiHelper.AddUi(player, Interface);
            DrawUI_Backpack_Upgrade_Info_Controller(player);
        }

        private void DrawUI_Backpack_Upgrade_Info_Controller(BasePlayer player)
        {
            if (!config.TurnedsSetting.UseUpgradeBackpack || _interface == null) return;

            if (!PlayerUpgrades.ContainsKey(player)) return;
            if (PlayerUpgrades[player] == null) return;
            String Interface = InterfaceBuilder.GetInterface("UI_Backpack_Upgrade_Info_Controller");
            if (Interface == null) return;

            Boolean IsUpgrade = HaveAllItem(player, PlayerUpgrades[player].ItemList, PlayerUpgrades[player].Container.customerInventory);
            Interface = Interface.Replace("%BACKPACK_UPGRADE_WORKBENCH_INFORMATION_SLOTS%", GetLang("BACKPACK_UPGRADE_WORKBENCH_INFORMATION_SLOTS", player.UserIDString, PlayerUpgrades[player].UpgradeSlotsUp));
            Interface = Interface.Replace("%BACKPACK_UPGRADE_WORKBENCH_INFORMATION_BUTTON_TILE%", GetLang((IsUpgrade ? "BACKPACK_UPGRADE_WORKBENCH_INFORMATION_BUTTON_TILE" : "BACKPACK_UPGRADE_WORKBENCH_INFORMATION_BUTTON_TILE_FALSE_RESOURCE"), player.UserIDString));
            Interface = Interface.Replace("%BUTTON_COLOR%", (IsUpgrade ? "0.4431373 0.5450981 0.2627451 1" : "0.7568628 0.2273419 0.2078431 1"));


            CuiHelper.DestroyUi(player, "BackpackStatusUpgrade");
            CuiHelper.AddUi(player, Interface);
        }
        #endregion

        #region DrawUI Backpak Upgrade Workbench
        private void DrawUI_Backpack_Upgrade_Workbench(BasePlayer player)
        {
            if (!config.TurnedsSetting.UseUpgradeBackpack || _interface == null) return;

            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_Backpack_Upgrade_Workbench);
            String Interface = InterfaceBuilder.GetInterface("UI_Backpack_Upgrade_Workbench");
            if (Interface == null) return;
            Configuration.Backpack.BackpackCraft BackpackOption = GetBackpackOption(player);
            if (BackpackOption == null) return;

            UInt64 ID = GetBackpackID(player);
            if (!Backpacks.ContainsKey(ID)) return;

            Boolean IsUpgrade = (BackpackOption.UpgradeList.Count - 1) < (Backpacks[ID].IndexUpgrade + 1); 
            Interface = Interface.Replace("%BACKPACK_UPGRADE_WORKBENCH_BUTTON%", GetLang(IsUpgrade ? "BACKPACK_UPGRADE_WORKBENCH_BUTTON_MAXIMUM" : "BACKPACK_UPGRADE_WORKBENCH_BUTTON", player.UserIDString));
            Interface = Interface.Replace("%COLOR%", IsUpgrade ? "0.7568628 0.2273419 0.2078431 1" : "0.4431373 0.5450981 0.2627451 1");
            Interface = Interface.Replace("%COMMAND%", IsUpgrade ? "" : "backpack.upgrade.menu");
            Interface = Interface.Replace("%BACKPACK_UPGRADE_WORKBENCH_DESCRIPTION%", GetLang("BACKPACK_UPGRADE_WORKBENCH_DESCRIPTION", player.UserIDString, GetMaximumUpgradeSlots(player) >= 42 ? 42 : GetMaximumUpgradeSlots(player)));
            Interface = Interface.Replace("%BACKPACK_UPGRADE_WORKBENCH_TITLE%", GetLang("BACKPACK_UPGRADE_WORKBENCH_TITLE", player.UserIDString));

            CuiHelper.AddUi(player, Interface);
        }
        #endregion

        private static InterfaceBuilder _interface;
        private class InterfaceBuilder
        {
            #region Vars

            public static InterfaceBuilder Instance;
            public const String UI_Backpack = "UI_BACKPACK";
            public const String UI_Backpack_Visual = "UI_BACKPACK_VISUAL";
            public const String UI_Backpack_Upgrade_Info = "UI_BACKPACK_UPGRATE_INFO";
            public const String UI_Backpack_Upgrade_Workbench = "UI_BACKPACK_UPGRATE_WORKBENCH";
            public Dictionary<String, String> Interfaces;

            #endregion

            #region Main

            public InterfaceBuilder()
            {
                Instance = this;
                Interfaces = new Dictionary<String, String>();
                BuildingBackpack_Main();
                BuildingBackpack_Slots();
                BuildingBackpack_Slots_Lock();
                BuildingBackpack_Craft();
                BuildingBackpack_UpgradeBackpack_Workbench();
                BuildingBackpack_UpgradeBackpack_Info();
                BuildingBackpack_UpgradeBackpack_Info_Controller();

                if (config.TurnedsSetting.VisualBackpackSlots.UseVisual)
                    BuildingBackpack_Visual_Backpack_Slot();
            }

            public static void AddInterface(String name, String json)
            {
                if (Instance.Interfaces.ContainsKey(name))
                {
                    _.PrintError($"Error! Tried to add existing cui elements! -> {name}");
                    return;
                }

                Instance.Interfaces.Add(name, json);
            }

            public static string GetInterface(String name)
            {
                string json = string.Empty;
                if (Instance.Interfaces.TryGetValue(name, out json) == false)
                {
                    _.PrintWarning($"Warning! UI elements not found by name! -> {name}");
                }

                return json;
            }

            public static void DestroyAll()
            {
                for (var i = 0; i < BasePlayer.activePlayerList.Count; i++)
                {
                    var player = BasePlayer.activePlayerList[i];
                    
                    CuiHelper.DestroyUi(player, UI_Backpack);
                    CuiHelper.DestroyUi(player, UI_Backpack_Visual);
                    CuiHelper.DestroyUi(player, UI_Backpack_Upgrade_Info);
                    CuiHelper.DestroyUi(player, UI_Backpack_Upgrade_Workbench);
                }
            }

            #endregion

            #region Building Interface
            private void BuildingBackpack_Main()
            {
                if (!config.TurnedsSetting.UseCrafting || config.TurnedsSetting.Types == TypeBackpack.OnlyPermission) return;
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    Image = { Color = "0 0 0 0.8", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" }
                }, "Overlay", UI_Backpack);

                container.Add(new CuiElement
                {
                    Name = "BackpackImage",
                    Parent = UI_Backpack,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = _.GetImage(config.BackpackItem.UrlBackpack) },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-605 -104", OffsetMax = "-349 152" }
                }
                });

                container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = "backpack.crafting" },
                    Text = { Text = "%CRAFT_BTN%", Font = "robotocondensed-regular.ttf", FontSize = 40, Align = TextAnchor.MiddleCenter, Color = "0.91 0.87 0.83 1" },
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-605 -160.464", OffsetMax = "-349 -103.995" }
                }, UI_Backpack, "TitleCraft");

                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = "0 0 0 0" },
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "205.779 -360", OffsetMax = "628.221 360" }
                }, UI_Backpack, "SlotPanels");

                container.Add(new CuiElement
                {
                    Name = "TitleSlot",
                    Parent = "SlotPanels",
                    Components = {
                    new CuiTextComponent { Text = "%SLOT_AVALIBLE_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 18, Align = TextAnchor.LowerLeft, Color = "0.91 0.87 0.83 1"},
                 	new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-211.221 210.295", OffsetMax = "211.219 242.64"  }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "TitleCraftMenu",
                    Parent = UI_Backpack,
                    Components = {
                    new CuiTextComponent { Text = "%TITLE_PLUGIN_CRAFT_MENU%", Font = "robotocondensed-regular.ttf", FontSize = 40, Align = TextAnchor.MiddleLeft, Color = "0.91 0.87 0.83 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-632.1 294.025", OffsetMax = "-213.633 354.497" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "InformationStore",
                    Parent = UI_Backpack,
                    Components = {
                    new CuiTextComponent { Text = "%TITLE_STORE_INFORMATION%", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.UpperLeft, Color = "0.91 0.87 0.83 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-629 270.595", OffsetMax = "0 302.805" }
                }
                });

                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = "0 0 0 0"},
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-328.658 -282.7", OffsetMax = "184.658 208.6" }
                }, UI_Backpack, "CraftPanel");

                container.Add(new CuiElement
                {
                    Name = "AHaveItemBackpack",
                    Parent = "CraftPanel",
                    Components = {
                    new CuiTextComponent { Text = "%TITLE_HAVE_ITEMS%", Font = "robotocondensed-regular.ttf", FontSize = 18, Align = TextAnchor.LowerLeft, Color = "0.91 0.87 0.83 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-256.658 -144.925", OffsetMax = "256.662 -118.475" }
                }
                });

                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = "0.91 0.87 0.83 0.15", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-256.66 -250.39", OffsetMax = "256.66 -150.39" }
                }, "CraftPanel", "TitleBlur");

                container.Add(new CuiElement
                {
                    Name = "InstructionLabel",
                    Parent = "TitleBlur",
                    Components = {
                    new CuiTextComponent { Text = "%TITLE_HAVE_ITEMS_DESCRIPTION%", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleLeft, Color = "0.91 0.87 0.83 1"  },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-244.095 -37.435", OffsetMax = "244.095 37.435" }
                }
                });

                container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Close = UI_Backpack },
                    Text = { Text = "✖", Font = "robotocondensed-regular.ttf", FontSize = 40, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-57 -57", OffsetMax = "0 0" }
                },  UI_Backpack, "CloseBackpack");

                AddInterface("UI_Backpack_Main", container.ToJson());
            }
            #endregion

            #region Building Slots

            private void BuildingBackpack_Slots()
            {
                if (!config.TurnedsSetting.UseCrafting || config.TurnedsSetting.Types == TypeBackpack.OnlyPermission) return;
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = "0.91 0.87 0.83 0.1"/*"0.79 0.77 0.62 0.1"*/, Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "%OFFSET_MIN%", OffsetMax = "%OFFSET_MAX%" }
                }, "SlotPanels", $"Slot_%INDEX%");

                //Int32 SlotY = 0;
                //Int32 SlotX = 0;
                //for (Int32 Slot = 0; Slot < 42; Slot++)
                //{
                //    container.Add(new CuiPanel 
                //    {
                //        CursorEnabled = false,
                //        Image = { Color = "0.91 0.87 0.83 0.1"/*"0.79 0.77 0.62 0.1"*/, Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                //        RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"{-211 + (SlotX * 72)} {144.6 - (SlotY * 72)}", OffsetMax = $"{-147 + (SlotX * 72)} {208.6 - (SlotY * 72)}" }
                //    }, "SlotPanels", $"Slot_{Slot}");

                //    SlotX++;
                //    if(SlotX == 6)
                //    {
                //        SlotX = 0;
                //        SlotY++;
                //    }
                //}

                AddInterface("UI_Backpack_Slots", container.ToJson());
            }    
            private void BuildingBackpack_Slots_Lock()
            {
                if (!config.TurnedsSetting.UseCrafting || config.TurnedsSetting.Types == TypeBackpack.OnlyPermission) return;
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = "1 1 1 0.8", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat", Sprite = "assets/icons/lock.png" },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" }
                }, $"Slot_%INDEX%");

                AddInterface("UI_Backpack_Slots_Lock", container.ToJson());
            }

            #endregion

            #region Building Crafts
            private void BuildingBackpack_Craft()
            {
                if (!config.TurnedsSetting.UseCrafting || config.TurnedsSetting.Types == TypeBackpack.OnlyPermission) return;
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = "0 0 0 0"/*"0.3679245 0.3679245 0.3679245 1" */},
                    RectTransform = { AnchorMin = "%ANCHOR_MIN%", AnchorMax = "%ANCHOR_MAX%" }
                }, "CraftPanel", "ItemCraft");

                container.Add(new CuiElement
                {
                    Name = "ImageIcon",
                    Parent = "ItemCraft",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = "%PNG_ITEM%" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-40 -37.51", OffsetMax = "40 40" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "InfoCount",
                    Parent = "ItemCraft",
                    Components = {
                    new CuiTextComponent { Text = $"X%AMOUNT%", Font = "robotocondensed-regular.ttf", FontSize = 18, Align = TextAnchor.LowerRight, Color = "0.91 0.87 0.83 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-37.859 -37.51", OffsetMax = "37.383 -13.787" }
                }
                });

                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = "%COLOR_PANEL%" },
                    RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-40 0", OffsetMax = "40 2.49" }
                }, "ItemCraft", "StatusPanel");

                AddInterface("UI_Backpack_Craft_Item", container.ToJson());
            }
            #endregion

            #region Building BackpackSlot Visual
            private void BuildingBackpack_Visual_Backpack_Slot()
            {
                CuiElementContainer container = new CuiElementContainer();
                Configuration.Turneds.VisualBackpackSlot.Position Position = config.TurnedsSetting.VisualBackpackSlots.PositionSlotVisual;

                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = "1 1 1 0.15" },
                    RectTransform = { AnchorMin = Position.AnchorMin, AnchorMax = Position.AnchorMax, OffsetMin = Position.OffsetMin, OffsetMax = Position.OffsetMax }
                }, "Overlay", UI_Backpack_Visual);

                container.Add(new CuiElement
                {
                    Name = "BpImage",
                    Parent = UI_Backpack_Visual,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = _.GetImage(config.BackpackItem.UrlBackpack) },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-25 -25", OffsetMax = "25 25" }
                }
                });

                if (config.TurnedsSetting.VisualBackpackSlots.UseSlots)
                {
                    container.Add(new CuiElement
                    {
                        Name = "IsFullSlots",
                        Parent = UI_Backpack_Visual,
                        Components = {
                        new CuiTextComponent { Text = "%SLOTS_INFO%", Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.MiddleRight, Color = "0.91 0.87 0.83 0.5"  },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-26.017 -30.072", OffsetMax = "26.017 -11.002" }
                    }
                    });
                }

                if (config.TurnedsSetting.VisualBackpackSlots.UseSlots)
                {
                    container.Add(new CuiPanel
                    {
                        CursorEnabled = false,
                        Image = { Color = "0 0 0 0.2" },
                        RectTransform = { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "0 -30.072", OffsetMax = "3.736 30.072" }
                    }, UI_Backpack_Visual, "IsFullPanel");

                    container.Add(new CuiPanel
                    {
                        CursorEnabled = false,
                        Image = { Color = "%Y_PROGRESS_COLOR%" },
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 %Y_PROGRESS%", OffsetMin = "0.5 1", OffsetMax = "0 0" }
                    }, "IsFullPanel", "IsFullProgress");
                }

                if (config.TurnedsSetting.VisualBackpackSlots.UseButton)
                {
                    container.Add(new CuiButton
                    {
                        Button = { Color = "0 0 0 0", Command = "bp" },
                        Text = { Text = "", Font = "robotocondensed-regular.ttf", FontSize = 40, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" }
                    }, UI_Backpack_Visual, "OPEN_BACKPACK");
                }

                AddInterface("UI_Backpack_Visual_Backpack_Slot", container.ToJson());
            }
            #endregion

            #region Building Upgrade Backpack
            private void BuildingBackpack_UpgradeBackpack_Info()
            {
                if (!config.TurnedsSetting.UseUpgradeBackpack) return;
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = "1 1 1 0.10581383" },
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "194.836 178.923", OffsetMax = "575.164 252.477" }
                }, "Overlay", UI_Backpack_Upgrade_Info);

                container.Add(new CuiElement
                {
                    Name = "Titles",
                    Parent = UI_Backpack_Upgrade_Info,
                    Components = {
                    new CuiTextComponent { Text = "%BACKPACK_UPGRADE_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 20, Align = TextAnchor.LowerLeft, Color = "0.91 0.87 0.83 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-190.166 41.466", OffsetMax = "190.164 73.334" }
                }
                }); 

                container.Add(new CuiElement
                {
                    Name = "DescriptionInstruction",
                    Parent = UI_Backpack_Upgrade_Info,
                    Components = {
                    new CuiTextComponent { Text = "%BACKPACK_UPGRADE_DESCRIPTION%", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleLeft, Color = "0.91 0.87 0.83 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-180.794 -33.795", OffsetMax = "180.792 33.795" }
                }
                });

                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = "1 1 1 0.10581383" },
                    RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-190.166 -430.851", OffsetMax = "190.154 -360.833" }
                }, UI_Backpack_Upgrade_Info, "BackpackStatusUpgrade");

                container.Add(new CuiButton
                {
                    Button = { Color = "0.4431373 0.5450981 0.2627451 1", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                    Text = { Text = "%BACKPACK_UPGRADE_WORKBENCH_INFORMATION_BUTTON_TILE%", Font = "robotocondensed-regular.ttf", FontSize = 18, Align = TextAnchor.MiddleCenter, Color = "0.91 0.87 0.83 1" },
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-118.576 -10.398", OffsetMax = "118.576 29.798" }
                }, "BackpackStatusUpgrade", "UpgradeButton");

                container.Add(new CuiElement
                {
                    Name = "InformationSlots",
                    Parent = "BackpackStatusUpgrade",
                    Components = {
                    new CuiTextComponent { Text = "%BACKPACK_UPGRADE_WORKBENCH_INFORMATION_SLOTS%", Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.MiddleCenter, Color = "0.91 0.87 0.83 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-190.16 -35.008", OffsetMax = "190.16 -10.398" }
                }
                });

                AddInterface("UI_Backpack_Upgrade_Info", container.ToJson());
            }
            private void BuildingBackpack_UpgradeBackpack_Info_Controller()
            {
                if (!config.TurnedsSetting.UseUpgradeBackpack) return;
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = "1 1 1 0.10581383" },
                    RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-190.166 -430.851", OffsetMax = "190.154 -360.833" }
                }, UI_Backpack_Upgrade_Info, "BackpackStatusUpgrade"); 

                container.Add(new CuiButton
                {
                    Button = { Color = "%BUTTON_COLOR%", Command = "backpack.upgrade", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                    Text = { Text = "%BACKPACK_UPGRADE_WORKBENCH_INFORMATION_BUTTON_TILE%", Font = "robotocondensed-regular.ttf", FontSize = 18, Align = TextAnchor.MiddleCenter, Color = "0.91 0.87 0.83 1" },
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-118.576 -10.398", OffsetMax = "118.576 29.798" }
                }, "BackpackStatusUpgrade", "UpgradeButton");

                container.Add(new CuiElement
                {
                    Name = "InformationSlots",
                    Parent = "BackpackStatusUpgrade",
                    Components = {
                    new CuiTextComponent { Text = "%BACKPACK_UPGRADE_WORKBENCH_INFORMATION_SLOTS%", Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.MiddleCenter, Color = "0.91 0.87 0.83 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-190.16 -35.008", OffsetMax = "190.16 -10.398" }
                }
                });

                AddInterface("UI_Backpack_Upgrade_Info_Controller", container.ToJson());
            }
            #endregion

            #region Building Upgrade Backpack Workbench
            private void BuildingBackpack_UpgradeBackpack_Workbench()
            {
                if (!config.TurnedsSetting.UseUpgradeBackpack) return;
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = "1 1 1 0.025", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                    RectTransform = { AnchorMin = config.TurnedsSetting.VisualBackpackSlots.PositionUpgrade.AnchorMin, AnchorMax = config.TurnedsSetting.VisualBackpackSlots.PositionUpgrade.AnchorMax, OffsetMin = config.TurnedsSetting.VisualBackpackSlots.PositionUpgrade.OffsetMin, OffsetMax = config.TurnedsSetting.VisualBackpackSlots.PositionUpgrade.OffsetMax }
                }, "Overlay", UI_Backpack_Upgrade_Workbench);

                container.Add(new CuiElement
                {
                    Name = "Titles",
                    Parent = UI_Backpack_Upgrade_Workbench,
                    Components = {
                    new CuiTextComponent { Text = "%BACKPACK_UPGRADE_WORKBENCH_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 20, Align = TextAnchor.LowerLeft, Color = "0.91 0.87 0.83 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-190.166 41.466", OffsetMax = "190.164 73.334" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "DescriptionInstruction",
                    Parent = UI_Backpack_Upgrade_Workbench,
                    Components = {
                    new CuiTextComponent { Text = "%BACKPACK_UPGRADE_WORKBENCH_DESCRIPTION%", Font = "robotocondensed-regular.ttf", FontSize = 13, Align = TextAnchor.MiddleLeft, Color = "0.91 0.87 0.83 0.7" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-123.077 -33.795", OffsetMax = "180.793 33.795" }
                }
                });
                container.Add(new CuiElement
                {
                    Name = "SpriteLogo",
                    Parent = UI_Backpack_Upgrade_Workbench,
                    Components = {
                    new CuiImageComponent { Color = "1 1 1 0.35", Sprite = "assets/icons/tools.png", },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-174.6 -16", OffsetMax = "-142.6 16" }
                }
                });

                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = "1 1 1 0.025", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-190.168 -91.693", OffsetMax = "190.162 -41.7" }
                },  UI_Backpack_Upgrade_Workbench, "PanelButtonInfo");

                container.Add(new CuiButton
                {
                    Button = { Command = "%COMMAND%", Color = "%COLOR%", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                    Text = { Text = "%BACKPACK_UPGRADE_WORKBENCH_BUTTON%", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "0.91 0.87 0.83 1" },
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-65.306 -15.956", OffsetMax = "65.306 15.956" },
                },  "PanelButtonInfo", "ButtonOpenMenu");

                AddInterface("UI_Backpack_Upgrade_Workbench", container.ToJson());
            }

            #endregion
        }

        #endregion

        #region Lang    
        public static StringBuilder sb = new StringBuilder();
        public string GetLang(string LangKey, string userID = null, params object[] args)
        {
            sb.Clear();
            if (args != null)
            {
                sb.AppendFormat(lang.GetMessage(LangKey, this, userID), args);
                return sb.ToString();
            }
            return lang.GetMessage(LangKey, this, userID);
        }
        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CRAFT_BTN"] = "CRAFT",
                ["SLOT_AVALIBLE_TITLE"] = "<b>YOUR AVAILABLE NUMBER OF SLOTS</b>",
                ["TITLE_PLUGIN_CRAFT_MENU"] = "CREATING BACKPACK",
                ["TITLE_STORE_INFORMATION"] = "YOU CAN EXPAND THE NUMBER OF SLOTS IN OUR STORE - VK.COM/MERCURYDEV",
                ["TITLE_HAVE_ITEMS"] = "<b>REQUIRED ITEMS FOR CRAFTING A BACKPACK</b>",
                ["TITLE_HAVE_ITEMS_DESCRIPTION"] = "In this section, the items that are required to create this backpack are displayed, you need to collect all the items and press the 'CRAFT' button, if you have the right amount collected, the indicator will change color to green under the item",

                ["CRAFTING_BACKPACK_NO_ITEMS"] = "You don't have enough items to create a backpack",
                ["BACKPACK_TITLE"] = "BACKPACK {0} SLOT(S)",
                ["BACKPACK_IS_OPENED"] = "Do you already have your backpack open!",
                ["BACKPACK_NO_WEARING"] = "In order to use a backpack, you need to put it on!",
                ["BACKPACK_NO_INITIALIZE"] = "The plugin is loading, expect you will be able to open crafting soon!",

                ["BACKPACK_UPGRADE_TITLE"] = "<b>Manual</b>",
                ["BACKPACK_UPGRADE_DESCRIPTION"] = "You need to collect these items and put them in the slot together with the backpack, in exchange you will receive an improved rucksack with an additional number of slots",
                
                ["BACKPACK_UPGRADE_WORKBENCH_TITLE"] = "<b>UPGRADE BACKPACK</b>",
                ["BACKPACK_UPGRADE_WORKBENCH_DESCRIPTION"] = "You can upgrade the backpack and increase the slots in it, to go to the upgrade menu, press the green button!\nThe maximum number of improvements to {0} slot(s)",
                ["BACKPACK_UPGRADE_WORKBENCH_BUTTON"] = "<b>UPGRADE BACKPACK</b>",
                ["BACKPACK_UPGRADE_WORKBENCH_INFORMATION_SLOTS"] = "By upgrading the backpack to this level, you will receive: +{0} slot(s)",
                ["BACKPACK_UPGRADE_WORKBENCH_INFORMATION_BUTTON_TILE"] = "<b>UPGRADE BACKPACK</b>",
                ["BACKPACK_UPGRADE_WORKBENCH_BUTTON_MAXIMUM"] = "<b>MAX UPGRADE</b>",
                ["BACKPACK_UPGRADE_WORKBENCH_INFORMATION_BUTTON_TILE_FALSE_RESOURCE"] = "<b>INSUFFICIENT RESOURCES</b>",

                ["BACKPACK_GRANT"] = "You have successfully received a backpack, the number of slots has been increased to : {0}",
                ["BACKPACK_REVOKE"] = "Your extra slots privilege expired, slots reduced to : {0}",
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CRAFT_BTN"] = "СКРАФТИТЬ",
                ["SLOT_AVALIBLE_TITLE"] = "<b>ВАШЕ ДОСТУПНОЕ КОЛИЧЕСТВО СЛОТОВ</b>",
                ["TITLE_PLUGIN_CRAFT_MENU"] = "СОЗДАНИЕ РЮКЗАКА",
                ["TITLE_STORE_INFORMATION"] = "РАСШИРИТЬ КОЛИЧЕСТВО СЛОТОВ МОЖНО У НАС В МАГАЗИНЕ - VK.COM/MERCURYDEV",
                ["TITLE_HAVE_ITEMS"] = "<b>ТРЕБУЕМЫЕ ПРЕДМЕТЫ ДЛЯ КРАФТА РЮКЗАКА</b>",
                ["TITLE_HAVE_ITEMS_DESCRIPTION"] = "В этой секции отображаются предметы, которые требуются для создания данного рюкзака, вам нужно собрать все элементы и нажать кнопку 'СКРАФТИТЬ', если у вас будет собрано нужное количество, под предметом индикатор изменит цвет на зеленый",

                ["CRAFTING_BACKPACK_NO_ITEMS"] = "У вас недостаточно предметов для создания рюкзака",
                ["BACKPACK_TITLE"] = "РЮКЗАК {0} СЛОТА(ОВ)",
                ["BACKPACK_IS_OPENED"] = "У вас уже открыт рюкзак!",
                ["BACKPACK_NO_WEARING"] = "Для того, чтобы использовать рюкзак, необходимо его надеть!",
                ["BACKPACK_NO_INITIALIZE"] = "Плагин загружается, ожидайте, вскоре вы сможете открыть крафт!",

                ["BACKPACK_UPGRADE_TITLE"] = "<b>Инструкция</b>",
                ["BACKPACK_UPGRADE_DESCRIPTION"] = "Вам нужно собрать указанные предметы и переложить в слот вместе с рюкзаком, в обмен вы получите улучшенный рюкзак с дополнительным количеством слотов",

                ["BACKPACK_UPGRADE_WORKBENCH_TITLE"] = "<b>УЛУЧШЕНИЕ РЮКЗАКА</b>",
                ["BACKPACK_UPGRADE_WORKBENCH_BUTTON"] = "<b>УЛУЧШИТЬ РЮК.</b>",
                ["BACKPACK_UPGRADE_WORKBENCH_BUTTON_MAXIMUM"] = "<b>МАКСИМУМ УЛ.</b>",
                ["BACKPACK_UPGRADE_WORKBENCH_DESCRIPTION"] = "Вы можете улучшать рюкзак и увеличивать слоты в нем, для перехода в меню улучшения нажмите зеленую кнопку!\nМаксимальное количество улучшений до - {0} слот(а/ов)",
                ["BACKPACK_UPGRADE_WORKBENCH_INFORMATION_SLOTS"] = "Улучшив рюкзак до данного уровня вы получите : +{0} слот(а/ов)",
                ["BACKPACK_UPGRADE_WORKBENCH_INFORMATION_BUTTON_TILE"] = "<b>УЛУЧШИТЬ РЮКЗАК</b>",
                ["BACKPACK_UPGRADE_WORKBENCH_INFORMATION_BUTTON_TILE_FALSE_RESOURCE"] = "<b>НЕДОСТАТОЧНО РЕСУРСОВ</b>",

                ["BACKPACK_GRANT"] = "Вы успешно получили рюкзак, количество слотов увеличено до : {0}",
                ["BACKPACK_REVOKE"] = "У вас истекла привилегия с дополнительными слотами, слоты уменьшились до : {0}",


            }, this, "ru");
        }
        #endregion

        #region Behaviour

        #region BP
        private class BackpackBehaviour : FacepunchBehaviour
        {
            public Item Backpack = null;
            private BasePlayer Player = null;
            public StorageContainer Container = null;
            public UInt64 BackpackID = 0;
            private Dictionary<Item, Item.Flag> SaveFlags = new Dictionary<Item, Item.Flag>();
            private void Awake()
            {
                Player = GetComponent<BasePlayer>();
                BackpackID = _.GetBackpackID(Player);
            }
            private void BlackListAction(Boolean State)
            {
                List<Item> Itemlist = _.GetItemBlacklist(Player);
                if (Itemlist == null) return;

                foreach (Item item in Itemlist)
                {
                    if (State)
                        if (!SaveFlags.ContainsKey(item))
                            SaveFlags.Add(item, item.flags);

                    item.SetFlag(global::Item.Flag.IsLocked, State);
                }

                if(!State)
                    foreach(KeyValuePair<Item, Item.Flag> Items in SaveFlags)
                        Items.Key.SetFlag(Items.Value, true);

                Player.SendNetworkUpdate();
            }
            public void Open()
            {
                Container = CreateContainer(Player);

                PushItems();

                LockSlot(true);

                _.timer.Once(0.1f, () => PlayerLootContainer(Player, Container));
                BlackListAction(true);

                if (!_.PlayerUseBackpacks.Contains(Player))
                    _.PlayerUseBackpacks.Add(Player);
            }

            public void LockSlot(bool state)
            {
                if (Backpack == null) return;

                Backpack.LockUnlock(state);

                foreach (var item in Player.inventory.AllItems())
                    if (item.skin == Backpack.skin)
                        item.LockUnlock(state);
            }

            public void Close()
            {
                LockSlot(false);
                _.Backpacks[BackpackID].Items = SaveItems(Container.inventory.itemList);
                Container.inventory.Clear();
                Container.Kill();
                Container = null;

                Destroy(false);
                BlackListAction(false);
                if (_.PlayerUseBackpacks.Contains(Player))
                    _.PlayerUseBackpacks.Remove(Player);
            }

            private void PushItems()
            {
                //_.Unsubscribe("OnItemAddedToContainer");

                var items = RestoreItems(_.Backpacks[BackpackID].Items);
                for (int i = items.Count - 1; i >= 0; i--)
                    items[i].MoveToContainer(Container.inventory, items[i].position);

               // _.Subscribe("OnItemAddedToContainer");
            }

            public void Destroy(bool isClose = true)
            {
                if (isClose)
                    Close();

                UnityEngine.Object.Destroy(this);
            }
        }
        #endregion

        #region Upgrade BP
        private class ShopFrontBehavior : FacepunchBehaviour
        {
            private BasePlayer Player = null;
            public ShopFront Container = null;
            public Int32 UpgradeSlotsUp = 0;
            public UInt64 BackpackID = 0;
            public List<Configuration.Backpack.BackpackCraft.ItemCraft> ItemList = null;
            private Dictionary<Item, Item.Flag> SaveFlags = new Dictionary<Item, Item.Flag>();
            private void Awake()
            {
                Player = GetComponent<BasePlayer>();
                BackpackID = _.GetBackpackID(Player);
                ItemList = GetListUpgrade();
            }
            public void Open()
            {
                if (ItemList == null) return;
                Container = CreateShopFront(Player);
                Invoke(() =>
                {
                    PlayerLootContainer(Player, Container, ItemList);
                    VendorLock(true);
                    WhiteListAction(true);
                    _.DrawUI_Backpack_Upgrade_Info(Player);
                }, 0.1f);      
            }
            private List<Configuration.Backpack.BackpackCraft.ItemCraft> GetListUpgrade()
            {
                Configuration.Backpack.BackpackCraft Backpack = _.GetBackpackOption(Player);
                if (Backpack == null) return null;
                if (!_.Backpacks.ContainsKey(BackpackID)) return null;
                Int32 IndexUpgrade = _.Backpacks[BackpackID].IndexUpgrade;
                if ((Backpack.UpgradeList.Count - 1) < (IndexUpgrade + 1)) return null;
                List<Configuration.Backpack.BackpackCraft.ItemCraft> ItemList = Backpack.UpgradeList[IndexUpgrade + 1].CraftItems;
                if (ItemList == null || ItemList.Count == 0) return null;
                UpgradeSlotsUp = Backpack.UpgradeList[IndexUpgrade + 1].SlotUpgrade;

                return ItemList;
            }
            private List<Item> GetWhiteList()
            {
                List<Item> WhiteList = new List<Item>();

                foreach (Configuration.Backpack.BackpackCraft.ItemCraft Items in ItemList)
                    foreach (Item item in Player.inventory.AllItems())
                    {
                        if (item.info.shortname == Items.Shortname)
                            WhiteList.Add(item);
                    }
                return WhiteList;
            }


            private void WhiteListAction(Boolean State)
            {
                if (ItemList == null) return;

                foreach (Item item in Player.inventory.AllItems().Where(i => !GetWhiteList().Contains(i)))
                {
                    if (State)
                        if (!SaveFlags.ContainsKey(item))
                            SaveFlags.Add(item, item.flags);

                    item.SetFlag(global::Item.Flag.IsLocked, State);
                }

                foreach (KeyValuePair<Item, Item.Flag> Items in SaveFlags)
                    Items.Key.SetFlag(Items.Value, true);

                Player.SendNetworkUpdate();
            }
            public void VendorLock(Boolean State)
            {
                if (Container == null || Container.vendorInventory == null) return;
                Container.vendorInventory.SetLocked(State);
            }
            public void Close()
            {
                WhiteListAction(false);
                if (Container != null)
                {
                    Container.inventory.Clear();
                    Container.Kill();
                    Container = null;
                }
                CuiHelper.DestroyUi(Player, InterfaceBuilder.UI_Backpack_Upgrade_Info);
                CuiHelper.DestroyUi(Player, InterfaceBuilder.UI_Backpack_Upgrade_Workbench);
                Destroy(false);
            }

            public void Destroy(bool isClose = true)
            {
                if (isClose)
                    Close();

                UnityEngine.Object.Destroy(this);
            }
        }
        #endregion

        #region Backpack Spine [PVE]

        class BackpackSpine : FacepunchBehaviour
        {
            Rigidbody rigidbodyBP;
            DroppedItemContainer backpack;
            BasePlayer player;

            public BackpackSpine()
            {
                player = GetComponent<BasePlayer>();

                backpack = GameManager.server.CreateEntity("assets/prefabs/misc/item drop/item_drop_backpack.prefab", player.transform.position + new Vector3(0f, -7f, 0f), new Quaternion()) as DroppedItemContainer;
                rigidbodyBP = backpack.GetComponent<Rigidbody>();
                rigidbodyBP.useGravity = false;
                rigidbodyBP.isKinematic = true;
                rigidbodyBP.drag = 0;
                rigidbodyBP.interpolation = RigidbodyInterpolation.Extrapolate;
                backpack.OwnerID = player.userID;

                ItemContainer container = new ItemContainer { playerOwner = player };
                container.ServerInitialize((Item)null, _.GetSlotsBackpack(player));
                if ((Int32)container.uid == 0)
                    container.GiveUID();

                backpack.inventory = container;
                backpack.SetFlag(BaseEntity.Flags.Busy, true);
                backpack.SetFlag(BaseEntity.Flags.Locked, true);
                backpack.Spawn();

                backpack.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                backpack.UpdateNetworkGroup();

                backpack.transform.localPosition = new Vector3(-0.05f, 0.03f, 0f);
                backpack.transform.localRotation = new Quaternion(-3f, 0f, 3f, 0f);

                backpack.SetParent(player, "spine2");
                backpack.ResetRemovalTime(Math.Max(99999999999999999, backpack.CalculateRemovalTime()));
                enabled = true;
            }

            public void OnDestroy() => KillParent();

            public void KillParent()
            {
                enabled = false;
                
                if (!backpack.IsDestroyed)
                    backpack.Kill();
                UnityEngine.GameObject.Destroy(this);
            }
        }

        #endregion

        #endregion
    }
}


// --- End of file: IQBackpack.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RocketTurrets.cs ---
// --- Original Local Path: RocketTurrets.cs ---

// Plugin formatted by redBDGR's Plugin Formatting Tool
using Oxide.Core; 
using Oxide.Core.Configuration; 
using Oxide.Core.Plugins; 
using Rust; 
using System; 
using System.Collections; 
using System.Collections.Generic; 
using System.Linq; 
using System.Text; 
using UnityEngine; 

namespace Oxide.Plugins
{
	[Info("RocketTurrets", "redBDGR", "1.3.15")]
	[Description("Create rocket shooting turrets")]
	class RocketTurrets : RustPlugin
	{
		private bool changed; private List<AutoTurret> rocketTurrets = new List<AutoTurret>(); private List<AutoTurret> antiairTurrets = new List<AutoTurret>(); private List<AutoTurret> javelinTurrets = new List<AutoTurret>(); private Dictionary<string, PlayerData> turretNumbers = new Dictionary<string, PlayerData>(); private List<ulong> turretIDs = new List<ulong>(); private List<ulong> antiAirIDs = new List<ulong>(); private List<ulong> javelinIDs = new List<ulong>(); private static RocketTurrets plugin; [PluginReference] Plugin RemoteTurrets; public static LayerMask collLayers = LayerMask.GetMask("Construction", "Deployed", "Tree", "Terrain", "Resource", "World", "Water", "Default", "AI"); private float rocketFireRate = 1.2f; private float rocketLockonTime = 5f; private float minHitDistance = 10f; private float rocketLockonRadius = 40f; private float rocketSpeed = 20f; private uint rocketLauncherSkin; private float explosionRadius = 4f; private bool explodeAtTarget = true; private int lockonSoundEveryxUpdate = 100; private bool requiresAmmo = true; private int maxNumberAllowed = 5; private bool rocketHeatSeeking; private bool customRocketTrail = false; private float aaFireRate = 1.2f; private float aaLockonTime = 5f; private float aaminHitDistance = 5f; private float aaLockonRadius = 150f; private float aarocketSpeed = 40f; private uint aaLauncherSkin; private float aaexplosionRadius = 4f; private int aalockonSoundEveryxUpdate = 100; private float damageToHeli = 500f; private bool aaRequiresAmmo = true; private int aaMaxNumberAllowed = 5; private bool aaRequireBuildingRightsToAccessInventory = true; private bool aaCustomRocketTrail = true; private float jrocketFireRate = 1.2f; private float jrocketLockonTime = 5f; private float jminHitDistance = 10f; private float jrocketLockonRadius = 40f; private float jrocketSpeed = 20f; private uint jrocketLauncherSkin; private float jexplosionRadius = 4f; private int jlockonSoundEveryxUpdate = 100; private bool jrequiresAmmo = true; private int jmaxNumberAllowed = 5; private bool jSeekTarget = true; private float jHeightBeforeCurve = 40f; private bool jCustomRocketTrail = true; private bool returnCostOnPickup; private bool returnCostOnDowngrade; private static Dictionary<string, object> RocketUpgradeCost() { var at = new Dictionary<string, object> { { "rocket.launcher", 1 } }; return at; } private static Dictionary<string, object> AntiAirUpgradeCost() { var at = new Dictionary<string, object> { { "targeting.computer", 1 }, { "cctv.camera", 2 }, { "rocket.launcher", 1 } }; return at; } private static Dictionary<string, object> JavelinUpgradeCost() { var at = new Dictionary<string, object> { { "rocket.launcher", 1 } }; return at; } private Dictionary<string, object> rocketUpgradeCost; private Dictionary<string, object> antiAirUpgradeCost; private Dictionary<string, object> javelinUpgradeCost; private const string permissionName = "rocketturrets.use"; private const string permissionNameROCKET = "rocketturrets.rocket"; private const string permissionNameANTIAIR = "rocketturrets.antiair"; private const string permissionNameJAVELIN = "rocketturrets.javelin"; private const string permissionNameUNLIMITED = "rocketturrets.unlimited"; private const string permissionNameAMMOUNLIMITED = "rocketturrets.unlimitedammo"; private class StoredData { public List<ulong> turretIDs = new List<ulong>(); public List<ulong> antiAirIDs = new List<ulong>(); public List<ulong> javelinIDs = new List<ulong>(); } private class StoredData2 { public Dictionary<string, PlayerData> turretNumbers = new Dictionary<string, PlayerData>(); } private class PlayerData { public int RocketTurrets; public int AntiAirTurrets; public int JavelinTurrets; } private DynamicConfigFile data; private DynamicConfigFile data2; private StoredData storedData; private StoredData2 storedData2; private void OnServerSave() => SaveData(); private void SaveData() { storedData.turretIDs = turretIDs; storedData.antiAirIDs = antiAirIDs; storedData.javelinIDs = javelinIDs; storedData2.turretNumbers = turretNumbers; data.WriteObject(storedData); data2.WriteObject(storedData2); } private void LoadData() { try { storedData = data.ReadObject<StoredData>(); storedData2 = data2.ReadObject<StoredData2>(); turretNumbers = storedData2.turretNumbers; turretIDs = storedData.turretIDs; antiAirIDs = storedData.antiAirIDs; javelinIDs = storedData.javelinIDs; } catch { Puts("Failed to load data, creating new file"); storedData = new StoredData(); } } protected override void LoadDefaultConfig() { Config.Clear(); LoadVariables(); } private void LoadVariables() { rocketFireRate = Convert.ToSingle(GetConfig("Turret Settings", "Rocket fire rate", 2f)); rocketLockonTime = Convert.ToSingle(GetConfig("Turret Settings", "Lockon length", 5f)); minHitDistance = Convert.ToSingle(GetConfig("Turret Settings", "Min shoot distance", 4f)); rocketLockonRadius = Convert.ToSingle(GetConfig("Turret Settings", "Rocket lockon radius", 40f)); rocketSpeed = Convert.ToSingle(GetConfig("Turret Settings", "Rocket speed", 20f)); rocketLauncherSkin = Convert.ToUInt32(GetConfig("Turret Settings", "Default rocket model skin", 0)); explosionRadius = Convert.ToSingle(GetConfig("Turret Settings", "Explosion radius", 4f)); explodeAtTarget = Convert.ToBoolean(GetConfig("Turret Settings", "Explode at target pos", true)); lockonSoundEveryxUpdate = Convert.ToInt32(GetConfig("Turret Settings", "Lockon sound every x updates", 100)); requiresAmmo = Convert.ToBoolean(GetConfig("Turret Settings", "Requires Ammo", true)); maxNumberAllowed = Convert.ToInt16(GetConfig("Turret Settings", "Maximum Allowed Per Player", 5)); rocketHeatSeeking = Convert.ToBoolean(GetConfig("Turret Settings", "Heatseeking Rockets", false)); customRocketTrail = Convert.ToBoolean(GetConfig("Turret Settings", "Custom Rocket Trail", false)); aaFireRate = Convert.ToSingle(GetConfig("AntiAir Settings", "Rocket fire rate", 2f)); aaLockonTime = Convert.ToSingle(GetConfig("AntiAir Settings", "Lockon length", 5f)); aaminHitDistance = Convert.ToSingle(GetConfig("AntiAir Settings", "Min shoot distance", 4f)); aaLockonRadius = Convert.ToSingle(GetConfig("AntiAir Settings", "Lockon radius", 80f)); aarocketSpeed = Convert.ToSingle(GetConfig("AntiAir Settings", "Rocket speed", 30f)); aaLauncherSkin = Convert.ToUInt32(GetConfig("AntiAir Settings", "Default rocket model skin", 0)); aaexplosionRadius = Convert.ToSingle(GetConfig("AntiAir Settings", "Explosion radius", 4f)); aalockonSoundEveryxUpdate = Convert.ToInt32(GetConfig("AntiAir Settings", "Lockon sound every x updates", 100)); damageToHeli = Convert.ToSingle(GetConfig("AntiAir Settings", "Damage to heli", 500f)); aaRequiresAmmo = Convert.ToBoolean(GetConfig("AntiAir Settings", "Requires Ammo", true)); aaMaxNumberAllowed = Convert.ToInt16(GetConfig("AntiAir Settings", "Maximum Allowed Per Player", 5)); aaRequireBuildingRightsToAccessInventory = Convert.ToBoolean(GetConfig("AntiAir Settings", "Require Build Acces to Loot", true)); aaCustomRocketTrail = Convert.ToBoolean(GetConfig("AntiAir Settings", "Custom Rocket Trail", true)); jrocketFireRate = Convert.ToSingle(GetConfig("Javelin Settings", "Rocket fire rate", 2f)); jrocketLockonTime = Convert.ToSingle(GetConfig("Javelin Settings", "Lockon Length", 5f)); jminHitDistance = Convert.ToSingle(GetConfig("Javelin Settings", "Min lockon distance", 10f)); jrocketLockonRadius = Convert.ToSingle(GetConfig("Javelin Settings", "Lockon radius", 80f)); jrocketSpeed = Convert.ToSingle(GetConfig("Javelin Settings", "Rocket speed", 15f)); jrocketLauncherSkin = Convert.ToUInt32(GetConfig("Javelin Settings", "Default rocket model skin", 0)); jexplosionRadius = Convert.ToSingle(GetConfig("Javelin Settings", "Explosion radius", 4f)); jlockonSoundEveryxUpdate = Convert.ToInt16(GetConfig("Javelin Settings", "Lockon sound every x updates", 100)); jrequiresAmmo = Convert.ToBoolean(GetConfig("Javelin Settings", "Requires ammo", true)); jmaxNumberAllowed = Convert.ToInt16(GetConfig("Javelin Settings", "Max number allowed per player", 5)); jSeekTarget = Convert.ToBoolean(GetConfig("Javelin Settings", "Seek target", true)); jHeightBeforeCurve = Convert.ToSingle(GetConfig("Javelin Settings", "Height before curve starts", 40f)); jCustomRocketTrail = Convert.ToBoolean(GetConfig("Javelin Settings", "Custom Rocket Trail", true)); rocketUpgradeCost = (Dictionary<string, object>)GetConfig("Turret Settings", "[ Cost to upgrade - Rocket tier ]", RocketUpgradeCost()); antiAirUpgradeCost = (Dictionary<string, object>)GetConfig("AntiAir Settings", "[Cost to Upgrade - AntiAir Tier ]", AntiAirUpgradeCost()); javelinUpgradeCost = (Dictionary<string, object>)GetConfig("Javelin Settings", "[ Cost to upgrade - Javelin Tier ]", JavelinUpgradeCost()); returnCostOnPickup = Convert.ToBoolean(GetConfig("General Settings", "Return upgrade cost on turret pickup", false)); returnCostOnDowngrade = Convert.ToBoolean(GetConfig("General Settings", "Return upgrade cost on turret downgrade", false)); if (!changed) return; SaveConfig(); changed = false; } private bool IsRocketTurret(AutoTurret turret) { if (turret.GetComponent<RocketTurret>() || turret.GetComponent<JavelinTurret>() || turret.GetComponent<AntiAirTurret>()) return true; return false; } private void ToggleTurretAutomation(AutoTurret turret, bool enabled) { if (turret.GetComponent<RocketTurret>()) turret.GetComponent<RocketTurret>().enabled = true; else if (turret.GetComponent<AntiAirTurret>()) turret.GetComponent<AntiAirTurret>().enabled = true; else if (turret.GetComponent<JavelinTurret>()) turret.GetComponent<JavelinTurret>().enabled = true; } private void TryFireRocket(AutoTurret turret) { if (turret.GetComponent<RocketTurret>()) turret.GetComponent<RocketTurret>().TryFireRocket(); else if (turret.GetComponent<AntiAirTurret>()) turret.GetComponent<AntiAirTurret>().TryFireRocket(); else if (turret.GetComponent<JavelinTurret>()) turret.GetComponent<JavelinTurret>().TryFireRocket(); } private class RocketTurret : MonoBehaviour { private float aimRadius = plugin.rocketLockonRadius; private float fireRate = plugin.rocketFireRate; private float rocketSpeed = plugin.rocketSpeed; private float minHitDistance = plugin.minHitDistance; private float lockonTime = plugin.rocketLockonTime; private uint rocketLauncherSkin = plugin.rocketLauncherSkin; private float explosionRadius = plugin.explosionRadius; private bool explodeOnTargetPos = plugin.explodeAtTarget; private int soundEveryxUpdates = plugin.lockonSoundEveryxUpdate; private bool requiresAmmo = plugin.requiresAmmo; private bool heatSeek = plugin.rocketHeatSeeking; private int updateCounter; private bool isLockedOn; private bool isLockingOn; private float lockonFinish; private float nextShoot; private AutoTurret turret; private BaseCombatEntity target; private DroppedItem launcher_1; private DroppedItem rocket_1; private DroppedItem rocket_2; private DestroyOnGroundMissing desGround; private GroundWatch groundWatch; private void Awake() { turret = gameObject.GetComponent<AutoTurret>(); InitAesthetics(); if (!plugin.rocketTurrets.Contains(turret)) plugin.rocketTurrets.Add(turret); turret.sightRange = aimRadius; if (!plugin.turretIDs.Contains(turret.net.ID)) plugin.turretIDs.Add(turret.net.ID); desGround = GetComponent<DestroyOnGroundMissing>(); if (!desGround) gameObject.AddComponent<DestroyOnGroundMissing>(); groundWatch = GetComponent<GroundWatch>(); if (!groundWatch) gameObject.AddComponent<GroundWatch>(); groundWatch.CancelInvoke("OnPhysicsNeighbourChanged"); groundWatch.InvokeRepeating("OnPhysicsNeighbourChanged", 0, 0.5f); } private void Update() { if (!turret.HasTarget()) { if (isLockedOn) isLockedOn = false; if (isLockingOn) isLockingOn = false; return; } if (!isLockedOn) { if (!isLockingOn) { lockonFinish = Time.time + lockonTime; isLockingOn = true; } else if (isLockingOn && Time.time > lockonFinish) LockToTarget(turret.target); else if (isLockingOn) { if (updateCounter == soundEveryxUpdates) { Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.unlock.prefab", turret.transform.position); updateCounter = 0; return; } updateCounter++; } } else { if (Time.time < nextShoot) return; if (Vector3.Distance(turret.muzzlePos.transform.position, turret.target.transform.position) < minHitDistance) return; var rocketItem = HasAmmo(); if (rocketItem == null) return; FireRocket(rocketItem); nextShoot = Time.time + fireRate; } } private void OnDestroy() { if (!launcher_1.IsDestroyed) launcher_1.Kill(); if (!rocket_1.IsDestroyed) rocket_1.Kill(); if (!rocket_2.IsDestroyed) rocket_2.Kill(); } public void Destroy() { if (plugin.rocketTurrets.Contains(turret)) plugin.rocketTurrets.Remove(turret); if (plugin.turretIDs.Contains(turret.net.ID)) plugin.turretIDs.Remove(turret.net.ID); OnDestroy(); if (this) Destroy(this); } private void DestroyTurret() { if (turret != null) turret.Kill(BaseNetworkable.DestroyMode.Gib); } public void UnloadDestroy() { if (plugin.rocketTurrets.Contains(turret)) plugin.rocketTurrets.Remove(turret); OnDestroy(); Destroy(this); } private Item HasAmmo() { if (plugin.permission.UserHasPermission(turret.OwnerID.ToString(), permissionNameAMMOUNLIMITED)) return ItemManager.CreateByName("ammo.rocket.basic"); return !requiresAmmo ? ItemManager.CreateByName("ammo.rocket.basic") : turret.inventory.itemList.FirstOrDefault(item => item.info.itemid == -742865266 || item.info.itemid == 1638322904 || item.info.itemid == -1841918730); } private void LockToTarget(BaseCombatEntity entity) { isLockedOn = true; isLockingOn = false; nextShoot = Time.time + 0.3f; target = entity; } private void InitAesthetics() { launcher_1 = ItemManager.CreateByItemID(442886268, 1, rocketLauncherSkin).Drop(turret.transform.position, Vector3.zero).GetComponent<DroppedItem>(); launcher_1.GetComponent<Rigidbody>().isKinematic = true; launcher_1.GetComponent<Rigidbody>().useGravity = false; launcher_1.allowPickup = false; launcher_1.CancelInvoke((Action)Delegate.CreateDelegate(typeof(Action), launcher_1, "IdleDestroy")); rocket_1 = ItemManager.CreateByItemID(-742865266).Drop(turret.transform.position, Vector3.zero).GetComponent<DroppedItem>(); rocket_1.GetComponent<Rigidbody>().isKinematic = true; rocket_1.GetComponent<Rigidbody>().useGravity = false; rocket_1.allowPickup = false; rocket_1.CancelInvoke((Action)Delegate.CreateDelegate(typeof(Action), rocket_1, "IdleDestroy")); rocket_2 = ItemManager.CreateByItemID(-742865266).Drop(turret.transform.position, Vector3.zero).GetComponent<DroppedItem>(); rocket_2.GetComponent<Rigidbody>().isKinematic = true; rocket_2.GetComponent<Rigidbody>().useGravity = false; rocket_2.allowPickup = false; rocket_2.CancelInvoke((Action)Delegate.CreateDelegate(typeof(Action), rocket_2, "IdleDestroy")); var launcherRot = new Vector3(); var rocketRot = new Vector3(); foreach (var entry in turret.gameObject.transform.GetAllChildren()) { if (entry.name != "weapon_socket") continue; launcherRot = entry.gameObject.transform.localRotation.eulerAngles; launcherRot = new Vector3(launcherRot.x, launcherRot.y + 180, launcherRot.z); rocketRot = entry.gameObject.transform.localRotation.eulerAngles; rocketRot = new Vector3(rocketRot.x, rocketRot.y + 270, rocketRot.z); } launcher_1.SetParent(turret, "weapon_socket"); launcher_1.transform.localPosition = new Vector3(0, 0, 0); launcher_1.transform.localRotation = Quaternion.Euler(launcherRot); rocket_1.SetParent(turret, "weapon_socket"); rocket_1.transform.localPosition = new Vector3(0, -0.05f, 0.17f); rocket_1.transform.localRotation = Quaternion.Euler(rocketRot); rocket_2.SetParent(turret, "weapon_socket"); rocket_2.transform.localPosition = new Vector3(0, -0.05f, -0.17f); rocket_2.transform.localRotation = Quaternion.Euler(rocketRot); } public void TryFireRocket() { if (Time.time < nextShoot) return; var rocketItem = HasAmmo(); if (rocketItem == null) return; FireRocket(rocketItem); nextShoot = Time.time + fireRate; } private void FireRocket(Item rocketItem) { ServerProjectile rocket = CreateRocket(turret.muzzlePos.transform.position, rocketItem); if (rocket == null) return; TimedExplosive expl = rocket.gameObject.GetComponent<TimedExplosive>(); if (enabled && explodeOnTargetPos && target) { float dist = Vector3.Distance(turret.muzzlePos.position, turret.target.transform.position); float time = dist / rocketSpeed; expl.SetFuse(time); } else expl.SetFuse(float.PositiveInfinity); expl.explosionRadius = explosionRadius; rocket.gravityModifier = 0f; rocket.speed = rocketSpeed; rocket.InitializeVelocity(turret.aimDir); Effect.server.Run("assets/prefabs/npc/patrol helicopter/effects/rocket_fire.prefab", turret.muzzlePos.position); if (plugin.customRocketTrail) { BaseEntity trail = GameManager.server.CreateEntity("assets/bundled/prefabs/oilfireballsmall.prefab"); trail.SetParent(rocket.GetComponent<BaseEntity>()); trail.Spawn(); } if (heatSeek) if (this.target != null) rocket.gameObject.AddComponent<HeatRocket>().target = target; } private ServerProjectile CreateRocket(Vector3 launchPos, Item rocketItem) { if (requiresAmmo) { if (rocketItem == null) return null; if (rocketItem.amount == 1) rocketItem.RemoveFromContainer(); else rocketItem.UseItem(); } else rocketItem.RemoveFromContainer(); BaseEntity rocket; switch (rocketItem.info.shortname) { case "ammo.rocket.basic": rocket = GameManager.server.CreateEntity("assets/prefabs/ammo/rocket/rocket_basic.prefab", launchPos); break; case "ammo.rocket.fire": rocket = GameManager.server.CreateEntity("assets/prefabs/ammo/rocket/rocket_fire.prefab", launchPos); break; case "ammo.rocket.hv": rocket = GameManager.server.CreateEntity("assets/prefabs/ammo/rocket/rocket_hv.prefab", launchPos); break; default: return null; } if (rocket == null) return null; rocket.creatorEntity = turret; rocket.Spawn(); if (target != null) { rocket.transform.LookAt(target.transform); rocket.GetComponent<ServerProjectile>()?.InitializeVelocity(target.transform.position); } else { rocket.transform.LookAt(turret.muzzlePos.position + turret.muzzlePos.forward.normalized * 10); rocket.GetComponent<ServerProjectile>()?.InitializeVelocity(turret.muzzlePos.position + turret.muzzlePos.forward * 10); } return rocket.GetComponent<ServerProjectile>(); } } private class AntiAirTurret : MonoBehaviour { private float aimRadius = plugin.aaLockonRadius; private float fireRate = plugin.aaFireRate; private float rocketSpeed = plugin.aarocketSpeed; private float minHitDistance = plugin.aaminHitDistance; private float lockonTime = plugin.aaLockonTime; private uint rocketLauncherSkin = plugin.aaLauncherSkin; private float explosionRadius = plugin.aaexplosionRadius; private int soundEveryxUpdates = plugin.aalockonSoundEveryxUpdate; private float damage = plugin.damageToHeli; private bool requiresAmmo = plugin.aaRequiresAmmo; private int updateCounter; private bool isLockedOn; private bool isLockingOn; private float lockonFinish; private float nextShoot; private AutoTurret turret; private BaseEntity entity; private BaseCombatEntity target; private SphereCollider sCol; private DroppedItem launcher_1; private DroppedItem rocket_1; private DroppedItem rocket_2; private DroppedItem computer; private DroppedItem camera_1; private DroppedItem camera_2; private void Awake() { turret = gameObject.GetComponent<AutoTurret>(); InitAesthetics(); turret.SetIsOnline(false); if (!plugin.antiairTurrets.Contains(turret)) plugin.antiairTurrets.Add(turret); turret.sightRange = 0.1f; if (!plugin.antiAirIDs.Contains(turret.net.ID)) plugin.antiAirIDs.Add(turret.net.ID); entity = gameObject.GetComponent<BaseEntity>(); sCol = entity.gameObject.AddComponent<SphereCollider>(); sCol.gameObject.layer = (int)Layer.Reserved1; sCol.radius = aimRadius; sCol.isTrigger = true; } private void Update() { if (target == null) { if (isLockedOn) isLockedOn = false; if (isLockingOn) isLockingOn = false; return; } if (!isLockedOn) { turret.target = target; turret.UpdateFacingToTarget(); if (!isLockingOn) { lockonFinish = Time.time + lockonTime; isLockingOn = true; } else if (isLockingOn && Time.time > lockonFinish) LockToTarget(turret.target); else if (isLockingOn) { if (updateCounter == soundEveryxUpdates) { Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.unlock.prefab", turret.transform.position); updateCounter = 0; return; } updateCounter++; } } else { TryFireRocket(); } } private void OnTriggerEnter(Collider col) { BaseHelicopter heli = col.GetComponentInParent<BaseHelicopter>(); CH47Helicopter chin = col.GetComponentInParent<CH47Helicopter>(); if (heli != null) target = heli; else if (chin != null) target = chin; } private void OnTriggerExit(Collider col) { if (col.GetComponentInParent<BaseHelicopter>() == null && col.GetComponentInParent<CH47Helicopter>() == null) return; if (col.GetComponentInParent<BaseCombatEntity>() != target) return; turret.target = null; turret.SetTarget(null); target = null; } private void OnDestroy() { if (!launcher_1.IsDestroyed) launcher_1.Kill(); if (!rocket_1.IsDestroyed) rocket_1.Kill(); if (!rocket_2.IsDestroyed) rocket_2.Kill(); if (!computer.IsDestroyed) computer.Kill(); if (!camera_1.IsDestroyed) camera_1.Kill(); if (!camera_2.IsDestroyed) camera_2.Kill(); if (sCol) Destroy(sCol); } public void Destroy() { if (plugin.antiairTurrets.Contains(turret)) plugin.antiairTurrets.Remove(turret); if (plugin.turretIDs.Contains(turret.net.ID)) plugin.turretIDs.Remove(turret.net.ID); OnDestroy(); Destroy(this); } private void DestroyTurret() { if (turret != null) turret.Kill(BaseNetworkable.DestroyMode.Gib); } public void UnloadDestroy() { if (plugin.antiairTurrets.Contains(turret)) plugin.antiairTurrets.Remove(turret); OnDestroy(); Destroy(this); } private Item HasAmmo() { if (plugin.permission.UserHasPermission(turret.OwnerID.ToString(), permissionNameAMMOUNLIMITED)) return ItemManager.CreateByName("ammo.rocket.basic"); return !requiresAmmo ? ItemManager.CreateByName("ammo.rocket.basic") : turret.inventory.itemList.FirstOrDefault(item => item.info.itemid == -742865266 || item.info.itemid == 1638322904 || item.info.itemid == -1841918730); } private void LockToTarget(BaseCombatEntity _entity) { isLockedOn = true; isLockingOn = false; nextShoot = Time.time + 0.3f; target = _entity; } private void InitAesthetics() { launcher_1 = ItemManager.CreateByItemID(442886268, 1, rocketLauncherSkin).Drop(turret.transform.position, Vector3.zero).GetComponent<DroppedItem>(); launcher_1.GetComponent<Rigidbody>().isKinematic = true; launcher_1.GetComponent<Rigidbody>().useGravity = false; launcher_1.allowPickup = false; launcher_1.CancelInvoke((Action)Delegate.CreateDelegate(typeof(Action), launcher_1, "IdleDestroy")); rocket_1 = ItemManager.CreateByItemID(-742865266).Drop(turret.transform.position, Vector3.zero).GetComponent<DroppedItem>(); rocket_1.GetComponent<Rigidbody>().isKinematic = true; rocket_1.GetComponent<Rigidbody>().useGravity = false; rocket_1.allowPickup = false; rocket_1.CancelInvoke((Action)Delegate.CreateDelegate(typeof(Action), rocket_1, "IdleDestroy")); rocket_2 = ItemManager.CreateByItemID(-742865266).Drop(turret.transform.position, Vector3.zero).GetComponent<DroppedItem>(); rocket_2.GetComponent<Rigidbody>().isKinematic = true; rocket_2.GetComponent<Rigidbody>().useGravity = false; rocket_2.allowPickup = false; rocket_2.CancelInvoke((Action)Delegate.CreateDelegate(typeof(Action), rocket_2, "IdleDestroy")); computer = ItemManager.CreateByItemID(1523195708).Drop(turret.transform.position, Vector3.zero).GetComponent<DroppedItem>(); computer.GetComponent<Rigidbody>().isKinematic = true; computer.GetComponent<Rigidbody>().useGravity = false; computer.allowPickup = false; computer.CancelInvoke((Action)Delegate.CreateDelegate(typeof(Action), computer, "IdleDestroy")); camera_1 = ItemManager.CreateByItemID(634478325).Drop(turret.transform.position, Vector3.zero).GetComponent<DroppedItem>(); camera_1.GetComponent<Rigidbody>().isKinematic = true; camera_1.GetComponent<Rigidbody>().useGravity = false; camera_1.allowPickup = false; camera_1.CancelInvoke((Action)Delegate.CreateDelegate(typeof(Action), camera_1, "IdleDestroy")); camera_2 = ItemManager.CreateByItemID(634478325).Drop(turret.transform.position, Vector3.zero).GetComponent<DroppedItem>(); camera_2.GetComponent<Rigidbody>().isKinematic = true; camera_2.GetComponent<Rigidbody>().useGravity = false; camera_2.allowPickup = false; camera_2.CancelInvoke((Action)Delegate.CreateDelegate(typeof(Action), camera_2, "IdleDestroy")); Vector3 computerRot = turret.gameObject.transform.localRotation.eulerAngles; computerRot = new Vector3(computerRot.x, computerRot.y + 240, computerRot.z); computer.SetParent(turret); computer.transform.localPosition = new Vector3(0.45f, 0, 0.25f); computer.transform.rotation = Quaternion.Euler(computerRot); Vector3 launcherRot = new Vector3(); Vector3 rocketRot = new Vector3(); foreach (var entry in turret.gameObject.transform.GetAllChildren()) { if (entry.name != "weapon_socket") continue; launcherRot = entry.gameObject.transform.localRotation.eulerAngles; launcherRot = new Vector3(launcherRot.x, launcherRot.y + 180, launcherRot.z); rocketRot = entry.gameObject.transform.localRotation.eulerAngles; rocketRot = new Vector3(rocketRot.x, rocketRot.y + 270, rocketRot.z); } launcher_1.SetParent(turret, "weapon_socket"); launcher_1.transform.localPosition = new Vector3(0, 0, 0); launcher_1.transform.localRotation = Quaternion.Euler(launcherRot); rocket_1.SetParent(turret, "weapon_socket"); rocket_1.transform.localPosition = new Vector3(0, -0.05f, 0.17f); rocket_1.transform.localRotation = Quaternion.Euler(rocketRot); rocket_2.SetParent(turret, "weapon_socket"); rocket_2.transform.localPosition = new Vector3(0, -0.05f, -0.17f); rocket_2.transform.localRotation = Quaternion.Euler(rocketRot); camera_1.SetParent(turret, "weapon_socket"); camera_1.transform.localPosition = new Vector3(0, 0.05f, -0.17f); camera_1.transform.localRotation = Quaternion.Euler(rocketRot); camera_2.SetParent(turret, "weapon_socket"); camera_2.transform.localPosition = new Vector3(0, 0.05f, 0.17f); camera_2.transform.localRotation = Quaternion.Euler(rocketRot); } public void TryFireRocket() { if (Time.time < nextShoot) return; if (turret.target) if (Vector3.Distance(turret.muzzlePos.transform.position, turret.target.transform.position) < minHitDistance) return; var rocketItem = HasAmmo(); if (rocketItem == null) return; FireRocket(rocketItem); nextShoot = Time.time + fireRate; } private void FireRocket(Item rocketItem) { ServerProjectile rocket = CreateRocket(turret.muzzlePos.transform.position, rocketItem); if (rocket == null) return; TimedExplosive expl = rocket.gameObject.GetComponent<TimedExplosive>(); if (turret.target != null) { float dist = Vector3.Distance(turret.muzzlePos.position, turret.target.transform.position); float time = dist / rocketSpeed; plugin.timer.Once(time - 4f, () => { if (target) target.Hurt(damage); }); } expl.explosionRadius = explosionRadius; rocket.gravityModifier = 0f; rocket.speed = rocketSpeed; rocket.InitializeVelocity(turret.muzzlePos.transform.forward); Effect.server.Run("assets/prefabs/npc/patrol helicopter/effects/rocket_fire.prefab", turret.muzzlePos.position); if (target != null) rocket.gameObject.AddComponent<HeatRocket>().target = turret.target; } private ServerProjectile CreateRocket(Vector3 launchPos, Item rocketItem) { if (requiresAmmo) { if (rocketItem == null) return null; if (rocketItem.amount == 1) rocketItem.RemoveFromContainer(); else rocketItem.UseItem(); } BaseEntity rocket; switch (rocketItem.info.shortname) { case "ammo.rocket.basic": rocket = GameManager.server.CreateEntity("assets/prefabs/ammo/rocket/rocket_basic.prefab", launchPos); break; case "ammo.rocket.fire": rocket = GameManager.server.CreateEntity("assets/prefabs/ammo/rocket/rocket_fire.prefab", launchPos); break; case "ammo.rocket.hv": rocket = GameManager.server.CreateEntity("assets/prefabs/ammo/rocket/rocket_hv.prefab", launchPos); break; default: return null; } if (rocket == null) return null; rocket.Spawn(); if (target) rocket.transform.LookAt(target.transform); else rocket.transform.LookAt(turret.aimDir); return rocket.GetComponent<ServerProjectile>(); } } private class JavelinTurret : MonoBehaviour { private float aimRadius = plugin.jrocketLockonRadius; private float fireRate = plugin.jrocketFireRate; private float rocketSpeed = plugin.jrocketSpeed; private float minHitDistance = plugin.jminHitDistance; private float lockonTime = plugin.jrocketLockonTime; private uint rocketLauncherSkin = plugin.jrocketLauncherSkin; private float explosionRadius = plugin.jexplosionRadius; private int soundEveryxUpdates = plugin.jlockonSoundEveryxUpdate; private bool requiresAmmo = plugin.jrequiresAmmo; private bool seekTarget = plugin.jSeekTarget; private int updateCounter; private bool isLockedOn; private bool isLockingOn; private float lockonFinish; private float nextShoot; private AutoTurret turret; private BaseCombatEntity target; private BaseCombatEntity externalTarget; private DroppedItem launcher_1; private DroppedItem rocket_1; private DroppedItem rocket_2; private DestroyOnGroundMissing desGround; private GroundWatch groundWatch; private void Awake() { turret = gameObject.GetComponent<AutoTurret>(); InitAesthetics(); if (!plugin.javelinTurrets.Contains(turret)) plugin.javelinTurrets.Add(turret); turret.sightRange = aimRadius; if (!plugin.javelinIDs.Contains(turret.net.ID)) plugin.javelinIDs.Add(turret.net.ID); desGround = GetComponent<DestroyOnGroundMissing>(); if (!desGround) gameObject.AddComponent<DestroyOnGroundMissing>(); groundWatch = GetComponent<GroundWatch>(); if (!groundWatch) gameObject.AddComponent<GroundWatch>(); groundWatch.CancelInvoke("OnPhysicsNeighbourChanged"); groundWatch.InvokeRepeating("OnPhysicsNeighbourChanged", 0, 0.5f); SphereCollider collider = turret.gameObject.AddComponent<SphereCollider>(); collider.gameObject.layer = (int)Layer.Reserved1; collider.radius = aimRadius; collider.isTrigger = true; } private void Update() { if (externalTarget) { turret.SetTarget(externalTarget); turret.UpdateAiming(); } if (!turret.HasTarget()) { if (isLockedOn) isLockedOn = false; if (isLockingOn) isLockingOn = false; return; } if (!isLockedOn) { if (!isLockingOn) { lockonFinish = Time.time + lockonTime; isLockingOn = true; } else if (isLockingOn && Time.time > lockonFinish) LockToTarget(turret.target); else if (isLockingOn) { if (updateCounter == soundEveryxUpdates) { Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.unlock.prefab", turret.transform.position); updateCounter = 0; return; } updateCounter++; } } else { if (Time.time < nextShoot) return; if (Vector3.Distance(turret.muzzlePos.transform.position, turret.target.transform.position) < minHitDistance) return; var rocketItem = HasAmmo(); if (rocketItem == null) return; FireRocket(rocketItem); nextShoot = Time.time + fireRate; } } private void OnTriggerEnter(Collider col) { if (col.name != "assets/prefabs/npc/m2bradley/bradleyapc.prefab") return; turret.SetTarget(col.GetComponent<BaseCombatEntity>()); externalTarget = col.GetComponent<BaseCombatEntity>(); turret.UpdateAiming(); } private void OnTriggerExit(Collider col) { if (col.name != "assets/prefabs/npc/m2bradley/bradleyapc.prefab") return; turret.SetTarget(null); turret.TargetScan(); externalTarget = null; turret.UpdateAiming(); isLockedOn = false; isLockingOn = false; } private void OnDestroy() { if (!launcher_1.IsDestroyed) launcher_1.Kill(); if (!rocket_1.IsDestroyed) rocket_1.Kill(); if (!rocket_2.IsDestroyed) rocket_2.Kill(); } public void Destroy() { if (plugin.rocketTurrets.Contains(turret)) plugin.rocketTurrets.Remove(turret); if (plugin.turretIDs.Contains(turret.net.ID)) plugin.turretIDs.Remove(turret.net.ID); OnDestroy(); if (this) Destroy(this); } private void DestroyTurret() { if (turret != null) turret.Kill(BaseNetworkable.DestroyMode.Gib); } public void UnloadDestroy() { if (plugin.rocketTurrets.Contains(turret)) plugin.rocketTurrets.Remove(turret); OnDestroy(); Destroy(this); } private Item HasAmmo() { if (plugin.permission.UserHasPermission(turret.OwnerID.ToString(), permissionNameAMMOUNLIMITED)) return ItemManager.CreateByName("ammo.rocket.basic"); return !requiresAmmo ? ItemManager.CreateByName("ammo.rocket.basic") : turret.inventory.itemList.FirstOrDefault(item => item.info.itemid == -742865266 || item.info.itemid == 1638322904 || item.info.itemid == -1841918730); } private void LockToTarget(BaseCombatEntity entity) { isLockedOn = true; isLockingOn = false; nextShoot = Time.time + 0.3f; target = entity; } private void InitAesthetics() { launcher_1 = ItemManager.CreateByItemID(442886268, 1, rocketLauncherSkin).Drop(turret.transform.position, Vector3.zero).GetComponent<DroppedItem>(); launcher_1.GetComponent<Rigidbody>().isKinematic = true; launcher_1.GetComponent<Rigidbody>().useGravity = false; launcher_1.allowPickup = false; launcher_1.CancelInvoke((Action)Delegate.CreateDelegate(typeof(Action), launcher_1, "IdleDestroy")); rocket_1 = ItemManager.CreateByItemID(-742865266).Drop(turret.transform.position, Vector3.zero).GetComponent<DroppedItem>(); rocket_1.GetComponent<Rigidbody>().isKinematic = true; rocket_1.GetComponent<Rigidbody>().useGravity = false; rocket_1.allowPickup = false; rocket_1.CancelInvoke((Action)Delegate.CreateDelegate(typeof(Action), rocket_1, "IdleDestroy")); rocket_2 = ItemManager.CreateByItemID(-742865266).Drop(turret.transform.position, Vector3.zero).GetComponent<DroppedItem>(); rocket_2.GetComponent<Rigidbody>().isKinematic = true; rocket_2.GetComponent<Rigidbody>().useGravity = false; rocket_2.allowPickup = false; rocket_2.CancelInvoke((Action)Delegate.CreateDelegate(typeof(Action), rocket_2, "IdleDestroy")); var launcherRot = new Vector3(); var rocketRot = new Vector3(); foreach (var entry in turret.gameObject.transform.GetAllChildren()) { if (entry.name != "weapon_socket") continue; launcherRot = entry.gameObject.transform.localRotation.eulerAngles; launcherRot = new Vector3(launcherRot.x, launcherRot.y + 180, launcherRot.z); rocketRot = entry.gameObject.transform.localRotation.eulerAngles; rocketRot = new Vector3(rocketRot.x, rocketRot.y + 270, rocketRot.z); } launcher_1.SetParent(turret, "weapon_socket"); launcher_1.transform.localPosition = new Vector3(0, 0, 0); launcher_1.transform.localRotation = Quaternion.Euler(launcherRot); rocket_1.SetParent(turret, "weapon_socket"); rocket_1.transform.localPosition = new Vector3(0, -0.05f, 0.17f); rocket_1.transform.localRotation = Quaternion.Euler(rocketRot); rocket_2.SetParent(turret, "weapon_socket"); rocket_2.transform.localPosition = new Vector3(0, -0.05f, -0.17f); rocket_2.transform.localRotation = Quaternion.Euler(rocketRot); } public void TryFireRocket() { if (Time.time < nextShoot) return; var rocketItem = HasAmmo(); if (rocketItem == null) return; FireRocket(rocketItem); nextShoot = Time.time + fireRate; } private void FireRocket(Item rocketItem) { ServerProjectile rocket = CreateRocket(turret.muzzlePos.transform.position, rocketItem); if (rocket == null) return; TimedExplosive expl = rocket.gameObject.GetComponent<TimedExplosive>(); expl.explosionRadius = explosionRadius; rocket.gravityModifier = 0f; rocket.speed = rocketSpeed; rocket.InitializeVelocity(turret.muzzlePos.transform.forward); Effect.server.Run("assets/prefabs/npc/patrol helicopter/effects/rocket_fire.prefab", turret.muzzlePos.position); if (target) rocket.gameObject.AddComponent<JavelinMissile>().targetEntity = target; else { RaycastHit hit; if (!UnityEngine.Physics.Raycast(turret.muzzlePos.position, turret.aimDir, out hit, float.PositiveInfinity, LayerMask.GetMask("Terrain", "World"))) { rocket.gameObject.AddComponent<JavelinMissile>().targetPos = turret.aimDir; return; } rocket.gameObject.AddComponent<JavelinMissile>().targetPos = hit.point; } } private ServerProjectile CreateRocket(Vector3 launchPos, Item rocketItem) { if (requiresAmmo) { if (rocketItem == null) return null; if (rocketItem.amount == 1) rocketItem.RemoveFromContainer(); else rocketItem.UseItem(); } else rocketItem.RemoveFromContainer(); BaseEntity rocket; switch (rocketItem.info.shortname) { case "ammo.rocket.basic": rocket = GameManager.server.CreateEntity("assets/prefabs/ammo/rocket/rocket_basic.prefab", launchPos); break; case "ammo.rocket.fire": rocket = GameManager.server.CreateEntity("assets/prefabs/ammo/rocket/rocket_fire.prefab", launchPos); break; case "ammo.rocket.hv": rocket = GameManager.server.CreateEntity("assets/prefabs/ammo/rocket/rocket_hv.prefab", launchPos); break; default: return null; } if (rocket == null) return null; rocket.creatorEntity = turret; rocket.Spawn(); if (target) { rocket.transform.LookAt(target.transform); rocket.GetComponent<ServerProjectile>()?.InitializeVelocity(target.transform.position); } else { rocket.transform.LookAt(turret.aimDir); rocket.GetComponent<ServerProjectile>()?.InitializeVelocity(turret.aimDir); } return rocket.GetComponent<ServerProjectile>(); } } private class HeatRocket : MonoBehaviour { private ServerProjectile rocket; private BaseEntity trail; private TimedExplosive expl; public BaseCombatEntity target; private void Awake() { rocket = gameObject.GetComponent<ServerProjectile>(); expl = rocket.GetComponent<TimedExplosive>(); if (expl) expl.CancelInvoke("Explode"); expl.SetFuse(float.PositiveInfinity); if (plugin.aaCustomRocketTrail) { trail = GameManager.server.CreateEntity("assets/bundled/prefabs/oilfireballsmall.prefab"); trail.SetParent(rocket.GetComponent<BaseEntity>()); trail.Spawn(); trail.GetComponent<BoxCollider>().size = Vector3.zero; } } private void FixedUpdate() { if (target == null) return; Vector3 x = target.transform.position - rocket.transform.position; rocket.InitializeVelocity(x); if (Vector3.Distance(rocket.transform.position, target.transform.position) < 0.2f) expl.Explode(); } } private class JavelinMissile : MonoBehaviour { public BaseNetworkable targetEntity; private BaseEntity trail; public Vector3 targetPos; private ServerProjectile rocket; private TimedExplosive expl; private float verticality = plugin.jHeightBeforeCurve; private bool seekTarget = plugin.jSeekTarget; private Vector3 startPos; private Vector3 endPos; private Vector3 center; private Vector3 vertPos; private Vector3 lastPos; private Vector3 nextPos; private Vector3 cachedPosition; private float startTime; private float journeyTime; private float fracComplete; private bool start; private bool finishedVertical; private void Awake() { rocket = gameObject.GetComponent<ServerProjectile>(); rocket.gravityModifier = 0; expl = rocket.GetComponent<TimedExplosive>(); expl.SetFuse(float.PositiveInfinity); if (expl) expl.CancelInvoke("Explode"); vertPos = transform.position + new Vector3(0, verticality, 0); if (plugin.jCustomRocketTrail) { trail = GameManager.server.CreateEntity("assets/bundled/prefabs/oilfireballsmall.prefab"); trail.SetParent(rocket.GetComponent<BaseEntity>()); trail.Spawn(); trail.GetComponent<BoxCollider>().size = Vector3.zero; } } private void FixedUpdate() { if (!finishedVertical) { if (targetEntity) cachedPosition = targetEntity.transform.position; else if (targetPos != null) cachedPosition = targetPos; if (Vector3.Distance(rocket.transform.position, vertPos) < 2f) { startTime = Time.time; finishedVertical = true; return; } rocket.InitializeVelocity(vertPos - rocket.transform.position); return; } if (targetEntity && fracComplete > 1f && seekTarget) cachedPosition = targetEntity.transform.position; else if (targetPos != null && fracComplete > 1f && seekTarget) cachedPosition = targetPos; if (targetEntity == null) cachedPosition = endPos; if (start == false) { startPos = rocket.transform.position; endPos = cachedPosition + new Vector3(0, verticality, 0); center = (startPos + endPos) * 0.5f - new Vector3(0, 0.1f, 0); journeyTime = Vector3.Distance(startPos, endPos) / rocket.speed; lastPos = transform.position; start = true; } fracComplete = (Time.time - startTime) / journeyTime; if (fracComplete < 1.1f) { Vector3 launcherRelCenter = startPos - center; Vector3 targetRelCenter = endPos - center; lastPos = nextPos; nextPos = Vector3.Slerp(launcherRelCenter, targetRelCenter, fracComplete) + center; } else { lastPos = nextPos; nextPos = cachedPosition; } rocket.InitializeVelocity(nextPos - rocket.transform.position); /* foreach (BasePlayer player in BasePlayer.activePlayerList) { player.SendConsoleCommand("ddraw.sphere", 10f, Color.red, velocityPos, 0.05f); player.SendConsoleCommand("ddraw.line", 10f, Color.red, lastPos, nextPos, 1f); } */ if (targetEntity != null) { if (Vector3.Distance(transform.position, targetEntity.transform.position) < 0.1f) expl.Explode(); } else { if (Vector3.Distance(transform.position, endPos) < 0.1f) expl.Explode(); } } } private void Init() { plugin = this; permission.RegisterPermission(permissionName, this); permission.RegisterPermission(permissionNameROCKET, this); permission.RegisterPermission(permissionNameANTIAIR, this); permission.RegisterPermission(permissionNameJAVELIN, this); permission.RegisterPermission(permissionNameUNLIMITED, this); permission.RegisterPermission(permissionNameAMMOUNLIMITED, this); LoadVariables(); } private void Loaded() { lang.RegisterMessages(new Dictionary<string, string> { ["No Permission"] = "You are not allowed to use this command!", ["Invalid Destination"] = "Invalid turret found!", ["Not Authed On Turret"] = "You are not authed on this turret!", ["Already A Rocket Turret"] = "This turret is already a rocket turret", ["Already A Normal Turret"] = "This turret is already a normal turret", ["Invalid Entity"] = "No turret was found", ["Invalid Items"] = "You do not have the required items to upgrade this turret! (/turret cost)", ["Help Menu Header"] = "<color=#00CD66>Welcome to the help center, listed below are some helpful commands and what they do:</color>", ["Help Menu line1"] = "- <color=#008B45>/turret rocket</color> (upgrades the turret you are looking at to a turret that shoots rockets)", ["Help Menu line2"] = "- <color=#008B45>/turret normal</color> (returns an upgraded turret back to a normal turret)", ["Help Menu line3"] = "- <color=#008B45>/turret antiair</color> (upgrades the turret you are looking at to an anti air turret)", ["Help Menu line4"] = "- <color=#008B45>/turret javelin</color> (upgrades the turret you are looking at to a javelin turret", ["Help Menu line5"] = "- <color=#008B45>/turret cost</color> (displays the cost of upgrading to a rocket turret)", ["Cost Menu Header (rocket)"] = "You will need the following items to upgrade to a rocket turret:", ["Cost Menu Header (anti-air)"] = "You will need the following items to upgrade to an anti-air turret:", ["Cost Menu Header (javelin)"] = "You will need the following items to upgrade to a javelin turret", ["Cost Menu Entry"] = "- <color=#00CD66>{0}</color> x <color=#00CD66>{1}</color>", ["Max Turrets Allowed"] = "You already have the maximum number of this turret type that is allowed ({0})", ["Downgrade First"] = "You need to downgrade this turret before you change its type!", ["AntiAir Toggle Warning"] = "AntiAir turrets do not need to be turned on, they are always scanning!", }, this); data = Interface.Oxide.DataFileSystem.GetFile("RocketTurrets/TurretData"); data2 = Interface.Oxide.DataFileSystem.GetFile("RocketTurrets/PlayerData"); } private void Unload() { foreach (var entry in UnityEngine.Object.FindObjectsOfType<AutoTurret>()) { var rt = entry.GetComponent<RocketTurret>(); if (rt) rt.UnloadDestroy(); var at = entry.GetComponent<AntiAirTurret>(); if (at) at.UnloadDestroy(); var jt = entry.GetComponent<JavelinTurret>(); if (jt) jt.UnloadDestroy(); } SaveData(); } private void OnServerInitialized() { LoadData(); ServerMgr.Instance.StartCoroutine(InitTurrets()); } private IEnumerator InitTurrets() { foreach (var entry in UnityEngine.Object.FindObjectsOfType<AutoTurret>()) { if (turretIDs.Contains(entry.net.ID)) { var rt = entry.GetComponent<RocketTurret>(); if (rt) rt.Destroy(); entry.gameObject.AddComponent<RocketTurret>(); rocketTurrets.Add(entry); yield return new WaitForSeconds(0.1f); } else if (antiAirIDs.Contains(entry.net.ID)) { var at = entry.GetComponent<AntiAirTurret>(); if (at) at.Destroy(); entry.gameObject.AddComponent<AntiAirTurret>(); antiairTurrets.Add(entry); yield return new WaitForSeconds(0.1f); } else if (javelinIDs.Contains(entry.net.ID)) { var jt = entry.GetComponent<JavelinTurret>(); if (jt) jt.Destroy(); entry.gameObject.AddComponent<JavelinTurret>(); javelinTurrets.Add(entry); yield return new WaitForSeconds(0.1f); } } } private void OnLootEntity(BasePlayer player, BaseEntity entity) { if (!aaRequireBuildingRightsToAccessInventory) return; if (!(entity is AutoTurret)) return; AutoTurret aa = (AutoTurret)entity; if (!antiairTurrets.Contains(aa)) return; if (!player.CanBuild()) NextTick(player.EndLooting); } private object OnTurretStartup(AutoTurret turret) { if (!antiairTurrets.Contains(turret)) return null; Collider[] x = Physics.OverlapSphere(turret.transform.position, 3f); foreach (Collider entry in x) { if (entry.GetComponent<BasePlayer>() == null) continue; BasePlayer player = entry.GetComponent<BasePlayer>(); player.ChatMessage(msg("AntiAir Toggle Warning", player.UserIDString)); } return false; } private object CanAcceptItem(ItemContainer container, Item item) { BaseEntity entity = container.entityOwner; if (entity == null) return null; if (entity.ShortPrefabName != "autoturret_deployed") return null; RocketTurret rt = entity.GetComponent<RocketTurret>(); AntiAirTurret at = entity.GetComponent<AntiAirTurret>(); if (rt != null) { if (item.info.shortname != "ammo.rocket.basic" && item.info.shortname != "ammo.rocket.fire" && item.info.shortname != "ammo.rocket.hv") return ItemContainer.CanAcceptResult.CannotAcceptRightNow; return null; } if (at == null) return null; if (container.entityOwner.GetComponent<LootContainer>() == null && item.info.shortname != "ammo.rocket.basic" && item.info.shortname != "ammo.rocket.fire" && item.info.shortname != "ammo.rocket.hv") return ItemContainer.CanAcceptResult.CannotAcceptRightNow; return null; } private void CanPickupEntity(BaseCombatEntity entity, BasePlayer player) { if (!returnCostOnPickup) return; AutoTurret turret = entity.GetComponent<AutoTurret>(); if (!turret) return; RocketTurret rt = turret.GetComponent<RocketTurret>(); AntiAirTurret at = turret.GetComponent<AntiAirTurret>(); if (rt != null) ReturnItems(entity.transform.position + new Vector3(0, 0.5f, 0), rocketUpgradeCost); else if (at != null) ReturnItems(entity.transform.position + new Vector3(0, 0.5f, 0), antiAirUpgradeCost); } private void OnEntityKill(BaseNetworkable entity) { AutoTurret turret = entity?.GetComponent<AutoTurret>(); if (!turret) return; RocketTurret rt = turret.GetComponent<RocketTurret>(); AntiAirTurret at = turret.GetComponent<AntiAirTurret>(); JavelinTurret jt = turret.GetComponent<JavelinTurret>(); if (!rt && !at && !jt) return; if (rt) { if (turretNumbers.ContainsKey(turret.OwnerID.ToString())) turretNumbers[turret.OwnerID.ToString()].RocketTurrets--; rocketTurrets.Remove(turret); } else if (at) { if (turretNumbers.ContainsKey(turret.OwnerID.ToString())) turretNumbers[turret.OwnerID.ToString()].AntiAirTurrets--; antiairTurrets.Remove(turret); } if (jt) { if (turretNumbers.ContainsKey(turret.OwnerID.ToString())) turretNumbers[turret.OwnerID.ToString()].JavelinTurrets--; javelinTurrets.Remove(turret); } turretIDs.Remove(turret.net.ID); } [ChatCommand("turret")] private void RocketTurretCMD(BasePlayer player, string command, string[] args) { if (!permission.UserHasPermission(player.UserIDString, permissionName)) { player.ChatMessage(msg("No Permission", player.UserIDString)); return; } if (!turretNumbers.ContainsKey(player.UserIDString)) turretNumbers.Add(player.UserIDString, new PlayerData { AntiAirTurrets = 0, RocketTurrets = 0, JavelinTurrets = 0 }); if (args.Length == 0) { DoHelpMenu(player); return; } if (args.Length != 1) return; switch (args[0]) { case "cost": DoItemMenu(player); return; case "help": DoHelpMenu(player); return; case "rocket": { RaycastHit hit; if (!Physics.Raycast(player.eyes.HeadRay(), out hit, Mathf.Infinity, collLayers)) { player.ChatMessage(msg("Invalid Destination", player.UserIDString)); return; } BaseEntity entity = hit.GetEntity(); if (entity == null) { player.ChatMessage(msg("Invalid Destination", player.UserIDString)); return; } if (entity.ShortPrefabName != "autoturret_deployed") { player.ChatMessage(msg("Invalid Entity", player.UserIDString)); return; } AutoTurret turret = entity.GetComponent<AutoTurret>(); if (!turret) { PrintError("Turret component was null!"); return; } if (!turret.IsAuthed(player)) { player.ChatMessage(msg("Not Authed On Turret", player.UserIDString)); return; } if (!permission.UserHasPermission(player.UserIDString, permissionNameROCKET)) { player.ChatMessage(msg("No Permission", player.UserIDString)); return; } AntiAirTurret at = turret.GetComponent<AntiAirTurret>(); JavelinTurret jt = turret.GetComponent<JavelinTurret>(); if (at || jt) { player.ChatMessage(msg("Downgrade First", player.UserIDString)); return; } if (turretNumbers[player.UserIDString].RocketTurrets >= maxNumberAllowed) { player.ChatMessage(string.Format(msg("Max Turrets Allowed", player.UserIDString), maxNumberAllowed)); return; } if (rocketTurrets.Contains(turret)) { player.ChatMessage(msg("Already A Rocket Turret")); return; } if (!CanUpgade(player.inventory.containerMain, player.inventory.containerBelt, "rocket")) { player.ChatMessage(msg("Invalid Items", player.UserIDString)); return; } rocketTurrets.Add(turret); turret.gameObject.AddComponent<RocketTurret>(); NextTick(() => Oxide.Core.Interface.CallHook("OnRocketTurretCreated", turret)); Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.updated.prefab", turret.transform.position); DropAmmo(turret); turret.inventory.onlyAllowedItem = null; if (!permission.UserHasPermission(player.UserIDString, permissionNameUNLIMITED)) turretNumbers[player.UserIDString].RocketTurrets++; break; } case "normal": { RaycastHit hit; if (!Physics.Raycast(player.eyes.HeadRay(), out hit, Mathf.Infinity, collLayers)) { player.ChatMessage(msg("Invalid Destination", player.UserIDString)); return; } BaseEntity entity = hit.GetEntity(); if (entity == null) { player.ChatMessage(msg("Invalid Destination", player.UserIDString)); return; } if (entity.ShortPrefabName != "autoturret_deployed") { player.ChatMessage(msg("Invalid Entity", player.UserIDString)); return; } AutoTurret turret = entity.GetComponent<AutoTurret>(); if (!rocketTurrets.Contains(turret) && !antiairTurrets.Contains(turret) && !javelinTurrets.Contains(turret)) { player.ChatMessage(msg("Already A Normal Turret", player.UserIDString)); return; } RocketTurret rt = turret.gameObject.GetComponent<RocketTurret>(); AntiAirTurret at = turret.gameObject.GetComponent<AntiAirTurret>(); JavelinTurret jt = turret.gameObject.GetComponent<JavelinTurret>(); Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.updated.prefab", turret.transform.position); if (returnCostOnDowngrade) { if (rt != null) ReturnItems(entity.transform.position + new Vector3(0, 1, 0), rocketUpgradeCost); else if (at != null) ReturnItems(entity.transform.position + new Vector3(0, 1, 0), antiAirUpgradeCost); else if (jt != null) ReturnItems(entity.transform.position + new Vector3(0, 1, 0), javelinUpgradeCost); } DropAmmo(turret); turret.inventory.onlyAllowedItem = ItemManager.FindItemDefinition("ammo.rifle"); if (!permission.UserHasPermission(player.UserIDString, permissionNameUNLIMITED)) { if (rt) { turretNumbers[turret.OwnerID.ToString()].RocketTurrets--; rt.Destroy(); } if (at) { turretNumbers[turret.OwnerID.ToString()].AntiAirTurrets--; at.Destroy(); } if (jt) { turretNumbers[turret.OwnerID.ToString()].JavelinTurrets--; jt.Destroy(); } } if (rocketTurrets.Contains(turret)) rocketTurrets.Remove(turret); else if (antiairTurrets.Contains(turret)) antiairTurrets.Remove(turret); else if (javelinTurrets.Contains(turret)) javelinTurrets.Remove(turret); NextTick(() => Oxide.Core.Interface.CallHook("OnRocketTurretCreated", turret)); break; } case "antiair": { RaycastHit hit; if (!Physics.Raycast(player.eyes.HeadRay(), out hit, Mathf.Infinity, collLayers)) { player.ChatMessage(msg("Invalid Destination", player.UserIDString)); return; } BaseEntity entity = hit.GetEntity(); if (entity == null) { player.ChatMessage(msg("Invalid Entity", player.UserIDString)); return; } if (entity.ShortPrefabName != "autoturret_deployed") { player.ChatMessage(msg("Invalid Entity", player.UserIDString)); return; } AutoTurret turret = entity.GetComponent<AutoTurret>(); if (!turret) { PrintError("Turret component was null!"); return; } if (!turret.IsAuthed(player)) { player.ChatMessage(msg("Not Authed On Turret", player.UserIDString)); return; } if (!permission.UserHasPermission(player.UserIDString, permissionNameANTIAIR)) { player.ChatMessage(msg("No Permission", player.UserIDString)); return; } RocketTurret rt = turret.GetComponent<RocketTurret>(); JavelinTurret jt = turret.GetComponent<JavelinTurret>(); if (rt || jt) { player.ChatMessage(msg("Downgrade First", player.UserIDString)); return; } if (turretNumbers[player.UserIDString].AntiAirTurrets >= aaMaxNumberAllowed) { player.ChatMessage(string.Format(msg("Max Turrets Allowed", player.UserIDString), aaMaxNumberAllowed)); return; } if (antiairTurrets.Contains(turret)) { player.ChatMessage(msg("Already an anti-air turret", player.UserIDString)); return; } if (!CanUpgade(player.inventory.containerMain, player.inventory.containerBelt, "antiair")) { player.ChatMessage(msg("Invalid Items", player.UserIDString)); return; } DropAmmo(turret); antiairTurrets.Add(turret); turret.gameObject.AddComponent<AntiAirTurret>(); NextTick(() => Oxide.Core.Interface.CallHook("OnRocketTurretCreated", turret)); Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.updated.prefab", turret.transform.position); turret.inventory.onlyAllowedItem = null; if (!permission.UserHasPermission(player.UserIDString, permissionNameUNLIMITED)) turretNumbers[player.UserIDString].AntiAirTurrets++; break; } case "javelin": { RaycastHit hit; if (!Physics.Raycast(player.eyes.HeadRay(), out hit, Mathf.Infinity, collLayers)) { player.ChatMessage(msg("Invalid Destination", player.UserIDString)); return; } BaseEntity entity = hit.GetEntity(); if (entity == null) { player.ChatMessage(msg("Invalid Destination", player.UserIDString)); return; } if (entity.ShortPrefabName != "autoturret_deployed") { player.ChatMessage(msg("Invalid Entity", player.UserIDString)); return; } AutoTurret turret = entity.GetComponent<AutoTurret>(); if (!turret) { PrintError("Turret component was null!"); return; } if (!turret.IsAuthed(player)) { player.ChatMessage(msg("Not Authed On Turret", player.UserIDString)); return; } if (!permission.UserHasPermission(player.UserIDString, permissionNameJAVELIN)) { player.ChatMessage(msg("No Permission", player.UserIDString)); return; } AntiAirTurret at = turret.GetComponent<AntiAirTurret>(); RocketTurret rt = turret.GetComponent<RocketTurret>(); if (at || rt) { player.ChatMessage(msg("Downgrade First", player.UserIDString)); return; } if (turretNumbers[player.UserIDString].JavelinTurrets >= jmaxNumberAllowed) { player.ChatMessage(string.Format(msg("Max Turrets Allowed", player.UserIDString), jmaxNumberAllowed)); return; } if (javelinTurrets.Contains(turret)) { player.ChatMessage(msg("Already A Rocket Turret")); return; } if (!CanUpgade(player.inventory.containerMain, player.inventory.containerBelt, "javelin")) { player.ChatMessage(msg("Invalid Items", player.UserIDString)); return; } javelinTurrets.Add(turret); turret.gameObject.AddComponent<JavelinTurret>(); NextTick(() => Oxide.Core.Interface.CallHook("OnRocketTurretCreated", turret)); Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.updated.prefab", turret.transform.position); DropAmmo(turret); turret.inventory.onlyAllowedItem = null; if (!permission.UserHasPermission(player.UserIDString, permissionNameUNLIMITED)) turretNumbers[player.UserIDString].JavelinTurrets++; return; } } } private static void ReturnItems(Vector3 dropPos, Dictionary<string, object> dic) { foreach (var _entry in dic) ItemManager.CreateByName(_entry.Key, (int)_entry.Value).Drop(dropPos, Vector3.zero, UnityEngine.Random.rotation); } private static void DropAmmo(AutoTurret turret) { List<Item> items = turret.inventory.itemList.ToList(); foreach (var entry in items) entry?.Drop(turret.transform.position + new Vector3(0f, 1f, 0f), Vector3.zero); } private void DoHelpMenu(BasePlayer player) { StringBuilder x = new StringBuilder(); x.AppendLine(msg("Help Menu Header", player.UserIDString)); if (permission.UserHasPermission(player.UserIDString, permissionName)) x.AppendLine(msg("Help Menu line1", player.UserIDString)); x.AppendLine(msg("Help Menu line2", player.UserIDString)); if (permission.UserHasPermission(player.UserIDString, permissionNameANTIAIR)) x.AppendLine(msg("Help Menu line3", player.UserIDString)); if (permission.UserHasPermission(player.UserIDString, permissionNameJAVELIN)) x.AppendLine(msg("Help Menu line4", player.UserIDString)); x.AppendLine(msg("Help Menu line5", player.UserIDString)); player.ChatMessage(x.ToString().TrimEnd()); } private void DoItemMenu(BasePlayer player) { StringBuilder x = new StringBuilder(); if (permission.UserHasPermission(player.UserIDString, permissionName)) { x.AppendLine(msg("Cost Menu Header (rocket)", player.UserIDString)); foreach (var entry in rocketUpgradeCost) { foreach (ItemDefinition item in ItemManager.itemList) if (item.shortname == entry.Key) x.AppendLine(string.Format(msg("Cost Menu Entry", player.UserIDString), item.displayName.english, entry.Value)); } x.AppendLine(); } if (permission.UserHasPermission(player.UserIDString, permissionNameANTIAIR)) { x.AppendLine(msg("Cost Menu Header (anti-air)", player.UserIDString)); foreach (var entry in antiAirUpgradeCost) { foreach (ItemDefinition item in ItemManager.itemList) if (item.shortname == entry.Key) x.AppendLine(string.Format(msg("Cost Menu Entry", player.UserIDString), item.displayName.english, entry.Value)); } x.AppendLine(); } if (permission.UserHasPermission(player.UserIDString, permissionNameJAVELIN)) { x.AppendLine(msg("Cost Menu Header (javelin)", player.UserIDString)); foreach (var entry in javelinUpgradeCost) { foreach (ItemDefinition item in ItemManager.itemList) if (item.shortname == entry.Key) x.AppendLine(string.Format(msg("Cost Menu Entry", player.UserIDString), item.displayName.english, entry.Value)); } } player.ChatMessage(x.ToString().TrimEnd()); } private bool CanUpgade(ItemContainer container, ItemContainer container2, string type) { Dictionary<string, int> itemsNeeded = new Dictionary<string, int>(); Dictionary<Item, int> cache = new Dictionary<Item, int>(); switch (type) { case "rocket": foreach (var entry in rocketUpgradeCost) itemsNeeded.Add(entry.Key, Convert.ToInt32(entry.Value)); break; case "antiair": foreach (var entry in antiAirUpgradeCost) itemsNeeded.Add(entry.Key, Convert.ToInt32(entry.Value)); break; case "javelin": foreach (var entry in javelinUpgradeCost) itemsNeeded.Add(entry.Key, Convert.ToInt32(entry.Value)); break; } foreach (Item item in container.itemList) if (itemsNeeded.ContainsKey(item.info.shortname)) if (itemsNeeded[item.info.shortname] > 0) { if (item.amount < itemsNeeded[item.info.shortname]) { cache.Add(item, item.amount); itemsNeeded[item.info.shortname] -= item.amount; } else if (item.amount > itemsNeeded[item.info.shortname]) { cache.Add(item, itemsNeeded[item.info.shortname]); itemsNeeded[item.info.shortname] = 0; } else { cache.Add(item, item.amount); itemsNeeded[item.info.shortname] = 0; } } foreach (Item item in container2.itemList) if (itemsNeeded.ContainsKey(item.info.shortname)) if (itemsNeeded[item.info.shortname] > 0) { if (item.amount < itemsNeeded[item.info.shortname]) { cache.Add(item, item.amount); itemsNeeded[item.info.shortname] -= item.amount; } else if (item.amount > itemsNeeded[item.info.shortname]) { cache.Add(item, itemsNeeded[item.info.shortname]); itemsNeeded[item.info.shortname] = 0; } else { cache.Add(item, item.amount); itemsNeeded[item.info.shortname] = 0; } } if (itemsNeeded.Any(entry => entry.Value > 0)) return false; RemoveItems(cache); return true; } private static void RemoveItems(Dictionary<Item, int> dic) { foreach (var entry in dic) { if (entry.Key.amount == entry.Value) entry.Key.RemoveFromContainer(); else entry.Key.UseItem(entry.Value); } } private object GetConfig(string menu, string datavalue, object defaultValue) { var data = Config[menu] as Dictionary<string, object>; if (data == null) { data = new Dictionary<string, object>(); Config[menu] = data; changed = true; } object value; if (data.TryGetValue(datavalue, out value)) return value; value = defaultValue; data[datavalue] = value; changed = true; return value; } private string msg(string key, string id = null) => lang.GetMessage(key, this, id); } } 
// If you wish to view this code in a formatted state, please contact redBDGR on discord @ redBDGR #0001


// --- End of file: RocketTurrets.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ShipControl.cs ---
// --- Original Local Path: ShipControl.cs ---

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("ShipControl", "Hougan", "0.0.2")]
    public class ShipControl : RustPlugin
    {
        #region Classes

        private class AdditionalContainer
        {
            [JsonProperty("Отображаемое имя")]
            public string DisplayName;
            [JsonProperty("Название префаба")]
            public string PrefabName;

            [JsonProperty("Локальная позиция")]
            public string LocalPosition;
            [JsonProperty("Возможные предметы")]
            public List<Dictionary<string, int>> RandomItems = new List<Dictionary<string, int>>();
        }

        private class Configuration
        {
            [JsonProperty("Отключить появление корабля на совсем")]
            public bool DisableEvent = false;

            [JsonProperty("Время плавания корабля")]
            public float ActiveTime = 40f;
            [JsonProperty("Время уплывания корабля")]
            public float DeActivateTime = 10f;

            [JsonProperty("Оповещение о прибытии корабля")]
            public string SpawnedAlert = "К берегу приблежается грузовой корабль!";
            
            [JsonProperty("Отключить появление лодки на борту")]
            public bool DisableRHIB = true;
            [JsonProperty("Изменить количество топлива в лодке на борту")]
            public int RHIB_Fuel = 150;

            [JsonProperty("Отключить появление стандартных контейнеров")]
            public bool DisableDefaultContainers = true;
            
            [JsonProperty("Дополнительные ящики с предметами")]
            public List<AdditionalContainer> CustomContainers = new List<AdditionalContainer>();

            public static Configuration GetNewConf()
            {
                return new Configuration();
            }
        }

        #endregion
        
        #region Variables

        public bool EventEnabled = false;
        public float EventDuration = 40f;
        public float EgressDuration = 10f;


        public float currentRadition;

        private List<AdditionalContainer> PossibleContainers = new List<AdditionalContainer>
        {
            new AdditionalContainer
            {
                PrefabName = "assets/bundled/prefabs/radtown/crate_elite.prefab",
                DisplayName = "Элитный ящик",
                
                LocalPosition = ""
            },
            new AdditionalContainer
            {
                PrefabName = "assets/bundled/prefabs/radtown/crate_normal.prefab",
                DisplayName = "Оружейный ящик",
                
                LocalPosition = ""
            },
            new AdditionalContainer
            {
                PrefabName = "assets/bundled/prefabs/radtown/crate_normal_2.prefab",
                DisplayName = "Обычный ящик",
                
                LocalPosition = ""
            },
            new AdditionalContainer
            {
                PrefabName = "assets/prefabs/deployable/chinooklockedcrate/codelockedhackablecrate.prefab",
                DisplayName = "Закрытый ящик",
                
                LocalPosition = ""
            }
        };

        private static Configuration config;


        #endregion

        #region Initialization

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config?.CustomContainers == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Ошибка чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }
            
            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConf();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion
        


        [ChatCommand("add.crate")]
        private void cmdChatAdmin(BasePlayer player)
        {
            if (!player.IsAdmin)
                return;
            
            RaycastHit hitInfo;
            if (!Physics.Raycast(player.transform.position, Vector3.down, out hitInfo) || !(hitInfo.GetEntity() is CargoShip))
            {
                player.ChatMessage("Вы находитесь не на корабле!");
                return;
            }

            UI_DrawChooseType(player);
        }

        [ConsoleCommand("UI_SC")]
        private void cmdConsoleHandler(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (player != null && args.HasArgs(2))
            {
                RaycastHit hitInfo;
                if (!Physics.Raycast(player.transform.position, Vector3.down, out hitInfo) || !(hitInfo.GetEntity() is CargoShip))
                {
                    player.ChatMessage("Вы находитесь не на корабле!");
                    return;
                }
                CargoShip cargoShip = hitInfo.GetEntity() as CargoShip;
                
                switch (args.Args[0].ToLower())
                {
                    case "addcrate":
                    {
                        AdditionalContainer newContainer = PossibleContainers.Find(p => p.PrefabName == args.Args[1]);
                        if (newContainer != null)
                        {
                            config.CustomContainers.Add(new AdditionalContainer
                            {
                                DisplayName = newContainer.DisplayName,
                                PrefabName = newContainer.PrefabName,
                                LocalPosition = cargoShip.transform.InverseTransformPoint(player.transform.position).ToString(),
                                RandomItems = new List<Dictionary<string, int>>
                                {
                                    new Dictionary<string, int>
                                    {
                                        ["rifle.ak"] = 1
                                    }
                                }
                            });

                            SpawnCustomContainer(config.CustomContainers.Last(), cargoShip);
                            
                            player.ChatMessage($"Вы успешно добавили {newContainer.DisplayName}, не забудьте настроить выпадающий лут!");
                            CuiHelper.DestroyUi(player, Layer);
                            SaveConfig();
                        }
                        break;
                    }
                }
            }
        }


        #region Interface

        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }
        
        
        private const string Layer = "UI_SC";

        private void UI_DrawChooseType(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, Layer);
            CuiElementContainer container = new CuiElementContainer();
            
            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0" }
            }, "Overlay", Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "-10000 -10000", OffsetMax = "10000 10000" },
                Button = { Color = "0 0 0 0", Close = Layer },
                Text = { Text = "" }
            }, Layer);

            var topPosition = 0.5f + (double) PossibleContainers.Count / 2 * 40 + (double) (PossibleContainers.Count - 1) / 2 * 5;
            foreach (var check in PossibleContainers)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = $"-300 {topPosition - 40}", OffsetMax = $"300 {topPosition}" },
                    Button = { Color = HexToRustFormat("#7C7D7A51"), Command = $"UI_SC AddCrate {check.PrefabName}" },
                    Text = { Text = check.DisplayName, Align = TextAnchor.MiddleCenter, FontSize = 20, Font = "robotocondensed-bold.ttf" }
                }, Layer);

                topPosition -= 40;
                topPosition -= 5;
            }

            CuiHelper.AddUi(player, container);
        }

        #endregion
        
        private void OnServerInitialized()
        {
            if (EventEnabled)
            {
                Server.Command($"cargoship.event_duration_minutes {config.ActiveTime}");
                Server.Command($"cargoship.egress_duration_minute {config.DeActivateTime}");
            }
        }

        private void OnEntitySpawned(BaseNetworkable entity)
        {
            if (entity is CargoShip)
            {
                if (config.DisableEvent)
                {
                    entity.Kill();
                    return;
                }

                if (config.SpawnedAlert != "")
                {
                    Server.Broadcast(config.SpawnedAlert);
                }
                
                var cargoShip = entity as CargoShip;
                var cargoRhib = cargoShip.children.Find(p => p is RHIB) as RHIB;

                if (config.DisableDefaultContainers)
                {
                    var containerList = cargoShip.children.Where(p => p is StorageContainer).ToArray();
                    foreach (var check in containerList)
                    {
                        check.Kill();
                    }
                }
                
                if (config.CustomContainers.Count > 0)
                {
                    timer.Once(120, () =>
                    {
                        if (cargoShip != null)
                        {
                            foreach (var check in config.CustomContainers)
                            {
                                SpawnCustomContainer(check, cargoShip);
                            }
                        }
                    });
                }

                if (config.DisableRHIB && cargoRhib != null)
                {
                    cargoRhib.Kill();
                }
                else if (cargoRhib != null)
                {
                    BaseEntity baseEntity = cargoRhib.fuelStorageInstance.Get(true);
                    if (!(bool) ((UnityEngine.Object) baseEntity))
                        return;
                    
                    baseEntity.GetComponent<StorageContainer>().inventory.Clear();
                    NextTick(() =>
                    {
                        baseEntity.GetComponent<StorageContainer>().inventory.AddItem(ItemManager.FindItemDefinition("lowgradefuel"), config.RHIB_Fuel);
                    });
                }
            }
        }

        private void SpawnCustomContainer(AdditionalContainer customContainer, CargoShip ship)
        {
            Vector3 position = customContainer.LocalPosition.ToVector3() + ship.transform.position;
            Quaternion rotation = default(Quaternion);
            BaseEntity entity = GameManager.server.CreateEntity(customContainer.PrefabName, position, rotation, true);
            if ((bool) ((UnityEngine.Object) entity))
            {
                entity.enableSaving = false;
                entity.SendMessage("SetWasDropped");
                entity.Spawn();
                entity.SetParent((BaseEntity) ship, true, false);
                
                if (entity.GetComponent<Rigidbody>() != null)
                    entity.GetComponent<Rigidbody>().isKinematic = true;

                var itemContainer = entity.GetComponent<StorageContainer>();
                if (customContainer.RandomItems.Count > 0)
                {
                    itemContainer.inventory.Clear();
                    foreach (var check in customContainer.RandomItems.GetRandom())
                    {
                        Item x = ItemManager.CreateByPartialName(check.Key, check.Value);
                        x.MoveToContainer(itemContainer.inventory);
                    }
                }
            }
        }
        
    }
}

// --- End of file: ShipControl.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NoDurability.cs ---
// --- Original Local Path: NoDurability.cs ---

using System;

namespace Oxide.Plugins
{
    [Info("NoDurability", "Wulf/lukespragg", "2.0.0", ResourceId = 1061)]
    public class NoDurability : CovalencePlugin
    {
        #region Initialization

        void Loaded()
        {
            #if !RUST
            throw new NotSupportedException($"This plugin does not support {(covalence.Game ?? "this game")}");
            #endif

            permission.RegisterPermission("nodurability.allowed", this);
        }

        #endregion

        #region Durability Control

        #if RUST
        void OnLoseCondition(Item item, ref float amount)
        {
            var player = item?.GetOwnerPlayer();
            if (player == null) return;

            if (HasPermission(player.UserIDString, "nodurability.allowed")) item.condition = item.maxCondition;

            //Puts($"{item.info.shortname} was damaged by: {amount} | Condition is: {item.condition}/{item.maxCondition}");
        }
        #endif

        #endregion

        #region Helper Methods

        bool HasPermission(string steamId, string perm) => permission.UserHasPermission(steamId, perm);

        #endregion
    }
}


// --- End of file: NoDurability.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/XAntiCheat.cs ---
// --- Original Local Path: XAntiCheat.cs ---

﻿using System;
using System.Collections.Generic;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using System.Linq;
using UnityEngine;
using Oxide.Core;
using Random = UnityEngine.Random;
using Rust;
using ProtoBuf;
using System.Collections;
using System.Text.RegularExpressions;
using Oxide.Core.Libraries;

namespace Oxide.Plugins
{
    [Info("XAntiCheat", "123", "2.0.2")]
    public class XAntiCheat : RustPlugin
    {
        static XAntiCheat fermens;
        const bool fermensEN = false;

        const bool debugmode = false;
        const string ipinnfourl = "https://ipinfo.io/{ip}/privacy?token={token}";
        const bool enablefull = true;
        const string ipinfosingup = "https://ipinfo.io/signup";

        #region message
        Dictionary<string, string> messages = new Dictionary<string, string>();
        private string GetMessage(string key, string userId)
        {
            return lang.GetMessage(key, this, userId);
        }
        #endregion

        #region CODE LOCK
        private static bool IsBanned(ulong userid)
        {
            return ServerUsers.Is(userid, ServerUsers.UserGroup.Banned);
        }

        private static bool IsImprisoned(ulong userid)
        {
            if (fermens.PrisonBitch == null) return false;
            return fermens.PrisonBitch.Call<bool>("ISIMPRISONED", userid);
        }

        private void OnCodeEntered(CodeLock codeLock, BasePlayer player, string code)
        {
            if (player == null) return;
            ulong owner = codeLock.OwnerID;
            if (owner == 0UL || code != codeLock.code) return;
            if (!codeLock.IsLocked())
            {
                codeLock.OwnerID = player.userID;
                return;
            }
            bool bann = IsBanned(owner);
            bool unprisoned = IsImprisoned(owner);

            if (bann || unprisoned)
            {
                ADDLOG("CODELOCK", messages["logCODELOCK"].Replace("{name}", player.displayName).Replace("{steamid}", player.UserIDString).Replace("{owner}", owner.ToString()), config.cODELOCK.webhook, 2);
                if (config.cODELOCK.enable)
                {
                    timer.Once(config.cODELOCK.seconds, () =>
                    {
                        BAN(player.UserIDString, config.cODELOCK.reason, config.cODELOCK.hours, player.displayName, config.cODELOCK.webhook);
                    });
                }
            }

        }

        object CanChangeCode(BasePlayer player, CodeLock codeLock, string newCode, bool isGuestCode)
        {
            codeLock.OwnerID = player.userID;
            return null;
        }
        #endregion

        #region КОНФИГ
        private static PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        class SILENT
        {
            [JsonProperty(fermensEN ? "Enable autoban?" : "Банить?")]
            public bool enable;

            [JsonProperty(fermensEN ? "Number of detections for a ban" : "Автобан (не знаешь, не трогай!)")]
            public int xdetects;

            [JsonProperty(fermensEN ? "Ban reason" : "Причина бана")]
            public string reason;

            [JsonProperty("Discord Webhook")]
            public string webhook;

            [JsonProperty(fermensEN ? "How many hours to ban?" : "На сколько часов бан?")]
            public int hours;
        }

        class SPIDER
        {
            [JsonProperty(fermensEN ? "Enable autoban?" : "Банить?")]
            public bool enable;

            [JsonProperty(fermensEN ? "Ban reason" : "Причина бана")]
            public string reason;

            [JsonProperty("Discord Webhook")]
            public string webhook;

            [JsonProperty(fermensEN ? "How many hours to ban?" : "На сколько часов бан?")]
            public int hours;
        }

        class FLY
        {
            [JsonProperty(fermensEN ? "Enable autoban?" : "Банить?")]
            public bool enable;

            [JsonProperty(fermensEN ? "Ban reason" : "Причина бана")]
            public string reason;

            [JsonProperty("Discord Webhook")]
            public string webhook;

            [JsonProperty(fermensEN ? "How many hours to ban?" : "На сколько часов бан?")]
            public int hours;
        }

        class SPINERBOT
        {
            [JsonProperty(fermensEN ? "Enable autoban?" : "Банить?")]
            public bool enable;

            [JsonProperty(fermensEN ? "Ban reason" : "Причина бана")]
            public string reason;

            [JsonProperty("Discord Webhook")]
            public string webhook;

            [JsonProperty(fermensEN ? "How many hours to ban?" : "На сколько часов бан?")]
            public int hours;
        }

        class NORECOIL
        {
            [JsonProperty(fermensEN ? "Enable autoban?" : "Банить?")]
            public bool enable;

            [JsonProperty(fermensEN ? "Ban reason" : "Причина бана")]
            public string reason;

            [JsonProperty(fermensEN ? "Delay in seconds before the ban" : "Задержка в секундах перед баном, после детекта")]
            public float seconds;

            [JsonProperty("Discord Webhook")]
            public string webhook;

            [JsonProperty(fermensEN ? "How many hours to ban?" : "На сколько часов бан?")]
            public int hours;
        }

        class HITMOD
        {
            [JsonProperty(fermensEN ? "Enable autoban?" : "Банить?")]
            public bool enable;

            [JsonProperty(fermensEN ? "Ban reason" : "Причина бана")]
            public string reason;

            [JsonProperty("Discord Webhook")]
            public string webhook;

            [JsonProperty(fermensEN ? "How many hours to ban?" : "На сколько часов бан?")]
            public int hours;
        }

        class CODELOCK
        {
            [JsonProperty(fermensEN ? "Enable autoban?" : "Банить?")]
            public bool enable;

            [JsonProperty(fermensEN ? "Ban reason" : "Причина бана")]
            public string reason;

            [JsonProperty("Discord Webhook")]
            public string webhook;

            [JsonProperty(fermensEN ? "Delay in seconds before the ban" : "Задержка в секундах перед баном, после детекта")]
            public float seconds;

            [JsonProperty(fermensEN ? "How many hours to ban?" : "На сколько часов бан?")]
            public int hours;
        }

        class TEAMBAN
        {
            [JsonProperty(fermensEN ? "Enable autoban?" : "Банить?")]
            public bool enable;

            [JsonProperty(fermensEN ? "Ban reason" : "Причина бана")]
            public string reason;

            [JsonProperty("Discord Webhook")]
            public string webhook;

            [JsonProperty(fermensEN ? "Ban if there are N bans in the team" : "Банить, если в команде N забаненных")]
            public int num;

            [JsonProperty(fermensEN ? "How many hours to ban?" : "На сколько часов бан?")]
            public int hours;
        }

        class ESPSTASH
        {
            [JsonProperty(fermensEN ? "Number of stashs" : "Количество")]
            public int amount;

            [JsonProperty("Discord Webhook")]
            public string webhook;

            [JsonProperty(fermensEN ? "Possible loot" : "Возможный лут")]
            public Dictionary<string, int> loots;
        }

        class DEBUGCAMERA
        {
            [JsonProperty(fermensEN ? "Enable autoban?" : "Банить?")]
            public bool enable;

            [JsonProperty("Discord Webhook")]
            public string webhook;
        }

        private class PluginConfig
        {
            [JsonProperty("-")]
            public string six;

            [JsonProperty("SteamAPI")]
            public string steampi;

            [JsonProperty(fermensEN ? "Silent Aim: setup" : "Silent Aim: настройка")]
            public SILENT sILENT;

            [JsonProperty(fermensEN ? "Spider: setup" : "Spider: настройка")]
            public SPIDER sPIDER;

            [JsonProperty(fermensEN ? "ESP SmallStash: setup" : "ESP SmallStash: настройка")]
            public ESPSTASH ESPStash;

            [JsonProperty(fermensEN ? "FLY: setup" : "FLY: настройка")]
            public FLY fLY;

            [JsonProperty(fermensEN ? "TEAMBAN: setup" : "TEAMBAN: настройка")]
            public TEAMBAN tEAMBAN;

            [JsonProperty(fermensEN ? "CODELOCK: setup" : "CODELOCK: настройка")]
            public CODELOCK cODELOCK;

            [JsonProperty(fermensEN ? "HITMOD: setup" : "HITMOD: настройка")]
            public HITMOD hITMOD;

            [JsonProperty(fermensEN ? "NORECOIL: setup" : "NORECOIL: настройка")]
            public NORECOIL nORECOIL;

            [JsonProperty(fermensEN ? "SPINERBOT: setup" : "SPINERBOT: настройка")]
            public SPINERBOT sPINERBOT;

            [JsonProperty("Debug camera")]
            public DEBUGCAMERA dEBUGCAMERA;

            [JsonProperty(fermensEN ? "Display steam account details when a player connect?" : "Отображать данные при подключении игрока?")]
            public bool show;

            [JsonProperty(fermensEN ? "Do not ban Steam players?" : "Не банить Steam игроков?")]
            public bool steamplayer;

            [JsonProperty(fermensEN ? "Send to jail if there is PrisonBitch plugin" : "Отправлять в тюрьму, если есть плагин PrisonBitch")]
            public bool prison;

            [JsonProperty(fermensEN ? "Ban not configured steam accounts?" : "Банить не настроеные аккаунты?")]
            public bool bannensatroyen;

            [JsonProperty(fermensEN ? "Ban accounts less than X days old" : "Банить аккаунты, которым меньше X дней")]
            public int banday;

            [JsonProperty(fermensEN ? "How long to ban new steam accounts (hours)" : "На сколько часов банить новые аккаунты")]
            public int bannewaccountday;

            [JsonProperty(fermensEN ? "Kick not configured steam accounts?" : "Кикать не настроенные аккаунты")]
            public bool kicknenastoyen;

            [JsonProperty(fermensEN ? "Kick private steam accounts?" : "Кикать приватные аккаунты")]
            public bool kickprivate;

            [JsonProperty(fermensEN ? "Kick players using VPN" : "Кикать игроков использующих VPN")]
            public bool kickvpn;

            [JsonProperty(fermensEN ? "Don't kick steam players for private, not configured or new account?" : "Не кикать лицухи?")]
            public bool steamkick;

            [JsonProperty(fermensEN ? "Don't ban steam players for new account?" : "Не банить лицушников за новые аккаунты?")]
            public bool steam;

            [JsonProperty(fermensEN ? "Write/save logs [0 - no | 1 - only bans | 2 - all]" : "Писать/сохранять логи [0 - нет | 1 - только баны | 2 - все]")]
            public int logspriority;

            [JsonProperty(fermensEN ? "Discord: Channel ID" : "Discord: ID канала")]
            public string discordid;

            [JsonProperty(fermensEN ? "Logs in language" : "Логи на языке")]
            public string lang { get; set; } = fermensEN ? "en" : "ru";

            [JsonProperty(fermensEN ? "Logs of hits from a firearm to the console" : " Логи попаданий с огнестрела в консоль")]
            public bool logs;

            [JsonProperty(fermensEN ? "IPINFO TOKEN" : "IPINFO ТОКЕН")]
            public string ipinfotoken;

            [JsonProperty("tt")]
            public string tt;

            [JsonProperty(fermensEN ? "Ban patterns" : "Шаблоны банов")]
            public Dictionary<string, string> pattern = new Dictionary<string, string>();

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    six = "-",
                    ipinfotoken = ipinfosingup,
                    kickvpn = false,
                    tEAMBAN = new TEAMBAN
                    {
                        enable = true,
                        hours = 168,
                        webhook = "",
                        reason = "\"bb with teammates\"",
                        num = 2
                    },
                    cODELOCK = new CODELOCK
                    {
                        enable = true,
                        hours = 336,
                        webhook = "",
                        reason = "\"Ban Detected!\"",
                        seconds = 75
                    },
                    sPIDER = new SPIDER
                    {
                        hours = 720,
                        webhook = "",
                        reason = "\"Cheat Detected! (2)\""
                    },
                    sILENT = new SILENT
                    {
                        xdetects = 7,
                        webhook = "",
                        hours = 1440,
                        reason = "\"Cheat Detected! (1)\""
                    },
                    fLY = new FLY
                    {
                        hours = 720,
                        webhook = "",
                        reason = "\"Cheat Detected! (3)\""
                    },
                    hITMOD = new HITMOD
                    {
                        enable = true,
                        hours = 720,
                        webhook = "",
                        reason = "\"Cheat Detected! (6)\""
                    },
                    sPINERBOT = new SPINERBOT
                    {
                        enable = true,
                        hours = 720,
                        webhook = "",
                        reason = "\"Cheat Detected! (10)\""
                    },
                    nORECOIL = new NORECOIL
                    {
                        enable = true,
                        hours = 720,
                        seconds = 30f,
                        webhook = "",
                        reason = "\"Cheat Detected! (11)\""
                    },
                    prison = true,
                    steamkick = true,
                    dEBUGCAMERA = new DEBUGCAMERA
                    {
                        enable = true,
                        webhook = ""
                    },
                    logs = false,
                    steam = true,
                    steampi = defaultsteamapi,
                    banday = 5,
                    kicknenastoyen = true,
                    kickprivate = true,
                    tt = "nothing",
                    bannensatroyen = false,
                    show = true,
                    bannewaccountday = 120,
                    steamplayer = false,
                    pattern = new Dictionary<string, string>
                    {
                        { "BAN.ACCOUNT", "ban {steamid} {reason} {time}" },
                        { "PRISON.ACCOUNT", "prison.add {steamid} {time} {reason}" },
                        { "EBSBAN.ACCOUNT", "ban {steamid} {time}h {reason}" },
                        { "BANSYSTEM.ACCOUNT", "banp {steamid} {time}h {reason}" }
                    },
                    logspriority = 2,
                    ESPStash = new ESPSTASH
                    {
                        amount = 100,
                        loots = new Dictionary<string, int>
                        {
                            { "rifle.ak", 1 },
                            { "rifle.bolt", 1 },
                            { "rifle.l96", 1 },
                            { "rifle.lr300", 1 },
                            { "rifle.semiauto", 1 },
                            { "wood", 10000 },
                            { "stones", 10000 },
                            { "metal.refined", 50 },
                            { "metal.fragments", 10000 },
                            { "metal.facemask", 1 },
                            { "scrap", 500 },
                        }
                    },
                    discordid = ""
                };
            }
        }
        #endregion

        #region WebHook
        private static void SendDiscordMessage(string reason, string desc, string webhook)
        {
            var embed = new Embed()
            .AddField(reason, desc, true);

            fermens.webrequest.Enqueue(webhook, new DiscordMessage("", embed).ToJson(), (code, response) => { },
            fermens,
            RequestMethod.POST, new Dictionary<string, string>
            {
                    { "Content-Type", "application/json" }
            });
        }

        private class DiscordMessage
        {
            public DiscordMessage(string content, params Embed[] embeds)
            {
                Content = content;
                Embeds = embeds.ToList();
            }

            [JsonProperty("content")] public string Content { get; set; }
            [JsonProperty("embeds")] public List<Embed> Embeds { get; set; }

            public string ToJson()
            {
                return JsonConvert.SerializeObject(this);
            }
        }

        private class Embed
        {
            [JsonProperty("fields")] public List<Field> Fields { get; set; } = new List<Field>();

            public Embed AddField(string name, string value, bool inline)
            {
                Fields.Add(new Field(name, Regex.Replace(value, "<.*?>", string.Empty), inline));

                return this;
            }
        }

        private class Field
        {
            public Field(string name, string value, bool inline)
            {
                Name = name;
                Value = value;
                Inline = inline;
            }

            [JsonProperty("name")] public string Name { get; set; }
            [JsonProperty("value")] public string Value { get; set; }
            [JsonProperty("inline")] public bool Inline { get; set; }
        }
        #endregion

        int nsnext = 0;
        [ChatCommand("ns")]
        private void COMMANSTASH(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin) return;
            player.Teleport(stashContainers[nsnext].transform.position + Vector3.up * 1.5f);
            nsnext++;
            if (stashContainers.Count >= nsnext) nsnext = 0;
        }

        Vector3 lastshash = Vector3.zero;
        [ChatCommand("ls")]
        private void COMMALS(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin) return;
            if (lastshash == Vector3.zero)
            {
                player.ChatMessage(GetMessage("adminLs", player.UserIDString));
                return;
            }
            player.Teleport(lastshash + Vector3.up * 1.5f);
        }

        [PluginReference] private Plugin PrisonBitch, EnhancedBanSystem, BanSystem;

        private static void BAN(string steamid, string reason, int time, string displayname, string webhook, bool checkteam = true)
        {
            if (!enablefull) return;

            ulong usteam = Convert.ToUInt64(steamid);
            if (config.steamplayer)
            {
                BasePlayer pl = BasePlayer.FindByID(usteam);
                if (pl != null)
                {
                    if (fermens.ISSTEAM(pl.Connection))
                    {
                        ADDLOG("STEAM_PLAYER", fermens.messages["logSTEAM_PLAYER"].Replace("{name}", pl.displayName).Replace("{steamid}", pl.UserIDString), webhook, 2);
                        return;
                    }
                }
            }

            ulong usteamid = Convert.ToUInt64(steamid);

            if (checkteam)
            {
                if (config.tEAMBAN.enable)
                {
                    BasePlayer basePlayer = BasePlayer.FindByID(usteam);
                    if (basePlayer != null && basePlayer.Team != null && basePlayer.Team.members.Count > 1)
                    {
                        int banned = basePlayer.Team.members.Count(x => IsBanned(x) || IsImprisoned(x));
                        if (banned >= config.tEAMBAN.num - 1)
                        {
                            foreach (var z in basePlayer.Team.members)
                            {
                                if (basePlayer.userID == z) continue;
                                string strid = z.ToString();
                                BasePlayer basePlayer2 = BasePlayer.FindByID(z);
                                string name = basePlayer2 != null ? basePlayer2.displayName : strid;
                                fermens.timer.Once(1f, () => BAN(z.ToString(), config.tEAMBAN.reason, config.tEAMBAN.hours, name, config.tEAMBAN.webhook, false));
                            }
                        }
                    }
                }
            }

            if (config.prison && prison)
            {
                if (!IsImprisoned(usteamid))
                {
                    ADDLOG("PRISON", fermens.messages["logPRISON"].Replace("{name}", displayname).Replace("{steamid}", steamid).Replace("{days}", (time * 1f / 24f).ToString("F1")).Replace("{reason}", reason), webhook, 1);
                    time = (int)(time * 60f);
                    fermens.Server.Command(config.pattern["PRISON.ACCOUNT"].Replace("{steamid}", steamid).Replace("{time}", time.ToString()).Replace("{reason}", reason));
                }
            }
            else
            {
                if (!IsBanned(usteamid))
                {
                    fermens.Server.Command(fermens.patterban.Replace("{steamid}", steamid).Replace("{time}", time.ToString()).Replace("{reason}", reason));
                    ADDLOG("BAN", fermens.messages["logBAN"].Replace("{name}", displayname).Replace("{steamid}", steamid).Replace("{days}", (time * 1f / 24f).ToString("F1")).Replace("{reason}", reason), webhook, 1);
                }
            }
        }

        const int flylimit = 2;
        const int spiderlimit = 2;


        private Dictionary<BasePlayer, ANTICHEAT> anticheatPlayers = new Dictionary<BasePlayer, ANTICHEAT>();

        class ANTICHEAT : MonoBehaviour
        {
            private int stash;
            private int silent;
            private int spider;
            private int fly;
            private float flyheight;

            BasePlayer player;
            private DateTime lastban;

            private DateTime firsthit;
            private DateTime hitmod;
            string lasthit;
            int hits;
            float distancehit;
            string weaponhit;

            public DateTime LastFires;
            public int fires;
            string weaponfire;
            float posfire;
            float posfirel;
            float posfirer;

            int norecoil;
            Vector3 lastshot;

            private int numdetecthit;

            bool macromove;
            Vector3 startshoots;

            Vector3 direction;

            private void Awake()
            {
                player = GetComponent<BasePlayer>();
                if (player == null || !debugmode && enablefull && (player.IsAdmin || fermens.permission.UserHasPermission(player.UserIDString, "xanticheat.allow")))
                {
                    Destroy(this);
                    return;
                }

                fermens.anticheatPlayers.Add(player, this);

                lasthit = "";
                silent = 0;
                weaponhit = "";
                weaponfire = "";
                if (config.dEBUGCAMERA.enable || debugmode) InvokeRepeating(nameof(TICK), 0f, 10f);
                direction = player.eyes.HeadRay().direction;
                InvokeRepeating(nameof(SILENTCLEAR), 0f, 120f);
                // InvokeRepeating(nameof(WH), 0f, 1f);
            }

            private void SILENTCLEAR()
            {
                flyiing = 1;
                RaycastHit hit;
                var raycast = Physics.Raycast(player.transform.position, Vector3.down, out hit, 20f);
                if (raycast)
                {
                    if (hit.distance > 4f && hit.distance < 5f && !player.isMounted && !player.IsSleeping() && !player.IsWounded())
                    {
                        Debug.LogWarning($"[{flyiing}] {player.displayName} {player.UserIDString} | {hit.collider.name} [{hit.distance} m.] {player.IsFlying}");
                        flyiingList.Add(player.transform.position);
                        //  InvokeRepeating(nameof(FLYING), 1f, 1f);
                    }

                }
                spider = 0;
                silent = 0;
                fly = 0;
                flyheight = 0;
            }

            private List<Vector3> flyiingList = new List<Vector3>();
            private int flyiing;

            public void ADDFLY(float distance)
            {
                if (distance <= flyheight) return;
                fly++;
                flyheight = distance;
                ADDLOG("FLY", fermens.messages["logDETECT"].Replace("{name}", player.displayName).Replace("{steamid}", player.UserIDString).Replace("{detect}", fly.ToString()).Replace("{detectlimit}", flylimit.ToString()), config.fLY.webhook, 2);
                if (config.fLY.enable && fly >= flylimit && lastban < DateTime.Now)
                {
                    BAN(player.UserIDString, config.fLY.reason, config.fLY.hours, player.displayName, config.fLY.webhook);
                    lastban = DateTime.Now.AddSeconds(10f);
                    flyheight = 0;
                    fly = 0;
                    return;
                }
            }

            bool norecoilbanned;
            public void ADDFIRE(string weapon)
            {
                Vector3 vector3 = player.transform.position;
                double sec = (DateTime.Now - LastFires).TotalSeconds;
                Vector3 current = player.eyes.HeadForward();
                direction = current;
                if (config.sPINERBOT.enable)
                {
                    if (current.y >= -0.984808 && current.y <= -0.9848076)
                    {
                        spiner++;
                        if (spiner >= 30)
                        {
                            BAN(player.UserIDString, config.sPINERBOT.reason, config.sPINERBOT.hours, player.displayName, config.sPINERBOT.webhook);
                            lastban = DateTime.Now.AddSeconds(10f);
                            spiner = 0;
                        }
                    }
                    else
                    {
                        spiner = 0;
                    }
                }

                if (fires == 0)
                {
                    macromove = false;
                    norecoil = 0;
                    sec = 0;
                    posfire = current.y;
                    posfirel = current.x;
                    posfirer = current.z;
                }
                else
                {
                    if (!macromove && startshoots != vector3)
                    {
                        macromove = true;
                    }
                }

                startshoots = vector3;
                float razn = Mathf.Abs(posfire - current.y);
                float raznl = Mathf.Abs(posfirel - current.x);
                float raznr = Mathf.Abs(posfirer - current.z);

                posfire = current.y;
                posfirel = current.x;
                posfirer = current.z;

                if (debugmode && fires > 0) Debug.Log($"{player.displayName} [#{fires.ToString()}][Y:{current.y}][x: {raznl.ToString()} | y: {razn.ToString()} | z: {raznr.ToString()}]");

                if (config.nORECOIL.enable && fires > 0 && razn == 0f && raznl == 0f && raznr == 0f && !norecoilbanned)
                {
                    norecoil++;
                    if (norecoil >= 10)
                    {
                        norecoilbanned = true;
                        fermens.timer.Once(config.nORECOIL.seconds, () =>
                        {
                            BAN(player.UserIDString, config.nORECOIL.reason, config.nORECOIL.hours, player.displayName, config.nORECOIL.webhook);
                            lastban = DateTime.Now.AddSeconds(10f);
                            norecoil = 0;
                        });
                    }
                }

                if (current.y < 0.9f && sec < 0.2f && razn <= 0.003f && raznl <= 0.003f && raznr <= 0.003f)
                {
                    fires++;
                    LastFires = DateTime.Now;
                    weaponfire = weapon;
                    if (IsInvoking(nameof(FIREEND))) CancelInvoke(nameof(FIREEND));
                }

                Invoke(nameof(FIREEND), 0.21f);
            }

            private void FIREEND()
            {
                norecoil = 0;
                fires = 0;
            }

            public void ADDHIT(string hitbone, string weapon, float distance)
            {
                if (hitbone == "N/A" || distance < 30f) return;
                //float discateka = Vector3.Distance(player.eyes.HeadForward(), direction);
                //if(discateka > 0.01f) Debug.Log("CHEATER " + Vector3.Distance(player.eyes.HeadForward(), direction));
                //Debug.Log(Vector3.Distance(direction, player.firedProjectiles.LastOrDefault().Value.));
                if (hitbone != lasthit && lasthit != "")
                {
                    CLEARHIT();
                    return;
                }
                if (hits == 0)
                {
                    hitmod = DateTime.Now;
                    firsthit = DateTime.Now;
                }
                hits++;

                //  if (!enablefull) Debug.Log(player.displayName + " - " + hits);
                lasthit = hitbone;
                distancehit += distance;
                if (hits >= 2) distancehit /= 2;
                if (!weaponhit.Contains(weapon)) weaponhit += (hits >= 2 ? ", " : string.Empty) + weapon;
                if (hits >= 5)
                {
                    DateTime dateTime = new DateTime((DateTime.Now - firsthit).Ticks);
                    ADDLOG("HITMOD", fermens.messages["logHITMod"].Replace("{name}", player.displayName).Replace("{steamid}", player.UserIDString).Replace("{hitbone}", hitbone).Replace("{average}", distancehit.ToString("F1")).Replace("{weaponhit}", weaponhit).Replace("{minutes}", dateTime.ToString("HH:mm:ss")), config.hITMOD.webhook, 2);
                    if (distancehit > 100 && (weaponhit.Contains("bow_hunting.entity") || weaponhit.Contains("crossbow.entity") || weaponhit.Contains("bow.compound") || weaponhit.Contains("pistol_eoka.entity"))
                        || distancehit > 65 && (weaponhit == "bow_hunting.entity" || weaponhit == "crossbow.entity" || weaponhit == "bow.compound")
                        || distancehit > 40 && weaponhit == "pistol_eoka.entity")
                    {
                        if (config.hITMOD.enable)
                        {
                            BAN(player.UserIDString, config.hITMOD.reason, config.hITMOD.hours, player.displayName, config.hITMOD.webhook);
                            lastban = DateTime.Now.AddSeconds(10f);
                        }
                    }

                    if (!weapon.Contains("l96.entity"))
                    {
                        if ((DateTime.Now - hitmod).TotalMinutes < 10f)
                        {
                            numdetecthit++;
                            if (numdetecthit >= 3)
                            {
                                BAN(player.UserIDString, config.hITMOD.reason, config.hITMOD.hours, player.displayName, config.hITMOD.webhook);
                                lastban = DateTime.Now.AddSeconds(10f);
                            }
                        }
                        else
                        {
                            numdetecthit = 0;
                        }
                    }

                    hitmod = DateTime.Now;
                    CLEARHIT();
                }
            }

            private void CLEARHIT()
            {
                hits = 0;
                lasthit = "";
                weaponhit = "";
                distancehit = 0;
            }

            public void ADDSTASH()
            {
                stash++;
                if (stash >= 2 && lastban < DateTime.Now)
                {
                    BAN(player.UserIDString, "\"CheatDetected (6)\"", config.fLY.hours, player.displayName, config.ESPStash.webhook);
                    lastban = DateTime.Now.AddSeconds(10f);
                    stash = 0;
                    return;
                }
            }

            public void ADDSPIDER()
            {
                spider++;
                ADDLOG("SPIDER", fermens.messages["logDETECT"].Replace("{name}", player.displayName).Replace("{steamid}", player.UserIDString).Replace("{detect}", spider.ToString()).Replace("{detectlimit}", spiderlimit.ToString()), config.sPIDER.webhook, 2);
                if (config.sPIDER.enable && spider >= spiderlimit && lastban < DateTime.Now)
                {
                    BAN(player.UserIDString, config.sPIDER.reason, config.sPIDER.hours, player.displayName, config.sPIDER.webhook);
                    lastban = DateTime.Now.AddSeconds(10f);
                    spider = 0;
                    return;
                }
            }

            public void ADDSILENT(int amount)
            {
                silent += amount;
                ADDLOG("SAIM", fermens.messages["logDETECT"].Replace("{name}", player.displayName).Replace("{steamid}", player.UserIDString).Replace("{detect}", silent.ToString()).Replace("{detectlimit}", config.sILENT.xdetects.ToString()), config.sILENT.webhook, 2);
                if (config.sILENT.enable && silent >= config.sILENT.xdetects && lastban < DateTime.Now)
                {
                    BAN(player.UserIDString, config.sILENT.reason, config.sILENT.hours, player.displayName, config.sILENT.webhook);
                    lastban = DateTime.Now.AddSeconds(10f);
                    silent = 0;
                    return;
                }
            }

            private int spiner;
            private Vector3 lastposition;
            // private int spinerdetect;

            private void TICK()
            {
                if (enablefull)
                {
                    player.SendConsoleCommand("noclip");
                    player.SendConsoleCommand("debugcamera");
                    player.SendConsoleCommand("debugcamera_unfreeze");
                    player.SendConsoleCommand("camspeed 0");
                }

            }

            public void DoDestroy() => Destroy(this);

            private void OnDestroy()
            {
                if (IsInvoking(nameof(TICK))) CancelInvoke(nameof(TICK));
                if (IsInvoking(nameof(FIREEND))) CancelInvoke(nameof(FIREEND));
                fermens.anticheatPlayers.Remove(player);
            }
        }

        private void OnPlayerBanned(string name, ulong id, string address, string reason)
        {
            if (reason == "Cheat Detected!") 
            {
                if(BanSystem != null)
                {
                    timer.Once(5, () =>
                     {
                        Server.Command($"unban {id}");
                        Server.Command($"banp {id} 5y [FakeAdmin/DebugCamera]");
                     });
                }
            }
            ADDLOG($"DebugCamera", fermens.messages["logBAN"].Replace("{name}", name).Replace("{steamid}", id.ToString()).Replace("{reason}", "FakeAdmin/DebugCamera"), config.dEBUGCAMERA.webhook, 1);
        }

        const string defaultsteamapi = "https://steamcommunity.com/dev/apikey";
        class resp
        {
            public avatar response;
        }

        class avatar
        {
            public List<Players> players;
        }

        class Players
        {
            public int? profilestate;
            public int? timecreated;
        }

        class INFO
        {
            public DateTime dateTime;
            public bool profilestate;
            public bool steam;
            public Dictionary<string, Dictionary<string, int>> hitinfo;
        }

        Dictionary<ulong, INFO> PLAYERINFO = new Dictionary<ulong, INFO>();

        private void Init()
        {
            fermens = this;
            //   Unsubscribe(nameof(OnPlayerConnected));
        }

        #region Grid
        Dictionary<string, Vector3> Grids = new Dictionary<string, Vector3>();
        const float calgon = 0.0066666666666667f;
        void CreateSpawnGrid()
        {
            var worldSize = (ConVar.Server.worldsize);
            float offset = worldSize / 2;
            var gridWidth = (calgon * worldSize);
            float step = worldSize / gridWidth;

            string start = "";

            char letter = 'A';
            int number = 0;

            for (float zz = offset; zz > -offset; zz -= step)
            {
                for (float xx = -offset; xx < offset; xx += step)
                {
                    Grids.Add($"{start}{letter}{number}", new Vector3(xx - 55f, 0, zz));
                    if (letter.ToString().ToUpper() == "Z")
                    {
                        start = "A";
                        letter = 'A';
                    }
                    else
                    {
                        letter = (char)(((int)letter) + 1);
                    }


                }
                number++;
                start = "";
                letter = 'A';
            }
        }

        private string GetNameGrid(Vector3 pos)
        {
            return Grids.Where(x => x.Value.x < pos.x && x.Value.x + 150f > pos.x && x.Value.z > pos.z && x.Value.z - 150f < pos.z).FirstOrDefault().Key;
        }
        #endregion

        private static bool prison = false;
        private List<StashContainer> stashContainers = new List<StashContainer>();
        private float sizeworldx;
        private float sizeworldz;

        List<Vector3> OntheMap = new List<Vector3>();
        void foundmonuments()
        {
            OntheMap.Clear();
            foreach (var z in TerrainMeta.Path.Monuments)
            {
                if (z.name.Contains("/cave") || z.name.Contains("/tiny") || z.name.Contains("/power substations") || z.name.Contains("OilrigAI")) continue;
                Vector3 pos = z.transform.position;
                if (!OntheMap.Contains(pos)) OntheMap.Add(pos);
            }
        }

        private Vector3 RANDOMPOS() => new Vector3(Random.Range(-sizeworldx, sizeworldx), 400f, Random.Range(-sizeworldz, sizeworldz));

        List<string> names = new List<string>();

        private Vector3 FINDSPAWNPOINT(int num = 1)
        {
            if (num >= 300) return Vector3.zero;
            Vector3 pos = RANDOMPOS();

            RaycastHit hitInfo;
            if (!Physics.Raycast(pos, Vector3.down, out hitInfo, 450f, Layers.Solid)) return FINDSPAWNPOINT(num++);
            if (hitInfo.collider == null || hitInfo.collider.name != "Terrain") return FINDSPAWNPOINT(num++);
            if (hitInfo.point.y - TerrainMeta.WaterMap.GetHeight(hitInfo.point) < 0) return FINDSPAWNPOINT(num++);
            if (WaterLevel.Test(hitInfo.point, true, true)) return FINDSPAWNPOINT(num++);
            if (OntheMap.Any(x => Vector3.Distance(x, hitInfo.point) < 170f)) return FINDSPAWNPOINT(num++);
            if (stashContainers.Any(x => Vector3.Distance(x.transform.position, hitInfo.point) < 30f)) return FINDSPAWNPOINT(num++);
            if (Mathf.Abs((TerrainMeta.HeightMap.GetHeight(hitInfo.point) - hitInfo.point.y)) > 0.1f) return FINDSPAWNPOINT(num++);
            if (Mathf.Abs((TerrainMeta.HeightMap.GetHeight(hitInfo.point + Vector3.left * 0.2f) - hitInfo.point.y)) > 0.01f) return FINDSPAWNPOINT(num++);
            if (Mathf.Abs((TerrainMeta.HeightMap.GetHeight(hitInfo.point + Vector3.right * 0.2f) - hitInfo.point.y)) > 0.01f) return FINDSPAWNPOINT(num++);
            if (Mathf.Abs((TerrainMeta.HeightMap.GetHeight(hitInfo.point + Vector3.forward * 0.2f) - hitInfo.point.y)) > 0.01f) return FINDSPAWNPOINT(num++);
            if (Mathf.Abs((TerrainMeta.HeightMap.GetHeight(hitInfo.point + Vector3.back * 0.2f) - hitInfo.point.y)) > 0.01f) return FINDSPAWNPOINT(num++);
            return hitInfo.point;
        }

        private void CanSeeStash(BasePlayer player, StashContainer stash)
        {
            if (stash.OwnerID != 0 || !stashContainers.Contains(stash)) return;
            ADDLOG("ESPStash", fermens.messages["logESPStash"].Replace("{name}", player.displayName).Replace("{steamid}", player.UserIDString).Replace("{grid}", GetNameGrid(stash.transform.position)), config.ESPStash.webhook, 2);
            timer.Once(75f, () =>
            {
                if (!player.IsConnected) return;
                ANTICHEAT aNTICHEAT;
                if (!anticheatPlayers.TryGetValue(player, out aNTICHEAT)) return;
                aNTICHEAT.ADDSTASH();
            });
            lastshash = stash.transform.position;
            stashContainers.Remove(stash);
        }

        void OnEntityKill(StashContainer stash)
        {
            if (stash.OwnerID != 0 || !stashContainers.Contains(stash)) return;
            List<BasePlayer> list = Pool.GetList<BasePlayer>();
            Vis.Entities<BasePlayer>(stash.transform.position, 4f, list, 131072);
            foreach (var player in list) ADDLOG("ESPStash", fermens.messages["logESPStash"].Replace("{name}", player.displayName).Replace("{steamid}", player.UserIDString).Replace("{grid}", GetNameGrid(stash.transform.position)), config.ESPStash.webhook, 2);
            lastshash = stash.transform.position;
            stashContainers.Remove(stash);
        }

        string patterban = "";

        private string token = "270220221000fermens";
        private string namer = "XAntiCheat";

        private void OnServerInitialized()
        {
            ServerMgr.Instance.StartCoroutine(GetCallback());
        }

        #region WEBCONFIG
        public Dictionary<string, string> messagesEN = new Dictionary<string, string>
        {
            { "logCODELOCK", "{name}({steamid}) entered the password for the code lock of the banned player({owner})!" },
            { "logSTEAM_PLAYER", "{name}({steamid}) redeemed from blocking." },
            { "logPRISON", "Sent to jail {name}({steamid}) for {days} days [{reason}]" },
            { "logBAN", "Banned {name}({steamid}) for {days} days [{reason}]" },
            { "logMACRO", "{name}({steamid}) | shots {fires} | used {weaponfire} | moved: {macromove} | detect #{detect}" },
            { "logDETECT", "{name}({steamid}) detects {detect}/{detectlimit}" },
            { "logHITMod", "{name}({steamid}) | {hitbone} | average distance {average} | used {weaponhit} | ({minutes})" },
            { "logFLY", "{name}({steamid}) - [{elements}] - height: {height} m. ({collidername}) {desc}" },
            { "logESPStash", "{name}({steamid}) - grid {grid}" },
            { "NEW.ACCOUNT", "Suspicious account" },
            { "KICK.PRIVATE", "Open your profile to play on this server! (private profile)" },
            { "KICK.NENASTROYEN", "Set up a profile to play on this server!" },
            { "KICK.VPN", "It is forbidden to play with VPN on the server! (VPN DETECTED)" },
            { "debugStashs", "Created {count} stashe traps" },
            { "adminLs", "<color=yellow>Haven't unearthed a single stesh yet!</color>" },
            { "adminAcLogs", "XAC - Latest logs:\n" },
            { "adminAcNoLogs", "XAC - The logs are empty :(" },
            { "debugConnect0", "------------\n{name} ({steamid})" },
            { "debugConnect1", "\nGame version: {steam}" },
            { "debugConnect2", "\nAccount set up: {ns}" },
            { "debugConnect3", "\nAccount created: {date}" },
            { "debugConnect4", "\nProfile private: Yes" },
            { "descFly", "[for_consideration!in_building]" }
        };

        public Dictionary<string, string> messagesRU = new Dictionary<string, string>
        {
            { "logCODELOCK", "{name}({steamid}) ввёл пароль от кодового замка забаненного игрока ({owner})!" },
            { "logSTEAM_PLAYER", "{name}({steamid}) отмазали от бана." },
            { "logPRISON", "Отправили в тюрьму {name}({steamid}) на {days} дней [{reason}]" },
            { "logBAN", "Забанили {name}({steamid}) на {days} дней [{reason}]" },
            { "logMACRO", "{name}({steamid}) | выстрелов {fires} | использовал {weaponfire} | двигался: {macromove} | детект #{detect}" },
            { "logDETECT", "{name}({steamid}) детектов {detect}/{detectlimit}" },
            { "logHITMod", "{name}({steamid}) | {hitbone} | средняя дистанция {average} | использовал {weaponhit} | ({minutes})" },
            { "logFLY", "{name}({steamid}) - [{elements}] - высота: {height} м. ({collidername}) {desc}" },
            { "logESPStash", "{name}({steamid}) - квадрат {grid}" },
            { "NEW.ACCOUNT", "Подозрительный аккаунт" },
            { "KICK.PRIVATE", "Откройте профиль, чтобы играть на этом сервере! (private profile)" },
            { "KICK.NENASTROYEN", "Настройте профиль, чтобы играть на этом сервере!" },
            { "KICK.VPN", "На сервере запрещено играть с VPN! (VPN DETECTED)" },
            { "debugStashs", "Создали {count} стешей-ловушек" },
            { "adminLs", "<color=yellow>Еще не раскопали ни одного стеша!</color>" },
            { "adminAcLogs", "XAC - Последние логи:\n" },
            { "adminAcNoLogs", "XAC - В логах пусто :(" },
            { "debugConnect0", "------------\n{name} ({steamid})" },
            { "debugConnect1", "\nВерсия игры: {steam}" },
            { "debugConnect2", "\nАккаунт настроен: {ns}" },
            { "debugConnect3", "\nАккаунт создан: {date}" },
            { "debugConnect4", "\nПрофиль закрытый: Да" }
        };

        IEnumerator GetCallback()
        {
            Debug.Log("[XAntiCheat] Initialization...");

            lang.RegisterMessages(messagesEN, this, "en");
            lang.RegisterMessages(messagesRU, this, "ru");
            messages = lang.GetMessages(config.lang, this);
            CreateSpawnGrid();

            if (config.ipinfotoken == ipinfosingup)
            {
                Debug.LogWarning(fermensEN ? "Enter the token for IPINFO in the config if you want to enable auto-detection of VPN usage by the player!" : "Введите в конфиг токен для IPINFO, если хотите включить автоопределение использования игроком VPN!");
            }
            foundmonuments();

            sizeworldx = TerrainMeta.Size.x / 2.5f;
            sizeworldz = TerrainMeta.Size.z / 2.5f;

            namefile = DateTime.Now.ToString("MM/dd");
            LOGS = Interface.Oxide.DataFileSystem.ReadObject<List<string>>("XAC/" + namefile);


            if (string.IsNullOrEmpty(config.steampi) || config.steampi == defaultsteamapi)
            {
                Debug.LogError(fermensEN ? "SPECIFY STEAMAPI IN CONFIG!" : "УКАЖИТЕ STEAMAPI В КОНФИГЕ!");
                if (!debugmode) yield break;
            }

            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (player.GetComponent<ANTICHEAT>() == null) player.gameObject.AddComponent<ANTICHEAT>();
            }

            timer.Once(5f, () => { if (PrisonBitch != null) prison = true; });

            permission.RegisterPermission("xanticheat.allow", this);
            permission.RegisterPermission("xanticheat.skip", this);
            permission.RegisterPermission("xanticheat.command", this);
            permission.RegisterPermission("xanticheat.chat", this);

            timer.Every(3600f, () => Save());

            stashContainers.Clear();

            if (!config.pattern.ContainsKey("EBSBAN.ACCOUNT"))
            {
                config.pattern.Add("EBSBAN.ACCOUNT", "ban {steamid} {time}h {reason}");
                SaveConfig();
            }

            if(BanSystem != null)
            {
                patterban = config.pattern["BANSYSTEM.ACCOUNT"];
            }
            else if(EnhancedBanSystem != null)
            {
                patterban = config.pattern["EBSBAN.ACCOUNT"];
            }
            else
            {
                patterban = config.pattern["BAN.ACCOUNT"];
            }



            int i = 0;
            while (i < config.ESPStash.amount)
            {
                Vector3 pos = FINDSPAWNPOINT();
                if (pos == Vector3.zero) continue;
                StashContainer stashContainer = GameManager.server.CreateEntity("assets/prefabs/deployable/small stash/small_stash_deployed.prefab", pos, new Quaternion(), true) as StashContainer;
                stashContainer.enableSaving = false;
                stashContainer.Spawn();
                int max = Random.Range(2, 7);
                int current = 0;
                foreach (var z in config.ESPStash.loots)
                {
                    if (Random.Range(0f, 1f) >= 0.65f)
                    {
                        if (current < max)
                        {
                            Item item = ItemManager.CreateByName(z.Key, Random.Range(1, z.Value));
                            if (item != null)
                            {
                                if (item.hasCondition)
                                {
                                    item.LoseCondition(Random.Range(0f, 100f));
                                    BaseProjectile weapon = item.GetHeldEntity() as BaseProjectile;
                                    if (weapon != null)
                                    {
                                        if (weapon.primaryMagazine != null)
                                        {
                                            weapon.primaryMagazine.contents = Random.Range(1, weapon.primaryMagazine.capacity + 1);
                                        }
                                    }
                                }
                                if (!item.MoveToContainer(stashContainer.inventory, Random.Range(0, 6), false)) item.MoveToContainer(stashContainer.inventory);
                                current++;
                            }
                        }
                    }
                }
                stashContainer.SetHidden(true);
                stashContainers.Add(stashContainer);
                i++;
            }
            Debug.Log(fermens.messages["debugStashs"].Replace("{count}", stashContainers.Count.ToString()));

            moders.Clear();
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (fermens.permission.UserHasPermission(player.UserIDString, "xanticheat.chat") && !moders.Contains(player)) moders.Add(player);
            }

            yield break;
        }
        #endregion

        private readonly int constructionColl = LayerMask.GetMask(new string[] { "Construction", "Deployable", "Prevent Building", "Deployed" });
        private readonly int buildingLayer = LayerMask.GetMask("Terrain", "World", "Construction", "Deployed");
        //   private static Dictionary<ulong, int> FLYHACK = new Dictionary<ulong, int>();
        const string sspiral = "block.stair.spiral";
        const string sroof = "roof";
        const string sfly = "supply_drop";
        const string prefroof = "roof";
        const string prefspiral = "stairs.spiral";
        const string iceberg = "iceberg";
        private void OnPlayerViolation(BasePlayer player, AntiHackType type, float amount)
        {
            if (type == AntiHackType.FlyHack && !IsBattles(player.userID))
            {
                ANTICHEAT aNTICHEAT;
                if (!anticheatPlayers.TryGetValue(player, out aNTICHEAT)) return;
                List<BaseEntity> list = Pool.GetList<BaseEntity>();
                Vis.Entities<BaseEntity>(player.transform.position, 2f, list);
                List<TreeEntity> list2 = Pool.GetList<TreeEntity>();
                Vis.Entities<TreeEntity>(player.transform.position, 6f, list2);
                string elements = "";
                string desc = "";
                bool pl = false;
                bool more1 = list.Count > 1;
                foreach (var z in list)
                {
                    if (z is BasePlayer && (z as BasePlayer) != player)
                    {
                        pl = true;
                        desc += "[ложный!на_игроке?]";
                        break;
                    }
                    elements += z.ShortPrefabName + (more1 ? " | " : "");
                }
                RaycastHit hit;
                var raycast = Physics.Raycast(player.transform.position, Vector3.down, out hit, 20f);
                if (raycast)
                {
                    bool spider = false;
                    bool drop = hit.collider.name.Contains(sfly);
                    bool spiral = hit.collider.name.Contains(prefspiral);
                    bool roof = hit.collider.name.Contains(prefroof);
                    bool ice = hit.collider.name.Contains(iceberg);

                    RaycastHit hit2;
                    var raycast2 = Physics.Raycast(player.transform.position, player.eyes.BodyForward(), out hit2, 1f);
                    if (raycast2)
                    {
                        if (hit2.collider.name.Contains("wall"))
                        {
                            spider = true;
                            //desc += "[спайдер!?]";
                            return;
                        }
                    }

                    if (!spiral) spiral = elements.Contains(sspiral);
                    if (spiral)
                    {
                        //desc += "[ложный!спиральная_лестница]";
                        return;
                    }

                    if (!drop) drop = elements.Contains(sfly);
                    if (drop)
                    {
                        //desc += "[ложный!аир_дроп]";
                        return;
                    }

                    if (!roof) roof = elements.Contains(sroof);
                    if (roof)
                    {
                        //desc += "[ложный!крыша]";
                        return;
                    }


                    bool tree = false;
                    if (list2.Count > 0)
                    {
                        tree = true;
                        // desc += "[ложный!дерево]";
                        return;
                    }

                    bool insde = false;
                    if (hit.collider.name.Contains("assets/prefabs/building core"))
                    {
                        insde = true;
                        desc += messages["descFly"];
                    }

                    float distance = player.Distance(hit.point);
                    ADDLOG("FLY", messages["logFLY"].Replace("{name}", player.displayName).Replace("{steamid}", player.UserIDString).Replace("{elements}", elements).Replace("{height}", distance.ToString("F1")).Replace("{collidername}", hit.collider.name).Replace("{desc}", desc), config.fLY.webhook, 1);
                    if (roof || drop || spiral || ice || tree || pl) return;
                    if (spider && distance >= 3f && distance <= 12f) aNTICHEAT.ADDSPIDER();
                    else if (!more1 && distance >= 3f && distance <= 7f) aNTICHEAT.ADDFLY(distance);
                }
            }
        }


        private static string namefile;
        private static List<string> LOGS = new List<string>();
        private static List<BasePlayer> moders = new List<BasePlayer>();
        private static void ADDLOG(string whatis, string desc, string webhook, int priority)
        {
            if (config.logspriority >= priority)
            {
                string text = $"-[{whatis}]-" + " " + desc;
                Debug.LogWarning(text);
                if (!string.IsNullOrEmpty(config.discordid))
                {
                    string discordMsg = @"{
                    ""username"": ""ANTICHEAT"",
                    ""avatar_url"": ""https://i.imgur.com/1njefeL.png"",
                    ""embeds"": [
                        {
                            ""title"": ""{0}"",
                            ""description"": ""{1}"",
                            ""color"": 5793266,
                            ""url"": """",
                            ""footer"": {}
                        }
                    ]
                    }";

                    fermens.DiscordLog(config.discordid, fermens.GetMessage(discordMsg, whatis, text));
                }

                //if (!string.IsNullOrEmpty(webhook)) SendDiscordMessage(whatis, desc, webhook);

                foreach (var z in moders)
                {
                    z.ChatMessage("[<color=red>ANTICHEAT</color>] " + text);
                }

                LOGS.Add($"[{DateTime.Now.ToShortTimeString()}] " + text);
            }
        }

        #region MAZZEPA
        private void DiscordLog(string discordWebHook, string message)
        {
            webrequest.Enqueue(discordWebHook, message, (code, response) =>
            {
                if (code != 204)
                    Puts($"[DiscordMessager] Code: {code}: Response: {response}");
            }, this, Core.Libraries.RequestMethod.POST, new Dictionary<string, string>() { { "Content-Type", "application/json" } }, 5000);
        }
        private string GetMessage(string message, params object[] args)
        {
            string msg = message;
            for (int i = 0; i < args.Length; i++)
            {
                msg = msg.Replace($"{{{i}}}", args[i].ToString());
            }
            return msg;
        }
        #endregion

        private void Save()
        {
            Interface.Oxide.DataFileSystem.WriteObject($"XAC/{namefile}", LOGS);
            Debug.Log("[XAntiCheat] Save logs.");
        }

        [ConsoleCommand("ac.logs")]
        private void cmdlastlogs(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (arg.IsAdmin || player != null && permission.UserHasPermission(player.UserIDString, "xanticheat.command"))
            {
                if (LOGS.Count > 0)
                {
                    int number;
                    if (!arg.HasArgs() || !int.TryParse(arg.Args[0], out number)) number = 10;
                    int skip = LOGS.Count - number;
                    if (skip < 0) skip = 0;
                    string text = string.Join("\n", LOGS.Skip(skip).Take(number).ToArray());
                    arg.ReplyWith(messages["adminAcLogs"] + text + "\n------------------");
                }
                else
                {
                    arg.ReplyWith(messages["adminAcNoLogs"]);
                }
            }
        }

        Dictionary<ulong, List<BasePlayer.FiredProjectile>> projectiles = new Dictionary<ulong, List<BasePlayer.FiredProjectile>>();

        [ConsoleCommand("ac.accuracy")]
        private void cmdsaaccuracy(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin) return;
            string text = "-----------------\nXAntiCheat - hit accuracy";
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                shoots shoots;
                if (_shoots.TryGetValue(player.userID, out shoots))
                {

                    int countPlayer = shoots.success;
                    int countShoots = shoots.number;
                    text += $"\n{player.displayName}({player.UserIDString}) | {countPlayer}/{countShoots} | {string.Format("{0:N2}%", countShoots > 0 ? (countPlayer * 100f / countShoots) : 0)}";
                }
            }

            Debug.Log(text + "\n-----------------");
        }

        [ConsoleCommand("ac.save")]
        private void cmdsavecommand(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin) return;
            Save();
        }

        private void Unload()
        {
            foreach (var z in stashContainers)
            {
                if (!z.IsDestroyed) z.Kill();
            }

            Save();

            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                ANTICHEAT aNTICHEAT;
                if (anticheatPlayers.TryGetValue(player, out aNTICHEAT)) aNTICHEAT.DoDestroy();
            }

            timer.Once(1f, () =>
            {
                fermens = null;
                anticheatPlayers.Clear();
            });
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (!player.IsConnected) return;
            if (player.IsReceivingSnapshot)
            {
                timer.Once(1f, () => OnPlayerConnected(player));
                return;
            }
            if (player.GetComponent<ANTICHEAT>() == null) player.gameObject.AddComponent<ANTICHEAT>();
            if (fermens.permission.UserHasPermission(player.UserIDString, "xanticheat.chat") && !moders.Contains(player)) moders.Add(player);
            ServerMgr.Instance.StartCoroutine(GETINFO(player));
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {

            ANTICHEAT aNTICHEAT;
            if (anticheatPlayers.TryGetValue(player, out aNTICHEAT)) aNTICHEAT.DoDestroy();
            if (moders.Contains(player)) moders.Remove(player);
        }

        class Eka
        {
            public Vector3 s;
            public Vector3 t;
        }

        Dictionary<ulong, shoots> _shoots = new Dictionary<ulong, shoots>();

        class shoots
        {
            public int number;
            public int success;
        }

        private void OnWeaponFired(BaseProjectile projectile, BasePlayer player, ItemModProjectile itemModProjectile, ProjectileShoot projectileShoot)
        {
            if (projectile == null || player == null || itemModProjectile == null || projectileShoot == null) return;

            shoots shoots;
            if (!_shoots.TryGetValue(player.userID, out shoots)) _shoots.Add(player.userID, new shoots { number = 1, success = 0 });
            else
            {
                shoots.number += projectileShoot.projectiles.Count;
                _shoots[player.userID] = shoots;
            }

            ANTICHEAT aNTICHEAT;

            if (!anticheatPlayers.TryGetValue(player, out aNTICHEAT) || projectile.primaryMagazine.capacity > projectile.primaryMagazine.definition.builtInSize) return;
            aNTICHEAT.ADDFIRE(projectile.GetItem().info.name);
        }

        private void OnEntityTakeDamage(object entity, HitInfo info)
        {
            if (info == null || info.Weapon == null || info.InitiatorPlayer == null || info.damageTypes != null && info.damageTypes.IsMeleeType()) return;
            if (info.InitiatorPlayer.IsNpc) return;

            shoots shoots;
            if (!_shoots.TryGetValue(info.InitiatorPlayer.userID, out shoots)) return;

            if (!(entity is BasePlayer)) return;
            BasePlayer player = entity as BasePlayer;
            if (player == null || player.IsNpc || !player.IsConnected || player.IsSleeping() || info.InitiatorPlayer == player || player.Team != null && player.Team.members.Contains(info.InitiatorPlayer.userID))
            {
                shoots.number -= 1;
                _shoots[info.InitiatorPlayer.userID] = shoots;
                return;
            }

            shoots.success += 1;
            _shoots[info.InitiatorPlayer.userID] = shoots;

            string weapon = info.WeaponPrefab != null && !string.IsNullOrEmpty(info.WeaponPrefab.ShortPrefabName) ? info.WeaponPrefab.ShortPrefabName : "x";
            string bone = !string.IsNullOrEmpty(info.boneName) ? info.boneName : "x";
            float distance = info.ProjectileDistance;

            if (config.logs) Debug.Log($"-- {info.InitiatorPlayer.displayName}({info.InitiatorPlayer.UserIDString}) [{weapon} | {bone} | {distance.ToString("F1")} m.] => {player.displayName}({player.UserIDString})");

            ANTICHEAT aNTICHEAT;
            if (!anticheatPlayers.TryGetValue(info.InitiatorPlayer, out aNTICHEAT)) return;

            aNTICHEAT.ADDHIT(bone, weapon, distance);

        }

        private bool IsNPC(BasePlayer player)
        {
            if (player is NPCPlayer) return true;
            if (!(player.userID >= 76560000000000000L || player.userID <= 0L)) return true;
            return false;
        }

        [PluginReference] Plugin MultiFighting, Battles, HaxBot, uDiscord;

        private bool IsBattles(ulong userid)
        {
            return Battles != null && Battles.Call<bool>("IsPlayerOnBattle", userid);
        }

        private bool ISSTEAM(Network.Connection connection)
        {
            if (MultiFighting == null) return true;
            return MultiFighting.Call<bool>("IsSteam", connection);
        }

        class tok
        {
            public string key;
            public uint appid;
            public string ticket;
        }
        IEnumerator GETINFO(BasePlayer player)
        {
            yield return new WaitForSeconds(1f);
            if (!player.IsConnected) yield break;
            yield return new WaitForEndOfFrame();
            webrequest.Enqueue($"https://api.steampowered.com/ISteamUser/GetPlayerSummaries/v0002/?key={config.steampi}&steamids={player.UserIDString}&format=json", null, (code, response) =>
            {
                if (response != null && code == 200)
                {
                    if (player.IsConnected)
                    {
                        string steamid = player.UserIDString;
                        string text = messages["debugConnect0"].Replace("{name}", player.displayName).Replace("{steamid}", steamid);
                        bool act = false;
                        INFO iNFO = new INFO();
                        resp sr = JsonConvert.DeserializeObject<resp>(response);
                        int datetime = sr.response.players[0].timecreated ?? 0;
                        DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);
                        DateTime create = epoch.AddSeconds(datetime).AddHours(3);
                        bool steam = ISSTEAM(player.Connection);
                        text += messages["debugConnect1"].Replace("{steam}", (steam ? "Steam" : "No-Steam"));
                        int nastr = sr.response.players[0].profilestate ?? 0;
                        bool ns = ISNASTROEN(nastr);
                        text += messages["debugConnect2"].Replace("{ns}", ns ? (fermensEN ? "Yes" : "Да") : (fermensEN ? "No" : "Нет"));
                        if (!ns && config.kicknenastoyen && !debugmode)
                        {
                            if (!permission.UserHasPermission(steamid, "xanticheat.allow") && !permission.UserHasPermission(steamid, "xanticheat.skip"))
                            {
                                timer.Once(30f, () => player.Kick(GetMessage("KICK.NENASTROYEN", steamid)));
                                act = true;
                            }
                        }
                        if (datetime > 0)
                        {
                            text += messages["debugConnect3"].Replace("{date}", create.ToShortDateString());
                        }
                        else
                        {
                            text += messages["debugConnect4"];
                            if (!steam || !config.steamkick)
                            {
                                if (config.kickprivate && !debugmode && !permission.UserHasPermission(steamid, "xanticheat.allow") && !permission.UserHasPermission(steamid, "xanticheat.skip"))
                                {
                                    timer.Once(30f, () => player.Kick(GetMessage("KICK.PRIVATE", steamid)));
                                    act = true;
                                }
                            }
                        }

                        if (config.show) Debug.Log(text + "\n------------");

                        if (!permission.UserHasPermission(steamid, "xanticheat.allow") && !debugmode && !permission.UserHasPermission(steamid, "xanticheat.skip") && (config.bannensatroyen && nastr != 1 || create.AddDays(config.banday) > DateTime.Now))
                        {
                            if (!act && (!steam || steam && config.steam)) Server.Command(patterban.Replace("{steamid}", steamid).Replace("{reason}", GetMessage("NEW.ACCOUNT", steamid)).Replace("{time}", config.bannewaccountday.ToString()));
                        }
                    }
                }
            }, this);

            yield return new WaitForEndOfFrame();
            //VPN
            if (string.IsNullOrEmpty(config.ipinfotoken) || config.ipinfotoken == ipinfosingup) yield break;
            string[] ip = player.IPlayer.Address.Split(':');
            webrequest.Enqueue(ipinnfourl.Replace("{token}", config.ipinfotoken).Replace("{ip}", ip[0]), null, (code, response) =>
            {
                if (response != null && code == 200)
                {
                    if (!player.IsConnected) return;
                    VPNINFO sr = JsonConvert.DeserializeObject<VPNINFO>(response);
                    bool VPN = sr.vpn;
                    Debug.Log($"[{player.displayName}({player.UserIDString}) | IP: {ip[0]} | VPN: {(VPN ? "Yes" : "No")}]");
                    if (!VPN) return;
                    if (config.kickvpn && !permission.UserHasPermission(player.UserIDString, "xanticheat.allow") && !permission.UserHasPermission(player.UserIDString, "xanticheat.skip"))
                    {
                        timer.Once(30f, () => Server.Command($"kick {player.UserIDString} \"{GetMessage("KICK.VPN", player.UserIDString)}\""));
                    }
                }
            }, this);
            yield break;
        }

        class VPNINFO
        {
            public bool vpn;
            public bool proxy;
            public bool tor;
            public bool hosting;
        }

        private bool ISNASTROEN(int num)
        {
            if (num == 1) return true;
            return false;
        }
    }
}


// --- End of file: XAntiCheat.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/PersonalBeacon.cs ---
// --- Original Local Path: PersonalBeacon.cs ---


using System.Collections.Generic;
using System;
using System.Reflection;
using System.Data;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;

/*
    This is my first plugin, and I'm not very good with C# - so this is probably horrible and I apologize now.  Thanks!
*/

namespace Oxide.Plugins
{
    [Info("PersonalBeacon", "Mordenak", "1.0.7", ResourceId = 1000)]
    class PersonalBeacon : RustPlugin
    {
        // To be moved into config file at some point...
        static int beaconHeight = 500;
        static int arrowSize = 10;
        static float beaconRefresh = 2f;

        static Core.Configuration.DynamicConfigFile BeaconData;
        static Dictionary<string, bool> userBeacons = new Dictionary<string, bool>();
        static Dictionary<string, Oxide.Plugins.Timer> userBeaconTimers = new Dictionary<string, Oxide.Plugins.Timer>();

        static Dictionary<string, bool> adminBeacons = new Dictionary<string, bool>();
        static Dictionary<string, Oxide.Plugins.Timer> adminTimers = new Dictionary<string, Oxide.Plugins.Timer>();

        static Dictionary<string, bool> adminBeaconIsOn = new Dictionary<string, bool>();
        static Dictionary<string, Oxide.Plugins.Timer> adminBeaconTimers = new Dictionary<string, Oxide.Plugins.Timer>();

        void Loaded()
        {
            LoadBeaconData();
        }

        void Unload()
        {
            SaveBeaconData();
            //CleanUpBeacons();
        }

        void OnServerSave()
        {
            SaveBeaconData();
        }

        private void SaveBeaconData()
        {
            Interface.GetMod().DataFileSystem.SaveDatafile("PersonalBeacon_Data");
        }
        private void LoadBeaconData()
        {
            //Debug.Log("Loading data...");
            try
            {
                //BeaconData = Interface.GetMod().DataFileSystem.ReadObject<Oxide.Core.Configuration.DynamicConfigFile>("PersonalBeacon_Data");
                BeaconData = Interface.GetMod().DataFileSystem.GetDatafile("PersonalBeacon_Data");
            }
            catch
            {
                Debug.Log("Failed to load datafile.");
            }
            //Debug.Log("Data should be loaded.");
        }
  
        void DisplayBeacon(BasePlayer player)
        {
            var playerId = player.userID.ToString();
            // player has disconnected
            if (!player.IsConnected())
            {
                Debug.Log("Cleaning up disconnected player timer.");
                userBeacons[playerId] = false;
                userBeaconTimers[playerId].Destroy();
                return;
            }

            if (BeaconData == null)
            {
                Debug.Log("BeaconData wasn't loaded before use, forcing load.");
                LoadBeaconData();
            }
            if (BeaconData[playerId] == null)
            {
                Debug.Log(string.Format("Player [{0}] -- BeaconData is corrupt.", playerId) );
                userBeacons[playerId] = false;
                userBeaconTimers[playerId].Destroy();
                return;
                /*
                foreach (var playerbeacons in BeaconData)
                {
                    Debug.Log(playerbeacons.ToString());
                }
                */
            }

            var table = BeaconData[playerId] as Dictionary<string, object>;
            //var beaconGround = new Vector3((float)table["x"], (float)table["y"], (float)table["z"]);
            var beaconGround = new Vector3();
            // Necessary evil here
            beaconGround.x = float.Parse(table["x"].ToString());
            beaconGround.y = float.Parse(table["y"].ToString());
            beaconGround.z = float.Parse(table["z"].ToString());

            var beaconSky = beaconGround;
            beaconSky.y = beaconSky.y + beaconHeight;

            player.SendConsoleCommand("ddraw.arrow", beaconRefresh, UnityEngine.Color.red, beaconGround, beaconSky, arrowSize);
        }

        [ChatCommand("setwp")]
        void cmdSetBeacon(BasePlayer player, string command, string[] args)
        {
            Dictionary<string, object> coords = new Dictionary<string, object>();
            coords.Add("x", player.transform.position.x);
            coords.Add("y", player.transform.position.y);
            coords.Add("z", player.transform.position.z);

            if (BeaconData == null)
            {
                Debug.Log("BeaconData wasn't loaded before use, forcing load.");
                LoadBeaconData();
            }

            BeaconData[player.userID.ToString()] = coords;

            var newVals = BeaconData[player.userID.ToString()] as Dictionary<string, object>;

            SendReply(player, string.Format("Beacon set to: x: {0}, y: {1}, z: {2}", newVals["x"], newVals["y"], newVals["z"]) );
        }

        [ChatCommand("wp")]
        void cmdBeacon(BasePlayer player, string command, string[] args)
        {

            if (BeaconData == null)
            {
                Debug.Log("BeaconData wasn't loaded before use, forcing load.");
                LoadBeaconData();
            }

            var playerId = player.userID.ToString();

            if (BeaconData[playerId] == null)
            {
                SendReply(player, "You have not set a waypoint yet.  Please run /setwp to create a waypoint.");
                Debug.Log(string.Format("Player [{0}] -- BeaconData is corrupt or non-existent.", playerId) );
                return;
                /*
                foreach (var playerbeacons in BeaconData)
                {
                    Debug.Log(playerbeacons.ToString());
                }
                */
            }
            if (!userBeacons.ContainsKey(playerId)) userBeacons.Add(playerId, false);

            // maybe unecessary
            if (userBeacons[playerId] == null) userBeacons[playerId] = false;

            if (userBeacons[playerId] == false)
            {
                DisplayBeacon(player); // display immediately
                userBeaconTimers[playerId] = timer.Repeat(beaconRefresh, 0, delegate() { DisplayBeacon(player); } );
                SendReply(player, "Beacon on.");
                userBeacons[playerId] = true;
            }
            else
            {
                userBeaconTimers[playerId].Destroy();
                SendReply(player, "Beacon off.");
                userBeacons[playerId] = false;
            }
        }

        // Admin commands:

        [ChatCommand("wpadmin")]
        void cmdAdminWaypoint(BasePlayer player, string command, string[] args)
        {
            if (player.net.connection.authLevel == 0) return;

            // set a wp at the current location
            var currLocation = player.transform.position;

            var playerId = player.userID.ToString();

            if (!adminBeaconIsOn.ContainsKey(playerId)) adminBeaconIsOn.Add(playerId, false);
            if (adminBeaconIsOn[playerId] == null) adminBeaconIsOn[playerId] = false;

            //var repeatBeacon = new Dictionary<string, Oxide.Plugins.Timer>();

            if (adminBeaconIsOn[playerId] == false)
            {
                SendReply(player, "Sending Admin Waypoint to all players.");
                adminBeaconTimers[playerId] = timer.Repeat(beaconRefresh, 0, delegate() {
                    var beaconGround = currLocation;

                    var beaconSky = beaconGround;
                    beaconSky.y = beaconSky.y + beaconHeight;
                    ConsoleSystem.Broadcast("ddraw.arrow", beaconRefresh, UnityEngine.Color.green, beaconGround, beaconSky, arrowSize);
                } );
                adminBeaconIsOn[playerId] = true;
            }
            else
            {
                SendReply(player, "Removing the Admin Waypoint.");
                foreach (var adbeacontimers in adminBeaconTimers)
                {
                    adbeacontimers.Value.Destroy();
                }
                adminBeaconIsOn[playerId] = false;
            }
        }

        [ChatCommand("wpcount")]
        void cmdCountBeacons(BasePlayer player, string command, string[] args)
        {
            if (player.net.connection.authLevel == 0) return;
            int wpCount = 0;
            foreach (var playerbeacons in BeaconData)
            {
                //Debug.Log(playerbeacons.ToString());
                wpCount = wpCount + 1;
            }
            //Debug.Log(string.Format("Found {0} waypoints.", wpCount) );
            SendReply(player, string.Format("Tracking {0} waypoints.", wpCount) );
        }

        [ChatCommand("wpshowall")]
        void cmdShowAllBeacons(BasePlayer player, string command, string[] args)
        {
            if (player.net.connection.authLevel == 0) return;
            var playerId = player.userID.ToString();
            if (!adminBeacons.ContainsKey(playerId)) adminBeacons.Add(playerId, false);
            if (adminBeacons[playerId] == null) adminBeacons[playerId] = false;
            if (adminBeacons[playerId] == false)
            {
                foreach (var playerbeacons in BeaconData)
                {
                    //Debug.Log(string.Format("Looking for beacon for player: {0}", playerbeacons.Key) );

                    var targetId = playerbeacons.Key;

                    var table = BeaconData[targetId] as Dictionary<string, object>;
                    //var beaconGround = new Vector3((float)table["x"], (float)table["y"], (float)table["z"]);
                    var beaconGround = new Vector3();
                    // Necessary evil here
                    beaconGround.x = float.Parse(table["x"].ToString());
                    beaconGround.y = float.Parse(table["y"].ToString());
                    beaconGround.z = float.Parse(table["z"].ToString());

                    var beaconSky = beaconGround;
                    beaconSky.y = beaconSky.y + beaconHeight;
                    player.SendConsoleCommand("ddraw.arrow", beaconRefresh, UnityEngine.Color.red, beaconGround, beaconSky, arrowSize);
                    adminTimers[targetId] = timer.Repeat(beaconRefresh, 0, delegate() { player.SendConsoleCommand("ddraw.arrow", beaconRefresh, UnityEngine.Color.red, beaconGround, beaconSky, arrowSize);; } );

                    //player.SendConsoleCommand("ddraw.arrow", 10f, UnityEngine.Color.red, beaconGround, beaconSky, 10);
                }
                SendReply(player, "All beacons on.");
                adminBeacons[playerId] = true;
            }
            else
            {
                foreach (var playerdata in BeaconData)
                {
                    adminTimers[playerdata.Key].Destroy();
                }
                //adminTimers[targetId].Destroy();
                SendReply(player, "All beacons off.");
                adminBeacons[playerId] = false;
            }
        }

        [HookMethod("SendHelpText")]
        private void SendHelpText(BasePlayer player) 
        {
            var helpString = "<color=#11FF22>PersonalBeacon</color>:\n/setwp - Sets the beacon to the current location.\n/wp - Toggles beacon on or off.";
            player.ChatMessage(helpString.TrimEnd());
        }
    }
}

// --- End of file: PersonalBeacon.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/FurnaceSort.cs ---
// --- Original Local Path: FurnaceSort.cs ---

﻿using Oxide.Core;
using System.Collections.Generic;
using System.Linq;
using System;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("FurnaceSort", "bazuka5801", "1.2.0")]
    class FurnaceSort : RustPlugin
    {
        #region FIELDS

        List<ulong> usePlayers = new List<ulong>();
        static List<ulong> activePlayers = new List<ulong>();
        Dictionary<BaseOven, BasePlayer> ovens = new Dictionary<BaseOven, BasePlayer>();

        private string furnacePanelMin = "0.895 0.42";
        private string furnacePanelMax = "0.945 0.46";
        private string furnaceTextMin = "0.65 0.42";
        private string furnaceTextMax = "0.89 0.46";

        private string furnaceBigPanelMin = "0.895 0.52";
        private string furnaceBigPanelMax = "0.945 0.56";
        private string furnaceBigTextMin = "0.65 0.42";
        private string furnaceBigTextMax = "0.89 0.46";


        #endregion

        #region OXIDE HOOKS

        void OnServerInitialized()
        {
            LoadDefaultConfig();
            LoadData();
        }

        void Unload()
        {
            SaveData();
            foreach (var dest in UnityEngine.Object.FindObjectsOfType<UIDestroyer>())
            {
                dest.Dest();
            }
        }


        void OnLootEntity(BasePlayer player, BaseEntity lootable)
        {
            if (player == null || lootable == null) return;
            var furnace = lootable.GetComponent<BaseOven>();
            if (furnace == null || !furnace.name.Contains("furnace")) return;

            DrawUI(player, furnace.ShortPrefabName != "furnace");
        }

        void DrawUI(BasePlayer player, bool bigFurnace = false)
        {
            bool use = usePlayers.Contains(player.userID);
            var container = new CuiElementContainer
            {
                {
                    new CuiPanel()
                    {
                        RectTransform = {AnchorMin = bigFurnace ? furnaceBigPanelMin : furnacePanelMin, AnchorMax =bigFurnace ? furnaceBigPanelMax : furnacePanelMax},
                        Image = new CuiImageComponent() {Color = "0 0 0 0"}
                    },
                    "Overlay", "furnacesort"
                },
                {
                    new CuiLabel()
                    {
                        RectTransform = {AnchorMin = bigFurnace ? furnaceBigTextMin : furnaceTextMin, AnchorMax = bigFurnace ? furnaceBigTextMax : furnaceTextMax},
                        Text =
                        {
                            Text = "Автоматическая сортировка печек:",
                            FontSize = 16,
                            Align = TextAnchor.MiddleRight
                        }
                    },
                    "Overlay", "furnacesort.lbl"
                },
                {
                    new CuiButton()
                    {
                        Button = {Command = "furnacesort.switch", Color = use ? "0.62 0.18 0.18 1" : "0.4 0.66 0.2 1"},
                        RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
                        Text = {Align = TextAnchor.MiddleCenter, Text = use ? "[OFF]" : "[ON]"}
                    },
                    "furnacesort", "furnacesort.switchbtn"
                }
            };
            CuiHelper.AddUi(player, container);
            var uiDestroyer = player.inventory.loot.entitySource.gameObject.AddComponent<UIDestroyer>();
            uiDestroyer.player = player;
            activePlayers.Add(player.userID);
            ovens[(BaseOven)player.inventory.loot.entitySource] = player;
        }

        private bool work = false;

        void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            if (work || item == null) return;
            work = true;
            var oven = container.entityOwner as BaseOven;
            if (oven == null)
            {
                work = false;
                return;
            }
            BasePlayer player;
            if (!ovens.TryGetValue(oven, out player))
            {
                work = false;
                return;
            }
            if (!usePlayers.Contains(player.userID))
            {
                work = false;
                return;
            }
            if (!(item.info.shortname == "sulfur.ore" || item.info.shortname == "metal.ore" ||
                  item.info.shortname == "hq.metal.ore"))
            {
                work = false;
                return;
            }
            int i1 = container.GetAmount(3655341, false) > 0 ? 0 : 1;
            int i2 = container.GetAmount(1436001773, false) > 0 ? 0 : 1;
            var max = container.capacity - container.itemList.Count - i1 - i2;
            if (max == 0)
            {
                work = false;
                return;
            }
            if (item.amount < max)
            {
                work = false;
                return;
            }
            int cellAmount = item.amount / max;
            for (int j = 1; j < max; j++)
            {
                var it = item.SplitItem(cellAmount);
                if (!it.MoveToContainer(container, -1, false))
                {
                    it.MoveToContainer(player.inventory.containerMain);
                }
            }
            work = false;
        }


        [ConsoleCommand("furnacesort.switch")]
        void cmdSwitch(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            if (usePlayers.Contains(player.userID))
            {
                usePlayers.Remove(player.userID);
            }
            else
            {
                usePlayers.Add(player.userID);
            }
            player.inventory.loot.entitySource.GetComponent<UIDestroyer>().Dest();
            DrawUI(player, player.inventory.loot?.entitySource?.ShortPrefabName != "furnace");
        }

        class UIDestroyer : MonoBehaviour
        {
            public BasePlayer player;
            void PlayerStoppedLooting(BasePlayer player)
            {
                CuiHelper.DestroyUi(player, "furnacesort.lbl");
                CuiHelper.DestroyUi(player, "furnacesort.switchbtn");
                CuiHelper.DestroyUi(player, "furnacesort");
                activePlayers.Remove(player.userID);
                Destroy(this);
            }

            public void Dest()
            {
                CuiHelper.DestroyUi(player, "furnacesort.lbl");
                CuiHelper.DestroyUi(player, "furnacesort.switchbtn");
                CuiHelper.DestroyUi(player, "furnacesort");
                activePlayers.Remove(player.userID);
                Destroy(this);
            }
        }

        #endregion

        #region CORE

        #endregion

        #region DATA

        private DynamicConfigFile saveFile = Interface.Oxide.DataFileSystem.GetFile("FurnaceSort");


        void LoadData()
        {
            usePlayers = saveFile.ReadObject<List<ulong>>() ?? new List<ulong>();
        }

        void OnServerSave()
        {
            SaveData();
        }

        void SaveData()
        {
            saveFile.WriteObject(usePlayers);
        }

        #endregion
    }
}

// --- End of file: FurnaceSort.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NoAdminOwnership.cs ---
// --- Original Local Path: NoAdminOwnership.cs ---

using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("NoAdminOwnership", "k1lly0u", "0.1.3", ResourceId = 2019)]
    class NoAdminOwnership : RustPlugin
    {
        #region Fields
        private List<ulong> itemOwnerDebug = new List<ulong>();
        private bool Initialized = false;
        #endregion

        #region Oxide Hooks
        void Loaded()
        {
            permission.RegisterPermission("noadminownership.ignore", this);
            lang.RegisterMessages(messages, this);
        }
        void OnServerInitialized()
        {
            LoadVariables();
            Initialized = true;
        }
        void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            if (!Initialized) return;
            var player = container.playerOwner;
            if (player == null) return;
            if (ignoreUser(player))
            {
                RemoveOwner(player.userID, item);
                if (isDebug(player))
                    PrintOwnership(player, item);
            }
        }
        void OnItemRemovedFromContainer(ItemContainer container, Item item)
        {
            if (!Initialized) return;
            var player = container.playerOwner;            
            if (player == null) return;
            if (ignoreUser(player))
            {
                RemoveOwner(player.userID, item);
                if (isDebug(player))
                    PrintOwnership(player, item);
            }
        }
       
        void RemoveOwner(ulong ID, Item item)
        {
            if (item.owners == null || item.owners.Count == 0) return;            
            else
            {
                foreach (var owner in item.owners)
                {
                    if (owner.userid == ID)
                    {
                        item.owners.Remove(owner);
                        return;
                    }
                }
            }
        }
        public void PrintOwnership(BasePlayer player, Item item)
        {
            SendReply(player, (string.Concat(MSG("owners", player.UserIDString), item.info.shortname)));
            float single = 0f;
            for (int i = 0; i < item.owners.Count; i++)
            {
                Item.OwnerFraction items = item.owners[i];
                SendReply(player, (string.Concat(items.player.displayName ?? items.userid.ToString(), ":", items.fraction)));
                single = single + items.fraction;
            }
            SendReply(player, (string.Concat(MSG("fracts", player.UserIDString), single)));
        }
        #endregion

        #region Functions
        private bool isAllowed(BasePlayer player)
        {
            var auth = player?.net?.connection?.authLevel ?? 0;
            if (auth >= 0) return true;            
            if (permission.UserHasPermission(player.UserIDString, "noadminownership.ignore")) return true;
            return false;
        }
        private bool ignoreUser(BasePlayer player)
        {
            var auth = player?.net?.connection?.authLevel ?? 0;
            if (configData.IgnoreAuth2 && auth == 2) return true;
            if (configData.IgnoreAuth1 && auth == 1) return true;
            if (configData.IgnoreUsingPermission && permission.UserHasPermission(player.UserIDString, "noadminownership.ignore")) return true;
            return false;
        }
        private bool isDebug(BasePlayer player) => itemOwnerDebug.Contains(player.userID);
        #endregion

        #region Chat Command
        [ChatCommand("ownership")]
        private void cmdOwnership(BasePlayer player, string command, string[] args)
        {
            if (isAllowed(player))
            {
                if (!itemOwnerDebug.Contains(player.userID))
                {
                    itemOwnerDebug.Add(player.userID);
                    SendReply(player, MSG("debugActive", player.UserIDString));
                }
                else
                {
                    itemOwnerDebug.Remove(player.userID);
                    SendReply(player, MSG("debugDeactive", player.UserIDString));
                }
            }
        }
        #endregion

        #region Messages
        private string MSG(string key, string ID = null) => lang.GetMessage(key, this, ID);
        Dictionary<string, string> messages = new Dictionary<string, string>
        {
            {"debugActive", "Ownership debug activated" },
            {"debugDeactive", "Ownership debug de-activated" },
            {"owners", "Owners for :" },
            {"fracts", " Total fraction: " }
        };
        #endregion

        #region Config        
        private ConfigData configData;
        class ConfigData
        {
            public bool IgnoreAuth2 { get; set; }
            public bool IgnoreAuth1 { get; set; }
            public bool IgnoreUsingPermission { get; set; }
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                IgnoreAuth1 = true,
                IgnoreAuth2 = true,
                IgnoreUsingPermission = false,
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion       
    }
}


// --- End of file: NoAdminOwnership.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/MiniCopterOptions.cs ---
// --- Original Local Path: MiniCopterOptions.cs ---

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Mini-Copter Options", "Pho3niX90", "2.5.1")]
    [Description("Provide a number of additional options for Mini-Copters, including storage and seats.")]
    internal class MiniCopterOptions : CovalencePlugin
    {
        #region Fields

        private readonly string minicopterPrefab = "assets/content/vehicles/minicopter/minicopter.entity.prefab";
        private readonly string storagePrefab = "assets/prefabs/deployable/hot air balloon/subents/hab_storage.prefab";
        private readonly string storageLargePrefab = "assets/content/vehicles/boats/rhib/subents/rhib_storage.prefab";
        private readonly string autoturretPrefab = "assets/prefabs/npc/autoturret/autoturret_deployed.prefab";
        private readonly string switchPrefab = "assets/prefabs/deployable/playerioents/simpleswitch/switch.prefab";
        private readonly string searchLightPrefab = "assets/prefabs/deployable/search light/searchlight.deployed.prefab";
        private readonly string flasherBluePrefab = "assets/prefabs/deployable/playerioents/lights/flasherlight/electric.flasherlight.deployed.prefab";
        private readonly string spherePrefab = "assets/prefabs/visualization/sphere.prefab";

        private const string resizableLootPanelName = "generic_resizable";
        private const int MinStorageCapacity = 6;
        private const int MaxStorageCapacity = 48;

        private static readonly Vector3 TurretSwitchPosition = new Vector3(0, 0.36f, 0.32f);

        private readonly object False = false;

        private Configuration config;
        private MiniCopterDefaults copterDefaults;
        private bool lastRanAtNight;
        private int setupTimeHooksAttempts;
        private TOD_Sky time;
        private float sunrise;
        private float sunset;
        private float lastNightCheck;
        private float[] stageFuelPerSec = new float[1];
        private float[] stageLiftFraction = new float[1];

        #endregion

        #region Hooks

        private void Init()
        {
            if (config.storageContainers > 3)
            {
                PrintWarning($"Storage Containers configuration value {config.storageContainers} exceeds the maximum, setting to 3.");
                config.storageContainers = 3;
            }
            else if (config.storageContainers < 0)
            {
                PrintWarning($"Storage Containers cannot be a negative value, setting to 0.");
                config.storageContainers = 0;
            }

            if (config.storageLargeContainers > 2)
            {
                PrintWarning($"Large Storage Containers configuration value {config.storageLargeContainers} exceeds the maximum, setting to 2.");
                config.storageLargeContainers = 2;
            }
            else if (config.storageLargeContainers < 0)
            {
                PrintWarning($"Large Storage Containers cannot be a negative value, setting to 0.");
                config.storageLargeContainers = 0;
            }

            if (config.largeStorageSize > MaxStorageCapacity)
            {
                PrintWarning($"Large Storage Containers Capacity configuration value {config.largeStorageSize} exceeds the maximum, setting to {MaxStorageCapacity}.");
                config.largeStorageSize = MaxStorageCapacity;
            }
            else if (config.largeStorageSize < MinStorageCapacity)
            {
                PrintWarning($"Storage Containers Capacity cannot be a smaller than {MinStorageCapacity}, setting to {MinStorageCapacity}.");
            }

            Unsubscribe(nameof(OnEntitySpawned));

            if (!config.autoturret)
            {
                Unsubscribe(nameof(OnTurretTarget));
            }
        }

        private void OnServerInitialized(bool init)
        {
            StoreMiniCopterDefaults();

            if (config.lightTail)
            {
                SetupTimeHooks();
            }

            if (!config.addSearchLight)
            {
                Unsubscribe(nameof(OnServerCommand));
            }

            foreach (var copter in BaseNetworkable.serverEntities.OfType<Minicopter>())
            {
                if (init)
                {
                    // Destroy problematic components immediately on server boot, since OnEntitySpawned will run changes on a delay.
                    foreach (var meshCollider in copter.GetComponentsInChildren<MeshCollider>())
                    {
                        UnityEngine.Object.DestroyImmediate(meshCollider);
                    }

                    foreach (var groundWatch in copter.GetComponentsInChildren<GroundWatch>())
                    {
                        UnityEngine.Object.DestroyImmediate(groundWatch);
                    }
                }

                OnEntitySpawned(copter);
            }

            Subscribe(nameof(OnEntitySpawned));
        }

        private void Unload()
        {
            if (config.lightTail && time != null)
            {
                time.Components.Time.OnHour -= OnHour;
            }

            // If the plugin is unloaded before OnServerInitialized() ran, don't revert minicopters to 0 values.
            if (copterDefaults != null)
            {
                foreach (var copter in BaseNetworkable.serverEntities.OfType<Minicopter>())
                {
                    if (config.restoreDefaults && CanModifyMiniCopter(copter))
                    {
                        RestoreMiniCopter(copter, config.reloadStorage);
                    }
                }
            }
        }

        private void OnEntitySpawned(Minicopter copter)
        {
            // Only add storage on spawn so we don't stack or mess with
            // existing player storage containers.
            ScheduleModifyMiniCopter(copter);
        }

        private void OnEntityKill(BaseNetworkable entity)
        {
            if (!config.dropStorage || !(entity is Minicopter))
                return;

            var containers = entity.GetComponentsInChildren<StorageContainer>();
            foreach (var container in containers)
            {
                container.DropItems();
            }

            var turrets = entity.GetComponentsInChildren<AutoTurret>();
            foreach (var turret in turrets)
            {
                turret.DropItems();
            }
        }

        private void OnSwitchToggled(ElectricSwitch electricSwitch, BasePlayer player)
        {
            var turret = electricSwitch.GetParentEntity() as AutoTurret;
            if (turret == null)
                return;

            var mini = turret.GetParentEntity() as Minicopter;
            if (mini == null)
            {
                // Ignore if the turret isn't on a mini, to avoid plugin conflicts.
                return;
            }

            if (electricSwitch.IsOn())
            {
                turret.SetFlag(IOEntity.Flag_HasPower, true);
                turret.InitiateStartup();
            }
            else
            {
                turret.SetFlag(IOEntity.Flag_HasPower, false);
                turret.InitiateShutdown();
            }
        }

        private object OnTurretTarget(AutoTurret turret, BaseCombatEntity target)
        {
            if (target == null)
                return null;

            var mini = turret.GetParentEntity() as Minicopter;
            if ((object)mini == null)
                return null;

            if (!config.autoTurretTargetsAnimals && target is BaseAnimalNPC)
                return False;

            var basePlayer = target as BasePlayer;
            if ((object)basePlayer != null)
            {
                if (!config.autoTurretTargetsNPCs && basePlayer.IsNpc)
                    return False;

                if (!config.autoTurretTargetsPlayers && basePlayer.userID.IsSteamId())
                    return False;

                if (basePlayer.InSafeZone() && (basePlayer.IsNpc || !basePlayer.IsHostile()))
                    return False;
            }

            return null;
        }

        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null || arg.cmd.FullName != "inventory.lighttoggle")
                return null;

            var player = arg.Player();
            if (player == null)
                return null;

            var mini = player.GetMountedVehicle() as Minicopter;
            if (mini == null)
                return null;

            if (!mini.IsDriver(player))
                return null;

            foreach (var child in mini.children)
            {
                var sphere = child as SphereEntity;
                if ((object)sphere == null)
                    continue;

                foreach (var grandChild in sphere.children)
                {
                    var light = grandChild as SearchLight;
                    if ((object)light == null)
                        continue;

                    light.SetFlag(IOEntity.Flag_HasPower, !light.IsPowered());

                    // Prevent other lights from toggling.
                    return False;
                }
            }

            return null;
        }

        private void OnEntityDismounted(BaseNetworkable entity, BasePlayer player)
        {
            if (config.flyHackPause > 0 && entity.GetParentEntity() is Minicopter)
            {
                player.PauseFlyHackDetection(config.flyHackPause);
            }
        }

        private void OnItemDeployed(Deployer deployer, StorageContainer container, BaseLock baseLock)
        {
            if (container == null || baseLock == null)
                return;

            var parent = container.GetParentEntity();
            if (parent == null || !(parent is Minicopter))
                return;

            if (container.PrefabName != storageLargePrefab)
                return;

            baseLock.transform.localPosition = new Vector3(0.0f, 0.3f, 0.298f);
            baseLock.transform.localRotation = Quaternion.Euler(new Vector3(0, 90, 0));
            baseLock.SendNetworkUpdateImmediate();
        }

        // When another plugin wants to modify a specific property, adjust the proposed value, using the delta between
        // the vanilla default and the configured value.
        private void OnMinicopterFuelPerSecChange(Plugin plugin, Minicopter copter, float[] fuelPerSec)
        {
            if (plugin.Name == nameof(MiniCopterOptions)
                || copterDefaults == null
                || config.fuelPerSec < 0
                || !CanModifyMiniCopter(copter))
                return;

            // For example, vanilla is 0.5, configured is 0.1, so multiply by 0.2.
            fuelPerSec[0] *= config.fuelPerSec / copterDefaults.fuelPerSec;
        }

        private void OnMinicopterLiftFractionChange(Plugin plugin, Minicopter copter, float[] liftFraction)
        {
            if (plugin.Name == nameof(MiniCopterOptions)
                || copterDefaults == null
                || config.liftFraction < 0
                || !CanModifyMiniCopter(copter))
                return;

            // For example, vanilla is 0.25, configured is 0.5, so multiply by 2.
            liftFraction[0] *= config.liftFraction / copterDefaults.liftFraction;
        }

        #endregion

        #region Exposed Hooks

        private static class ExposedHooks
        {
            public static object OnMiniCopterOptions(Minicopter copter)
            {
                return Interface.CallHook("OnMiniCopterOptions", copter);
            }

            public static object OnMinicopterFuelPerSecChange(Plugin plugin, Minicopter copter, float[] fuelPerSec)
            {
                return Interface.CallHook("OnMinicopterFuelPerSecChange", plugin, copter, fuelPerSec);
            }

            public static object OnMinicopterLiftFractionChange(Plugin plugin, Minicopter copter, float[] liftFraction)
            {
                return Interface.CallHook("OnMinicopterLiftFractionChange", plugin, copter, liftFraction);
            }
        }

        #endregion

        #region Helpers

        private bool IsNight()
        {
            if (time == null)
                return false;

            var hour = time.Cycle.Hour;
            return hour > sunset || hour < sunrise;
        }

        private void OnHour()
        {
            var hour = time.Cycle.Hour;
            var isNight = IsNight();

            //Puts($"OnHour: hour is now {hour}, and it is night {isNight}");
            if ((isNight == lastRanAtNight) || (lastNightCheck == hour))
                return;

            //Puts($"OnHour Called: Night:{isNight} LastRanAtNight:{lastRanAtNight}");
            lastNightCheck = hour;

            var minis = BaseNetworkable.serverEntities.OfType<Minicopter>().ToArray();
            //Puts($"OnHour Called: Minis to modify {minis.Count}");\
            foreach (var mini in minis)
            {
                var tailLight = mini.GetComponentInChildren<FlasherLight>();
                if (tailLight != null)
                {
                    tailLight.SetFlag(IOEntity.Flag_HasPower, isNight);
                }
            }

            lastRanAtNight ^= true;
        }

        private void SetupTimeHooks()
        {
            time = TOD_Sky.Instance;

            if (time == null)
            {
                if (setupTimeHooksAttempts++ >= 10)
                {
                    PrintError("Unable to detect time system. Tail light will not follow time of day.");;
                    return;
                }

                timer.Once(1, SetupTimeHooks);
                return;
            }

            sunrise = time.SunriseTime;
            sunset = time.SunsetTime;

            time.Components.Time.OnHour += OnHour;
        }

        private StorageContainer[] GetStorage(Minicopter copter)
        {
            return copter.GetComponentsInChildren<StorageContainer>()
                .Where(x => x.name == storagePrefab || x.name == storageLargePrefab)
                .ToArray();
        }

        private void AddLargeStorageBox(Minicopter copter)
        {
            if (config.storageLargeContainers == 1)
            {
                AddStorageBox(copter, storageLargePrefab, new Vector3(0.0f, 0.07f, -1.05f), Quaternion.Euler(0, 180f, 0));
            }
            else if (config.storageLargeContainers >= 2)
            {
                AddStorageBox(copter, storageLargePrefab, new Vector3(-0.48f, 0.07f, -1.05f), Quaternion.Euler(0, 180f, 0));
                AddStorageBox(copter, storageLargePrefab, new Vector3(0.48f, 0.07f, -1.05f), Quaternion.Euler(0, 180f, 0));
            }

        }

        private void AddRearStorageBox(Minicopter copter)
        {
            AddStorageBox(copter, storagePrefab, new Vector3(0, 0.75f, -1f));
        }

        private void AddSideStorageBoxes(Minicopter copter)
        {
            AddStorageBox(copter, storagePrefab, new Vector3(0.6f, 0.24f, -0.35f));
            AddStorageBox(copter, storagePrefab, new Vector3(-0.6f, 0.24f, -0.35f));
        }

        private void AddStorageBox(Minicopter copter, string prefab, Vector3 position)
        {
            AddStorageBox(copter, prefab, position, Quaternion.identity);
        }

        private void SetupStorage(StorageContainer box)
        {
            if (box.PrefabName.Equals(storageLargePrefab))
            {
                box.isLockable = config.largeStorageLockable;
                box.inventory.capacity = config.largeStorageSize;
                box.panelName = resizableLootPanelName;
            }
        }

        private void AddStorageBox(Minicopter copter, string prefab, Vector3 position, Quaternion rotation)
        {
            var box = GameManager.server.CreateEntity(prefab, position, rotation) as StorageContainer;
            if (box == null)
                return;

            box.Spawn();
            box.SetParent(copter);

            SetupStorage(box);
            box.SendNetworkUpdateImmediate();
        }

        private void SetupInvincibility(BaseCombatEntity entity)
        {
            entity._maxHealth = 99999999f;
            entity._health = 99999999f;
            entity.SendNetworkUpdate();
        }

        private void SetupTailLight(FlasherLight tailLight)
        {
            tailLight.pickup.enabled = false;
            DestroyGroundComp(tailLight);
            tailLight.SetFlag(IOEntity.Flag_HasPower, IsNight());
        }

        private void AddTailLight(Minicopter copter)
        {
            var tailLight = GameManager.server.CreateEntity(flasherBluePrefab, new Vector3(0, 1.2f, -2.0f), Quaternion.Euler(33, 180, 0)) as FlasherLight;
            if (tailLight == null)
                return;

            SetupTailLight(tailLight);
            tailLight.SetParent(copter);
            tailLight.Spawn();
            SetupInvincibility(tailLight);
        }

        private void SetupSphereEntity(SphereEntity sphereEntity)
        {
            sphereEntity.EnableSaving(true);
            sphereEntity.EnableGlobalBroadcast(false);
        }

        private void SetupSearchLight(SearchLight searchLight)
        {
            searchLight.pickup.enabled = false;
            DestroyMeshCollider(searchLight);
            DestroyGroundComp(searchLight);
        }

        private void AddSearchLight(Minicopter copter)
        {
            var sphereEntity = GameManager.server.CreateEntity(spherePrefab, new Vector3(0, -100, 0), Quaternion.identity) as SphereEntity;
            if (sphereEntity == null)
                return;

            SetupSphereEntity(sphereEntity);
            sphereEntity.SetParent(copter);
            sphereEntity.Spawn();

            var searchLight = GameManager.server.CreateEntity(searchLightPrefab, sphereEntity.transform.position) as SearchLight;
            if (searchLight == null)
                return;

            SetupSearchLight(searchLight);
            searchLight.Spawn();
            SetupInvincibility(searchLight);
            searchLight.SetFlag(BaseEntity.Flags.Reserved5, true);
            searchLight.SetFlag(BaseEntity.Flags.Busy, true);
            searchLight.SetParent(sphereEntity);
            searchLight.transform.localPosition = Vector3.zero;
            searchLight.transform.localRotation = Quaternion.Euler(-20, 180, 180);

            sphereEntity.currentRadius = 0.1f;
            sphereEntity.lerpRadius = 0.1f;
            sphereEntity.UpdateScale();
            sphereEntity.SendNetworkUpdateImmediate();

            timer.Once(3f, () =>
            {
                if (sphereEntity != null)
                {
                    sphereEntity.transform.localPosition = new Vector3(0, 0.24f, 1.8f);
                }
            });
        }

        private void SetupAutoTurret(AutoTurret turret)
        {
            turret.pickup.enabled = false;
            turret.sightRange = config.turretRange;
            DestroyMeshCollider(turret);
            DestroyGroundComp(turret);
        }

        private void AddTurret(Minicopter copter)
        {
            var turret = GameManager.server.CreateEntity(autoturretPrefab, new Vector3(0, 0, 2.47f)) as AutoTurret;
            if (turret == null)
                return;

            SetupAutoTurret(turret);
            turret.SetParent(copter);
            turret.Spawn();

            var player = BasePlayer.FindByID(copter.OwnerID);
            if (player != null)
            {
                turret.authorizedPlayers.Add(new ProtoBuf.PlayerNameID
                {
                    userid = player.userID,
                    username = player.displayName,
                });
                turret.SendNetworkUpdate();
            }

            AddSwitch(turret);
        }

        private void SetupSwitch(ElectricSwitch electricSwitch)
        {
            electricSwitch.pickup.enabled = false;
            DestroyMeshCollider(electricSwitch);
            DestroyGroundComp(electricSwitch);

            if (electricSwitch.HasParent())
            {
                var transform = electricSwitch.transform;
                if (transform.localPosition != TurretSwitchPosition)
                {
                    transform.localPosition = TurretSwitchPosition;
                    electricSwitch.InvalidateNetworkCache();
                    electricSwitch.SendNetworkUpdate_Position();
                }
            }
        }

        private void AddSwitch(AutoTurret turret)
        {
            var switchPosition = turret.transform.TransformPoint(TurretSwitchPosition);
            var switchRotation = turret.transform.rotation;

            var electricSwitch = GameManager.server.CreateEntity(switchPrefab, switchPosition, switchRotation) as ElectricSwitch;
            if (electricSwitch != null)
            {
                SetupSwitch(electricSwitch);
                electricSwitch.Spawn();
                SetupInvincibility(electricSwitch);

                // Spawning the switch at the desired world position and then parenting it, allows it to render correctly initially.
                electricSwitch.SetParent(turret, worldPositionStays: true);
            }
        }

        private void DestroyGroundComp(BaseEntity ent)
        {
            UnityEngine.Object.DestroyImmediate(ent.GetComponent<DestroyOnGroundMissing>());
            UnityEngine.Object.DestroyImmediate(ent.GetComponent<GroundWatch>());
        }

        private void DestroyMeshCollider(BaseEntity ent)
        {
            foreach (var mesh in ent.GetComponentsInChildren<MeshCollider>())
            {
                UnityEngine.Object.DestroyImmediate(mesh);
            }
        }

        private void RestoreMiniCopter(Minicopter copter, bool removeStorage = false)
        {
            if (copterDefaults != null)
            {
                var proposedFuelPerSec = copterDefaults.fuelPerSec;
                if (config.fuelPerSec >= 0 && CanModifyFuelPerSec(copter, ref proposedFuelPerSec))
                {
                    copter.fuelPerSec = proposedFuelPerSec;
                }

                var proposedLiftFraction = copterDefaults.liftFraction;
                if (config.liftFraction >= 0 && CanModifyLiftFraction(copter, ref proposedLiftFraction))
                {
                    copter.liftFraction = proposedLiftFraction;
                }

                if (config.torqueScalePitch >= 0)
                {
                    copter.torqueScale.x = copterDefaults.torqueScale.x;
                }

                if (config.torqueScaleYaw >= 0)
                {
                    copter.torqueScale.y = copterDefaults.torqueScale.y;
                }

                if (config.torqueScaleRoll >= 0)
                {
                    copter.torqueScale.z = copterDefaults.torqueScale.z;
                }
            }

            if (removeStorage)
            {
                foreach (var child in copter.children.FindAll(child => child.name == storagePrefab || child.name == storageLargePrefab || child.name == autoturretPrefab))
                {
                    child.Kill();
                }
            }
        }

        private void ModifyMiniCopter(Minicopter copter)
        {
            if (copterDefaults != null)
            {
                var proposedFuelPerSec = config.fuelPerSec;
                if (config.fuelPerSec >= 0 && CanModifyFuelPerSec(copter, ref proposedFuelPerSec))
                {
                    copter.fuelPerSec = proposedFuelPerSec;
                }

                var proposedLiftFraction = config.liftFraction;
                if (config.liftFraction >= 0 && CanModifyLiftFraction(copter, ref proposedLiftFraction))
                {
                    copter.liftFraction = proposedLiftFraction;
                }

                if (config.torqueScalePitch >= 0)
                {
                    copter.torqueScale.x = config.torqueScalePitch;
                }

                if (config.torqueScaleYaw >= 0)
                {
                    copter.torqueScale.y = config.torqueScaleYaw;
                }

                if (config.torqueScaleRoll >= 0)
                {
                    copter.torqueScale.z = config.torqueScaleRoll;
                }
            }

            // Override the inertia tensor since if the server had rebooted while there were attachments, it would have been snapshotted to an unreasonable value.
            // This is the vanilla amount while the prevent building object is inactive.
            // To determine this value, simply deactivate the prevent building object, call rigidBody.ResetInertiaTensor(), then print the value.
            copter.rigidBody.inertiaTensor = new Vector3(407.1f, 279.6f, 173.2f);

            if (config.autoturret)
            {
                // Setup existing turret, or add a new one.
                var turret = copter.GetComponentInChildren<AutoTurret>();
                if (turret != null)
                {
                    SetupAutoTurret(turret);

                    // Setup existing switch, but don't add a new one.
                    var turretSwitch = turret.GetComponentInChildren<ElectricSwitch>();
                    if (turretSwitch != null)
                    {
                        SetupSwitch(turretSwitch);
                    }
                }
                else
                {
                    AddTurret(copter);
                }
            }

            var existingStorage = GetStorage(copter);
            if (existingStorage.Length > 0)
            {
                // Existing storage found, update its state and don't add any more storage.
                foreach (var storage in existingStorage)
                {
                    SetupStorage(storage);
                }
            }
            else
            {
                // Add storage since none was found.
                AddLargeStorageBox(copter);

                switch (config.storageContainers)
                {
                    case 1:
                        AddRearStorageBox(copter);
                        break;
                    case 2:
                        AddSideStorageBoxes(copter);
                        break;
                    case 3:
                        AddRearStorageBox(copter);
                        AddSideStorageBoxes(copter);
                        break;
                }
            }

            if (config.addSearchLight)
            {
                // Setup existing search light, or add a new one.
                var searchLight = copter.GetComponentInChildren<SearchLight>();
                if (searchLight != null)
                {
                    SetupSearchLight(searchLight);
                    SetupInvincibility(searchLight);

                    var sphereEntity = searchLight.GetParentEntity() as SphereEntity;
                    if (sphereEntity != null)
                    {
                        SetupSphereEntity(sphereEntity);
                    }
                }
                else
                {
                    AddSearchLight(copter);
                }
            }

            if (config.lightTail)
            {
                // Setup existing tail light, or add a new one.
                var tailLight = copter.GetComponentInChildren<FlasherLight>();
                if (tailLight != null)
                {
                    SetupTailLight(tailLight);
                    SetupInvincibility(tailLight);
                }
                else
                {
                    AddTailLight(copter);
                }
            }
        }

        private bool CanModifyMiniCopter(Minicopter copter)
        {
            var hookResult = ExposedHooks.OnMiniCopterOptions(copter);
            if (hookResult is bool && !(bool)hookResult)
                return false;

            return true;
        }

        private bool CanModifyFuelPerSec(Minicopter copter, ref float proposedFuelPerSec)
        {
            stageFuelPerSec[0] = proposedFuelPerSec;

            var hookResult = ExposedHooks.OnMinicopterFuelPerSecChange(this, copter, stageFuelPerSec);
            if (hookResult is bool && !(bool)hookResult)
                return false;

            proposedFuelPerSec = stageFuelPerSec[0];
            return true;
        }

        private bool CanModifyLiftFraction(Minicopter copter, ref float proposedLiftFraction)
        {
            stageLiftFraction[0] = proposedLiftFraction;

            var hookResult = ExposedHooks.OnMinicopterLiftFractionChange(this, copter, stageLiftFraction);
            if (hookResult is bool && !(bool)hookResult)
                return false;

            proposedLiftFraction = stageLiftFraction[0];
            return true;
        }

        private void ScheduleModifyMiniCopter(Minicopter copter)
        {
            // Delay to allow plugins to detect the Mini and save its ID so they can block modification via hooks.
            NextTick(() =>
            {
                if (copter == null || copter.IsDestroyed)
                    return;

                if (!CanModifyMiniCopter(copter))
                    return;

                ModifyMiniCopter(copter);
            });
        }

        private void StoreMiniCopterDefaults()
        {
            var copter = GameManager.server.FindPrefab(minicopterPrefab)?.GetComponent<Minicopter>();
            if (copter == null)
                return;

            //Puts($"Defaults for copters saved as \nfuelPerSecond = {copter.fuelPerSec}\nliftFraction = {copter.liftFraction}\ntorqueScale = {copter.torqueScale}");
            copterDefaults = new MiniCopterDefaults
            {
                fuelPerSec = copter.fuelPerSec,
                liftFraction = copter.liftFraction,
                torqueScale = copter.torqueScale
            };
        }

        #endregion

        #region Configuration

        private class MiniCopterDefaults
        {
            public float fuelPerSec;
            public float liftFraction;
            public Vector3 torqueScale;
        }

        private class Configuration : SerializableConfiguration
        {
            // Populated with Rust defaults.
            [JsonProperty("Fuel per Second")]
            public float fuelPerSec = 0.5f;

            [JsonProperty("Lift Fraction")]
            public float liftFraction = 0.25f;

            [JsonProperty("Pitch Torque Scale")]
            public float torqueScalePitch = 400f;

            [JsonProperty("Yaw Torque Scale")]
            public float torqueScaleYaw = 400f;

            [JsonProperty("Roll Torque Scale")]
            public float torqueScaleRoll = 200f;

            [JsonProperty("Storage Containers")]
            public int storageContainers = 0;

            [JsonProperty("Large Storage Containers")]
            public int storageLargeContainers = 0;

            [JsonProperty("Restore Defaults")]
            public bool restoreDefaults = true;

            [JsonProperty("Reload Storage")]
            public bool reloadStorage = false;

            [JsonProperty("Drop Storage Loot On Death")]
            public bool dropStorage = true;

            [JsonProperty("Large Storage Lockable")]
            public bool largeStorageLockable = true;

            [JsonProperty("Large Storage Size (Max 48)")]
            public int largeStorageSize = 48;

            [JsonProperty("Large Storage Size (Max 42)")]
            public int largeStorageSizeDeprecated {
                set { largeStorageSize = value; }
            }

            [JsonProperty("Seconds to pause flyhack when dismount from heli.")]
            public int flyHackPause = 1;

            [JsonProperty("Add auto turret to heli")]
            public bool autoturret = false;

            [JsonProperty("Auto turret targets players")]
            public bool autoTurretTargetsPlayers = true;

            [JsonProperty("Auto turret targets NPCs")]
            public bool autoTurretTargetsNPCs = true;

            [JsonProperty("Auto turret targets animals")]
            public bool autoTurretTargetsAnimals = true;

            [JsonProperty("Mini Turret Range (Default 30)")]
            public float turretRange = 30f;

            [JsonProperty("Light: Add Searchlight to heli")]
            public bool addSearchLight = true;

            [JsonProperty("Light: Add Nightitme Tail Light")]
            public bool lightTail = false;
        }

        private Configuration GetDefaultConfig() => new Configuration();

        #region Configuration Helpers

        private class SerializableConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(SerializableConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(config))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion

        #endregion
    }
}


// --- End of file: MiniCopterOptions.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Battlefield.cs ---
// --- Original Local Path: Battlefield.cs ---

using System.Collections.Generic;
using System;
using System.Data;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Plugins;
using System.Timers;
using Rust;

namespace Oxide.Plugins
{
    [Info("Event Battlefield", "Reneb", "1.0.4")]
    class Battlefield : RustPlugin
    {
        ////////////////////////////////////////////////////////////
        // Setting all fields //////////////////////////////////////
        ////////////////////////////////////////////////////////////
        [PluginReference]
        Plugin EventManager;
        [PluginReference]
        Plugin ZoneManager;

        private bool useThisEvent;
        private bool EventStarted;
        private bool Changed;

        private List<BattlefieldPlayer> BattlefieldPlayers = new List<BattlefieldPlayer>();

        private Hash<BattlefieldPlayer, string> WeaponVote = new Hash<BattlefieldPlayer, string>();
        private Hash<BattlefieldPlayer, string> GroundVote = new Hash<BattlefieldPlayer, string>();
        private string currentGround;
        private string currentWeapon;

        ////////////////////////////////////////////////////////////
        // BattlefieldPlayer class to store informations ////////////
        ////////////////////////////////////////////////////////////
        class BattlefieldPlayer : MonoBehaviour
        {
            public BasePlayer player;
            public int kills;

            void Awake()
            {
                player = GetComponent<BasePlayer>();
                enabled = false;
                kills = 0;
            }
        }


        //////////////////////////////////////////////////////////////////////////////////////
        // Oxide Hooks ///////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////
        void Loaded()
        {
            useThisEvent = false;
            EventStarted = false;
        }
        void OnServerInitialized()
        {
            if (EventManager == null)
            {
                Puts("Event plugin doesn't exist");
                return;
            }
            LoadVariables();
            RegisterGame();
        }
        void RegisterGame()
        {
            var success = EventManager.Call("RegisterEventGame", new object[] { EventName });
            if (success == null)
            {
                Puts("Event plugin doesn't exist");
                return;
            }
        }
        void LoadDefaultConfig()
        {
            Puts("Event Battlefield: Creating a new config file");
            Config.Clear();
            LoadVariables();
        }
        void Unload()
        {
            if (useThisEvent && EventStarted)
            {
                EventManager.Call("EndEvent", new object[] { });
                var objects = GameObject.FindObjectsOfType(typeof(BattlefieldPlayer));
                if (objects != null)
                    foreach (var gameObj in objects)
                        GameObject.Destroy(gameObj);
            }
        }



        //////////////////////////////////////////////////////////////////////////////////////
        // Configurations ////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////

        static string EventName = "Battlefield";

        static float EventStartHealth = 100;

        static Dictionary<string, object> EventGrounds = DefaultGrounds();
        static string DefaultGround = "shortrange";
        static string DefaultWeapon = "assault";

        static string EventMessageKill = "{0} killed {2}. ({1} kills)";
        static string EventMessageOpenBroadcast = "In Battlefield, it's a free for all, the goal is to kill as many players as possible!";
        static string EventMessageErrorNotLaunched = "Battlefield isn't currently launched";
        static string EventMessageErrorNotStarted = "You need to wait for the Battlefield to be started to use this command.";
        static string EventMessageErrorVoteNotBF = "You must be in the battlefield to vote";
        static string EventMessageVoteGroundAvaible = "ï¸»â³âä¸ Battlefield Grounds Avaible ä¸ââ³ï¸» Votes required for an item: {0}";
        static string EventMessageVoteGroundVotes = "{0} - {1} votes";
        static string EventMessageErrorVoteNoGround = "This battlefield ground doesn't exist.";
        static string EventMessageErrorVoteAlreadyGround = "The current ground is already {0}.";
        static string EventMessageVoteGroundVoted = "You have voted for the ground: {0}.";
        static string EventMessageVoteGroundShowVotes = "â³âä¸ {0} has {1} votes";
        static string EventMessageVoteGroundNew = "ï¸»â³âä¸ New ground is now: {0}";
        static string EventMessageVoteWeaponNew = "ï¸»â³âä¸ New weapon kit is now: {0}";
        static string EventMessageVoteWeaponShowVotes = "â³âä¸ {0} has {1} votes";
        static string EventMessageVoteWeaponAvaible = "ï¸»â³âä¸ Avaible Weapon Kits For Current Ground ä¸ââ³ï¸»  Votes required for an item: {0}";
        static string EventMessageVoteWeaponVotes = "{0} - {1} votes";
        static string EventMessageErrorVoteNoKit = "This weapon kits doesn't exist in this battleground.";
        static string EventMessageErrorVoteAlreadyWeapon = "The current weapon is already {0}.";
        static string EventMessageVoteWeaponVoted = "ï¸»â³âä¸ You have voted for the weapon: {0}.";

        static int TokensAddKill = 1;
        static int EventVotePercent = 60;


        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        private void LoadConfigVariables()
        {
            CheckCfg<string>("Battlefield - Event - Name", ref EventName);
            CheckCfgFloat("Battlefield - Start - Health", ref EventStartHealth);

            CheckCfg<string>("Messages - Kill", ref EventMessageKill);
            CheckCfg<string>("Messages - Open Broadcast", ref EventMessageOpenBroadcast);
            CheckCfg<string>("Messages - Error - Not Selected", ref EventMessageErrorNotLaunched);
            CheckCfg<string>("Messages - Error - Not Started", ref EventMessageErrorNotStarted);
            CheckCfg<string>("Messages - Error - Not joined", ref EventMessageErrorVoteNotBF);
            CheckCfg<string>("Messages - Vote - Grounds - Show Avaible Title", ref EventMessageVoteGroundAvaible);
            CheckCfg<string>("Messages - Vote - Grounds - Show Avaible List", ref EventMessageVoteGroundVotes);
            CheckCfg<string>("Messages - Error - Vote - Ground Doesnt Exist", ref EventMessageErrorVoteNoGround);
            CheckCfg<string>("Messages - Error - Vote - Ground Already This One", ref EventMessageErrorVoteAlreadyGround);
            CheckCfg<string>("Messages - Vote - Grounds - Voted", ref EventMessageVoteGroundVoted);
            CheckCfg<string>("Messages - Vote - Grounds - Show Votes", ref EventMessageVoteGroundShowVotes);
            CheckCfg<string>("Messages - Vote - Grounds - New", ref EventMessageVoteGroundNew);
            CheckCfg<string>("Messages - Vote - Weapons - New", ref EventMessageVoteWeaponNew);
            CheckCfg<string>("Messages - Vote - Weapons - Show Votes", ref EventMessageVoteWeaponShowVotes);
            CheckCfg<string>("Messages - Vote - Weapons - Show Avaible Title", ref EventMessageVoteWeaponAvaible);
            CheckCfg<string>("Messages - Vote - Weapons - Show Avaible List", ref EventMessageVoteWeaponVotes);
            CheckCfg<string>("Messages - Vote - Weapons - Voted", ref EventMessageVoteWeaponVoted);
            CheckCfg<string>("Messages - Error - Vote - Weapon Doesnt Exist", ref EventMessageErrorVoteNoKit);
            CheckCfg<string>("Messages - Error - Vote - Weapon Already This One", ref EventMessageErrorVoteAlreadyWeapon);

            CheckCfg<Dictionary<string, object>>("Battlefield - Grounds", ref EventGrounds);

            CheckCfg<string>("Battlefield - Default Ground", ref DefaultGround);
            CheckCfg<string>("Battlefield - Default Weapon Kit", ref DefaultWeapon);
            CheckCfg<int>("Battlefield - Vote - % needed to win", ref EventVotePercent);
            
            CheckCfg<int>("Tokens - Per Kill", ref TokensAddKill);

            currentWeapon = DefaultWeapon;
            currentGround = DefaultGround;

        }
        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }
        private void CheckCfgFloat(string Key, ref float var)
        {

            if (Config[Key] != null)
                var = Convert.ToSingle(Config[Key]);
            else
                Config[Key] = var;
        }
        static Dictionary<string,object> DefaultGrounds()
        {
            var grounds = new Dictionary<string, object>();

            var ground1 = new Dictionary<string, object>();
            var ground1kit = new List<string>();
            ground1kit.Add("pistols");
            ground1kit.Add("assault");
            ground1.Add("kits", ground1kit);
            ground1.Add("zone", "BattlefieldGround1");
            ground1.Add("spawnfile", "shortrangespawnfile");
                 
            var ground2 = new Dictionary<string, object>();
            var ground2kit = new List<string>();
            ground2kit.Add("sniper");
            ground2kit.Add("pistols");
            ground2.Add("kits", ground2kit);
            ground2.Add("zone", "BattlefieldGround2");
            ground2.Add("spawnfile", "longrangespawnfile");
             
            grounds.Add("shortrange", ground1);
            grounds.Add("longrange", ground2);

            return grounds;
        }
        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        object GetEventConfig(string configname)
        {
            if (!useThisEvent) return null;
            if (Config[configname] == null) return null;
            return Config[configname];
        }
         
        //////////////////////////////////////////////////////////////////////////////////////
        // Beginning Of Event Manager Hooks //////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////
        void OnSelectEventGamePost(string name)
        {
            if (EventName == name)
            {
                useThisEvent = true;
                currentWeapon = DefaultWeapon;
                currentGround = DefaultGround;
                ResetVotes();
                var currentbfdata = EventGrounds[currentGround] as Dictionary<string, object>;
                if (currentbfdata["spawnfile"] != null && currentbfdata["spawnfile"].ToString() != "")
                    EventManager.Call("SelectSpawnfile", new object[] { currentbfdata["spawnfile"].ToString() });
            }
            else
                useThisEvent = false;
        }
        void OnEventPlayerSpawn(BasePlayer player)
        {
            if (useThisEvent && EventStarted)
            {
                player.inventory.Strip();
                EventManager.Call("GivePlayerKit", new object[] { player, currentWeapon });
                player.health = EventStartHealth;
            }
        }
        object OnSelectSpawnFile(string name)
        {
            if (useThisEvent)
            {
                return true;
            }
            return null;
        }
        object OnSelectKit(string kitname)
        {
            if (useThisEvent)
            {
                SetWeapon(kitname);
                return true;
            }
            return null;
        }
        object OnEventOpenPost()
        {
            if (useThisEvent)
                EventManager.Call("BroadcastEvent", new object[] { EventMessageOpenBroadcast });
            return null;
        }
        object OnEventEndPost()
        {
            if (useThisEvent)
            {
                EventStarted = false;
                BattlefieldPlayers.Clear();
            }
            return null;
        }
        object OnRequestZoneName()
        {
            if(useThisEvent)
            {
                var eventgrounddata = EventGrounds[currentGround] as Dictionary<string, object>;
                return eventgrounddata["zone"].ToString();
            }
            return null;
        }
        object OnEventStartPre()
        {
            if (useThisEvent)
            {
                EventStarted = true;
            }
            return null;
        }
        object OnEventJoinPost(BasePlayer player)
        {
            if (useThisEvent)
            {
                if (player.GetComponent<BattlefieldPlayer>())
                    GameObject.Destroy(player.GetComponent<BattlefieldPlayer>());
                BattlefieldPlayers.Add(player.gameObject.AddComponent<BattlefieldPlayer>());
            }
            return null;
        }
        object OnEventLeavePost(BasePlayer player)
        {
            if (useThisEvent)
            {
                if (player.GetComponent<BattlefieldPlayer>())
                {
                    BattlefieldPlayers.Remove(player.GetComponent<BattlefieldPlayer>());
                    GameObject.Destroy(player.GetComponent<BattlefieldPlayer>());
                }
            }
            return null;
        }

        void OnEventPlayerDeath(BasePlayer victim, HitInfo hitinfo)
        {
            if (useThisEvent)
            {
                if (hitinfo.Initiator != null)
                {
                    BasePlayer attacker = hitinfo.Initiator.ToPlayer();
                    if (attacker != null)
                    {
                        if (attacker != victim)
                        {
                            AddKill(attacker, victim);
                        }
                    }
                }
            }
            return;
        }
        //////////////////////////////////////////////////////////////////////////////////////
        // End Of Event Manager Hooks ////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////

        void AddKill(BasePlayer player, BasePlayer victim)
        {
            if (!player.GetComponent<BattlefieldPlayer>())
                return;

            player.GetComponent<BattlefieldPlayer>().kills++;
            EventManager.Call("AddTokens", player.userID.ToString(), TokensAddKill);
            EventManager.Call("BroadcastEvent", string.Format(EventMessageKill, player.displayName, player.GetComponent<BattlefieldPlayer>().kills.ToString(), victim.displayName));
        }

        int GetGroundVotes(string groundname)
        {
            int groundvote = 0;
            foreach(KeyValuePair<BattlefieldPlayer, string> pair in GroundVote)
            {
                if (pair.Key == null) continue;
                if (pair.Value == groundname)
                    groundvote++;
            }
            return groundvote;
        }
        int GetWeaponVotes(string weaponname)
        {
            int weaponvote = 0;
            foreach (KeyValuePair<BattlefieldPlayer, string> pair in WeaponVote)
            {
                if (pair.Key == null) continue;
                if (pair.Value == weaponname)
                    weaponvote++;
            }
            return weaponvote;
        }
        int EventPlayersCount()
        {
            int plcount = 0;
            foreach (BattlefieldPlayer bfplayer in BattlefieldPlayers)
            {
                plcount++;
            }
            return plcount;
        }
        int VotePlayersNeeded() { return (int)Math.Ceiling( (decimal)(EventPlayersCount() * EventVotePercent / 100) ); }
        void ResetVotes()
        {
            GroundVote.Clear();
            WeaponVote.Clear();
        }


        bool hasAccess(BasePlayer player)
        {
            if (player.net.connection.authLevel < 1)
            {
                return false;
            }
            return true;
        }
        
        [ChatCommand("ground")]
        void cmdChatGround(BasePlayer player, string command, string[] args)
        {
            if(!useThisEvent)
            {
                SendReply(player, EventMessageErrorNotLaunched);
                return;
            }
            
            if (!EventStarted)
            {
                SendReply(player, EventMessageErrorNotStarted);
                return;
            }
            BattlefieldPlayer bfplayer = player.GetComponent<BattlefieldPlayer>();
            
            if (bfplayer == null && !hasAccess(player))
            {
                SendReply(player, EventMessageErrorVoteNotBF);
                return;
            }
            if (args.Length == 0)
            {
                SendReply(player, string.Format(EventMessageVoteGroundAvaible, VotePlayersNeeded().ToString()));
                foreach (KeyValuePair<string,object> pair in EventGrounds)
                {
                    SendReply(player, string.Format(EventMessageVoteGroundVotes, pair.Key, GetGroundVotes(pair.Key).ToString()));
                }
                return;
            }
            string voteground = args[0];
            if(!EventGrounds.ContainsKey(voteground))
            {
                SendReply(player, EventMessageErrorVoteNoGround);
                return;
            }
            if (voteground == currentGround)
            {
                SendReply(player, string.Format(EventMessageErrorVoteAlreadyGround, currentGround));
                return;
            }

            if(hasAccess(player))
            {
                SetGround(voteground);
                return;
            }

            SendReply(player, string.Format(EventMessageVoteGroundVoted, voteground));
            if (GroundVote[bfplayer] == voteground)
                return;
            GroundVote[bfplayer] = voteground;
            CheckGroundVotes();
        }
        void CheckGroundVotes()
        {
            int votesneeded = VotePlayersNeeded();
            var votes = new Hash<string, int>();
            foreach(KeyValuePair<BattlefieldPlayer, string> pair in GroundVote)
            {
                votes[pair.Value]++;
                if(votes[pair.Value] >= votesneeded)
                {
                    SetGround(pair.Value);
                    return;
                }
            }
            foreach (KeyValuePair<string, int> pair in votes)
            {
                EventManager.Call("BroadcastEvent", string.Format(EventMessageVoteGroundShowVotes, pair.Key, pair.Value.ToString()));
            }
        }
        void SetGround(string newGround)
        {
            var eventgrounddata = EventGrounds[newGround] as Dictionary<string, object>;
            if (eventgrounddata == null) { EventManager.Call("BroadcastToChat", string.Format("Error while setting new ground: {0}. data doesn't exist. WTF?", newGround)); return; }
            if (eventgrounddata["spawnfile"] == null) { EventManager.Call("BroadcastToChat", string.Format("Error while setting new ground: {0}. spawnfile isn't set", newGround)); return; }

            var newkit = currentWeapon;
            var eventgroundkits = eventgrounddata["kits"] as List<object>;
            if (!eventgroundkits.Contains(newkit))
            {
                newkit = (string)eventgroundkits[0];
            }
            if(newkit == null) { EventManager.Call("BroadcastToChat", string.Format("Error while setting new ground: {0}. no kits were found", newGround)); return; }

            object success = EventManager.Call("SelectSpawnfile", eventgrounddata["spawnfile"].ToString());
            if(success is string)
            {
                EventManager.Call("BroadcastToChat", string.Format("Error while setting new ground: {0}. {1}", newGround, success.ToString()));
                return;
            }

            EventManager.Call("BroadcastEvent", string.Format(EventMessageVoteGroundNew, newGround));
            
            var oldzone = currentGround;
            currentGround = newGround;
            Debug.Log(oldzone);
            Debug.Log(currentGround);
            SetWeapon(newkit);
            foreach (BattlefieldPlayer bfplayer in BattlefieldPlayers)
            {
                bfplayer.player.Die();
                ZoneManager?.Call("RemovePlayerFromZoneKeepinlist", oldzone, bfplayer.player);                
            }
            GroundVote.Clear();
        }
        void SetWeapon(string newWeapon)
        {
            EventManager.Call("BroadcastEvent", string.Format(EventMessageVoteWeaponNew, newWeapon));
            currentWeapon = newWeapon;
            foreach (BattlefieldPlayer bfplayer in BattlefieldPlayers)
            {
                OnEventPlayerSpawn(bfplayer.player);
            }
            WeaponVote.Clear();
        }
        void CheckWeaponVotes()
        {
            int votesneeded = VotePlayersNeeded();
            var votes = new Hash<string, int>();
            foreach (KeyValuePair<BattlefieldPlayer, string> pair in WeaponVote)
            {
                votes[pair.Value]++;
                if (votes[pair.Value] >= votesneeded)
                {
                    SetWeapon(pair.Value);
                    return;
                }
            }
            foreach (KeyValuePair<string, int> pair in votes)
            {
                EventManager.Call("BroadcastEvent", string.Format(EventMessageVoteWeaponShowVotes, pair.Key, pair.Value.ToString()));
            }
        }
        [ChatCommand("weapon")]
        void cmdChatWeapon(BasePlayer player, string command, string[] args)
        {
            if (!useThisEvent)
            {
                SendReply(player, EventMessageErrorNotLaunched);
                return;
            }
            if (!EventStarted)
            {
                SendReply(player, EventMessageErrorNotStarted);
                return;
            }
            BattlefieldPlayer bfplayer = player.GetComponent<BattlefieldPlayer>();
            if (bfplayer == null && !hasAccess(player))
            {
                SendReply(player, EventMessageErrorVoteNotBF);
                return;
            }
            var eventgrounddata = EventGrounds[currentGround] as Dictionary<string, object>;
            var eventgroundkits = eventgrounddata["kits"] as List<object>;
            if (args.Length == 0)
            {
                SendReply(player, string.Format(EventMessageVoteWeaponAvaible, VotePlayersNeeded().ToString()));
                foreach (string kitname in eventgroundkits)
                {
                    SendReply(player, string.Format(EventMessageVoteWeaponVotes, kitname, GetWeaponVotes(kitname).ToString()));
                }
                return;
            }
            string voteweap = args[0];
            
            if (!eventgroundkits.Contains(voteweap))
            {
                SendReply(player, EventMessageErrorVoteNoKit);
                return;
            }

            if(voteweap == currentWeapon)
            {
                SendReply(player, string.Format(EventMessageErrorVoteAlreadyWeapon, currentWeapon));
                return;
            }

            if (hasAccess(player))
            {
                SetWeapon(voteweap);
                return;
            }

            SendReply(player, string.Format(EventMessageVoteWeaponVoted, voteweap));
            if (WeaponVote[bfplayer] == voteweap)
                return;
            WeaponVote[bfplayer] = voteweap;
            CheckWeaponVotes();
        }
    }
}



// --- End of file: Battlefield.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/IQReportSystem.cs ---
// --- Original Local Path: IQReportSystem.cs ---

﻿using System;
using System.Collections.Generic;
using UnityEngine;
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Libraries.Covalence;
using ConVar;
using Newtonsoft.Json.Linq;
using Oxide.Core.Libraries;
using System.Linq;
using Oxide.Core.Plugins;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("IQReportSystem", "", "0.1.0")]
    class IQReportSystem : RustPlugin
    {
        #region Reference
        [PluginReference] Plugin GameWerAC, ImageLibrary, MultiFighting, IQChat, Friends, IQPersonal;
        public string GetImage(string shortname, ulong skin = 0) => (string)ImageLibrary?.Call("GetImage", shortname, skin);
        public bool AddImage(string url, string shortname, ulong skin = 0) => (bool)ImageLibrary?.Call("AddImage", url, shortname, skin);
        public void SetCheck(BasePlayer player) => IQPersonal?.CallHook("API_SET_CHECK", player.userID);
        public void SetBans(BasePlayer player) => IQPersonal?.CallHook("API_SET_BANS", player.userID);
        public void SetScore(ulong UserID, int Amount) => IQPersonal?.CallHook("API_SET_SCORE", UserID, Amount);
        public void RemoveScore(ulong UserID, int Amount) => IQPersonal?.CallHook("API_REMOVE_SCORE", UserID, Amount);
        #endregion

        #region Vars

        #region Permission
        string PermissionModeration = "iqreportsystem.moderation";
        string PermissionAdmin = "iqreportsystem.admin";
        #endregion

        #region Lists
        public Dictionary<ulong, int> CooldownPC = new Dictionary<ulong, int>();
        public Dictionary<ulong, PlayerSaveCheckClass> PlayerSaveCheck = new Dictionary<ulong, PlayerSaveCheckClass>();
        public class PlayerSaveCheckClass
        {
            public string Discord;
            public string NickName;
            public string StatusNetwork;

            public ulong ModeratorID;
        }
        #endregion

        #region JSON
        private class Response
        {
            public List<string> last_ip;
            public string last_nick;
            public List<ulong> another_accs;
            public List<last_checks> last_check;
            public class last_checks
            {
                public ulong moderSteamID;
                public string serverName;
                public int time;
            }
            public List<RustCCBans> bans;
            public class RustCCBans
            {
                public int banID;
                public string reason;
                public string serverName;
                public int OVHserverID;
                public int banDate;
            }
        }
        #endregion

        #endregion

        #region Configuration
        private static Configuration config = new Configuration();
        public class Configuration
        {
            [JsonProperty("Основные настройки")]
            public Settings Setting = new Settings();
            [JsonProperty("Причины репорта")]
            public List<string> ReasonReport = new List<string>();
            [JsonProperty("Причины блокировки")] 
            public List<BanReason> ReasonBan = new List<BanReason>();
            [JsonProperty("Настройки RustCheatCheck(Будет при проверке выдавать доступ в чекер и выводить информацию модератору)")]
            public RCCSettings RCCSetting = new RCCSettings();
            [JsonProperty("Настройка репутации для проверяющих")]
            public RaitingSettings RaitingSetting = new RaitingSettings();
            internal class BanReason
            {
                [JsonProperty("Название")]
                public string DisplayName;
                [JsonProperty("Команда")]
                public string Command;
            }
            internal class RCCSettings
            {
                [JsonProperty("Включить поддержку RCC")]
                public bool RCCUse;
                [JsonProperty("Ключ от RCC")]
                public string Key;
            }
            internal class RaitingSettings
            {
                [JsonProperty("Сколько репутации снимать за 1-2 звезды(IQPersonal)")]
                public int RemoveAmountOneTwo;
                [JsonProperty("Сколько репутации давать за 3-4 звезды(IQPersonal)")]
                public int GiveAmountThreeFour;
                [JsonProperty("Сколько репутации давать за 5 звезд(IQPersonal)")]
                public int GiveAmountFive;
            }
            internal class Settings
            {
                [JsonProperty("Настройки IQChat")]
                public ChatSettings ChatSetting = new ChatSettings();
                [JsonProperty("Настройки интерфейса")]
                public InterfaceSetting Interface = new InterfaceSetting();

                [JsonProperty("Включить/отключить оповещение о максимальном кол-во репортов")]
                public bool MaxReportAlert;
                [JsonProperty("Максимальное количество репортов")]
                public int MaxReport;
                [JsonProperty("Перезарядка для отправки репорта(секунды)")]
                public int CooldownTime;
                [JsonProperty("Запретить друзьям репортить друг друга")]
                public bool FriendNoReport;
                [JsonProperty("Включить логирование в беседу ВК")]
                public bool VKMessage;
                [JsonProperty("Включить логирование в Discord")]
                public bool DiscrodMessage;
                [JsonProperty("Webhooks для дискорда")]
                public string WebHook;
                [JsonProperty("Настройки ВК")]
                public VKSetting VKSettings = new VKSetting();

                internal class ChatSettings
                {
                    [JsonProperty("IQChat : Кастомный префикс в чате")]
                    public string CustomPrefix;
                    [JsonProperty("IQChat : Кастомный аватар в чате(Если требуется)")]
                    public string CustomAvatar;
                }
                internal class VKSetting
                {
                    [JsonProperty("Токен от группы ВК(От группы будут идти сообщения в беседу.Вам нужно добавить свою группу в беседу!)")]
                    public string Token;
                    [JsonProperty("ID беседы для группы")]
                    public string ChatID;
                }
                internal class InterfaceSetting
                {
                    [JsonProperty("Настройка интерфейса для отправки жалобы")]
                    public ReasonInterfaceSetting ReasonInterface = new ReasonInterfaceSetting();
                    [JsonProperty("Настройка интерфейса для уведомления")]
                    public AlertInterfaceSettings AlertInterface = new AlertInterfaceSettings(); 
                    [JsonProperty("Настройка интерфейса для мини-панели модератора")]
                    public ModeratorPanelInterfaceSettings ModderatorPanel = new ModeratorPanelInterfaceSettings(); 
                    [JsonProperty("Настройка интерфейса для рейтинга")]
                    public RaitingInterfaceSettings RaitingInterface = new RaitingInterfaceSettings();
                    [JsonProperty("Sprite для рейтинга(звезды)")]
                    public string SpriteRaiting;
                    [JsonProperty("Sprite для кнопки жалоб в панели модератора")]
                    public string SpriteReportModeration;
                    [JsonProperty("Sprite для иконки жалоб")]
                    public string SpriteReport;
                    [JsonProperty("Цвет текста в плагине")]
                    public string HexLabels;
                    [JsonProperty("Цвет боковой панели")]
                    public string HexRightMenu;
                    [JsonProperty("Цвет кнопок боковой панели")]
                    public string HexButtonRightMenu;
                    [JsonProperty("Цвет основной панели")]
                    public string HexMainPanel;
                    [JsonProperty("Цвет панели поиска и заднего фона игроков")]
                    public string HexSearchPanel; 
                    [JsonProperty("Цвет кнопки у игрока для перехода к действию")]
                    public string HexPlayerButton;
                    [JsonProperty("Sprite кнопки у игрока для преехода к действию")]
                    public string SpritePlayerButton;

                    internal class ReasonInterfaceSetting
                    {
                        [JsonProperty("Цвет основной панели")]
                        public string HexMain;
                        [JsonProperty("Цвет панели с заголовком")]
                        public string HexTitlePanel;
                        [JsonProperty("Цвет жалоб")]
                        public string HexButton;
                        [JsonProperty("Цвет текста с жалобами")]
                        public string HexLabel;
                        [JsonProperty("Sprite кнопки закрыть")]
                        public string SpriteClose;             
                        [JsonProperty("Sprite панели с заголовком")]
                        public string SpriteTitlePanel;
                        [JsonProperty("Цвет кнопки закрыть")]
                        public string HexClose;
                    }
                    internal class AlertInterfaceSettings
                    {
                        [JsonProperty("Цвет основной панели")]
                        public string HexMain;
                        [JsonProperty("Цвет заголовка и полоски")]
                        public string HexTitle;
                        [JsonProperty("Цвет текста")]
                        public string HexLabel;
                    }
                    internal class ModeratorPanelInterfaceSettings
                    {
                        [JsonProperty("Цвет основной панели")]
                        public string HexMain;
                        [JsonProperty("Цвет панели с заголовком")]
                        public string HexTitlePanel;
                        [JsonProperty("Sprite панели с заголовком")]
                        public string SpriteTitlePanel;
                        [JsonProperty("Цвет текста")]
                        public string HexLabel;
                        [JsonProperty("Цвет кнопки вердикт и задний фон причин")]
                        public string HexBanButton;
                        [JsonProperty("Цвет кнопки окончания проверки")]
                        public string HexStopButton;
                    }
                    internal class RaitingInterfaceSettings
                    {
                        [JsonProperty("Цвет основной панели")]
                        public string HexMain;
                        [JsonProperty("Цвет панели с заголовком")]
                        public string HexTitlePanel;
                        [JsonProperty("Sprite панели с заголовком")]
                        public string SpriteTitlePanel;
                        [JsonProperty("Цвет текста")]
                        public string HexLabel;
                        [JsonProperty("Цвет иконок с рейтингом")]
                        public string HexRaitingButton;
                        [JsonProperty("Sprite рейтинга")]
                        public string SpriteRaiting;
                    }
                }
            }

            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    Setting = new Settings
                    {
                        FriendNoReport = false,
                        MaxReport = 3,
                        MaxReportAlert = true,
                        CooldownTime = 600,
                        VKMessage = true,
                        DiscrodMessage = false,
                        WebHook = "",
                        ChatSetting = new Settings.ChatSettings
                        {
                            CustomAvatar = "",
                            CustomPrefix = ""
                        },
                        VKSettings = new Settings.VKSetting
                        {
                            Token = "",
                            ChatID = ""
                        },
                        Interface = new Settings.InterfaceSetting
                        {
                            SpriteRaiting = "assets/icons/favourite_servers.png",
                            SpriteReportModeration = "assets/icons/subtract.png",
                            SpriteReport = "assets/icons/examine.png",
                            SpritePlayerButton = "assets/icons/vote_up.png",
                            HexPlayerButton = "#45542BFF",
                            HexLabels = "#DAD1C7FF",
                            HexButtonRightMenu = "#802A2AFF",
                            HexMainPanel = "#21211AF2",
                            HexRightMenu = "#762424FF",
                            HexSearchPanel = "#3B3D37FF",
                            ReasonInterface = new Settings.InterfaceSetting.ReasonInterfaceSetting
                            {
                                HexMain = "#585450FF",
                                HexTitlePanel = "#54514DFF",
                                HexButton = "#3E482EFF",
                                HexClose = "#B4371EFF",
                                HexLabel = "#bdd197",
                                SpriteClose = "assets/icons/vote_down.png",
                                SpriteTitlePanel = "assets/icons/connection.png"
                            },
                            AlertInterface = new Settings.InterfaceSetting.AlertInterfaceSettings
                            {
                                HexMain = "#21211AF2",
                                HexLabel = "#DAD1C7FF",
                                HexTitle = "#B4371EFF",
                            },
                            ModderatorPanel = new Settings.InterfaceSetting.ModeratorPanelInterfaceSettings
                            {
                                HexMain = "#575450FF",
                                HexTitlePanel = "#54514DFF",
                                HexLabel = "#DAD1C7FF",
                                SpriteTitlePanel = "assets/icons/study.png",
                                HexBanButton = "#B4371EFF",
                                HexStopButton = "#3E482EFF"
                            },
                            RaitingInterface = new Settings.InterfaceSetting.RaitingInterfaceSettings
                            {
                                HexMain = "#575450FF",
                                HexTitlePanel = "#54514DFF",
                                HexLabel = "#DAD1C7FF",
                                HexRaitingButton = "#cdb980",
                                SpriteTitlePanel = "assets/icons/ignite.png",
                                SpriteRaiting = "assets/icons/favourite_servers.png"
                            }
                        }
                    },
                    ReasonReport = new List<string>
                    {
                        "Использование читов",
                        "Макросы",
                        "Игра 3+",                      
                    },
                    ReasonBan = new List<BanReason>
                    { 
                        new BanReason
                        {
                            DisplayName = "Использование читов",
                            Command = "ban {0} soft",
                        },
                        new BanReason
                        {
                            DisplayName = "Макросы",
                            Command = "ban {0} 30d macros",
                        },
                        new BanReason
                        {
                            DisplayName = "Игра 3+",
                            Command = "ban {0} 14d 3+",
                        },
                        new BanReason
                        {
                            DisplayName = "Отказ",
                            Command = "ban {0} 7d otkaz",
                        },
                    },
                    RCCSetting = new RCCSettings
                    {
                        RCCUse = false,
                        Key = "xxxxxxxxxxxxxxRCCKey",
                    },
                    RaitingSetting = new RaitingSettings
                    {
                        RemoveAmountOneTwo = 4,
                        GiveAmountThreeFour = 3,
                        GiveAmountFive = 5
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Ошибка чтения конфигурации #13 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region Data
        public Dictionary<ulong, PlayerInfo> ReportInformation = new Dictionary<ulong, PlayerInfo>();
        public Dictionary<ulong, ModeratorInfo> ModeratorInformation = new Dictionary<ulong, ModeratorInfo>();
        public class PlayerInfo
        {
            [JsonProperty("Отображаемое имя")]
            public string DisplayName;
            [JsonProperty("IP Адреса")]
            public List<string> IP;
            [JsonProperty("Последняя жалоба")]
            public string LastReport;
            [JsonProperty("Последний проверяющий модератор")]
            public string LastCheckModerator;
            [JsonProperty("Количество проверок")]
            public int CheckCount;
            [JsonProperty("История жалоб")]
            public List<string> ReportHistory;
            [JsonProperty("Количество жалоб")]
            public int ReportCount;
            [JsonProperty("Игровой статус")]
            public string GameStatus;
        }

        public class ModeratorInfo
        {
            [JsonProperty("Проверки игроков с вердиктами")]
            public Dictionary<string, string> CheckPlayerModerator = new Dictionary<string, string>();
            [JsonProperty("Блокировки игроков с вердиктом")]
            public Dictionary<string, string> BanPlayerModerator = new Dictionary<string, string>();
            [JsonProperty("Общее количество проверок")]
            public int CheckCount;
            [JsonProperty("История оценок модератора")]
            public List<int> Arrayrating;
            [JsonProperty("Средняя оценка качества")]
            public float AverageRating;
        }
        #endregion

        #region Metods

        #region MetodsReport

        void Metods_PlayerConnected(BasePlayer player)
        {
            if (!ReportInformation.ContainsKey(player.userID))
            {
                PlayerInfo pInfo = new PlayerInfo
                {
                    DisplayName = player.displayName,
                    IP = new List<string>(),
                    LastReport = "",
                    LastCheckModerator = "",
                    CheckCount = 0,
                    ReportCount = 0,
                    GameStatus = IsSteam(player.UserIDString),
                    ReportHistory = new List<string>(),
                };
                ReportInformation.Add(player.userID, pInfo);
            }
            else
            {
                var User = ReportInformation[player.userID];
                var IP = covalence.Players.FindPlayerById(player.UserIDString).Address;

                User.GameStatus = IsSteam(player.UserIDString);
                if (!User.IP.Contains(IP))
                    User.IP.Add(IP);
            }

            if (permission.UserHasPermission(player.UserIDString, PermissionModeration))
            {
                if (!ModeratorInformation.ContainsKey(player.userID))
                {
                    ModeratorInfo mInfo = new ModeratorInfo
                    {
                        CheckCount = 0,
                        BanPlayerModerator = new Dictionary<string, string>(),
                        CheckPlayerModerator = new Dictionary<string, string>(),
                        Arrayrating = new List<int>(),
                        AverageRating = 0,
                    };
                    ModeratorInformation.Add(player.userID, mInfo);
                }
            }
            Metods_StatusNetwork(player, lang.GetMessage("NETWORD_STATUS_ONLINE",this,player.UserIDString));
        }

        void Metods_Report(BasePlayer target, int ReasonIndex)
        {
            if (permission.UserHasPermission(target.UserIDString, PermissionAdmin))
                return;

            if (IsSteam(target.UserIDString) == lang.GetMessage("IS_STEAM_STATUS_PIRATE", this, target.UserIDString))
            {
                if (GameWerAC != null)
                {
                    GameWerAC.Call("GetScreenReport", target);
                    Puts("Выполнен скриншот экрана для пирата");
                }
            }

            string ReasonReport = config.ReasonReport[ReasonIndex];

            var User = ReportInformation[target.userID];
            User.ReportCount++;
            User.LastReport = ReasonReport;
            User.ReportHistory.Insert(0, ReasonReport);

            if (config.Setting.MaxReportAlert)
                if (User.ReportCount >= config.Setting.MaxReport)
                {
                    foreach (var MList in BasePlayer.activePlayerList)
                        if (permission.UserHasPermission(MList.UserIDString, PermissionModeration))
                            SendChat(MList, String.Format(lang.GetMessage("METODS_HELP_MODERS", this, MList.UserIDString), target.displayName, User.ReportCount));
                    VKSendMessage(String.Format(lang.GetMessage("METODS_HELP_MODERS_VK", this), target.displayName, User.ReportCount));
                    DiscordSendMessage(String.Format(lang.GetMessage("METODS_HELP_MODERS_VK", this), target.displayName, User.ReportCount));
                }
        }

        #endregion

        #region MetodsCooldown
        void Metods_GiveCooldown(ulong ID,  int cooldown)
        {
            CooldownPC[ID] = cooldown + (int)CurrentTime();          
        }

        bool Metods_GetCooldown(ulong ID)
        {
            if (!CooldownPC.ContainsKey(ID) || Math.Max(0, CooldownPC[ID]) < 1 || CooldownPC[ID] <= (int)CurrentTime())
                return false;
            else return true;
        }

        #endregion

        #region MetodsModeration

        void Metods_CheckModeration(BasePlayer Suspect, BasePlayer Moderator)
        {
            if (PlayerSaveCheck.ContainsKey(Suspect.userID))
            {
                SendChat(Moderator, lang.GetMessage("PLAYER_CHECKED", this));
                return;
            }
            else PlayerSaveCheck.Add(Suspect.userID, new PlayerSaveCheckClass {  });
            SendChat(Moderator, String.Format(lang.GetMessage("METODS_MODER_START_CHECK",this, Moderator.UserIDString),Suspect.displayName));
            VKSendMessage(String.Format(lang.GetMessage("METODS_MODER_START_CHECK_VK", this),Moderator.displayName,Moderator.UserIDString,Suspect.displayName,Suspect.UserIDString));           
            Metods_AFK(Suspect.userID, Moderator);
        }

        void Metods_CheckModerationFinish(BasePlayer moderator, ulong SuspectID)
        {
            IPlayer Suspect = covalence.Players.FindPlayerById(SuspectID.ToString());
            if (Suspect.IsConnected)
            {
                BasePlayer SOnline = BasePlayer.FindByID(ulong.Parse(Suspect.Id));
                CuiHelper.DestroyUi(SOnline, PARENT_UI_ALERT_SEND);
                SendChat(SOnline, lang.GetMessage("MSG_CHECK_CHECK_STOP", this, moderator.UserIDString));
            }

            CuiHelper.DestroyUi(moderator, PARENT_UI_MODERATOR_MINI_PANEL);
            PlayerSaveCheck.Remove(ulong.Parse(Suspect.Id));

            var User = ReportInformation[ulong.Parse(Suspect.Id)];
            var Moderator = ModeratorInformation[moderator.userID];

            Moderator.CheckCount++;
            if (!Moderator.CheckPlayerModerator.ContainsKey(Suspect.Name))
                Moderator.CheckPlayerModerator.Add(Suspect.Name, User.LastReport);

            User.ReportCount = 0;
            User.ReportHistory.Clear();
            User.LastReport = lang.GetMessage("NON_REPORT",this);
            User.CheckCount++;
            User.LastCheckModerator = moderator.displayName;

            SendChat(moderator, lang.GetMessage("METODS_MODER_STOP_CHECK",this, moderator.UserIDString));
            VKSendMessage(String.Format(lang.GetMessage("METODS_MODER_STOP_CHECK_VK",this),moderator.displayName));
            DiscordSendMessage(String.Format(lang.GetMessage("METODS_MODER_STOP_CHECK_VK",this),moderator.displayName));
            SetCheck(moderator);
        }

        void Metods_StatusNetwork(BasePlayer Suspect, string Reason)
        {
            if (PlayerSaveCheck.ContainsKey(Suspect.userID))
            {
                if (Suspect.IsConnected)
                    if (Suspect.IsReceivingSnapshot)
                    {
                        timer.Once(3, () => Metods_StatusNetwork(Suspect, lang.GetMessage("NETWORD_STATUS_ONLINE", this, Suspect.UserIDString)));
                        return;
                    }

                PlayerSaveCheck[Suspect.userID].StatusNetwork = Reason;
                BasePlayer Moderator = BasePlayer.FindByID(PlayerSaveCheck[Suspect.userID].ModeratorID);

                CuiHelper.DestroyUi(Moderator, UI_MODERATION_CHECK_MENU_NETWORK);
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.6782616 0.5478261", AnchorMax = "0.9884076 0.7333333" },
                    Text = { Text = $"{PlayerSaveCheck[Suspect.userID].StatusNetwork}", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.UpperCenter, Color = HexToRustFormat("#FFFFFFFF") }
                }, PARENT_UI_MODERATOR_MINI_PANEL, UI_MODERATION_CHECK_MENU_NETWORK);

                CuiHelper.AddUi(Moderator, container);
                UI_AlertSendPlayer(Suspect);             

                SendChat(Moderator, String.Format(lang.GetMessage("STATUS_CHANGED", this, Moderator.UserIDString), Suspect.displayName, Reason));
                VKSendMessage(String.Format(lang.GetMessage("STATUS_CHANGED_VK", this), Suspect.displayName, Reason));
                DiscordSendMessage(String.Format(lang.GetMessage("STATUS_CHANGED_VK", this), Suspect.displayName, Reason));
            }
        }

        public Timer ModerTimeOutTimer;
        void Metods_ModeratorExitCheck(BasePlayer Moderator)
        {
            foreach (var ModeratorCritical in PlayerSaveCheck)
                if (ModeratorCritical.Value.ModeratorID == Moderator.userID)
                {
                    IPlayer ModeratorOffline = covalence.Players.FindPlayerById(ModeratorCritical.Value.ModeratorID.ToString());
                    IPlayer Suspect = covalence.Players.FindPlayerById(ModeratorCritical.Key.ToString());
                    int TimeOutCount = 0;
                    ModerTimeOutTimer = timer.Repeat(5, 10, () =>
                        {
                            if (ModeratorOffline.IsConnected)
                            {
                                UI_MiniPanelModerator(Moderator, ModeratorCritical.Key);
                                SendChat(Moderator, lang.GetMessage("MODERATOR_RETURN_WELCOME",this, Moderator.UserIDString));
                                if (ModerTimeOutTimer != null)
                                {
                                    ModerTimeOutTimer.Destroy();
                                    ModerTimeOutTimer = null;
                                }
                                return;
                            }
                            else
                            {
                                TimeOutCount++;
                                if (TimeOutCount >= 10)
                                {
                                    PlayerSaveCheck.Remove(ModeratorCritical.Key);

                                    foreach (var OnlineModeration in BasePlayer.activePlayerList)
                                        if (permission.UserHasPermission(OnlineModeration.UserIDString, PermissionModeration))
                                            if (Suspect.IsConnected)
                                            {                                             
                                                BasePlayer SOnline = BasePlayer.FindByID(ulong.Parse(Suspect.Id));
                                                CuiHelper.DestroyUi(SOnline, PARENT_UI_ALERT_SEND);
                                           
                                                SendChat(SOnline, String.Format(lang.GetMessage("MODERATOR_DISCONNECTED_STOP_CHECK",this, Moderator.UserIDString),ModeratorOffline.Name));
                                                SendChat(OnlineModeration, String.Format(lang.GetMessage("MODERATOR_DISCONNECTED_STOP_RESEND",this, Moderator.UserIDString),ModeratorOffline.Name,Suspect.Name));
                                                VKSendMessage(String.Format(lang.GetMessage("MODERATOR_DISCONNECTED_STOP_RESEND", this), ModeratorOffline.Name, Suspect.Name));
                                                DiscordSendMessage(String.Format(lang.GetMessage("MODERATOR_DISCONNECTED_STOP_RESEND", this), ModeratorOffline.Name, Suspect.Name));

                                                if (ModerTimeOutTimer != null)
                                                {
                                                    ModerTimeOutTimer.Destroy();
                                                    ModerTimeOutTimer = null;
                                                }
                                            }
                                    return;
                                }
                            }
                        });

                }
        }

        void Metods_ModeratorBanned(BasePlayer Moderator,ulong SuspectID, int i)
        {
            CuiHelper.DestroyUi(Moderator, PARENT_UI_MODERATOR_MINI_PANEL);
            IPlayer Suspect = covalence.Players.FindPlayerById(SuspectID.ToString());
            string Reason = config.ReasonBan[i].DisplayName;

            rust.RunClientCommand(Moderator, String.Format(config.ReasonBan[i].Command, SuspectID));
            PlayerSaveCheck.Remove(SuspectID);

            var ModeratorInfo = ModeratorInformation[Moderator.userID];
            ModeratorInfo.CheckCount++;
            if (!ModeratorInfo.CheckPlayerModerator.ContainsKey(Suspect.Name))
                ModeratorInfo.CheckPlayerModerator.Add(Suspect.Name, Reason);
            if (!ModeratorInfo.BanPlayerModerator.ContainsKey(Suspect.Name))
                ModeratorInfo.BanPlayerModerator.Add(Suspect.Name, Reason);

            SendChat(Moderator, String.Format(lang.GetMessage("MODERATOR_COMPLETED_CHECK", this, Moderator.UserIDString), Reason));
            VKSendMessage(String.Format(lang.GetMessage("MODERATOR_COMPLETED_CHECK_VK", this), Moderator.displayName, Moderator.UserIDString, Suspect.Name, SuspectID, Reason, AFKCheck[SuspectID]));
            DiscordSendMessage(String.Format(lang.GetMessage("MODERATOR_COMPLETED_CHECK_VK", this), Moderator.displayName, Moderator.UserIDString, Suspect.Name, SuspectID, Reason, AFKCheck[SuspectID]));
            SetBans(Moderator);
        }

        #endregion

        #region MetodsAFK
        void Metods_CheckStopInAFK(BasePlayer moderator, string ID)
        {
            IPlayer Suspect = covalence.Players.FindPlayerById(ID);
            if (Suspect.IsConnected)
            {
                BasePlayer SOnline = BasePlayer.FindByID(ulong.Parse(Suspect.Id));
                CuiHelper.DestroyUi(SOnline, PARENT_UI_ALERT_SEND);
            }
            CuiHelper.DestroyUi(moderator, PARENT_UI_MODERATOR_MINI_PANEL);
            PlayerSaveCheck.Remove(ulong.Parse(Suspect.Id));

            SendChat(moderator, lang.GetMessage("PLAYER_AFK_CHECK_STOP",this));
            VKSendMessage(String.Format(lang.GetMessage("PLAYER_AFK_CHECK_STOP_VK", this), moderator.displayName, moderator.userID, Suspect.Name));
            DiscordSendMessage(String.Format(lang.GetMessage("PLAYER_AFK_CHECK_STOP_VK", this), moderator.displayName, moderator.userID, Suspect.Name));
        }

        public Dictionary<ulong,int> AFKCheck = new Dictionary<ulong, int>();
        void Metods_AFK(ulong SuspectID, BasePlayer moderator)
        {
            IPlayer Suspect = covalence.Players.FindPlayerById(SuspectID.ToString());
            if (!AFKCheck.ContainsKey(SuspectID))
                AFKCheck.Add(SuspectID, 0);
            else AFKCheck[SuspectID] = 0;

            int tryAFK = 0;
            SavePositionAFK(Suspect, moderator, tryAFK);
            timer.Repeat(5f, 6, () =>
            {
                SavePositionAFK(Suspect, moderator,tryAFK);
                tryAFK++;
            });
        }

        readonly Hash<string, GenericPosition> lastPosition = new Hash<string, GenericPosition>();
        void SavePositionAFK(IPlayer Suspect, BasePlayer moderator, int num)
        {
            var pPosition = Suspect.Position();
            if (!lastPosition.ContainsKey(Suspect.Id))
                lastPosition.Add(Suspect.Id, pPosition);
            else
            {
                if (lastPosition[Suspect.Id] != pPosition)
                    SendChat(moderator, String.Format(lang.GetMessage("PLAYER_AFK_CHANGE_POS",this, moderator.UserIDString),num));
                else
                {
                    SendChat(moderator, String.Format(lang.GetMessage("PLAYER_AFK_CHANGE_NO_POS", this, moderator.UserIDString), num));
                    AFKCheck[ulong.Parse(Suspect.Id)] += 1;
                }
                lastPosition[Suspect.Id] = pPosition;
            }

            if (num >= 5)
            {
                if (AFKCheck[ulong.Parse(Suspect.Id)] >= 3)
                    Metods_CheckStopInAFK(moderator, Suspect.Id);
                else
                {
                    BasePlayer SuspectOnline = BasePlayer.FindByID(ulong.Parse(Suspect.Id));
                    UI_AlertSendPlayer(SuspectOnline);
                    PlayerSaveCheck = new Dictionary<ulong, PlayerSaveCheckClass>
                    {
                        [SuspectOnline.userID] = new PlayerSaveCheckClass
                        {
                            Discord = lang.GetMessage("DISCORD_NULL",this),
                            NickName = SuspectOnline.displayName,
                            StatusNetwork = lang.GetMessage("NETWORD_STATUS_ONLINE", this, SuspectOnline.UserIDString),

                            ModeratorID = moderator.userID,
                        }
                    };
                    UI_MiniPanelModerator(moderator, SuspectOnline.userID);
                    SendChat(moderator, lang.GetMessage("PLAYER_NON_AFK", this, moderator.UserIDString));
                    
                    /*if(config.RCCSetting.RCCUse)
                    {
                        string Key = config.RCCSetting.Key;
                        if (String.IsNullOrEmpty(Key)) return;
                        try
                        {
                            string API = $"https://rustcheatcheck.ru/panel/api?action=addPlayer&key={Key}&player={Suspect.Id}";
                            webrequest.Enqueue(API, null, (code, response) => { }, this);
                        }
                        catch { }
                    }*/
                }
            }
        }

        #endregion

        #endregion

        #region Command

        #region UseCommand
        [ChatCommand("report")]
       
	   void ReportChatCommand(BasePlayer player, string command, string[] args)
        {
            if (player == null)
                return;

            if (args == null || args.Length == 0)
            {
                UI_Interface(player);
                return;
            }
        }

        [ConsoleCommand("report.list")]
        void ReportList(ConsoleSystem.Arg arg)
        {
            PrintError(lang.GetMessage("REPORT_LIST_CONSOLE",this));
            foreach (var List in BasePlayer.activePlayerList)
                if (ReportInformation[List.userID].ReportCount >= config.Setting.MaxReport)
                    PrintError($"{List.displayName} : {ReportInformation[List.userID].ReportCount}");

        }

        [ChatCommand("discord")]
        void SendDiscord(BasePlayer Suspect, string command, string[] args)
        {
            if (!PlayerSaveCheck.ContainsKey(Suspect.userID))
            {
                SendChat(Suspect, lang.GetMessage("MSG_CHECK_DISCORD", this, Suspect.UserIDString));
                return;
            }
            string Discord = "";
            foreach (var arg in args)
                Discord += " " + arg;

            PlayerSaveCheck[Suspect.userID].Discord = Discord;

            SendChat(Suspect, String.Format(lang.GetMessage("MSG_DISCORD_SEND", this, Suspect.UserIDString),Discord));
            VKSendMessage(String.Format(lang.GetMessage("DISCROD_VK_SEND", this), Suspect.displayName, Suspect.userID, Discord));
            DiscordSendMessage(String.Format(lang.GetMessage("DISCROD_VK_SEND", this), Suspect.displayName, Suspect.userID, Discord));

            BasePlayer Moderator = BasePlayer.FindByID(PlayerSaveCheck[Suspect.userID].ModeratorID);
            CuiHelper.DestroyUi(Moderator, UI_MODERATION_CHECK_MENU_DISCORD);
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.01159436 0.5478261", AnchorMax = "0.7072465 0.7333333" },
                Text = { Text = $"Discord : {PlayerSaveCheck[Suspect.userID].Discord}", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.UpperCenter, Color = HexToRustFormat("#FFFFFFFF") }
            }, PARENT_UI_MODERATOR_MINI_PANEL, UI_MODERATION_CHECK_MENU_DISCORD);

            CuiHelper.AddUi(Moderator, container);
        }
       
        [ConsoleCommand("call")]
        void CallAdminCheck(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (!player.IsAdmin) return;
            ulong SuspectID = ulong.Parse(arg.Args[0]);
            if(player == null)
            {
                PrintWarning("Вы должны быть на сервере");
                SendChat(player, "Вы должны быть на сервере");
                return;
            }
            BasePlayer Suspect = BasePlayer.FindByID(SuspectID);
            if(Suspect == null)
            {
                PrintWarning("Игрока нет");
                SendChat(player, "Игрока нет");
                return;
            }
            Metods_CheckModeration(Suspect, player);
            Puts("Вы вызвали игрока на проверку"); 
            SendChat(player, "Вы вызвали игрока на проверку");
        }

        [ConsoleCommand("report")]
        void ReportCommand(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();

            if (arg == null || arg.Args == null || arg.Args.Length == 0)
            {
                if (player == null) return;
                UI_Interface(player);
                return;
            }

            switch (arg.Args[0].ToLower())
            {
                case "give":
                    {
                        if (arg.Args.Length != 3)
                        {
                            PrintWarning("Используйте правильный синтаксис : report give SteamID Amount");
                            return;
                        }
                        if (string.IsNullOrEmpty(arg.Args[1]))
                        {
                            PrintWarning("Укажите корректный Steam64ID");
                            return;
                        }
                        if (!arg.Args[1].IsSteamId())
                        {
                            PrintWarning("Укажите корректный Steam64ID");
                            return;
                        }
                        if (string.IsNullOrEmpty(arg.Args[2]))
                        {
                            PrintWarning("Укажите корректное количество");
                            return;
                        }

                        ReportInformation[ulong.Parse(arg.Args[1])].ReportCount += Convert.ToInt32(arg.Args[2]);
                        if (player != null)
                        {
                            VKSendMessage(String.Format(lang.GetMessage("CONSOLE_REPORT_GIVE", this), arg.Args[1], arg.Args[2], ReportInformation[ulong.Parse(arg.Args[1])].ReportCount));
                            DiscordSendMessage(String.Format(lang.GetMessage("CONSOLE_REPORT_GIVE", this), arg.Args[1], arg.Args[2], ReportInformation[ulong.Parse(arg.Args[1])].ReportCount));
                        }
                        PrintWarning("ACCESS");
                        return;
                    }
                case "remove":
                    {
                        if (arg.Args.Length != 3)
                        {
                            PrintWarning("Используйте правильный синтаксис : report remove SteamID Amount");
                            return;
                        }
                        if (string.IsNullOrEmpty(arg.Args[1]))
                        {
                            PrintWarning("Укажите корректный Steam64ID");
                            return;
                        }
                        if (!arg.Args[1].IsSteamId())
                        {
                            PrintWarning("Укажите корректный Steam64ID");
                            return;
                        }
                        if (string.IsNullOrEmpty(arg.Args[2]))
                        {
                            PrintWarning("Укажите корректное количество");
                            return;
                        }
                        ReportInformation[ulong.Parse(arg.Args[1])].ReportCount -= Convert.ToInt32(arg.Args[2]);
                        if (player != null)
                        {
                            VKSendMessage(String.Format(lang.GetMessage("CONSOLE_REPORT_REMOVE", this), arg.Args[1], arg.Args[2], ReportInformation[ulong.Parse(arg.Args[1])].ReportCount));
                        }
                        PrintWarning("ACCESS");
                        return;
                    }
            }
        }

        #endregion

        #region FuncCommand
        [ConsoleCommand("iqreport")]
        void IQReportSystemCommands(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            string Key = arg.Args[0].ToLower();

            switch (Key)
            {
                case "page":
                    {
                        string PageAction = arg.Args[1];
                        bool Moderation = Convert.ToBoolean(arg.Args[2]);
                        int Page = Convert.ToInt32(arg.Args[3]);
                        switch (PageAction)
                        {
                            case "next":
                                {
                                    UI_Player_Loaded(player, Moderation, Page + 1);
                                    break;
                                }
                            case "back":
                                {
                                    UI_Player_Loaded(player, Moderation, Page - 1);
                                    break;
                                }
                        }
                        break;
                    };
                case "moderation_menu":
                    {
                        UI_PanelReportsPlayer(player, true);
                        break;
                    };
                case "reports_menu":
                    {
                        ulong SuspectID = ulong.Parse(arg.Args[1]);
                        BasePlayer Suspect = BasePlayer.FindByID(SuspectID);
                        UI_SendReport(player, Suspect);
                        break;
                    }
                case "moderation_send":
                    {
                        ulong SuspectID = ulong.Parse(arg.Args[1]);
                        BasePlayer Suspect = BasePlayer.FindByID(SuspectID);

                        UI_ModerReport(player, Suspect);
                        break;
                    }
                case "send_report":
                    {
                        ulong SuspectID = ulong.Parse(arg.Args[1]);
                        int IndexReason = Convert.ToInt32(arg.Args[2]);
                        string ReasonReport = config.ReasonReport[IndexReason];

                        if (player == null) return;
                        CuiHelper.DestroyUi(player, PARENT_UI);

                        if (Metods_GetCooldown(player.userID) == true)
                        {
                            SendChat(player, String.Format(lang.GetMessage("MSG_COOLDOWN", this, player.UserIDString), FormatTime(TimeSpan.FromSeconds(Math.Max(0, CooldownPC[player.userID] - CurrentTime())))));
                            return;
                        }

                        BasePlayer Suspect = BasePlayer.FindByID(SuspectID);

                        Metods_Report(Suspect, IndexReason);
                        Metods_GiveCooldown(player.userID, config.Setting.CooldownTime);
                        SendChat(player, String.Format(lang.GetMessage("MSG_REPORTED_SUSPECT", this, player.UserIDString), Suspect.displayName, ReasonReport));
                        VKSendMessage(String.Format(lang.GetMessage("METODS_SEND_REPORT_VK", this), Suspect.displayName, Suspect.UserIDString, ReasonReport, player.displayName, player.userID));
                        DiscordSendMessage(String.Format(lang.GetMessage("METODS_SEND_REPORT_VK", this), Suspect.displayName, Suspect.UserIDString, ReasonReport, player.displayName, player.userID));
                        break;
                    }
                case "search":
                    {
                        if (arg.Args.Length != 4) return;

                        bool Moderation = Convert.ToBoolean(arg.Args[1]);
                        int Page = Convert.ToInt32(arg.Args[2]);
                        string SearchSay = arg.Args[3];

                        UI_Player_Loaded(player, Moderation, Page, SearchSay);
                        break;
                    }
                case "send_check":
                    {
                        if (player == null) return;
                        ulong SuspectID = ulong.Parse(arg.Args[1]);
                        BasePlayer Suspect = BasePlayer.FindByID(SuspectID);
                        if (permission.UserHasPermission(player.UserIDString, PermissionModeration))
                            Metods_CheckModeration(Suspect, player);

                        break;
                    }
                case "moderator_reason_ban":
                    {
                        if (player == null) return;
                        ulong SuspectID = ulong.Parse(arg.Args[1]);
                        BasePlayer Suspect = BasePlayer.FindByID(SuspectID);
                        if (permission.UserHasPermission(player.UserIDString, PermissionModeration))
                            UI_OpenReasonsBan(player, SuspectID);
                        break;
                    }
                case "moderator_ban":
                    {
                        if (player == null) return;
                        ulong SuspectID = ulong.Parse(arg.Args[1]);
                        BasePlayer Suspect = BasePlayer.FindByID(SuspectID);
                        int Index = Convert.ToInt32(arg.Args[2]);
                        Metods_ModeratorBanned(player, SuspectID, Index);
                        break;
                    }
                case "moderator_stop":
                    {
                        if (player == null) return;
                        ulong SuspectID = ulong.Parse(arg.Args[1]);
                        BasePlayer Suspect = BasePlayer.FindByID(SuspectID);
                        if (permission.UserHasPermission(player.UserIDString, PermissionModeration))
                            Metods_CheckModerationFinish(player, SuspectID);
                        UI_RaitingSend(Suspect, player);
                        return;
                    }
                case "raiting": 
                    {
                        BasePlayer Moderator = BasePlayer.FindByID(ulong.Parse(arg.Args[1]));
                        int Raiting = Convert.ToInt32(arg.Args[2]);
                        var RaitingModerator = ModeratorInformation[Moderator.userID].Arrayrating;

                        VKSendMessage(String.Format(lang.GetMessage("UI_RAITING_MODERATION_VK_GIVE", this), player.displayName, player.UserIDString, Moderator.displayName, Moderator.UserIDString, Raiting));
                        DiscordSendMessage(String.Format(lang.GetMessage("UI_RAITING_MODERATION_VK_GIVE", this), player.displayName, player.UserIDString, Moderator.displayName, Moderator.UserIDString, Raiting));
                        SendChat(player, lang.GetMessage("UI_RAITING_MODERATION_VK_GIVE_THX", this, player.UserIDString));

                        RaitingModerator.Add(Raiting);

                        if (Raiting <= 2)
                        {
                            RemoveScore(Moderator.userID, config.RaitingSetting.RemoveAmountOneTwo);
                            SendChat(Moderator, String.Format(lang.GetMessage("UI_RAIT_ALERT_MODER", this, Moderator.UserIDString), Raiting, $"-{config.RaitingSetting.RemoveAmountOneTwo}"));
                            return;
                        }
                        if (Raiting > 2 && Raiting < 5)
                        {
                            SetScore(Moderator.userID, config.RaitingSetting.GiveAmountThreeFour);
                            SendChat(Moderator, String.Format(lang.GetMessage("UI_RAIT_ALERT_MODER", this, Moderator.UserIDString), Raiting, $"{config.RaitingSetting.GiveAmountThreeFour}"));
                            return;
                        }
                        if (Raiting >= 5)
                        {
                            SetScore(Moderator.userID, config.RaitingSetting.GiveAmountFive);
                            SendChat(Moderator, String.Format(lang.GetMessage("UI_RAIT_ALERT_MODER", this, Moderator.UserIDString), Raiting, $"{config.RaitingSetting.GiveAmountFive}"));
                            return;
                        }
                        break;
                    }
            }
        }
        #endregion

        public float GetAverageRaiting(ulong userID)
        {
            var Data = ModeratorInformation[userID];
            float AverageRaiting = Data.AverageRating;
            int RaitingFull = 0;
            for(int i = 0; i < Data.Arrayrating.Count; i++)
                RaitingFull += Data.Arrayrating[i];

            int FormulDivision = Data.Arrayrating.Count == 0 ? 1 : Data.Arrayrating.Count;
            AverageRaiting = RaitingFull / FormulDivision;
            return AverageRaiting;
        }

        #endregion

        #region Lang
        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["PLAYER_CHECKED"] = "The player had already check!",

                ["MSG_REPORTED_SUSPECT"] = "You have successfully submitted a player report - {0}\nReported : {1}\nThe moderator will review your complaint as soon as possible!",
                ["MSG_CHECK_DISCORD"] = "You can't send Discord without checking!",
                ["MSG_CHECK_CHECK_STOP"] = "You have successfully passed the test!\nWe wish you a pleasant game on our server!",
                ["MSG_COOLDOWN"] = "You have recently sent a complaint!\nWait <color=#47AF5DFF>{0}</color>",
                ["MSG_DISCORD_SEND"] = "You have successfully submitted the information!\nDiscord - {0}\nExpect a call from the moderator",

                ["UI_MODERATOR_PANEL_TITLE"] = "Server moderator menu",
                ["UI_MODERATOR_PANEL_DESCRIPTION"] = "This list shows players who have reached the limit of complaints,click on the player to get more information",
                ["UI_MODERATOR_PANEL_START_CHECK"] = "Call for verification",
                ["UI_STATUS"] = "Status",

                ["NETWORD_STATUS_ONLINE"] = "Online",
                ["IS_STEAM_STATUS_PIRATE"] = "Pirate",
                ["IS_STEAM_STATUS_LICENSE"] = "License",

                ["METODS_SEND_REPORT_VK"] = "[IQReportSystem]\nA complaint has been sent to player {0} ({1})!\nComplaint - {2}\nReporter : {3}({4})",
                ["METODS_HELP_MODERS"] = "Player <color=#47AF5DFF>{0}</color> reached the limit of reports!\nThe number of his reports - <color=#47AF5DFF>{1}</color>\nModeration that is free - check the player!",
                ["METODS_HELP_MODERS_VK"] = "[IQReportSystem]\nPlayer {0} reached the limit of reports!\nThe number of his reports - {1}\nModeration that is free - check the player!",
                ["METODS_MODER_START_CHECK"] = "You started checking!\nSuspect - <color=#47AF5DFF>{0}</color>\nGetting started with AFK!\nIf the player is not AFK, they will receive a notification of verification!",
                ["METODS_MODER_START_CHECK_VK"] = "[IQReportSystem]\nModerator {0}({1}) started checking!\nSuspect - {2}({3})",
                ["METODS_MODER_STOP_CHECK"] = "Verification completed.\nHave a nice day!\nDo not forget to check the complaint list!",
                ["METODS_MODER_STOP_CHECK_VK"] = "[IQReportSystem]\nModerator {0} finished checking!",
                ["NON_REPORT"] = "No complaints",
                ["MODERATOR_RETURN_WELCOME"] = "Welcome back!\nthe check was not canceled, continue!",
                ["STATUS_CHANGED"] = "The player's {0} status has changed to: {1}\n Wait for the player on the server for 10 minutes!\nIf the player does not enter after 10 minutes-issue a ban for Refusal",
                ["STATUS_CHANGED_VK"] = "[IQReportSystem]The player's {0} status has changed to: {1}\n Wait for the player on the server for 10 minutes!\nIf the player does not enter after 10 minutes-issue a ban for Refusal",
                ["MODERATOR_DISCONNECTED_STOP_CHECK"] = "The check was removed!\nModerator {0} left the server\nReason: connection Failure\nWe apologize!\nWe will inform the other moderation!",
                ["MODERATOR_DISCONNECTED_STOP_RESEND"] = "Moderator {0} finally left the server during verification!\n Player {1} is waiting for other moderators to check!",
                ["MODERATOR_COMPLETED_CHECK"] = "You successfully completed the review and delivered your verdict\nYour verdict : {0}",
                ["MODERATOR_COMPLETED_CHECK_VK"] = "[[IQ Report System]\nModerator {0}[(1)] finished checking \nSuspect {2}[{3}]\nVerdict : {4}\n[AFK Check]Player didn't move : {5}/5",
                ["PLAYER_AFK_CHECK_STOP"] = "Suspect AFK\nThe check is removed automatically!",
                ["PLAYER_AFK_CHECK_STOP_VK"] = "[IQReportSystem]\nModerator {0}({1}) checking the player {2}.\nThe AFK suspect and the check was removed!",
                ["PLAYER_AFK_CHANGE_POS"] = "The player was moving! Check {0}/5",
                ["PLAYER_AFK_CHANGE_NO_POS"] = "The player didn't move! Check {0}/5",
                ["PLAYER_NON_AFK"] = "The player moves.\nProverite on!",
                ["DISCORD_NULL"] = "Not provided",
                ["REPORT_LIST_CONSOLE"] = "\n[IQReportSystem]:\nList of players in the Moderation Panel",
                ["DISCROD_VK_SEND"] = "[IQReportSystem]\nSuspect {0}({1}) provided Discord for verification!\nDiscord - {2}",
                ["CONSOLE_REPORT_GIVE"] = "Player {0} is successfully added to the report in the amount of {1}. Its number is - {2}",
                ["CONSOLE_REPORT_REMOVE"] = "Player {0} successfully removed reports in the amount of - {1} His number is - {2}",
                ["MODERATOR_NON_OPEN_MENU"] = "You can't open the moderator menu when checking a player!\nFinish checking!",
                ["UI_RAITING_MODERATION_VK_GIVE"] = "[IQReportSystem]:\nPlayer {0}({1}) rated the work of moderator {2}({3}) on {4} stars",
                ["UI_RAITING_MODERATION_VK_GIVE_THX"] = "Thx!",
                ["UI_RAIT_ALERT_MODER"] = "Your work has been rated with {0} stars. You gain {1} reputation.",

                ["UI_NEW_CHECKED_COUNT"] = "<size=14>CHECKED: {0}</size>",
                ["UI_NEW_CLOSE"] = "<size=24><b>CLOSE</b></size>",

                ["UI_NEW_MODERATION_TITLE_PANEL"] = "<size=18>PANEL MODERATION</size>",
                ["UI_NEW_MODERATION_REPORT_BTN"] = "<size=20><b>REPORTS</b></size>",

                ["UI_NEW_MODERATION_TITLE_STATS"] = "<size=18><b>CHECK STATISTICS</b></size>",
                ["UI_NEW_MODERATION_STATS_COUNTCHECK"] = "<size=12>NUMBER OF CHECKS: {0}</size>",
                ["UI_NEW_MODERATION_STATS_COUNTBANS"] = "<size=12>BLOCKEDS: {0}</size>",
                ["UI_NEW_MODERATION_STATS_STARS"] = "<size=15><b>QUALITY CONTROL : {0}</b></size>",

                ["UI_NEW_MODERATION_REPORT_PANEL_TITLE"] = "<size=70><b>REPORTS</b></size>",
                ["UI_NEW_MODERATION_REPORT_PANEL_DESCRIPTION"] = "<size=10>CHOOSE A PLAYER TO SEND TO IT'S COMPLAINT</size>",
                ["UI_NEW_MODERATION_REPORT_PANEL_SEARCH_DESCRIPTION"] = "<size=14>ENTER NICK OR STEAM64ID TO SEARCH A PLAYER</size>",
                ["UI_NEW_MODERATION_REPORT_PANEL_DESCRIPTION_MODERATOR"] = "<size=10>SELECT A PLAYER IN THE PANEL TO START A CHECK</size>",
                ["UI_NEW_MODERATION_REPORT_PANEL_SEARCH_TITLE"] = "<size=50><b>SEARCH</b></size>",

                ["UI_NEW_MODERATION_REPORT_PANEL_PLAYER_REPORTEDS"] = "<size=14><b>REPORTS : {0}</b></size>",

                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_TITLE"] = "<size=30><b>COMPLAINT INFORMATION</b></size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_DESC"] = "<size=12>CHOOSE THE REASON FOR THE PLAYER COMPLAINT</size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_TITLE"] = "<size=25><b>PLAYER</b></size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_CLOSE"] = "<size=18><b>CLOSE</b></size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_LIST"] = "<size=20><b>CHOOSE THE REASON FROM THE LIST</b></size>",


                ["UI_NEW_MODERATION_MODER_GO_CHECK_TITLE"] = "<size=30><b>PLAYER INFORMATION</b></size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_DESC"] = "<size=12>CHOOSE ACTION WHICH YOU WANT TO PERFORM</size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_TITLE"] = "<size=25><b>DETAILED INFORMATION</b></size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_HISTORY_REPORT"] = "<size=18>HISTORY OF COMPLAINTS</size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_HISTORY_RCC"] = "<size=18>INFO RCC</size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_REPORTS"] = "<size=25><b>REPORTS</b></size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_LAST_CHECK"] = "<size=14>LAST CHECKER: {0}</size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_COUNT_CHECK"] = "<size=14>CHECK COUNTS: {0}</size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_GOCHECK"] = "<size=18>START</size>",

                ["UI_NEW_ALERT_PLAYER_WARNING"] = "<size=40><b>YOU CALLED TO THE TEST</b></size>",
                ["UI_NEW_ALERT_PLAYER_TITLE"] = "<size=18>You exceeded the maximum allowable number of complaints.\npoetomu,provide your ex, in order to be contacted by our moderation!\nPV case of ignoring this message, you will get a lock! (You have 5 minutes)</size>",
                ["UI_NEW_ALERT_PLAYER_DESC"] = "<size=15>to provide data for communication,use the commands:\n/discord\npdale you will be contacted by the moderator</size>",

                ["UI_NEW_MINI_PANEL_MODERATOR_TITLE"] = "<size=14><b>MENU MODERATOR</b></size>",
                ["UI_NEW_MINI_PANEL_MODERATOR_BAN"] = "<size=18><b>BAN</b></size>",
                ["UI_NEW_MINI_PANEL_MODERATOR_STOP"] = "<size=18><b>STOP</b></size>",

                ["UI_NEW_RAITING_PANEL"] = "<size=13><b>GIVE RAITING</b>></size>",

            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["PLAYER_CHECKED"] = "Данного игрока уже проверяют!",

                ["MSG_REPORTED_SUSPECT"] = "Вы успешно отправили жалобу на игрока - {0}\nЖалоба : {1}\nМодератор рассмотрит вашу жалобу как можно скорее!",
                ["MSG_CHECK_DISCORD"] = "Вы не можете отправить Discord без проверки!",
                ["MSG_CHECK_CHECK_STOP"] = "Вы успешно прошли проверку!\nЖелаем приятной игры на нашем сервере!",
                ["MSG_COOLDOWN"] = "Вы недавно отправляли жалобу!\nПодождите еще <color=#47AF5DFF>{0}</color>",
                ["MSG_DISCORD_SEND"] = "Вы успешно предоставили данные!\nDiscord - {0}\nОжидайте звонка от модератора",

                ["UI_MODERATOR_PANEL_TITLE"] = "Меню модератора сервера",
                ["UI_MODERATOR_PANEL_DESCRIPTION"] = "В данном списке отображены игроки - достигшие предела жалоб,нажмите по игроку чтобы получить больше информации",
                ["UI_MODERATOR_PANEL_START_CHECK"] = "Вызвать на проверку",
                ["UI_STATUS"] = "Статус",

                ["NETWORD_STATUS_ONLINE"] = "Онлайн",
                ["IS_STEAM_STATUS_PIRATE"] = "Пират",
                ["IS_STEAM_STATUS_LICENSE"] = "Лицензия", 

                ["METODS_SEND_REPORT_VK"] = "[IQReportSystem]\nНа игрока {0}({1}) отправили жалобу!\nЖалоба - {2}\nОтправил жалобу : {3}({4})",
                ["METODS_HELP_MODERS"] = "Игрок <color=#47AF5DFF>{0}</color> достиг предельного количества репортов!\nКоличество его репортов - <color=#47AF5DFF>{1}</color>\nМодерация которая свободна - проверьте игрока!",
                ["METODS_HELP_MODERS_VK"] = "[IQReportSystem]\nИгрок {0} достиг предельного количества репортов!\nКоличество его репортов - {1}\nМодерация которая свободна - проверьте игрока!",
                ["METODS_MODER_START_CHECK"] = "Вы начали проверку!\nПодозреваемый - <color=#47AF5DFF>{0}</color>\nНачинаем проверку на AFK!\nЕсли игрок не AFK - ему выведут уведомление о проверке!",
                ["METODS_MODER_START_CHECK_VK"] = "[IQReportSystem]\nМодератор {0}({1}) начал проверку!\nПодозреваемый - {2}({3})",
                ["METODS_MODER_STOP_CHECK"] = "Проверка завершена.\nУдачного дня!\nНе забывай проверять список жалоб!",
                ["METODS_MODER_STOP_CHECK_VK"] = "[IQReportSystem]\nМодератор {0} закончил проверку!",
                ["NON_REPORT"] = "Жалоб нет",
                ["MODERATOR_RETURN_WELCOME"] = "С возвращением!\nПроверка не была отменена,продолжайте!",
                ["STATUS_CHANGED"] = "У игрока {0} изменился статус на : {1}\nОжидайте игрока на сервере в течении 10 минут!\nЕсли игрок не зайдет после 10 минут - выдавайте бан за Отказ",
                ["STATUS_CHANGED_VK"] = "[IQReportSystem]У игрока {0} изменился статус на : {1}\nОжидайте игрока на сервере в течении 10 минут!\nЕсли игрок не зайдет после 10 минут - выдавайте бан за Отказ",
                ["MODERATOR_DISCONNECTED_STOP_CHECK"] = "Проверка была снята!\nМодератор {0} покинул сервер\n Причина : Разрыв соединения\nПриносим свои извинения!\nМы сообщим другой модерации!",
                ["MODERATOR_DISCONNECTED_STOP_RESEND"] = "Модератор {0} окончательно покинул сервер во время проверки!\nИгрок {1} ожидает других модераторов для проверки!",
                ["MODERATOR_COMPLETED_CHECK"] = "Вы успешно завершили проверку и вынесли свой вердикт\nВаш вердикт : {0}",
                ["MODERATOR_COMPLETED_CHECK_VK"] = "[IQReportSystem]\nМодератор {0}[(1)] закончил проверку\n Подозреваемый {2}[{3}]\nВердикт : {4}\n[Проверка на AFK]Игрок не двигался : {5}/5",
                ["PLAYER_AFK_CHECK_STOP"] = "Игрок AFK\nПроверка снята автоматически!",
                ["PLAYER_AFK_CHECK_STOP_VK"] = "[IQReportSystem]\nМодератор {0}({1}) проверял игрока {2}.\nИгрок AFK и проверка была снята!",
                ["PLAYER_AFK_CHANGE_POS"] = "Игрок двигался! Проверка {0}/5",
                ["PLAYER_AFK_CHANGE_NO_POS"] = "Игрок не двигался! Проверка {0}/5",
                ["PLAYER_NON_AFK"] = "Игрок двигается.\nПроверяйте дальше!",
                ["DISCORD_NULL"] = "Не предоставлен",
                ["REPORT_LIST_CONSOLE"] = "\n[IQReportSystem]:\nСписок игроков в Панели-Модерации",
                ["DISCROD_VK_SEND"] = "[IQReportSystem]\nИгрок {0}({1}) предоставил Discord на проверку!\nDiscord - {2}",
                ["CONSOLE_REPORT_GIVE"] = "Игроку {0} успешно добавлены репорты в количестве - {1}. Его количество составляет - {2}",
                ["CONSOLE_REPORT_REMOVE"] = "Игроку {0} успешно сняты репорты в количестве - {1} Его количество составляет - {2}",
                ["MODERATOR_NON_OPEN_MENU"] = "Вы не можете открыть меню модератора при проверке игрока!\nОкончите проверку!",
                ["UI_RAITING_MODERATION_VK_GIVE"] = "[IQReportSystem]:\nИгрок {0}({1}) оценил работу модератора {2}({3}) на {4} звезды",
                ["UI_RAITING_MODERATION_VK_GIVE_THX"] = "Спасибо за ваш отзыв!",
                ["UI_RAIT_ALERT_MODER"] = "Вашу работу оценили в {0} звезд(ы). Вы получаете {1} репутации",


                ["UI_NEW_CHECKED_COUNT"] = "<size=14>ПРОВЕРЕН: {0}</size>",
                ["UI_NEW_CLOSE"] = "<size=24><b>ЗАКРЫТЬ</b></size>",

                ["UI_NEW_MODERATION_TITLE_PANEL"] = "<size=18>ПАНЕЛЬ ПРОВЕРЯЮЩЕГО</size>",
                ["UI_NEW_MODERATION_REPORT_BTN"] = "<size=20><b>ЖАЛОБЫ</b></size>",

                ["UI_NEW_MODERATION_TITLE_STATS"] = "<size=18><b>СТАТИСТИКА ПРОВЕРЯЮЩЕГО</b></size>",
                ["UI_NEW_MODERATION_STATS_COUNTCHECK"] = "<size=12>КОЛИЧЕСТВО ПРОВЕРОК: {0}</size>",
                ["UI_NEW_MODERATION_STATS_COUNTBANS"] = "<size=12>БЛОКИРОВОК ВЫДАНО: {0}</size>",
                ["UI_NEW_MODERATION_STATS_STARS"] = "<size=15><b>ОЦЕНКА КАЧЕСТВА : {0}</b></size>",

                ["UI_NEW_MODERATION_REPORT_PANEL_TITLE"] = "<size=70><b>ЖАЛОБЫ</b></size>",
                ["UI_NEW_MODERATION_REPORT_PANEL_DESCRIPTION"] = "<size=10>ВЫБЕРИТЕ ИГРОКА ЧТОБЫ ОТПРАВИТЬ НА НЕГО ЖАЛОБУ</size>",
                ["UI_NEW_MODERATION_REPORT_PANEL_DESCRIPTION_MODERATOR"] = "<size=10>ВЫБЕРИТЕ ИГРОКА В ПАНЕЛИ ЧТОБЫ НАЧАТЬ ПРОВЕРКУ</size>",
                ["UI_NEW_MODERATION_REPORT_PANEL_SEARCH_DESCRIPTION"] = "<size=14>ВВЕДИТЕ НИК ИЛИ STEAM64ID ДЛЯ ПОИСКА ИГРОКА</size>",
                ["UI_NEW_MODERATION_REPORT_PANEL_SEARCH_TITLE"] = "<size=50><b>ПОИСК</b></size>",

                ["UI_NEW_MODERATION_REPORT_PANEL_PLAYER_REPORTEDS"] = "<size=14><b>ЖАЛОБЫ : {0}</b></size>",

                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_TITLE"] = "<size=30><b>ИНФОРМАЦИЯ О ЖАЛОБЕ</b></size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_DESC"] = "<size=12>ВЫБЕРИТЕ ПРИЧИНУ ДЛЯ ЖАЛОБЫ НА ИГРОКА</size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_TITLE"] = "<size=25><b>ИГРОК</b></size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_CLOSE"] = "<size=18><b>ЗАКРЫТЬ</b></size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_LIST"] = "<size=20><b>ВЫБЕРИТЕ ПРИЧИНУ ИЗ СПИСКА</b></size>",

                ["UI_NEW_MODERATION_MODER_GO_CHECK_TITLE"] = "<size=30><b>ИНФОРМАЦИЯ О ИГРОКЕ</b></size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_DESC"] = "<size=12>ВЫБЕРИТЕ ДЕЙСТВИЯ КОТОРОЕ ХОТИТЕ СОВЕРШИТЬ</size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_TITLE"] = "<size=25><b>ПОДРОБНАЯ ИНФОРМАЦИЯ</b></size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_HISTORY_REPORT"] = "<size=18>ИСТОРИЯ ЖАЛОБ</size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_HISTORY_RCC"] = "<size=18>ИНФОРМАЦИЯ RCC</size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_REPORTS"] = "<size=25><b>ЖАЛОБ</b></size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_LAST_CHECK"] = "<size=14>ПОСЛЕДНИЙ ПРОВЕРЯЮЩИЙ : {0}</size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_COUNT_CHECK"] = "<size=14>КОЛИЧЕСТВО ПРОВЕРОК: {0}</size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_GOCHECK"] = "<size=18>ПРОВЕРИТЬ</size>",

                ["UI_NEW_ALERT_PLAYER_WARNING"] = "<size=40><b>ВАС ВЫЗВАЛИ НА ПРОВЕРКУ</b></size>",
                ["UI_NEW_ALERT_PLAYER_TITLE"] = "<size=18>Вы превысили максимально-допустимое количество жалоб.\nПоэтому,предоставьте ваш Discord, для того чтобы с вами связалась наша модерация!\nВ случае игнорирования данного сообщения - вы получите блокировку! (У вас имеется 5 минут)</size>",
                ["UI_NEW_ALERT_PLAYER_DESC"] = "<size=15>Чтобы предоставить данные для связи,используйте команды:\n/discord\nДалее с вами свяжется модератор</size>",

                ["UI_NEW_MINI_PANEL_MODERATOR_TITLE"] = "<size=14><b>МЕНЮ ПРОВЕРЯЮЩЕГО</b></size>",
                ["UI_NEW_MINI_PANEL_MODERATOR_BAN"] = "<size=18><b>ВЕРДИКТ</b></size>",
                ["UI_NEW_MINI_PANEL_MODERATOR_STOP"] = "<size=18><b>СТОП</b></size>",


                ["UI_NEW_RAITING_PANEL"] = "<size=13><b>ОЦЕНИТЕ ПРОВЕРЯЮЩЕГО</b>></size>",
            }, this, "ru");
            PrintWarning("Языковой файл загружен успешно");
        }
        #endregion

        #region Interface

        public static string PARENT_UI =  "MAIN_PARENT_UI";
        public static string PARENT_UI_REPORT_MENU = "PARENT_UI_REPORT_MENU";
        public static string PARENT_UI_PLAYER_PANEL = "PARENT_UI_PLAYER_PANEL";
        public static string PARENT_UI_PLAYER_REPORT = "PARENT_UI_PLAYER_REPORT";
        public static string PARENT_UI_MODER_REPORT = "PARENT_UI_MODER_REPORT";
        public static string PARENT_UI_ALERT_SEND = "PARENT_UI_ALERT_SEND";
        public static string PARENT_UI_MODERATOR_MINI_PANEL = "PARENT_UI_MODERATOR_MINI_PANEL";
        private static string UI_MODERATION_CHECK_MENU_DISCORD = "UI_MODERATION_CHECK_MENU_DISCORD_PARENT";
        private static string UI_MODERATION_CHECK_MENU_NETWORK = "UI_MODERATION_CHECK_MENU_NETWORK_PARENT";
        private static string UI_MODERATION_RAITING = "UI_MODERATION_RAITING";


        #region UI Main Interface
        void UI_Interface(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, PARENT_UI);
            var Interface = config.Setting.Interface;
            var InformationUser = ReportInformation[player.userID];

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-200 0", OffsetMax = "0 720" },
                Image = { FadeIn = 0.15f, Color = HexToRustFormat(Interface.HexRightMenu), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            }, "Overlay", PARENT_UI);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.006666541 0.7046295", AnchorMax = "1 0.7462999" },
                Text = { Text = $"<b><size=22>{player.displayName}</size></b>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperCenter }
            }, PARENT_UI);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.6851852", AnchorMax = "1 0.7166605" },
                Text = { Text = String.Format(lang.GetMessage("UI_NEW_CHECKED_COUNT", this, player.UserIDString), InformationUser.CheckCount), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperCenter }
            }, PARENT_UI);

            string ImageAvatar = GetImage(player.UserIDString, 0);
            container.Add(new CuiElement
            {
                Parent = PARENT_UI,
                Name = $"AVATAR",
                Components =
                 {
                    new CuiRawImageComponent { Png = ImageAvatar,Color = HexToRustFormat("#FFFFFFFF") },
                    new CuiRectTransformComponent{ AnchorMin = "0.08076949 0.7518547", AnchorMax = $"0.9341028 0.9888917"},
                 }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.05555556" },
                Button = { Close = PARENT_UI, Color = "0 0 0 0" },
                Text = { Text = lang.GetMessage("UI_NEW_CLOSE", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Align = TextAnchor.MiddleCenter }
            }, PARENT_UI);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.6851852", AnchorMax = "1 0.7166605" },
                Text = { Text = String.Format(lang.GetMessage("UI_NEW_CHECKED_COUNT", this, player.UserIDString), InformationUser.CheckCount), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperCenter }
            }, PARENT_UI);

            if (permission.UserHasPermission(player.UserIDString, PermissionModeration))
            {
                var InformationModerator = ModeratorInformation[player.userID];

                #region PANEL MODERATION MENU

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0.4907467", AnchorMax = "1 0.5574059" },
                    Text = { Text = lang.GetMessage("UI_NEW_MODERATION_TITLE_PANEL", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                }, PARENT_UI);

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.1533333 0.4212967", AnchorMax = "1 0.47963" },
                    Button = { Command = "iqreport moderation_menu", Color = HexToRustFormat(Interface.HexButtonRightMenu), Material = "assets/content/ui/uibackgroundblur.mat" },
                    Text = { Text = lang.GetMessage("UI_NEW_MODERATION_REPORT_BTN", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Align = TextAnchor.MiddleCenter }
                },  PARENT_UI, "BTN_REPORTS");

                container.Add(new CuiElement
                {
                    Parent = "BTN_REPORTS",
                    Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = Interface.SpriteReportModeration },
                        new CuiRectTransformComponent { AnchorMin = "0.02362165 0", AnchorMax = "0.2755902 1" }
                    }
                });

                #endregion

                #region STATS PANEL MODERATION MENU

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0.2574087", AnchorMax = "1 0.3138935" },
                    Text = { Text = lang.GetMessage("UI_NEW_MODERATION_TITLE_STATS", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                }, PARENT_UI);

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0.003333271 0.1240732", AnchorMax = "1 0.2500008" },
                    Image = { Color = HexToRustFormat(Interface.HexButtonRightMenu), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
                },  PARENT_UI, "STATS_MODERATION");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0.6911764", AnchorMax = "1 1" },
                    Text = { Text = String.Format(lang.GetMessage("UI_NEW_MODERATION_STATS_COUNTCHECK", this, player.UserIDString), InformationModerator.CheckCount), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                },  "STATS_MODERATION");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0.5441177", AnchorMax = "1 0.7499995" },
                    Text = { Text = String.Format(lang.GetMessage("UI_NEW_MODERATION_STATS_COUNTBANS", this, player.UserIDString), InformationModerator.BanPlayerModerator.Count), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                }, "STATS_MODERATION");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.2573562" },
                    Text = { Text = String.Format(lang.GetMessage("UI_NEW_MODERATION_STATS_STARS", this, player.UserIDString), GetAverageRaiting(player.userID)), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.LowerCenter }
                }, "STATS_MODERATION");

                for (int i = 0; i < 5; i++)
                {
                    string ColorStar = Math.Floor(GetAverageRaiting(player.userID)) == 0 ? "#D9BA6AA2" : Math.Floor(GetAverageRaiting(player.userID)) >= i+1 ? "#d9ba6a" : "#D9BA6AA2";
                    container.Add(new CuiElement
                    {
                        Parent = "STATS_MODERATION",
                        Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(ColorStar), Sprite = Interface.SpriteRaiting },
                        new CuiRectTransformComponent { AnchorMin = $"{0.07023425 + (i * 0.175)} 0.2058797", AnchorMax = $"{0.2307694 + (i * 0.175)} 0.5661694" }
                    }
                    });
                }

                #endregion
            }

            CuiHelper.AddUi(player, container);
            UI_PanelReportsPlayer(player);
        }

        #endregion

        #region UI Panel Reports Interface

        void UI_PanelReportsPlayer(BasePlayer player, bool Moderation = false)
        {
            var Interface = config.Setting.Interface;
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, PARENT_UI_REPORT_MENU);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "-1080 0", OffsetMax = "0 720" },
                Image = { Color = HexToRustFormat(Interface.HexMainPanel), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            },  PARENT_UI, PARENT_UI_REPORT_MENU);

            container.Add(new CuiElement
            {
                Parent = PARENT_UI_REPORT_MENU,
                Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = Interface.SpriteReport },
                        new CuiRectTransformComponent { AnchorMin = "0.007901235 0.8648087", AnchorMax = "0.09876543 0.9833272" }
                    }
            });

            string SearchName = "";
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.3799841 0.8888888", AnchorMax = "0.7234467 0.925926" },
                Image = { Color = HexToRustFormat(Interface.HexSearchPanel), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            },  PARENT_UI_REPORT_MENU, PARENT_UI_REPORT_MENU + ".Input");

            container.Add(new CuiElement
            {
                Parent = PARENT_UI_REPORT_MENU + ".Input",
                Name = PARENT_UI_REPORT_MENU + ".Input.Current",
                Components =
                { 
                    new CuiInputFieldComponent { Text = SearchName, FontSize = 14,Command = $"iqreport search {Moderation} {0} {SearchName}", Align = TextAnchor.MiddleLeft, Color = HexToRustFormat(Interface.HexLabels), CharsLimit = 15},
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.09925909 0.8462963", AnchorMax = "0.4113576 0.9805495" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_REPORT_PANEL_TITLE", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, PARENT_UI_REPORT_MENU);

            string DescriptionReportTitle = Moderation ? "UI_NEW_MODERATION_REPORT_PANEL_DESCRIPTION_MODERATOR" : "UI_NEW_MODERATION_REPORT_PANEL_DESCRIPTION";
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.1 0.9546276", AnchorMax = "0.38 0.98" },
                Text = { Text = lang.GetMessage(DescriptionReportTitle, this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, PARENT_UI_REPORT_MENU);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.7315881 0.8675926", AnchorMax = "0.9332467 0.9527467" }, 
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_REPORT_PANEL_SEARCH_TITLE", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, PARENT_UI_REPORT_MENU);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.3799841 0.9277778", AnchorMax = "0.7313576 0.95" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_REPORT_PANEL_SEARCH_DESCRIPTION", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, PARENT_UI_REPORT_MENU);

            CuiHelper.AddUi(player, container);
            UI_Player_Loaded(player, Moderation);
        }

        #endregion

        #region UI Player Loaded Interface
        void UI_Player_Loaded(BasePlayer player, bool Moderation = false, int Page = 0, string TargetName = "")
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, PARENT_UI_PLAYER_PANEL);
            var Interface = config.Setting.Interface;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.8296296" },
                Image = { Color = "0 0 0 0" }
            }, PARENT_UI_REPORT_MENU, PARENT_UI_PLAYER_PANEL);

            int x = 0, y = 0, i = 0;
            IEnumerable<BasePlayer> playerList = Moderation ? BasePlayer.activePlayerList.Where(z => ReportInformation[z.userID].ReportCount >= config.Setting.MaxReport).Skip(Page * 20) 
                                                            : BasePlayer.activePlayerList.Where(z => z.displayName.Contains(TargetName) || z.UserIDString.Contains(TargetName)).Skip(Page * 20);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.4866512 0.008887243", AnchorMax = "0.5140741 0.05357143" },
                Text = { Text = $"<size=20>{Page}</size>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, PARENT_UI_PLAYER_PANEL);
            if ((playerList.Count() - (Page * 20)) > 20)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.5222067 0.008887243", AnchorMax = "0.5496294 0.05357143" },
                    Button = { Command = $"iqreport page next {Moderation} {Page}", Color = HexToRustFormat(Interface.HexPlayerButton), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                    Text = { Text = "<b><size=20>></size></b>", Align = TextAnchor.MiddleCenter }
                },  PARENT_UI_PLAYER_PANEL);
            }
            if(Page > 0)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.4510956 0.008887243", AnchorMax = "0.4785185 0.05357143" },
                    Button = { Command = $"iqreport page back {Moderation} {Page}", Color = HexToRustFormat(Interface.HexPlayerButton), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                    Text = { Text = "<b><size=20><</size></b>", Align = TextAnchor.MiddleCenter }
                }, PARENT_UI_PLAYER_PANEL);
            }
            foreach (BasePlayer p in playerList)
            {
                if (Friends != null)
                    if (config.Setting.FriendNoReport)
                        if ((bool)Friends.Call("HasFriend", player.userID, p.userID)) continue;

                if (p.userID == player.userID) continue;

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"{0.00246954 + (x * 0.2585)} {0.8671876 - (y * 0.2)}", AnchorMax = $"{0.2 + (x * 0.2585)} {0.9910715 - (y * 0.2)}" },
                    Image = { Color = HexToRustFormat(Interface.HexSearchPanel), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
                },  PARENT_UI_PLAYER_PANEL, $"PLAYER_{i}");

                string ImageAvatar = GetImage(p.UserIDString, 0);
                container.Add(new CuiElement
                {
                    Parent = $"PLAYER_{i}",
                    Components =
                 {
                    new CuiRawImageComponent { Png = ImageAvatar,Color = HexToRustFormat("#FFFFFFAA") },
                    new CuiRectTransformComponent{ AnchorMin = "0 0", AnchorMax = $"0.3600007 1"},
                 }
                });

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.3699992 0.6756751", AnchorMax = "1 1" },
                    Text = { Text = $"<b><size=16>{p.displayName}</size></b>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
                },  $"PLAYER_{i}");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.3699992 0.432432", AnchorMax = "1 0.7567569" },
                    Text = { Text = $"<size=14>{p.UserIDString}</size>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
                }, $"PLAYER_{i}");

                string CMDD = Moderation ? $"iqreport moderation_send {p.userID}" : $"iqreport reports_menu {p.userID}";
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "2 0", OffsetMax = "22 75" },
                    Button = { Command = CMDD, Color = HexToRustFormat(Interface.HexPlayerButton) },
                    Text = { Text = "" }
                },  $"PLAYER_{i}", $"BTN_ACTION_{i}");

                container.Add(new CuiElement
                {
                    Parent = $"BTN_ACTION_{i}",
                    Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = Interface.SpritePlayerButton },
                        new CuiRectTransformComponent { AnchorMin = "0 0.41", AnchorMax = "0.96 0.62" }
                    }
                });

                if (Moderation)
                {
                    var InformationUser = ReportInformation[p.userID];

                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0.3699992 0.01801781", AnchorMax = "1 0.2342333" },
                        Text = { Text = String.Format(lang.GetMessage("UI_NEW_MODERATION_REPORT_PANEL_PLAYER_REPORTEDS",this, p.UserIDString), InformationUser.ReportCount), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
                    }, $"PLAYER_{i}");
                }

                i++;
                x++;
                if(x == 4)
                {
                    x = 0;
                    y++;
                }
                if(y == 5 && x == 0)
                    break;
            }
            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region UI Send Report
        void UI_SendReport(BasePlayer player, BasePlayer Suspect)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, PARENT_UI_PLAYER_REPORT);
            var InterfaceReport = config.Setting.Interface.ReasonInterface;
            var Interface= config.Setting.Interface;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Color = HexToRustFormat("#21211AF2") }
            },  "Overlay", PARENT_UI_PLAYER_REPORT);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.25 0.1768519", AnchorMax = "0.7 0.8" },
                Image = { Color = HexToRustFormat(InterfaceReport.HexMain) }
            },  PARENT_UI_PLAYER_REPORT,"PANEL_MAIN_REPORT");

            #region TitlePanel

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.8662704", AnchorMax = "1 1" },
                Image = { Color = HexToRustFormat(InterfaceReport.HexTitlePanel) }
            },  "PANEL_MAIN_REPORT", "TITLE_PANEL");

            container.Add(new CuiElement
            {
                Parent = $"TITLE_PANEL",
                Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = InterfaceReport.SpriteTitlePanel },
                        new CuiRectTransformComponent { AnchorMin = "0.01851851 0.1000004", AnchorMax = "0.09259258 0.8111112" }
                    }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.09953713 0", AnchorMax = "1 0.6333335" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_SEND_REPORT_PANEL_TITLE",this,player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            },  "TITLE_PANEL");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.09953713 0.4444447", AnchorMax = "1 0.9" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_SEND_REPORT_PANEL_DESC", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "TITLE_PANEL");

            #endregion

            #region MainPanel
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.09143519 0.7028232", AnchorMax = "0.2731481 0.768202" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_TITLE", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "PANEL_MAIN_REPORT");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.5973254", AnchorMax = "1 0.6493313" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_LIST", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, "PANEL_MAIN_REPORT");

            string ImageAvatar = GetImage(Suspect.UserIDString, 0);
            container.Add(new CuiElement
            {
                Parent = $"PANEL_MAIN_REPORT",
                Components =
                 {
                    new CuiRawImageComponent { Png = ImageAvatar,Color = HexToRustFormat("#FFFFFFAA") },
                    new CuiRectTransformComponent{ AnchorMin = "0.33449 0.6909361", AnchorMax = $"0.4085641 0.7860327"},
                 }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.412036 0.7444279", AnchorMax = "0.9918982 0.7860327" },
                Text = { Text = $"<b><size=14>{Suspect.displayName}</size></b>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
            }, "PANEL_MAIN_REPORT");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.412036 0.6909361", AnchorMax = "0.9918982 0.7265974" },
                Text = { Text = $"<size=12>{Suspect.UserIDString}</size>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
            }, "PANEL_MAIN_REPORT");
            #endregion

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.3263901 0.01188706", AnchorMax = "0.6678232 0.08023772" },
                Button = { Close = PARENT_UI_PLAYER_REPORT, Color = HexToRustFormat(InterfaceReport.HexClose) },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_CLOSE",this,player.UserIDString), Align = TextAnchor.MiddleCenter }
            }, $"PANEL_MAIN_REPORT", $"BTN_CLOSE");

            container.Add(new CuiElement
            {
                Parent = $"BTN_CLOSE",
                Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = InterfaceReport.SpriteClose },
                        new CuiRectTransformComponent { AnchorMin = "0.006779703 0.04347827", AnchorMax = "0.1491535 0.9565219" }
                    }
            });

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.09509653", AnchorMax = "1 0.5884101" },
                Image = { Color = "0 0 0 0" }
            }, "PANEL_MAIN_REPORT", "PANEL_MAIN_REPORT_REASON");

            int x = 0, y = 0, i = 0;
            foreach(var Reason in config.ReasonReport)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{0.06944443 + (x * 0.45)} {0.8253011 - (y * 0.2)}", AnchorMax = $"{0.4895834 + (x * 0.45)} {0.9879518 - (y * 0.2)}" },
                    Button = { Close = PARENT_UI_PLAYER_REPORT, Command = $"iqreport send_report {Suspect.userID} {i}", Color = HexToRustFormat(InterfaceReport.HexButton) },
                    Text = { Text = Reason, Align = TextAnchor.MiddleCenter, Color = HexToRustFormat(InterfaceReport.HexLabel) }
                }, $"PANEL_MAIN_REPORT_REASON", $"REASON_{i}");

                x++;
                i++;
                if (x == 2)
                {
                    x = 0;
                    y++;
                }
                if (x == 0 && y == 5)
                    break;
            }

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region UI Moder Report
        void UI_ModerReport(BasePlayer player, BasePlayer Suspect)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, PARENT_UI_MODER_REPORT);
            var InterfaceReport = config.Setting.Interface.ReasonInterface;
            var Interface = config.Setting.Interface;
            var Data = ReportInformation[Suspect.userID];

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Color = HexToRustFormat("#21211AF2") }
            }, "Overlay", PARENT_UI_MODER_REPORT);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.25 0.1768519", AnchorMax = "0.7 0.8" },
                Image = { Color = HexToRustFormat(InterfaceReport.HexMain) }
            }, PARENT_UI_MODER_REPORT, "PANEL_MAIN_REPORT");

            #region TitlePanel

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.8662704", AnchorMax = "1 1" },
                Image = { Color = HexToRustFormat(InterfaceReport.HexTitlePanel) }
            }, "PANEL_MAIN_REPORT", "TITLE_PANEL");

            container.Add(new CuiElement
            {
                Parent = $"TITLE_PANEL",
                Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = InterfaceReport.SpriteTitlePanel },
                        new CuiRectTransformComponent { AnchorMin = "0.01851851 0.1000004", AnchorMax = "0.09259258 0.8111112" }
                    }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.09953713 0", AnchorMax = "1 0.6333335" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_MODER_GO_CHECK_TITLE", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "TITLE_PANEL");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.09953713 0.4444447", AnchorMax = "1 0.9" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_MODER_GO_CHECK_DESC", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "TITLE_PANEL");

            #endregion

            #region MainPanel
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.09143519 0.7028232", AnchorMax = "0.2731481 0.768202" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_TITLE", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "PANEL_MAIN_REPORT");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.5482913", AnchorMax = "1 0.6136701" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_MODER_GO_CHECK_MORE_TITLE", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, "PANEL_MAIN_REPORT");

            string ImageAvatar = GetImage(Suspect.UserIDString, 0);
            container.Add(new CuiElement
            {
                Parent = $"PANEL_MAIN_REPORT",
                Components =
                 {
                    new CuiRawImageComponent { Png = ImageAvatar,Color = HexToRustFormat("#FFFFFFAA") },
                    new CuiRectTransformComponent{ AnchorMin = "0.33449 0.6909361", AnchorMax = $"0.4085641 0.7860327"},
                 }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.412036 0.7444279", AnchorMax = "0.9918982 0.7860327" },
                Text = { Text = $"<b><size=14>{Suspect.displayName}</size></b>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
            }, "PANEL_MAIN_REPORT");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.412036 0.6909361", AnchorMax = "0.9918982 0.7265974" },
                Text = { Text = $"<size=12>{Suspect.UserIDString}</size>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
            }, "PANEL_MAIN_REPORT");
            #endregion

            #region MoreDetalis

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.00925926 0.4695395", AnchorMax = "0.3611112 0.5349182" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_MODER_GO_CHECK_MORE_HISTORY_REPORT", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            },  "PANEL_MAIN_REPORT");

            string LastCheck = String.IsNullOrEmpty(Data.LastCheckModerator) ? "Не был проверен" : Data.LastCheckModerator;
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.01041757 0.1738484", AnchorMax = "0.6319444 0.2392275" },
                Text = { Text = String.Format(lang.GetMessage("UI_NEW_MODERATION_MODER_GO_CHECK_MORE_LAST_CHECK", this, player.UserIDString), LastCheck), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "PANEL_MAIN_REPORT");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.0104176 0.127786", AnchorMax = "0.5497685 0.1931651" },
                Text = { Text = String.Format(lang.GetMessage("UI_NEW_MODERATION_MODER_GO_CHECK_MORE_COUNT_CHECK", this, player.UserIDString), Data.CheckCount), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "PANEL_MAIN_REPORT");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.6377296 0.1456166", AnchorMax = "0.8194424 0.2139673" },
                Text = { Text = String.Format(lang.GetMessage("UI_NEW_MODERATION_MODER_GO_CHECK_MORE_REPORTS", this, player.UserIDString)), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "PANEL_MAIN_REPORT");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.8275464 0.1411597", AnchorMax = "0.9953676 0.2243681" },
                Text = { Text = $"<size=30><b>{Data.ReportCount}</b></size>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, "PANEL_MAIN_REPORT");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.009259251 0.2496285", AnchorMax = "0.3611112 0.4680535" },
                Image = { Color = "0 0 0 0" }
            }, "PANEL_MAIN_REPORT", "REPORT_HISTORY_PANEL");

            for (int i = 0; i < ReportInformation[Suspect.userID].ReportHistory.Count; i++)
            {
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = $"0 {0.7755102 - (i * 0.18)}", AnchorMax = $"1 {1 - (i * 0.18)}" },
                    Text = { Text = ReportInformation[Suspect.userID].ReportHistory[i], FontSize = 15, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter, Color = HexToRustFormat(Interface.HexLabels) }
                },  "REPORT_HISTORY_PANEL", $"REASON_{i}");

                if (i >= 5) break;
            }

            if (config.RCCSetting.RCCUse)
            {
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.6400454 0.4695393", AnchorMax = "0.9918971 0.5349184" },
                    Text = { Text = lang.GetMessage("UI_NEW_MODERATION_MODER_GO_CHECK_MORE_HISTORY_RCC", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                }, "PANEL_MAIN_REPORT");

                string Key = config.RCCSetting.Key;
                if (!String.IsNullOrEmpty(Key))
                {
                    try
                    {
                        string API = $"https://rustcheatcheck.ru/panel/api?action=getInfo&key={Key}&player={Suspect.userID}";
                        webrequest.EnqueueGet(API, (code, response) =>
                        {
                            string ServersCheck = "Был проверен на серверах:";
                            var resources = JsonConvert.DeserializeObject<Response>(response);
                            if (resources.last_check == null)
                                ServersCheck += $"\nНе проверялся";
                            else
                            {
                                foreach (var resource in resources.last_check)
                                    ServersCheck += $"\n{resource.serverName}";
                            }

                            CuiHelper.DestroyUi(player, "LABELRCC");
                            CuiElementContainer RCCCONT = new CuiElementContainer();

                            RCCCONT.Add(new CuiLabel
                            {
                                RectTransform = { AnchorMin = $"0.6400445 0.3254086", AnchorMax = $"0.9918977 0.4665672" },
                                Text = { Text = ServersCheck, FontSize = 15, Font = "robotocondensed-regular.ttf", Align = TextAnchor.UpperCenter, Color = HexToRustFormat(Interface.HexLabels) }
                            }, "PANEL_MAIN_REPORT", "LABELRCC");

                            CuiHelper.AddUi(player, RCCCONT);
                        }, this);
                    }
                    catch (Exception ex) { }
                }
            }

            #endregion

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.1006964 0.01188706", AnchorMax = "0.4421295 0.08023772" },
                Button = { Close = PARENT_UI_MODER_REPORT, Color = HexToRustFormat(InterfaceReport.HexClose) },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_CLOSE", this, player.UserIDString), Align = TextAnchor.MiddleCenter }
            }, $"PANEL_MAIN_REPORT", $"BTN_CLOSE");

            container.Add(new CuiElement
            {
                Parent = $"BTN_CLOSE",
                Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = InterfaceReport.SpriteClose },
                        new CuiRectTransformComponent { AnchorMin = "0.006779703 0.04347827", AnchorMax = "0.1491535 0.9565219" }
                    }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5462967 0.01188706", AnchorMax = "0.8877298 0.08023772" },
                Button = { Close = PARENT_UI_MODER_REPORT, Command = $"iqreport send_check {Suspect.userID}", Color = HexToRustFormat(InterfaceReport.HexButton) },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_GOCHECK", this, player.UserIDString), Align = TextAnchor.MiddleCenter }
            }, $"PANEL_MAIN_REPORT", $"BTN_GO_CHECK");

            container.Add(new CuiElement
            {
                Parent = $"BTN_GO_CHECK",
                Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = InterfaceReport.SpriteClose },
                        new CuiRectTransformComponent { AnchorMin = "0.006779703 0.04347827", AnchorMax = "0.1491535 0.9565219" }
                    }
            });

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region UI Alert Player Check
        void UI_AlertSendPlayer(BasePlayer Suspect)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(Suspect, PARENT_UI_ALERT_SEND);
            var InterfaceAlert = config.Setting.Interface.AlertInterface;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.575", AnchorMax = "1 0.8888889" },
                Image = { FadeIn = 0.15f, Color = HexToRustFormat(InterfaceAlert.HexMain), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            }, "Overlay", PARENT_UI_ALERT_SEND);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.365625 0.2595869", AnchorMax = "0.6463541 0.2772861" },
                Image = { Color = HexToRustFormat(InterfaceAlert.HexTitle), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            },  PARENT_UI_ALERT_SEND);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.7079645", AnchorMax = "1 1" },
                Text = { Text = lang.GetMessage("UI_NEW_ALERT_PLAYER_WARNING",this, Suspect.UserIDString), Color = HexToRustFormat(InterfaceAlert.HexTitle), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperCenter }
            }, PARENT_UI_ALERT_SEND);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.2949852", AnchorMax = "1 0.761062" },
                Text = { Text = lang.GetMessage("UI_NEW_ALERT_PLAYER_TITLE", this, Suspect.UserIDString), Color = HexToRustFormat(InterfaceAlert.HexLabel), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperCenter }
            }, PARENT_UI_ALERT_SEND);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.2300885" },
                Text = { Text = lang.GetMessage("UI_NEW_ALERT_PLAYER_DESC", this, Suspect.UserIDString), Color = HexToRustFormat(InterfaceAlert.HexLabel), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperCenter }
            }, PARENT_UI_ALERT_SEND);

            CuiHelper.AddUi(Suspect, container);
        }
        #endregion

        #region UI Moder Menu
        
        void UI_MiniPanelModerator(BasePlayer player, ulong SuspectID)
        {
            CuiHelper.DestroyUi(player, PARENT_UI_MODERATOR_MINI_PANEL);
            CuiElementContainer container = new CuiElementContainer();
            var Interface = config.Setting.Interface.ModderatorPanel;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-450 15", OffsetMax = "-220 130" },
                Image = { Color = HexToRustFormat(Interface.HexMain) }
            }, "Overlay", PARENT_UI_MODERATOR_MINI_PANEL);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.7797101", AnchorMax = "1 1" },
                Image = { Color = HexToRustFormat(Interface.HexTitlePanel) }
            }, PARENT_UI_MODERATOR_MINI_PANEL, "TITLE_PANEL");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.1130467", AnchorMax = "1 1" }, 
                Text = { Text = lang.GetMessage("UI_NEW_MINI_PANEL_MODERATOR_TITLE", this, player.UserIDString), Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter, Color = HexToRustFormat(Interface.HexLabel) }
            },  "TITLE_PANEL");

            container.Add(new CuiElement
            {
                Parent = $"TITLE_PANEL",
                Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabel), Sprite = Interface.SpriteTitlePanel },
                        new CuiRectTransformComponent { AnchorMin = "0.005797102 0.07894736", AnchorMax = "0.09855073 0.9210525" }
                    }
            }); 
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.008695543 0.03614452", AnchorMax = $"0.48 0.5" },
                Button = { Command = $"iqreport moderator_stop {SuspectID}", Color = HexToRustFormat(Interface.HexStopButton) },
                Text = { Text = lang.GetMessage("UI_NEW_MINI_PANEL_MODERATOR_STOP", this, player.UserIDString), Align = TextAnchor.MiddleCenter, Color = HexToRustFormat(Interface.HexLabel) }
            }, PARENT_UI_MODERATOR_MINI_PANEL);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.5188398 0.03614452", AnchorMax = $"0.9913077 0.5" },
                Button = { Command = $"iqreport moderator_reason_ban {SuspectID}", Color = HexToRustFormat(Interface.HexBanButton) },
                Text = { Text = lang.GetMessage("UI_NEW_MINI_PANEL_MODERATOR_BAN", this, player.UserIDString), Align = TextAnchor.MiddleCenter, Color = HexToRustFormat(Interface.HexLabel) }
            }, PARENT_UI_MODERATOR_MINI_PANEL);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.01159436 0.5478261", AnchorMax = "0.7072465 0.7333333" },
                Text = { Text = $"Discord : {PlayerSaveCheck[SuspectID].Discord}", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.UpperCenter, Color = HexToRustFormat("#FFFFFFFF") }
            }, PARENT_UI_MODERATOR_MINI_PANEL, UI_MODERATION_CHECK_MENU_DISCORD);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.6782616 0.5478261", AnchorMax = "0.9884076 0.7333333" },
                Text = { Text = $"{PlayerSaveCheck[SuspectID].StatusNetwork}", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.UpperCenter, Color = HexToRustFormat("#FFFFFFFF") }
            }, PARENT_UI_MODERATOR_MINI_PANEL, UI_MODERATION_CHECK_MENU_NETWORK);

            CuiHelper.AddUi(player, container);
        }
        void UI_OpenReasonsBan(BasePlayer player, ulong SuspectID)
        {
            CuiElementContainer container = new CuiElementContainer();
            var Interface = config.Setting.Interface.ModderatorPanel;

            for (int i = 0; i < config.ReasonBan.Count; i++)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0 1", AnchorMax = $"0 1", OffsetMin = $"0 {2 + (i * 30)}", OffsetMax = $"230 {30 + (i * 30)}" },
                    Button = { FadeIn = 0.3f + (i / 10), Command = $"iqreport moderator_ban {SuspectID} {i}", Color = HexToRustFormat(Interface.HexBanButton) },
                    Text = { Text = config.ReasonBan[i].DisplayName, FontSize = 15, Align = TextAnchor.MiddleCenter, Color = HexToRustFormat(Interface.HexLabel) }
                },  PARENT_UI_MODERATOR_MINI_PANEL);
            }

            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region UI Raiting Moderation
        void UI_RaitingSend(BasePlayer player, BasePlayer Moderator)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, UI_MODERATION_RAITING);
            var Interface = config.Setting.Interface.RaitingInterface;

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-450 15", OffsetMax = "-220 100" },
                Image = { Color = HexToRustFormat(Interface.HexMain), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            }, "Overlay", UI_MODERATION_RAITING);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.6", AnchorMax = "0.99 0.99" },
                Image = { Color = HexToRustFormat(Interface.HexTitlePanel), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            }, UI_MODERATION_RAITING,"TITLE_PANEL");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.1536232 0", AnchorMax = "1 1" },
                Text = { Text = lang.GetMessage("UI_NEW_RAITING_PANEL", this, player.UserIDString), Font = "robotocondensed-regular.ttf", Color = HexToRustFormat(Interface.HexLabel), Align = TextAnchor.MiddleCenter }
            }, "TITLE_PANEL");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.01449275 0.07843139", AnchorMax = $"0.1362319 0.901961" },
                Image = { Color = HexToRustFormat(Interface.HexLabel), Sprite = Interface.SpriteTitlePanel}
            },  "TITLE_PANEL");

            for (int i = 1, x = 0; i < 6; i++, x++)
            {
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"{0.02451923 + (x * 0.2)} 0.1933336", AnchorMax = $"{0.1886218 + (x * 0.2)} 0.6200002" },
                    Image = { Color = HexToRustFormat(Interface.HexRaitingButton), Sprite = Interface.SpriteRaiting}
                }, UI_MODERATION_RAITING, $"STAR_{i}");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Close = UI_MODERATION_RAITING, Command = $"iqreport raiting {Moderator.userID} {i}", Color = "0 0 0 0" },
                    Text = { Text = "", Color = "0 0 0 0", FontSize = 30, Align = TextAnchor.MiddleLeft }
                }, $"STAR_{i}");
            }

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #endregion

        #region Hooks
        private void OnServerInitialized()
        {
            ReportInformation = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, PlayerInfo>>("IQReportSystem/Reports");
            ModeratorInformation = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, ModeratorInfo>>("IQReportSystem/Moders");

            foreach (var player in BasePlayer.activePlayerList)
                OnPlayerInit(player);

            permission.RegisterPermission(PermissionModeration, this);
            permission.RegisterPermission(PermissionAdmin, this);
        }

        void OnPlayerInit(BasePlayer player) => Metods_PlayerConnected(player);
        private void Unload()
        {
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQReportSystem/Reports", ReportInformation);
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQReportSystem/Moders", ModeratorInformation);

            foreach (var p in BasePlayer.activePlayerList)
                DestroyAll(p);
        }
        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            Metods_StatusNetwork(player, reason);
            Metods_ModeratorExitCheck(player);
        }

        void DestroyAll(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PARENT_UI);
            CuiHelper.DestroyUi(player, PARENT_UI_REPORT_MENU);
            CuiHelper.DestroyUi(player, PARENT_UI_PLAYER_PANEL);
            CuiHelper.DestroyUi(player, PARENT_UI_PLAYER_REPORT);
            CuiHelper.DestroyUi(player, PARENT_UI_MODER_REPORT);
            CuiHelper.DestroyUi(player, PARENT_UI_ALERT_SEND);
            CuiHelper.DestroyUi(player, PARENT_UI_MODERATOR_MINI_PANEL);
            CuiHelper.DestroyUi(player, UI_MODERATION_CHECK_MENU_DISCORD);
            CuiHelper.DestroyUi(player, UI_MODERATION_CHECK_MENU_NETWORK);
            CuiHelper.DestroyUi(player, UI_MODERATION_RAITING);
        }

        #endregion

        #region Helps

        #region PluginsAPI

        void VKSendMessage(string Message)
        {
            if (!config.Setting.VKMessage) return;
            var VK = config.Setting.VKSettings;
            if (String.IsNullOrEmpty(VK.ChatID) || String.IsNullOrEmpty(VK.Token))
            {
                PrintWarning("Вы не настроили конфигурацию,в пункте с ВК");
                return;
            }
            int RandomID = UnityEngine.Random.Range(0, 9999);
            while (Message.Contains("#"))
                Message = Message.Replace("#", "%23");
            webrequest.EnqueueGet($"https://api.vk.com/method/messages.send?chat_id={VK.ChatID}&random_id={RandomID}&message={Message}&access_token={VK.Token}&v=5.92", (code, response) => { }, this);
        }

        void DiscordSendMessage(string key, ulong userID = 0, params object[] args)
        {
            if (!config.Setting.DiscrodMessage) return;
            if (String.IsNullOrEmpty(config.Setting.WebHook)) return;

            List<Fields> fields = new List<Fields>
                {
                    new Fields("IQReportSystem", key, true),
                };

            FancyMessage newMessage = new FancyMessage(null, false, new FancyMessage.Embeds[1] { new FancyMessage.Embeds(null, 635133, fields, new Authors("IQReportSystem", "https://vk.com/mercurydev", "https://i.imgur.com/ILk3uJc.png", null), new Footer("Author: Mercury[https://vk.com/mercurydev]", "https://i.imgur.com/ILk3uJc.png", null)) });
            Request($"{config.Setting.WebHook}", newMessage.toJSON());
        }

        #region FancyDiscord
        public class FancyMessage
        {
            public string content { get; set; }
            public bool tts { get; set; }
            public Embeds[] embeds { get; set; }

            public class Embeds
            {
                public string title { get; set; }
                public int color { get; set; }
                public List<Fields> fields { get; set; }
                public Footer footer { get; set; }
                public Authors author { get; set; }

                public Embeds(string title, int color, List<Fields> fields, Authors author, Footer footer)
                {
                    this.title = title;
                    this.color = color;
                    this.fields = fields;
                    this.author = author;
                    this.footer = footer;

                }
            }

            public FancyMessage(string content, bool tts, Embeds[] embeds)
            {
                this.content = content;
                this.tts = tts;
                this.embeds = embeds;
            }

            public string toJSON() => JsonConvert.SerializeObject(this);
        }

        public class Footer
        {
            public string text { get; set; }
            public string icon_url { get; set; }
            public string proxy_icon_url { get; set; }
            public Footer(string text, string icon_url, string proxy_icon_url)
            {
                this.text = text;
                this.icon_url = icon_url;
                this.proxy_icon_url = proxy_icon_url;
            }
        }

        public class Authors
        {
            public string name { get; set; }
            public string url { get; set; }
            public string icon_url { get; set; }
            public string proxy_icon_url { get; set; }
            public Authors(string name, string url, string icon_url, string proxy_icon_url)
            {
                this.name = name;
                this.url = url;
                this.icon_url = icon_url;
                this.proxy_icon_url = proxy_icon_url;
            }
        }

        public class Fields
        {
            public string name { get; set; }
            public string value { get; set; }
            public bool inline { get; set; }
            public Fields(string name, string value, bool inline)
            {
                this.name = name;
                this.value = value;
                this.inline = inline;
            }
        }

        private void Request(string url, string payload, Action<int> callback = null)
        {
            Dictionary<string, string> header = new Dictionary<string, string>();
            header.Add("Content-Type", "application/json");
            webrequest.EnqueuePost(url, payload, (code, response) =>
            {
                if (code != 200 && code != 204)
                {
                    if (response != null)
                    {
                        try
                        {
                            JObject json = JObject.Parse(response);
                            if (code == 429)
                            {
                                float seconds = float.Parse(Math.Ceiling((double)(int)json["retry_after"] / 1000).ToString());
                            }
                            else
                            {
                                PrintWarning($" Discord rejected that payload! Responded with \"{json["message"].ToString()}\" Code: {code}");
                            }
                        }
                        catch
                        {
                            PrintWarning($"Failed to get a valid response from discord! Error: \"{response}\" Code: {code}");
                        }
                    }
                    else
                    {
                        PrintWarning($"Discord didn't respond (down?) Code: {code}");
                    }
                }
                try
                {
                    callback?.Invoke(code);
                }
                catch (Exception ex) { }

            }, this, header);
        }
        #endregion

        int API_GET_REPORT_COUNT(ulong UserID)
        {
            var User = ReportInformation[UserID];
            return User.ReportCount;
        }
        int API_GET_CHECK_COUNT(ulong UserID)
        {
            var User = ReportInformation[UserID];
            return User.CheckCount;
        }
        List<string> API_GET_LIST_API(ulong UserID)
        {
            var User = ReportInformation[UserID];
            return User.IP;
        }
        string API_GET_GAME_STATUS(ulong UserID)
        {
            var User = ReportInformation[UserID];
            return User.GameStatus;
        }
        string API_GET_LAST_CHECK_MODERATOR(ulong UserID)
        {
            var User = ReportInformation[UserID];
            return User.LastCheckModerator;
        }
        string API_GET_LAST_REPORT(ulong UserID)
        {
            var User = ReportInformation[UserID];
            return User.LastReport;
        }
        List<string> API_GET_REPORT_HISTORY(ulong UserID)
        {
            var User = ReportInformation[UserID];
            return User.ReportHistory;
        }

        #endregion

        #region MSG
        public void SendChat(BasePlayer player,string Message)
        {
            var Chat = config.Setting.ChatSetting;
            if (IQChat)
                IQChat?.Call("API_ALERT_PLAYER", player, Message, Chat.CustomPrefix, Chat.CustomAvatar);
            else player.SendConsoleCommand("chat.add", 0, Message);
        }

        #endregion

        #region Hex
        private static string HexToRustFormat(string hex)
        {
            Color color;
            ColorUtility.TryParseHtmlString(hex, out color);
            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }
        #endregion

        #region Steam

        string IsSteam(string id)
        {        
            if (MultiFighting != null)
            {
                var player = BasePlayer.Find(id);
                if (player == null)
                {
                    return "ERROR #1";
                }
                var obj = MultiFighting.CallHook("IsSteam", player.Connection);
                if (obj is bool)
                {
                    if ((bool)obj)
                    {
                        return lang.GetMessage("IS_STEAM_STATUS_LICENSE", this, id);
                    }
                    else
                    {
                        return lang.GetMessage("IS_STEAM_STATUS_PIRATE",this,id);
                    }
                }
                else
                {
                    return "ERROR #2";
                }
            }
            else return lang.GetMessage("IS_STEAM_STATUS_LICENSE", this, id);
        }

        #endregion

        #region Format

        static DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        static double CurrentTime() => DateTime.UtcNow.Subtract(epoch).TotalSeconds;

        public static string FormatTime(TimeSpan time)
        {
            string result = string.Empty;
            if (time.Days != 0)
                result += $"{Format(time.Days, "дней", "дня", "день")} ";

            if (time.Hours != 0)
                result += $"{Format(time.Hours, "часов", "часа", "час")} ";

            if (time.Minutes != 0)
                result += $"{Format(time.Minutes, "минут", "минуты", "минута")} ";

            if (time.Seconds != 0)
                result += $"{Format(time.Seconds, "секунд", "секунды", "секунда")} ";

            return result;
        }

        private static string Format(int units, string form1, string form2, string form3)
        {
            var tmp = units % 10;

            if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                return $"{units} {form1}";

            if (tmp >= 2 && tmp <= 4)
                return $"{units} {form2}";

            return $"{units} {form3}";
        }

        #endregion

        #endregion
    }

}



// --- End of file: IQReportSystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/PerformanceMonitor.cs ---
// --- Original Local Path: PerformanceMonitor.cs ---

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;


namespace Oxide.Plugins
{
    [Info("Performance Monitor", "Orange", "1.2.7")]
    [Description("Tool for collecting information about server performance")]
    public class PerformanceMonitor : RustPlugin
    {
        #region Vars

        private const string commandString = "monitor.createreport";
        private const string commandString2 = "monitor.report";
        private PerformanceDump currentReport;

        #endregion

        #region Oxide Hooks

        private void Init()
        {

            cmd.AddConsoleCommand(commandString, this, nameof(cmdCompleteNow));
            cmd.AddConsoleCommand(commandString2, this, nameof(cmdCompleteNow));
        }

        private void OnServerInitialized()
        {
            if (config.checkTime > 0)
            {
                timer.Every(config.checkTime, CreateReport);
            }
        }

        #endregion

        #region Commands

        private void cmdCompleteNow(ConsoleSystem.Arg arg)
        {
            if (arg.IsAdmin == false)
            {
                return;
            }

            CreateReport();
        }

        #endregion

        #region Core

        private void CreateReport()
        {
            ServerMgr.Instance.StartCoroutine(CreateActualReport());
        }

        private IEnumerator CreateActualReport()
        {
            if (currentReport != null)
            {
                yield break;
            }

            currentReport = new PerformanceDump();

            Stopwatch sw = new Stopwatch();
            sw.Start();

            CompletePluginsReport();
            ServerMgr.Instance.StartCoroutine(CompleteEntitiesReport());

            while (!currentReport.entities.completed && config.runEntitiesReport)
            {
                Puts($"Report status: {currentReport.statusBar}% [{currentReport.entitiesChecked}/{currentReport.entitiesTotal}]");
                yield return new WaitForEndOfFrame();
            }

            SaveReport(currentReport);
            currentReport = null;
            sw.Stop();
            Puts($"Performance report was completed in {sw.Elapsed.Seconds + (sw.Elapsed.Milliseconds / 1000.0)} seconds.");
        }

        private void CompletePluginsReport()
        {
            List<string> list = Pool.GetList<string>();

            if (config.runPluginsReport == false)
            {
                return;
            }

            if (config.sortByHookTime)
            {
                foreach (var plugin in plugins.GetAll().OrderByDescending(x => x.TotalHookTime))
                {
                    ProcessPlugins(plugin, list);
                }
            }
            else
            {
#if CARBON
                foreach (var plugin in plugins.GetAll().OrderByDescending(x => x.TotalMemoryUsed))
#else
                foreach (var plugin in plugins.GetAll().OrderByDescending(x => x.TotalHookTime))
#endif
                {
                    ProcessPlugins(plugin, list);
                }
            }
            currentReport.plugins = list.ToArray();
            Pool.FreeList(ref list);
        }

        private void ProcessPlugins(Plugin plugin, List<string> list)
        {

            string name = plugin.Name;
            if (name == Name || plugin.IsCorePlugin || config.excludedPlugins.Contains(name))
            {
                return;
            }
#if CARBON
            string memory = FormatBytes(plugin.TotalMemoryUsed);
            double time = Math.Round(plugin.TotalHookTime.TotalSeconds, 6);
#else
          // string memory = FormatBytes(plugin.);
            double time = Math.Round(plugin.TotalHookTime, 6);
#endif
            VersionNumber version = plugin.Version;

            string info = $"{name} ({version}), Total Hook Time = {time}";

            list.Add(info);
        }

        private IEnumerator CompleteEntitiesReport()
        {
            if (config.runEntitiesReport == false)
            {
                yield break;
            }

            // Swapped to serverEntities.OfType<> Instead of UnityEngine.FindObjectOfType<> due to absolute absurdity of time scale between the two.
            // serverEntities took 0.0151 ms, UnityEngine took 201.12 ms.
            var entities = BaseNetworkable.serverEntities.OfType<BaseEntity>();
            var entitiesByShortname = currentReport.entities.list;

            currentReport.entitiesTotal = entities.Count();

            int count = 0;
            foreach (BaseEntity entity in entities)
            {
                currentReport.entitiesChecked++;
                currentReport.statusBar = Convert.ToInt32(count * 100 / currentReport.entitiesTotal);

                if (entity.IsValid() == false)
                {
                    continue;
                }

                var shortname = entity.ShortPrefabName;
                if (config.excludedEntities.Contains(shortname))
                {
                    continue;
                }

                EntityInfo info;
                if (entitiesByShortname.TryGetValue(shortname, out info) == false)
                {
                    info = new EntityInfo();
                    entitiesByShortname.Add(shortname, info);
                }


                if (entity.OwnerID == 0)
                {
                    info.countUnowned++;
                    currentReport.entities.countUnowned++;
                }
                else
                {
                    info.countOwned++;
                    currentReport.entities.countOwned++;
                }

                info.countGlobal++;
                currentReport.entities.countGlobal++;
            }

            currentReport.entities.list = currentReport.entities.list.OrderByDescending(x => x.Value.countGlobal).ToDictionary(x => x.Key, y => y.Value);

            currentReport.entities.completed = true;
        }

        #endregion

        #region Utils

        private void SaveReport(PerformanceDump dump)
        {
            string name1;
            if (config.EuropeanTimeSave) name1 = DateTime.Now.ToString("dd/MM/yyyy").Replace("/", "-");
            else name1 = DateTime.Now.ToString("MM/dd/yyyy").Replace("/", "-");
            string name2 = DateTime.Now.ToString(Time()).Replace(':', '-');
            string filename = $"PerformanceMonitor/Reports/{name1}/{name2}";
            Interface.Oxide.DataFileSystem.WriteObject(filename, dump);
        }

        private string Time()
