           },

            {"coffeecan.helmet", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/4/44/Coffee_Can_Helmet_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061305" },
            }
            },
            {"bone.armor.suit", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/1/14/Bone_Armor_icon.png/revision/latest/scale-to-width-down/100?cb=20160901064349" },
            }
            },
            {"attire.hide.vest", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/c/c0/Hide_Vest_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061337" },
            }
            },
            {"attire.hide.skirt", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/9/91/Hide_Skirt_icon.png/revision/latest/scale-to-width-down/100?cb=20160513065030" },
            }
            },
            {"attire.hide.poncho", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/7/7f/Hide_Poncho_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061141" },
            }
            },
            {"attire.hide.pants", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/e/e4/Hide_Pants_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061352" },
            }
            },
            {"attire.hide.helterneck", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/2/25/Hide_Halterneck_icon.png/revision/latest/scale-to-width-down/100?cb=20160513065021" },
            }
            },
            {"attire.hide.boots", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/5/57/Hide_Boots_icon.png/revision/latest/scale-to-width-down/100?cb=20151106060954" },
            }
            },
            {"deer.skull.mask", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/2/22/Deer_Skull_icon.png/revision/latest/scale-to-width-down/100?cb=20150405141500" },
            }
            },
            }
            },
            {Category.Weapons, new Dictionary<string, Dictionary<ulong, string>>
            {
            {"pistol.revolver", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/5/58/Revolver_icon.png/revision/latest/scale-to-width-down/100?cb=20160226092929" },
                {10114, "http://vignette1.wikia.nocookie.net/play-rust/images/5/51/Outback_revolver_icon.png/revision/latest/scale-to-width-down/100?cb=20160226092935"},
            }
            },
            {"pistol.semiauto", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/6/6b/Semi-Automatic_Pistol_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200319" },
                {10087, "http://vignette2.wikia.nocookie.net/play-rust/images/7/7c/Contamination_Pistol_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200655"},
                {10108, "http://vignette3.wikia.nocookie.net/play-rust/images/c/c3/Halloween_Bat_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201053" },
                {10081, "http://vignette1.wikia.nocookie.net/play-rust/images/7/70/Reaper_Note_Pistol_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200711"},
                {10073, "http://vignette2.wikia.nocookie.net/play-rust/images/5/53/Red_Shine_Pistol_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200630" },
            }
            },
            {"rifle.ak", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/d/d1/Assault_Rifle_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200609" },
                {10135, "http://vignette2.wikia.nocookie.net/play-rust/images/9/9e/Digital_Camo_AK47_icon.png/revision/latest/scale-to-width-down/100?cb=20160211225138"},
                {10137, "http://vignette4.wikia.nocookie.net/play-rust/images/9/9f/Military_Camo_AK47_icon.png/revision/latest/scale-to-width-down/100?cb=20160211225144" },
                {10138, "http://vignette1.wikia.nocookie.net/play-rust/images/a/a1/Tempered_AK47_icon.png/revision/latest/scale-to-width-down/100?cb=20160211204335"},
            }
            },
            {"rifle.bolt", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/5/55/Bolt_Action_Rifle_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200415" },
                {10117, "http://vignette2.wikia.nocookie.net/play-rust/images/2/22/Dreamcatcher_icon.png/revision/latest/scale-to-width-down/100?cb=20160214234844"},
                {10115, "http://vignette1.wikia.nocookie.net/play-rust/images/9/9e/Ghost_Bolt_Rifle_icon.png/revision/latest/scale-to-width-down/100?cb=20160214234902" },
                {10116, "http://vignette1.wikia.nocookie.net/play-rust/images/c/cf/Tundra_Bolt_Rifle_icon.png/revision/latest/scale-to-width-down/100?cb=20160214234858"},
            }
            },
            {"shotgun.pump", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/6/60/Pump_Shotgun_icon.png/revision/latest/scale-to-width-down/100?cb=20160310205718" },
                {10074, "http://vignette4.wikia.nocookie.net/play-rust/images/9/94/Chieftain_Pump_Shotgun_icon.png/revision/latest/scale-to-width-down/100?cb=20151106062100"},
                {10140, "http://vignette4.wikia.nocookie.net/play-rust/images/4/42/The_Swampmaster_icon.png/revision/latest/scale-to-width-down/100?cb=20160310205830" },
            }
            },
            {"shotgun.waterpipe", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/1/1b/Waterpipe_Shotgun_icon.png/revision/latest/scale-to-width-down/100?cb=20160310205730" },
                {10143, "http://vignette3.wikia.nocookie.net/play-rust/images/4/4a/The_Peace_Pipe_icon.png/revision/latest/scale-to-width-down/100?cb=20160310205804"},
            }
            },
            {"rifle.lr300", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/d/d9/LR-300_Assault_Rifle_icon.png/revision/latest/scale-to-width-down/100?cb=20160825132402"},
            }
            },
            {"crossbow", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/2/23/Crossbow_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061004" },
            }
            },
            {"smg.thompson", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/4/4e/Thompson_icon.png/revision/latest/scale-to-width-down/100?cb=20160226092921" },
                {10120, "http://vignette3.wikia.nocookie.net/play-rust/images/8/84/Santa%27s_Little_Helper_icon.png/revision/latest/scale-to-width-down/100?cb=20160225141743"},
            }
            },
            {"weapon.mod.small.scope", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/9/9c/4x_Zoom_Scope_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201610" },
            }
            },
            {"weapon.mod.silencer", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/9/9f/Silencer_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200615" },
            }
            },
            {"weapon.mod.muzzlebrake", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/3/38/Muzzle_Brake_icon.png/revision/latest/scale-to-width-down/100?cb=20160601121719" },
            }
            },
            {"weapon.mod.muzzleboost", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/7/7d/Muzzle_Boost_icon.png/revision/latest/scale-to-width-down/100?cb=20160601121705" },
            }
            },
            {"weapon.mod.lasersight", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/8/8e/Weapon_Lasersight_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201545" },
            }
            },
            {"weapon.mod.holosight", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/4/45/Holosight_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200620" },
            }
            },
            {"weapon.mod.flashlight", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/0/0d/Weapon_Flashlight_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201539" },
            }
            },
            {"spear.wooden", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/f/f2/Wooden_Spear_icon.png/revision/latest/scale-to-width-down/100?cb=20151106060930" },
            }
            },
            {"spear.stone", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/0/0a/Stone_Spear_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061726" },
            }
            },
            {"smg.2", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/9/95/Custom_SMG_icon.png/revision/latest/scale-to-width-down/100?cb=20151108000740" },
            }
            },
            {"shotgun.double", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/3/3f/Double_Barrel_Shotgun_icon.png/revision/latest/scale-to-width-down/100?cb=20160816061211" },
            }
            },
            {"salvaged.sword", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/7/77/Salvaged_Sword_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061458" },
            }
            },
            {"salvaged.cleaver", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/7/7e/Salvaged_Cleaver_icon.png/revision/latest/scale-to-width-down/100?cb=20151106054417" },
            }
            },
            {"rocket.launcher", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/0/06/Rocket_Launcher_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061852" },
            }
            },
            {"rifle.semiauto", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/8/8d/Semi-Automatic_Rifle_icon.png/revision/latest/scale-to-width-down/100?cb=20160128160721" },
            }
            },
            {"pistol.eoka", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/b/b5/Eoka_Pistol_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061104" },
            }
            },
            {"machete", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/3/34/Machete_icon.png/revision/latest/scale-to-width-down/100?cb=20151106060741" },
            }
            },
            {"mace", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/4/4d/Mace_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061207" },
            }
            },
            {"longsword", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/3/34/Longsword_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061240" },
            }
            },
            {"lmg.m249", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/c/c6/M249_icon.png/revision/latest/scale-to-width-down/100?cb=20151112221315" },
            }
            },
            {"knife.bone", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/c/c7/Bone_Knife_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061357" },
            }
            },
            {"flamethrower", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/5/55/Flame_Thrower_icon.png/revision/latest/scale-to-width-down/100?cb=20160415084104" },
            }
            },
            {"bow.hunting", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/2/25/Hunting_Bow_icon.png/revision/latest/scale-to-width-down/100?cb=20151106060745" },
            }
            },
            {"bone.club", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/1/19/Bone_Club_icon.png/revision/latest/scale-to-width-down/100?cb=20151106060940" },
            }
            },
            {"grenade.f1", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/5/52/F1_Grenade_icon.png/revision/latest/scale-to-width-down/100?cb=20151106054509" },
            }
            },
            {"grenade.beancan", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/b/be/Beancan_Grenade_icon.png/revision/latest/scale-to-width-down/50?cb=20151106060959" },
            }
            },
            }
            },


            {Category.Ammunition, new Dictionary<string, Dictionary<ulong, string>>
            {
            {"ammo.handmade.shell", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/0/0d/Handmade_Shell_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061522" },
            }
            },
            {"ammo.pistol", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/9/9b/Pistol_Bullet_icon.png/revision/latest/scale-to-width-down/43?cb=20151106061928" },
            }
            },
             {"ammo.pistol.fire", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/3/31/Incendiary_Pistol_Bullet_icon.png/revision/latest/scale-to-width-down/100?cb=20151106054326" },
            }
            },
            {"ammo.pistol.hv", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/e/e5/HV_Pistol_Ammo_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061857" },
            }
            },
            {"ammo.rifle", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/4/49/5.56_Rifle_Ammo_icon.png/revision/latest/scale-to-width-down/100?cb=20150405103333" },
            }
            },
            {"ammo.rifle.explosive", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/3/31/Explosive_5.56_Rifle_Ammo_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061449" },
            }
            },
            {"ammo.rifle.hv", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/d/df/HV_5.56_Rifle_Ammo_icon.png/revision/latest/scale-to-width-down/100?cb=20150612151932" },
            }
            },
            {"ammo.rifle.incendiary", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/e/e1/Incendiary_5.56_Rifle_Ammo_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200254" },
            }
            },
            {"ammo.rocket.basic", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/9/95/Rocket_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061039" },
            }
            },
            {"ammo.rocket.fire", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/f/f9/Incendiary_Rocket_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061939" },
            }
            },
            {"ammo.rocket.hv", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/f/f4/High_Velocity_Rocket_icon.png/revision/latest/scale-to-width-down/100?cb=20151106054436" },
            }
            },
            {"ammo.rocket.smoke", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/8/80/Smoke_Rocket_icon.png/revision/latest/scale-to-width-down/100?cb=20150531134255" },
            }
            },
            {"ammo.shotgun", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/2/2f/12_Gauge_Buckshot_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061114" },
            }
            },
            {"ammo.shotgun.slug", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/1/1a/12_Gauge_Slug_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061838" },
            }
            },
            {"arrow.hv", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/e/e5/High_Velocity_Arrow_icon.png/revision/latest/scale-to-width-down/100?cb=20151106054350" },
            }
            },
            {"arrow.wooden", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/3/3d/Wooden_Arrow_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061615" },
            }
            },
            }
            },

            {Category.Medical, new Dictionary<string, Dictionary<ulong, string>>
            {
            {"bandage", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/f/f8/Bandage_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061541" },
            }
            },
            {"syringe.medical", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/9/99/Medical_Syringe_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061059" },
            }
            },
            { "largemedkit", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/9/99/Large_Medkit_icon.png/revision/latest/scale-to-width-down/100?cb=20151106054425" },
            }
            },
            { "antiradpills", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/0/0e/Anti-Radiation_Pills_icon.png/revision/latest/scale-to-width-down/100?cb=20151106060926" },
            }
            },
            }
            },


            {Category.Building, new Dictionary<string, Dictionary<ulong, string>>
            {
            {"bed", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/f/fe/Bed_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061212" },
            }
            },
            {"box.wooden", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/f/ff/Wood_Storage_Box_icon.png/revision/latest/scale-to-width-down/100?cb=20151106054500" },
            }
            },
            {"box.wooden.large", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/b/b2/Large_Wood_Box_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200336" },
            }
            },
            {"ceilinglight", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/4/43/Ceiling_Light_icon.png/revision/latest/scale-to-width-down/100?cb=20160331070008" },
            }
            },
            {"door.double.hinged.metal", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/1/14/Sheet_Metal_Double_Door_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201657" },
            }
            },
            {"door.double.hinged.toptier", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/c/c1/Armored_Double_Door_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201616" },
            }
            },
            {"door.double.hinged.wood", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/4/41/Wood_Double_Door_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201605" },
            }
            },
            {"door.hinged.metal", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/8/83/Sheet_Metal_Door_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201232" },
            }
            },
            {"door.hinged.toptier", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/b/bc/Armored_Door_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201148" },
            }
            },
            {"door.hinged.wood", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/7/7e/Wooden_Door_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201125" },
            }
            },
            {"floor.grill", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/4/48/Floor_Grill_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201701" },
            }
            },
            {"floor.ladder.hatch", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/7/7c/Ladder_Hatch_icon.png/revision/latest/scale-to-width-down/100?cb=20160203005615" },
            }
            },
            {"gates.external.high.stone", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/8/85/High_External_Stone_Gate_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201341" },
            }
            },
            {"gates.external.high.wood", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/5/53/High_External_Wooden_Gate_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200625" },
            }
            },
            {"shelves", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/a/a5/Salvaged_Shelves_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201358" },
            }
            },
            {"shutter.metal.embrasure.a", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/8/88/Metal_Vertical_embrasure_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201307" },
            }
            },
            {"shutter.metal.embrasure.b", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/5/5d/Metal_horizontal_embrasure_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201154" },
            }
            },
            {"shutter.wood.a", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/2/2b/Wood_Shutters_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201159" },
            }
            },
            {"sign.hanging", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/d/df/Two_Sided_Hanging_Sign_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200913" },
            }
            },
            {"sign.hanging.banner.large", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/2/29/Large_Banner_Hanging_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200937" },
            }
            },
            {"sign.hanging.ornate", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/4/4f/Two_Sided_Ornate_Hanging_Sign_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200909" },
            }
            },
            {"sign.pictureframe.landscape", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/8/87/Landscape_Picture_Frame_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200943" },
            }
            },
            {"sign.pictureframe.portrait", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/5/50/Portrait_Picture_Frame_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200949" },
            }
            },
            {"sign.pictureframe.tall", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/6/65/Tall_Picture_Frame_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201003" },
            }
            },
            {"sign.pictureframe.xl", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/b/bf/XL_Picture_Frame_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200847" },
            }
            },
            {"sign.pictureframe.xxl", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/9/95/XXL_Picture_Frame_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200933" },
            }
            },
            {"sign.pole.banner.large", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/1/16/Large_Banner_on_pole_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200958" },
            }
            },
            {"sign.post.double", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/5/5e/Double_Sign_Post_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200918" },
            }
            },
            {"sign.post.single", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/1/11/Single_Sign_Post_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200928" },
            }
            },
            {"sign.post.town", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/6/62/One_Sided_Town_Sign_Post_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200953" },
            }
            },
            {"sign.post.town.roof", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/f/fa/Two_Sided_Town_Sign_Post_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200904" },
            }
            },
            {"sign.wooden.huge", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/6/6e/Huge_Wooden_Sign_icon.png/revision/latest/scale-to-width-down/100?cb=20151106054354" },
            }
            },
            {"sign.wooden.large", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/b/bc/Large_Wooden_Sign_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061909" },
            }
            },
            {"sign.wooden.medium", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/c/c3/Wooden_Sign_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061634" },
            }
            },
            {"sign.wooden.small", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/7/70/Small_Wooden_Sign_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061315" },
            }
            },
            {"jackolantern.angry", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/9/96/Jack_O_Lantern_Angry_icon.png/revision/latest/scale-to-width-down/100?cb=20151106062158" },
            }
            },
            {"jackolantern.happy", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/9/92/Jack_O_Lantern_Happy_icon.png/revision/latest/scale-to-width-down/100?cb=20151106062154" },
            }
            },
            {"ladder.wooden.wall", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/c/c8/Wooden_Ladder_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200358" },
            }
            },
            {"lantern", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/4/46/Lantern_icon.png/revision/latest/scale-to-width-down/100?cb=20151106060856" },
            }
            },
            {"lock.code", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/0/0c/Code_Lock_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061407" },
            }
            },
            {"mining.quarry", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/b/b8/Mining_Quarry_icon.png/revision/latest/scale-to-width-down/100?cb=20151106054421" },
            }
            },
            {"wall.external.high", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/9/96/High_External_Wooden_Wall_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061300" },
            }
            },
            {"wall.external.high.stone", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/b/b6/High_External_Stone_Wall_icon.png/revision/latest/scale-to-width-down/100?cb=20151106060841" },
            }
            },
            {"wall.frame.cell", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/f/f6/Prison_Cell_Wall_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201626" },
            }
            },
            {"wall.frame.cell.gate", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/3/30/Prison_Cell_Gate_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201621" },
            }
            },
            {"wall.frame.fence", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/2/2a/Chainlink_Fence_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201645" },
            }
            },
            {"wall.frame.fence.gate", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/7/7a/Chainlink_Fence_Gate_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201556" },
            }
            },
            {"wall.frame.shopfront", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/c/c1/Shop_Front_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201551" },
            }
            },
            {"wall.window.bars.metal", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/f/fe/Metal_Window_Bars_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201255" },
            }
            },
            {"wall.window.bars.toptier", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/e/eb/Reinforced_Window_Bars_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201133" },
            }
            },
            {"wall.window.bars.wood", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/2/27/Wooden_Window_Bars_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201138" },
            }
            },
            {"lock.key", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/9/9e/Lock_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061620" },
            }
            },
            { "barricade.concrete", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/b/b3/Concrete_Barricade_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061124" },
            }
            },
            {"barricade.metal", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/b/bb/Metal_Barricade_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061108" },
            }
            },
            { "barricade.sandbags", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/a/a7/Sandbag_Barricade_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061417" },
            }
            },
            { "barricade.wood", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/e/e5/Wooden_Barricade_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061024" },
            }
            },
            { "barricade.woodwire", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/7/7b/Barbed_Wooden_Barricade_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061508" },
            }
            },
            { "barricade.stone", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/c/cc/Stone_Barricade_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061226" },
            }
            },
            }
            },

            {Category.Resources, new Dictionary<string, Dictionary<ulong, string>>
            {
            {"charcoal", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/a/ad/Charcoal_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061556" },
            }
            },
            {"cloth", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/f/f7/Cloth_icon.png/revision/latest/scale-to-width-down/100?cb=20151106071629" },
            }
            },
            {"crude.oil", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/3/3c/Crude_Oil_icon.png/revision/latest/scale-to-width-down/100?cb=20151106054451" },
            }
            },
            {"fat.animal", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/d/d5/Animal_Fat_icon.png/revision/latest/scale-to-width-down/100?cb=20151106060911" },
            }
            },
            {"hq.metal.ore", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/8/80/High_Quality_Metal_Ore_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061625" },
            }
            },
            {"lowgradefuel", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/2/26/Low_Grade_Fuel_icon.png/revision/latest/scale-to-width-down/100?cb=20151110002210" },
            }
            },
            {"metal.fragments", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/7/74/Metal_Fragments_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061759" },
            }
            },
            {"metal.ore", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/0/0a/Metal_Ore_icon.png/revision/latest/scale-to-width-down/100?cb=20151106060814" },
            }
            },
            {"leather", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/9/9a/Leather_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061923" },
            }
            },
            {"metal.refined", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/a/a1/High_Quality_Metal_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061156" },
            }
            },
            {"wood", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/f/f2/Wood_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061551" },
            }
            },
            {"seed.corn", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/2/29/Corn_Seed_icon.png/revision/latest/scale-to-width-down/100?cb=20151106054446" },
            }
            },
            {"seed.hemp", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/1/1c/Hemp_Seed_icon.png/revision/latest/scale-to-width-down/100?cb=20160708084856" },
            }
            },
            {"seed.pumpkin", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/6/66/Pumpkin_Seed_icon.png/revision/latest/scale-to-width-down/100?cb=20151106054519" },
            }
            },
            {"stones", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/8/85/Stones_icon.png/revision/latest/scale-to-width-down/100?cb=20150405123145" },
            }
            },
            {"sulfur", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/3/32/Sulfur_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061605" },
            }
            },
            {"sulfur.ore", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/2/22/Sulfur_Ore_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061904" },
            }
            },
            {"gunpowder", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/1/17/Gun_Powder_icon.png/revision/latest/scale-to-width-down/100?cb=20151106060731" },
            }
            },
            {"researchpaper", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/a/ac/Research_Paper_icon.png/revision/latest/scale-to-width-down/100?cb=20160819103106" },
            }
            },
            {"explosives", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/4/47/Explosives_icon.png/revision/latest/scale-to-width-down/100?cb=20151106054330" },
            }
            },
            }
            },





            {Category.Tools, new Dictionary<string, Dictionary<ulong, string>>
            {
            {"botabag", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/f/f5/Bota_Bag_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061015" },
            }
            },
            {"box.repair.bench", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/3/3b/Repair_Bench_icon.png/revision/latest/scale-to-width-down/100?cb=20151119214020" },
            }
            },
            {"bucket.water", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/b/bc/Water_Bucket_icon.png/revision/latest/scale-to-width-down/100?cb=20160413085322" },
            }
            },
            {"explosive.satchel", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/0/0b/Satchel_Charge_icon.png/revision/latest/scale-to-width-down/100?cb=20160813023035" },
            }
            },
            {"explosive.timed", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/6/6c/Timed_Explosive_Charge_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061610" },
            }
            },
            {"flare", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/5/57/Flare_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061129" },
            }
            },
            {"fun.guitar", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/b/bb/Acoustic_Guitar_icon.png/revision/latest/scale-to-width-down/100?cb=20151106060809" },
            }
            },
            {"furnace", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/e/e3/Furnace_icon.png/revision/latest/scale-to-width-down/100?cb=20151106054341" },
            }
            },
            {"furnace.large", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/e/ee/Large_Furnace_icon.png/revision/latest/scale-to-width-down/100?cb=20151106054456" },
            }
            },
            {"hatchet", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/0/06/Hatchet_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061743" },
            }
            },
            {"icepick.salvaged", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/e/e1/Salvaged_Icepick_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061453" },
            }
            },
            {"axe.salvaged", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/c/c9/Salvaged_Axe_icon.png/revision/latest/scale-to-width-down/100?cb=20151106060750" },
            }
            },
            {"pickaxe", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/8/86/Pick_Axe_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061323" },
            }
            },
            {"research.table", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/2/21/Research_Table_icon.png/revision/latest/scale-to-width-down/100?cb=20160129014240" },
            }
            },
            {"small.oil.refinery", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/a/ac/Small_Oil_Refinery_icon.png/revision/latest/scale-to-width-down/100?cb=20151119214041" },
            }
            },
            {"stone.pickaxe", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/7/77/Stone_Pick_Axe_icon.png/revision/latest/scale-to-width-down/100?cb=20150405134645" },
            }
            },
            {"stonehatchet", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/9/9b/Stone_Hatchet_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061843" },
            }
            },
            {"supply.signal", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/2/24/Supply_Signal_icon.png/revision/latest/scale-to-width-down/100?cb=20151106071621" },
            }
            },
            {"surveycharge", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/9/9a/Survey_Charge_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061517" },
            }
            },
            {"target.reactive", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/6/60/Reactive_Target_icon.png/revision/latest/scale-to-width-down/100?cb=20160331070018" },
            }
            },
            {"tool.camera", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/0/0e/Camera_icon.png/revision/latest/scale-to-width-down/100?cb=20151106060755" },
            }
            },
            {"water.barrel", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/e/e2/Water_Barrel_icon.png/revision/latest/scale-to-width-down/100?cb=20160504013134" },
            }
            },
            {"water.catcher.large", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/3/35/Large_Water_Catcher_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061049" },
            }
            },
            {"water.catcher.small", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/0/04/Small_Water_Catcher_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061919" },
            }
            },
            {"water.purifier", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/6/6e/Water_Purifier_icon.png/revision/latest/scale-to-width-down/100?cb=20160512082941" },
            }
            },
            {"torch", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/4/48/Torch_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061512" },
            }
            },
            {"stash.small", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/5/53/Small_Stash_icon.png/revision/latest/scale-to-width-down/100?cb=20151106062004" },
            }
            },
            {"sleepingbag", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/b/be/Sleeping_Bag_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200428" },
            }
            },
            {"hammer.salvaged", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/f/f8/Salvaged_Hammer_icon.png/revision/latest/scale-to-width-down/100?cb=20151106060804" },
            }
            },
            {"hammer", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/5/57/Hammer_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061319" },
            }
            },
            {"blueprintbase", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/8/83/Blueprint_icon.png/revision/latest/scale-to-width-down/100?cb=20160819063752" },
            }
            },
            {"fishtrap.small", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/9/9d/Survival_Fish_Trap_icon.png/revision/latest/scale-to-width-down/100?cb=20160506135224" },
            }
            },
            {"building.planner", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/b/ba/Building_Plan_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061847" },
            }
            },
            }
            },

            {Category.Other, new Dictionary<string, Dictionary<ulong, string>>
            {
            { "cctv.camera", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/2/24/CCTV_Camera_icon.png/revision/latest/scale-to-width-down/100?cb=20151106062215" },
            }
            },
            {"pookie.bear", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/6/61/Pookie_Bear_icon.png/revision/latest/scale-to-width-down/100?cb=20151217230015" },
            }
            },
            {"targeting.computer", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/0/07/Targeting_Computer_icon.png/revision/latest/scale-to-width-down/100?cb=20151106062210" },
            }
            },
            {"trap.bear", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/b/b0/Snap_Trap_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061711" },
            }
            },
            {"trap.landmine", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/8/83/Land_Mine_icon.png/revision/latest/scale-to-width-down/100?cb=20160211200450" },
            }
            },
            {"autoturret", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/f/f9/Auto_Turret_icon.png/revision/latest/scale-to-width-down/100?cb=20151106062203" },
            }
            },
            {"spikes.floor", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/f/f7/Wooden_Floor_Spikes_icon.png/revision/latest/scale-to-width-down/100?cb=20150517235346" },
            }
            },
            {"note", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/d/d5/Note_icon.png/revision/latest/scale-to-width-down/100?cb=20151106060819" },
            }
            },
            {"paper", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/9/96/Paper_icon.png/revision/latest/scale-to-width-down/100?cb=20151106054403" },
            }
            },
            {"map", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/c/c8/Paper_Map_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061639" },
            }
            },
            {"campfire", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/3/35/Camp_Fire_icon.png/revision/latest/scale-to-width-down/100?cb=20151106060846" },
            }
            },
            }
            },

            {Category.Food, new Dictionary<string, Dictionary<ulong, string>>
            {
            { "wolfmeat.cooked", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/1/16/Cooked_Wolf_Meat_icon.png/revision/latest/scale-to-width-down/100?cb=20160131235320" },
            }
            },
            {"waterjug", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/f/f2/Water_Jug_icon.png/revision/latest/scale-to-width-down/100?cb=20160422072821" },
            }
            },
            {"water.salt", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/c/ce/Salt_Water_icon.png/revision/latest/scale-to-width-down/100?cb=20160708084848" },
            }
            },
            {"water", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/7/7f/Water_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061403" },
            }
            },
            {"smallwaterbottle", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/f/fc/Small_Water_Bottle_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061933" },
            }
            },
            {"pumpkin", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/4/4c/Pumpkin_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061814" },
            }
            },
            {"mushroom", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/a/a8/Mushroom_icon.png/revision/latest/scale-to-width-down/100?cb=20151106060836" },
            }
            },
            {"meat.pork.cooked", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/d/dc/Cooked_Pork_icon.png/revision/latest/scale-to-width-down/100?cb=20160211201237" },
            }
            },
            {"humanmeat.cooked", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/d/d2/Cooked_Human_Meat_icon.png/revision/latest/scale-to-width-down/100?cb=20150405113229" },
            }
            },
            {"granolabar", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/6/6c/Granola_Bar_icon.png/revision/latest/scale-to-width-down/100?cb=20151106060916" },
            }
            },
            {"fish.cooked", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/8/8b/Cooked_Fish_icon.png/revision/latest/scale-to-width-down/100?cb=20160506135233" },
            }
            },
            {"chocholate", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/4/45/Chocolate_Bar_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061914" },
            }
            },
            {"chicken.cooked", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/6/6f/Cooked_Chicken_icon.png/revision/latest/scale-to-width-down/100?cb=20151108000759" },
            }
            },
            {"candycane", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/2/2c/Candy_Cane_icon.png/revision/latest/scale-to-width-down/100?cb=20151217224745" },
            }
            },
            {"can.tuna", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/2/2d/Can_of_Tuna_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061943" },
            }
            },
            {"can.beans", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/e/e5/Can_of_Beans_icon.png/revision/latest/scale-to-width-down/100?cb=20151106060935" },
            }
            },
            {"blueberries", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/f/f8/Blueberries_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061231" },
            }
            },
            {"black.raspberries", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/6/6f/Black_Raspberries_icon.png/revision/latest/scale-to-width-down/100?cb=20151119214047" },
            }
            },
            {"bearmeat.cooked", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/1/17/Bear_Meat_Cooked_icon.png/revision/latest/scale-to-width-down/100?cb=20160109015147" },
            }
            },
            {"apple", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/d/dc/Apple_icon.png/revision/latest/scale-to-width-down/100?cb=20151106061034" },
            }
            },
            }
            }
        };

        private Dictionary<string, string> defaultBackgrounds = new Dictionary<string, string>
        {
            { "NEVERDELETE", "http://www.intrawallpaper.com/static/images/r4RtXBr.png" },
            { "default2", "http://www.intrawallpaper.com/static/images/background-wallpapers-32_NLplhCS.jpg" },
            { "default3", "http://www.intrawallpaper.com/static/images/Light-Wood-Background-Wallpaper_JHG6qot.jpg" },
            { "default4", "http://www.intrawallpaper.com/static/images/White-Background-BD1.png" },
            { "default5", "http://www.intrawallpaper.com/static/images/Red_Background_05.jpg" },
            { "default6", "http://www.intrawallpaper.com/static/images/White-Background-BD1.png" },
            { "default7", "http://www.intrawallpaper.com/static/images/abstract-hd-wallpapers-1080p_gDn0G81.jpg" },
            { "default8", "http://www.intrawallpaper.com/static/images/Background-HD-High-Quality-C23.jpg" },
            { "default10", "http://www.intrawallpaper.com/static/images/wood_background_hd_picture_3_169844.jpg" },
            { "default11", "http://www.intrawallpaper.com/static/images/518079-background-hd.jpg" },
            { "default12", "http://www.intrawallpaper.com/static/images/special_flashy_stars_background_03_hd_pictures_170805.jpg" },
            { "default13", "http://www.intrawallpaper.com/static/images/maxresdefault_jKFJl8g.jpg" },
            { "default14", "http://www.intrawallpaper.com/static/images/maxresdefault15.jpg" },
        };



        void SaveData()
        {
            MData.WriteObject(mData);
            //IMGData.WriteObject(imgData);
        }

        void LoadData()
        {
            try
            {
                mData = MData.ReadObject<MarketData>();
            }
            catch
            {
                Puts("Couldn't load the Absolut Market Data, creating a new datafile");
                mData = new MarketData();
            }
            try
            {
                imgData = IMGData.ReadObject<AMImages>();
            }
            catch
            {
                Puts("Couldn't load the Absolut Market Image File, creating a new datafile");
                imgData = new AMImages();
            }
            if (!imgData.SavedBackgrounds.ContainsKey("NEVERDELETE"))
                GetBackgrounds(); 
        //try
        //{
        //    bkData = BKData.ReadObject<Backgrounds>();
        //}
        //catch
        //{
        //    Puts("Couldn't Find Pending Background File , creating a new File");
        //    bkData = new Backgrounds();
        //    bkData.PendingBackgrounds = defaultBackgrounds;
        //    BKData.WriteObject(bkData);
        //}
    }

        #endregion

        #region Config        
        private ConfigData configData;
        class ConfigData
        { 
            public string MarketMenuKeyBinding { get; set; }
            public bool UseUniqueNames { get; set; }
            public bool ServerRewards { get; set; }
            public int InfoInterval { get; set; }

        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                MarketMenuKeyBinding = "b",
                UseUniqueNames = false,
                InfoInterval = 15,
                ServerRewards = false,
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

        #region Messages
        Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            {"title", "Absolut Market: " },
            {"AMInfo", "This server is running Absolut Market. Press '{0}' to access the Market Menu and to set a Trade Box. Happy Trading!"},
            {"NoTradeBox", "Error finding target Trade Box!" },
            {"TradeBoxDestroyed", "Your Trade Box has been destroyed!" },
            {"TradeBoxEmpty", "Your Trade Box is empty... place items in it to sell them" },
            {"TradeBoxEmptyNoSR", "Your Trade Box is empty and you have 0 Server Rewards Points...Load Items or Get Points to continue" },
            {"TradeBoxFull", "Your Trade Box is full! Clear room first." },
            {"TradeBoxCreation", "Make this your Trade Box?" },
            {"TradeBoxCanceled", "You have " },
            {"Yes", "Yes?" },
            {"No", "No?" },
            {"SetName", "Please Provide a Name for this Item: {0}</color>" },
            {"SetpriceItemshortname", "Please Select an Item you want in return for {0}</color>"  },
            {"SetPriceAmount", "Please type the amount of {0} required to buy the {1}</color>" },
            {"ItemDetails", "You are listing: {0}: {1}\n          For {2} {3}" },
            {"ItemName", "" },
            {"SelectItemToSell", "Please select an Item from your Trade Box to sell...</color>" },
            {"ListItem", "List Item?" },
            {"CancelListing", "Cancel Listing?" },
            {"ItemListingCanceled", "You have successfully canceled item listing!" },
            {"NewItemListed", "You have successfully listed {0}!" },
            {"NewMoneyListed", "You have successfully listed {1} {0}" },
            {"ItemNotInBox", "It appears the item you are trying to list is no longer in the Trade Box. Listing Canceled..." },
            {"NotEnoughPurchaseItem", "You do not have enough {0}. You need {1}!" },
            {"TradeBoxMode", "You are now in Trade Box Selection Mode. Place a large or small wooden box at anytime to make it your Trade Box. Type quit at anytime to leave this mode." },
            {"ExitedBoxMode", "You have successfully exited Trade Box Selection Mode." },
            {"TradeBoxAssignment", "Set\nTrade Box" },
            {"ItemBeingSold","For Sale" },
            {"Purchasecost", "Cost" },
            {"NewItemInfo", "Listing Item Details" },
            {"removelisting", "Remove?" },
            {"YourTradeBoxFullBuying","Your Trade Box is Full!"},
            {"SellerTradeBoxFullBuying", "Seller's Trade Box is Full!" },
            {"YourNoTradeBoxBuying","You do not have a Trade Box!" },
            {"SellerNoTradeBoxBuying","Seller does not have a Trade Box!" },
            {"NewPurchase", "You have successfully purchased {1} {0}" },
            {"NewSale", "You have successfully sold {1} {0}" },
            {"Next", "Next" },
            {"Back", "Back" },
            {"First", "First" },
            {"Last", "Last" },
            {"Close", "Close"},
            {"Quit", "Quit"},
            {"PurchaseConfirmation", "Would you like to purchase:\n{0}?" },
            {"ItemCondition", "Item Condition: {0}%" },
            {"ConditionWarning", "Some items do not have a condition and will reflect as 0" },
            {"ItemAlreadyListed", "This item already appears to be listed!" },
            {"ItemRemoved", "{0} has been removed from the Absolut Market because {1}" },
            {"FromBox", "it was removed from the Trade Box!" },
            {"ItemCondChange", "the condition of the item has changed." },
            {"ItemQuantityChange", "the quantity of the item has changed." },
            {"TradeBoxChanged", "you have set a new Trade Box." },
            {"ItemGoneChange", "the item is not in the Seller's box." },
            {"SelectItemToBlacklist", "Select an item to Blacklist...</color>" },
            {"SelectItemToUnBlacklist", "Select an item to Remove from Blacklist...</color>" },
            {"AdminPanel", "Admin Menu" },
            {"BlackListingADD", "Add\nBacklist Item" },
            {"BlackListingREMOVE", "Remove\nBacklist Item" },
            {"ChangeTheme", "Change Theme" },
            {"SelectTheme", "Select a Theme" },
            {"Amount", "Amount: {0}" },
            {"Name", "Name: {0}" },
            {"NotEnoughSRPoints", "You do not have enough ServerReward Points!" },
            {"ImgReload", "Images have been wiped and reloaded!" },
            {"ImgRefresh", "Images have been refreshed !" },
            {"BckReload", "Background Images have been wiped and reloaded!" },
            {"BckRefresh", "Background Images have been refreshed and {0} have been added!" },
            {"Seller", "         Seller\n{0}" },
            {"InExchange", "In Exchange\nFor" },
            {"SellerRemoval", "you removed it." },
            {"AllItemsAreBL", "All the items in your box are BlackListed!" },
            {"AllItemsAreBLNoSR", "All the items in your box are BlackListed and you have 0 Server Rewards Points!" },
            {"AllItemsAreListed", "All the items in your box are already listed! Add more and try again." },
            {"AllItemsAreListedNoSR", "All the items in your box are already listed and you have 0 Server Rewards Points!" },
            {"ChangeMode", "Change Mode" }
        };
        #endregion
    }
}


// --- End of file: AbsolutMarket.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AFKChecker.cs ---
// --- Original Local Path: AFKChecker.cs ---

﻿using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("AFKChecker", "Автор Hougan, дополнил FREDWAY и Ryamkk", "0.0.1")]
    [Description("Проверяет игрока на длительность отсутствия за игрокй")]
    public class AFKChecker : RustPlugin
    {
		private string CheckPermission = "AFKChecker.Moder";
        private string IgnorePermission = "AFKChecker.Ignore";
        private int Interval = 5;
		private ulong senderID = 76561198236355670;
		private string header = "Виртуальный помощник";
		private string prefixcolor = "#81B67A";
		private string prefixsize = "16";
		
		private void LoadDefaultConfig()
        {
            GetConfig("Настройки сообщений", "Иконка для сообщений в чате (необходимо указать id профиля steam)", ref senderID);
            GetConfig("Настройки сообщений", "Названия префикса", ref header);
			GetConfig("Настройки сообщений", "Цвет префикса", ref prefixcolor);
			GetConfig("Настройки сообщений", "Размер префиса", ref prefixsize);
			
			GetConfig("Основные настройки", "Разрешение на проверку игрока", ref CheckPermission);
			GetConfig("Основные настройки", "Разрешение на игнорирование проверки", ref IgnorePermission);
			GetConfig("Основные настройки", "Интервал проверки на движение/крафт/и прочие действия", ref Interval);
            SaveConfig();
        }
		
		[JsonProperty("Словарь хранящий время АФК игроков")]
        private Dictionary<ulong, Player> afkDictionary = new Dictionary<ulong, Player>();
        private class Player
        {
            [JsonProperty("Время без движений")] 
            public int AFKTime = 0;
            [JsonProperty("Прочие действия в этом интервале")]
            public bool Actions = false;
            
            [JsonProperty("Последняя позиция")] 
            public Vector3 LastPosition;
        }

        private void OnServerInitialized()
        {
            permission.RegisterPermission(CheckPermission, this);
            permission.RegisterPermission(IgnorePermission, this);
            
            PrintWarning($"Проверка игрока на AFK запущена, интервал: {Interval} сек.");
            timer.Every(Interval, TrackAFK);
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (afkDictionary.ContainsKey(player.userID))
                afkDictionary.Remove(player.userID);
        }

        private void OnPlayerChat(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (player == null)
                return;
            
            if (!afkDictionary.ContainsKey(player.userID))
                return;
            
            afkDictionary[player.userID].Actions = true;
        }
        
        private void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            if (!afkDictionary.ContainsKey(player.userID))
                return;
            
            afkDictionary[player.userID].Actions = true;
        }
        
        private void OnLootEntityEnd(BasePlayer player, BaseCombatEntity entity)
        {
            if (!afkDictionary.ContainsKey(player.userID))
                return;
            
            afkDictionary[player.userID].Actions = true;
        }

        private void TrackAFK()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (!afkDictionary.ContainsKey(player.userID))
                {
                    afkDictionary.Add(player.userID, new Player 
					{
						LastPosition = player.transform.position 
					});
                    continue;
                }
                
                Player currentPlayer = afkDictionary[player.userID];
                if (currentPlayer.Actions)
                {
                    currentPlayer.LastPosition = player.transform.position;
                    currentPlayer.Actions = false;
                    currentPlayer.AFKTime = 0;
                    continue;
                }

                if (Vector3.Distance(currentPlayer.LastPosition, player.transform.position) > 1)
                {
                    currentPlayer.LastPosition = player.transform.position;
                    currentPlayer.AFKTime = 0;
                    continue;
                }

                if (player.inventory.crafting.queue.Count > 0)
                {
                    currentPlayer.AFKTime = 0;
                    continue;
                }

                currentPlayer.AFKTime += Interval;
            }
        }

        [ChatCommand("afkcheck")]
        private void cmdAFKCheck(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, CheckPermission))
            {
                ReplyWithHelper(player, $"У вас недостаточно прав для использования этой команды");
                return;
            }

            if (args.Length == 0)
            {
                ReplyWithHelper(player, $"Вы не ввели имя игрока которого хотите проверить");
                return;
            }

            List<BasePlayer> targetList = FindPlayers(args[0]);
            switch (targetList.Count)
            {
                case 0:
                {
                    ReplyWithHelper(player, $"Мы не смогли найти игрока по вашему запросу!");
                    break;
                }
                case 1:
                {
                    BasePlayer target = targetList[0];
                    if (permission.UserHasPermission(target.UserIDString, IgnorePermission))
                    {
                        ReplyWithHelper(player, $"Вы не можете проверять этого игрока!");
                        return;
                    }
                    
                    if (!afkDictionary.ContainsKey(target.userID))
                    {
                        ReplyWithHelper(player, $"Непредвиденная ошибка, попробуйте позже!");
                        return;
                    }

                    Player targetAFK = afkDictionary[target.userID];
                    if (targetAFK.AFKTime == 0)
                    {
                        ReplyWithHelper(player, $"Игрок двигался или совершал другие действия в течение последних {Interval} секунд!");
                        return;
                    }
                    
                    ReplyWithHelper(player, $"Игрок не совершал никаких действий в течении последних: {new TimeSpan(0, 0, targetAFK.AFKTime).ToShortString()}!");
                    break;
                }
                default:
                {
                    string message = $"Мы нашли несколько игроков по вашему запросу:\n\n";

                    for (int i = 0; i < targetList.Count; i++)
                        message += $"[<color=#81B67A>{i}.</color>] {targetList[i].displayName} [{targetList[i].userID}]";
                    
                    player.ChatMessage(message);
                    break;
                }
            }
        }

        private bool IsAFK(BasePlayer player)
        {
            Player targetAFK = afkDictionary[player.userID];
            if (targetAFK.AFKTime == 0)
                return false;

            return true;
        }

        private List<BasePlayer> FindPlayers(string nameOrId)
        {
            List<BasePlayer> targetList = new List<BasePlayer>();
            foreach (var check in BasePlayer.activePlayerList)
            {
                if (check.userID.ToString() == nameOrId)
                    return new List<BasePlayer> { check };
                if (check.displayName.ToLower().Contains(nameOrId.ToLower()))
                    targetList.Add(check);
            }
            
            return targetList;
        }
		
		public void ReplyWithHelper(BasePlayer player, string message, string[] args = null)
        {
            if (args != null)
	        {
                message = string.Format(message, args);
	        }
			
	        player.SendConsoleCommand("chat.add", senderID, string.Format("<size=prefixsize><color=prefixcolor>{0}</color>:</size>\n{1}", header, message));
        }
		
		private void GetConfig<T>(string menu, string Key, ref T var)
        {
            if (Config[menu, Key] != null)
            {
                var = (T)Convert.ChangeType(Config[menu, Key], typeof(T));
            }

            Config[menu, Key] = var;
        }
    }
}

// --- End of file: AFKChecker.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/Trade.cs ---
// --- Original Local Path: TrashRust/Trade.cs ---

using Network;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using System;
using System.Linq;
using System.Collections.Generic;
using UnityEngine;
namespace Oxide.Plugins
{
    /*ПЛАГИН БЫЛ ПОФИКШЕН С ПОМОЩЬЮ ПРОГРАММЫ СКАЧАНОЙ С https://discord.gg/dNGbxafuJn */ [Info("Trade", "https://discord.gg/dNGbxafuJn", "2.2.0")]
    public class Trade : RustPlugin
    {
        private static Trade ins;
        private PluginConfig config;
        public List<TradeBox> tradeBoxes = new List<TradeBox>();
        private List<TradePendings> pendings = new List<TradePendings>();
        private Dictionary<BasePlayer, DateTime> Cooldowns = new Dictionary<BasePlayer, DateTime>();

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Благодарим за покупку плагина на сайте RustPlugin.ru. Если вы передадите этот плагин сторонним лицам знайте - это лишает вас гарантированных обновлений!");
            config = PluginConfig.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
            if (config.PluginVersion < Version)
                UpdateConfigValues();
            Config.WriteObject(config, true);
        }

        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (config.PluginVersion < new VersionNumber(2, 2, 0))
            {
                PrintWarning("Config update detected! Updating config values...");
                config.mainSettings.permsNum = new Dictionary<string, PermissionTrade>()
                {
                    ["trade.one"] = new PermissionTrade()
                    {
                        GetCapacity = 4,
                        GetCooldown = 50,
                    },
                    ["trade.two"] = new PermissionTrade()
                    {
                        GetCapacity = 5,
                        GetCooldown = 40,
                    },
                    ["trade.three"] = new PermissionTrade()
                    {
                        GetCapacity = 6,
                        GetCooldown = 30,
                    },
                };
                PrintWarning("Config update completed!");
            }
            config.PluginVersion = Version;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        public class MainSettings
        {
            [JsonProperty("Запретить принимать запрос в BuildingBlock")]
            public bool getCupAuth = true;

            [JsonProperty("Запретить отправлять запрос в BuildingBlock")]
            public bool getCupSend = true;

            [JsonProperty("Запретить использовать трейд в полёте")]
            public bool getFly = true;

            [JsonProperty("Запретить использовать трейд в воде")]
            public bool getSwim = true;

            [JsonProperty("Запретить обмениватся игрокам если игроки не в тиме (Стандартная система друзей)")]
            public bool enabledTeamate = false;

            [JsonProperty("Запретить использовать трейд в предсмертном состоянии")]
            public bool getWound = true;

            [JsonProperty("Время ответа на предложения обмена (секунд)")]
            public int getTime = 15;

            [JsonProperty("Задержка использования трейда (Cooldown - секунд)")]
            public double CooldownTrade = 60.0;

            [JsonProperty("Разрешить трейд если между игроками если их дистанция больше указанной (-1 - отключение)")]
            public double TradeDistance = 50;

            [JsonProperty("Количество активных слотов при обмене")]
            public int getInt = 8;

            [JsonProperty("Список привилегий и размера слотов при обмене")]
            public Dictionary<string, PermissionTrade> permsNum = new Dictionary<string, PermissionTrade>();

            [JsonProperty("Привилегия на использование команды trade")]
            public string Permission = "trade.use";

            [JsonProperty("Разрешить использование трейда только если игрок имеет привилегию указаную в конфиге")]
            public bool UsePermission = false;
        }

        public class PermissionTrade
        {
            [JsonProperty("Размер слотов у данной привилегии")]
            public int GetCapacity = 0;
            [JsonProperty("Задержка после обмена у данной привилегии")]
            public int GetCooldown = 0;
        }

        class PluginConfig
        {
            [JsonProperty("Основные")]
            public MainSettings mainSettings;

            [JsonProperty("Версия конфигурации")]
            public VersionNumber PluginVersion = new VersionNumber();


            [JsonIgnore]
            [JsonProperty("Инициализация плагина")]
            public bool Init;

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    mainSettings = new MainSettings()
                    {
                        permsNum = new Dictionary<string, PermissionTrade>()
                        {
                            ["trade.one"] = new PermissionTrade()
                            {
                                GetCapacity = 4,
                                GetCooldown = 50,
                            },
                            ["trade.two"] = new PermissionTrade()
                            {
                                GetCapacity = 5,
                                GetCooldown = 40,
                            },
                            ["trade.three"] = new PermissionTrade()
                            {
                                GetCapacity = 6,
                                GetCooldown = 30,
                            },
                        }
                    },
                    PluginVersion = new VersionNumber(),

                };
            }
        }

        [PluginReference] Plugin Duel;
        private bool IsDuelPlayer(BasePlayer player)
        {
            if (!Duel) return false;
            var dueler = Duel?.Call("IsPlayerOnActiveDuel", player);
            if (dueler is bool) return (bool)dueler;
            return false;
        }

        private bool IsTeamate(BasePlayer player, BasePlayer target)
        {
            if (!config.mainSettings.enabledTeamate) return true;
            if (player.currentTeam == 0 || target.currentTeam == 0) return false;
            return player.currentTeam == target.currentTeam;
        }

        int GetTradeSize(string UserID)
        {
            int size = config.mainSettings.getInt;
            foreach (var num in config.mainSettings.permsNum)
            {
                if (permission.UserHasPermission(UserID, num.Key))
                    if (num.Value.GetCapacity > size) size = num.Value.GetCapacity;
            }
            return size;
        }

        double GetPlayerCooldown(string UserID)
        {
            var cd = config.mainSettings.CooldownTrade;
            foreach (var num in config.mainSettings.permsNum)
            {
                if (permission.UserHasPermission(UserID, num.Key))
                    if (num.Value.GetCooldown < cd) cd = num.Value.GetCapacity;
            }
            return cd;
        }

        void Reply(BasePlayer player, string langKey, params object[] args) => SendReply(player, Messages[langKey], args);

        bool CanPlayerTrade(BasePlayer player)
        {
            var reply = 288;
            if (reply == 0) { }
            if (!config.Init) return false;
            if (config.mainSettings.getSwim)
            {
                if (player.IsSwimming())
                {
                    Reply(player, "DENIED.SWIMMING");
                    return false;
                }
            }
            if (config.mainSettings.getCupSend || config.mainSettings.getCupAuth)
            {
                if (!player.CanBuild())
                {
                    Reply(player, "DENIED.PRIVILEGE");
                    return false;
                }
            }
            if (config.mainSettings.getFly)
            {
                if (!player.IsOnGround() || player.IsFlying)
                {
                    Reply(player, "DENIED.FALLING");
                    return false;
                }
            }
            if (config.mainSettings.getWound)
            {
                if (player.IsWounded())
                {
                    Reply(player, "DENIED.WOUNDED");
                    return false;
                }
            }
            if (Cooldowns.ContainsKey(player))
            {
                double seconds = Cooldowns[player].Subtract(DateTime.Now).TotalSeconds;
                if (seconds >= 0)
                {
                    Reply(player, "COOLDOWN", seconds);
                    return false;
                }
            }
            if (IsDuelPlayer(player))
            {
                Reply(player, "DENIED.DUEL");
                return false;
            }
            var canTrade = Interface.Call("CanTrade", player);
            if (canTrade != null)
            {
                if (canTrade is string)
                {
                    SendReply(player, Convert.ToString(canTrade));
                    return false;
                }
                Reply(player, "DENIED.GENERIC");
                return false;
            }
            return true;
        }

        Dictionary<string, string> Messages = new Dictionary<string, string>() {
                {
                "DENIED.SWIMMING", "Недоступно, вы плаваете!"
            }
            , {
                "DENIED.DUEL", "Недоступно, один из игроков на Duel!"
            }
            , {
                "DENIED.PERMISSIONON", "Недоступно, у Вас нету прав на использование трейда!"
            }
            , {
                "DENIED.PERMISSIOONTARGETN", "Недоступно, у {0} прав на использование трейда!"
            }
            , {
                "DENIED.FALLING", "Недоступно, вы левитируете!"
            }
            , {
                "DENIED.WOUNDED", "Недоступно, вы в предсмертном состоянии!"
            }
            , {
                "DENIED.GENERIC", "Недоступно, заблокировано другим плагином!"
            }
            , {
                "DENIED.PRIVILEGE", "Недоступно, вы в зоне Building Blocked!"
            }
            , {
                "DENIED.PERMISSION", "Недоступно, вы в зоне Building Blocked!"
            }
            , {
                "TRADE.HELP", "Trade by RustPlugin.ru\nИспользуйте комманду <color=orange>/trade \"НИК\"</color> для обмена\nЧто бы принять обмен, введите: <color=orange>/trade yes</color> (или /trade accept)\nЧто бы отказаться от обмена введите: <color=orange>/trade no </color> (или /trade cancel)"
            }
            , {
                "PLAYER.NOT.FOUND", "Игрок '{0}' не найден!"
            }
             , {
                "TRADE.ALREADY.PENDING", "Невозможно! Вы либо вам уже отправлено предложение обмена!"
            }
            , {
                "TRADE.TARGET.ALREADY.PENDING", "Невозможно! У игрока есть активное предложение обмена!"
            }

            , {
                "TRADE.ACCEPT.PENDING.EMPTY", "У вас нет входящих предложний обмена!"
            }
            , {
                "TRADE.CANCELED", "Trade отменен!"
            }
            , {
                "TRADE.TOYOU", "Нельзя отправлять запрос самому себе!"
            }
            , {
                "TRADE.SUCCESS", "Trade успешно завершён!"
            }
            , {
                "PENDING.RECIEVER.FORMAT", "Игрок '{0}' отправил вам предложние обмена\nДля принятия обмена используйте команду <color=orange>/trade yes</color>\nЧто бы отказаться введите <color=orange>/trade no</color>"
            }
            , {
                "PENDING.SENDER.FORMAT", "Предложение обмена игроку '{0}' успешно отправлено, ожидайте..."
            }
            , {
                "PENDING.TIMEOUT.SENDER", "Trade отменён! Причина: время истекло."
            }
            , {
                "PENDING.TIMEOUT.RECIEVER", "Trade отменён! Причина: вы вовремя не приняли запрос."
            }
            , {
                "PENDING.CANCEL.SENDER", "Trade отменён! Причина: игрок '{0}' отказался"
            },
            {
                "COOLDOWN", "Вы только недавно обменивались, подождите - {0:0} сек."
            },
            {
                "GET.FRIENDS", "Вы не состоите в одной тиме с игроком {0}, трейд запрещен"
            },
            {
                "GET.DISTANCE", "Трейд запрещен на малых дистанциях между вами игроком"
            },
        };


        private void Loaded()
        {
            ins = this;
            lang.RegisterMessages(Messages, this);
            Messages = lang.GetMessages("en", this);
            permission.RegisterPermission(config.mainSettings.Permission, this);
            var perms = config.mainSettings.permsNum.Where(p => p.Key.StartsWith("trade."));
            foreach (var perm in perms)
            {
                if (!permission.PermissionExists(perm.Key))
                    permission.RegisterPermission(perm.Key, this);

            }
            if (!permission.PermissionExists(config.mainSettings.Permission))
                permission.RegisterPermission(config.mainSettings.Permission, this);
            config.Init = true;
        }

        void OnServerInitialized()
        {
            timer.Every(1f, TradeTimerHandle);
        }

        class TradePendings
        {
            public BasePlayer target;
            public BasePlayer player;
            public int seconds;

            public TradePendings(BasePlayer player, int Seconds, BasePlayer target)
            {
                this.target = target;
                this.player = player;
                seconds = Seconds;

            }
        }

        void TradeTimerHandle()
        {
            for (int i = pendings.Count - 1;
           i >= 0;
           i--)
            {
                var pend = pendings[i];
                if (pend.target != null && !pend.target.IsConnected || pend.target.IsWounded())
                {
                    pendings.RemoveAt(i);
                    continue;
                }
                if (pend.player != null && !pend.player.IsConnected || pend.player.IsWounded())
                {
                    pendings.RemoveAt(i);
                    continue;
                }
                if (--pend.seconds <= 0)
                {
                    pendings.RemoveAt(i);
                    if (pend.player.IsConnected) Reply(pend.player, "PENDING.TIMEOUT.SENDER");
                    if (pend.target.IsConnected) Reply(pend.target, "PENDING.TIMEOUT.RECIEVER");
                }
            }
        }

        void Unload()
        {
            foreach (var trade in tradeBoxes)
            {
                UnityEngine.Object.Destroy(trade);
            }
        }

        private void OnItemSplit(Item item, int amount)
        {
            if (!config.Init) return;
            if (item == null) return;
            if (item.GetRootContainer() == null || item.GetRootContainer()?.entityOwner == null || item.GetRootContainer()?.entityOwner?.GetComponent<ShopFront>() == null) return;
            var container = item.GetRootContainer().entityOwner?.GetComponent<ShopFront>();
            if (container != null)
                if (container.GetComponent<TradeBox>() != null)
                {
                    if (container.vendorInventory != null && container.customerInventory != null)
                        if (container.vendorInventory.IsLocked() || container.customerInventory.IsLocked())
                            container.ResetTrade();
                }
        }

        [PluginReference] Plugin SkinBox;

        bool isSkinBox(ulong playerID)
        {
            if (!SkinBox) return false;
            return (bool)SkinBox?.Call("IsSkinBoxPlayer", playerID);
        }

        object CanMoveItem(Item item, PlayerInventory playerLoot, ItemContainerId targetContainer, bool fag)
        {
            if (!config.Init) return null;
            if (playerLoot == null) return null;
            var container = playerLoot.FindContainer(targetContainer);
            if (container == null) return null;
            var player = playerLoot.containerMain.playerOwner;
            if (player == null) return null;
            if (container.entityOwner != null && container.entityOwner is ShopFront)
            {
                var shopfront = container.entityOwner.GetComponent<ShopFront>();
                if (shopfront != null)
                {
                    if (item.contents != null)
                    {
                        item.contents.SetLocked(true);
                        item.MarkDirty();
                    }
                    if (shopfront.IsPlayerCustomer(player) && shopfront.customerInventory.uid!= targetContainer)
                        return false;
                    else if (shopfront.IsPlayerVendor(player) && shopfront.vendorInventory.uid!= targetContainer) return false;
                }
            }
            else
            {
                if (item.contents != null && item.contents.IsLocked() && !isSkinBox(player.userID))
                {
                    item.contents.SetLocked(false);
                    item.MarkDirty();
                }
            }
            return null;
        }

        void OnEntityKill(ShopFront shop)
        {
            if (shop == null) return;
            if (shop.GetComponent<TradeBox>() != null)
            {
                if (shop.GetComponent<TradeBox>().player1 != null)
                    shop.GetComponent<TradeBox>().player1.EndLooting();
                if (shop.GetComponent<TradeBox>().player2 != null)
                    shop.GetComponent<TradeBox>().player2.EndLooting();
            }
        }

        object OnEntityVisibilityCheck(ShopFront shop, BasePlayer player, ulong rpcId, string debugName, float maximumDistance)
        {
            if (!config.Init) return null;
            if (shop == null || shop?.net.ID == null || player == null) return null;
            if (shop.GetComponent<TradeBox>() != null)
            {
                if (shop.IsPlayerVendor(player))
                {
                    shop.SetFlag(global::BaseEntity.Flags.Reserved1, true, false, true);
                    shop.vendorInventory.SetLocked(true);
                }
                else if (shop.IsPlayerCustomer(player))
                {
                    shop.SetFlag(global::BaseEntity.Flags.Reserved2, true, false, true);
                    shop.customerInventory.SetLocked(true);
                }
                if (shop.HasFlag(global::BaseEntity.Flags.Reserved1) && shop.HasFlag(global::BaseEntity.Flags.Reserved2))
                {
                    shop.SetFlag(global::BaseEntity.Flags.Reserved3, true, false, true);
                    shop.Invoke(new Action(shop.GetComponent<TradeBox>().CustomCompleteTrade), 2f);
                    return false;
                }
                return true;
            }
            return null;
        }

        public BasePlayer FindOnline(string nameOrUserId, ulong playerid = 294912)
        {
            nameOrUserId = nameOrUserId.ToLower();
            foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
            {
                if (activePlayer.displayName.ToLower().Contains(nameOrUserId) || activePlayer.UserIDString == nameOrUserId) return activePlayer;
            }
            return null;
        }

        [ConsoleCommand("trade")]
        void cmdTrade(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null || arg.Args.Length == 0) return;
            var name = arg.Args[0];
            CmdChatTrade(player, string.Empty, new string[] {
                name
            }
            );
        }

        [ChatCommand("trade")]
        void CmdChatTrade(BasePlayer player, string command, string[] args)
        {
            if (!config.Init) return;
            if (player == null) return;
            if (args.Length == 0 || args == null)
            {
                Reply(player, "TRADE.HELP");
                return;
            }
            if (config.mainSettings.UsePermission && !permission.UserHasPermission(player.UserIDString, config.mainSettings.Permission))
            {
                Reply(player, "DENIED.PERMISSIONON");
                return;
            }
            if (Cooldowns.ContainsKey(player))
            {
                double seconds = Cooldowns[player].Subtract(DateTime.Now).TotalSeconds;
                if (seconds >= 0)
                {
                    Reply(player, "COOLDOWN", seconds);
                    return;
                }
            }
            switch (args[0])
            {
                default:
                    if (!CanPlayerTrade(player))
                        return;
                    var name = args[0];
                    var target = FindOnline(name);
                    if (target == null)
                    {
                        Reply(player, "PLAYER.NOT.FOUND", name);
                        return;
                    }
                    if (target == player)
                    {
                        Reply(player, "TRADE.TOYOU");
                        return;
                    }
                    if (!IsTeamate(player, target))
                    {
                        Reply(player, "GET.FRIENDS", target.displayName);
                        return;
                    }
                    if (Vector3.Distance(player.transform.position, target.transform.position) < config.mainSettings.TradeDistance)
                    {
                        Reply(player, "GET.DISTANCE", target.displayName);
                        return;
                    }


                    var tradeTargetpend = pendings.Find(p => p.player == target || p.target == target);
                    if (tradeTargetpend != null)
                    {
                        Reply(player, "TRADE.TARGET.ALREADY.PENDING");
                        return;
                    }
                    if (config.mainSettings.UsePermission && !permission.UserHasPermission(target.UserIDString, config.mainSettings.Permission))
                    {
                        Reply(player, "DENIED.PERMISSIOONTARGETN", target.displayName);
                        return;
                    }
                    if (config.mainSettings.getCupSend)
                    {
                        if (!player.CanBuild())
                        {
                            Reply(player, "DENIED.PRIVILEGE");
                            return;
                        }
                    }

                    var tradepend = pendings.Find(p => p.player == player || p.target == player);
                    if (tradepend != null)
                    {
                        Reply(player, "TRADE.ALREADY.PENDING");
                        return;
                    }
                    pendings.Add(new TradePendings(player, config.mainSettings.getTime, target));
                    Reply(player, "PENDING.SENDER.FORMAT", target.displayName);
                    Reply(target, "PENDING.RECIEVER.FORMAT", player.displayName);
                    break;
                case "accept":
                case "yes":
                    if (!CanPlayerTrade(player)) return;
                    var tp = pendings.Find(p => p.player == player || p.target == player);
                    if (tp == null)
                    {
                        Reply(player, "TRADE.ACCEPT.PENDING.EMPTY");
                        return;
                    }
                    if (IsDuelPlayer(tp.target) || IsDuelPlayer(tp.player))
                    {
                        pendings.Remove(tp);
                        Reply(tp.player, "DENIED.DUEL");
                        Reply(tp.target, "DENIED.DUEL");
                        return;
                    }
                    pendings.Remove(tp);
                    TradeBox trade = TradeBox.Spawn();
                    if (trade == null) return;

                    tradeBoxes.Add(trade);
                    timer.Once(0.5f, () =>
                    {
                        if (tp.player == null || !tp.player.IsConnected) return;
                        if (tp.target == null || !tp.target.IsConnected) return;
                        trade.StartLoot(tp.player, tp.target);
                    });
                    break;
                case "cancel":
                case "no":
                    var pend = pendings.Find(p => p.player == player || p.target == player);
                    if (pend == null)
                    {
                        Reply(player, "TRADE.ACCEPT.PENDING.EMPTY");
                        return;
                    }
                    pendings.Remove(pend);

                    if (pend.player.IsConnected) Reply(pend.player, "PENDING.CANCEL.SENDER", player.displayName);
                    Reply(pend.target, "TRADE.CANCELED");
                    break;
            }
        }

        public class TradeBox : MonoBehaviour
        {
            public ShopFront shopFront;
            public BasePlayer player1, player2;

            void Awake()
            {
                shopFront = gameObject.GetComponent<ShopFront>();
                enabled = false;
            }

            public static TradeBox Spawn()
            {
                var storage = SpawnContainer(new Vector3());
                var box = storage.gameObject.AddComponent<TradeBox>();
                return box;
            }

            private static ShopFront SpawnContainer(Vector3 position)
            {
                ShopFront shopFront = GameManager.server.CreateEntity("assets/prefabs/building/wall.frame.shopfront/wall.frame.shopfront.metal.prefab", position, new Quaternion(), true) as ShopFront;
                if (shopFront == null) return null;
                shopFront.Spawn();
                shopFront.vendorInventory.capacity = 1;
                shopFront.customerInventory.capacity = 1;
                UnityEngine.Object.Destroy(shopFront.GetComponent<DestroyOnGroundMissing>());
                UnityEngine.Object.Destroy(shopFront.GetComponent<GroundWatch>());
                return shopFront;
            }

            public void StartLoot(BasePlayer player, BasePlayer target)
            {
                if (player == null || target == null)
                {
                    Destroy(this);
                    return;
                }
                player1 = player;
                player2 = target;
                shopFront.vendorInventory.capacity = ins.GetTradeSize(player.UserIDString);
                shopFront.customerInventory.capacity = ins.GetTradeSize(target.UserIDString);
                player.EndLooting();
                target.EndLooting();
                shopFront.vendorPlayer = player1;
                shopFront.customerPlayer = player2;
                if (!player1.net.subscriber.IsSubscribed(shopFront.net.group))
                    player1.net.subscriber.Subscribe(shopFront.net.group);
                if (!player2.net.subscriber.IsSubscribed(shopFront.net.group))
                    player2.net.subscriber.Subscribe(shopFront.net.group);
                SendEntity(player1, (BaseEntity)shopFront);
                SendEntity(player2, (BaseEntity)shopFront);
                SendEntity(player1, (BaseEntity)player2);
                SendEntity(player2, (BaseEntity)player1);
                StartLooting(player1);
                StartLooting(player2);
                shopFront.ResetTrade();
                shopFront.UpdatePlayers();
                enabled = true;

            }

            public void SendEntity(BasePlayer a, BaseEntity b, string reason = "⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠")
            {
                









var      nw = Net.sv.StartWrite();
                {
                    a.net.connection.validate.entityUpdates++;
                    BaseNetworkable.SaveInfo c = new BaseNetworkable.SaveInfo
                    {
                        forConnection = a.net.connection,
                        forDisk = false
                    }
                    ;
                    nw.PacketID(Message.Type.Entities);
                    nw.UInt32(a.net.connection.validate.entityUpdates);
                    b.ToStreamForNetwork(nw, c);
                    nw.Send(new SendInfo(a.net.connection));
                }
            }

            public void StartLooting(BasePlayer player)
            {
                player.inventory.loot.StartLootingEntity(shopFront, false);
                player.inventory.loot.AddContainer(shopFront.vendorInventory);
                player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", shopFront.panelName);
                shopFront.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                player.inventory.loot.AddContainer(shopFront.customerInventory);
                player.inventory.loot.SendImmediate();
            }

            public void PlayerStoppedLooting(BasePlayer player) => Destroy(this);

            public void OnDestroy()
            {
                if (player1 != null)
                    player1.EndLooting();
                if (player2 != null)
                    player2.EndLooting();
                if (shopFront != null && !shopFront.IsDestroyed)
                    shopFront.Kill();
            }

            void FixedUpdate()
            {
                if (!player1.net.subscriber.IsSubscribed(shopFront.net.group))
                {
                    SendEntity(player1, shopFront);
                    SendEntity(player1, player2);
                    player1.net.subscriber.Subscribe(shopFront.net.group);
                    shopFront.UpdatePlayers();
                }
                if (!player2.net.subscriber.IsSubscribed(shopFront.net.group))
                {
                    SendEntity(player2, shopFront);
                    SendEntity(player2, player1);
                    player2.net.subscriber.Subscribe(shopFront.net.group);
                    shopFront.UpdatePlayers();
                }
            }


            public void CustomCompleteTrade()
            {
                if (shopFront.vendorPlayer != null && shopFront.customerPlayer != null && shopFront.HasFlag(global::BaseEntity.Flags.Reserved1) && shopFront.HasFlag(global::BaseEntity.Flags.Reserved2))
                {
                    for (int i = shopFront.vendorInventory.capacity - 1; i >= 0; i--)
                    {
                        Item slot = shopFront.vendorInventory.GetSlot(i);
                        Item slot2 = shopFront.customerInventory.GetSlot(i);
                        if (shopFront.customerPlayer && slot != null)
                        {
                            player2.GiveItem(slot, global::BaseEntity.GiveItemReason.Generic);
                        }
                        if (shopFront.vendorPlayer && slot2 != null)
                        {
                            player1.GiveItem(slot2, global::BaseEntity.GiveItemReason.Generic);
                        }
                    }
                    global::Effect.server.Run(shopFront.transactionCompleteEffect.resourcePath, player1, 0u, new Vector3(0f, 1f, 0f), Vector3.zero, null, false);
                    global::Effect.server.Run(shopFront.transactionCompleteEffect.resourcePath, player2, 0u, new Vector3(0f, 1f, 0f), Vector3.zero, null, false);
                    ins.Reply(player1, "TRADE.SUCCESS");
                    ins.Reply(player2, "TRADE.SUCCESS");
                    ins.Cooldowns[player1] = DateTime.Now.AddSeconds(ins.GetPlayerCooldown(player1.UserIDString));
                    ins.Cooldowns[player2] = DateTime.Now.AddSeconds(ins.GetPlayerCooldown(player2.UserIDString));
                    ins.tradeBoxes.Remove(this);
                    Destroy(this);
                }
            }
        }

        bool PlayerGetActiveTrade(BasePlayer player)
        {
            var contains = pendings.Find(p => p.target == player);
            return contains != null;
        }
    }
}

// --- End of file: Trade.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/NoPhysics.cs ---
// --- Original Local Path: TrashRust/NoPhysics.cs ---

﻿using Physics = UnityEngine.Physics;

namespace Oxide.Plugins
{
    [Info("NoPhysics", "Mategus", "1.0.0")]

    class NoPhysics : RustPlugin
    {
        void OnServerInitialized()
        {
            DisableCollision();
        }

        private void DisableCollision()
        {
            Physics.IgnoreLayerCollision(26, 26, true);
        }
    }
}

// --- End of file: NoPhysics.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/IQReportSystem.cs ---
// --- Original Local Path: TrashRust/IQReportSystem.cs ---

﻿using System;
using System.Collections.Generic;
using UnityEngine;
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Libraries.Covalence;
using ConVar;
using Newtonsoft.Json.Linq;
using Oxide.Core.Libraries;
using System.Linq;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("IQReportSystem", "Mercury", "0.1.9")]
    class IQReportSystem : RustPlugin
    {
        /// <summary>
        /// - Поправил , когда игроки с меню в режиме оффлайн пропадали
        /// 
        /// Обновление 0.1.8 :
        /// - Исправил совместимость с IQFakeActive
        /// - Исправил метод с жалобой, когда не был установлен IQFakeActive
        /// - Исправлены страницы
        /// - Исправлен поиск по нику или SteamID 
        /// - Корректирован поиск по игрокам , теперь он ищет не зависимо от регистра
        /// - Оптимизировал плагин
        /// 
        ///  Обновление 0.1.9 :
        ///  - Обновлены страницы
        ///  - Поправлена ошибка с стимИд после поиска
        /// </summary>

        #region Reference
        [PluginReference] Plugin GameWerAC, ImageLibrary, MultiFighting, IQChat, Friends, IQPersonal, IQFakeActive;
        public string GetImage(string shortname, ulong skin = 0) => (string)ImageLibrary?.Call("GetImage", shortname, skin);
        public bool AddImage(string url, string shortname, ulong skin = 0) => (bool)ImageLibrary?.Call("AddImage", url, shortname, skin);
        public void SetCheck(BasePlayer player) => IQPersonal?.CallHook("API_SET_CHECK", player.userID);
        public void SetBans(BasePlayer player) => IQPersonal?.CallHook("API_SET_BANS", player.userID);
        public void SetScore(ulong UserID, int Amount) => IQPersonal?.CallHook("API_SET_SCORE", UserID, Amount);
        public void RemoveScore(ulong UserID, int Amount) => IQPersonal?.CallHook("API_REMOVE_SCORE", UserID, Amount);

        #region IQFakeActive
        public bool IsFake(ulong userID)
        {
            if (!IQFakeActive) return false;
            if (!config.IQFakeActiveSettings.UseIQFakeActive) return false;

            return (bool)IQFakeActive?.Call("IsFake", userID);
        }
        public string FindFakeName(ulong userID) => (string)IQFakeActive?.Call("FindFakeName", userID);
        public void StartSysncFakeActive() => IQFakeActive?.Call("SyncReserved");
        void SyncReservedFinish(string JSON)
        {
            if (!config.IQFakeActiveSettings.UseIQFakeActive) return;
            List<FakePlayer> ContentDeserialize = JsonConvert.DeserializeObject<List<FakePlayer>>(JSON);
            PlayerBases = ContentDeserialize;

            PrintWarning("IQReportSystem - успешно синхронизирована с IQFakeActive");
            PrintWarning("=============SYNC==================");

            
        }
        public List<FakePlayer> PlayerBases = new List<FakePlayer>();
        public class FakePlayer
        {
            public ulong UserID;
            public string DisplayName;
            public string IQChatPreifx;
            public string IQChatColorChat;
            public string IQChatColorNick;
        }
        #endregion

        #endregion

        #region Vars

        #region Permission
        string PermissionModeration = "moderation.iqreportsystem";
        string PermissionAdmin = "admin.iqreportsystem";
        #endregion

        #region Lists
        public Dictionary<ulong, int> CooldownPC = new Dictionary<ulong, int>();
        public Dictionary<ulong, PlayerSaveCheckClass> PlayerSaveCheck = new Dictionary<ulong, PlayerSaveCheckClass>();
        public class PlayerSaveCheckClass
        {
            public string Discord;
            public string NickName;
            public string StatusNetwork;

            public ulong ModeratorID;
        }
        #endregion

        #region JSON
        private class Response
        {
            public List<string> last_ip;
            public string last_nick;
            public List<ulong> another_accs;
            public List<last_checks> last_check;
            public class last_checks
            {
                public ulong moderSteamID;
                public string serverName;
                public int time;
            }
            public List<RustCCBans> bans;
            public class RustCCBans
            {
                public int banID;
                public string reason;
                public string serverName;
                public int OVHserverID;
                public int banDate;
            }
        }
        #endregion

        #endregion

        #region Configuration
        private static Configuration config = new Configuration();
        public class Configuration
        {
            [JsonProperty("Основные настройки")]
            public Settings Setting = new Settings();
            [JsonProperty("Причины репорта")]
            public List<string> ReasonReport = new List<string>();
            [JsonProperty("Причины блокировки")] 
            public List<BanReason> ReasonBan = new List<BanReason>();
            [JsonProperty("Настройки RustCheatCheck(Будет при проверке выдавать доступ в чекер и выводить информацию модератору)")]
            public RCCSettings RCCSetting = new RCCSettings();
            [JsonProperty("Настройка репутации для проверяющих")]
            public RaitingSettings RaitingSetting = new RaitingSettings();
            [JsonProperty("Настройка совместной работы с IQFakeActive")]
            public IQFakeActive IQFakeActiveSettings = new IQFakeActive();
            internal class BanReason
            {
                [JsonProperty("Название")]
                public string DisplayName;
                [JsonProperty("Команда")]
                public string Command;
            }
            internal class RCCSettings
            {
                [JsonProperty("Включить поддержку RCC")]
                public bool RCCUse;
                [JsonProperty("Ключ от RCC")]
                public string Key;
            }
            internal class RaitingSettings
            {
                [JsonProperty("Сколько репутации снимать за 1-2 звезды(IQPersonal)")]
                public int RemoveAmountOneTwo;
                [JsonProperty("Сколько репутации давать за 3-4 звезды(IQPersonal)")]
                public int GiveAmountThreeFour;
                [JsonProperty("Сколько репутации давать за 5 звезд(IQPersonal)")]
                public int GiveAmountFive;
            }
            internal class IQFakeActive
            {
                [JsonProperty("Использовать IQFakeActive")]
                public bool UseIQFakeActive;
            }
            internal class Settings
            {
                [JsonProperty("Настройки IQChat")]
                public ChatSettings ChatSetting = new ChatSettings();
                [JsonProperty("Настройки интерфейса")]
                public InterfaceSetting Interface = new InterfaceSetting();

                [JsonProperty("Включить/отключить общее оповоещение для всех игроков(если игрока вызвали на проверку или вынесли вердикт,сообщение будет видно всем)")]
                public bool UseAlertUsers;

                [JsonProperty("Включить/отключить оповещение о максимальном кол-во репортов")]
                public bool MaxReportAlert;
                [JsonProperty("Максимальное количество репортов")]
                public int MaxReport;
                [JsonProperty("Перезарядка для отправки репорта(секунды)")]
                public int CooldownTime;
                [JsonProperty("Запретить друзьям репортить друг друга")]
                public bool FriendNoReport;
                [JsonProperty("Включить логирование в беседу ВК")]
                public bool VKMessage;
                [JsonProperty("Включить логирование в Discord")]
                public bool DiscrodMessage;
                [JsonProperty("Webhooks для дискорда")]
                public string WebHook;
                [JsonProperty("Настройки ВК")]
                public VKSetting VKSettings = new VKSetting();

                internal class ChatSettings
                {
                    [JsonProperty("IQChat : Кастомный префикс в чате")]
                    public string CustomPrefix;
                    [JsonProperty("IQChat : Кастомный аватар в чате(Если требуется)")]
                    public string CustomAvatar;
                }
                internal class VKSetting
                {
                    [JsonProperty("Токен от группы ВК(От группы будут идти сообщения в беседу.Вам нужно добавить свою группу в беседу!)")]
                    public string Token;
                    [JsonProperty("ID беседы для группы")]
                    public string ChatID;
                }
                internal class InterfaceSetting
                {
                    [JsonProperty("Настройка интерфейса для отправки жалобы")]
                    public ReasonInterfaceSetting ReasonInterface = new ReasonInterfaceSetting();
                    [JsonProperty("Настройка интерфейса для уведомления")]
                    public AlertInterfaceSettings AlertInterface = new AlertInterfaceSettings(); 
                    [JsonProperty("Настройка интерфейса для мини-панели модератора")]
                    public ModeratorPanelInterfaceSettings ModderatorPanel = new ModeratorPanelInterfaceSettings(); 
                    [JsonProperty("Настройка интерфейса для рейтинга")]
                    public RaitingInterfaceSettings RaitingInterface = new RaitingInterfaceSettings();
                    [JsonProperty("Sprite для рейтинга(звезды)")]
                    public string SpriteRaiting;
                    [JsonProperty("Sprite для кнопки жалоб в панели модератора")]
                    public string SpriteReportModeration;
                    [JsonProperty("Sprite для иконки жалоб")]
                    public string SpriteReport;
                    [JsonProperty("Цвет текста в плагине")]
                    public string HexLabels;
                    [JsonProperty("Цвет боковой панели")]
                    public string HexRightMenu;
                    [JsonProperty("Цвет кнопок боковой панели")]
                    public string HexButtonRightMenu;
                    [JsonProperty("Цвет основной панели")]
                    public string HexMainPanel;
                    [JsonProperty("Цвет панели поиска и заднего фона игроков")]
                    public string HexSearchPanel; 
                    [JsonProperty("Цвет кнопки у игрока для перехода к действию")]
                    public string HexPlayerButton;
                    [JsonProperty("Sprite кнопки у игрока для преехода к действию")]
                    public string SpritePlayerButton;

                    internal class ReasonInterfaceSetting
                    {
                        [JsonProperty("Цвет основной панели")]
                        public string HexMain;
                        [JsonProperty("Цвет панели с заголовком")]
                        public string HexTitlePanel;
                        [JsonProperty("Цвет жалоб")]
                        public string HexButton;
                        [JsonProperty("Цвет текста с жалобами")]
                        public string HexLabel;
                        [JsonProperty("Sprite кнопки закрыть")]
                        public string SpriteClose;             
                        [JsonProperty("Sprite панели с заголовком")]
                        public string SpriteTitlePanel;
                        [JsonProperty("Цвет кнопки закрыть")]
                        public string HexClose;
                    }
                    internal class AlertInterfaceSettings
                    {
                        [JsonProperty("Цвет основной панели")]
                        public string HexMain;
                        [JsonProperty("Цвет заголовка и полоски")]
                        public string HexTitle;
                        [JsonProperty("Цвет текста")]
                        public string HexLabel;
                    }
                    internal class ModeratorPanelInterfaceSettings
                    {
                        [JsonProperty("Цвет основной панели")]
                        public string HexMain;
                        [JsonProperty("Цвет панели с заголовком")]
                        public string HexTitlePanel;
                        [JsonProperty("Sprite панели с заголовком")]
                        public string SpriteTitlePanel;
                        [JsonProperty("Цвет текста")]
                        public string HexLabel;
                        [JsonProperty("Цвет кнопки вердикт и задний фон причин")]
                        public string HexBanButton;
                        [JsonProperty("Цвет кнопки окончания проверки")]
                        public string HexStopButton;
                    }
                    internal class RaitingInterfaceSettings
                    {
                        [JsonProperty("Цвет основной панели")]
                        public string HexMain;
                        [JsonProperty("Цвет панели с заголовком")]
                        public string HexTitlePanel;
                        [JsonProperty("Sprite панели с заголовком")]
                        public string SpriteTitlePanel;
                        [JsonProperty("Цвет текста")]
                        public string HexLabel;
                        [JsonProperty("Цвет иконок с рейтингом")]
                        public string HexRaitingButton;
                        [JsonProperty("Sprite рейтинга")]
                        public string SpriteRaiting;
                    }
                }
            }

            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    Setting = new Settings
                    {
                        UseAlertUsers = true,
                        FriendNoReport = false,
                        MaxReport = 3,
                        MaxReportAlert = true,
                        CooldownTime = 600,
                        VKMessage = true,
                        DiscrodMessage = false,
                        WebHook = "",
                        ChatSetting = new Settings.ChatSettings
                        {
                            CustomAvatar = "",
                            CustomPrefix = ""
                        },
                        VKSettings = new Settings.VKSetting
                        {
                            Token = "",
                            ChatID = ""
                        },
                        Interface = new Settings.InterfaceSetting
                        {
                            SpriteRaiting = "assets/icons/favourite_servers.png",
                            SpriteReportModeration = "assets/icons/subtract.png",
                            SpriteReport = "assets/icons/examine.png",
                            SpritePlayerButton = "assets/icons/vote_up.png",
                            HexPlayerButton = "#45542BFF",
                            HexLabels = "#DAD1C7FF",
                            HexButtonRightMenu = "#802A2AFF",
                            HexMainPanel = "#21211AF2",
                            HexRightMenu = "#762424FF",
                            HexSearchPanel = "#3B3D37FF",
                            ReasonInterface = new Settings.InterfaceSetting.ReasonInterfaceSetting
                            {
                                HexMain = "#585450FF",
                                HexTitlePanel = "#54514DFF",
                                HexButton = "#3E482EFF",
                                HexClose = "#B4371EFF",
                                HexLabel = "#bdd197",
                                SpriteClose = "assets/icons/vote_down.png",
                                SpriteTitlePanel = "assets/icons/connection.png"
                            },
                            AlertInterface = new Settings.InterfaceSetting.AlertInterfaceSettings
                            {
                                HexMain = "#21211AF2",
                                HexLabel = "#DAD1C7FF",
                                HexTitle = "#B4371EFF",
                            },
                            ModderatorPanel = new Settings.InterfaceSetting.ModeratorPanelInterfaceSettings
                            {
                                HexMain = "#575450FF",
                                HexTitlePanel = "#54514DFF",
                                HexLabel = "#DAD1C7FF",
                                SpriteTitlePanel = "assets/icons/study.png",
                                HexBanButton = "#B4371EFF",
                                HexStopButton = "#3E482EFF"
                            },
                            RaitingInterface = new Settings.InterfaceSetting.RaitingInterfaceSettings
                            {
                                HexMain = "#575450FF",
                                HexTitlePanel = "#54514DFF",
                                HexLabel = "#DAD1C7FF",
                                HexRaitingButton = "#cdb980",
                                SpriteTitlePanel = "assets/icons/ignite.png",
                                SpriteRaiting = "assets/icons/favourite_servers.png"
                            }
                        }
                    },
                    ReasonReport = new List<string>
                    {
                        "Использование читов",
                        "Макросы",
                        "Игра 3+",                      
                    },
                    ReasonBan = new List<BanReason>
                    { 
                        new BanReason
                        {
                            DisplayName = "Использование читов",
                            Command = "ban {0} soft",
                        },
                        new BanReason
                        {
                            DisplayName = "Макросы",
                            Command = "ban {0} 30d macros",
                        },
                        new BanReason
                        {
                            DisplayName = "Игра 3+",
                            Command = "ban {0} 14d 3+",
                        },
                        new BanReason
                        {
                            DisplayName = "Отказ",
                            Command = "ban {0} 7d otkaz",
                        },
                    },
                    RCCSetting = new RCCSettings
                    {
                        RCCUse = false,
                        Key = "xxxxxxxxxxxxxxRCCKey",
                    },
                    IQFakeActiveSettings = new IQFakeActive
                    {
                      UseIQFakeActive = false,
                    },
                    RaitingSetting = new RaitingSettings
                    {
                        RemoveAmountOneTwo = 4,
                        GiveAmountThreeFour = 3,
                        GiveAmountFive = 5
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Ошибка чтения конфигурации #93 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region Data
        public Dictionary<ulong, PlayerInfo> ReportInformation = new Dictionary<ulong, PlayerInfo>();
        public Dictionary<ulong, ModeratorInfo> ModeratorInformation = new Dictionary<ulong, ModeratorInfo>();
        public class PlayerInfo
        {
            [JsonProperty("Отображаемое имя")]
            public string DisplayName;
            [JsonProperty("IP Адреса")]
            public List<string> IP;
            [JsonProperty("Последняя жалоба")]
            public string LastReport;
            [JsonProperty("Последний проверяющий модератор")]
            public string LastCheckModerator;
            [JsonProperty("Количество проверок")]
            public int CheckCount;
            [JsonProperty("История жалоб")]
            public List<string> ReportHistory;
            [JsonProperty("Количество жалоб")]
            public int ReportCount;
            [JsonProperty("Игровой статус")]
            public string GameStatus;
        }

        public class ModeratorInfo
        {
            [JsonProperty("Проверки игроков с вердиктами")]
            public Dictionary<string, string> CheckPlayerModerator = new Dictionary<string, string>();
            [JsonProperty("Блокировки игроков с вердиктом")]
            public Dictionary<string, string> BanPlayerModerator = new Dictionary<string, string>();
            [JsonProperty("Общее количество проверок")]
            public int CheckCount;
            [JsonProperty("История оценок модератора")]
            public List<int> Arrayrating;
            [JsonProperty("Средняя оценка качества")]
            public float AverageRating;
        }
        #endregion

        #region Metods

        #region MetodsReport

        void Metods_PlayerConnected(BasePlayer player)
        {
            if (player == null)
                return;
            if (!ReportInformation.ContainsKey(player.userID))
            {
                PlayerInfo pInfo = new PlayerInfo
                {
                    DisplayName = player.displayName,
                    IP = new List<string>(),
                    LastReport = "",
                    LastCheckModerator = "",
                    CheckCount = 0,
                    ReportCount = 0,
                    GameStatus = IsSteam(player.UserIDString),
                    ReportHistory = new List<string>(),
                };
                ReportInformation.Add(player.userID, pInfo);
            }
            else
            {
                var User = ReportInformation[player.userID];
                var IP = covalence.Players.FindPlayerById(player.UserIDString).Address;

                User.GameStatus = IsSteam(player.UserIDString);
                if (!String.IsNullOrWhiteSpace(IP))
                    if (!User.IP.Contains(IP))
                        User.IP.Add(IP);
            }

            if (permission.UserHasPermission(player.UserIDString, PermissionModeration))
            {
                if (!ModeratorInformation.ContainsKey(player.userID))
                {
                    ModeratorInfo mInfo = new ModeratorInfo
                    {
                        CheckCount = 0,
                        BanPlayerModerator = new Dictionary<string, string>(),
                        CheckPlayerModerator = new Dictionary<string, string>(),
                        Arrayrating = new List<int>(),
                        AverageRating = 0,
                    };
                    ModeratorInformation.Add(player.userID, mInfo);
                }
            }
            else
            {
                if (ModeratorInformation.ContainsKey(player.userID))
                    ModeratorInformation.Remove(player.userID);
            }
            Metods_StatusNetwork(player, lang.GetMessage("NETWORD_STATUS_ONLINE", this, player.UserIDString));
        }

        void Metods_Report(BasePlayer target, int ReasonIndex)
        {
            if (permission.UserHasPermission(target.UserIDString, PermissionAdmin))
                return;

            if (IsSteam(target.UserIDString) == lang.GetMessage("IS_STEAM_STATUS_PIRATE", this, target.UserIDString))
            {
                if (GameWerAC != null)
                {
                    GameWerAC.Call("GetScreenReport", target);
                    Puts("Выполнен скриншот экрана для пирата");
                }
            }

            string ReasonReport = config.ReasonReport[ReasonIndex];

            var User = ReportInformation[target.userID];
            User.ReportCount++;
            User.LastReport = ReasonReport;
            User.ReportHistory.Insert(0, ReasonReport);

            if (config.Setting.MaxReportAlert)
                if (User.ReportCount >= config.Setting.MaxReport)
                {
                    foreach (var MList in BasePlayer.activePlayerList)
                        if (permission.UserHasPermission(MList.UserIDString, PermissionModeration))
                            SendChat(MList, String.Format(lang.GetMessage("METODS_HELP_MODERS", this, MList.UserIDString), target.displayName, User.ReportCount));
                    VKSendMessage(String.Format(lang.GetMessage("METODS_HELP_MODERS_VK", this), target.displayName, User.ReportCount));
                    DiscordSendMessage(String.Format(lang.GetMessage("METODS_HELP_MODERS_VK", this), target.displayName, User.ReportCount));
                }
        }

        #endregion

        #region MetodsCooldown
        void Metods_GiveCooldown(ulong ID,  int cooldown)
        {
            CooldownPC[ID] = cooldown + (int)CurrentTime();          
        }

        bool Metods_GetCooldown(ulong ID)
        {
            if (!CooldownPC.ContainsKey(ID) || Math.Max(0, CooldownPC[ID]) < 1 || CooldownPC[ID] <= (int)CurrentTime())
                return false;
            else return true;
        }

        #endregion

        #region MetodsModeration

        void Metods_CheckModeration(BasePlayer Suspect, BasePlayer Moderator)
        {
            if (PlayerSaveCheck.ContainsKey(Suspect.userID))
            {
                SendChat(Moderator, lang.GetMessage("PLAYER_CHECKED", this));
                return;
            }
            else PlayerSaveCheck.Add(Suspect.userID, new PlayerSaveCheckClass {  });
            SendChat(Moderator, String.Format(lang.GetMessage("METODS_MODER_START_CHECK",this, Moderator.UserIDString),Suspect.displayName));
            VKSendMessage(String.Format(lang.GetMessage("METODS_MODER_START_CHECK_VK", this),Moderator.displayName,Moderator.UserIDString,Suspect.displayName,Suspect.UserIDString));           
            Metods_AFK(Suspect.userID, Moderator);

            if(config.Setting.UseAlertUsers)
                foreach(var p in BasePlayer.activePlayerList)
                    SendChat(p, String.Format(lang.GetMessage("METODS_MODER_START_CHECK_VK", this, p.UserIDString), Moderator.displayName, Moderator.UserIDString, Suspect.displayName, Suspect.UserIDString));
        }

        void Metods_CheckModerationFinish(BasePlayer moderator, ulong SuspectID)
        {
            IPlayer Suspect = covalence.Players.FindPlayerById(SuspectID.ToString());
            if (Suspect.IsConnected)
            {
                BasePlayer SOnline = BasePlayer.FindByID(ulong.Parse(Suspect.Id));
                CuiHelper.DestroyUi(SOnline, PARENT_UI_ALERT_SEND);
                SendChat(SOnline, lang.GetMessage("MSG_CHECK_CHECK_STOP", this, moderator.UserIDString));
            }

            CuiHelper.DestroyUi(moderator, PARENT_UI_MODERATOR_MINI_PANEL);
            PlayerSaveCheck.Remove(ulong.Parse(Suspect.Id));

            var User = ReportInformation[ulong.Parse(Suspect.Id)];
            var Moderator = ModeratorInformation[moderator.userID];

            Moderator.CheckCount++;
            if (!Moderator.CheckPlayerModerator.ContainsKey(Suspect.Name))
                Moderator.CheckPlayerModerator.Add(Suspect.Name, User.LastReport);

            User.ReportCount = 0;
            User.ReportHistory.Clear();
            User.LastReport = lang.GetMessage("NON_REPORT",this);
            User.CheckCount++;
            User.LastCheckModerator = moderator.displayName;

            SendChat(moderator, lang.GetMessage("METODS_MODER_STOP_CHECK",this, moderator.UserIDString));
            VKSendMessage(String.Format(lang.GetMessage("METODS_MODER_STOP_CHECK_VK",this),moderator.displayName));
            DiscordSendMessage(String.Format(lang.GetMessage("METODS_MODER_STOP_CHECK_VK",this),moderator.displayName));
            SetCheck(moderator);

            if (config.Setting.UseAlertUsers)
                foreach (var p in BasePlayer.activePlayerList)
                    SendChat(p, String.Format(lang.GetMessage("METODS_MODER_STOP_CHECK_ALERT", this, p.UserIDString), moderator.displayName, Suspect.Name));
        }

        void Metods_StatusNetwork(BasePlayer Suspect, string Reason)
        {
            if (Suspect == null) return;
            if (PlayerSaveCheck.ContainsKey(Suspect.userID))
            {
                if (Suspect.IsConnected)
                    if (Suspect.IsReceivingSnapshot)
                    {
                        timer.Once(3, () => Metods_StatusNetwork(Suspect, lang.GetMessage("NETWORD_STATUS_ONLINE", this, Suspect.UserIDString)));
                        return;
                    }

                PlayerSaveCheck[Suspect.userID].StatusNetwork = Reason;
                BasePlayer Moderator = BasePlayer.FindByID(PlayerSaveCheck[Suspect.userID].ModeratorID);

                CuiHelper.DestroyUi(Moderator, UI_MODERATION_CHECK_MENU_NETWORK);
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.6782616 0.5478261", AnchorMax = "0.9884076 0.7333333" },
                    Text = { Text = $"{PlayerSaveCheck[Suspect.userID].StatusNetwork}", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.UpperCenter, Color = HexToRustFormat("#FFFFFFFF") }
                }, PARENT_UI_MODERATOR_MINI_PANEL, UI_MODERATION_CHECK_MENU_NETWORK);

                CuiHelper.AddUi(Moderator, container);
                UI_AlertSendPlayer(Suspect);             

                SendChat(Moderator, String.Format(lang.GetMessage("STATUS_CHANGED", this, Moderator.UserIDString), Suspect.displayName, Reason));
                VKSendMessage(String.Format(lang.GetMessage("STATUS_CHANGED_VK", this), Suspect.displayName, Reason));
                DiscordSendMessage(String.Format(lang.GetMessage("STATUS_CHANGED_VK", this), Suspect.displayName, Reason));
            }
        }

        public Timer ModerTimeOutTimer;
        void Metods_ModeratorExitCheck(BasePlayer Moderator)
        {
            foreach (var ModeratorCritical in PlayerSaveCheck)
                if (ModeratorCritical.Value.ModeratorID == Moderator.userID)
                {
                    IPlayer ModeratorOffline = covalence.Players.FindPlayerById(ModeratorCritical.Value.ModeratorID.ToString());
                    IPlayer Suspect = covalence.Players.FindPlayerById(ModeratorCritical.Key.ToString());
                    int TimeOutCount = 0;
                    ModerTimeOutTimer = timer.Repeat(5, 10, () =>
                        {
                            if (ModeratorOffline.IsConnected)
                            {
                                UI_MiniPanelModerator(Moderator, ModeratorCritical.Key);
                                SendChat(Moderator, lang.GetMessage("MODERATOR_RETURN_WELCOME",this, Moderator.UserIDString));
                                if (ModerTimeOutTimer != null)
                                {
                                    ModerTimeOutTimer.Destroy();
                                    ModerTimeOutTimer = null;
                                }
                                return;
                            }
                            else
                            {
                                TimeOutCount++;
                                if (TimeOutCount >= 10)
                                {
                                    PlayerSaveCheck.Remove(ModeratorCritical.Key);

                                    foreach (var OnlineModeration in BasePlayer.activePlayerList)
                                        if (permission.UserHasPermission(OnlineModeration.UserIDString, PermissionModeration))
                                            if (Suspect.IsConnected)
                                            {                                             
                                                BasePlayer SOnline = BasePlayer.FindByID(ulong.Parse(Suspect.Id));
                                                CuiHelper.DestroyUi(SOnline, PARENT_UI_ALERT_SEND);
                                           
                                                SendChat(SOnline, String.Format(lang.GetMessage("MODERATOR_DISCONNECTED_STOP_CHECK",this, Moderator.UserIDString),ModeratorOffline.Name));
                                                SendChat(OnlineModeration, String.Format(lang.GetMessage("MODERATOR_DISCONNECTED_STOP_RESEND",this, Moderator.UserIDString),ModeratorOffline.Name,Suspect.Name));
                                                VKSendMessage(String.Format(lang.GetMessage("MODERATOR_DISCONNECTED_STOP_RESEND", this), ModeratorOffline.Name, Suspect.Name));
                                                DiscordSendMessage(String.Format(lang.GetMessage("MODERATOR_DISCONNECTED_STOP_RESEND", this), ModeratorOffline.Name, Suspect.Name));

                                                if (ModerTimeOutTimer != null)
                                                {
                                                    ModerTimeOutTimer.Destroy();
                                                    ModerTimeOutTimer = null;
                                                }
                                            }
                                    return;
                                }
                            }
                        });

                }
        }

        void Metods_ModeratorBanned(BasePlayer Moderator,ulong SuspectID, int i)
        {
            CuiHelper.DestroyUi(Moderator, PARENT_UI_MODERATOR_MINI_PANEL);
            IPlayer Suspect = covalence.Players.FindPlayerById(SuspectID.ToString());
            string Reason = config.ReasonBan[i].DisplayName;

            rust.RunClientCommand(Moderator, String.Format(config.ReasonBan[i].Command, SuspectID));
            PlayerSaveCheck.Remove(SuspectID);

            var ModeratorInfo = ModeratorInformation[Moderator.userID];
            ModeratorInfo.CheckCount++;
            if (!ModeratorInfo.CheckPlayerModerator.ContainsKey(Suspect.Name))
                ModeratorInfo.CheckPlayerModerator.Add(Suspect.Name, Reason);
            if (!ModeratorInfo.BanPlayerModerator.ContainsKey(Suspect.Name))
                ModeratorInfo.BanPlayerModerator.Add(Suspect.Name, Reason);

            SendChat(Moderator, String.Format(lang.GetMessage("MODERATOR_COMPLETED_CHECK", this, Moderator.UserIDString), Reason));
            VKSendMessage(String.Format(lang.GetMessage("MODERATOR_COMPLETED_CHECK_VK", this), Moderator.displayName, Moderator.UserIDString, Suspect.Name, SuspectID, Reason, AFKCheck[SuspectID]));
            DiscordSendMessage(String.Format(lang.GetMessage("MODERATOR_COMPLETED_CHECK_VK", this), Moderator.displayName, Moderator.UserIDString, Suspect.Name, SuspectID, Reason, AFKCheck[SuspectID]));
            SetBans(Moderator);

            if (config.Setting.UseAlertUsers)
                foreach (var p in BasePlayer.activePlayerList)
                    SendChat(p, String.Format(lang.GetMessage("MODERATOR_COMPLETED_CHECK_ALERT", this, p.UserIDString), Moderator.displayName, Suspect.Name, Reason));
        }

        #endregion

        #region MetodsAFK
        void Metods_CheckStopInAFK(BasePlayer moderator, string ID)
        {
            IPlayer Suspect = covalence.Players.FindPlayerById(ID);
            if (Suspect.IsConnected)
            {
                BasePlayer SOnline = BasePlayer.FindByID(ulong.Parse(Suspect.Id));
                CuiHelper.DestroyUi(SOnline, PARENT_UI_ALERT_SEND);
            }
            CuiHelper.DestroyUi(moderator, PARENT_UI_MODERATOR_MINI_PANEL);
            PlayerSaveCheck.Remove(ulong.Parse(Suspect.Id));

            SendChat(moderator, lang.GetMessage("PLAYER_AFK_CHECK_STOP",this));
            VKSendMessage(String.Format(lang.GetMessage("PLAYER_AFK_CHECK_STOP_VK", this), moderator.displayName, moderator.userID, Suspect.Name));
            DiscordSendMessage(String.Format(lang.GetMessage("PLAYER_AFK_CHECK_STOP_VK", this), moderator.displayName, moderator.userID, Suspect.Name));
        }

        public Dictionary<ulong,int> AFKCheck = new Dictionary<ulong, int>();
        void Metods_AFK(ulong SuspectID, BasePlayer moderator)
        {
            IPlayer Suspect = covalence.Players.FindPlayerById(SuspectID.ToString());
            if (!AFKCheck.ContainsKey(SuspectID))
                AFKCheck.Add(SuspectID, 0);
            else AFKCheck[SuspectID] = 0;

            int tryAFK = 0;
            SavePositionAFK(Suspect, moderator, tryAFK);
            timer.Repeat(5f, 6, () =>
            {
                SavePositionAFK(Suspect, moderator,tryAFK);
                tryAFK++;
            });
        }

        readonly Hash<string, GenericPosition> lastPosition = new Hash<string, GenericPosition>();
        void SavePositionAFK(IPlayer Suspect, BasePlayer moderator, int num)
        {
            var pPosition = Suspect.Position();
            if (!lastPosition.ContainsKey(Suspect.Id))
                lastPosition.Add(Suspect.Id, pPosition);
            else
            {
                if (lastPosition[Suspect.Id] != pPosition)
                    SendChat(moderator, String.Format(lang.GetMessage("PLAYER_AFK_CHANGE_POS",this, moderator.UserIDString),num));
                else
                {
                    SendChat(moderator, String.Format(lang.GetMessage("PLAYER_AFK_CHANGE_NO_POS", this, moderator.UserIDString), num));
                    AFKCheck[ulong.Parse(Suspect.Id)] += 1;
                }
                lastPosition[Suspect.Id] = pPosition;
            }

            if (num >= 5)
            {
                if (AFKCheck[ulong.Parse(Suspect.Id)] >= 3)
                    Metods_CheckStopInAFK(moderator, Suspect.Id);
                else
                {
                    BasePlayer SuspectOnline = BasePlayer.FindByID(ulong.Parse(Suspect.Id));
                    UI_AlertSendPlayer(SuspectOnline);
                    PlayerSaveCheck = new Dictionary<ulong, PlayerSaveCheckClass>
                    {
                        [SuspectOnline.userID] = new PlayerSaveCheckClass
                        {
                            Discord = lang.GetMessage("DISCORD_NULL",this),
                            NickName = SuspectOnline.displayName,
                            StatusNetwork = lang.GetMessage("NETWORD_STATUS_ONLINE", this, SuspectOnline.UserIDString),

                            ModeratorID = moderator.userID,
                        }
                    };
                    UI_MiniPanelModerator(moderator, SuspectOnline.userID);
                    SendChat(moderator, lang.GetMessage("PLAYER_NON_AFK", this, moderator.UserIDString));
                    
                    if(config.RCCSetting.RCCUse)
                    {
                        string Key = config.RCCSetting.Key;
                        if (String.IsNullOrEmpty(Key)) return;
                        try
                        {
                            string API = $"https://rustcheatcheck.ru/panel/api?action=addPlayer&key={Key}&player={Suspect.Id}";
                            webrequest.Enqueue(API, null, (code, response) => { }, this);
                        }
                        catch { }
                    }
                }
            }
        }

        #endregion

        #endregion

        #region Command

        #region UseCommand
        [ChatCommand("report")]
        void ReportChatCommand(BasePlayer player, string command, string[] args)
        {
            if (player == null)
                return;

            if (args == null || args.Length == 0)
            {
                rust.RunClientCommand(player, "custommenu true Report");
                return;
            }
        }

        [ConsoleCommand("report.list")]
        void ReportList(ConsoleSystem.Arg arg)
        {
            PrintError(lang.GetMessage("REPORT_LIST_CONSOLE",this));
            foreach (var List in BasePlayer.activePlayerList)
                if (ReportInformation[List.userID].ReportCount >= config.Setting.MaxReport)
                    PrintError($"{List.displayName} : {ReportInformation[List.userID].ReportCount}");

        }

        [ChatCommand("discord")]
        void SendDiscord(BasePlayer Suspect, string command, string[] args)
        {
            if (!PlayerSaveCheck.ContainsKey(Suspect.userID))
            {
                SendChat(Suspect, lang.GetMessage("MSG_CHECK_DISCORD", this, Suspect.UserIDString));
                return;
            }
            string Discord = "";
            foreach (var arg in args)
                Discord += " " + arg;

            PlayerSaveCheck[Suspect.userID].Discord = Discord;

            SendChat(Suspect, String.Format(lang.GetMessage("MSG_DISCORD_SEND", this, Suspect.UserIDString),Discord));
            VKSendMessage(String.Format(lang.GetMessage("DISCROD_VK_SEND", this), Suspect.displayName, Suspect.userID, Discord));
            DiscordSendMessage(String.Format(lang.GetMessage("DISCROD_VK_SEND", this), Suspect.displayName, Suspect.userID, Discord));

            BasePlayer Moderator = BasePlayer.FindByID(PlayerSaveCheck[Suspect.userID].ModeratorID);
            CuiHelper.DestroyUi(Moderator, UI_MODERATION_CHECK_MENU_DISCORD);
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.01159436 0.5478261", AnchorMax = "0.7072465 0.7333333" },
                Text = { Text = $"Discord : {PlayerSaveCheck[Suspect.userID].Discord}", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.UpperCenter, Color = HexToRustFormat("#FFFFFFFF") }
            }, PARENT_UI_MODERATOR_MINI_PANEL, UI_MODERATION_CHECK_MENU_DISCORD);

            CuiHelper.AddUi(Moderator, container);
        }
       
        [ConsoleCommand("call")]
        void CallAdminCheck(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (!player.IsAdmin) return;
            ulong SuspectID = ulong.Parse(arg.Args[0]);
            if(player == null)
            {
                PrintWarning("Вы должны быть на сервере");
                SendChat(player, "Вы должны быть на сервере");
                return;
            }
            BasePlayer Suspect = BasePlayer.FindByID(SuspectID);
            if(Suspect == null)
            {
                PrintWarning("Игрока нет");
                SendChat(player, "Игрока нет");
                return;
            }
            Metods_CheckModeration(Suspect, player);
            Puts("Вы вызвали игрока на проверку"); 
            SendChat(player, "Вы вызвали игрока на проверку");
        }

        [ConsoleCommand("report")]
        void ReportCommand(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();

            if (arg == null || arg.Args == null || arg.Args.Length == 0)
            {
                if (player == null) return;
                rust.RunClientCommand(player, "custommenu true Report");
                return;
            }

            switch (arg.Args[0].ToLower())
            {
                case "give":
                    {
                        if (arg.Args.Length != 3)
                        {
                            PrintWarning("Используйте правильный синтаксис : report give SteamID Amount");
                            return;
                        }
                        if (string.IsNullOrWhiteSpace(arg.Args[1]))
                        {
                            PrintWarning("Укажите корректный Steam64ID");
                            return;
                        }
                        if (!arg.Args[1].IsSteamId())
                        {
                            PrintWarning("Укажите корректный Steam64ID");
                            return;
                        }
                        if (string.IsNullOrWhiteSpace(arg.Args[2]))
                        {
                            PrintWarning("Укажите корректное количество");
                            return;
                        }

                        ReportInformation[ulong.Parse(arg.Args[1])].ReportCount += Convert.ToInt32(arg.Args[2]);
                        if (player != null)
                        {
                            VKSendMessage(String.Format(lang.GetMessage("CONSOLE_REPORT_GIVE", this), arg.Args[1], arg.Args[2], ReportInformation[ulong.Parse(arg.Args[1])].ReportCount));
                            DiscordSendMessage(String.Format(lang.GetMessage("CONSOLE_REPORT_GIVE", this), arg.Args[1], arg.Args[2], ReportInformation[ulong.Parse(arg.Args[1])].ReportCount));
                        }
                        PrintWarning("ACCESS");
                        return;
                    }
                case "remove":
                    {
                        if (arg.Args.Length != 3)
                        {
                            PrintWarning("Используйте правильный синтаксис : report remove SteamID Amount");
                            return;
                        }
                        if (string.IsNullOrWhiteSpace(arg.Args[1]))
                        {
                            PrintWarning("Укажите корректный Steam64ID");
                            return;
                        }
                        if (!arg.Args[1].IsSteamId())
                        {
                            PrintWarning("Укажите корректный Steam64ID");
                            return;
                        }
                        if (string.IsNullOrWhiteSpace(arg.Args[2]))
                        {
                            PrintWarning("Укажите корректное количество");
                            return;
                        }
                        ReportInformation[ulong.Parse(arg.Args[1])].ReportCount -= Convert.ToInt32(arg.Args[2]);
                        if (player != null)
                        {
                            VKSendMessage(String.Format(lang.GetMessage("CONSOLE_REPORT_REMOVE", this), arg.Args[1], arg.Args[2], ReportInformation[ulong.Parse(arg.Args[1])].ReportCount));
                        }
                        PrintWarning("ACCESS");
                        return;
                    }
            }
        }

        #endregion

        #region FuncCommand
        [ConsoleCommand("iqreport")]
        void IQReportSystemCommands(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            string Key = arg.Args[0].ToLower();

            switch (Key)
            {
                case "page":
                    {
                        string PageAction = arg.Args[1];
                        bool Moderation = Convert.ToBoolean(arg.Args[2]);
                        int Page = Convert.ToInt32(arg.Args[3]);
                        switch (PageAction)
                        {
                            case "next":
                                {
                                    UI_Player_Loaded(player, Moderation, Page + 1);
                                    break;
                                }
                            case "back":
                                {
                                    UI_Player_Loaded(player, Moderation, Page - 1);
                                    break;
                                }
                        }
                        break;
                    };
                case "moderation_menu":
                    {
                        UI_PanelReportsPlayer(player, true);
                        break;
                    };
                case "reports_menu":
                    {
                        //  int BaseID = int.Parse(arg.Args[1]);
                        
                        ulong UserID = ulong.Parse(arg.Args[1]);
                        UI_SendReport(player, UserID);
                        break;
                    }
                case "moderation_send":
                    {
                        ulong SuspectID = ulong.Parse(arg.Args[1]);
                        BasePlayer Suspect = BasePlayer.FindByID(SuspectID);

                        UI_ModerReport(player, Suspect);
                        break;
                    }
                case "send_report":
                    {
                        ulong SuspectID = ulong.Parse(arg.Args[1]);
                        int IndexReason = Convert.ToInt32(arg.Args[2]);
                        string ReasonReport = config.ReasonReport[IndexReason];

                        if (player == null) return;
                        

                        if (Metods_GetCooldown(player.userID) == true)
                        {
                            SendChat(player, String.Format(lang.GetMessage("MSG_COOLDOWN", this, player.UserIDString), FormatTime(TimeSpan.FromSeconds(Math.Max(0, CooldownPC[player.userID] - CurrentTime())))));
                            CuiHelper.DestroyUi(player, "XMenu");
                            return;
                        }
                        
                        if(IsFake(SuspectID))
                        {
                            Metods_GiveCooldown(player.userID, config.Setting.CooldownTime);
                            SendChat(player, String.Format(lang.GetMessage("MSG_REPORTED_SUSPECT", this, player.UserIDString), FindFakeName(SuspectID), ReasonReport));
                            CuiHelper.DestroyUi(player, "XMenu");
                            return;
                        }
                        BasePlayer Suspect = BasePlayer.FindByID(SuspectID);
                        if (Suspect == null) return;

                        Metods_Report(Suspect, IndexReason);
                        Metods_GiveCooldown(player.userID, config.Setting.CooldownTime);
                        SendChat(player, String.Format(lang.GetMessage("MSG_REPORTED_SUSPECT", this, player.UserIDString), Suspect.displayName, ReasonReport));
                        VKSendMessage(String.Format(lang.GetMessage("METODS_SEND_REPORT_VK", this), Suspect.displayName, Suspect.UserIDString, ReasonReport, player.displayName, player.userID));
                        DiscordSendMessage(String.Format(lang.GetMessage("METODS_SEND_REPORT_VK", this), Suspect.displayName, Suspect.UserIDString, ReasonReport, player.displayName, player.userID));
                        CuiHelper.DestroyUi(player, "XMenu");
                        break;
                    }
                case "search":
                    {
                        if (arg.Args.Length != 4) return;

                        bool Moderation = Convert.ToBoolean(arg.Args[1]);
                        int Page = Convert.ToInt32(arg.Args[2]);
                        string SearchSay = arg.Args[3];

                        UI_Player_Loaded(player, Moderation, Page, SearchSay);
                        break;
                    }
                case "send_check":
                    {
                        if (player == null) return;
                        ulong SuspectID = ulong.Parse(arg.Args[1]);
                        BasePlayer Suspect = BasePlayer.FindByID(SuspectID);
                        if (permission.UserHasPermission(player.UserIDString, PermissionModeration))
                            Metods_CheckModeration(Suspect, player);

                        break;
                    }
                case "moderator_reason_ban":
                    {
                        if (player == null) return;
                        ulong SuspectID = ulong.Parse(arg.Args[1]);
                        BasePlayer Suspect = BasePlayer.FindByID(SuspectID);
                        if (permission.UserHasPermission(player.UserIDString, PermissionModeration))
                            UI_OpenReasonsBan(player, SuspectID);
                        break;
                    }
                case "moderator_ban":
                    {
                        if (player == null) return;
                        ulong SuspectID = ulong.Parse(arg.Args[1]);
                        BasePlayer Suspect = BasePlayer.FindByID(SuspectID);
                        int Index = Convert.ToInt32(arg.Args[2]);
                        Metods_ModeratorBanned(player, SuspectID, Index);
                        break;
                    }
                case "moderator_stop":
                    {
                        if (player == null) return;
                        ulong SuspectID = ulong.Parse(arg.Args[1]);
                        BasePlayer Suspect = BasePlayer.FindByID(SuspectID);
                        if (permission.UserHasPermission(player.UserIDString, PermissionModeration))
                            Metods_CheckModerationFinish(player, SuspectID);
                        UI_RaitingSend(Suspect, player);
                        return;
                    }
                case "raiting": 
                    {
                        BasePlayer Moderator = BasePlayer.FindByID(ulong.Parse(arg.Args[1]));
                        int Raiting = Convert.ToInt32(arg.Args[2]);
                        var RaitingModerator = ModeratorInformation[Moderator.userID].Arrayrating;

                        VKSendMessage(String.Format(lang.GetMessage("UI_RAITING_MODERATION_VK_GIVE", this), player.displayName, player.UserIDString, Moderator.displayName, Moderator.UserIDString, Raiting));
                        DiscordSendMessage(String.Format(lang.GetMessage("UI_RAITING_MODERATION_VK_GIVE", this), player.displayName, player.UserIDString, Moderator.displayName, Moderator.UserIDString, Raiting));
                        SendChat(player, lang.GetMessage("UI_RAITING_MODERATION_VK_GIVE_THX", this, player.UserIDString));

                        RaitingModerator.Add(Raiting);

                        if (Raiting <= 2)
                        {
                            RemoveScore(Moderator.userID, config.RaitingSetting.RemoveAmountOneTwo);
                            SendChat(Moderator, String.Format(lang.GetMessage("UI_RAIT_ALERT_MODER", this, Moderator.UserIDString), Raiting, $"-{config.RaitingSetting.RemoveAmountOneTwo}"));
                            return;
                        }
                        if (Raiting > 2 && Raiting < 5)
                        {
                            SetScore(Moderator.userID, config.RaitingSetting.GiveAmountThreeFour);
                            SendChat(Moderator, String.Format(lang.GetMessage("UI_RAIT_ALERT_MODER", this, Moderator.UserIDString), Raiting, $"{config.RaitingSetting.GiveAmountThreeFour}"));
                            return;
                        }
                        if (Raiting >= 5)
                        {
                            SetScore(Moderator.userID, config.RaitingSetting.GiveAmountFive);
                            SendChat(Moderator, String.Format(lang.GetMessage("UI_RAIT_ALERT_MODER", this, Moderator.UserIDString), Raiting, $"{config.RaitingSetting.GiveAmountFive}"));
                            return;
                        }
                        break;
                    }
            }
        }
        #endregion

        public float GetAverageRaiting(ulong userID)
        {
            var Data = ModeratorInformation[userID];
            float AverageRaiting = Data.AverageRating;
            int RaitingFull = 0;
            for(int i = 0; i < Data.Arrayrating.Count; i++)
                RaitingFull += Data.Arrayrating[i];

            int FormulDivision = Data.Arrayrating.Count == 0 ? 1 : Data.Arrayrating.Count;
            AverageRaiting = RaitingFull / FormulDivision;
            return AverageRaiting;
        }

        #endregion

        #region Lang
        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["PLAYER_CHECKED"] = "The player had already check!",

                ["MSG_REPORTED_SUSPECT"] = "You have successfully submitted a player report - {0}\nReported : {1}\nThe moderator will review your complaint as soon as possible!",
                ["MSG_CHECK_DISCORD"] = "You can't send Discord without checking!",
                ["MSG_CHECK_CHECK_STOP"] = "You have successfully passed the test!\nWe wish you a pleasant game on our server!",
                ["MSG_COOLDOWN"] = "You have recently sent a complaint!\nWait <color=#47AF5DFF>{0}</color>",
                ["MSG_DISCORD_SEND"] = "You have successfully submitted the information!\nDiscord - {0}\nExpect a call from the moderator",

                ["UI_MODERATOR_PANEL_TITLE"] = "Server moderator menu",
                ["UI_MODERATOR_PANEL_DESCRIPTION"] = "This list shows players who have reached the limit of complaints,click on the player to get more information",
                ["UI_MODERATOR_PANEL_START_CHECK"] = "Call for verification",
                ["UI_STATUS"] = "Status",

                ["NETWORD_STATUS_ONLINE"] = "Online",
                ["IS_STEAM_STATUS_PIRATE"] = "Pirate",
                ["IS_STEAM_STATUS_LICENSE"] = "License",

                ["METODS_SEND_REPORT_VK"] = "[IQReportSystem]\nA complaint has been sent to player {0} ({1})!\nComplaint - {2}\nReporter : {3}({4})",
                ["METODS_HELP_MODERS"] = "Player <color=#47AF5DFF>{0}</color> reached the limit of reports!\nThe number of his reports - <color=#47AF5DFF>{1}</color>\nModeration that is free - check the player!",
                ["METODS_HELP_MODERS_VK"] = "[IQReportSystem]\nPlayer {0} reached the limit of reports!\nThe number of his reports - {1}\nModeration that is free - check the player!",
                ["METODS_MODER_START_CHECK"] = "You started checking!\nSuspect - <color=#47AF5DFF>{0}</color>\nGetting started with AFK!\nIf the player is not AFK, they will receive a notification of verification!",
                ["METODS_MODER_START_CHECK_VK"] = "[IQReportSystem]\nModerator {0}({1}) started checking!\nSuspect - {2}({3})",
                ["METODS_MODER_STOP_CHECK"] = "Verification completed.\nHave a nice day!\nDo not forget to check the complaint list!",
                ["METODS_MODER_STOP_CHECK_VK"] = "[IQReportSystem]\nModerator {0} finished checking!",
                ["METODS_MODER_STOP_CHECK_ALERT"] = "Moderator {0} has finished Player check - {1}\nNo illegal found",

                ["NON_REPORT"] = "No complaints",
                ["MODERATOR_RETURN_WELCOME"] = "Welcome back!\nthe check was not canceled, continue!",
                ["STATUS_CHANGED"] = "The player's {0} status has changed to: {1}\n Wait for the player on the server for 10 minutes!\nIf the player does not enter after 10 minutes-issue a ban for Refusal",
                ["STATUS_CHANGED_VK"] = "[IQReportSystem]The player's {0} status has changed to: {1}\n Wait for the player on the server for 10 minutes!\nIf the player does not enter after 10 minutes-issue a ban for Refusal",
                ["MODERATOR_DISCONNECTED_STOP_CHECK"] = "The check was removed!\nModerator {0} left the server\nReason: connection Failure\nWe apologize!\nWe will inform the other moderation!",
                ["MODERATOR_DISCONNECTED_STOP_RESEND"] = "Moderator {0} finally left the server during verification!\n Player {1} is waiting for other moderators to check!",
                ["MODERATOR_COMPLETED_CHECK"] = "You successfully completed the review and delivered your verdict\nYour verdict : {0}",
                ["MODERATOR_COMPLETED_CHECK_ALERT"] = "Moderator {0} successfully completed the review  {1}\nVerdict: {2}",
                ["MODERATOR_COMPLETED_CHECK_VK"] = "[[IQ Report System]\nModerator {0}[(1)] finished checking \nSuspect {2}[{3}]\nVerdict : {4}\n[AFK Check]Player didn't move : {5}/5",
                ["PLAYER_AFK_CHECK_STOP"] = "Suspect AFK\nThe check is removed automatically!",
                ["PLAYER_AFK_CHECK_STOP_VK"] = "[IQReportSystem]\nModerator {0}({1}) checking the player {2}.\nThe AFK suspect and the check was removed!",
                ["PLAYER_AFK_CHANGE_POS"] = "The player was moving! Check {0}/5",
                ["PLAYER_AFK_CHANGE_NO_POS"] = "The player didn't move! Check {0}/5",
                ["PLAYER_NON_AFK"] = "The player moves.\nProverite on!",
                ["DISCORD_NULL"] = "Not provided",
                ["REPORT_LIST_CONSOLE"] = "\n[IQReportSystem]:\nList of players in the Moderation Panel",
                ["DISCROD_VK_SEND"] = "[IQReportSystem]\nSuspect {0}({1}) provided Discord for verification!\nDiscord - {2}",
                ["CONSOLE_REPORT_GIVE"] = "Player {0} is successfully added to the report in the amount of {1}. Its number is - {2}",
                ["CONSOLE_REPORT_REMOVE"] = "Player {0} successfully removed reports in the amount of - {1} His number is - {2}",
                ["MODERATOR_NON_OPEN_MENU"] = "You can't open the moderator menu when checking a player!\nFinish checking!",
                ["UI_RAITING_MODERATION_VK_GIVE"] = "[IQReportSystem]:\nPlayer {0}({1}) rated the work of moderator {2}({3}) on {4} stars",
                ["UI_RAITING_MODERATION_VK_GIVE_THX"] = "Thx!",
                ["UI_RAIT_ALERT_MODER"] = "Your work has been rated with {0} stars. You gain {1} reputation.",

                ["UI_NEW_CHECKED_COUNT"] = "<size=14>CHECKED: {0}</size>",
                ["UI_NEW_CLOSE"] = "<size=24><b>CLOSE</b></size>",

                ["UI_NEW_MODERATION_TITLE_PANEL"] = "<size=18>PANEL MODERATION</size>",
                ["UI_NEW_MODERATION_REPORT_BTN"] = "<size=20><b>REPORTS</b></size>",

                ["UI_NEW_MODERATION_TITLE_STATS"] = "<size=18><b>CHECK STATISTICS</b></size>",
                ["UI_NEW_MODERATION_STATS_COUNTCHECK"] = "<size=8>NUMBER OF CHECKS: {0}</size>",
                ["UI_NEW_MODERATION_STATS_COUNTBANS"] = "<size=8>BLOCKEDS: {0}</size>",
                ["UI_NEW_MODERATION_STATS_STARS"] = "<size=15><b>QUALITY CONTROL : {0}</b></size>",

                ["UI_NEW_MODERATION_REPORT_PANEL_TITLE"] = "<size=70><b>REPORTS</b></size>",
                ["UI_NEW_MODERATION_REPORT_PANEL_DESCRIPTION"] = "<size=8>CHOOSE A PLAYER TO SEND TO IT'S COMPLAINT</size>",
                ["UI_NEW_MODERATION_REPORT_PANEL_SEARCH_DESCRIPTION"] = "<size=14>ENTER NICK OR STEAM64ID TO SEARCH A PLAYER</size>",
                ["UI_NEW_MODERATION_REPORT_PANEL_DESCRIPTION_MODERATOR"] = "<size=8>SELECT A PLAYER IN THE PANEL TO START A CHECK</size>",
                ["UI_NEW_MODERATION_REPORT_PANEL_SEARCH_TITLE"] = "<size=50><b>SEARCH</b></size>",

                ["UI_NEW_MODERATION_REPORT_PANEL_PLAYER_REPORTEDS"] = "<size=14><b>REPORTS : {0}</b></size>",

                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_TITLE"] = "<size=30><b>COMPLAINT INFORMATION</b></size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_DESC"] = "<size=8>CHOOSE THE REASON FOR THE PLAYER COMPLAINT</size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_TITLE"] = "<size=25><b>PLAYER</b></size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_CLOSE"] = "<size=18><b>CLOSE</b></size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_LIST"] = "<size=20><b>CHOOSE THE REASON FROM THE LIST</b></size>",


                ["UI_NEW_MODERATION_MODER_GO_CHECK_TITLE"] = "<size=30><b>PLAYER INFORMATION</b></size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_DESC"] = "<size=8>CHOOSE ACTION WHICH YOU WANT TO PERFORM</size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_TITLE"] = "<size=25><b>DETAILED INFORMATION</b></size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_HISTORY_REPORT"] = "<size=18>HISTORY OF COMPLAINTS</size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_HISTORY_RCC"] = "<size=18>INFO RCC</size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_REPORTS"] = "<size=25><b>REPORTS</b></size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_LAST_CHECK"] = "<size=14>LAST CHECKER: {0}</size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_COUNT_CHECK"] = "<size=14>CHECK COUNTS: {0}</size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_GOCHECK"] = "<size=18>START</size>",

                ["UI_NEW_ALERT_PLAYER_WARNING"] = "<size=40><b>YOU CALLED TO THE TEST</b></size>",
                ["UI_NEW_ALERT_PLAYER_TITLE"] = "<size=18>You exceeded the maximum allowable number of complaints.\npoetomu,provide your ex, in order to be contacted by our moderation!\nPV case of ignoring this message, you will get a lock! (You have 5 minutes)</size>",
                ["UI_NEW_ALERT_PLAYER_DESC"] = "<size=15>to provide data for communication,use the commands:\n/discord\npdale you will be contacted by the moderator</size>",

                ["UI_NEW_MINI_PANEL_MODERATOR_TITLE"] = "<size=14><b>MENU MODERATOR</b></size>",
                ["UI_NEW_MINI_PANEL_MODERATOR_BAN"] = "<size=18><b>BAN</b></size>",
                ["UI_NEW_MINI_PANEL_MODERATOR_STOP"] = "<size=18><b>STOP</b></size>",

                ["UI_NEW_RAITING_PANEL"] = "<size=13><b>GIVE RAITING</b>></size>",

            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["PLAYER_CHECKED"] = "Данного игрока уже проверяют!",

                ["MSG_REPORTED_SUSPECT"] = "Вы успешно отправили жалобу на игрока - {0}\nЖалоба : {1}\nМодератор рассмотрит вашу жалобу как можно скорее!",
                ["MSG_CHECK_DISCORD"] = "Вы не можете отправить Discord без проверки!",
                ["MSG_CHECK_CHECK_STOP"] = "Вы успешно прошли проверку!\nЖелаем приятной игры на нашем сервере!",
                ["MSG_COOLDOWN"] = "Вы недавно отправляли жалобу!\nПодождите еще <color=#47AF5DFF>{0}</color>",
                ["MSG_DISCORD_SEND"] = "Вы успешно предоставили данные!\nDiscord - {0}\nОжидайте звонка от модератора",

                ["UI_MODERATOR_PANEL_TITLE"] = "Меню модератора сервера",
                ["UI_MODERATOR_PANEL_DESCRIPTION"] = "В данном списке отображены игроки - достигшие предела жалоб,нажмите по игроку чтобы получить больше информации",
                ["UI_MODERATOR_PANEL_START_CHECK"] = "Вызвать на проверку",
                ["UI_STATUS"] = "Статус",

                ["NETWORD_STATUS_ONLINE"] = "Онлайн",
                ["IS_STEAM_STATUS_PIRATE"] = "Пират",
                ["IS_STEAM_STATUS_LICENSE"] = "Лицензия", 

                ["METODS_SEND_REPORT_VK"] = "[IQReportSystem]\nНа игрока {0}({1}) отправили жалобу!\nЖалоба - {2}\nОтправил жалобу : {3}({4})",
                ["METODS_HELP_MODERS"] = "Игрок <color=#47AF5DFF>{0}</color> достиг предельного количества репортов!\nКоличество его репортов - <color=#47AF5DFF>{1}</color>\nМодерация которая свободна - проверьте игрока!",
                ["METODS_HELP_MODERS_VK"] = "[IQReportSystem]\nИгрок {0} достиг предельного количества репортов!\nКоличество его репортов - {1}\nМодерация которая свободна - проверьте игрока!",
                ["METODS_MODER_START_CHECK"] = "Вы начали проверку!\nПодозреваемый - <color=#47AF5DFF>{0}</color>\nНачинаем проверку на AFK!\nЕсли игрок не AFK - ему выведут уведомление о проверке!",
                ["METODS_MODER_START_CHECK_VK"] = "[IQReportSystem]\nМодератор {0}({1}) начал проверку!\nПодозреваемый - {2}({3})",
                ["METODS_MODER_STOP_CHECK"] = "Проверка завершена.\nУдачного дня!\nНе забывай проверять список жалоб!",
                ["METODS_MODER_STOP_CHECK_VK"] = "[IQReportSystem]\nМодератор {0} закончил проверку!",
                ["METODS_MODER_STOP_CHECK_ALERT"] = "Модератор {0} закончил проверку игрока - {1}\nЗапрещенного не обнаружено",
                ["NON_REPORT"] = "Жалоб нет",
                ["MODERATOR_RETURN_WELCOME"] = "С возвращением!\nПроверка не была отменена,продолжайте!",
                ["STATUS_CHANGED"] = "У игрока {0} изменился статус на : {1}\nОжидайте игрока на сервере в течении 10 минут!\nЕсли игрок не зайдет после 10 минут - выдавайте бан за Отказ",
                ["STATUS_CHANGED_VK"] = "[IQReportSystem]У игрока {0} изменился статус на : {1}\nОжидайте игрока на сервере в течении 10 минут!\nЕсли игрок не зайдет после 10 минут - выдавайте бан за Отказ",
                ["MODERATOR_DISCONNECTED_STOP_CHECK"] = "Проверка была снята!\nМодератор {0} покинул сервер\n Причина : Разрыв соединения\nПриносим свои извинения!\nМы сообщим другой модерации!",
                ["MODERATOR_DISCONNECTED_STOP_RESEND"] = "Модератор {0} окончательно покинул сервер во время проверки!\nИгрок {1} ожидает других модераторов для проверки!",
                ["MODERATOR_COMPLETED_CHECK"] = "Вы успешно завершили проверку и вынесли свой вердикт\nВаш вердикт : {0}",
                ["MODERATOR_COMPLETED_CHECK_ALERT"] = "Модератор {0} закончил проверку игрока {1}\nВердикт: {2}",
                ["MODERATOR_COMPLETED_CHECK_VK"] = "[IQReportSystem]\nМодератор {0}[(1)] закончил проверку\n Подозреваемый {2}[{3}]\nВердикт : {4}\n[Проверка на AFK]Игрок не двигался : {5}/5",
                ["PLAYER_AFK_CHECK_STOP"] = "Игрок AFK\nПроверка снята автоматически!",
                ["PLAYER_AFK_CHECK_STOP_VK"] = "[IQReportSystem]\nМодератор {0}({1}) проверял игрока {2}.\nИгрок AFK и проверка была снята!",
                ["PLAYER_AFK_CHANGE_POS"] = "Игрок двигался! Проверка {0}/5",
                ["PLAYER_AFK_CHANGE_NO_POS"] = "Игрок не двигался! Проверка {0}/5",
                ["PLAYER_NON_AFK"] = "Игрок двигается.\nПроверяйте дальше!",
                ["DISCORD_NULL"] = "Не предоставлен",
                ["REPORT_LIST_CONSOLE"] = "\n[IQReportSystem]:\nСписок игроков в Панели-Модерации",
                ["DISCROD_VK_SEND"] = "[IQReportSystem]\nИгрок {0}({1}) предоставил Discord на проверку!\nDiscord - {2}",
                ["CONSOLE_REPORT_GIVE"] = "Игроку {0} успешно добавлены репорты в количестве - {1}. Его количество составляет - {2}",
                ["CONSOLE_REPORT_REMOVE"] = "Игроку {0} успешно сняты репорты в количестве - {1} Его количество составляет - {2}",
                ["MODERATOR_NON_OPEN_MENU"] = "Вы не можете открыть меню модератора при проверке игрока!\nОкончите проверку!",
                ["UI_RAITING_MODERATION_VK_GIVE"] = "[IQReportSystem]:\nИгрок {0}({1}) оценил работу модератора {2}({3}) на {4} звезды",
                ["UI_RAITING_MODERATION_VK_GIVE_THX"] = "Спасибо за ваш отзыв!",
                ["UI_RAIT_ALERT_MODER"] = "Вашу работу оценили в {0} звезд(ы). Вы получаете {1} репутации",


                ["UI_NEW_CHECKED_COUNT"] = "<size=14>ПРОВЕРЕН: {0}</size>",
                ["UI_NEW_CLOSE"] = "<size=24><b>ЗАКРЫТЬ</b></size>",

                ["UI_NEW_MODERATION_TITLE_PANEL"] = "<size=18>ПАНЕЛЬ ПРОВЕРЯЮЩЕГО</size>",
                ["UI_NEW_MODERATION_REPORT_BTN"] = "<size=20><b>ЖАЛОБЫ</b></size>",

                ["UI_NEW_MODERATION_TITLE_STATS"] = "<size=18><b>СТАТИСТИКА ПРОВЕРЯЮЩЕГО</b></size>",
                ["UI_NEW_MODERATION_STATS_COUNTCHECK"] = "<size=8>КОЛИЧЕСТВО ПРОВЕРОК: {0}</size>",
                ["UI_NEW_MODERATION_STATS_COUNTBANS"] = "<size=8>БЛОКИРОВОК ВЫДАНО: {0}</size>",
                ["UI_NEW_MODERATION_STATS_STARS"] = "<size=15><b>ОЦЕНКА КАЧЕСТВА : {0}</b></size>",

                ["UI_NEW_MODERATION_REPORT_PANEL_TITLE"] = "<size=70><b>ЖАЛОБЫ</b></size>",
                ["UI_NEW_MODERATION_REPORT_PANEL_DESCRIPTION"] = "<size=8>ВЫБЕРИТЕ ИГРОКА ЧТОБЫ ОТПРАВИТЬ НА НЕГО ЖАЛОБУ</size>",
                ["UI_NEW_MODERATION_REPORT_PANEL_DESCRIPTION_MODERATOR"] = "<size=8>ВЫБЕРИТЕ ИГРОКА В ПАНЕЛИ ЧТОБЫ НАЧАТЬ ПРОВЕРКУ</size>",
                ["UI_NEW_MODERATION_REPORT_PANEL_SEARCH_DESCRIPTION"] = "<size=14>ВВЕДИТЕ НИК ИЛИ STEAM64ID ДЛЯ ПОИСКА ИГРОКА</size>",
                ["UI_NEW_MODERATION_REPORT_PANEL_SEARCH_TITLE"] = "<size=50><b>ПОИСК</b></size>",

                ["UI_NEW_MODERATION_REPORT_PANEL_PLAYER_REPORTEDS"] = "<size=14><b>ЖАЛОБЫ : {0}</b></size>",

                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_TITLE"] = "<size=30><b>ИНФОРМАЦИЯ О ЖАЛОБЕ</b></size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_DESC"] = "<size=8>ВЫБЕРИТЕ ПРИЧИНУ ДЛЯ ЖАЛОБЫ НА ИГРОКА</size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_TITLE"] = "<size=25><b>ИГРОК</b></size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_CLOSE"] = "<size=18><b>ЗАКРЫТЬ</b></size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_LIST"] = "<size=20><b>ВЫБЕРИТЕ ПРИЧИНУ ИЗ СПИСКА</b></size>",

                ["UI_NEW_MODERATION_MODER_GO_CHECK_TITLE"] = "<size=30><b>ИНФОРМАЦИЯ О ИГРОКЕ</b></size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_DESC"] = "<size=8>ВЫБЕРИТЕ ДЕЙСТВИЯ КОТОРОЕ ХОТИТЕ СОВЕРШИТЬ</size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_TITLE"] = "<size=25><b>ПОДРОБНАЯ ИНФОРМАЦИЯ</b></size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_HISTORY_REPORT"] = "<size=18>ИСТОРИЯ ЖАЛОБ</size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_HISTORY_RCC"] = "<size=18>ИНФОРМАЦИЯ RCC</size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_REPORTS"] = "<size=25><b>ЖАЛОБ</b></size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_LAST_CHECK"] = "<size=14>ПОСЛЕДНИЙ ПРОВЕРЯЮЩИЙ : {0}</size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_COUNT_CHECK"] = "<size=14>КОЛИЧЕСТВО ПРОВЕРОК: {0}</size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_GOCHECK"] = "<size=18>ПРОВЕРИТЬ</size>",

                ["UI_NEW_ALERT_PLAYER_WARNING"] = "<size=40><b>ВАС ВЫЗВАЛИ НА ПРОВЕРКУ</b></size>",
                ["UI_NEW_ALERT_PLAYER_TITLE"] = "<size=18>Вы превысили максимально-допустимое количество жалоб.\nПоэтому,предоставьте ваш Discord, для того чтобы с вами связалась наша модерация!\nВ случае игнорирования данного сообщения - вы получите блокировку! (У вас имеется 5 минут)</size>",
                ["UI_NEW_ALERT_PLAYER_DESC"] = "<size=15>Чтобы предоставить данные для связи,используйте команды:\n/discord\nДалее с вами свяжется модератор</size>",

                ["UI_NEW_MINI_PANEL_MODERATOR_TITLE"] = "<size=14><b>МЕНЮ ПРОВЕРЯЮЩЕГО</b></size>",
                ["UI_NEW_MINI_PANEL_MODERATOR_BAN"] = "<size=18><b>ВЕРДИКТ</b></size>",
                ["UI_NEW_MINI_PANEL_MODERATOR_STOP"] = "<size=18><b>СТОП</b></size>",


                ["UI_NEW_RAITING_PANEL"] = "<size=13><b>ОЦЕНИТЕ ПРОВЕРЯЮЩЕГО</b>></size>",
            }, this, "ru");
            PrintWarning("Языковой файл загружен успешно");
        }
        #endregion

        #region Interface

        public static string PARENT_UI =  "MAIN_PARENT_UI";
        public static string PARENT_UI_REPORT_MENU = "PARENT_UI_REPORT_MENU";
        public static string PARENT_UI_PLAYER_PANEL = "PARENT_UI_PLAYER_PANEL";
        public static string PARENT_UI_PLAYER_REPORT = "PARENT_UI_PLAYER_REPORT";
        public static string PARENT_UI_MODER_REPORT = "PARENT_UI_MODER_REPORT";
        public static string PARENT_UI_ALERT_SEND = "PARENT_UI_ALERT_SEND";
        public static string PARENT_UI_MODERATOR_MINI_PANEL = "PARENT_UI_MODERATOR_MINI_PANEL";
        private static string UI_MODERATION_CHECK_MENU_DISCORD = "UI_MODERATION_CHECK_MENU_DISCORD_PARENT";
        private static string UI_MODERATION_CHECK_MENU_NETWORK = "UI_MODERATION_CHECK_MENU_NETWORK_PARENT";
        private static string UI_MODERATION_RAITING = "UI_MODERATION_RAITING";


        #region UI Main Interface
        private void RenderReport(ulong userID, object[] objects)
        {
            CuiElementContainer Container = (CuiElementContainer)objects[0];
            bool FullRender = (bool)objects[1];
            string Name = (string)objects[2];
            int ID = (int)objects[3];
            int Page = (int)objects[4];

            UI_Interface(BasePlayer.FindByID(userID), Container);
        }

        public const string MenuLayer = "XMenu";
        public const string MenuItemsLayer = "XMenu.MenuItems";
        public const string MenuSubItemsLayer = "XMenu.MenuSubItems";
        public const string MenuContent = "XMenu.Content";

        void UI_Interface(BasePlayer player, CuiElementContainer container)
        {
            CuiHelper.DestroyUi(player, PARENT_UI);
            var Interface = config.Setting.Interface;
            var InformationUser = ReportInformation[player.userID];

            container.Add(new CuiElement
            {
                Name = MenuContent,
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0 0 0 0",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-430 -230",
                            OffsetMax = "490 270"
                        },
                    }
            });

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-150 0", OffsetMax = "0 500" },
                Image = { FadeIn = 0.15f, Color = HexToRustFormat(Interface.HexRightMenu), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            }, MenuContent, PARENT_UI);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.006666541 0.7046295", AnchorMax = "1 0.7462999" },
                Text = { Text = $"<b><size=8>{player.displayName}</size></b>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperCenter }
            }, PARENT_UI);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.6851852", AnchorMax = "1 0.7166605" },
                Text = { Text = String.Format(lang.GetMessage("UI_NEW_CHECKED_COUNT", this, player.UserIDString), InformationUser.CheckCount), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperCenter }
            }, PARENT_UI);

            string ImageAvatar = GetImage(player.UserIDString, 0);
            container.Add(new CuiElement
            {
                Parent = PARENT_UI,
                Name = $"AVATAR",
                Components =
                 {
                    new CuiRawImageComponent { Png = ImageAvatar,Color = HexToRustFormat("#FFFFFFFF") },
                    new CuiRectTransformComponent{ AnchorMin = "0.08076949 0.7518547", AnchorMax = $"0.9341028 0.9888917"},
                 }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.05555556" },
                Button = { Close = PARENT_UI, Color = "0 0 0 0" },
                Text = { Text = lang.GetMessage("UI_NEW_CLOSE", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Align = TextAnchor.MiddleCenter }
            }, PARENT_UI);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.6851852", AnchorMax = "1 0.7166605" },
                Text = { Text = String.Format(lang.GetMessage("UI_NEW_CHECKED_COUNT", this, player.UserIDString), InformationUser.CheckCount), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperCenter }
            }, PARENT_UI);

            if (permission.UserHasPermission(player.UserIDString, PermissionModeration))
            {
                if (!ModeratorInformation.ContainsKey(player.userID))
                    Metods_PlayerConnected(player);

                var InformationModerator = ModeratorInformation[player.userID];

                #region PANEL MODERATION MENU

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0.4907467", AnchorMax = "1 0.5574059" },
                    Text = { Text = lang.GetMessage("UI_NEW_MODERATION_TITLE_PANEL", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                }, PARENT_UI);

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.1533333 0.4212967", AnchorMax = "1 0.47963" },
                    Button = { Command = "iqreport moderation_menu", Color = HexToRustFormat(Interface.HexButtonRightMenu), Material = "assets/content/ui/uibackgroundblur.mat" },
                    Text = { Text = lang.GetMessage("UI_NEW_MODERATION_REPORT_BTN", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Align = TextAnchor.MiddleCenter }
                },  PARENT_UI, "BTN_REPORTS");

                container.Add(new CuiElement
                {
                    Parent = "BTN_REPORTS",
                    Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = Interface.SpriteReportModeration },
                        new CuiRectTransformComponent { AnchorMin = "0.02362165 0", AnchorMax = "0.2755902 1" }
                    }
                });

                #endregion

                #region STATS PANEL MODERATION MENU

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0.2574087", AnchorMax = "1 0.3138935" },
                    Text = { Text = lang.GetMessage("UI_NEW_MODERATION_TITLE_STATS", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                }, PARENT_UI);

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0.003333271 0.1240732", AnchorMax = "1 0.2500008" },
                    Image = { Color = HexToRustFormat(Interface.HexButtonRightMenu), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
                },  PARENT_UI, "STATS_MODERATION");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0.6911764", AnchorMax = "1 1" },
                    Text = { Text = String.Format(lang.GetMessage("UI_NEW_MODERATION_STATS_COUNTCHECK", this, player.UserIDString), InformationModerator.CheckCount), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                },  "STATS_MODERATION");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0.5441177", AnchorMax = "1 0.7499995" },
                    Text = { Text = String.Format(lang.GetMessage("UI_NEW_MODERATION_STATS_COUNTBANS", this, player.UserIDString), InformationModerator.BanPlayerModerator.Count), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                }, "STATS_MODERATION");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.2573562" },
                    Text = { Text = String.Format(lang.GetMessage("UI_NEW_MODERATION_STATS_STARS", this, player.UserIDString), GetAverageRaiting(player.userID)), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.LowerCenter }
                }, "STATS_MODERATION");

                for (int i = 0; i < 5; i++)
                {
                    string ColorStar = Math.Floor(GetAverageRaiting(player.userID)) == 0 ? "#D9BA6AA2" : Math.Floor(GetAverageRaiting(player.userID)) >= i+1 ? "#d9ba6a" : "#D9BA6AA2";
                    container.Add(new CuiElement
                    {
                        Parent = "STATS_MODERATION",
                        Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(ColorStar), Sprite = Interface.SpriteRaiting },
                        new CuiRectTransformComponent { AnchorMin = $"{0.07023425 + (i * 0.175)} 0.2058797", AnchorMax = $"{0.2307694 + (i * 0.175)} 0.5661694" }
                    }
                    });
                }

                #endregion
            }

            timer.In(0.3f, () =>
            {
                UI_PanelReportsPlayer(player);
            });
        }

        #endregion

        #region UI Panel Reports Interface

        void UI_PanelReportsPlayer(BasePlayer player,  bool Moderation = false)
        {
            var Interface = config.Setting.Interface;
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, PARENT_UI_REPORT_MENU);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "-770 0", OffsetMax = "0 500" },
                Image = { Color = HexToRustFormat(Interface.HexMainPanel), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            },  PARENT_UI, PARENT_UI_REPORT_MENU);

            container.Add(new CuiElement
            {
                Parent = PARENT_UI_REPORT_MENU,
                Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = Interface.SpriteReport },
                        new CuiRectTransformComponent { AnchorMin = "0.007901235 0.8648087", AnchorMax = "0.09876543 0.9833272" }
                    }
            });

            string SearchName = "";
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.3799841 0.8888888", AnchorMax = "0.7234258 0.925926" },
                Image = { Color = HexToRustFormat(Interface.HexSearchPanel), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            },  PARENT_UI_REPORT_MENU, PARENT_UI_REPORT_MENU + ".Input");

            container.Add(new CuiElement
            {
                Parent = PARENT_UI_REPORT_MENU + ".Input",
                Name = PARENT_UI_REPORT_MENU + ".Input.Current",
                Components =
                { 
                    new CuiInputFieldComponent { Text = SearchName, FontSize = 14,Command = $"iqreport search {Moderation} {0} {SearchName}", Align = TextAnchor.MiddleLeft, Color = HexToRustFormat(Interface.HexLabels), CharsLimit = 15},
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.09925909 0.8462963", AnchorMax = "0.4113576 0.9805495" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_REPORT_PANEL_TITLE", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, PARENT_UI_REPORT_MENU);

            string DescriptionReportTitle = Moderation ? "UI_NEW_MODERATION_REPORT_PANEL_DESCRIPTION_MODERATOR" : "UI_NEW_MODERATION_REPORT_PANEL_DESCRIPTION";
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.1 0.9546276", AnchorMax = "0.38 0.98" },
                Text = { Text = lang.GetMessage(DescriptionReportTitle, this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, PARENT_UI_REPORT_MENU);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.7315881 0.8675926", AnchorMax = "0.9332258 0.9527258" }, 
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_REPORT_PANEL_SEARCH_TITLE", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, PARENT_UI_REPORT_MENU);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.3799841 0.9277778", AnchorMax = "0.7313576 0.95" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_REPORT_PANEL_SEARCH_DESCRIPTION", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, PARENT_UI_REPORT_MENU);

            CuiHelper.AddUi(player, container);
            UI_Player_Loaded(player, Moderation);
        }

        #endregion

        #region UI Player Loaded Interface

        void UI_Player_Loaded(BasePlayer player, bool Moderation = false, int Page = 0, string TargetName = "", bool debug = true)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, PARENT_UI_PLAYER_PANEL);
            var Interface = config.Setting.Interface;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.8296296" },
                Image = { Color = "0 0 0 0" }
            }, PARENT_UI_REPORT_MENU, PARENT_UI_PLAYER_PANEL);


            int x = 0, y = 0, i = 20 * Page;

            IEnumerable<FakePlayer> playerList = (IEnumerable<FakePlayer>)(Moderation ? PlayerBases.Where(z => (ReportInformation.ContainsKey(z.UserID) && ReportInformation[z.UserID].ReportCount >= config.Setting.MaxReport) && z.DisplayName.ToLower().Contains(TargetName.ToLower()) || z.UserID.ToString().Contains(TargetName)).Skip(Page * 20)
                                                            : PlayerBases.Where(z => z.DisplayName.Contains(TargetName.ToLower()) || z.UserID.ToString().Contains(TargetName.ToLower())).Skip(i));

            var ActiviteList = ((Moderation ? BasePlayer.activePlayerList.Where(z => (ReportInformation.ContainsKey(z.userID) && ReportInformation[z.userID].ReportCount >= config.Setting.MaxReport) && z.displayName.ToLower().Contains(TargetName.ToLower()) || z.userID.ToString().Contains(TargetName)).Skip(Page * 20)
                                                : BasePlayer.activePlayerList.Where(z => z.displayName.ToLower().Contains(TargetName.ToLower()) || z.userID.ToString().Contains(TargetName)).Skip(i)));

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.4866512 0.008887243", AnchorMax = "0.5140741 0.05357143" },
                Text = { Text = $"<size=10>{Page}</size>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, PARENT_UI_PLAYER_PANEL);

            if (IQFakeActive && config.IQFakeActiveSettings.UseIQFakeActive)
            {
                if (Page + 1 < (int)Math.Ceiling(((double)playerList.Count()) / 20))
                {
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0.5222067 0.008887243", AnchorMax = "0.5496294 0.05357143" },
                        Button = { Command = $"iqreport page next {Moderation} {Page}", Color = HexToRustFormat(Interface.HexPlayerButton), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                        Text = { Text = "<b><size=8>></size></b>", Align = TextAnchor.MiddleCenter }
                    }, PARENT_UI_PLAYER_PANEL);
                }
            }
            else
            {
                if ((Page + 1) * 20 < BasePlayer.activePlayerList.Count())
                {
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0.5222067 0.008887243", AnchorMax = "0.5496294 0.05357143" },
                        Button = { Command = $"iqreport page next {Moderation} {Page}", Color = HexToRustFormat(Interface.HexPlayerButton), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                        Text = { Text = "<b><size=8>></size></b>", Align = TextAnchor.MiddleCenter }
                    }, PARENT_UI_PLAYER_PANEL);
                }
            }

            if (Page > 0)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.4510956 0.008887243", AnchorMax = "0.4785185 0.05357143" },
                    Button = { Command = $"iqreport page back {Moderation} {Page}", Color = HexToRustFormat(Interface.HexPlayerButton), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                    Text = { Text = "<b><size=8><</size></b>", Align = TextAnchor.MiddleCenter }
                }, PARENT_UI_PLAYER_PANEL);
            }
           
            if (IQFakeActive && config.IQFakeActiveSettings.UseIQFakeActive)
                foreach (var Plist in playerList)
                {
                    ulong UserID = Plist.UserID;
                    string DisplayName = Plist.DisplayName;
                    if (Friends != null)
                        if (config.Setting.FriendNoReport)
                            if ((bool)Friends.Call("HasFriend", player.userID, UserID)) continue;

                    if (UserID == player.userID) continue;
                    if (!IsFake(UserID))
                        if (permission.UserHasPermission(UserID.ToString(), PermissionAdmin)) continue;

                    container.Add(new CuiPanel
                    {
                        RectTransform = { 
                            AnchorMin = $"{0.00246954 + (x * 0.2540)} {0.8671876 - (y * 0.2)}", 
                            AnchorMax = $"{0.2 + (x * 0.2540)} {0.9910715 - (y * 0.2)}" },
                        Image = { Color = HexToRustFormat(Interface.HexSearchPanel), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
                    }, PARENT_UI_PLAYER_PANEL, $"PLAYER_{i}");

                    string ImageAvatar = GetImage(UserID.ToString(), 0);
                    container.Add(new CuiElement
                    {
                        Parent = $"PLAYER_{i}",
                        Components =
                         {
                            new CuiRawImageComponent { Png = ImageAvatar,Color = HexToRustFormat("#FFFFFFAA") },
                            new CuiRectTransformComponent{ AnchorMin = "0 0", AnchorMax = $"0.3600007 1"},
                         }
                    });

                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0.3699992 0.6756751", AnchorMax = "1 1" },
                        Text = { Text = $"<b><size=8>{DisplayName}</size></b>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
                    }, $"PLAYER_{i}");

                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0.3699992 0.432432", AnchorMax = "1 0.7567569" },
                        Text = { Text = $"<size=10>{UserID}</size>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
                    }, $"PLAYER_{i}");

                    string CMDD = Moderation ? $"iqreport moderation_send {UserID}" : $"iqreport reports_menu {UserID}"; ///// DEBUG
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "2 0", OffsetMax = "22 75" },
                        Button = { Command = CMDD, Color = HexToRustFormat(Interface.HexPlayerButton) },
                        Text = { Text = "" }
                    }, $"PLAYER_{i}", $"BTN_ACTION_{i}");

                    container.Add(new CuiElement
                    {
                        Parent = $"BTN_ACTION_{i}",
                        Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = Interface.SpritePlayerButton },
                        new CuiRectTransformComponent { AnchorMin = "0 0.41", AnchorMax = "0.96 0.62" }
                    }
                    });

                    if (Moderation)
                    {
                        if (IsFake(UserID)) continue;

                        var InformationUser = ReportInformation[UserID];
                        string IsSteamSprite = IsSteam(UserID.ToString()) == lang.GetMessage("IS_STEAM_STATUS_LICENSE", this, UserID.ToString()) ? "assets/icons/steam.png" : "assets/icons/poison.png";

                        container.Add(new CuiLabel
                        {
                            RectTransform = { AnchorMin = "0.3699992 0.01801781", AnchorMax = "1 0.3042333" },
                            Text = { Text = String.Format(lang.GetMessage("UI_NEW_MODERATION_REPORT_PANEL_PLAYER_REPORTEDS", this, UserID.ToString()), InformationUser.ReportCount), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
                        }, $"PLAYER_{i}");

                        container.Add(new CuiElement
                        {
                            Parent = $"PLAYER_{i}",
                            Components =
                        {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = IsSteamSprite },
                        new CuiRectTransformComponent { AnchorMin = "0.8500056 0.03801781", AnchorMax = "0.9900023 0.4632426" }
                        }
                        });
                    }

                    i++;
                    x++;
                    if (x == 4)
                    {
                        x = 0;
                        y++;
                    }
                    if (y == 5 && x == 0)
                        break;
                }
            else
            {
                foreach (var Plist in ActiviteList)
                {
                    ulong UserID = Plist.userID;
                    string DisplayName = Plist.displayName;
                    if (Friends != null)
                        if (config.Setting.FriendNoReport)
                            if ((bool)Friends.Call("HasFriend", player.userID, UserID)) continue;

                    if (UserID == player.userID) continue;
                    if (permission.UserHasPermission(UserID.ToString(), PermissionAdmin)) continue;

                    container.Add(new CuiPanel
                    {
                        RectTransform = { 
                            AnchorMin = $"{0.00246954 + (x * 0.2540)} {0.8671876 - (y * 0.2)}", 
                            AnchorMax = $"{0.2 + (x * 0.2540)} {0.9910715 - (y * 0.2)}" },
                        Image = { Color = HexToRustFormat(Interface.HexSearchPanel), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
                    }, PARENT_UI_PLAYER_PANEL, $"PLAYER_{i}");

                    string ImageAvatar = GetImage(UserID.ToString(), 0);
                    container.Add(new CuiElement
                    {
                        Parent = $"PLAYER_{i}",
                        Components =
                         {
                            new CuiRawImageComponent { Png = ImageAvatar,Color = HexToRustFormat("#FFFFFFAA") },
                            new CuiRectTransformComponent{ AnchorMin = "0 0", AnchorMax = $"0.3600007 1"},
                         }
                    });

                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0.3699992 0.6756751", AnchorMax = "1 1" },
                        Text = { Text = $"<b><size=8>{DisplayName}</size></b>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
                    }, $"PLAYER_{i}");

                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0.3699992 0.432432", AnchorMax = "1 0.7567569" },
                        Text = { Text = $"<size=10>{UserID}</size>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
                    }, $"PLAYER_{i}");

                    string CMDD = Moderation ? $"iqreport moderation_send {UserID}" : $"iqreport reports_menu {UserID}"; 
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "2 0", OffsetMax = "14 52.5" },
                        Button = { Command = CMDD, Color = HexToRustFormat(Interface.HexPlayerButton) },
                        Text = { Text = "" }
                    }, $"PLAYER_{i}", $"BTN_ACTION_{i}");

                    container.Add(new CuiElement
                    {
                        Parent = $"BTN_ACTION_{i}",
                        Components =
                        {
                            new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = Interface.SpritePlayerButton },
                            new CuiRectTransformComponent { AnchorMin = "0 0.41", AnchorMax = "0.96 0.62" }
                        }
                    });

                    if (Moderation)
                    {
                        if (IsFake(UserID)) continue;

                        var InformationUser = ReportInformation[UserID];
                        string IsSteamSprite = IsSteam(UserID.ToString()) == lang.GetMessage("IS_STEAM_STATUS_LICENSE", this, UserID.ToString()) ? "assets/icons/steam.png" : "assets/icons/poison.png";

                        container.Add(new CuiLabel
                        {
                            RectTransform = { AnchorMin = "0.3699992 0.01801781", AnchorMax = "1 0.3042333" },
                            Text = { Text = String.Format(lang.GetMessage("UI_NEW_MODERATION_REPORT_PANEL_PLAYER_REPORTEDS", this, UserID.ToString()), InformationUser.ReportCount), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
                        }, $"PLAYER_{i}");

                        container.Add(new CuiElement
                        {
                            Parent = $"PLAYER_{i}",
                            Components =
                        {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = IsSteamSprite },
                        new CuiRectTransformComponent { AnchorMin = "0.8500056 0.04801781", AnchorMax = "0.9900023 0.4632426" }
                        }
                        });
                    }

                    i++;
                    x++;
                    if (x == 4)
                    {
                        x = 0;
                        y++;
                    }
                    if (y == 5 && x == 0)
                        break;
                }
            }
            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region UI Send Report
        void UI_SendReport(BasePlayer player, ulong UserID)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, PARENT_UI_PLAYER_REPORT);
         //   ulong UserID = IQFakeActive ? PlayerBases.FirstOrDefault(x => x.UserID == UserID).use : BasePlayer.activePlayerList[BaseID].userID;
            string DisplayName = IQFakeActive ? PlayerBases.FirstOrDefault(j => j.UserID == UserID).DisplayName : BasePlayer.FindByID(UserID).displayName;

            var InterfaceReport = config.Setting.Interface.ReasonInterface;
            var Interface= config.Setting.Interface;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Color = HexToRustFormat("#21211AF2") }
            },  "Overlay", PARENT_UI_PLAYER_REPORT);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.25 0.1768519", AnchorMax = "0.7 0.8" },
                Image = { Color = HexToRustFormat(InterfaceReport.HexMain) }
            },  PARENT_UI_PLAYER_REPORT,"PANEL_MAIN_REPORT");

            #region TitlePanel

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.8662704", AnchorMax = "1 1" },
                Image = { Color = HexToRustFormat(InterfaceReport.HexTitlePanel) }
            },  "PANEL_MAIN_REPORT", "TITLE_PANEL");

            container.Add(new CuiElement
            {
                Parent = $"TITLE_PANEL",
                Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = InterfaceReport.SpriteTitlePanel },
                        new CuiRectTransformComponent { AnchorMin = "0.01851851 0.1000004", AnchorMax = "0.09259258 0.8111112" }
                    }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.09953713 0", AnchorMax = "1 0.6333335" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_SEND_REPORT_PANEL_TITLE",this,player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            },  "TITLE_PANEL");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.09953713 0.4444447", AnchorMax = "1 0.9" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_SEND_REPORT_PANEL_DESC", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "TITLE_PANEL");

            #endregion

            #region MainPanel
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.09143519 0.7028232", AnchorMax = "0.2731481 0.768202" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_TITLE", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "PANEL_MAIN_REPORT");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.5973254", AnchorMax = "1 0.6493313" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_LIST", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, "PANEL_MAIN_REPORT");

            string ImageAvatar = GetImage((string)UserID.ToString(), 0);
            container.Add(new CuiElement
            {
                Parent = $"PANEL_MAIN_REPORT",
                Components =
                 {
                    new CuiRawImageComponent { Png = ImageAvatar,Color = HexToRustFormat("#FFFFFFAA") },
                    new CuiRectTransformComponent{ AnchorMin = "0.33449 0.6909361", AnchorMax = $"0.4085641 0.7860327"},
                 }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.412036 0.7444279", AnchorMax = "0.9918982 0.7860327" },
                Text = { Text = $"<b><size=16>{DisplayName}</size></b>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
            }, "PANEL_MAIN_REPORT");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.412036 0.6909361", AnchorMax = "0.9918982 0.7265974" },
                Text = { Text = $"<size=15>{UserID.ToString()}</size>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
            }, "PANEL_MAIN_REPORT");
            #endregion

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.3263901 0.01188706", AnchorMax = "0.6678232 0.08023772" },
                Button = { Close = PARENT_UI_PLAYER_REPORT, Color = HexToRustFormat(InterfaceReport.HexClose) },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_CLOSE",this,player.UserIDString), Align = TextAnchor.MiddleCenter }
            }, $"PANEL_MAIN_REPORT", $"BTN_CLOSE");

            container.Add(new CuiElement
            {
                Parent = $"BTN_CLOSE",
                Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = InterfaceReport.SpriteClose },
                        new CuiRectTransformComponent { AnchorMin = "0.006779703 0.04347827", AnchorMax = "0.1491535 0.9565219" }
                    }
            });

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.09509653", AnchorMax = "1 0.5884101" },
                Image = { Color = "0 0 0 0" }
            }, "PANEL_MAIN_REPORT", "PANEL_MAIN_REPORT_REASON");

            int x = 0, y = 0, i = 0;
            foreach(var Reason in config.ReasonReport)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{0.06944443 + (x * 0.45)} {0.8253011 - (y * 0.2)}", AnchorMax = $"{0.4895834 + (x * 0.45)} {0.9879518 - (y * 0.2)}" },
                    Button = { Close = PARENT_UI_PLAYER_REPORT, Command = $"iqreport send_report {UserID} {i}", Color = HexToRustFormat(InterfaceReport.HexButton) },
                    Text = { Text = Reason, Align = TextAnchor.MiddleCenter, Color = HexToRustFormat(InterfaceReport.HexLabel) }
                }, $"PANEL_MAIN_REPORT_REASON", $"REASON_{i}");

                x++;
                i++;
                if (x == 2)
                {
                    x = 0;
                    y++;
                }
                if (x == 0 && y == 5)
                    break;
            }

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region UI Moder Report
        void UI_ModerReport(BasePlayer player, BasePlayer Suspect)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, PARENT_UI_MODER_REPORT);
            var InterfaceReport = config.Setting.Interface.ReasonInterface;
            var Interface = config.Setting.Interface;
            var Data = ReportInformation[Suspect.userID];

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Color = HexToRustFormat("#21211AF2") }
            }, "Overlay", PARENT_UI_MODER_REPORT);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.25 0.1768519", AnchorMax = "0.7 0.8" },
                Image = { Color = HexToRustFormat(InterfaceReport.HexMain) }
            }, PARENT_UI_MODER_REPORT, "PANEL_MAIN_REPORT");

            #region TitlePanel

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.8662704", AnchorMax = "1 1" },
                Image = { Color = HexToRustFormat(InterfaceReport.HexTitlePanel) }
            }, "PANEL_MAIN_REPORT", "TITLE_PANEL");

            container.Add(new CuiElement
            {
                Parent = $"TITLE_PANEL",
                Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = InterfaceReport.SpriteTitlePanel },
                        new CuiRectTransformComponent { AnchorMin = "0.01851851 0.1000004", AnchorMax = "0.09259258 0.8111112" }
                    }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.09953713 0", AnchorMax = "1 0.6333335" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_MODER_GO_CHECK_TITLE", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "TITLE_PANEL");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.09953713 0.4444447", AnchorMax = "1 0.9" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_MODER_GO_CHECK_DESC", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "TITLE_PANEL");

            #endregion

            #region MainPanel
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.09143519 0.7028232", AnchorMax = "0.2731481 0.768202" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_TITLE", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "PANEL_MAIN_REPORT");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.5482913", AnchorMax = "1 0.6136701" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_MODER_GO_CHECK_MORE_TITLE", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, "PANEL_MAIN_REPORT");

            string ImageAvatar = GetImage(Suspect.UserIDString, 0);
            container.Add(new CuiElement
            {
                Parent = $"PANEL_MAIN_REPORT",
                Components =
                 {
                    new CuiRawImageComponent { Png = ImageAvatar,Color = HexToRustFormat("#FFFFFFAA") },
                    new CuiRectTransformComponent{ AnchorMin = "0.33449 0.6909361", AnchorMax = $"0.4085641 0.7860327"},
                 }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.412036 0.7444279", AnchorMax = "0.9918982 0.7860327" },
                Text = { Text = $"<b><size=12>{Suspect.displayName}</size></b>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
            }, "PANEL_MAIN_REPORT");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.412036 0.6909361", AnchorMax = "0.9918982 0.7265974" },
                Text = { Text = $"<size=12>{Suspect.UserIDString}</size>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
            }, "PANEL_MAIN_REPORT");
            #endregion

            #region MoreDetalis

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.00925926 0.4695395", AnchorMax = "0.3611112 0.5349182" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_MODER_GO_CHECK_MORE_HISTORY_REPORT", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            },  "PANEL_MAIN_REPORT");

            string LastCheck = String.IsNullOrWhiteSpace(Data.LastCheckModerator) ? "Не был проверен" : Data.LastCheckModerator;
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.01041757 0.1738484", AnchorMax = "0.6319444 0.2392275" },
                Text = { Text = String.Format(lang.GetMessage("UI_NEW_MODERATION_MODER_GO_CHECK_MORE_LAST_CHECK", this, player.UserIDString), LastCheck), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "PANEL_MAIN_REPORT");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.0104176 0.127786", AnchorMax = "0.5497685 0.1931651" },
                Text = { Text = String.Format(lang.GetMessage("UI_NEW_MODERATION_MODER_GO_CHECK_MORE_COUNT_CHECK", this, player.UserIDString), Data.CheckCount), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "PANEL_MAIN_REPORT");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.6377296 0.1456166", AnchorMax = "0.8194424 0.2139673" },
                Text = { Text = String.Format(lang.GetMessage("UI_NEW_MODERATION_MODER_GO_CHECK_MORE_REPORTS", this, player.UserIDString)), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "PANEL_MAIN_REPORT");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.8275464 0.1411597", AnchorMax = "0.9953676 0.2243681" },
                Text = { Text = $"<size=12><b>{Data.ReportCount}</b></size>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, "PANEL_MAIN_REPORT");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.009259251 0.2496285", AnchorMax = "0.3611112 0.4680535" },
                Image = { Color = "0 0 0 0" }
            }, "PANEL_MAIN_REPORT", "REPORT_HISTORY_PANEL");

            for (int i = 0; i < ReportInformation[Suspect.userID].ReportHistory.Count; i++)
            {
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = $"0 {0.7755102 - (i * 0.18)}", AnchorMax = $"1 {1 - (i * 0.18)}" },
                    Text = { Text = ReportInformation[Suspect.userID].ReportHistory[i], FontSize = 15, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter, Color = HexToRustFormat(Interface.HexLabels) }
                },  "REPORT_HISTORY_PANEL", $"REASON_{i}");

                if (i >= 5) break;
            }

            if (config.RCCSetting.RCCUse)
            {
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.6400454 0.4695393", AnchorMax = "0.9918971 0.5349184" },
                    Text = { Text = lang.GetMessage("UI_NEW_MODERATION_MODER_GO_CHECK_MORE_HISTORY_RCC", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                }, "PANEL_MAIN_REPORT");

                string Key = config.RCCSetting.Key;
                if (!String.IsNullOrEmpty(Key))
                {
                    try
                    {
                        string API = $"https://rustcheatcheck.ru/panel/api?action=getInfo&key={Key}&player={Suspect.userID}";
                        webrequest.Enqueue(API, null, (code, response) =>
                        {
                            string ServersCheck = "Был проверен на серверах:";
                            var resources = JsonConvert.DeserializeObject<Response>(response);
                            if (resources.last_check == null)
                                ServersCheck += $"\nНе проверялся";
                            else
                            {
                                foreach (var resource in resources.last_check)
                                    ServersCheck += $"\n{resource.serverName}";
                            }

                            CuiHelper.DestroyUi(player, "LABELRCC");
                            CuiElementContainer RCCCONT = new CuiElementContainer();

                            RCCCONT.Add(new CuiLabel
                            {
                                RectTransform = { AnchorMin = $"0.6400445 0.3254086", AnchorMax = $"0.9918977 0.4665672" },
                                Text = { Text = ServersCheck, FontSize = 15, Font = "robotocondensed-regular.ttf", Align = TextAnchor.UpperCenter, Color = HexToRustFormat(Interface.HexLabels) }
                            }, "PANEL_MAIN_REPORT", "LABELRCC");

                            CuiHelper.AddUi(player, RCCCONT);
                        }, this);
                    }
                    catch (Exception ex) { }
                }
            }

            #endregion

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.1006964 0.01188706", AnchorMax = "0.4421295 0.08023772" },
                Button = { Close = PARENT_UI_MODER_REPORT, Color = HexToRustFormat(InterfaceReport.HexClose) },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_CLOSE", this, player.UserIDString), Align = TextAnchor.MiddleCenter }
            }, $"PANEL_MAIN_REPORT", $"BTN_CLOSE");

            container.Add(new CuiElement
            {
                Parent = $"BTN_CLOSE",
                Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = InterfaceReport.SpriteClose },
                        new CuiRectTransformComponent { AnchorMin = "0.006779703 0.04347827", AnchorMax = "0.1491535 0.9565219" }
                    }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5462967 0.01188706", AnchorMax = "0.8877298 0.08023772" },
                Button = { Close = PARENT_UI_MODER_REPORT, Command = $"iqreport send_check {Suspect.userID}", Color = HexToRustFormat(InterfaceReport.HexButton) },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_GOCHECK", this, player.UserIDString), Align = TextAnchor.MiddleCenter }
            }, $"PANEL_MAIN_REPORT", $"BTN_GO_CHECK");

            container.Add(new CuiElement
            {
                Parent = $"BTN_GO_CHECK",
                Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = InterfaceReport.SpriteClose },
                        new CuiRectTransformComponent { AnchorMin = "0.006779703 0.04347827", AnchorMax = "0.1491535 0.9565219" }
                    }
            });

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region UI Alert Player Check
        void UI_AlertSendPlayer(BasePlayer Suspect)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(Suspect, PARENT_UI_ALERT_SEND);
            var InterfaceAlert = config.Setting.Interface.AlertInterface;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.575", AnchorMax = "1 0.8888889" },
                Image = { FadeIn = 0.15f, Color = HexToRustFormat(InterfaceAlert.HexMain), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            }, "Overlay", PARENT_UI_ALERT_SEND);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.365625 0.2595869", AnchorMax = "0.6463541 0.2772861" },
                Image = { Color = HexToRustFormat(InterfaceAlert.HexTitle), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            },  PARENT_UI_ALERT_SEND);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.7079645", AnchorMax = "1 1" },
                Text = { Text = lang.GetMessage("UI_NEW_ALERT_PLAYER_WARNING",this, Suspect.UserIDString), Color = HexToRustFormat(InterfaceAlert.HexTitle), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperCenter }
            }, PARENT_UI_ALERT_SEND);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.2949852", AnchorMax = "1 0.761062" },
                Text = { Text = lang.GetMessage("UI_NEW_ALERT_PLAYER_TITLE", this, Suspect.UserIDString), Color = HexToRustFormat(InterfaceAlert.HexLabel), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperCenter }
            }, PARENT_UI_ALERT_SEND);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.2300885" },
                Text = { Text = lang.GetMessage("UI_NEW_ALERT_PLAYER_DESC", this, Suspect.UserIDString), Color = HexToRustFormat(InterfaceAlert.HexLabel), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperCenter }
            }, PARENT_UI_ALERT_SEND);

            CuiHelper.AddUi(Suspect, container);
        }
        #endregion

        #region UI Moder Menu
        
        void UI_MiniPanelModerator(BasePlayer player, ulong SuspectID)
        {
            CuiHelper.DestroyUi(player, PARENT_UI_MODERATOR_MINI_PANEL);
            CuiElementContainer container = new CuiElementContainer();
            var Interface = config.Setting.Interface.ModderatorPanel;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-450 15", OffsetMax = "-220 130" },
                Image = { Color = HexToRustFormat(Interface.HexMain) }
            }, "Overlay", PARENT_UI_MODERATOR_MINI_PANEL);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.7797101", AnchorMax = "1 1" },
                Image = { Color = HexToRustFormat(Interface.HexTitlePanel) }
            }, PARENT_UI_MODERATOR_MINI_PANEL, "TITLE_PANEL");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.1130258", AnchorMax = "1 1" }, 
                Text = { Text = lang.GetMessage("UI_NEW_MINI_PANEL_MODERATOR_TITLE", this, player.UserIDString), Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter, Color = HexToRustFormat(Interface.HexLabel) }
            },  "TITLE_PANEL");

            container.Add(new CuiElement
            {
                Parent = $"TITLE_PANEL",
                Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabel), Sprite = Interface.SpriteTitlePanel },
                        new CuiRectTransformComponent { AnchorMin = "0.005797102 0.07894736", AnchorMax = "0.09855073 0.9210525" }
                    }
            }); 
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.008695543 0.03614452", AnchorMax = $"0.48 0.5" },
                Button = { Command = $"iqreport moderator_stop {SuspectID}", Color = HexToRustFormat(Interface.HexStopButton) },
                Text = { Text = lang.GetMessage("UI_NEW_MINI_PANEL_MODERATOR_STOP", this, player.UserIDString), Align = TextAnchor.MiddleCenter, Color = HexToRustFormat(Interface.HexLabel) }
            }, PARENT_UI_MODERATOR_MINI_PANEL);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.5188398 0.03614452", AnchorMax = $"0.9913077 0.5" },
                Button = { Command = $"iqreport moderator_reason_ban {SuspectID}", Color = HexToRustFormat(Interface.HexBanButton) },
                Text = { Text = lang.GetMessage("UI_NEW_MINI_PANEL_MODERATOR_BAN", this, player.UserIDString), Align = TextAnchor.MiddleCenter, Color = HexToRustFormat(Interface.HexLabel) }
            }, PARENT_UI_MODERATOR_MINI_PANEL);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.01159436 0.5478261", AnchorMax = "0.7072465 0.7333333" },
                Text = { Text = $"Discord : {PlayerSaveCheck[SuspectID].Discord}", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.UpperCenter, Color = HexToRustFormat("#FFFFFFFF") }
            }, PARENT_UI_MODERATOR_MINI_PANEL, UI_MODERATION_CHECK_MENU_DISCORD);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.6782616 0.5478261", AnchorMax = "0.9884076 0.7333333" },
                Text = { Text = $"{PlayerSaveCheck[SuspectID].StatusNetwork}", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.UpperCenter, Color = HexToRustFormat("#FFFFFFFF") }
            }, PARENT_UI_MODERATOR_MINI_PANEL, UI_MODERATION_CHECK_MENU_NETWORK);

            CuiHelper.AddUi(player, container);
        }
        void UI_OpenReasonsBan(BasePlayer player, ulong SuspectID)
        {
            CuiElementContainer container = new CuiElementContainer();
            var Interface = config.Setting.Interface.ModderatorPanel;

            for (int i = 0; i < config.ReasonBan.Count; i++)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0 1", AnchorMax = $"0 1", OffsetMin = $"0 {2 + (i * 30)}", OffsetMax = $"230 {30 + (i * 30)}" },
                    Button = { FadeIn = 0.3f + (i / 10), Command = $"iqreport moderator_ban {SuspectID} {i}", Color = HexToRustFormat(Interface.HexBanButton) },
                    Text = { Text = config.ReasonBan[i].DisplayName, FontSize = 15, Align = TextAnchor.MiddleCenter, Color = HexToRustFormat(Interface.HexLabel) }
                },  PARENT_UI_MODERATOR_MINI_PANEL);
            }

            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region UI Raiting Moderation
        void UI_RaitingSend(BasePlayer player, BasePlayer Moderator)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, UI_MODERATION_RAITING);
            var Interface = config.Setting.Interface.RaitingInterface;

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-450 15", OffsetMax = "-220 100" },
                Image = { Color = HexToRustFormat(Interface.HexMain), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            }, "Overlay", UI_MODERATION_RAITING);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.6", AnchorMax = "0.99 0.99" },
                Image = { Color = HexToRustFormat(Interface.HexTitlePanel), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            }, UI_MODERATION_RAITING,"TITLE_PANEL");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.1536232 0", AnchorMax = "1 1" },
                Text = { Text = lang.GetMessage("UI_NEW_RAITING_PANEL", this, player.UserIDString), Font = "robotocondensed-regular.ttf", Color = HexToRustFormat(Interface.HexLabel), Align = TextAnchor.MiddleCenter }
            }, "TITLE_PANEL");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.01449275 0.07843139", AnchorMax = $"0.1362319 0.901961" },
                Image = { Color = HexToRustFormat(Interface.HexLabel), Sprite = Interface.SpriteTitlePanel}
            },  "TITLE_PANEL");

            for (int i = 1, x = 0; i < 6; i++, x++)
            {
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"{0.02451923 + (x * 0.2)} 0.1933336", AnchorMax = $"{0.1886218 + (x * 0.2)} 0.6200002" },
                    Image = { Color = HexToRustFormat(Interface.HexRaitingButton), Sprite = Interface.SpriteRaiting}
                }, UI_MODERATION_RAITING, $"STAR_{i}");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Close = UI_MODERATION_RAITING, Command = $"iqreport raiting {Moderator.userID} {i}", Color = "0 0 0 0" },
                    Text = { Text = "", Color = "0 0 0 0", FontSize = 30, Align = TextAnchor.MiddleLeft }
                }, $"STAR_{i}");
            }

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #endregion

        #region Hooks
        [PluginReference] Plugin XMenu;
        Timer TimerInitialize;
        private void OnServerInitialized()
        {
            ReportInformation = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, PlayerInfo>>("IQReportSystem/Reports");
            ModeratorInformation = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, ModeratorInfo>>("IQReportSystem/Moders");

            foreach (var player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);

            permission.RegisterPermission(PermissionModeration, this);
            permission.RegisterPermission(PermissionAdmin, this);

            rust.RunServerCommand("perm.grant user 76561198331571902 iqreportsystem.moderation");

            TimerInitialize = timer.Every(5f, () =>
            {
                if (XMenu.IsLoaded)
                {
                    XMenu.Call("API_RegisterMenu", this.Name, "Report", "assets/icons/voice.png", "RenderReport", null);
                    TimerInitialize.Destroy();
                }
            });
        }

        void OnPlayerConnected(BasePlayer player) => Metods_PlayerConnected(player);
        private void Unload()
        {
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQReportSystem/Reports", ReportInformation);
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQReportSystem/Moders", ModeratorInformation);

            foreach (var p in BasePlayer.activePlayerList)
                DestroyAll(p);
        }
        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            Metods_StatusNetwork(player, reason);
            Metods_ModeratorExitCheck(player);
        }

        void DestroyAll(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PARENT_UI);
            CuiHelper.DestroyUi(player, PARENT_UI_REPORT_MENU);
            CuiHelper.DestroyUi(player, PARENT_UI_PLAYER_PANEL);
            CuiHelper.DestroyUi(player, PARENT_UI_PLAYER_REPORT);
            CuiHelper.DestroyUi(player, PARENT_UI_MODER_REPORT);
            CuiHelper.DestroyUi(player, PARENT_UI_ALERT_SEND);
            CuiHelper.DestroyUi(player, PARENT_UI_MODERATOR_MINI_PANEL);
            CuiHelper.DestroyUi(player, UI_MODERATION_CHECK_MENU_DISCORD);
            CuiHelper.DestroyUi(player, UI_MODERATION_CHECK_MENU_NETWORK);
            CuiHelper.DestroyUi(player, UI_MODERATION_RAITING);
        }

        #endregion

        #region Helps

        #region PluginsAPI

        void VKSendMessage(string Message)
        {
            if (!config.Setting.VKMessage) return;
            var VK = config.Setting.VKSettings;
            if (String.IsNullOrEmpty(VK.ChatID) || String.IsNullOrEmpty(VK.Token))
            {
                PrintWarning("Вы не настроили конфигурацию,в пункте с ВК");
                return;
            }
            int RandomID = UnityEngine.Random.Range(0, 9999);
            while (Message.Contains("#"))
                Message = Message.Replace("#", "%23");
            webrequest.Enqueue($"https://api.vk.com/method/messages.send?chat_id={VK.ChatID}&random_id={RandomID}&message={Message}&access_token={VK.Token}&v=5.92", null, (code, response) => { }, this);
        }

        void DiscordSendMessage(string key, ulong userID = 0, params object[] args)
        {
            if (!config.Setting.DiscrodMessage) return;
            if (String.IsNullOrEmpty(config.Setting.WebHook)) return;

            List<Fields> fields = new List<Fields>
                {
                    new Fields("IQReportSystem", key, true),
                };

            FancyMessage newMessage = new FancyMessage(null, false, new FancyMessage.Embeds[1] { new FancyMessage.Embeds(null, 635133, fields, new Authors("IQReportSystem", "https://vk.com/mercurydev", "https://i.imgur.com/ILk3uJc.png", null), new Footer("Author: Mercury[https://vk.com/mercurydev]", "https://i.imgur.com/ILk3uJc.png", null)) });
            Request($"{config.Setting.WebHook}", newMessage.toJSON());
        }

        #region FancyDiscord
        public class FancyMessage
        {
            public string content { get; set; }
            public bool tts { get; set; }
            public Embeds[] embeds { get; set; }

            public class Embeds
            {
                public string title { get; set; }
                public int color { get; set; }
                public List<Fields> fields { get; set; }
                public Footer footer { get; set; }
                public Authors author { get; set; }

                public Embeds(string title, int color, List<Fields> fields, Authors author, Footer footer)
                {
                    this.title = title;
                    this.color = color;
                    this.fields = fields;
                    this.author = author;
                    this.footer = footer;

                }
            }

            public FancyMessage(string content, bool tts, Embeds[] embeds)
            {
                this.content = content;
                this.tts = tts;
                this.embeds = embeds;
            }

            public string toJSON() => JsonConvert.SerializeObject(this);
        }

        public class Footer
        {
            public string text { get; set; }
            public string icon_url { get; set; }
            public string proxy_icon_url { get; set; }
            public Footer(string text, string icon_url, string proxy_icon_url)
            {
                this.text = text;
                this.icon_url = icon_url;
                this.proxy_icon_url = proxy_icon_url;
            }
        }

        public class Authors
        {
            public string name { get; set; }
            public string url { get; set; }
            public string icon_url { get; set; }
            public string proxy_icon_url { get; set; }
            public Authors(string name, string url, string icon_url, string proxy_icon_url)
            {
                this.name = name;
                this.url = url;
                this.icon_url = icon_url;
                this.proxy_icon_url = proxy_icon_url;
            }
        }

        public class Fields
        {
            public string name { get; set; }
            public string value { get; set; }
            public bool inline { get; set; }
            public Fields(string name, string value, bool inline)
            {
                this.name = name;
                this.value = value;
                this.inline = inline;
            }
        }

        private void Request(string url, string payload, Action<int> callback = null)
        {
            Dictionary<string, string> header = new Dictionary<string, string>();
            header.Add("Content-Type", "application/json");
            webrequest.Enqueue(url, payload, (code, response) =>
            {
                if (code != 200 && code != 204)
                {
                    if (response != null)
                    {
                        try
                        {
                            JObject json = JObject.Parse(response);
                            if (code == 429)
                            {
                                float seconds = float.Parse(Math.Ceiling((double)(int)json["retry_after"] / 1000).ToString());
                            }
                            else
                            {
                                PrintWarning($" Discord rejected that payload! Responded with \"{json["message"].ToString()}\" Code: {code}");
                            }
                        }
                        catch
                        {
                            PrintWarning($"Failed to get a valid response from discord! Error: \"{response}\" Code: {code}");
                        }
                    }
                    else
                    {
                        PrintWarning($"Discord didn't respond (down?) Code: {code}");
                    }
                }
                try
                {
                    callback?.Invoke(code);
                }
                catch (Exception ex) { }

            }, this, RequestMethod.POST, header);
        }
        #endregion

        int API_GET_REPORT_COUNT(ulong UserID)
        {
            var User = ReportInformation[UserID];
            return User.ReportCount;
        }
        int API_GET_CHECK_COUNT(ulong UserID)
        {
            var User = ReportInformation[UserID];
            return User.CheckCount;
        }
        List<string> API_GET_LIST_API(ulong UserID)
        {
            var User = ReportInformation[UserID];
            return User.IP;
        }
        string API_GET_GAME_STATUS(ulong UserID)
        {
            var User = ReportInformation[UserID];
            return User.GameStatus;
        }
        string API_GET_LAST_CHECK_MODERATOR(ulong UserID)
        {
            var User = ReportInformation[UserID];
            return User.LastCheckModerator;
        }
        string API_GET_LAST_REPORT(ulong UserID)
        {
            var User = ReportInformation[UserID];
            return User.LastReport;
        }
        List<string> API_GET_REPORT_HISTORY(ulong UserID)
        {
            var User = ReportInformation[UserID];
            return User.ReportHistory;
        }

        #endregion

        #region MSG
        public void SendChat(BasePlayer player,string Message, Chat.ChatChannel channel = Chat.ChatChannel.Global)
        {
            var Chat = config.Setting.ChatSetting;
            if (IQChat)
                IQChat?.Call("API_ALERT_PLAYER", player, Message, Chat.CustomPrefix, Chat.CustomAvatar);
            else player.SendConsoleCommand("chat.add", channel, 0, Message);
        }

        #endregion

        #region Hex
        private static string HexToRustFormat(string hex)
        {
            Color color;
            ColorUtility.TryParseHtmlString(hex, out color);
            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }
        #endregion

        #region Steam

        string IsSteam(string id)
        {        
            if (MultiFighting != null)
            {
                var player = BasePlayer.Find(id);
                if (player == null)
                {
                    return "ERROR #1";
                }
                var obj = MultiFighting.CallHook("IsSteam", player.Connection);
                if (obj is bool)
                {
                    if ((bool)obj)
                    {
                        return lang.GetMessage("IS_STEAM_STATUS_LICENSE", this, id); 
                    }
                    else
                    {
                        return lang.GetMessage("IS_STEAM_STATUS_PIRATE",this,id);
                    }
                }
                else
                {
                    return "ERROR #2";
                }
            }
            else return lang.GetMessage("IS_STEAM_STATUS_LICENSE", this, id);
        }

        #endregion

        #region Format

        static DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        static double CurrentTime() => DateTime.UtcNow.Subtract(epoch).TotalSeconds;

        public static string FormatTime(TimeSpan time)
        {
            string result = string.Empty;
            if (time.Days != 0)
                result += $"{Format(time.Days, "дней", "дня", "день")} ";

            if (time.Hours != 0)
                result += $"{Format(time.Hours, "часов", "часа", "час")} ";

            if (time.Minutes != 0)
                result += $"{Format(time.Minutes, "минут", "минуты", "минута")} ";

            if (time.Seconds != 0)
                result += $"{Format(time.Seconds, "секунд", "секунды", "секунда")} ";

            return result;
        }

        private static string Format(int units, string form1, string form2, string form3)
        {
            var tmp = units % 10;

            if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                return $"{units} {form1}";

            if (tmp >= 2 && tmp <= 4)
                return $"{units} {form2}";

            return $"{units} {form3}";
        }

        #endregion

        #endregion
    }
}


// --- End of file: IQReportSystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/MagicDescription.cs ---
// --- Original Local Path: TrashRust/MagicDescription.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace Oxide.Plugins
{
    [Info("Magic Description", "Wulf/lukespragg", "1.4.0")]
    [Description("Adds dynamic information in the server description")]
    public class MagicDescription : RustPlugin
    {
        #region Configuration

        private Configuration config;

        public class Configuration
        {
            [JsonProperty(PropertyName = "Server description")]
            public string Description { get; set; } = "Powered by Oxide {magic.version} for Rust {magic.version protocol}";

            [JsonProperty(PropertyName = "Update interval (seconds)")]
            public int UpdateInterval { get; set; } = 20;

            [JsonProperty(PropertyName = "Show loaded plugins (true/false)")]
            public bool ShowPlugins { get; set; } = false;

            [JsonProperty(PropertyName = "Hidden plugins (filename or title)")]
            public List<string> HiddenPlugins { get; set; } = new List<string>();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            string configPath = $"{Interface.Oxide.ConfigDirectory}{Path.DirectorySeparatorChar}{Name}.json";
            PrintWarning($"Could not load a valid configuration file, creating a new configuration file at {configPath}");
            config = new Configuration();
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion Configuration

        #region Initialization

        private static readonly Regex varRegex = new Regex(@"\{(.*?)\}");
        private static bool serverInitialized;

        private void OnServerInitialized()
        {
            serverInitialized = true;

            UpdateDescription();
            timer.Every(config.UpdateInterval, () => UpdateDescription());

            if (!config.ShowPlugins)
            {
                Unsubscribe(nameof(OnPluginLoaded));
                Unsubscribe(nameof(OnPluginUnloaded));
            }
        }

        private void OnServerSave() => SaveConfig();

        #endregion Initialization

        #region Description Handling

        private string UpdateDescription(string text = "")
        {
            if (!string.IsNullOrEmpty(text))
            {
                config.Description = text;
            }

            StringBuilder newDescription = new StringBuilder(config.Description);

            foreach (Match match in varRegex.Matches(config.Description))
            {
                string command = match.Groups[1].Value;

                if (!string.IsNullOrEmpty(command))
                {
                    string reply = ConsoleSystem.Run(ConsoleSystem.Option.Server.Quiet(), command);
                    newDescription.Replace(match.ToString(), reply.Replace("\"", "") ?? "");
                }
            }

            if (config.ShowPlugins)
            {
                Plugin[] loadedPlugins = plugins.GetAll();

                if (loadedPlugins.Length != 0)
                {
                    int count = 0;
                    string pluginList = null;

                    foreach (Plugin plugin in loadedPlugins.Where(p => !p.IsCorePlugin))
                    {
                        if (!config.HiddenPlugins.Contains(plugin.Title) && !config.HiddenPlugins.Contains(plugin.Name))
                        {
                            pluginList += plugin.Title + ", ";
                            count++;
                        }
                    }
                    if (pluginList != null)
                    {
                        if (pluginList.EndsWith(", "))
                        {
                            pluginList = pluginList.Remove(pluginList.Length - 2);
                        }
                        newDescription.Append($"\n\nPlugins ({count}): {pluginList}");
                    }
                }
            }

            if (newDescription.ToString() != ConVar.Server.description)
            {
                ConVar.Server.description = newDescription.ToString();
                Puts($"Server description updated: \nmagic.description: \"{config.Description}\"");
            }

            return ConVar.Server.description;
        }

        private void OnPluginLoaded(Plugin plugin)
        {
            if (serverInitialized)
            {
                UpdateDescription();
            }
        }

        private void OnPluginUnloaded(Plugin plugin)
        {
            if (serverInitialized)
            {
                UpdateDescription();
            }
        }

        #endregion Description Handling

        #region Command Handling

        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            if (!serverInitialized || !arg.IsAdmin || arg.cmd.FullName != "server.description")
            {
                return null;
            }

            if (!arg.HasArgs() || arg.Args.GetValue(0) == null)
            {
                return null;
            }

            string magicDescription = string.Join(" ", arg.Args.ToArray());
            arg.ReplyWith($"server.description: \"{UpdateDescription(magicDescription)}\"");

            return true;
        }

        [ConsoleCommand("magic.description")]
        private void DescriptionCommand(ConsoleSystem.Arg arg)
        {
            if (arg.IsAdmin)
            {
                arg.ReplyWith($"magic.description: \"{config.Description}\"");
            }
        }

        [ConsoleCommand("magic.version")]
        private void VersionCommand(ConsoleSystem.Arg arg)
        {
            if (arg.IsAdmin)
            {
                switch (arg.FullString.ToLower())
                {
                    case "rust":
                    case "protocol":
                        arg.ReplyWith(Rust.Protocol.printable);
                        break;

                    case "branch":
                        arg.ReplyWith(Facepunch.BuildInfo.Current.Scm.Branch);
                        break;

                    case "date":
                    case "builddate":
                        arg.ReplyWith(Facepunch.BuildInfo.Current.BuildDate.ToLocalTime().ToString());
                        break;

                    default:
                        arg.ReplyWith(OxideMod.Version.ToString());
                        break;
                }
            }
        }

        #endregion Command Handling
    }
}


// --- End of file: MagicDescription.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/TimedEvents.cs ---
// --- Original Local Path: TrashRust/TimedEvents.cs ---

using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Timed Events", "Orange", "1.1.1")]
    [Description("Triggers various types of events like Airdrops, Helicopters and same")]
    public class TimedEvents : RustPlugin
    {
        #region Vars

        private const string prefabCH47 = "assets/prefabs/npc/ch47/ch47scientists.entity.prefab";
        private const string prefabPlane = "assets/prefabs/npc/cargo plane/cargo_plane.prefab";
        private const string prefabShip = "assets/content/vehicles/boats/cargoship/cargoshiptest.prefab";
        private const string prefabPatrol = "assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab";

        #endregion
        
        #region Oxide Hooks

        private void OnServerInitialized()
        {
            SpawnTank(true);
            SpawnShip(true);
            SpawnPatrol(true);
            SpawnPlane(true);
            SpawnCH47(true);
        }

        private void OnEntitySpawned(SupplySignal entity)
        {
            DelaySubscribe(10);
        }
        
        private void OnEntitySpawned(CargoPlane entity)
        {
            if (entity.OwnerID == 0 && config.plane.disableDefault)
            {
                entity.Kill();
            }
        }
        
        private void OnEntitySpawned(CargoShip entity)
        {
            if (entity.OwnerID == 0 && config.ship.disableDefault)
            {
                entity.Kill();
            }
        }
        
        private void OnEntitySpawned(BradleyAPC entity)
        {
            if (entity.OwnerID == 0 && config.tank.disableDefault)
            {
                entity.Kill();
            }
        }
        
        private void OnEntitySpawned(BaseHelicopter entity)
        {
            if (entity.OwnerID == 0 && config.patrol.disableDefault)
            {
                entity.Kill();
            }
        }
        
        private void OnEntitySpawned(CH47Helicopter entity)
        {
            if (entity.OwnerID == 0 && config.ch47.disableDefault)
            {
                timer.Once(1f, () => { entity.Kill(); });
            }
        }

        #endregion

        #region Core

        private void DelaySubscribe(int time = 0)
        {
            Unsubscribe("OnEntitySpawned");
            
            timer.Once(time, () =>
            {
                Subscribe("OnEntitySpawned");
            });
        }

        private void SpawnTank(bool skipSpawn = false)
        {
            if (Online() >= config.tank.playersMin && skipSpawn == false)
            {
                DelaySubscribe(1);
                BradleySpawner.singleton?.SpawnBradley();
            }

            var time = Core.Random.Range(config.tank.timerMin, config.tank.timerMax);
            timer.Once(time, () => SpawnTank());
        }

        private void SpawnShip(bool skipSpawn = false)
        {
            if (Online() >= config.ship.playersMin && skipSpawn == false)
            {
                var amount = Core.Random.Range(config.ship.spawnMin, config.ship.spawnMax);
                DelaySubscribe(1);

                for (var i = 0; i < amount; i++)
                {
                    var x = TerrainMeta.Size.x;
                    var vector3 = Vector3Ex.Range(-1f, 1f);
                    vector3.y = 0.0f;
                    vector3.Normalize();
                    var worldPos = vector3 * (x * 1f);
                    worldPos.y = TerrainMeta.WaterMap.GetHeight(worldPos);
                    var entity = GameManager.server.CreateEntity(prefabShip, worldPos);
                    entity?.Spawn();
                }
            }

            var time = Core.Random.Range(config.ship.timerMin, config.ship.timerMax);
            timer.Once(time, () => SpawnShip());
        }

        private void SpawnPatrol(bool skipSpawn = false)
        {
            if (Online() >= config.patrol.playersMin && skipSpawn == false)
            {
                var amount = Core.Random.Range(config.patrol.spawnMin, config.patrol.spawnMax);
                DelaySubscribe(1);
            
                for (var i = 0; i < amount; i++)
                {
                    var position = new Vector3(ConVar.Server.worldsize, 100, ConVar.Server.worldsize) - new Vector3(50f, 0f, 50f);
                    var entity = GameManager.server.CreateEntity(prefabPatrol, position);
                    entity?.Spawn();
                }
            }
            
            var time = Core.Random.Range(config.patrol.timerMin, config.patrol.timerMax);
            timer.Once(time, () => SpawnPatrol());
        }

        private void SpawnPlane(bool skipSpawn = false)
        {
            if (Online() >= config.plane.playersMin && skipSpawn == false)
            {
                var amount = Core.Random.Range(config.plane.spawnMin, config.plane.spawnMax);
                DelaySubscribe(1);
            
                for (var i = 0; i < amount; i++)
                {
                    var position = new Vector3(ConVar.Server.worldsize, 100, ConVar.Server.worldsize) - new Vector3(50f, 0f, 50f);
                    var entity = GameManager.server.CreateEntity(prefabPlane, position);
                    entity?.Spawn();
                }
            }
            
            var time = Core.Random.Range(config.plane.timerMin, config.plane.timerMax);
            timer.Once(time, () => SpawnPlane());
        }
        
        private void SpawnCH47(bool skipSpawn = false)
        {
            if (Online() >= config.ch47.playersMin && skipSpawn == false)
            {
                var amount = Core.Random.Range(config.ch47.spawnMin, config.ch47.spawnMax);
                DelaySubscribe(1);
            
                for (var i = 0; i < amount; i++)
                {
                    var position = new Vector3(ConVar.Server.worldsize, 100, ConVar.Server.worldsize) - new Vector3(50f, 0f, 50f);
                    var entity = GameManager.server.CreateEntity(prefabCH47, position) as CH47HelicopterAIController;
                    entity?.TriggeredEventSpawn();
                    entity?.Spawn();
                }
            }
            
            var time = Core.Random.Range(config.ch47.timerMin, config.ch47.timerMax);
            timer.Once(time, () => SpawnCH47());
        }

        private int Online()
        {
            return BasePlayer.activePlayerList.Count;
        }

        #endregion

        #region Configuration

        private static ConfigData config;
        
        private class ConfigData
        {    
            [JsonProperty(PropertyName = "1. Cargo plane settings:")]
            public EventSettings plane;
            
            [JsonProperty(PropertyName = "2. Patrol Helicopter settings:")]
            public EventSettings patrol;
            
            [JsonProperty(PropertyName = "3. Bradley APC settings:")]
            public EventSettings tank;
            
            [JsonProperty(PropertyName = "4. CH47 settings:")]
            public EventSettings ch47;
            
            [JsonProperty(PropertyName = "5. Cargo ship settings:")]
            public EventSettings ship;
        }
        
        private class EventSettings
        {
            [JsonProperty(PropertyName = "1. Disable default spawns")]
            public bool disableDefault;
                
            [JsonProperty(PropertyName = "2. Minimal respawn time (in seconds)")]
            public int timerMin;
                
            [JsonProperty(PropertyName = "3. Maximal respawn time (in seconds)")]
            public int timerMax;
                
            [JsonProperty(PropertyName = "4. Minimal amount that spawned by once")]
            public int spawnMin;
                
            [JsonProperty(PropertyName = "5. Maximal amount that spawned by once")]
            public int spawnMax;
                
            [JsonProperty(PropertyName = "6. Minimal players to start event")]
            public int playersMin;
        }
        
        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                plane = new EventSettings
                {
                    disableDefault = false,
                    playersMin = 0,
                    timerMax = 7200,
                    timerMin = 3600,
                    spawnMax = 1,
                    spawnMin = 1
                },
                patrol = new EventSettings
                {
                    disableDefault = false,
                    playersMin = 0,
                    timerMax = 7200,
                    timerMin = 3600,
                    spawnMax = 1,
                    spawnMin = 1
                },
                tank = new EventSettings
                {
                    disableDefault = false,
                    playersMin = 0,
                    timerMax = 7200,
                    timerMin = 3600,
                    spawnMax = 1,
                    spawnMin = 1
                },
                ch47 = new EventSettings
                {
                    disableDefault = false,
                    playersMin = 0,
                    timerMax = 7200,
                    timerMin = 3600,
                    spawnMax = 1,
                    spawnMin = 1
                },
                ship = new EventSettings
                {
                    disableDefault = false,
                    playersMin = 0,
                    timerMax = 7200,
                    timerMin = 3600,
                    spawnMax = 1,
                    spawnMin = 1
                }
            };
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
   
            try
            {
                config = Config.ReadObject<ConfigData>();
            }
            catch
            {
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintError("Configuration file is corrupt(or not exists), creating new one!");
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
    }
}

// --- End of file: TimedEvents.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/InfoTabs.cs ---
// --- Original Local Path: TrashRust/InfoTabs.cs ---

using Newtonsoft.Json.Linq;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("InfoTabs", "VooDoo", "1.0.0")]
    [Description("Rules and Commands for XMenu")]
    public class InfoTabs : RustPlugin
    {
        [PluginReference] Plugin XMenu;


        #region Config
        private PluginConfig config;
        private class PluginConfig
        {
            public ColorConfig colorConfig;
            public class ColorConfig
            {
                public string menuContentHighlighting;
                public string menuContentHighlightingalternative;

                public string menuContentText;
                public string menuContentTextAlternative;

                public string gradientColor;
            }

            public Dictionary<string, string> commandsTab;
            public Dictionary<string, string> ranksTab;
            public Dictionary<string, string> bindsTab;

            public List<string> rulesTab;

            public int groupID;
            public string authToken;
        }

        private void Init()
        {
            config = Config.ReadObject<PluginConfig>();
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                colorConfig = new PluginConfig.ColorConfig()
                {
                    menuContentHighlighting = "#0000007f",
                    menuContentHighlightingalternative = "#FFFFFF10",
                    menuContentTextAlternative = "#90BD47",
                    menuContentText = "#FFFFFFAA",
                    gradientColor = "#00000099",
                },
                commandsTab = new Dictionary<string, string>()
                {
                    ["custommenu"] = "Открыть это меню",
                },
                bindsTab = new Dictionary<string, string>()
                {
                    ["bind z custommenu"] = "Открыть это меню",
                },
                ranksTab = new Dictionary<string, string>()
                {
                    ["bind z custommenu"] = "Открыть это меню",
                },
                rulesTab = new List<string>()
                {
                    "Текст",
                },
                authToken = "",
                groupID = 0
            };
        }
        #endregion

        #region Layers
        public const string MenuLayer = "XMenu";
        public const string MenuItemsLayer = "XMenu.MenuItems";
        public const string MenuSubItemsLayer = "XMenu.MenuSubItems";
        public const string MenuContent = "XMenu.Content";
        #endregion

        Timer TimerInitialize;
        private void OnServerInitialized()
        {
            TimerInitialize = timer.Every(5f, () =>
            {
                if (XMenu.IsLoaded)
                {
                    XMenu.Call("API_RegisterSubMenu", this.Name, "Main", "Правила", "RenderRules", null);
                    XMenu.Call("API_RegisterSubMenu", this.Name, "Main", "Команды", "RenderCommands", null);
                    XMenu.Call("API_RegisterSubMenu", this.Name, "Main", "Новости", "RenderNews", null);

                    int RulesID = (int)XMenu.Call("API_GetSubMenuID", "Main", "Информация");
                    cmd.AddChatCommand("help", this, (p, cmd, args) => rust.RunClientCommand(p, $"custommenu true Main {RulesID}"));

                    TimerInitialize.Destroy();
                }
            });
        }

        private void RenderCommands(ulong userID, object[] objects)
        {
            CuiElementContainer Container = (CuiElementContainer)objects[0];
            bool FullRender = (bool)objects[1];
            string Name = (string)objects[2];
            int ID = (int)objects[3];
            int Page = (int)objects[4];

            Container.Add(new CuiElement
            {
                Name = MenuContent,
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0 0 0 0",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-215 -230",
                            OffsetMax = "500 270"
                        },
                    }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info",
                Parent = MenuContent,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "80 -460",
                            OffsetMax = "630 -10"
                        }
                    }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Title",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"<color={config.colorConfig.menuContentTextAlternative}>Команда</color>",
                                Align = TextAnchor.MiddleLeft,
                                FontSize = 24,
                                Font = "robotocondensed-bold.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.05 0.9",
                                AnchorMax = "0.975 0.975",
                            },
                            new CuiOutlineComponent()
                            {
                                 Color = "0 0 0 1",
                                 Distance = "0.5 -0.5"
                            }
                        }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Title",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"<color={config.colorConfig.menuContentText}>Описание</color>",
                                Align = TextAnchor.MiddleLeft,
                                FontSize = 24,
                                Font = "robotocondensed-bold.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.4 0.9",
                                AnchorMax = "0.95 0.975",
                            },
                            new CuiOutlineComponent()
                            {
                                 Color = "0 0 0 1",
                                 Distance = "0.5 -0.5"
                            }
                        }
            });

            string Commands = $"<color={config.colorConfig.menuContentTextAlternative}>";
            string Info = $"<color={config.colorConfig.menuContentText}>";
            for (int i = 0, x = 0; i < config.commandsTab.Count; i++)
            {
                if(Page * 27 > i)
                    continue;

                if (x > 26)
                    continue;

                Commands += $"{config.commandsTab.ElementAt(i).Key}\n";
                Info += $"{config.commandsTab.ElementAt(i).Value}\n";

                x++;
            }

            Commands += "</color>";
            Info += "</color>";

            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Text",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = Commands,
                                Align = TextAnchor.UpperLeft,
                                FontSize = 12,
                                Font = "robotocondensed-bold.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.05 0",
                                AnchorMax = "0.375 0.88",
                            },
                            new CuiOutlineComponent()
                            {
                                 Color = "0 0 0 1",
                                 Distance = "0.5 -0.5"
                            }
                        }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Text",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = Info,
                                Align = TextAnchor.UpperLeft,
                                FontSize = 12,
                                Font = "robotocondensed-bold.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.4 0",
                                AnchorMax = "0.95 0.88",
                            },
                            new CuiOutlineComponent()
                            {
                                 Color = "0 0 0 1",
                                 Distance = "0.5 -0.5"
                            }
                        }
            });

            if ((int)Page > 0)
            {
                Container.Add(new CuiElement
                {
                    Name = MenuContent + ".BackTitle",
                    Parent = MenuContent,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "80 -500",
                            OffsetMax = "110 -470"
                        }
                    }
                });
                Container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = $"custommenu false Main {ID} {(int)Page - 1}", },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = "<", Align = TextAnchor.MiddleCenter, FontSize = 20 }
                }, MenuContent + ".BackTitle", MenuContent + ".BackTitleBtn");
            }
            if ((int)(Page * 27) + 27 < config.commandsTab.Count)
            {
                Container.Add(new CuiElement
                {
                    Name = MenuContent + ".NextTitle",
                    Parent = MenuContent,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "600 -500",
                            OffsetMax = "630 -470"
                        }
                    }
                });
                Container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = $"custommenu false Main {ID} {(int)Page + 1}", },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = ">", Align = TextAnchor.MiddleCenter, FontSize = 20 }
                }, MenuContent + ".NextTitle", MenuContent + ".NextTitleBtn");
            }
        }

        private void RenderRanks(ulong userID, object[] objects)
        {
            CuiElementContainer Container = (CuiElementContainer)objects[0];
            bool FullRender = (bool)objects[1];
            string Name = (string)objects[2];
            int ID = (int)objects[3];
            int Page = (int)objects[4];

            Container.Add(new CuiElement
            {
                Name = MenuContent,
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0 0 0 0",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-215 -230",
                            OffsetMax = "500 270"
                        },
                    }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info",
                Parent = MenuContent,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "80 -460",
                            OffsetMax = "630 -10"
                        }
                    }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Title",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"<color={config.colorConfig.menuContentText}>Требования</color>",
                                Align = TextAnchor.MiddleLeft,
                                FontSize = 24,
                                Font = "robotocondensed-bold.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.4 0.9",
                                AnchorMax = "0.65 0.975",
                            },
                            new CuiOutlineComponent()
                            {
                                 Color = "0 0 0 1",
                                 Distance = "0.5 -0.5"
                            }
                        }
            });
			
			Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Title",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"<color={config.colorConfig.menuContentText}>Зарплаты</color>",
                                Align = TextAnchor.MiddleLeft,
                                FontSize = 24,
                                Font = "robotocondensed-bold.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.7 0.9",
                                AnchorMax = "0.95 0.975",
                            },
                            new CuiOutlineComponent()
                            {
                                 Color = "0 0 0 1",
                                 Distance = "0.5 -0.5"
                            }
                        }
            });

            string Ranks = $"<color={config.colorConfig.menuContentTextAlternative}>";
            string Info = $"<color={config.colorConfig.menuContentText}>";
			string Third = $"<color={config.colorConfig.menuContentText}>";
            for (int i = 0, x = 0; i < config.ranksTab.Count; i++)
            {
                if (Page * 27 > i)
                    continue;

                if (x > 26)
                    continue;

                Ranks += $"{config.ranksTab.ElementAt(i).Key}\n";
                Info += $"{config.ranksTab.ElementAt(i).Value.Split('|')[0]}\n";
				Third += $"{config.ranksTab.ElementAt(i).Value.Split('|')[1]}\n";
                x++;
            }

            Ranks += "</color>";
            Info += "</color>";
			Third += "</color>";
			
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Text",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = Ranks,
                                Align = TextAnchor.UpperLeft,
                                FontSize = 12,
                                Font = "robotocondensed-bold.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.05 0",
                                AnchorMax = "0.375 0.88",
                            },
                            new CuiOutlineComponent()
                            {
                                 Color = "0 0 0 1",
                                 Distance = "0.4 -0.5"
                            }
                        }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Text",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = Info,
                                Align = TextAnchor.UpperLeft,
                                FontSize = 12,
                                Font = "robotocondensed-bold.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.4 0",
                                AnchorMax = "0.75 0.88",
                            },
                            new CuiOutlineComponent()
                            {
                                 Color = "0 0 0 1",
                                 Distance = "0.5 -0.5"
                            }
                        }
            });
			
			            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Text",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = Third,
                                Align = TextAnchor.UpperLeft,
                                FontSize = 12,
                                Font = "robotocondensed-bold.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.7 0",
                                AnchorMax = "0.95 0.88",
                            },
                            new CuiOutlineComponent()
                            {
                                 Color = "0 0 0 1",
                                 Distance = "0.5 -0.5"
                            }
                        }
            });

            if ((int)Page > 0)
            {
                Container.Add(new CuiElement
                {
                    Name = MenuContent + ".BackTitle",
                    Parent = MenuContent,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "80 -500",
                            OffsetMax = "110 -470"
                        }
                    }
                });
                Container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = $"custommenu false Main {ID} {(int)Page - 1}", },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = "<", Align = TextAnchor.MiddleCenter, FontSize = 20 }
                }, MenuContent + ".BackTitle", MenuContent + ".BackTitleBtn");
            }
            if ((int)(Page * 27) + 27 < config.ranksTab.Count)
            {
                Container.Add(new CuiElement
                {
                    Name = MenuContent + ".NextTitle",
                    Parent = MenuContent,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "600 -500",
                            OffsetMax = "630 -470"
                        }
                    }
                });
                Container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = $"custommenu false Main {ID} {(int)Page + 1}", },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = ">", Align = TextAnchor.MiddleCenter, FontSize = 20 }
                }, MenuContent + ".NextTitle", MenuContent + ".NextTitleBtn");
            }
        }

        private void RenderBinds(ulong userID, object[] objects)
        {
            CuiElementContainer Container = (CuiElementContainer)objects[0];
            bool FullRender = (bool)objects[1];
            string Name = (string)objects[2];
            int ID = (int)objects[3];
            int Page = (int)objects[4];

            Container.Add(new CuiElement
            {
                Name = MenuContent,
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0 0 0 0",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-215 -230",
                            OffsetMax = "500 270"
                        },
                    }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info",
                Parent = MenuContent,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "80 -460",
                            OffsetMax = "630 -10"
                        }
                    }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Title",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"<color={config.colorConfig.menuContentTextAlternative}>Бинд</color>",
                                Align = TextAnchor.MiddleLeft,
                                FontSize = 24,
                                Font = "robotocondensed-bold.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.05 0.9",
                                AnchorMax = "0.975 0.975",
                            },
                            new CuiOutlineComponent()
                            {
                                 Color = "0 0 0 1",
                                 Distance = "0.5 -0.5"
                            }
                        }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Title",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"<color={config.colorConfig.menuContentText}>Описание</color>",
                                Align = TextAnchor.MiddleLeft,
                                FontSize = 24,
                                Font = "robotocondensed-bold.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.4 0.9",
                                AnchorMax = "0.95 0.975",
                            },
                            new CuiOutlineComponent()
                            {
                                 Color = "0 0 0 1",
                                 Distance = "0.5 -0.5"
                            }
                        }
            });

            string Commands = $"<color={config.colorConfig.menuContentTextAlternative}>";
            string Info = $"<color={config.colorConfig.menuContentText}>";
            for (int i = 0, x = 0; i < config.bindsTab.Count; i++)
            {
                if (Page * 27 > i)
                    continue;

                if (x > 26)
                    continue;

                Commands += $"{config.bindsTab.ElementAt(i).Key}\n";
                Info += $"{config.bindsTab.ElementAt(i).Value}\n";

                x++;
            }

            Commands += "</color>";
            Info += "</color>";

            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Text",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = Commands,
                                Align = TextAnchor.UpperLeft,
                                FontSize = 12,
                                Font = "robotocondensed-bold.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.05 0",
                                AnchorMax = "0.375 0.88",
                            },
                            new CuiOutlineComponent()
                            {
                                 Color = "0 0 0 1",
                                 Distance = "0.5 -0.5"
                            }
                        }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Text",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = Info,
                                Align = TextAnchor.UpperLeft,
                                FontSize = 12,
                                Font = "robotocondensed-bold.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.4 0",
                                AnchorMax = "0.95 0.88",
                            },
                            new CuiOutlineComponent()
                            {
                                 Color = "0 0 0 1",
                                 Distance = "0.5 -0.5"
                            }
                        }
            });

            if ((int)Page > 0)
            {
                Container.Add(new CuiElement
                {
                    Name = MenuContent + ".BackTitle",
                    Parent = MenuContent,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "80 -500",
                            OffsetMax = "110 -470"
                        }
                    }
                });
                Container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = $"custommenu false Main {ID} {(int)Page - 1}", },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = "<", Align = TextAnchor.MiddleCenter, FontSize = 20 }
                }, MenuContent + ".BackTitle", MenuContent + ".BackTitleBtn");
            }
            if ((int)(Page * 27) + 27 < config.bindsTab.Count)
            {
                Container.Add(new CuiElement
                {
                    Name = MenuContent + ".NextTitle",
                    Parent = MenuContent,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "600 -550",
                            OffsetMax = "630 -520"
                        }
                    }
                });
                Container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = $"custommenu false Main {ID} {(int)Page + 1}", },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = ">", Align = TextAnchor.MiddleCenter, FontSize = 20 }
                }, MenuContent + ".NextTitle", MenuContent + ".NextTitleBtn");
            }
        }

        private void RenderRules(ulong userID, object[] objects)
        {
            CuiElementContainer Container = (CuiElementContainer)objects[0];
            bool FullRender = (bool)objects[1];
            string Name = (string)objects[2];
            int ID = (int)objects[3];
            int Page = (int)objects[4];

            Container.Add(new CuiElement
            {
                Name = MenuContent,
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0 0 0 0",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-215 -230",
                            OffsetMax = "500 270"
                        },
                    }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info",
                Parent = MenuContent,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "80 -460",
                            OffsetMax = "630 -10"
                        }
                    }
            });

            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Title",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"<color={config.colorConfig.menuContentText}>Информация и правила | Страница №{Page+1}</color>",
                                Align = TextAnchor.MiddleCenter,
                                FontSize = 24,
                                Font = "robotocondensed-bold.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.05 0.9",
                                AnchorMax = "0.95 0.975",
                            }
                        }
            });

            string Info = $"<color={config.colorConfig.menuContentText}>";
            for (int i = 0, x = 0; i < config.rulesTab.Count; i++)
            {
                if (Page * 27 > i)
                    continue;

                if (x > 26)
                    continue;

                Info += $"{config.rulesTab.ElementAt(i)}\n";

                x++;
            }
            Info += "</color>";

            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Text",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = Info,
                                Align = TextAnchor.UpperLeft,
                                FontSize = 12,
                                Font = "robotocondensed-bold.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.05 0",
                                AnchorMax = "0.95 0.88",
                            }
                        }
            });

            if ((int)Page > 0)
            {
                Container.Add(new CuiElement
                {
                    Name = MenuContent + ".BackTitle",
                    Parent = MenuContent,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "80 -500",
                            OffsetMax = "110 -470"
                        }
                    }
                });
                Container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = $"custommenu false Main {ID} {(int)Page - 1}", },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = "<", Align = TextAnchor.MiddleCenter, FontSize = 20 }
                }, MenuContent + ".BackTitle", MenuContent + ".BackTitleBtn");
            }
            if ((int)(Page * 27) + 27 < config.rulesTab.Count)
            {
                Container.Add(new CuiElement
                {
                    Name = MenuContent + ".NextTitle",
                    Parent = MenuContent,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "600 -500",
                            OffsetMax = "630 -470"
                        }
                    }
                });
                Container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = $"custommenu false Main {ID} {(int)Page + 1}", },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = ">", Align = TextAnchor.MiddleCenter, FontSize = 20 }
                }, MenuContent + ".NextTitle", MenuContent + ".NextTitleBtn");
            }
        }

        int NewsID = 0;
        private void RenderNews(ulong userID, object[] objects)
        {
            CuiElementContainer Container = (CuiElementContainer)objects[0];
            bool FullRender = (bool)objects[1];
            string Name = (string)objects[2];
            int ID = (int)objects[3];
            int Page = (int)objects[4];

            NewsID = (int)XMenu.Call("API_GetSubMenuID", "Main", "Новости");
            BasePlayer player = BasePlayer.FindByID(userID);
            Container.Add(new CuiElement
            {
                Name = MenuContent,
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-135 -190",
                            OffsetMax = "415 260"
                        },
                    }
            });

            if (Page > 0)
            {
                Container.Add(new CuiElement
                {
                    Name = MenuContent + ".BackTitle",
                    Parent = MenuContent,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "0 -490",
                            OffsetMax = "30 -460"
                        }
                    }
                });
                Container.Add(new CuiButton
                {
                    Button = { FadeIn = 0.5f, Color = "0 0 0 0", Command = $"custommenu false Main {NewsID} {Page - 1}", },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = "<", Align = TextAnchor.MiddleCenter, FontSize = 14 }
                }, MenuContent + ".BackTitle", MenuContent + ".BackTitleBtn");
            }
            if (Page < MaxOffset - 1)
            {
                Container.Add(new CuiElement
                {
                    Name = MenuContent + ".NextTitle",
                    Parent = MenuContent,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "520 -490",
                            OffsetMax = "550 -460"
                        }
                    }
                });
                Container.Add(new CuiButton
                {
                    Button = { FadeIn = 0.5f, Color = "0 0 0 0", Command = $"custommenu false Main {NewsID} {Page + 1}", },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = ">", Align = TextAnchor.MiddleCenter, FontSize = 14 }
                }, MenuContent + ".NextTitle", MenuContent + ".NextTitleBtn");
            }

            GetWall(player, Page + 0);
        }

        int MaxOffset = 2;
        public void GetWall(BasePlayer player, int offset)
        {
            Core.Libraries.WebRequests webRequest = new Core.Libraries.WebRequests();
            webRequest.Enqueue($"https://api.vk.com/method/wall.get?owner_id=-{config.groupID}&extended=0&v=5.92&offset={offset}&count=1&access_token={config.authToken}", null, (code, response) =>
            {
                JToken jToken = JObject.Parse(response);
                MaxOffset = int.Parse(jToken["response"]["count"].ToString());
                bool HasImagePost = jToken["response"]["items"]?.ElementAt(0)["attachments"]?.Count() > 0;
                CuiElementContainer Container = new CuiElementContainer();
                Container.Add(new CuiElement
                {
                    Name = MenuContent + ".Title",
                    Parent = MenuContent,
                    Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"<color=#fff9f9AA>{jToken["response"]["items"].ElementAt(0)["text"]}</color>",
                                Align = TextAnchor.UpperCenter,
                                FontSize = 17,
                                Font = "robotocondensed-bold.ttf",
                                FadeIn = 0.5f,
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.025 0.075",
                                AnchorMax = "0.975 0.675",
                            }
                        }
                });
                Container.Add(new CuiElement
                {
                    Name = MenuContent + ".Title",
                    Parent = MenuContent,
                    Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"<color=#fff9f9AA>{UnixTimeStampToDateTime(long.Parse(jToken["response"]["items"].ElementAt(0)["date"].ToString())).ToString("F")}</color>",
                                Align = TextAnchor.MiddleCenter,
                                FontSize = 17,
                                Font = "robotocondensed-bold.ttf",
                                FadeIn = 0.5f,
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.025 0.025",
                                AnchorMax = "0.975 0.075",
                            }
                        }
                });
                Container.Add(new CuiElement
                {
                    Name = MenuContent + ".Img",
                    Parent = MenuContent,
                    Components =
                        {
                            new CuiRawImageComponent
                            {
                                Color = "1 1 1 1",
                                Sprite = "assets/content/ui/menuui/rustlogo-blurred.png",
                                FadeIn = 0.5f,
                            },
                            new CuiRectTransformComponent
                            {
                                 AnchorMin = "0 1",
                                 AnchorMax = "0 1",
                                 OffsetMin = "137.5 -100",
                                 OffsetMax = "412.5 -25"
                            }
                        }
                });

                CuiHelper.AddUi(player, Container);
            }, this);
        }

        #region Utils
        public static DateTime UnixTimeStampToDateTime(double unixTimeStamp)
        {
            System.DateTime dtDateTime = new DateTime(1970, 1, 1, 0, 0, 0, 0, System.DateTimeKind.Utc);
            dtDateTime = dtDateTime.AddSeconds(unixTimeStamp).ToLocalTime();
            return dtDateTime;
        }

        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }
        #endregion
    }
}

// --- End of file: InfoTabs.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/WipeBlock.cs ---
// --- Original Local Path: TrashRust/WipeBlock.cs ---

using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("WipeBlock", "VooDoo", "1.0.0")]
    [Description("WipeBlock and Tab for XMenu")]
    public class WipeBlock : RustPlugin
    {
        [PluginReference] Plugin XMenu;
        [PluginReference] Plugin Notifications;
        public static WipeBlock instance;

        #region ImageLibrary Addon
        [PluginReference] Plugin ImageLibrary;
        bool AddImage(string url, string imageName, ulong imageId, Action callback = null) => (bool)ImageLibrary.Call("AddImage", url, imageName, imageId, callback);
        string GetImage(string imageName, ulong imageId = 0, bool returnUrl = false) => (string)ImageLibrary.Call("GetImage", imageName, imageId, returnUrl);
        #endregion

        #region Config
        private Dictionary<string, int> blockTime = new Dictionary<string, int>();
        private PluginConfig config;
        private class PluginConfig
        {
            public Dictionary<string, Dictionary<int, List<string>>> blockedItems;

            public ColorConfig colorConfig;
            public string serverName;
            public class ColorConfig
            {
                public string menuContentHighlighting;
                public string menuContentHighlightingalternative;

                public string menuContentText;
                public string menuContentTextAlternative;

                public string gradientColor;
            }
        }

        private void Init()
        {
            config = Config.ReadObject<PluginConfig>();
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                serverName = "<b>TRASH <color=#1d71ff>RUST</color> X20</b>",

                colorConfig = new PluginConfig.ColorConfig()
                {
                    menuContentHighlighting = "#0000007f",
                    menuContentHighlightingalternative = "#FFFFFF10",

                    menuContentTextAlternative = "#FFFFFFAA",
                    menuContentText = "#FFFFFFAA",

                    gradientColor = "#00000099",
                },

                blockedItems = new Dictionary<string, Dictionary<int, List<string>>>()
                {
                    ["Оружие"] = new Dictionary<int, List<string>>
                    {
                        [3600] = new List<string>
                        {
                            "crossbow",
                            "bow.compound",
                        },
                        [7200] = new List<string>
                        {
                            "shotgun.waterpipe",
                            "pistol.revolver",
                        },
                        [14400] = new List<string>
                        {
                            "pistol.semiauto",
                            "pistol.python",
                            "shotgun.double",
                            "shotgun.pump",
                        },
                        [28800] = new List<string>
                        {
                            "pistol.m92",
                            "shotgun.spas12",
                        },
                        [43200] = new List<string>
                        {

                            "rifle.semiauto",
                            "rifle.m39",
                        },
                        [57600] = new List<string>
                        {
                            "smg.2",
                            "smg.thompson",
                            "smg.mp5",
                            "surveycharge",
                            "grenade.beancan",
                            "grenade.f1",
                        },
                        [86400] = new List<string>
                        {
                            "rifle.bolt",
                            "rifle.ak",
                            "rifle.lr300",
                            "rifle.l96",
                            "lmg.m249",
                            "multiplegrenadelauncher",
                            "explosive.satchel",
                        },
                        [172800] = new List<string>
                        {
                            "rocket.launcher",
                            "explosive.timed"
                        },
                    },
                    ["Броня"] = new Dictionary<int, List<string>>
                    {
                        [57600] = new List<string>
                        {
                            "coffeecan.helmet",
                            "roadsign.jacket",
                            "roadsign.kilt"
                        },
                        [86400] = new List<string>
                        {
                            "metal.facemask",
                            "metal.plate.torso",
                            "heavy.plate.helmet",
                            "heavy.plate.jacket",
                            "heavy.plate.pants",
                        },
                    },
                    ["Боеприпасы"] = new Dictionary<int, List<string>>
                    {
                        [86400] = new List<string>
                        {
                            "ammo.rifle.explosive",
                        },
                        [172800] = new List<string>
                        {
                            "ammo.rocket.basic",
                            "ammo.rocket.fire",
                            "ammo.rocket.hv",
                        },
                    }
                }
            };
        }
        #endregion

        #region U'Mod Hook's
        private long SaveCreatedTime = 0;
        Timer TimerInitialize;
        private void OnServerInitialized()
        {
            instance = this;
            SaveCreatedTime = Interface.Oxide.DataFileSystem.ReadObject<long>("WipeBlock/WipeTime");
            if (SaveCreatedTime == 0)
            {
                SaveCreatedTime = ToEpoch(DateTime.UtcNow);
                Interface.Oxide.DataFileSystem.WriteObject("WipeBlock/WipeTime", SaveCreatedTime);
            }

            TimerInitialize = timer.Every(5f, () =>
            {
                if (XMenu.IsLoaded)
                {
                    XMenu.Call("API_RegisterMenu", this.Name, "WipeBlock", "assets/icons/bullet.png", "RenderWipeBlock", null);
                    cmd.AddChatCommand("wipeblock", this, (p, cmd, args) => rust.RunClientCommand(p, "custommenu true WipeBlock"));
                    TimerInitialize.Destroy();
                }
            });

            foreach (var category in config.blockedItems)
                foreach (var timeCategory in category.Value)
                    foreach (var item in timeCategory.Value)
                        blockTime.Add(item, timeCategory.Key);
        }

        private void OnNewSave()
        {
            SaveCreatedTime = ToEpoch(DateTime.UtcNow);
            Interface.Oxide.DataFileSystem.WriteObject("WipeBlock/WipeTime", SaveCreatedTime);
        }

        private bool? CanWearItem(PlayerInventory inventory, Item item)
        {

            var player = inventory.gameObject.ToBaseEntity() as BasePlayer;
            if (!player.userID.IsSteamId()) return null;

            var isBlocked = IsBlocked(item.info) > 0 ? false : (bool?)null;
            if (isBlocked == false) DrawBlock(player, item);
            return isBlocked;
        }

        private bool? CanEquipItem(PlayerInventory inventory, Item item)
        {
            var player = inventory.gameObject.ToBaseEntity() as BasePlayer;
            if (player == null || !player.userID.IsSteamId()) return null;
            if (player.IsAdmin) return null;

            var isBlocked = IsBlocked(item.info) > 0 ? false : (bool?)null;
            if (isBlocked == false) DrawBlock(player, item);
            return isBlocked;
        }

        private object OnReloadWeapon(BasePlayer player, BaseProjectile projectile)
        {
            if (!player.userID.IsSteamId()) return null;

            var isBlocked = IsBlocked(projectile.primaryMagazine.ammoType) > 0 ? false : (bool?)null;
            if (isBlocked == false) Notifications.Call("API_AddUINote", player.userID, $"Вы не можете использовать этот тип боеприпасов!");
            return isBlocked;
        }

        void OnWeaponFired(BaseProjectile projectile, BasePlayer player, ItemModProjectile mod, ProtoBuf.ProjectileShoot projectiles)
        {
            if (!player.userID.IsSteamId()) return;

            var isBlocked = IsBlocked(projectile.primaryMagazine.ammoType) > 0 ? false : (bool?)null;
            if (isBlocked == false)
            {
                projectile.primaryMagazine.contents = 0;
                projectile.GetItem().LoseCondition(projectile.GetItem().maxCondition);
                projectile.SendNetworkUpdate();
                player.SendNetworkUpdate();
                Item ammo = ItemManager.CreateByItemID(projectile.primaryMagazine.ammoType.itemid, 1, 0);
                Notifications.Call("API_AddUINote", player.userID, $"Хорошая попытка, правда ваше оружие теперь сломано!");
            }
        }


        private object OnReloadMagazine(BasePlayer player, BaseProjectile projectile)
        {
            if (!player.userID.IsSteamId())
                return null;
            if (player.IsAdmin)
                return null;

            NextTick(() =>
            {
                var isBlocked = IsBlocked(projectile.primaryMagazine.ammoType) > 0 ? false : (bool?)null;
                if (isBlocked == false)
                {
                    projectile.primaryMagazine.contents = 0;
                    projectile.GetItem().LoseCondition(projectile.GetItem().maxCondition);
                    projectile.SendNetworkUpdate();
                    player.SendNetworkUpdate();
                    Item ammo = ItemManager.CreateByItemID(projectile.primaryMagazine.ammoType.itemid, 1, 0);
                    Notifications.Call("API_AddUINote", player.userID, $"Хорошая попытка, правда ваше оружие теперь сломано!");
                }
            });
            return null;
        }

        private void DrawBlock(BasePlayer player, Item item)
        {
            string inputText = "Предмет {name} временно заблокирован, подождите {1}".Replace("{name}", item.info.displayName.english).Replace("{1}", $"{Convert.ToInt32(Math.Floor(TimeSpan.FromSeconds(IsBlocked(item.info)).TotalHours))} час. {TimeSpan.FromSeconds(IsBlocked(item.info)).Minutes} минут.");
            Notifications.Call("API_AddUINote", player.userID, inputText);
        }
        #endregion

        #region UI
        #region Layers
        public const string MenuLayer = "XMenu";
        public const string MenuItemsLayer = "XMenu.MenuItems";
        public const string MenuSubItemsLayer = "XMenu.MenuSubItems";
        public const string MenuContent = "XMenu.Content";
        #endregion

        private void RenderWipeBlock(ulong userID, object[] objects)
        {
            CuiElementContainer Container = (CuiElementContainer)objects[0];
            bool FullRender = (bool)objects[1];
            string Name = (string)objects[2];
            int ID = (int)objects[3];
            int Page = (int)objects[4];

            Container.Add(new CuiElement
            {
                Name = MenuContent,
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-430 -230",
                            OffsetMax = "490 270"
                        },
                    }
            });

            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Title",
                Parent = MenuContent,
                Components =
                    {
                        new CuiTextComponent
                        {
                            Text = $"<color={config.colorConfig.menuContentText}><b>ВАЙПОВАЯ БЛОКИРОВКА ПРЕДМЕТОВ НА СЕРВЕРЕ</b> <color={config.colorConfig.menuContentTextAlternative}>{config.serverName}</color>\n<size=24>Вайп сервера был произведён: {epoch.AddSeconds(SaveCreatedTime).ToString("dd-MM-yyyy")}</size></color>",
                            Align = TextAnchor.MiddleCenter,
                            FontSize = 30,
                            Font = "robotocondensed-bold.ttf",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = $"0 -80",
                            OffsetMax = $"920 0",
                        }
                    }
            });
            for (int i = 0, x = 0, y = 3; i < config.blockedItems.Count; i++, x = 0)
            {
                Container.Add(new CuiElement
                {
                    Name = MenuContent + $".Category_{i}",
                    Parent = MenuContent,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = $"<color={config.colorConfig.menuContentText}>{config.blockedItems.ElementAt(i).Key}</color>",
                            Align = TextAnchor.MiddleCenter,
                            FontSize = 16,
                            Font = "robotocondensed-bold.ttf",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = $"0 {50 - y * 55}",
                            OffsetMax = $"920 {100 - y * 55}",
                        }
                    }
                });
                y++;
                for (int j = 0; j < config.blockedItems.ElementAt(i).Value.Count; j++)
                {
                    for (int k = 0; k < config.blockedItems.ElementAt(i).Value.ElementAt(j).Value.Count; k++, x++)
                    {
                        if (x == 15)
                        {
                            x = 0;
                            y++;
                        }

                        Container.Add(new CuiElement
                        {
                            Name = MenuContent + $".Item_{k}",
                            Parent = MenuContent,
                            Components =
                            {
                                new CuiImageComponent
                                {
                                    Color = HexToRustFormat(config.colorConfig.menuContentHighlightingalternative),
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1",
                                    AnchorMax = "0 1",
                                    OffsetMin = $"{35 + x * 55} {50 - y * 55}",
                                    OffsetMax = $"{85 + x * 55} {100 - y * 55}"
                                }
                            }
                        });
                        Container.Add(new CuiElement
                        {
                            Name = MenuContent + $".Item_{k}",
                            Parent = MenuContent,
                            Components =
                            {
                                new CuiRawImageComponent
                                {
                                    Png = GetImage(config.blockedItems.ElementAt(i).Value.ElementAt(j).Value.ElementAt(k)),
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1",
                                    AnchorMax = "0 1",
                                    OffsetMin = $"{35 + x * 55} {50 - y * 55}",
                                    OffsetMax = $"{85 + x * 55} {100 - y * 55}"
                                }
                            }
                        });
                        string text = IsBlocked(config.blockedItems.ElementAt(i).Value.ElementAt(j).Value.ElementAt(k)) > 0
                        ? $"<color=#FFFFFFB3><size=9>ОСТАЛОСЬ\nЖДАТЬ:</size></color>\n\n<color=#FFAA00FF><size=11>{TimeSpan.FromSeconds((int)IsBlocked(config.blockedItems.ElementAt(i).Value.ElementAt(j).Value.ElementAt(k))).ToShortString()}</size></color>"
                        : "";
                        Container.Add(new CuiElement
                        {
                            Name = MenuContent + $".Item_{k}_Title",
                            Parent = MenuContent,
                            Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = $"<color={config.colorConfig.menuContentText}>{text}</color>",
                                    Align = TextAnchor.MiddleCenter,
                                    FontSize = 6,
                                    Font = "robotocondensed-bold.ttf",
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1",
                                    AnchorMax = "0 1",
                                    OffsetMin = $"{35 + x * 55} {50 - y * 55}",
                                    OffsetMax = $"{85 + x * 55} {100 - y * 55}"
                                }
                            }
                        });
                    }
                }
                y++;
            }
        }
        #endregion

        #region Helpers
        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }

        private double IsBlocked(ItemDefinition itemDefinition) => IsBlocked(itemDefinition.shortname);
        private double IsBlocked(string shortname)
        {
            if (!blockTime.ContainsKey(shortname))
                return 0;

            var lefTime = blockTime[shortname] + SaveCreatedTime - CurrentTime();

            return lefTime > 0 ? lefTime : 0;
        }

        private static readonly DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        private static double CurrentTime() { return DateTime.UtcNow.Subtract(epoch).TotalSeconds; }
        private static string ToShortString(TimeSpan timeSpan)
        {
            int i = 0;
            string resultText = "";
            if (timeSpan.Days > 0)
            {
                resultText += timeSpan.Days + " День";
                i++;
            }
            if (timeSpan.Hours > 0 && i < 2)
            {
                if (resultText.Length != 0)
                    resultText += " ";
                resultText += timeSpan.Days + " Час";
                i++;
            }
            if (timeSpan.Minutes > 0 && i < 2)
            {
                if (resultText.Length != 0)
                    resultText += " ";
                resultText += timeSpan.Days + " Мин.";
                i++;
            }
            if (timeSpan.Seconds > 0 && i < 2)
            {
                if (resultText.Length != 0)
                    resultText += " ";
                resultText += timeSpan.Days + " Сек.";
                i++;
            }

            return resultText;
        }

        private long ToEpoch(DateTime dateTime) => (long)(dateTime - new DateTime(1970, 1, 1)).TotalSeconds;
        #endregion
    }
}

// --- End of file: WipeBlock.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/NoWorkbench.cs ---
// --- Original Local Path: TrashRust/NoWorkbench.cs ---

﻿using Newtonsoft.Json;
using System.Linq;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("NoWorkbench", "k1lly0u", "0.1.51")]
    [Description("Eliminates the requirement of being near a bench to craft")]
    class NoWorkbench : RustPlugin
    {        
        private Dictionary<int, int> defaultBlueprints;

        #region Oxide Hooks  
        private void OnServerInitialized()
        {
            LoadVariables();
            defaultBlueprints = ItemManager.GetBlueprints().ToDictionary(x => x.targetItem.itemid, y => y.workbenchLevelRequired);

            foreach (ItemBlueprint bp in ItemManager.GetBlueprints())            
                bp.workbenchLevelRequired = 0;            

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);
        }
       
        private void OnPlayerConnected(BasePlayer player)
        {
            if (player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.In(3, () => OnPlayerConnected(player));
                return;
            }

            player.ClientRPCPlayer(null, player, "craftMode", 1);

            if (configData.NoBlueprints)
                UnlockAllBlueprints(player);             
        }        

        private void UnlockAllBlueprints(BasePlayer player)
        {
            ProtoBuf.PersistantPlayer playerInfo = SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerInfo(player.userID);
            foreach (ItemBlueprint itemBlueprint in ItemManager.bpList)
            {
                if (itemBlueprint.userCraftable && !itemBlueprint.defaultBlueprint)
                {
                    if (!playerInfo.unlockedItems.Contains(itemBlueprint.targetItem.itemid))                   
                        playerInfo.unlockedItems.Add(itemBlueprint.targetItem.itemid);
                }
            }
            SingletonComponent<ServerMgr>.Instance.persistance.SetPlayerInfo(player.userID, playerInfo);
            player.SendNetworkUpdateImmediate(false);
            player.ClientRPCPlayer<int>(null, player, "UnlockedBlueprint", 0);
        }

        private void Unload()
        {
            foreach (ItemBlueprint bp in ItemManager.GetBlueprints())
                bp.workbenchLevelRequired = defaultBlueprints[bp.targetItem.itemid];
        }
        #endregion
       
        #region Config        
        private ConfigData configData;
        private class ConfigData
        {
            [JsonProperty(PropertyName = "Disable the need for blueprints")]
            public bool NoBlueprints { get; set; }            
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            ConfigData config = new ConfigData
            {
                NoBlueprints = false
            };
            SaveConfig(config);
        }

        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();

        private void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion
    }
}


// --- End of file: NoWorkbench.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/WipeSchedule.cs ---
// --- Original Local Path: TrashRust/WipeSchedule.cs ---

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("WipeSchedule", "Mevent", "1.0.4⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠")]
    public class WipeSchedule : RustPlugin
    {
        #region Fields⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        private string Layer = "UI_WipeSchedule";
        public enum Types
        {
            None,
            GLOBAL_WIPE,
            WIPE
        }

        private Dictionary<int, string> DaysOfWeek = new Dictionary<int, string>()
        {
            [1] = "Понедельник",
            [2] = "Вторник",
            [3] = "Среда",
            [4] = "Четверг",
            [5] = "Пятница",
            [6] = "Суббота",
            [7] = "Воскресенье",
        };

        public List<DayClass> DaysList = new List<DayClass>();

        public class DayClass
        {
            public int day;
            public string color;
            public Types types;
            public string description;
        }
        #endregion

        #region Config⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        private ConfigData config;

        private class ConfigData
        {
            [JsonProperty("Список чат-команд для открытия календаря")]
            public List<string> Commands;
            [JsonProperty("Раз во сколько секунд обновлять календарь?")]
            public int Delay;
            [JsonProperty("Цвет дней в нынешнем месяце")]
            public string ActiveColor;
            [JsonProperty("Цвет дней в предыдущем и следующем месяце")]
            public string DisactiveColor;
            [JsonProperty("Настройка")]
            public Dictionary<int, WipeClass> wipe;
        }

        private class WipeClass
        {
            [JsonProperty("Тип")]
            public Types type;
            [JsonProperty("Цвет кнопки")]
            public string color;
            [JsonProperty("Описание")]
            public string description;
        }

        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                Commands = new List<string>
                {
                    "wipe", "schedule", "wipedate"
                },
                Delay = 7200,
                ActiveColor = "0.67 0.67 0.67 0.8",
                DisactiveColor = "0 0 0 0.6",
                wipe = new Dictionary<int, WipeClass>
                {
                    {
                        1, new WipeClass
                        {
                            color = "0.78 0.30 0.26 0.8",
                            type = Types.GLOBAL_WIPE,
                            description = "ГЛОБАЛЬНЫЙ ВАЙП"
                        }
                    },
                    {
                        9, new WipeClass
                        {
                            color = "0.45 0.64 0.45 0.8",
                            type = Types.WIPE,
                            description = "ВАЙП КАРТЫ"
                        }
                    },
                    {
                        16, new WipeClass
                        {
                            color = "0.78 0.30 0.26 0.8",
                            type = Types.GLOBAL_WIPE,
                            description = "ГЛОБАЛЬНЫЙ ВАЙП"
                        }
                    },
                    {
                        23, new WipeClass
                        {
                            color = "0.45 0.64 0.45 0.8",
                            type = Types.WIPE,
                            description = "ВАЙП КАРТЫ"
                        }
                    },
                    {
                        30, new WipeClass
                        {
                            color = "0.45 0.64 0.45 0.8",
                            type = Types.WIPE,
                            description = "ВАЙП КАРТЫ"
                        }
                    }
                }
            };
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            PrintError("Configuration file is corrupt(or not exists), creating new one!");
            config = GetDefaultConfig();
        }
        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion

        #region Hooks⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        [PluginReference] Plugin XMenu;
        Timer TimerInitialize;
        private void OnServerInitialized()
        {

            TimerInitialize = timer.Every(5f, () =>
            {
                if (XMenu.IsLoaded)
                {
                    XMenu.Call("API_RegisterMenu", this.Name, "WipeSchedule", "assets/icons/demolish_immediate.png", "RenderSchedule", null);

                    cmd.AddChatCommand("wipe", this, (p, cmd, args) => rust.RunClientCommand(p, "custommenu true WipeSchedule"));
                    TimerInitialize.Destroy();
                }
            });

            PrintWarning("  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
            PrintWarning($"     {Name} v{Version} loading");
            PrintWarning($"        Plugin loaded - OK");
            PrintWarning("  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");

            for (int i = 0; i < config.Commands.Count; i++)
                cmd.AddChatCommand(config.Commands[i], this, nameof(CmdChatSchedule));

            cmd.AddConsoleCommand("UI_Schedule", this, nameof(CmdConsoleSchedule));

            CalculateTable();

            timer.Every(config.Delay, () => CalculateTable());
        }

        private void CmdChatSchedule(BasePlayer player, string command, string[] args)
        {
            
        }

        private void CmdConsoleSchedule(ConsoleSystem.Arg args)
        {
            var player = args.Player();

            int index = 0;
            if (!args.HasArgs(1) || !int.TryParse(args.Args[0], out index)) return;

            var check = DaysList[index];
            if (check.types != Types.None)
            {
                var container = new CuiElementContainer();
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = $"{check.description}", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, FontSize = 12, Font = "robotocondensed-bold.ttf" }
                }, Layer + $".Day.Of.{index}", Layer + $".Day.Of.{index}.Text");
                CuiHelper.DestroyUi(player, Layer + $".Day.Of.{index}.Text");
                CuiHelper.AddUi(player, container);
            }
        }
        #endregion

        #region Interface⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        public const string MenuLayer = "XMenu";
        public const string MenuItemsLayer = "XMenu.MenuItems";
        public const string MenuSubItemsLayer = "XMenu.MenuSubItems";
        public const string MenuContent = "XMenu.Content";


        private void RenderSchedule(ulong userID, object[] objects)
        {
            CuiElementContainer Container = (CuiElementContainer)objects[0];
            bool FullRender = (bool)objects[1];
            string Name = (string)objects[2];
            int ID = (int)objects[3];
            int Page = (int)objects[4];

            Container.Add(new CuiElement
            {
                Name = MenuContent,
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0 0 0 0",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-430 -230",
                            OffsetMax = "490 270"
                        },
                    }
            });

            BuildUI(BasePlayer.FindByID(userID), Container);
        }

        private void BuildUI(BasePlayer player, CuiElementContainer container)
        {
            var monthName = FirstUpper(DateTime.Now.ToString("MMMM", CultureInfo.GetCultureInfo("ru-RU")));

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Color = "0 0 0 0.3" },
                Text = { Text = "" }
            }, MenuContent, Layer + ".BG");
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-450 -245", OffsetMax = "250 210" },
                Image = { Color = "0.3 0.3 0.3 0.5" },
                CursorEnabled = true
            }, Layer + ".BG", Layer);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "5 -25", OffsetMax = "200 25" },
                Text = { Text = $"<b>{monthName}</b>", FontSize = 32, Align = TextAnchor.MiddleCenter }
            }, Layer);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "5 -350", OffsetMax = "200 -25" },
                Text = { Text = $"ИНФОРМАЦИЯ О ВАПАХ TRASH RUST:\n\n<color=#73A473>Вайп без чертежей:</color> раз в 5 дней! Меняется карта и ничего не скидывается кроме статистики сервера - /stats, вайп блокировки предметов и оружия - /wipe\n\n<color=#C74D43>Глобальный вайп:</color> раз в 10 дней! Меняется карта, сбрасываются навыки вашего РПГ - /rpg, денежные бонусы - /bonus, все изученные вами чертежи вместе со статистикой в целом.\n\n*Период времени проведения вайпа по техническим причинам может меняться, но в целом отталкиваться от текущей даты, поэтому просим вас зарание ознакамливаться с информцией в группе нашего сервера <color=#1d71ff>vk.com/crystalrustgame</color>", FontSize = 12, Align = TextAnchor.MiddleCenter }
            }, Layer);

            #region Loop
            var xDaysSwitch = 2.5f;
            for (int i = 1; i <= 7; i++)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = $"{xDaysSwitch} 5", OffsetMax = $"{xDaysSwitch + 95} 30" },
                    Button = { Command = "", Color = "0.37 0.37 0.37 0.8" },
                    Text = { Text = DaysOfWeek[i], Align = TextAnchor.MiddleCenter, FontSize = 13, Color = "1 1 1 0.8", Font = "robotocondensed-bold.ttf" }
                }, Layer);
                xDaysSwitch += 100;
            }

            var ySwitch = -5;
            var xSwitch = 2.5f;
            for (int i = 0; i < DaysList.Count; i++)
            {
                var check = DaysList[i];

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = $"{xSwitch} {ySwitch - 70}", OffsetMax = $"{xSwitch + 95} {ySwitch}" },
                    Button = { Color = check.color, Command = $"UI_Schedule {i}", FadeIn = 1f },
                    Text = { Text = "" }
                }, Layer, Layer + $".Day.Of.{i}");
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = $"{check.day}", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, FontSize = 16 }
                }, Layer + $".Day.Of.{i}", Layer + $".Day.Of.{i}.Text");

                xSwitch += 100;

                if ((i + 1) % 7 == 0)
                {
                    xSwitch = 2.5f;
                    ySwitch -= 75;
                }
            }
            #endregion

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "712.5 5", OffsetMax = "737.5 30" },
                Image = { Color = "0.78 0.30 0.26 0.8" }
            }, Layer, Layer + ".GlobalWipe");
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 1", OffsetMin = "5 -20", OffsetMax = "175 20" },
                Text = { Text = "- Глобальный вайп с удалением чертежей", Align = TextAnchor.MiddleLeft, FontSize = 12, Font = "robotocondensed-bold.ttf" }
            }, Layer + ".GlobalWipe");
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "712.5 40", OffsetMax = "737.5 65" },
                Image = { Color = "0.45 0.64 0.45 0.8", }
            }, Layer, Layer + ".Wipe");
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 1", OffsetMin = "5 -20", OffsetMax = "175 20" },
                Text = { Text = "- Вайп без удаления чертежей", Align = TextAnchor.MiddleLeft, FontSize = 12, Font = "robotocondensed-bold.ttf" }
            }, Layer + ".Wipe");

            CuiHelper.DestroyUi(player, Layer);
            //CuiHelper.AddUi(player, container);
        }
        #endregion

        #region Utils⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        private void CalculateTable()
        {
            DaysList.Clear();

            Calendar myCal = CultureInfo.InvariantCulture.Calendar;
            DateTime myDT = new DateTime(DateTime.Now.Year, DateTime.Now.Month, 1, myCal);

            var PreviousMonth = myDT.AddMonths(-1);
            var DaysInPreviousMonth = (int)DateTime.DaysInMonth(PreviousMonth.Year, PreviousMonth.Month);

            int j = Convert.ToInt32(myCal.GetDayOfWeek(myDT)) - 1;

            j = j == -1 ? 6 : j;

            var LastDay = new DateTime(PreviousMonth.Year, PreviousMonth.Month, DaysInPreviousMonth);
            var backDays = LastDay.AddDays(-j + 1);
            for (int m = 0; m < j; m++)
            {
                DaysList.Add(new DayClass
                {
                    day = backDays.Day,
                    color = config.DisactiveColor,
                    description = string.Empty,
                    types = Types.None
                });
                backDays = backDays.AddDays(1);
            }

            int month = myCal.GetMonth(myDT);
            while (myCal.GetMonth(myDT) == month)
            {
                var check = config.wipe.Where(x => x.Key == myDT.Day).FirstOrDefault().Value != null;

                DaysList.Add(new DayClass
                {
                    day = myDT.Day,
                    color = check ? config.wipe[myDT.Day].color : config.ActiveColor,
                    description = check ? config.wipe[myDT.Day].description : string.Empty,
                    types = check ? config.wipe[myDT.Day].type : Types.None
                });

                myDT = myDT.AddDays(1);
                j--;
            }

            if (DaysList.Count < 42)
            {
                var DaysToEndTable = 42 - DaysList.Count;

                for (int i = 1; i <= DaysToEndTable; i++)
                {
                    DaysList.Add(new DayClass
                    {
                        day = i,
                        color = config.DisactiveColor,
                        description = string.Empty,
                        types = Types.None
                    });
                }
            }
        }

        public string FirstUpper(string str)
        {
            str = str.ToLower();
            string[] s = str.Split(' ');
            for (int i = 0; i < s.Length; i++)
            {
                if (s[i].Length > 1)
                    s[i] = s[i].Substring(0, 1).ToUpper() + s[i].Substring(1, s[i].Length - 1);
                else s[i] = s[i].ToUpper();
            }
            return string.Join(" ", s);
        }
        #endregion
    }
}

// --- End of file: WipeSchedule.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/SpawnModularCar.cs ---
// --- Original Local Path: TrashRust/SpawnModularCar.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Rust;
using Rust.Modular;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using System.Text;

namespace Oxide.Plugins
{
    [Info("Spawn Modular Car", "WhiteThunder", "5.2.2")]
    [Description("Allows players to spawn modular cars.")]
    internal class SpawnModularCar : CovalencePlugin
    {
        #region Fields

        [PluginReference]
        private Plugin VehicleDeployedLocks;

        private static SpawnModularCar _pluginInstance;
        private static Configuration _pluginConfig;

        private PluginData _pluginData;
        private CommonPresets _commonPresets;

        private const string DefaultPresetName = "default";
        private const int PresetMaxLength = 30;

        private const string PermissionSpawnSockets2 = "spawnmodularcar.spawn.2";
        private const string PermissionSpawnSockets3 = "spawnmodularcar.spawn.3";
        private const string PermissionSpawnSockets4 = "spawnmodularcar.spawn.4";

        private const string PermissionEnginePartsTier1 = "spawnmodularcar.engineparts.tier1";
        private const string PermissionEnginePartsTier2 = "spawnmodularcar.engineparts.tier2";
        private const string PermissionEnginePartsTier3 = "spawnmodularcar.engineparts.tier3";

        private const string PermissionFix = "spawnmodularcar.fix";
        private const string PermissionFetch = "spawnmodularcar.fetch";
        private const string PermissionDespawn = "spawnmodularcar.despawn";
        private const string PermissionAutoFuel = "spawnmodularcar.autofuel";
        private const string PermissionAutoCodeLock = "spawnmodularcar.autocodelock";
        private const string PermissionAutoKeyLock = "spawnmodularcar.autokeylock";
        private const string PermissionAutoStartEngine = "spawnmodularcar.autostartengine";
        private const string PermissionAutoFillTankers = "spawnmodularcar.autofilltankers";
        private const string PermissionGiveCar = "spawnmodularcar.givecar";

        private const string PermissionPresets = "spawnmodularcar.presets";
        private const string PermissionPresetLoad = "spawnmodularcar.presets.load";
        private const string PermissionCommonPresets = "spawnmodularcar.presets.common";
        private const string PermissionManageCommonPresets = "spawnmodularcar.presets.common.manage";

        private const string PrefabSockets2 = "assets/content/vehicles/modularcar/2module_car_spawned.entity.prefab";
        private const string PrefabSockets3 = "assets/content/vehicles/modularcar/3module_car_spawned.entity.prefab";
        private const string PrefabSockets4 = "assets/content/vehicles/modularcar/4module_car_spawned.entity.prefab";

        private const string ItemDropPrefab = "assets/prefabs/misc/item drop/item_drop.prefab";

        private const string RepairEffectPrefab = "assets/bundled/prefabs/fx/build/promote_toptier.prefab";
        private const string TankerFilledEffectPrefab = "assets/prefabs/food/water jug/effects/water-jug-fill-container.prefab";

        // These layers are used to preventing spawning inside walls or players.
        private const int BoxcastLayers = Layers.Mask.Default
            + Layers.Mask.Deployed
            + Layers.Mask.Player_Server
            + Layers.Mask.AI
            + Layers.Mask.Vehicle_Detailed
            + Layers.Mask.Vehicle_World
            + Layers.Mask.World
            + Layers.Mask.Construction
            + Layers.Mask.Tree;

        // These layers are used to find a surface to spawn on.
        private const int RaycastLayers = Layers.Mask.Default
            + Layers.Mask.Terrain
            + Layers.World
            + Layers.Mask.Construction;

        private static readonly Vector3 ShortCarExtents = new Vector3(1, 1.1f, 1.5f);
        private static readonly Vector3 MediumCarExtents = new Vector3(1, 1.1f, 2.3f);
        private static readonly Vector3 LongCarExtents = new Vector3(1, 1.1f, 3);

        private static readonly Vector3 ShortCarFrontLeft = new Vector3(ShortCarExtents.x, 0, ShortCarExtents.z);
        private static readonly Vector3 ShortCarFrontRight = new Vector3(-ShortCarExtents.x, 0, ShortCarExtents.z);
        private static readonly Vector3 ShortCarBackLeft = new Vector3(ShortCarExtents.x, 0, -ShortCarExtents.z);
        private static readonly Vector3 ShortCarBackRight = new Vector3(-ShortCarExtents.x, 0, -ShortCarExtents.z);

        private static readonly Vector3 MediumCarFrontLeft = new Vector3(MediumCarExtents.x, 0, MediumCarExtents.z);
        private static readonly Vector3 MediumCarFrontRight = new Vector3(-MediumCarExtents.x, 0, MediumCarExtents.z);
        private static readonly Vector3 MediumCarBackLeft = new Vector3(MediumCarExtents.x, 0, -MediumCarExtents.z);
        private static readonly Vector3 MediumCarBackRight = new Vector3(-MediumCarExtents.x, 0, -MediumCarExtents.z);

        private static readonly Vector3 LongCarFrontLeft = new Vector3(LongCarExtents.x, 0, LongCarExtents.z);
        private static readonly Vector3 LongCarFrontRight = new Vector3(-LongCarExtents.x, 0, LongCarExtents.z);
        private static readonly Vector3 LongCarBackLeft = new Vector3(LongCarExtents.x, 0, -LongCarExtents.z);
        private static readonly Vector3 LongCarBackRight = new Vector3(-LongCarExtents.x, 0, -LongCarExtents.z);

        private static readonly float ForwardRaycastDistance = 1.5f + ShortCarExtents.x;
        private const float DownwardRaycastDistance = 4;

        private readonly RaycastHit[] _raycastBuffer = new RaycastHit[1];

        private readonly Dictionary<string, PlayerConfig> _playerConfigsMap = new Dictionary<string, PlayerConfig>();

        #endregion

        #region Hooks

        private void Init()
        {
            _pluginInstance = this;

            _pluginData = PluginData.LoadData();
            _commonPresets = CommonPresets.LoadData(_pluginData);

            MigrateConfig();

            permission.RegisterPermission(PermissionSpawnSockets2, this);
            permission.RegisterPermission(PermissionSpawnSockets3, this);
            permission.RegisterPermission(PermissionSpawnSockets4, this);

            permission.RegisterPermission(PermissionEnginePartsTier1, this);
            permission.RegisterPermission(PermissionEnginePartsTier2, this);
            permission.RegisterPermission(PermissionEnginePartsTier3, this);

            permission.RegisterPermission(PermissionFix, this);
            permission.RegisterPermission(PermissionFetch, this);
            permission.RegisterPermission(PermissionDespawn, this);
            permission.RegisterPermission(PermissionAutoFuel, this);
            permission.RegisterPermission(PermissionAutoCodeLock, this);
            permission.RegisterPermission(PermissionAutoKeyLock, this);
            permission.RegisterPermission(PermissionAutoStartEngine, this);
            permission.RegisterPermission(PermissionAutoFillTankers, this);
            permission.RegisterPermission(PermissionGiveCar, this);

            permission.RegisterPermission(PermissionPresets, this);
            permission.RegisterPermission(PermissionPresetLoad, this);
            permission.RegisterPermission(PermissionCommonPresets, this);
            permission.RegisterPermission(PermissionManageCommonPresets, this);
        }

        private void Unload()
        {
            _pluginInstance = null;
            _pluginConfig = null;
        }

        private void OnNewSave(string filename)
        {
            _pluginData.PlayerCars.Clear();
            _pluginData.Cooldowns.ClearAll();
            _pluginData.SaveData();
        }

        private void OnEntityKill(ModularCar car)
        {
            if (!IsPlayerCar(car))
                return;

            string userId = _pluginData.PlayerCars.FirstOrDefault(x => x.Value == car.net.ID.Value).Key;
            BasePlayer player = BasePlayer.Find(userId);

            if (player != null)
                ChatMessage(player, "Generic.Info.CarDestroyed");

            _pluginData.UnregisterCar(userId);
        }

        private void OnEngineStarted(ModularCar car, BasePlayer player)
        {
            if (car == null
                || car.OwnerID == 0
                || !_pluginData.PlayerCars.ContainsValue(car.net.ID.Value)
                || !permission.UserHasPermission(car.OwnerID.ToString(), PermissionAutoStartEngine))
                return;

            if (car.engineController.IsStarting)
            {
                car.CancelInvoke(car.engineController.FinishStartingEngine);
                car.engineController.FinishStartingEngine();
            }
        }

        #endregion

        #region API

        private static class ApiParser
        {
            public static string CodeLockField = "CodeLock";
            public static string KeyLockField = "KeyLock";
            public static string EnginePartsTierField = "EnginePartsTier";
            public static string FreshWaterAmountField = "FreshWaterAmount";
            public static string FuelAmountField = "FuelAmount";
            public static string ModulesField = "Modules";

            public static bool TryParseOptions(Dictionary<string, object> options, out PresetCarOptions presetOptions)
            {
                var codeLock = BoolOption(options, CodeLockField);
                var keyLock = BoolOption(options, KeyLockField);
                var enginePartsTier = IntOption(options, EnginePartsTierField);
                var freshWaterAmount = IntOption(options, FreshWaterAmountField);
                var fuelAmount = IntOption(options, FuelAmountField);
                var moduleIDs = ParseModulesOption(options);

                presetOptions = null;

                if (moduleIDs == null)
                {
                    _pluginInstance.LogError($"[API] '{ApiParser.ModulesField}' field is missing or unrecognizable.");
                    return false;
                }

                if (moduleIDs.Length < 2 || moduleIDs.Length > 4)
                {
                    _pluginInstance.LogError($"[API] Requested a car with {moduleIDs.Length} sockets, but only 2-4 sockets is supported.");
                    return false;
                }

                presetOptions = new PresetCarOptions
                {
                    CodeLock = codeLock,
                    KeyLock = keyLock,
                    EnginePartsTier = enginePartsTier,
                    FreshWaterAmount = freshWaterAmount,
                    FuelAmount = fuelAmount,
                    NormalizedModuleIDs = moduleIDs
                };
                return true;
            }

            private static bool BoolOption(Dictionary<string, object> options, string name)
            {
                object value;
                return options.TryGetValue(name, out value) && value is bool
                    ? (bool)value
                    : false;
            }

            private static int IntOption(Dictionary<string, object> options, string name)
            {
                object value;
                return options.TryGetValue(name, out value) && value is int
                    ? (int)value
                    : 0;
            }

            public static int[] ParseModulesOption(Dictionary<string, object> options)
            {
                if (!options.ContainsKey(ModulesField))
                    return null;

                var moduleArray = options[ModulesField] as object[];
                if (moduleArray == null)
                    return null;

                return _pluginInstance.ValidateModules(moduleArray);
            }
        }

        private ModularCar API_SpawnPreset(Dictionary<string, object> options, BasePlayer player, Vector3 position, Quaternion rotation)
        {
            PresetCarOptions presetOptions;
            if (!ApiParser.TryParseOptions(options, out presetOptions))
                return null;

            if (SpawnWasBlocked(player))
                return null;

            if (position == Vector3.zero && player != null)
                DetermineCarPositionAndRotation(player, presetOptions.Length, out position, out rotation);

            return SpawnCar(presetOptions, position, rotation, player, shouldTrackCar: false);
        }

        private ModularCar API_SpawnNamedPreset(string presetName, BasePlayer player, Vector3 position, Quaternion rotation)
        {
            var presetOptions = _pluginConfig.FindPreset(presetName)?.Options;
            if (presetOptions == null)
            {
                LogError($"[API] Server preset '{presetName}' not found.");
                return null;
            }

            if (presetOptions.Length < 2 || presetOptions.Length > 4)
            {
                LogError($"[API] Requested a car with {presetOptions.Length} sockets, but only 2-4 sockets is supported.");
                return null;
            }

            if (SpawnWasBlocked(player))
                return null;

            if (position == Vector3.zero && player != null)
                DetermineCarPositionAndRotation(player, presetOptions.Length, out position, out rotation);

            return SpawnCar(presetOptions, position, rotation, player, shouldTrackCar: false);
        }

        private ModularCar API_SpawnPresetCar(BasePlayer player, Dictionary<string, object> options, Action<ModularCar> onReady = null)
        {
            PresetCarOptions presetOptions;
            if (!ApiParser.TryParseOptions(options, out presetOptions))
                return null;

            if (SpawnWasBlocked(player))
                return null;

            Vector3 spawnPosition;
            Quaternion rotation;
            if (!TryGetIdealCarPositionAndRotation(player, presetOptions.Length, out spawnPosition, out rotation))
            {
                spawnPosition = GetFixedCarPosition(player);
                rotation = GetRelativeCarRotation(player);
            }

            var car = SpawnCar(presetOptions, spawnPosition, rotation, player, shouldTrackCar: false);
            if (car != null)
            {
                // Note: Consumers no longer need to use this callback since this plugin now forces synchronous module registration.
                onReady?.Invoke(car);
            }

            return car;
        }

        #endregion

        #region Commands

        [Command("givecar")]
        private void SpawnCarServerCommand(IPlayer player, string cmd, string[] args)
        {
            if (!player.IsServer && !VerifyPermissionAny(player, PermissionGiveCar))
                return;

            if (args.Length < 2)
            {
                ReplyToPlayer(player, "Command.Give.Error.Syntax");
                return;
            }

            var playerNameOrIdArg = args[0];
            var presetNameArg = args[1];

            var targetPlayer = BasePlayer.Find(playerNameOrIdArg);
            if (targetPlayer == null)
            {
                ReplyToPlayer(player, "Command.Give.Error.PlayerNotFound", playerNameOrIdArg);
                return;
            }

            var preset = _pluginConfig.FindPreset(presetNameArg);
            if (preset == null)
            {
                ReplyToPlayer(player, "Generic.Error.PresetNotFound", presetNameArg);
                return;
            }

            var carOptions = preset.Options;
            if (carOptions.Length < 2)
            {
                ReplyToPlayer(player, "Command.Give.Error.PresetTooFewModules", preset.Name, carOptions.Length);
                return;
            }
            if (carOptions.Length > 4)
            {
                ReplyToPlayer(player, "Command.Give.Error.PresetTooManyModules", preset.Name, carOptions.Length);
                return;
            }

            Vector3 spawnPosition;
            Quaternion rotation;
            if (!TryGetIdealCarPositionAndRotation(targetPlayer, preset.Options.Length, out spawnPosition, out rotation))
            {
                spawnPosition = GetFixedCarPosition(targetPlayer);
                rotation = GetRelativeCarRotation(targetPlayer);
            }

            var car = SpawnCar(carOptions, spawnPosition, rotation, targetPlayer, shouldTrackCar: false);
            if (car != null)
            {
                ReplyToPlayer(player, "Command.Give.Success", targetPlayer.displayName, preset.Name);
            }
        }

        [Command("mycar")]
        private void MyCarCommand(IPlayer player, string cmd, string[] args)
        {
            if (player.IsServer)
                return;

            var basePlayer = player.Object as BasePlayer;
            if (!basePlayer.CanInteract())
                return;

            if (args.Length == 0)
            {
                SubCommand_SpawnCar(player, args);
                return;
            }

            switch (args[0].ToLower())
            {
                case "help":
                    SubCommand_Help(player, args.Skip(1).ToArray());
                    return;

                case "list":
                    SubCommand_ListPresets(player, args.Skip(1).ToArray());
                    return;

                case "save":
                    SubCommand_SavePreset(player, args.Skip(1).ToArray());
                    return;

                case "update":
                    SubCommand_UpdatePreset(player, args.Skip(1).ToArray());
                    return;

                case "load":
                    SubCommand_LoadPreset(player, args.Skip(1).ToArray());
                    return;

                case "rename":
                    SubCommand_RenamePreset(player, args.Skip(1).ToArray());
                    return;

                case "delete":
                    SubCommand_DeletePreset(player, args.Skip(1).ToArray());
                    return;

                case "fix":
                    SubCommand_FixCar(player, args.Skip(1).ToArray());
                    return;

                case "fetch":
                    SubCommand_FetchCar(player, args.Skip(1).ToArray());
                    return;

                case "destroy":
                    SubCommand_DestroyCar(player, args.Skip(1).ToArray());
                    return;

                case "autocodelock":
                    SubCommand_ToggleAutoCodeLock(player, args.Skip(1).ToArray());
                    return;

                case "autokeylock":
                    SubCommand_ToggleAutoKeyLock(player, args.Skip(1).ToArray());
                    return;

                case "autofilltankers":
                    SubCommand_ToggleAutoFillTankers(player, args.Skip(1).ToArray());
                    return;

                case "common":
                    SubCommand_CommonPreset(player, args.Skip(1).ToArray());
                    return;

                default:
                    SubCommand_SpawnCar(player, args);
                    return;
            }
        }

        private void SubCommand_CommonPreset(IPlayer player, string[] args)
        {
            if (args.Length == 0)
            {
                ReplyToPlayer(player, "Command.Common.Error.Syntax");
                return;
            }

            switch (args[0].ToLower())
            {
                case "list":
                    SubCommand_Common_ListPresets(player, args.Skip(1).ToArray());
                    return;

                case "load":
                    SubCommand_Common_LoadPreset(player, args.Skip(1).ToArray());
                    return;

                case "save":
                    SubCommand_Common_SavePreset(player, args.Skip(1).ToArray());
                    return;

                case "update":
                    SubCommand_Common_UpdatePreset(player, args.Skip(1).ToArray());
                    return;

                case "rename":
                    SubCommand_Common_RenamePreset(player, args.Skip(1).ToArray());
                    return;

                case "delete":
                    SubCommand_Common_DeletePreset(player, args.Skip(1).ToArray());
                    return;

                default:
                    SubCommand_Common_SpawnCar(player, args);
                    return;
            }
        }

        private void SubCommand_Help(IPlayer player, string[] args)
        {
            ushort maxAllowedSockets = GetPlayerMaxAllowedCarSockets(player.Id);
            if (maxAllowedSockets == 0)
            {
                ReplyToPlayer(player, "Generic.Error.NoPermission");
                return;
            }

            var canUsePresets = permission.UserHasPermission(player.Id, PermissionPresets);
            var canLoadPresets = permission.UserHasPermission(player.Id, PermissionPresetLoad);

            var sb = new StringBuilder();
            sb.AppendLine(GetMessage(player, "Command.Help"));

            if (canUsePresets)
                sb.AppendLine(GetMessage(player, "Command.Help.Spawn.Basic.PresetsAllowed"));
            else
                sb.AppendLine(GetMessage(player, "Command.Help.Spawn.Basic"));

            sb.AppendLine(GetMessage(player, "Command.Help.Spawn.Sockets"));

            if (permission.UserHasPermission(player.Id, PermissionFix))
                sb.AppendLine(GetMessage(player, "Command.Help.Fix"));

            if (permission.UserHasPermission(player.Id, PermissionFetch))
                sb.AppendLine(GetMessage(player, "Command.Help.Fetch"));

            if (permission.UserHasPermission(player.Id, PermissionDespawn))
                sb.AppendLine(GetMessage(player, "Command.Help.Destroy"));

            if (canUsePresets)
            {
                sb.AppendLine(GetMessage(player, "Command.Help.Section.PersonalPresets"));
                sb.AppendLine(GetMessage(player, "Command.Help.ListPresets"));
                sb.AppendLine(GetMessage(player, "Command.Help.Spawn.Preset"));

                if (canLoadPresets)
                    sb.AppendLine(GetMessage(player, "Command.Help.LoadPreset"));

                sb.AppendLine(GetMessage(player, "Command.Help.SavePreset"));
                sb.AppendLine(GetMessage(player, "Command.Help.UpdatePreset"));
                sb.AppendLine(GetMessage(player, "Command.Help.RenamePreset"));
                sb.AppendLine(GetMessage(player, "Command.Help.DeletePreset"));
            }

            if (permission.UserHasPermission(player.Id, PermissionCommonPresets))
            {
                sb.AppendLine(GetMessage(player, "Command.Help.Section.CommonPresets"));
                sb.AppendLine(GetMessage(player, "Command.Help.Common.ListPresets"));
                sb.AppendLine(GetMessage(player, "Command.Help.Common.Spawn"));

                if (canLoadPresets)
                    sb.AppendLine(GetMessage(player, "Command.Help.Common.LoadPreset"));

                if (permission.UserHasPermission(player.Id, PermissionManageCommonPresets))
                {
                    sb.AppendLine(GetMessage(player, "Command.Help.Common.SavePreset"));
                    sb.AppendLine(GetMessage(player, "Command.Help.Common.UpdatePreset"));
                    sb.AppendLine(GetMessage(player, "Command.Help.Common.RenamePreset"));
                    sb.AppendLine(GetMessage(player, "Command.Help.Common.DeletePreset"));
                }
            }

            var canCodeLock = VehicleDeployedLocks != null && permission.UserHasPermission(player.Id, PermissionAutoCodeLock);
            var canKeyLock = permission.UserHasPermission(player.Id, PermissionAutoKeyLock);
            var canFillTankers = permission.UserHasPermission(player.Id, PermissionAutoFillTankers);

            if (canCodeLock || canKeyLock || canFillTankers)
                sb.AppendLine(GetMessage(player, "Command.Help.Section.PersonalSettings"));

            if (canCodeLock)
                sb.AppendLine(GetMessage(player, "Command.Help.ToggleAutoCodeLock", BooleanToLocalizedString(player, GetPlayerConfig(player).Settings.AutoCodeLock)));

            if (canKeyLock)
                sb.AppendLine(GetMessage(player, "Command.Help.ToggleAutoKeyLock", BooleanToLocalizedString(player, GetPlayerConfig(player).Settings.AutoKeyLock)));

            if (canFillTankers)
                sb.AppendLine(GetMessage(player, "Command.Help.ToggleAutoFillTankers", BooleanToLocalizedString(player, GetPlayerConfig(player).Settings.AutoFillTankers)));

            if (permission.UserHasPermission(player.Id, PermissionGiveCar))
            {
                sb.AppendLine("Command.Help.Section.OtherCommands");
                sb.AppendLine(GetMessage(player, "Command.Help.Give"));
            }

            player.Reply(sb.ToString());
        }

        private void SubCommand_SpawnCar(IPlayer player, string[] args)
        {
            ushort maxAllowedSockets = GetPlayerMaxAllowedCarSockets(player.Id);
            if (maxAllowedSockets == 0)
            {
                ReplyToPlayer(player, "Generic.Error.NoPermission");
                return;
            }

            if (!VerifyHasNoCar(player)
                || !VerifyOffCooldown(player, CooldownType.Spawn)
                || !VerifyLocationNotRestricted(player)
                || !_pluginConfig.CanSpawnBuildingBlocked && !VerifyNotBuildingBlocked(player))
                return;

            // Key binds automatically pass the "True" argument.
            var wasPassedArgument = args.Length > 0 && args[0] != "True";

            if (wasPassedArgument)
            {
                int desiredSockets;
                if (int.TryParse(args[0], out desiredSockets))
                {
                    if (desiredSockets < 2 || desiredSockets > 4)
                    {
                        ReplyToPlayer(player, "Command.Spawn.Error.SocketSyntax");
                        return;
                    }

                    if (desiredSockets > maxAllowedSockets)
                    {
                        ReplyToPlayer(player, "Generic.Error.NoPermission");
                        return;
                    }

                    SpawnRandomCarForPlayer(player, desiredSockets);
                    return;
                }

                if (!VerifyPermissionAny(player, PermissionPresets))
                    return;

                var presetNameArg = args[0];

                SimplePreset preset;
                if (!VerifyOnlyOneMatchingPreset(player, GetPlayerConfig(player), presetNameArg, out preset))
                    return;

                SpawnPresetCarForPlayer(player, preset);
            }
            else
            {
                if (permission.UserHasPermission(player.Id, PermissionPresets))
                {
                    var preset = GetPlayerConfig(player).FindPreset(DefaultPresetName);
                    if (preset != null)
                    {
                        SpawnPresetCarForPlayer(player, preset);
                        return;
                    }
                }

                SpawnRandomCarForPlayer(player, maxAllowedSockets);
            }
        }

        private void SubCommand_Common_SpawnCar(IPlayer player, string[] args)
        {
            ushort maxAllowedSockets = GetPlayerMaxAllowedCarSockets(player.Id);
            if (maxAllowedSockets == 0)
            {
                ReplyToPlayer(player, "Generic.Error.NoPermission");
                return;
            }

            if (!VerifyPermissionAny(player, PermissionCommonPresets)
                || !VerifyHasNoCar(player)
                || !VerifyOffCooldown(player, CooldownType.Spawn)
                || !VerifyLocationNotRestricted(player)
                || !_pluginConfig.CanSpawnBuildingBlocked && !VerifyNotBuildingBlocked(player))
                return;

            var presetNameArg = args[0];

            SimplePreset preset;
            if (!VerifyOnlyOneMatchingPreset(player, _commonPresets, presetNameArg, out preset))
                return;

            SpawnPresetCarForPlayer(player, preset);
        }

        private void SubCommand_FixCar(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, PermissionFix))
                return;

            ModularCar car;
            if (!VerifyHasCar(player, out car)
                || !VerifyOffCooldown(player, CooldownType.Fix)
                || FixMyCarWasBlocked(player.Object as BasePlayer, car))
                return;

            if (car.IsDead())
                ReviveCar(car);

            FixCar(car, GetPlayerAllowedFuel(player.Id), GetPlayerEnginePartsTier(player.Id));
            MaybeFillTankerModules(car, GetPlayerAllowedFreshWater(player.Id));
            _pluginData.StartCooldown(player.Id, CooldownType.Fix);

            MaybePlayCarRepairEffects(car);
            ReplyToPlayer(player, "Command.Fix.Success");
        }

        private void SubCommand_FetchCar(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, PermissionFetch))
                return;

            var basePlayer = player.Object as BasePlayer;
            ModularCar car;
            Vector3 fetchPosition;
            Quaternion fetchRotation;

            if (!VerifyHasCar(player, out car)
                || !_pluginConfig.CanFetchOccupied && !VerifyCarNotOccupied(player, car)
                || !VerifyOffCooldown(player, CooldownType.Fetch)
                || !VerifyLocationNotRestricted(player)
                || !_pluginConfig.CanFetchBuildingBlocked && !VerifyNotBuildingBlocked(player)
                || !VerifySufficientSpace(player, car.TotalSockets, out fetchPosition, out fetchRotation)
                || FetchMyCarWasBlocked(basePlayer, car))
                return;

            // This is a hacky way to determine that the car is on a lift.
            if (car.rigidBody.isKinematic && !TryReleaseCarFromLift(car))
            {
                var messages = new List<string> { GetMessage(player, "Command.Fetch.Error.StuckOnLift") };
                if (permission.UserHasPermission(player.Id, PermissionDespawn))
                    messages.Add(GetMessage(player, "Command.Fetch.Error.StuckOnLift.Help"));

                player.Reply(string.Join(" ", messages));
                return;
            }

            if (_pluginConfig.DismountPlayersOnFetch)
                DismountAllPlayersFromCar(car);

            // Temporarily clear max angular velocity to prevent the car from unexpectedly spinning when teleporting really far.
            var maxAngularVelocity = car.rigidBody.maxAngularVelocity;
            car.rigidBody.maxAngularVelocity = 0;

            car.transform.SetPositionAndRotation(fetchPosition, fetchRotation);
            car.SetVelocity(Vector3.zero);
            car.SetAngularVelocity(Vector3.zero);
            car.UpdateNetworkGroup();
            car.SendNetworkUpdateImmediate();
            timer.Once(1f, () =>
            {
                if (car != null)
                    car.rigidBody.maxAngularVelocity = maxAngularVelocity;
            });

            _pluginData.StartCooldown(player.Id, CooldownType.Fetch);
            ReplyToPlayer(player, "Command.Fetch.Success");
        }

        private void SubCommand_DestroyCar(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, PermissionDespawn))
                return;

            var basePlayer = player.Object as BasePlayer;
            ModularCar car;

            if (!VerifyHasCar(player, out car)
                || !_pluginConfig.CanDespawnOccupied && !VerifyCarNotOccupied(player, car)
                || DestroyMyCarWasBlocked(basePlayer, car))
                return;

            var extractedEngineParts = ExtractEnginePartsAboveTierAndDeleteRest(car, GetPlayerEnginePartsTier(player.Id));

            car.Kill();

            if (extractedEngineParts.Count > 0)
            {
                GiveItemsToPlayerOrDrop(basePlayer, extractedEngineParts);
                ReplyToPlayer(player, "Generic.Info.PartsRecovered");
            }
        }

        private void SubCommand_ListPresets(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, PermissionPresets))
                return;

            PlayerConfig config = GetPlayerConfig(player);
            if (config.Presets.Count == 0)
            {
                ReplyToPlayer(player, "Generic.Error.NoPresets");
                return;
            }

            var presetList = config.Presets.Select(p => p).ToList();
            presetList.Sort(SortPresetNames);

            var sb = new StringBuilder();
            sb.AppendLine(GetMessage(player, "Command.List"));

            foreach (var preset in presetList)
                sb.AppendLine(GetMessage(player, "Command.List.Item", preset.Name, preset.NumSockets));

            player.Reply(sb.ToString());
        }

        private void SubCommand_Common_ListPresets(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, PermissionCommonPresets))
                return;

            if (_commonPresets.Presets.Count == 0)
            {
                ReplyToPlayer(player, "Generic.Error.NoCommonPresets");
                return;
            }

            ushort maxAllowedSockets = GetPlayerMaxAllowedCarSockets(player.Id);

            var presetList = _commonPresets.Presets.Where(p => p.NumSockets <= maxAllowedSockets).ToList();
            presetList.Sort(SortPresetNames);

            var sb = new StringBuilder();
            sb.AppendLine(GetMessage(player, "Command.Common.List"));

            foreach (var preset in presetList)
                sb.AppendLine(GetMessage(player, "Command.List.Item", preset.Name, preset.NumSockets));

            player.Reply(sb.ToString());
        }

        private void SubCommand_SavePreset(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, PermissionPresets))
                return;

            ModularCar car;
            if (!VerifyHasCar(player, out car))
                return;

            var presetNameArg = args.Length == 0 ? DefaultPresetName : args[0];

            var presetManager = GetPlayerConfig(player);
            if (!VerifyNoMatchingPreset(player, presetManager, presetNameArg))
                return;

            if (presetManager.Presets.Count >= _pluginConfig.MaxPresetsPerPlayer)
            {
                ReplyToPlayer(player, "Command.SavePreset.Error.TooManyPresets", _pluginConfig.MaxPresetsPerPlayer);
                return;
            }

            SavePreset(player, presetManager, presetNameArg, car);
        }

        private void SubCommand_Common_SavePreset(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, PermissionManageCommonPresets))
                return;

            if (args.Length == 0)
            {
                ReplyToPlayer(player, "Command.Common.SavePreset.Error.Syntax");
                return;
            }

            var presetNameArg = args[0];

            ModularCar car;
            if (!VerifyHasCar(player, out car)
                || !VerifyNoMatchingPreset(player, _commonPresets, presetNameArg))
                return;

            SavePreset(player, _commonPresets, presetNameArg, car);
        }

        private void SavePreset(IPlayer player, SimplePresetManager presetManager, string presetNameArg, ModularCar car)
        {
            if (presetNameArg.Length > PresetMaxLength)
            {
                ReplyToPlayer(player, "Generic.Error.PresetNameLength", PresetMaxLength);
                return;
            }

            presetManager.SavePreset(SimplePreset.FromCar(car, presetNameArg));
            ReplyToPlayer(player, "Command.SavePreset.Success", presetNameArg);
        }

        private void SubCommand_UpdatePreset(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, PermissionPresets))
                return;

            var presetNameArg = args.Length == 0 ? DefaultPresetName : args[0];
            UpdatePreset(player, GetPlayerConfig(player), presetNameArg);
        }

        private void SubCommand_Common_UpdatePreset(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, PermissionManageCommonPresets))
                return;

            if (args.Length == 0)
            {
                ReplyToPlayer(player, "Command.Common.UpdatePreset.Error.Syntax");
                return;
            }

            UpdatePreset(player, _commonPresets, args[0]);
        }

        private void UpdatePreset(IPlayer player, SimplePresetManager presetManager, string presetNameArg)
        {
            ModularCar car;
            if (!VerifyHasCar(player, out car))
                return;

            SimplePreset preset;
            if (!VerifyHasPreset(player, presetManager, presetNameArg, out preset))
                return;

            presetManager.UpdatePreset(SimplePreset.FromCar(car, preset.Name));
            ReplyToPlayer(player, "Command.UpdatePreset.Success", preset.Name);
        }

        private void SubCommand_LoadPreset(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, PermissionPresetLoad))
                return;

            var presetNameArg = args.Length == 0 ? DefaultPresetName : args[0];
            LoadPreset(player, GetPlayerConfig(player.Id), presetNameArg);
        }

        private void SubCommand_Common_LoadPreset(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, PermissionPresetLoad)
                || !VerifyPermissionAny(player, PermissionCommonPresets))
                return;

            if (args.Length == 0)
            {
                ReplyToPlayer(player, "Command.Common.LoadPreset.Error.Syntax");
                return;
            }

            var presetNameArg = args[0];
            LoadPreset(player, _commonPresets, presetNameArg);
        }

        private void LoadPreset(IPlayer player, SimplePresetManager presetManager, string presetNameArg)
        {
            var basePlayer = player.Object as BasePlayer;
            ModularCar car;

            if (!VerifyHasCar(player, out car)
                || !VerifyCarNotOccupied(player, car)
                || !VerifyOffCooldown(player, CooldownType.Load)
                || LoadMyCarPresetWasBlocked(basePlayer, car))
                return;

            SimplePreset preset;
            if (!VerifyOnlyOneMatchingPreset(player, presetManager, presetNameArg, out preset))
                return;

            var presetNumSockets = preset.NumSockets;
            if (presetNumSockets > GetPlayerMaxAllowedCarSockets(player.Id))
            {
                ReplyToPlayer(player, "Generic.Error.NoPermissionToPresetSocketCount", preset.Name, preset.NumSockets);
                return;
            }

            if (presetNumSockets != car.TotalSockets)
            {
                ReplyToPlayer(player, "Command.LoadPreset.Error.SocketCount", preset.Name, presetNumSockets, car.TotalSockets);
                return;
            }

            if (car.IsDead())
                ReviveCar(car);

            var wasEngineOn = car.IsOn();
            var enginePartsTier = GetPlayerEnginePartsTier(player.Id);
            var extractedEngineParts = ExtractEnginePartsAboveTierAndDeleteRest(car, enginePartsTier);
            UpdateCarModules(car, preset.ModuleIDs);
            _pluginData.StartCooldown(player.Id, CooldownType.Load);

            NextTick(() => {
                var wereExtraParts = false;

                if (extractedEngineParts.Count > 0)
                {
                    var remainingEngineParts = AddEngineItemsAndReturnRemaining(car, extractedEngineParts);
                    if (remainingEngineParts.Count > 0)
                    {
                        wereExtraParts = true;
                        GiveItemsToPlayerOrDrop(basePlayer, remainingEngineParts);
                    }
                }

                FixCar(car, GetPlayerAllowedFuel(player.Id), enginePartsTier);

                // Restart the engine if it turned off during the brief moment it had no engine or no parts.
                if (wasEngineOn && !car.IsOn() && car.engineController.CanRunEngine())
                    car.engineController.FinishStartingEngine();

                MaybeFillTankerModules(car, GetPlayerAllowedFreshWater(player.Id));

                if (car.CarLock.HasALock && !car.CarLock.CanHaveALock())
                {
                    car.RemoveLock();
                }

                MaybePlayCarRepairEffects(car);

                var chatMessages = new List<string>() { GetMessage(player, "Command.LoadPreset.Success", preset.Name) };
                if (wereExtraParts)
                    chatMessages.Add(GetMessage(player, "Generic.Info.PartsRecovered"));

                player.Reply(string.Join(" ", chatMessages));
            });
        }

        private void SubCommand_RenamePreset(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, PermissionPresets))
                return;

            if (args.Length < 2)
            {
                ReplyToPlayer(player, "Command.RenamePreset.Error.Syntax");
                return;
            }

            RenamePreset(player, GetPlayerConfig(player), args[0], args[1]);
        }

        private void SubCommand_Common_RenamePreset(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, PermissionManageCommonPresets))
                return;

            if (args.Length < 2)
            {
                ReplyToPlayer(player, "Command.Common.RenamePreset.Error.Syntax");
                return;
            }

            RenamePreset(player, _commonPresets, args[0], args[1]);
        }

        private void RenamePreset(IPlayer player, SimplePresetManager presetManager, string oldName, string newName)
        {
            SimplePreset preset;
            if (!VerifyHasPreset(player, presetManager, oldName, out preset))
                return;

            // Cache actual old preset name since matching is case-insensitive.
            var actualOldPresetName = preset.Name;

            SimplePreset existingPresetWithNewName = presetManager.FindPreset(newName);

            if (newName.Length > PresetMaxLength)
            {
                ReplyToPlayer(player, "Generic.Error.PresetNameLength", PresetMaxLength);
                return;
            }

            // Allow renaming if just changing case.
            if (existingPresetWithNewName != null && preset != existingPresetWithNewName)
            {
                ReplyToPlayer(player, "Generic.Error.PresetAlreadyTaken", existingPresetWithNewName.Name);
                return;
            }

            presetManager.RenamePreset(preset, newName);
            ReplyToPlayer(player, "Command.RenamePreset.Success", actualOldPresetName, newName);
        }

        private void SubCommand_DeletePreset(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, PermissionPresets))
                return;

            var presetNameArg = args.Length == 0 ? DefaultPresetName : args[0];
            DeletePreset(player, GetPlayerConfig(player), presetNameArg);
        }

        private void SubCommand_Common_DeletePreset(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, PermissionManageCommonPresets))
                return;

            if (args.Length == 0)
            {
                ReplyToPlayer(player, "Command.Common.DeletePreset.Error.Syntax");
                return;
            }

            DeletePreset(player, _commonPresets, args[0]);
        }

        private void DeletePreset(IPlayer player, SimplePresetManager presetManager, string presetNameArg)
        {
            SimplePreset preset;
            if (!VerifyHasPreset(player, presetManager, presetNameArg, out preset))
                return;

            presetManager.DeletePreset(preset);
            ReplyToPlayer(player, "Command.DeletePreset.Success", preset.Name);
        }

        private void SubCommand_ToggleAutoCodeLock(IPlayer player, string[] args)
        {
            if (VehicleDeployedLocks == null
                || !VerifyPermissionAny(player, PermissionAutoCodeLock))
                return;

            var config = GetPlayerConfig(player);
            config.Settings.AutoCodeLock = !config.Settings.AutoCodeLock;
            config.SaveData();
            ReplyToPlayer(player, "Command.ToggleAutoCodeLock.Success", BooleanToLocalizedString(player, config.Settings.AutoCodeLock));
        }

        private void SubCommand_ToggleAutoKeyLock(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, PermissionAutoKeyLock))
                return;

            var config = GetPlayerConfig(player);
            config.Settings.AutoKeyLock = !config.Settings.AutoKeyLock;
            config.SaveData();
            ReplyToPlayer(player, "Command.ToggleAutoKeyLock.Success", BooleanToLocalizedString(player, config.Settings.AutoKeyLock));
        }

        private void SubCommand_ToggleAutoFillTankers(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, PermissionAutoFillTankers))
                return;

            var config = GetPlayerConfig(player);
            config.Settings.AutoFillTankers = !config.Settings.AutoFillTankers;
            config.SaveData();
            ReplyToPlayer(player, "Command.ToggleAutoFillTankers.Success", BooleanToLocalizedString(player, config.Settings.AutoFillTankers));
        }

        #endregion

        #region Helper Methods - Command Checks

        private static bool SpawnWasBlocked(BasePlayer player)
        {
            object hookResult = Interface.CallHook("CanSpawnModularCar", player);
            return hookResult is bool && (bool)hookResult == false;
        }

        private static bool SpawnMyCarWasBlocked(BasePlayer player)
        {
            if (SpawnWasBlocked(player))
                return true;

            object hookResult = Interface.CallHook("CanSpawnMyCar", player);
            return hookResult is bool && (bool)hookResult == false;
        }

        private static bool FetchMyCarWasBlocked(BasePlayer player, ModularCar car)
        {
            object hookResult = Interface.CallHook("CanFetchMyCar", player, car);
            return hookResult is bool && (bool)hookResult == false;
        }

        private static bool FixMyCarWasBlocked(BasePlayer player, ModularCar car)
        {
            object hookResult = Interface.CallHook("CanFixMyCar", player, car);
            return hookResult is bool && (bool)hookResult == false;
        }

        private static bool LoadMyCarPresetWasBlocked(BasePlayer player, ModularCar car)
        {
            object hookResult = Interface.CallHook("CanLoadMyCarPreset", player, car);
            return hookResult is bool && (bool)hookResult == false;
        }

        private static bool DestroyMyCarWasBlocked(BasePlayer player, ModularCar car)
        {
            object hookResult = Interface.CallHook("CanDestroyMyCar", player, car);
            return hookResult is bool && (bool)hookResult == false;
        }

        private bool VerifyPermissionAny(IPlayer player, params string[] permissionNames)
        {
            foreach (var perm in permissionNames)
            {
                if (!permission.UserHasPermission(player.Id, perm))
                {
                    ReplyToPlayer(player, "Generic.Error.NoPermission");
                    return false;
                }
            }
            return true;
        }

        private bool VerifyLocationNotRestricted(IPlayer player)
        {
            if ((player.Object as BasePlayer).GetComponentInParent<CargoShip>() != null)
            {
                ReplyToPlayer(player, "Generic.Error.LocationRestricted");
                return false;
            }
            return true;
        }

        private bool VerifyNotBuildingBlocked(IPlayer player)
        {
            if ((player.Object as BasePlayer).IsBuildingBlocked())
            {
                ReplyToPlayer(player, "Generic.Error.BuildingBlocked");
                return false;
            }
            return true;
        }

        private bool VerifySufficientSpace(IPlayer player, int numSockets, out Vector3 determinedPosition, out Quaternion determinedRotation)
        {
            var basePlayer = player.Object as BasePlayer;

            if (!TryGetIdealCarPositionAndRotation(basePlayer, numSockets, out determinedPosition, out determinedRotation)
                || !HasSufficientSpace(basePlayer, numSockets, determinedPosition, determinedRotation))
            {
                ReplyToPlayer(player, "Generic.Error.InsufficientSpace");
                return false;
            }

            return true;
        }

        private bool VerifyHasPreset(IPlayer player, SimplePresetManager presetManager, string presetName, out SimplePreset preset)
        {
            preset = presetManager.FindPreset(presetName);
            if (preset == null)
            {
                ReplyToPlayer(player, "Generic.Error.PresetNotFound", presetName);
                return false;
            }
            return true;
        }

        private bool VerifyNoMatchingPreset(IPlayer player, SimplePresetManager presetManager, string presetName)
        {
            var existingPreset = presetManager.FindPreset(presetName);
            if (existingPreset != null)
            {
                ReplyToPlayer(player, "Command.SavePreset.Error.PresetAlreadyExists", existingPreset.Name);
                return false;
            }
            return true;
        }

        private bool VerifyHasCar(IPlayer player, out ModularCar car)
        {
            car = FindPlayerCar(player);
            if (car == null)
            {
                ReplyToPlayer(player, "Generic.Error.CarNotFound");
                return false;
            }
            return true;
        }

        private bool VerifyHasNoCar(IPlayer player)
        {
            if (FindPlayerCar(player) == null)
                return true;

            var messages = new List<string> { GetMessage(player, "Command.Spawn.Error.CarAlreadyExists") };
            if (permission.UserHasPermission(player.Id, PermissionFetch))
                messages.Add(GetMessage(player, "Command.Spawn.Error.CarAlreadyExists.Help"));

            player.Reply(string.Join(" ", messages));
            return false;
        }

        private bool VerifyCarNotOccupied(IPlayer player, ModularCar car)
        {
            // Players can either be mounted in seats, or standing on flatbed modules.
            if (car.AnyMounted()
                || car.AttachedModuleEntities.Any(module => module.children.Any(child => child is BasePlayer)))
            {
                ReplyToPlayer(player, "Generic.Error.CarOccupied");
                return false;
            }
            return true;
        }

        private bool VerifyOffCooldown(IPlayer player, CooldownType cooldownType)
        {
            var secondsRemaining = _pluginData.GetRemainingCooldownSeconds(player.Id, cooldownType);
            if (secondsRemaining > 0)
            {
                ReplyToPlayer(player, "Generic.Error.Cooldown", secondsRemaining);
                return false;
            }
            return true;
        }

        private bool VerifyOnlyOneMatchingPreset(IPlayer player, SimplePresetManager presetManager, string presetName, out SimplePreset preset)
        {
            preset = presetManager.FindPreset(presetName);
            if (preset != null)
                return true;

            var matchingPresets = presetManager.FindMatchingPresets(presetName);
            var matchCount = matchingPresets.Count;

            if (matchCount == 0)
            {
                ReplyToPlayer(player, "Generic.Error.PresetNotFound", presetName);
                return false;
            }
            else if (matchCount > 1)
            {
                ReplyToPlayer(player, "Generic.Error.PresetMultipleMatches", presetName);
                return false;
            }

            preset = matchingPresets.First();
            return true;
        }

        #endregion

        #region Helper Methods - Cars

        private static int SortPresetNames(SimplePreset a, SimplePreset b) =>
            a.Name.ToLower() == DefaultPresetName ? -1 :
            b.Name.ToLower() == DefaultPresetName ? 1 :
            a.Name.CompareTo(b.Name);

        private static Vector3 GetCarExtents(int numSockets)
        {
            switch (numSockets)
            {
                case 2:
                    return ShortCarExtents;
                case 3:
                    return MediumCarExtents;
                default:
                    return LongCarExtents;
            }
        }

        private static void GetCarFrontBack(int numSockets, out Vector3 frontLeft, out Vector3 frontRight, out Vector3 backLeft, out Vector3 backRight)
        {
            switch (numSockets)
            {
                case 2:
                    frontLeft = ShortCarFrontLeft;
                    frontRight = ShortCarFrontRight;
                    backLeft = ShortCarBackLeft;
                    backRight = ShortCarBackRight;
                    return;
                case 3:
                    frontLeft = MediumCarFrontLeft;
                    frontRight = MediumCarFrontRight;
                    backLeft = MediumCarBackLeft;
                    backRight = MediumCarBackRight;
                    return;
                default:
                    frontLeft = LongCarFrontLeft;
                    frontRight = LongCarFrontRight;
                    backLeft = LongCarBackLeft;
                    backRight = LongCarBackRight;
                    return;
            }
        }

        private static int[] GetCarModuleIDs(ModularCar car)
        {
            var moduleIDs = new List<int>();

            for (int socketIndex = 0; socketIndex < car.TotalSockets; socketIndex++)
            {
                BaseVehicleModule module;
                if (car.TryGetModuleAt(socketIndex, out module) && module.FirstSocketIndex == socketIndex)
                    moduleIDs.Add(module.AssociatedItemDef.itemid);
                else
                    // Use 0 to represent an empty socket.
                    moduleIDs.Add(0);
            }

            return moduleIDs.ToArray();
        }

        private static Vector3 GetPlayerForwardPosition(BasePlayer player)
        {
            Vector3 forward = player.GetNetworkRotation() * Vector3.forward;
            forward.y = 0;
            return forward.normalized;
        }

        // Directly in front of the player.
        private static Vector3 GetFixedCarPosition(BasePlayer player)
        {
            Vector3 forward = GetPlayerForwardPosition(player);
            Vector3 position = player.transform.position + forward * 3f;
            position.y = player.transform.position.y + 1f;
            return position;
        }

        // On surface in front of player.
        private static bool TryGetIdealCarPositionAndRotation(BasePlayer player, int numSockets, out Vector3 position, out Quaternion rotation)
        {
            var carMiddle = player.eyes.position + GetPlayerForwardPosition(player) * ForwardRaycastDistance;

            Vector3 carFrontLeft, carFrontRight, carBackLeft, carBackRight;
            GetCarFrontBack(numSockets, out carFrontLeft, out carFrontRight, out carBackLeft, out carBackRight);

            var initialRotation = GetRelativeCarRotation(player);

            RaycastHit frontLeftHit, frontRightHit, backLeftHit, backRightHit;
            if (!Physics.Raycast(carMiddle + initialRotation * carFrontLeft, Vector3.down, out frontLeftHit, DownwardRaycastDistance, RaycastLayers, QueryTriggerInteraction.Ignore)
                || !Physics.Raycast(carMiddle + initialRotation * carFrontRight, Vector3.down, out frontRightHit, DownwardRaycastDistance, RaycastLayers, QueryTriggerInteraction.Ignore)
                || !Physics.Raycast(carMiddle + initialRotation * carBackLeft, Vector3.down, out backLeftHit, DownwardRaycastDistance, RaycastLayers, QueryTriggerInteraction.Ignore)
                || !Physics.Raycast(carMiddle + initialRotation * carBackRight, Vector3.down, out backRightHit, DownwardRaycastDistance, RaycastLayers, QueryTriggerInteraction.Ignore))
            {
                position = Vector3.zero;
                rotation = Quaternion.identity;
                return false;
            }

            // Rotate the car relative to the hit positions.
            rotation = Quaternion.LookRotation((frontLeftHit.point - backLeftHit.point), Vector3.up)
                * Quaternion.Euler(0, 0, (frontLeftHit.point - frontRightHit.point).y * 30);

            // Spawn in the midpoint between the front and back hits.
            position = Vector3.Lerp(frontLeftHit.point, backRightHit.point, 0.5f);

            return true;
        }

        private static void DetermineCarPositionAndRotation(BasePlayer player, int numSockets, out Vector3 position, out Quaternion rotation)
        {
            if (!TryGetIdealCarPositionAndRotation(player, numSockets, out position, out rotation))
            {
                position = GetFixedCarPosition(player);
                rotation = GetRelativeCarRotation(player);
            }
        }

        private static Quaternion GetRelativeCarRotation(BasePlayer player) =>
            Quaternion.Euler(0, player.GetNetworkRotation().eulerAngles.y - 90, 0);

        private static void AddInitialModules(ModularCar car, int[] ModuleIDs)
        {
            for (int socketIndex = 0; socketIndex < car.TotalSockets; socketIndex++)
            {
                var desiredItemID = ModuleIDs[socketIndex];

                // We are using 0 to represent an empty socket which we skip.
                if (desiredItemID != 0)
                {
                    var moduleItem = ItemManager.CreateByItemID(desiredItemID);
                    if (moduleItem != null)
                        car.TryAddModule(moduleItem, socketIndex);
                }
            }
        }

        private static void UpdateCarModules(ModularCar car, int[] moduleIDs)
        {
            // Phase 1: Remove all modules that don't match the desired preset.
            // This is done first since some modules take up two sockets.
            for (int socketIndex = 0; socketIndex < car.TotalSockets; socketIndex++)
            {
                var desiredItemID = moduleIDs[socketIndex];
                var existingItem = car.Inventory.ModuleContainer.GetSlot(socketIndex);

                if (existingItem != null && existingItem.info.itemid != desiredItemID)
                {
                    existingItem.RemoveFromContainer();
                    existingItem.Remove();
                }
            }

            // Phase 2: Add the modules that are missing.
            for (int socketIndex = 0; socketIndex < car.TotalSockets; socketIndex++)
            {
                var desiredItemID = moduleIDs[socketIndex];
                var existingItem = car.Inventory.ModuleContainer.GetSlot(socketIndex);

                // We are using 0 to represent an empty socket which we skip.
                if (existingItem == null && desiredItemID != 0)
                {
                    var moduleItem = ItemManager.CreateByItemID(desiredItemID);
                    if (moduleItem != null)
                        car.TryAddModule(moduleItem, socketIndex);
                }
            }
        }

        private static List<Item> AddEngineItemsAndReturnRemaining(ModularCar car, List<Item> engineItems)
        {
            var itemsByType = engineItems
                .GroupBy(item => item.info.GetComponent<ItemModEngineItem>().engineItemType)
                .ToDictionary(
                    grouping => grouping.Key,
                    grouping => grouping.OrderByDescending(item => item.info.GetComponent<ItemModEngineItem>().tier).ToList()
                );

            foreach (var module in car.AttachedModuleEntities)
            {
                var engineStorage = (module as VehicleModuleEngine)?.GetContainer() as EngineStorage;
                if (engineStorage == null)
                    continue;

                for (var slotIndex = 0; slotIndex < engineStorage.inventory.capacity; slotIndex++)
                {
                    var engineItemType = engineStorage.slotTypes[slotIndex];
                    if (!itemsByType.ContainsKey(engineItemType))
                        continue;

                    var itemsOfType = itemsByType[engineItemType];
                    var existingItem = engineStorage.inventory.GetSlot(slotIndex);
                    if (existingItem != null || itemsOfType.Count == 0)
                        continue;

                    itemsOfType[0].MoveToContainer(engineStorage.inventory, slotIndex, allowStack: false);
                    itemsOfType.RemoveAt(0);
                }
            }

            return itemsByType.Values.SelectMany(x => x).ToList();
        }

        private static void AddUpgradeOrRepairEngineParts(EngineStorage engineStorage, int desiredTier)
        {
            var inventory = engineStorage.inventory;
            if (inventory == null)
                return;

            // Ignore if the engine storage is locked, since it must be controlled by another plugin.
            if (inventory.IsLocked())
                return;

            for (var i = 0; i < inventory.capacity; i++)
            {
                var item = inventory.GetSlot(i);
                if (item != null)
                {
                    var component = item.info.GetComponent<ItemModEngineItem>();
                    if (component != null && component.tier < desiredTier)
                    {
                        item.RemoveFromContainer();
                        item.Remove();
                        TryAddEngineItem(engineStorage, i, desiredTier);
                    }
                    else
                        item.condition = item.maxCondition;
                }
                else if (desiredTier > 0)
                    TryAddEngineItem(engineStorage, i, desiredTier);
            }
        }

        private static bool TryAddEngineItem(EngineStorage engineStorage, int slot, int tier)
        {
            ItemModEngineItem output;
            if (!engineStorage.allEngineItems.TryGetItem(tier, engineStorage.slotTypes[slot], out output))
                return false;

            var component = output.GetComponent<ItemDefinition>();
            var item = ItemManager.Create(component);
            if (item == null)
                return false;

            item.condition = component.condition.max;
            item.MoveToContainer(engineStorage.inventory, slot, allowStack: false);

            return true;
        }

        private static List<Item> ExtractEnginePartsAboveTierAndDeleteRest(ModularCar car, int tier)
        {
            var extractedEngineParts = new List<Item>();

            foreach (var module in car.AttachedModuleEntities)
            {
                var engineStorage = (module as VehicleModuleEngine)?.GetContainer() as EngineStorage;
                if (engineStorage == null)
                    continue;

                var inventory = engineStorage.inventory;

                // Ignore if the engine storage is locked, since it must be controlled by another plugin.
                if (inventory.IsLocked())
                    continue;

                for (var i = 0; i < inventory.capacity; i++)
                {
                    var item = inventory.GetSlot(i);
                    if (item == null)
                        continue;

                    var component = item.info.GetComponent<ItemModEngineItem>();
                    if (component == null)
                        continue;

                    item.RemoveFromContainer();

                    if (component.tier > tier)
                        extractedEngineParts.Add(item);
                    else
                        item.Remove();
                }
            }

            return extractedEngineParts;
        }

        private static void GiveItemsToPlayerOrDrop(BasePlayer player, List<Item> itemList)
        {
            var itemsToDrop = new List<Item>();

            foreach (var item in itemList)
                if (!player.inventory.GiveItem(item))
                    itemsToDrop.Add(item);

            if (itemsToDrop.Count > 0)
                DropEngineParts(player, itemsToDrop);
        }

        private static void DropEngineParts(BasePlayer player, List<Item> itemList)
        {
            if (itemList.Count == 0)
                return;

            var position = player.GetDropPosition();
            if (itemList.Count == 1)
            {
                itemList[0].Drop(position, player.GetDropVelocity());
                return;
            }

            var container = GameManager.server.CreateEntity(ItemDropPrefab, position, player.GetNetworkRotation()) as DroppedItemContainer;
            if (container == null)
                return;

            container.playerName = $"{player.displayName}'s Engine Parts";

            // 4 large engines * 8 parts (each damaged) = 32 max engine parts.
            // This fits within the standard max size of 36.
            var capacity = Math.Min(itemList.Count, container.maxItemCount);

            container.inventory = new ItemContainer();
            container.inventory.ServerInitialize(null, capacity);
            container.inventory.GiveUID();
            container.inventory.entityOwner = container;
            container.inventory.SetFlag(ItemContainer.Flag.NoItemInput, true);

            foreach (var item in itemList)
                if (!item.MoveToContainer(container.inventory))
                    item.DropAndTossUpwards(position);

            container.ResetRemovalTime();
            container.SetVelocity(player.GetDropVelocity());
            container.Spawn();
        }

        private static void FixCar(ModularCar car, int fuelAmount, int enginePartsTier)
        {
            car.SetHealth(car.MaxHealth());
            car.SendNetworkUpdate();
            AddOrRestoreFuel(car, fuelAmount);

            foreach (var module in car.AttachedModuleEntities)
            {
                module.SetHealth(module.MaxHealth());
                module.SendNetworkUpdate();

                var engineModule = module as VehicleModuleEngine;
                if (engineModule != null)
                {
                    var engineStorage = engineModule.GetContainer() as EngineStorage;
                    AddUpgradeOrRepairEngineParts(engineStorage, enginePartsTier);
                    engineModule.RefreshPerformanceStats(engineStorage);
                }
            }
        }

        private static void ReviveCar(ModularCar car)
        {
            car.lifestate = BaseCombatEntity.LifeState.Alive;
            car.repair.enabled = true;

            foreach (var module in car.AttachedModuleEntities)
                module.repair.enabled = true;
        }

        private static void AddOrRestoreFuel(ModularCar car, int specifiedFuelAmount)
        {
            var fuelContainer = car.GetFuelSystem().GetFuelContainer();
            var targetFuelAmount = specifiedFuelAmount == -1 ? fuelContainer.allowedItem.stackable : specifiedFuelAmount;
            if (targetFuelAmount == 0)
                return;

            var fuelItem = fuelContainer.inventory.FindItemByItemID(fuelContainer.allowedItem.itemid);
            if (fuelItem == null)
            {
                fuelContainer.inventory.AddItem(fuelContainer.allowedItem, targetFuelAmount);
            }
            else if (fuelItem.amount < targetFuelAmount)
            {
                fuelItem.amount = targetFuelAmount;
                fuelItem.MarkDirty();
            }
        }

        private bool TryReleaseCarFromLift(ModularCar car)
        {
            ModularCarGarage lift;
            if (!TryFindCarLift(car, out lift))
                return false;

            // Disable the lift for a bit, to prevent it from grabbing the car back.
            lift.enabled = false;
            lift.ReleaseOccupant();
            lift.Invoke(() => lift.enabled = true, 0.5f);

            return true;
        }

        private bool TryFindCarLift(ModularCar car, out ModularCarGarage lift)
        {
            if (Physics.RaycastNonAlloc(car.transform.position, car.transform.right, _raycastBuffer, 2, Physics.DefaultRaycastLayers, QueryTriggerInteraction.Ignore) > 0)
            {
                lift = _raycastBuffer[0].GetEntity() as ModularCarGarage;
                if (lift != null && lift.carOccupant == car)
                    return true;
            }

            if (Physics.RaycastNonAlloc(car.transform.position, car.transform.right * -1, _raycastBuffer, 2, Physics.DefaultRaycastLayers, QueryTriggerInteraction.Ignore) > 0)
            {
                lift = _raycastBuffer[0].GetEntity() as ModularCarGarage;
                if (lift != null && lift.carOccupant == car)
                    return true;
            }

            lift = null;
            return false;
        }

        private static void DismountAllPlayersFromCar(ModularCar car)
        {
            // Dismount seated players.
            if (car.AnyMounted())
                car.DismountAllPlayers();

            // Dismount players standing on flatbed modules.
            foreach (var module in car.AttachedModuleEntities)
                foreach (var child in module.children.ToList())
                    if (child is BasePlayer)
                        (child as BasePlayer).SetParent(null, worldPositionStays: true);
        }

        private static void MaybeFillTankerModules(ModularCar car, int specifiedLiquidAmount)
        {
            if (specifiedLiquidAmount == 0)
                return;

            foreach (var module in car.AttachedModuleEntities)
            {
                var liquidContainer = (module as VehicleModuleStorage)?.GetContainer() as LiquidContainer;
                if (liquidContainer == null)
                    continue;

                if (FillLiquidContainer(liquidContainer, specifiedLiquidAmount) && _pluginConfig.EnableEffects)
                    Effect.server.Run(TankerFilledEffectPrefab, module.transform.position);
            }
        }

        private static bool FillLiquidContainer(LiquidContainer liquidContainer, int specifiedAmount)
        {
            var targetAmount = specifiedAmount == -1 ? liquidContainer.maxStackSize : specifiedAmount;
            var defaultItem = liquidContainer.defaultLiquid;
            var existingItem = liquidContainer.GetLiquidItem();

            if (existingItem == null)
            {
                liquidContainer.inventory.AddItem(defaultItem, targetAmount);
                return true;
            }

            if (existingItem.info.itemid != defaultItem.itemid)
            {
                // Remove other liquid such as salt water.
                existingItem.RemoveFromContainer();
                existingItem.Remove();
                liquidContainer.inventory.AddItem(defaultItem, targetAmount);
                return true;
            }

            if (existingItem.amount >= targetAmount)
                // Nothing added in this case.
                return false;

            existingItem.amount = targetAmount;
            existingItem.MarkDirty();
            return true;
        }

        private static void MaybePlayCarRepairEffects(ModularCar car)
        {
            if (!_pluginConfig.EnableEffects)
                return;

            if (car.AttachedModuleEntities.Count > 0)
                foreach (var module in car.AttachedModuleEntities)
                    Effect.server.Run(RepairEffectPrefab, module.transform.position);
            else
                Effect.server.Run(RepairEffectPrefab, car.transform.position);
        }

        private static int Clamp(int x, int min, int max) => Math.Min(max, Math.Max(min, x));

        private bool IsPlayerCar(ModularCar car) =>
            _pluginData.PlayerCars.ContainsValue(car.net.ID.Value);

        private ModularCar FindPlayerCar(IPlayer player)
        {
            if (!_pluginData.PlayerCars.ContainsKey(player.Id))
                return null;

            var car = BaseNetworkable.serverEntities.Find(new NetworkableId(_pluginData.PlayerCars[player.Id])) as ModularCar;

            // Just in case the car was removed and that somehow wasn't detected sooner.
            // This could happen if the data file somehow got out of sync for instance.
            if (car == null)
                _pluginData.UnregisterCar(player.Id);

            return car;
        }

        private bool HasSufficientSpace(BasePlayer player, int numSockets, Vector3 desiredPosition, Quaternion rotation)
        {
            var carExtents = GetCarExtents(numSockets);
            var carCenterPoint = desiredPosition + rotation * new Vector3(0, carExtents.y);

            // Need some extra height for the boxcast to allow spawning on a lift since lifts are construction.
            // Cars can't be spawned on sleepers.
            // Cars can still be spawned below ceiling lights.
            carCenterPoint.y += 0.3f;

            return Physics.BoxCastNonAlloc(carCenterPoint, carExtents, rotation * Vector3.forward, _raycastBuffer, rotation, 0.1f, BoxcastLayers, QueryTriggerInteraction.Ignore) == 0;
        }

        private int GetPlayerAllowedFreshWater(string userId) =>
            permission.UserHasPermission(userId, PermissionAutoFillTankers) && GetPlayerConfig(userId).Settings.AutoFillTankers ? _pluginConfig.FreshWaterAmount : 0;

        private int GetPlayerAllowedFuel(string userId) =>
            permission.UserHasPermission(userId, PermissionAutoFuel) ? _pluginConfig.FuelAmount : 0;

        private int GetPlayerEnginePartsTier(string userId)
        {
            if (permission.UserHasPermission(userId, PermissionEnginePartsTier3))
                return 3;
            else if (permission.UserHasPermission(userId, PermissionEnginePartsTier2))
                return 2;
            else if (permission.UserHasPermission(userId, PermissionEnginePartsTier1))
                return 1;
            else
                return 0;
        }

        private ushort GetPlayerMaxAllowedCarSockets(string userId)
        {
            if (permission.UserHasPermission(userId, PermissionSpawnSockets4))
                return 4;
            else if (permission.UserHasPermission(userId, PermissionSpawnSockets3))
                return 3;
            else if (permission.UserHasPermission(userId, PermissionSpawnSockets2))
                return 2;
            else
                return 0;
        }

        private void SpawnRandomCarForPlayer(IPlayer player, int desiredSockets)
        {
            var basePlayer = player.Object as BasePlayer;
            Vector3 spawnPosition;
            Quaternion rotation;
            if (!VerifySufficientSpace(player, desiredSockets, out spawnPosition, out rotation)
                || SpawnMyCarWasBlocked(basePlayer))
                return;

            var carOptions = new RandomCarOptions(player.Id, desiredSockets);
            var car = SpawnCar(carOptions, spawnPosition, rotation, basePlayer, shouldTrackCar: true);
            if (car == null)
                return;

            ReplyToPlayer(player, "Command.Spawn.Success");
        }

        private void SpawnPresetCarForPlayer(IPlayer player, SimplePreset preset)
        {
            if (preset.NumSockets > GetPlayerMaxAllowedCarSockets(player.Id))
            {
                ReplyToPlayer(player, "Generic.Error.NoPermissionToPresetSocketCount", preset.Name, preset.NumSockets);
                return;
            }

            var basePlayer = player.Object as BasePlayer;
            Vector3 spawnPosition;
            Quaternion rotation;
            if (!VerifySufficientSpace(player, preset.NumSockets, out spawnPosition, out rotation)
                || SpawnMyCarWasBlocked(basePlayer))
                return;

            var carOptions = new PresetCarOptions(player.Id, preset.ModuleIDs);
            var car = SpawnCar(carOptions, spawnPosition, rotation, basePlayer, shouldTrackCar: true);
            if (car == null)
                return;

            ReplyToPlayer(player, "Command.Spawn.Success.Preset", preset.Name);

            if (preset != null)
                MaybePlayCarRepairEffects(car);
        }

        private ModularCar SpawnCar(BaseCarOptions options, Vector3 position, Quaternion rotation, BasePlayer player = null, bool shouldTrackCar = false)
        {
            var numSockets = options.Length;

            string prefabName;
            if (numSockets == 4)
                prefabName = PrefabSockets4;
            else if (numSockets == 3)
                prefabName = PrefabSockets3;
            else if (numSockets == 2)
                prefabName = PrefabSockets2;
            else
                return null;

            var car = GameManager.server.CreateEntity(prefabName, position, rotation) as ModularCar;
            if (car == null)
                return null;

            var presetOptions = options as PresetCarOptions;
            if (presetOptions != null)
                car.spawnSettings.useSpawnSettings = false;

            if (player != null)
                car.OwnerID = player.userID;

            car.Spawn();

            if (presetOptions != null)
                AddInitialModules(car, presetOptions.NormalizedModuleIDs);

            if (shouldTrackCar && player != null)
            {
                _pluginData.StartCooldown(player.UserIDString, CooldownType.Spawn, save: false);
                _pluginData.RegisterCar(player.UserIDString, car);
            }

            // Force all modules to be processed and registered in AttachedModuleEntities.
            // This allows plugins to easily interact with the module entities such as to add engine parts.
            foreach (KeyValuePair<BaseVehicleModule, Action> entry in car.moduleAddActions.ToList())
            {
                entry.Key.CancelInvoke(entry.Value);
                entry.Value.Invoke();
            }

            FixCar(car, options.FuelAmount, options.EnginePartsTier);
            MaybeFillTankerModules(car, options.FreshWaterAmount);

            if (options.CodeLock && VehicleDeployedLocks != null)
                VehicleDeployedLocks.Call("API_DeployCodeLock", car, player);

            if (!options.CodeLock && options.KeyLock && VehicleDeployedLocks != null)
                VehicleDeployedLocks.Call("API_DeployKeyLock", car, player);

            return car;
        }

        private bool ShouldTryAddCodeLockForPlayer(string userId) =>
            permission.UserHasPermission(userId, PermissionAutoCodeLock) && GetPlayerConfig(userId).Settings.AutoCodeLock;

        private bool ShouldTryAddKeyLockForPlayer(string userId) =>
            permission.UserHasPermission(userId, PermissionAutoKeyLock) && GetPlayerConfig(userId).Settings.AutoKeyLock;

        private int[] ValidateModules(object[] moduleArray)
        {
            ItemManager.Initialize();

            var moduleIDList = new List<int>();

            foreach (var module in moduleArray)
            {
                ItemDefinition itemDef;

                if (module is int || module is long)
                {
                    var moduleInt = module is long ? Convert.ToInt32((long)module) : (int)module;
                    if (moduleInt == 0)
                    {
                        moduleIDList.Add(0);
                        continue;
                    }
                    itemDef = ItemManager.FindItemDefinition(moduleInt);
                }
                else if (module is string)
                {
                    int parsedItemId;
                    if (int.TryParse(module as string, out parsedItemId))
                    {
                        if (parsedItemId == 0)
                        {
                            moduleIDList.Add(0);
                            continue;
                        }
                        itemDef = ItemManager.FindItemDefinition(parsedItemId);
                    }
                    else
                        itemDef = ItemManager.FindItemDefinition(module as string);
                }
                else
                {
                    LogWarning("Unable to parse module id or name: '{0}'", module);
                    continue;
                }

                if (itemDef == null)
                {
                    LogWarning("No item definition found for: '{0}'", module);
                    continue;
                }

                var vehicleModule = itemDef.GetComponent<ItemModVehicleModule>();
                if (vehicleModule == null)
                {
                    LogWarning("No vehicle module found for item: '{0}'", module);
                    continue;
                }

                moduleIDList.Add(itemDef.itemid);

                // Normalize module IDs by adding 0s after the module if it takes multiple sockets.
                for (var i = 0; i < vehicleModule.SocketsTaken - 1; i++)
                    moduleIDList.Add(0);
            }

            return moduleIDList.ToArray();
        }

        #endregion

        #region Data Management

        private class PluginData : SimplePresetManager
        {
            [JsonProperty("playerCars")]
            public Dictionary<string, ulong> PlayerCars = new Dictionary<string, ulong>();

            [JsonProperty("Cooldowns")]
            public CooldownManager Cooldowns = new CooldownManager();

            public override List<SimplePreset> Presets { get; set; }
            public bool ShouldSerializePresets() => false;

            public static PluginData LoadData() =>
                Interface.Oxide.DataFileSystem.ReadObject<PluginData>(_pluginInstance.Name);

            public override void SaveData()
            {
                Interface.Oxide.DataFileSystem.WriteObject(_pluginInstance.Name, this);
            }

            public void RegisterCar(string userId, ModularCar car)
            {
                PlayerCars.Add(userId, car.net.ID.Value);
                SaveData();
            }

            public void UnregisterCar(string userId)
            {
                PlayerCars.Remove(userId);
                SaveData();
            }

            public long GetRemainingCooldownSeconds(string userId, CooldownType cooldownType)
            {
                long cooldownStart;
                if (!Cooldowns.GetCooldownMap(cooldownType).TryGetValue(userId, out cooldownStart))
                    return 0;

                var cooldownSeconds = _pluginConfig.Cooldowns.GetSeconds(cooldownType);
                return cooldownStart + cooldownSeconds - DateTimeOffset.UtcNow.ToUnixTimeSeconds();
            }

            public void StartCooldown(string userId, CooldownType cooldownType, bool save = true)
            {
                if (_pluginConfig.Cooldowns.GetSeconds(cooldownType) <= 0)
                    return;

                Cooldowns.GetCooldownMap(cooldownType)[userId] = DateTimeOffset.UtcNow.ToUnixTimeSeconds();

                if (save)
                    SaveData();
            }
        }

        private class CommonPresets : SimplePresetManager
        {
            private static string Filename =>
                $"{_pluginInstance.Name}_CommonPresets";

            public static CommonPresets LoadData(PluginData pluginData)
            {
                var data = Interface.Oxide.DataFileSystem.ReadObject<CommonPresets>(Filename);

                if (pluginData.Presets != null)
                {
                    if (data.Presets == null || data.Presets.Count == 0)
                    {
                        _pluginInstance.LogWarning($"Migrating common presets to separate data file: {Filename}.json.");
                        data.Presets = pluginData.Presets.ToList();
                        data.SaveData();
                    }
                    else
                    {
                        _pluginInstance.LogWarning($"Deleting common presets from main data file since they appear to have already been migrated to a separate data file: {Filename}.json.");
                    }
                    pluginData.Presets.Clear();
                    pluginData.SaveData();
                }

                return data;
            }

            public override void SaveData() =>
                Interface.Oxide.DataFileSystem.WriteObject(Filename, this);
        }

        private PlayerConfig GetPlayerConfig(IPlayer player) =>
            GetPlayerConfig(player.Id);

        private PlayerConfig GetPlayerConfig(string userId)
        {
            if (_playerConfigsMap.ContainsKey(userId))
                return _playerConfigsMap[userId];

            PlayerConfig config = PlayerConfig.Get(Name, userId);
            _playerConfigsMap.Add(userId, config);
            return config;
        }

        private enum CooldownType { Spawn, Fetch, Load, Fix }

        private class CooldownManager
        {
            [JsonProperty("Spawn")]
            private Dictionary<string, long> Spawn = new Dictionary<string, long>();

            [JsonProperty("Fetch")]
            private Dictionary<string, long> Fetch = new Dictionary<string, long>();

            [JsonProperty("LoadPreset")]
            private Dictionary<string, long> LoadPreset = new Dictionary<string, long>();

            [JsonProperty("Fix")]
            private Dictionary<string, long> Fix = new Dictionary<string, long>();

            public Dictionary<string, long> GetCooldownMap(CooldownType cooldownType)
            {
                switch (cooldownType)
                {
                    case CooldownType.Spawn:
                        return Spawn;
                    case CooldownType.Fetch:
                        return Fetch;
                    case CooldownType.Load:
                        return LoadPreset;
                    case CooldownType.Fix:
                        return Fix;
                    default:
                        _pluginInstance.LogWarning($"Cooldown not implemented for {cooldownType}");
                        return null;
                }
            }

            public void ClearAll()
            {
                Spawn.Clear();
                Fetch.Clear();
                LoadPreset.Clear();
                Fix.Clear();
            }
        }

        private abstract class SimplePresetManager
        {
            public static Func<SimplePreset, bool> MatchPresetName(string presetName) =>
                new Func<SimplePreset, bool>(preset => preset.Name.Equals(presetName, StringComparison.CurrentCultureIgnoreCase));

            [JsonProperty("Presets")]
            public virtual List<SimplePreset> Presets { get; set; } = new List<SimplePreset>();

            public SimplePreset FindPreset(string presetName) =>
                Presets.FirstOrDefault(MatchPresetName(presetName));

            public List<SimplePreset> FindMatchingPresets(string presetName) =>
                Presets.Where(preset => preset.Name.IndexOf(presetName, StringComparison.CurrentCultureIgnoreCase) >= 0).ToList();

            public bool HasPreset(string presetName) =>
                Presets.Any(MatchPresetName(presetName));

            public void SavePreset(SimplePreset newPreset)
            {
                Presets.Add(newPreset);
                SaveData();
            }

            public void UpdatePreset(SimplePreset newPreset)
            {
                var presetIndex = Presets.FindIndex(new Predicate<SimplePreset>(MatchPresetName(newPreset.Name)));
                if (presetIndex == -1)
                    return;

                Presets[presetIndex] = newPreset;
                SaveData();
            }

            public void RenamePreset(SimplePreset preset, string newName)
            {
                preset.Name = newName;
                SaveData();
            }

            public void DeletePreset(SimplePreset preset)
            {
                Presets.Remove(preset);
                SaveData();
            }

            public abstract void SaveData();
        }

        private class PlayerConfig : SimplePresetManager
        {
            public static PlayerConfig Get(string dirPath, string ownerID)
            {
                var filepath = $"{dirPath}/{ownerID}";

                var config = Interface.Oxide.DataFileSystem.ExistsDatafile(filepath) ?
                    Interface.Oxide.DataFileSystem.ReadObject<PlayerConfig>(filepath) :
                    new PlayerConfig(ownerID);

                config.Filepath = filepath;
                return config;
            }

            [JsonIgnore]
            private string Filepath;

            [JsonProperty("OwnerID")]
            public string OwnerID { get; private set; }

            [JsonProperty("Settings")]
            public PlayerSettings Settings = new PlayerSettings();

            public PlayerConfig(string ownerID)
            {
                OwnerID = ownerID;
            }

            public override void SaveData() =>
                Interface.Oxide.DataFileSystem.WriteObject(Filepath, this);
        }

        private class SimplePreset
        {
            public static SimplePreset FromCar(ModularCar car, string presetName)
            {
                return new SimplePreset
                {
                    Name = presetName,
                    ModuleIDs = GetCarModuleIDs(car)
                };
            }

            [JsonProperty("Name")]
            public string Name;

            [JsonProperty("ModuleIDs")]
            public int[] ModuleIDs;

            [JsonIgnore]
            public int NumSockets
            {
                get { return ModuleIDs.Length; }
            }
        }

        private class PlayerSettings
        {
            [JsonProperty("AutoCodeLock")]
            public bool AutoCodeLock = false;

            [JsonProperty("AutoKeyLock")]
            public bool AutoKeyLock = false;

            [JsonProperty("AutoFillTankers")]
            public bool AutoFillTankers = false;
        }

        #endregion

        #region Configuration

        private void MigrateConfig()
        {
            if (_pluginConfig.ValidateServerPresets())
            {
                LogWarning("Performing automatic config migration.");
                SaveConfig();
            }
        }

        private class Configuration : SerializableConfiguration
        {
            [JsonProperty("CanSpawnWhileBuildingBlocked")]
            public bool CanSpawnBuildingBlocked = false;

            [JsonProperty("CanFetchWhileBuildingBlocked")]
            public bool CanFetchBuildingBlocked = false;

            [JsonProperty("CanFetchWhileOccupied")]
            public bool CanFetchOccupied = false;

            [JsonProperty("CanDespawnWhileOccupied")]
            public bool CanDespawnOccupied = false;

            [JsonProperty("DismountPlayersOnFetch")]
            public bool DismountPlayersOnFetch = true;

            [JsonProperty("FuelAmount")]
            public int FuelAmount = 500;

            [JsonProperty("FreshWaterAmount")]
            public int FreshWaterAmount = -1;

            [JsonProperty("MaxPresetsPerPlayer")]
            public int MaxPresetsPerPlayer = 10;

            [JsonProperty("EnableEffects")]
            public bool EnableEffects = true;

            [JsonProperty("Cooldowns")]
            public CooldownConfig Cooldowns = new CooldownConfig();

            [JsonProperty("Presets")]
            public ServerPreset[] Presets = new ServerPreset[0];

            public ServerPreset FindPreset(string name)
            {
                var nameLower = name.ToLower();

                foreach (var preset in Presets)
                {
                    if (preset.Name.ToLower() == nameLower)
                    {
                        return preset;
                    }
                }

                return null;
            }

            public bool ValidateServerPresets()
            {
                var changed = false;

                foreach (var preset in Presets)
                    if (preset.Options.ValidateModules())
                        changed = true;

                return changed;
            }
        }

        private class ServerPreset
        {
            [JsonProperty("Name")]
            public string Name;

            [JsonProperty("Options")]
            public ServerPresetOptions Options;
        }

        private abstract class BaseCarOptions
        {
            private int _enginePartsTier = 0;

            [JsonProperty("CodeLock", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public bool CodeLock = false;

            [JsonProperty("EnginePartsTier", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public int EnginePartsTier
            {
                get { return _enginePartsTier; }
                set { _enginePartsTier = Clamp(value, 0, 3); }
            }

            [JsonProperty("FreshWaterAmount", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public int FreshWaterAmount = 0;

            [JsonProperty("FuelAmount", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public int FuelAmount = 0;

            [JsonProperty("KeyLock", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public bool KeyLock = false;

            [JsonIgnore]
            public abstract int Length { get; }

            public BaseCarOptions() { }

            public BaseCarOptions(string userId)
            {
                CodeLock = _pluginInstance.ShouldTryAddCodeLockForPlayer(userId);
                KeyLock = _pluginInstance.ShouldTryAddKeyLockForPlayer(userId);
                EnginePartsTier = _pluginInstance.GetPlayerEnginePartsTier(userId);
                FuelAmount = _pluginInstance.GetPlayerAllowedFuel(userId);
                FreshWaterAmount = _pluginInstance.GetPlayerAllowedFreshWater(userId);
            }
        }

        private class PresetCarOptions : BaseCarOptions
        {
            [JsonProperty("ModuleIDs")]
            public virtual int[] NormalizedModuleIDs { get; set; } = new int[0];

            [JsonIgnore]
            public override int Length
            {
                get { return NormalizedModuleIDs?.Length ?? 0; }
            }

            // Empty constructor needed for deserialization.
            public PresetCarOptions() { }

            public PresetCarOptions(string userId, int[] moduleIDs) : base(userId)
            {
                NormalizedModuleIDs = moduleIDs;
            }
        }

        private class RandomCarOptions : BaseCarOptions
        {
            public int NumSockets;

            public override int Length
            {
                get { return NumSockets; }
            }

            public RandomCarOptions(string userId, int numSockets) : base(userId)
            {
                NumSockets = numSockets;
            }
        }

        private class ServerPresetOptions : PresetCarOptions
        {
            // Override so we can avoid serializing it.
            public override int[] NormalizedModuleIDs { get; set; }

            // Hidden from config.
            public bool ShouldSerializeNormalizedModuleIDs() => false;

            [JsonProperty("Modules")]
            public object[] Modules;

            // Return value indicates whether the config was changed.
            public bool ValidateModules()
            {
                // Give precedence to "Modules".
                if (Modules != null)
                {
                    NormalizedModuleIDs = _pluginInstance.ValidateModules(Modules);
                }
                else if (NormalizedModuleIDs != null)
                {
                    // Resave the config with the field renamed to Modules.
                    // Must do this before normalizing so that no extra 0's are added.
                    Modules = NormalizedModuleIDs.Cast<object>().ToArray();
                    NormalizedModuleIDs = NormalizeModuleIDs(NormalizedModuleIDs);
                    return true;
                }

                return false;
            }

            private int[] NormalizeModuleIDs(int[] moduleIDs)
            {
                ItemManager.Initialize();

                var moduleIDList = moduleIDs.ToList();

                for (var i = 0; i < moduleIDList.Count; i++)
                {
                    if (moduleIDList[i] != 0)
                    {
                        // Add a 0 after each module that takes 2 sockets.
                        // This is more user-friendly than requiring people to add the 0s themselves.
                        var itemDefinition = ItemManager.FindItemDefinition(moduleIDList[i]);
                        var socketsTaken = itemDefinition.GetComponent<ItemModVehicleModule>()?.SocketsTaken ?? 1;
                        if (socketsTaken == 2)
                            moduleIDList.Insert(i + 1, 0);
                    }
                }

                return moduleIDList.ToArray();
            }
        }

        private class CooldownConfig
        {
            [JsonProperty("SpawnCarSeconds")]
            public long SpawnSeconds = 3600;

            [JsonProperty("FetchCarSeconds")]
            public long FetchSeconds = 600;

            [JsonProperty("LoadPresetSeconds")]
            public long LoadPresetSeconds = 3600;

            [JsonProperty("FixCarSeconds")]
            public long FixSeconds = 3600;

            public long GetSeconds(CooldownType cooldownType)
            {
                switch (cooldownType)
                {
                    case CooldownType.Spawn:
                        return SpawnSeconds;
                    case CooldownType.Fetch:
                        return FetchSeconds;
                    case CooldownType.Load:
                        return LoadPresetSeconds;
                    case CooldownType.Fix:
                        return FixSeconds;
                    default:
                        _pluginInstance.LogWarning($"Cooldown not implemented for {cooldownType}");
                        return 0;
                }
            }
        }

        private Configuration GetDefaultConfig() => new Configuration();

        #endregion

        #region Configuration Boilerplate

        private class SerializableConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(SerializableConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            bool changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _pluginConfig = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _pluginConfig = Config.ReadObject<Configuration>();
                if (_pluginConfig == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_pluginConfig))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_pluginConfig, true);
        }

        #endregion

        #region Localization

        private string BooleanToLocalizedString(IPlayer player, bool value) =>
            value ? GetMessage(player, "Generic.Setting.On") : GetMessage(player, "Generic.Setting.Off");

        private void ReplyToPlayer(IPlayer player, string messageName, params object[] args) =>
            player.Reply(string.Format(GetMessage(player, messageName), args));

        private void ChatMessage(BasePlayer player, string messageName, params object[] args) =>
            player.ChatMessage(string.Format(GetMessage(player.IPlayer, messageName), args));

        private string GetMessage(IPlayer player, string messageName, params object[] args)
        {
            var message = lang.GetMessage(messageName, this, player.Id);
            return args.Length > 0 ? string.Format(message, args) : message;
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Generic.Setting.On"] = "<color=yellow>ON</color>",
                ["Generic.Setting.Off"] = "<color=#bbb>OFF</color>",

                ["Generic.Error.NoPermission"] = "You don't have permission to use this command.",
                ["Generic.Error.LocationRestricted"] = "Error: Cannot do that here.",
                ["Generic.Error.BuildingBlocked"] = "Error: Cannot do that while building blocked.",
                ["Generic.Error.NoPresets"] = "You don't have any saved presets.",
                ["Generic.Error.NoCommonPresets"] = "There are no common presets.",
                ["Generic.Error.CarNotFound"] = "Error: You need a car to do that.",
                ["Generic.Error.CarOccupied"] = "Error: Cannot do that while your car is occupied.",
                ["Generic.Error.Cooldown"] = "Please wait <color=yellow>{0}s</color> and try again.",
                ["Generic.Error.NoPermissionToPresetSocketCount"] = "Error: You don't have permission to use preset <color=yellow>{0}</color> because it requires <color=yellow>{1}</color> sockets.",
                ["Generic.Error.PresetNotFound"] = "Error: Preset <color=yellow>{0}</color> not found.",
                ["Generic.Error.PresetMultipleMatches"] = "Error: Multiple presets found matching <color=yellow>{0}</color>. Use <color=yellow>mycar list</color> to view your presets.",
                ["Generic.Error.PresetAlreadyTaken"] = "Error: Preset <color=yellow>{0}</color> is already taken.",
                ["Generic.Error.PresetNameLength"] = "Error: Preset name may not be longer than {0} characters.",
                ["Generic.Error.InsufficientSpace"] = "Error: Not enough space.",

                ["Generic.Info.CarDestroyed"] = "Your modular car was destroyed.",
                ["Generic.Info.PartsRecovered"] = "Recovered engine components were added to your inventory or dropped in front of you.",

                ["Command.Spawn.Error.SocketSyntax"] = "Syntax: <color=yellow>mycar <2|3|4></color>",
                ["Command.Spawn.Error.CarAlreadyExists"] = "Error: You already have a car.",
                ["Command.Spawn.Error.CarAlreadyExists.Help"] = "Try <color=yellow>mycar fetch</color> or <color=yellow>mycar help</color>.",
                ["Command.Spawn.Success"] = "Here is your modular car.",
                ["Command.Spawn.Success.Preset"] = "Here is your modular car from preset <color=yellow>{0}</color>.",

                ["Command.Fix.Success"] = "Your car was fixed.",
                ["Command.Fetch.Error.StuckOnLift"] = "Error: Unable to fetch your car from its lift.",
                ["Command.Fetch.Error.StuckOnLift.Help"] = "You can use <color=yellow>mycar destroy</color> to destroy it.",
                ["Command.Fetch.Success"] = "Here is your modular car.",

                ["Command.SavePreset.Error.TooManyPresets"] = "Error: You may not have more than <color=yellow>{0}</color> presets. You may delete another preset and try again. See <color=yellow>mycar help</color>.",
                ["Command.SavePreset.Error.PresetAlreadyExists"] = "Error: Preset <color=yellow>{0}</color> already exists. Use <color=yellow>mycar update {0}</color> to update it.",
                ["Command.SavePreset.Success"] = "Saved car as <color=yellow>{0}</color> preset.",
                ["Command.UpdatePreset.Success"] = "Updated <color=yellow>{0}</color> preset with current module configuration.",
                ["Command.LoadPreset.Error.SocketCount"] = "Error: Unable to load <color=yellow>{0}</color> preset (<color=yellow>{1}</color> sockets) because your car has <color=yellow>{2}</color> sockets.",
                ["Command.LoadPreset.Success"] = "Loaded <color=yellow>{0}</color> preset onto your car.",
                ["Command.DeletePreset.Success"] = "Deleted <color=yellow>{0}</color> preset.",
                ["Command.RenamePreset.Error.Syntax"] = "Syntax: <color=yellow>mycar rename <name> <new_name></color>",
                ["Command.RenamePreset.Success"] = "Renamed <color=yellow>{0}</color> preset to <color=yellow>{1}</color>",
                ["Command.List"] = "Your saved modular car presets:",
                ["Command.List.Item"] = "<color=yellow>{0}</color> ({1} sockets)",

                ["Command.Common.List"] = "Common modular car presets:",
                ["Command.Common.Error.Syntax"] = "Try <color=yellow>mycar help</color>",
                ["Command.Common.LoadPreset.Error.Syntax"] = "Syntax: <color=yellow>mycar common load <name></color>",
                ["Command.Common.SavePreset.Error.Syntax"] = "Syntax: <color=yellow>mycar common save <name></color>",
                ["Command.Common.SavePreset.Error.PresetAlreadyExists"] = "Error: Common preset <color=yellow>{0}</color> already exists. Use <color=yellow>mycar common update {0}</color> to update it.",
                ["Command.Common.UpdatePreset.Error.Syntax"] = "Syntax: <color=yellow>mycar common update <name></color>",
                ["Command.Common.RenamePreset.Error.Syntax"] = "Syntax: <color=yellow>mycar common rename <name> <new_name></color>",
                ["Command.Common.DeletePreset.Error.Syntax"] = "Syntax: <color=yellow>mycar common delete <name></color>",

                ["Command.ToggleAutoCodeLock.Success"] = "<color=yellow>AutoCodeLock</color> set to {0}",
                ["Command.ToggleAutoKeyLock.Success"] = "<color=yellow>AutoKeyLock</color> set to {0}",
                ["Command.ToggleAutoFillTankers.Success"] = "<color=yellow>AutoFillTankers</color> set to {0}",

                ["Command.Give.Error.Syntax"] = "Syntax: <color=yellow>givecar <player> <preset></color>",
                ["Command.Give.Error.PlayerNotFound"] = "Error: Player <color=yellow>{0}</color> not found.",
                ["Command.Give.Error.PresetTooFewModules"] = "Error: Preset <color=yellow>{0}</color> has too few modules ({1}).",
                ["Command.Give.Error.PresetTooManyModules"] = "Error: Preset <color=yellow>{0}</color> has too many modules ({1}).",
                ["Command.Give.Success"] = "Modular car given to <color=yellow>{0}</color> from preset <color=yellow>{1}</color>.",

                ["Command.Help"] = "<color=orange>SpawnModularCar Command Usages</color>",
                ["Command.Help.Spawn.Basic"] = "<color=yellow>mycar</color> - Spawn a random car with max allowed sockets",
                ["Command.Help.Spawn.Basic.PresetsAllowed"] = "<color=yellow>mycar</color> - Spawn a car using your <color=yellow>default</color> preset if saved, else spawn a random car with max allowed sockets",
                ["Command.Help.Spawn.Sockets"] = "<color=yellow>mycar <2|3|4></color> - Spawn a random car of desired length",
                ["Command.Help.Fetch"] = "<color=yellow>mycar fetch</color> - Fetch your car",
                ["Command.Help.Fix"] = "<color=yellow>mycar fix</color> - Fix your car",
                ["Command.Help.Destroy"] = "<color=yellow>mycar destroy</color> - Destroy your car",

                ["Command.Help.Section.PersonalPresets"] = "<color=orange>--- Personal presets ---</color>",
                ["Command.Help.ListPresets"] = "<color=yellow>mycar list</color> - List your saved presets",
                ["Command.Help.Spawn.Preset"] = "<color=yellow>mycar <name></color> - Spawn a car from a saved preset",
                ["Command.Help.LoadPreset"] = "<color=yellow>mycar load <name></color> - Load a preset onto your car",
                ["Command.Help.SavePreset"] = "<color=yellow>mycar save <name></color> - Save your car as a preset",
                ["Command.Help.UpdatePreset"] = "<color=yellow>mycar update <name></color> - Overwrite a preset",
                ["Command.Help.RenamePreset"] = "<color=yellow>mycar rename <name> <new_name></color> - Rename a preset",
                ["Command.Help.DeletePreset"] = "<color=yellow>mycar delete <name></color> - Delete a preset",

                ["Command.Help.Section.CommonPresets"] = "<color=orange>--- Common presets ---</color>",
                ["Command.Help.Common.ListPresets"] = "<color=yellow>mycar common list</color> - List common presets",
                ["Command.Help.Common.Spawn"] = "<color=yellow>mycar common <name></color> - Spawn a car from a common preset",
                ["Command.Help.Common.LoadPreset"] = "<color=yellow>mycar common load <name></color> - Load a common preset onto your car",
                ["Command.Help.Common.SavePreset"] = "<color=yellow>mycar common save <name></color> - Save your car as a common preset",
                ["Command.Help.Common.UpdatePreset"] = "<color=yellow>mycar common update <name></color> - Overwrite a common preset",
                ["Command.Help.Common.RenamePreset"] = "<color=yellow>mycar common rename <name> <new_name></color> - Rename a common preset",
                ["Command.Help.Common.DeletePreset"] = "<color=yellow>mycar common delete <name></color> - Delete a common preset",

                ["Command.Help.Section.PersonalSettings"] = "<color=orange>--- Personal settings ---</color>",
                ["Command.Help.ToggleAutoCodeLock"] = "<color=yellow>mycar autocodelock</color> - Toggle AutoCodeLock: {0}",
                ["Command.Help.ToggleAutoKeyLock"] = "<color=yellow>mycar autokeylock</color> - Toggle AutoKeyLock: {0}",
                ["Command.Help.ToggleAutoFillTankers"] = "<color=yellow>mycar autofilltankers</color> - Toggle automatic filling of tankers with fresh water: {0}",

                ["Command.Help.Section.OtherCommands"] = "<color=orange>--- Other commands ---</color>",
                ["Command.Help.Give"] = "<color=yellow>givecar <player> <preset></color> - Spawn a car for the target player from the specified server preset",
            }, this);
        }

        #endregion
    }
}


// --- End of file: SpawnModularCar.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/CommercialNick.cs ---
// --- Original Local Path: TrashRust/CommercialNick.cs ---

﻿using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using ConVar;

namespace Oxide.Plugins
{
    [Info("CommercialNick+", "DezLife", "2.5.13")]
    [Description("Плагин позволяющий давать награду за приставку в нике , например название вашего сервера")]

    class CommercialNick : RustPlugin
    {
        [PluginReference] Plugin IQChat;

        #region config
        private Configuration config;

        public class Configuration
        {
            [JsonProperty("Наградить за что то в нике:")]
            public List<string> CONF_BlockedParts;
            [JsonProperty("Настройки")]
            public setings seting;
        }

        public class setings
        {
            [JsonProperty("Использовать выдачу баланса ?")]
            public bool GameStore;
            [JsonProperty("Бонус в виде баланса GameStores или OVH (если не нужно оставить пустым)")]
            public string GameStoreBonus;
            [JsonProperty("У вас магазин ОВХ?")]
            public bool OVHStore;
            [JsonProperty("Store id")]
            public string storeid;
            [JsonProperty("Store key")]
            public string storekey;
            [JsonProperty("Лог сообщения(Показывается в магазине после выдачи в истории. Если OVH оставить пустым)")]
            public string GameStoreMSG;
            [JsonProperty("Использовать выдачу привилегии")]
            public bool commands;
            [JsonProperty("Команда для выдачи")]
            public string commandsgo;
            [JsonProperty("Названия того что он получит от команды")]
            public string commandprize;
            [JsonProperty("Время которое нужно отыграть игроку с приставкой в нике что бы получить награду (секунды)")]
            public int timeplay;
            [JsonProperty("Разршить после вайпа получить приз заново")]
            public bool wipeclear;
        }

        protected override void LoadDefaultConfig()
        {
            config = new Configuration()
            {
                CONF_BlockedParts = new List<string>()
                {
                   "PONYLAND",
                   "PONY LAND",
                   "pony land",
                   "ponyland",
                   "DURACHOCK",
                   "Pony Land",
                },
                seting = new setings
                {
                    GameStore = false,
                    GameStoreBonus = "",
                    OVHStore = false,
                    storeid = "storeid",
                    storekey = "storekey",
                    GameStoreMSG = "За заход после вайпа:3",
                    commands = true,
                    commandsgo = "addgroup %STEAMID% vip 226d",
                    commandprize = "vip",
                    timeplay = 500,
                    wipeclear = true,
                },
            };
            SaveConfig(config);
        }

        void SaveConfig(Configuration config)
        {
            Config.WriteObject(config, true);
            SaveConfig();
        }

        public void LoadConfigVars()
        {
            config = Config.ReadObject<Configuration>();
            Config.WriteObject(config, true);
        }

        #endregion

        #region data
        private Dictionary<ulong, bool> ConnectedPlayers = new Dictionary<ulong, bool>();
        #endregion

        void OnNewSave(string filename)
        {
            if (config.seting.wipeclear)
            {
                ConnectedPlayers.Clear();
                PrintWarning("Обнаружен WIPE . Дата игроков сброшена");
            }
        }

        private void OnServerInitialized()
        {
            #region Load Config / Lang
            LoadConfigVars();
            #endregion

            if (Interface.Oxide.DataFileSystem.ExistsDatafile("CommercialNick/PlayerInfo"))
                ConnectedPlayers = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, bool>>("CommercialNick/PlayerInfo");

            for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
            {
                OnPlayerConnected(BasePlayer.activePlayerList[i]);
            }

            #region info   

            if (!string.IsNullOrEmpty(config.seting.GameStoreBonus) && !config.seting.OVHStore)
            {
                if (config.seting.storeid == "storeid" || config.seting.storekey == "storekey")
                {
                    PrintError("Вы не настроили ID И KEY от магазина GameStores");
                }
            }
            #endregion
        }

        void OnServerSave()
        {
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("CommercialNick/PlayerInfo", ConnectedPlayers);

        }
        private void Unload()
        {
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("CommercialNick/PlayerInfo", ConnectedPlayers);
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (!ConnectedPlayers.ContainsKey(player.userID))
            {
                ConnectedPlayers.Add(player.userID, false);
                Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("CommercialNick/PlayerInfo", ConnectedPlayers);
            }

            NextTick(() => {
                NickName(player);
            });
        }

        void NickName(BasePlayer player)
        {
            if (!ConnectedPlayers.ContainsKey(player.userID))
            {
                OnPlayerConnected(player);
                return;
            }
            if (ContainsAny(player.displayName, config.CONF_BlockedParts) && ConnectedPlayers[player.userID] == false)
            {
                timer.Once(config.seting.timeplay, () =>
                {
                    PrizeGive(player.userID);
                });
            }
        }

        public void PrizeGive(ulong id)
        {
            if (ConnectedPlayers[id])
                return;

            BasePlayer player = BasePlayer.FindByID(id);
            if (config.seting.commands)
            {
                ConnectedPlayers[player.userID] = true;
                Server.Command(config.seting.commandsgo.Replace("%STEAMID%", player.userID.ToString()));
                LogToFile("ConnectPlayer", $" [{player.userID}] получил {config.seting.commandsgo}", this);
                SendChat($"Вы получили награду в виде {config.seting.commandprize}. Награда за приставку в нике", player);
            }
            try
            {
                if (!config.seting.OVHStore)
                {
                    webrequest.Enqueue($"https://gamestores.ru/api?shop_id={config.seting.storeid}&secret={config.seting.storekey}&action=moneys&type=plus&steam_id={id}&amount={config.seting.GameStoreBonus}&mess={config.seting.GameStoreMSG}", null, (i, s) =>
                    {
                        if (i != 200)
                        {
                        }
                        if (s.Contains("success"))
                        {
                            ConnectedPlayers[id] = true;
                            LogToFile("ConnectPlayer", $" [{id}] получил {config.seting.GameStoreBonus} рублей", this);
                            SendChat($"Вы получили награду в виде {config.seting.GameStoreBonus} рублей. Награда за приставку в нике", player);
                        }
                        if (s.Contains("fail"))
                        {
                            SendChat("Вы не получили приз за приставку в ники т.к не авторизованы в магазине.", player);
                            return;
                        }
                    }, this);
                }
                else if (config.seting.OVHStore)
                {
                    plugins.Find("RustStore").CallHook("APIChangeUserBalance", id, config.seting.GameStoreBonus, new Action<string>((result) =>
                    {
                        if (result == "SUCCESS")
                        {
                            ConnectedPlayers[id] = true;
                            LogToFile("ConnectPlayer", $" [{id}] получил {config.seting.GameStoreBonus} рублей", this);
                            SendChat($"Вы получили награду в виде {config.seting.GameStoreBonus} рублей. Награда за приставку в нике", player);
                        }
                        else
                        {
                            SendChat("Вы не получили приз за приставку в ники т.к не авторизованы в магазине.", player);
                            return;
                        }
                    }));
                }
            }
            catch(Exception ex)
            {
                LogToFile(Title, ex.ToString(), this);
            }
            
        }


        #region helpers

        #region ReplyMSG

        public void SendChat(string Message, BasePlayer player, Chat.ChatChannel channel = Chat.ChatChannel.Global)
        {
            if (IQChat)
                IQChat?.Call("API_ALERT_PLAYER", player, Message);
            else player.SendConsoleCommand("chat.add", channel, 0, Message);
        }
        #endregion

        private bool ContainsAny(string input, List<string> check)
        {
            foreach (var str in check)
            {
                var word = str.ToLower();
                if (input.ToLower().Contains(word))
                {
                    return true;
                }
            }
            return false;
        }
        #endregion
    }
}


// --- End of file: CommercialNick.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/Settings.cs ---
// --- Original Local Path: TrashRust/Settings.cs ---

﻿using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Settings", "VooDoo", "1.0.0")]
    [Description("Settings switch's")]
    public class Settings : RustPlugin
    {
        [PluginReference] Plugin XMenu;

        #region Config
        public Dictionary<ulong, Dictionary<int, UserSettings>> userSettings = new Dictionary<ulong, Dictionary<int, UserSettings>>();
        public class UserSettings
        {
            public bool isOn;
            public Dictionary<int, UserSettings> settings;
        }

        private PluginConfig config;
        private class PluginConfig
        {
            public ColorConfig colorConfig;
            public class ColorConfig
            {
                public string menuContentHighlighting;
                public string menuContentHighlightingalternative;

                public string gradientColor;
            }

            public Dictionary<int, PluginSettings> pluginSettings;
            public class PluginSettings
            {
                public string commandDescription;
                public string command;
                public bool isChecked;
                public bool onlyOne;

                public Dictionary<int, PluginSettings> subSettings;
            }
        }

        private void Init()
        {
            config = Config.ReadObject<PluginConfig>();
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                colorConfig = new PluginConfig.ColorConfig()
                {
                    menuContentHighlighting = "#0000007f",
                    menuContentHighlightingalternative = "#FFFFFF10",

                    gradientColor = "#00000099",
                },

                pluginSettings = new Dictionary<int, PluginConfig.PluginSettings>()
                {
                    [0] = new PluginConfig.PluginSettings
                    {
                        commandDescription = "Описание пункта в меню настроек",
                        command = "chat.say Switch",
                        isChecked = false,
                        onlyOne = true,
                        subSettings = new Dictionary<int, PluginConfig.PluginSettings>()
                        {
                            [0] = new PluginConfig.PluginSettings
                            {
                                commandDescription = "Описание подпункта #1",
                                command = "chat.say SubSwitch1",
                                isChecked = true,
                                subSettings = null,
                                onlyOne = false
                            },
                            [1] = new PluginConfig.PluginSettings
                            {
                                commandDescription = "Описание подпункта #2",
                                command = "chat.say SubSwitch2",
                                isChecked = true,
                                subSettings = null,
                                onlyOne = false
                            },
                            [2] = new PluginConfig.PluginSettings
                            {
                                commandDescription = "Описание подпункта #3",
                                command = "chat.say SubSwitch3",
                                isChecked = true,
                                subSettings = null,
                                onlyOne = false
                            }
                        }
                     },
                    [1] = new PluginConfig.PluginSettings
                    {
                        commandDescription = "Описание пункта в меню настроек",
                        command = "chat.say Switch",
                        isChecked = false,
                        onlyOne = false,
                        subSettings = new Dictionary<int, PluginConfig.PluginSettings>()
                        {
                            [0] = new PluginConfig.PluginSettings
                            {
                                commandDescription = "Описание подпункта #1",
                                command = "chat.say SubSwitch1",
                                isChecked = true,
                                subSettings = null,
                                onlyOne = false
                            },
                            [1] = new PluginConfig.PluginSettings
                            {
                                commandDescription = "Описание подпункта #2",
                                command = "chat.say SubSwitch2",
                                isChecked = true,
                                subSettings = null,
                                onlyOne = false
                            },
                            [2] = new PluginConfig.PluginSettings
                            {
                                commandDescription = "Описание подпункта #3",
                                command = "chat.say SubSwitch3",
                                isChecked = true,
                                subSettings = null,
                                onlyOne = false
                            }
                        }
                    },
                    [2] = new PluginConfig.PluginSettings
                    {
                        commandDescription = "Описание пункта в меню настроек",
                        command = "chat.say Switch",
                        isChecked = false,
                        onlyOne = true,
                        subSettings = new Dictionary<int, PluginConfig.PluginSettings>()
                        {
                            [0] = new PluginConfig.PluginSettings
                            {
                                commandDescription = "Описание подпункта #1",
                                command = "chat.say SubSwitch1",
                                isChecked = true,
                                subSettings = null,
                                onlyOne = false
                            },
                            [1] = new PluginConfig.PluginSettings
                            {
                                commandDescription = "Описание подпункта #2",
                                command = "chat.say SubSwitch2",
                                isChecked = true,
                                subSettings = null,
                                onlyOne = false
                            },
                            [2] = new PluginConfig.PluginSettings
                            {
                                commandDescription = "Описание подпункта #3",
                                command = "chat.say SubSwitch3",
                                isChecked = true,
                                subSettings = null,
                                onlyOne = false
                            }
                        }
                    }
                }
            };
        }
        #endregion

        #region Layers
        public const string MenuLayer = "XMenu";
        public const string MenuItemsLayer = "XMenu.MenuItems";
        public const string MenuSubItemsLayer = "XMenu.MenuSubItems";
        public const string MenuContent = "XMenu.Content";
        #endregion


        Timer TimerInitialize;
        private void OnServerInitialized()
        {
            TimerInitialize = timer.Every(5f, () =>
            {
                if (XMenu.IsLoaded)
                {
                    XMenu.Call("API_RegisterSubMenu", this.Name, "Main", "Настройки", "RenderSettings", null);

                    int SettingsID = (int)XMenu.Call("API_GetSubMenuID", "Main", "Настройки");
                    cmd.AddChatCommand("settings", this, (p, cmd, args) => rust.RunClientCommand(p, $"custommenu true Main {SettingsID}"));

                    TimerInitialize.Destroy();
                }
            });

            foreach (var p in BasePlayer.activePlayerList) { OnPlayerConnected(p); }
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player == null)
                return;

            if (player.IsReceivingSnapshot)
            {
                timer.In(1f, () => OnPlayerConnected(player));
                return;
            }

            if (!userSettings.ContainsKey(player.userID))
            {
                userSettings.Add(player.userID, new Dictionary<int, UserSettings>());

                foreach(var settings in config.pluginSettings)
                {
                    userSettings[player.userID].Add(settings.Key, new UserSettings()
                    {
                            isOn = settings.Value.isChecked,
                            settings = new Dictionary<int, UserSettings>()
                    });

                    foreach(var subSettings in settings.Value.subSettings)
                    {
                        userSettings[player.userID][settings.Key].settings.Add(subSettings.Key, new UserSettings()
                        {
                            isOn = subSettings.Value.isChecked,
                            settings = null
                        });
                    }
                }
            }
            else
            {
                foreach (var settings in config.pluginSettings)
                {
                    if (!userSettings[player.userID].ContainsKey(settings.Key))
                    {
                        userSettings[player.userID].Add(settings.Key, new UserSettings()
                        {
                            isOn = settings.Value.isChecked,
                            settings = new Dictionary<int, UserSettings>()
                        });
                    }

                    foreach (var subSettings in settings.Value.subSettings)
                    {
                        if (!userSettings[player.userID][settings.Key].settings.ContainsKey(subSettings.Key))
                        {
                            userSettings[player.userID][settings.Key].settings.Add(subSettings.Key, new UserSettings()
                            {
                                isOn = subSettings.Value.isChecked,
                                settings = null
                            });
                        }
                    }
                }
            }
        }

        private void RenderSettings(ulong userID, object[] objects)
        {
            CuiElementContainer Container = (CuiElementContainer)objects[0];
            bool FullRender = (bool)objects[1];
            string Name = (string)objects[2];
            int ID = (int)objects[3];
            int Page = (int)objects[4];

            Container.Add(new CuiElement
            {
                Name = MenuContent,
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0 0 0 0",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-215 -230",
                            OffsetMax = "500 270"
                        },
                    }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info",
                Parent = MenuContent,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "80 -460",
                            OffsetMax = "630 -10"
                        }
                    }
            });

            for(int i = 0, x = 0; i < config.pluginSettings.Count; i++)
            {
                string text = $"<color=#FFFFFF66>☐  {config.pluginSettings.ElementAt(i).Value.commandDescription}</color>";
                if(userSettings[userID][config.pluginSettings.ElementAt(i).Key].isOn)
                    text = $"<color=#FFFFFF>☑  {config.pluginSettings.ElementAt(i).Value.commandDescription}</color>";

                Container.Add(new CuiElement
                {
                    Name = MenuContent + ".Info" + $".{i}.-1",
                    Parent = MenuContent + ".Info",
                    Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = text,
                                    Align = TextAnchor.MiddleLeft,
                                    FontSize = 16,
                                    Font = "robotocondensed-regular.ttf",
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1",
                                    AnchorMax = "0 1",
                                    OffsetMin = $"30 {-50 - x * 25}",
                                    OffsetMax = $"550 {-25 - x * 25}"
                                }
                            }
                });

                Container.Add(new CuiButton
                {
                    Button = { Color = "1 1 1 0", Command = $"settings.sendcommand {x} {i} -1 {config.pluginSettings.ElementAt(i).Value.command.Replace("%STEAMID%", userID.ToString())}" },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", },
                    Text = { Text = "", Align = TextAnchor.MiddleCenter }
                }, MenuContent + ".Info" + $".{i}.-1", MenuContent + ".Info" + $".{i}.Btn");
                x++;

                for(int j = 0; j < config.pluginSettings.ElementAt(i).Value.subSettings.Count; j++)
                {
                    string subText = $"<color=#FFFFFF66>☐  {config.pluginSettings.ElementAt(i).Value.subSettings.ElementAt(j).Value.commandDescription}</color>";
                    if (userSettings[userID][config.pluginSettings.ElementAt(i).Key].settings.ElementAt(j).Value.isOn)
                        subText = $"<color=#FFFFFF>☑  {config.pluginSettings.ElementAt(i).Value.subSettings.ElementAt(j).Value.commandDescription}</color>";

                    Container.Add(new CuiElement
                    {
                        Name = MenuContent + ".Info" + $".{i}.{j}",
                        Parent = MenuContent + ".Info",
                        Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = subText,
                                    Align = TextAnchor.MiddleLeft,
                                    FontSize = 16,
                                    Font = "robotocondensed-regular.ttf",
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1",
                                    AnchorMax = "0 1",
                                    OffsetMin = $"60 {-50 - x * 25}",
                                    OffsetMax = $"550 {-25 - x * 25}"
                                }
                            }
                    });
                    Container.Add(new CuiButton
                    {
                        Button = { Color = "1 1 1 0", Command = $"settings.sendcommand {x} {i} {j} {config.pluginSettings.ElementAt(i).Value.subSettings.ElementAt(j).Value.command.Replace("%STEAMID%", userID.ToString())}" },
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", },
                        Text = { Text = "", Align = TextAnchor.MiddleCenter }
                    }, MenuContent + ".Info" + $".{i}.{j}", MenuContent + ".Info" + $".{i}.{j}.Btn");
                    x++;
                }
            }
        }

        [ConsoleCommand("settings.sendcommand")]
        private void SendCommand(ConsoleSystem.Arg arg)
        {
            if (arg.HasArgs(4))
            {
                int x = int.Parse(arg.Args[0]);
                int i = int.Parse(arg.Args[1]);
                int j = int.Parse(arg.Args[2]);

                string command = string.Join(" ", arg.Args.Skip(3));

                rust.RunClientCommand(arg.Player(), command.Replace("%STEAMID%",arg.Player().UserIDString));

                if (j != -1 && config.pluginSettings[i].onlyOne)
                {
                    x = 0;
                    for(int o = 0; o < config.pluginSettings.Count; o++)
                    {
                        x++;
                        if (o >= i)
                            break;

                        for(int p = 0; p < config.pluginSettings.ElementAt(o).Value.subSettings.Count; p++)
                        {
                            x++;
                        }
                    }
                    for(int k = 0; k < config.pluginSettings[i].subSettings.Count; k++)
                    {
                        CuiHelper.DestroyUi(arg.Player(), MenuContent + ".Info" + $".{i}.{k}");
                        if (k != j)
                            userSettings[arg.Connection.userid][i].settings[k].isOn = false;
                        else
                            userSettings[arg.Connection.userid][i].settings[k].isOn = true;

                        CuiElementContainer Container = new CuiElementContainer();
                        bool isOn =userSettings[arg.Connection.userid][i].settings[k].isOn;
                        string subText = $"{(isOn ? "<color=#FFFFFF>☑" : "<color=#FFFFFF66>☐")}  {config.pluginSettings.ElementAt(i).Value.subSettings.ElementAt(k).Value.commandDescription}</color>";
                        Container.Add(new CuiElement
                        {
                            Name = MenuContent + ".Info" + $".{i}.{k}",
                            Parent = MenuContent + ".Info",
                            Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = subText,
                                    Align = TextAnchor.MiddleLeft,
                                    FontSize = 16,
                                    Font = "robotocondensed-regular.ttf",
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1",
                                    AnchorMax = "0 1",
                                    OffsetMin = $"{60} {-50 - x * 25}",
                                    OffsetMax = $"550 {-25 - x * 25}"
                                }
                            }
                        });


                        Container.Add(new CuiButton
                        {
                            Button = { Color = "1 1 1 0", Command = $"settings.sendcommand {x} {i} {k} {config.pluginSettings.ElementAt(i).Value.subSettings.ElementAt(k).Value.command}" },
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", },
                            Text = { Text = "", Align = TextAnchor.MiddleCenter }
                        }, MenuContent + ".Info" + $".{i}.{k}", MenuContent + ".Info" + $".{i}.{k}.Btn");
                        CuiHelper.AddUi(arg.Player(), Container);
                        x++;
                    }
                    return;
                }
                else
                {
                    CuiHelper.DestroyUi(arg.Player(), MenuContent + ".Info" + $".{i}.{j}");

                    if (j != -1)
                    {
                        userSettings[arg.Connection.userid][i].settings[j].isOn = !userSettings[arg.Connection.userid][i].settings[j].isOn;
                    }
                    else
                    {
                        userSettings[arg.Connection.userid][i].isOn = !userSettings[arg.Connection.userid][i].isOn;
                    }

                    bool isOn = j != -1 ? userSettings[arg.Connection.userid][i].settings[j].isOn : userSettings[arg.Connection.userid][i].isOn;
                    CuiElementContainer Container = new CuiElementContainer();
                    string subText = $"{(isOn ? "<color=#FFFFFF>☑" : "<color=#FFFFFF66>☐")}  {(j != -1 ? config.pluginSettings.ElementAt(i).Value.subSettings.ElementAt(j).Value.commandDescription : config.pluginSettings.ElementAt(i).Value.commandDescription)}</color>";
                    Container.Add(new CuiElement
                    {
                        Name = MenuContent + ".Info" + $".{i}.{j}",
                        Parent = MenuContent + ".Info",
                        Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = subText,
                                    Align = TextAnchor.MiddleLeft,
                                    FontSize = 16,
                                    Font = "robotocondensed-regular.ttf",
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1",
                                    AnchorMax = "0 1",
                                    OffsetMin = $"{(j != -1 ? "60" : "30")} {-50 - x * 25}",
                                    OffsetMax = $"550 {-25 - x * 25}"
                                }
                            }
                    });


                    Container.Add(new CuiButton
                    {
                        Button = { Color = "1 1 1 0", Command = $"settings.sendcommand {x} {i} {j} {(j != -1 ? config.pluginSettings.ElementAt(i).Value.subSettings.ElementAt(j).Value.command.Replace("%STEAMID%", arg.Player().userID.ToString()) : config.pluginSettings.ElementAt(i).Value.command.Replace("%STEAMID%", arg.Player().userID.ToString()))}" },
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", },
                        Text = { Text = "", Align = TextAnchor.MiddleCenter }
                    }, MenuContent + ".Info" + $".{i}.{j}", MenuContent + ".Info" + $".{i}.{j}.Btn");
                    CuiHelper.AddUi(arg.Player(), Container);
                }
            }
        }

        #region Utils
        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }
        #endregion
    }
}


// --- End of file: Settings.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/IQChat.cs ---
// --- Original Local Path: TrashRust/IQChat.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using CompanionServer;
using ConVar;
using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    /*ПЛАГИН БЫЛ ПОФИКШЕН С ПОМОЩЬЮ ПРОГРАММЫ СКАЧАНОЙ С https://discord.gg/dNGbxafuJn */ [Info("IQChat", "https://discord.gg/dNGbxafuJn", "0.3.4")]
    [Description("Самый приятный чат для вашего сервера из ветки IQ")]
    class IQChat : RustPlugin
    {
        /// <summary>
        /// Обновление 0.3.4
        /// - Добавлена поддержка IQRankSystem
        /// - Добавлен дополнительный префикс - Ранг совместно с плагином IQRankSystem
        /// - Добавлено отображение времени отыгранного на сервере - совместно с плагином IQRankSystem
        /// - Добавлен пункт в меню чата "Ранг" с поддержкой IQRankSystem
        /// - Добавлена сортировка по доступным рангам IQRankSystem
        /// - Добавлен пункт Включения/Отключения случайных сообщений при подключении игрока
        /// - Добавлен список случайных сообщений при подключении игрока, так-же с поддержкой его страны
        /// - Добавлен пункт Включения/Отключения случайных сообщений при отключении игрока
        /// - Добавлен список случайных сообщений при отключении игрока, так-же с поддержкой его причины 
        /// - Значительно оптимизировал форматирование сообщений
        /// </summary>


        #region Reference
        [PluginReference] Plugin IQPersonal, IQFakeActive, XDNotifications, IQRankSystem;

        #region IQPersonal
        public void SetMute(BasePlayer player) => IQPersonal?.CallHook("API_SET_MUTE", player.userID);
        public void BadWords(BasePlayer player) => IQPersonal?.CallHook("API_DETECTED_BAD_WORDS", player.userID);
        #endregion

        #region XDNotifications
        private void AddNotify(BasePlayer player, string title, string description, string command = "", string cmdyes = "", string cmdno = "")
        {
            if (!XDNotifications) return;
            var Setting = config.ReferenceSetting.XDNotificationsSettings;
            Interface.Oxide.CallHook("AddNotify", player, title, description, Setting.Color, Setting.AlertDelete, Setting.SoundEffect, command, cmdyes, cmdno);
        }
        #endregion

        #region IQFakeActive
        public bool IsFake(string DisplayName) => (bool)IQFakeActive?.Call("IsFake", DisplayName);
        void SyncReservedFinish()
        {
            if (!config.ReferenceSetting.IQFakeActiveSettings.UseIQFakeActive) return;
            PrintWarning("IQChat - успешно синхронизирована с IQFakeActive");
            PrintWarning("=============SYNC==================");
        }
        #endregion

        #region IQRankSystem
        string IQRankGetRank(ulong userID) => (string)(IQRankSystem?.Call("API_GET_RANK_NAME", userID));
        string IQRankGetTimeGame(ulong userID) => (string)(IQRankSystem?.Call("API_GET_TIME_GAME", userID));
        List<string> IQRankListKey(ulong userID) => (List<string>)(IQRankSystem?.Call("API_RANK_USER_KEYS", userID));
        string IQRankGetNameRankKey(string Key) => (string)(IQRankSystem?.Call("API_GET_RANK_NAME", Key));
        void IQRankSetRank(ulong userID, string RankKey) => IQRankSystem?.Call("API_SET_ACTIVE_RANK", userID, RankKey);
        bool IQRankUserAcces(ulong userID, string RankKey) => (bool)IQRankSystem?.Call("API_GET_RANK_ACCESS", userID, RankKey);

        #endregion

        #endregion

        #region Vars
        public Dictionary<BasePlayer, BasePlayer> PMHistory = new Dictionary<BasePlayer, BasePlayer>();

        public string PermMuteMenu = "muteuse.iqchat";
        class Response
        {
            [JsonProperty("country")]
            public string Country { get; set; }
        }
        public static StringBuilder sb = new StringBuilder();
        public string GetLang(string LangKey, string userID = null, params object[] args)
        {
            sb.Clear();
            if (args != null)
            {
                sb.AppendFormat(lang.GetMessage(LangKey, this, userID), args);
                return sb.ToString();
            }
            return lang.GetMessage(LangKey, this, userID);
        }
        #endregion

        #region Configuration

        private static Configuration config = new Configuration();
        private class Configuration
        {
            [JsonProperty("Права для смены ника")]
            public string RenamePermission;
            [JsonProperty("Настройка префиксов")]
            public List<AdvancedFuncion> PrefixList = new List<AdvancedFuncion>();
            [JsonProperty("Настройка цветов для ников")]
            public List<AdvancedFuncion> NickColorList = new List<AdvancedFuncion>();
            [JsonProperty("Настройка цветов для сообщений")]
            public List<AdvancedFuncion> MessageColorList = new List<AdvancedFuncion>();
            [JsonProperty("Настройка сообщений в чате")]
            public MessageSettings MessageSetting;
            [JsonProperty("Настройка причин блокировок чата")]
            public List<ReasonMuteChat> ReasonListChat = new List<ReasonMuteChat>();
            [JsonProperty("Настройка интерфейса")]
            public InterfaceSettings InterfaceSetting;
            [JsonProperty("Настройка оповещения")]
            public AlertSetting AlertSettings;         
            [JsonProperty("Настройка привилегий")]
            public AutoSetups AutoSetupSetting;
            [JsonProperty("Настройка Rust+")]
            public RustPlus RustPlusSettings;
            [JsonProperty("Дополнительная настройка")]
            public OtherSettings OtherSetting;
            [JsonProperty("Настройка автоответчика")]
            public AnswerMessage AnswerMessages = new AnswerMessage();

            [JsonProperty("Настройка плагинов поддержки")]
            public ReferenceSettings ReferenceSetting = new ReferenceSettings();
            internal class AdvancedFuncion
            {
                [JsonProperty("Права")]
                public string Permissions;
                [JsonProperty("Значение")]
                public string Argument;
            }
            internal class AnswerMessage
            {
                [JsonProperty("Включить автоответчик?(true - да/false - нет)")]
                public bool UseAnswer;
                [JsonProperty("Настройка сообщений [Ключевое слово] = Ответ")]
                public Dictionary<string, string> AnswerMessageList = new Dictionary<string, string>();
            }
            internal class RustPlus
            {
                [JsonProperty("Использовать Rust+")]
                public bool UseRustPlus;
                [JsonProperty("Название для уведомления Rust+")]
                public string DisplayNameAlert;
            }
            internal class ReasonMuteChat
            {
                [JsonProperty("Причина мута")]
                public string Reason;
                [JsonProperty("Время мута")]
                public int TimeMute;
            }
            internal class ReferenceSettings
            {
                [JsonProperty("Настройка XDNotifications")]
                public XDNotifications XDNotificationsSettings = new XDNotifications();
                [JsonProperty("Настройка IQFakeActive")]
                public IQFakeActive IQFakeActiveSettings = new IQFakeActive();
                [JsonProperty("Настройка IQRankSystem")]
                public IQRankSystem IQRankSystems = new IQRankSystem();
                internal class XDNotifications
                {
                    [JsonProperty("Включить поддержку XDNotifications(UI уведомления будут заменены на уведомление с XDNotifications)")]
                    public bool UseXDNotifications;
                    [JsonProperty("Цвет заднего фона уведомления(HEX)")]
                    public string Color;
                    [JsonProperty("Через сколько удалиться уведомление")]
                    public int AlertDelete;
                    [JsonProperty("Звуковой эффект")]
                    public string SoundEffect;
                }
                internal class IQRankSystem
                {
                    [JsonProperty("Использовать поддержку рангов")]
                    public bool UseRankSystem;
                    [JsonProperty("Отображать игрокам их отыгранное время рядом с рангом")]
                    public bool UseTimeStandart;
                }
                internal class IQFakeActive
                {
                    [JsonProperty("Использовать поддержку IQFakeActive")]
                    public bool UseIQFakeActive;
                }
            }
            internal class AutoSetups
            {
                [JsonProperty("Настройки сброса привилегий")]
                public ReturnDefault ReturnDefaultSetting = new ReturnDefault();
                [JsonProperty("Автоматической установки префиксов/цвета ника/цвета чата")]
                public SetupAuto SetupAutoSetting = new SetupAuto();
                internal class ReturnDefault
                {
                    [JsonProperty("Сбрасывать автоматически префикс при окончании его прав")]
                    public bool UseDropPrefix;
                    [JsonProperty("Сбрасывать автоматически цвет ника при окончании его прав")]
                    public bool UseDropColorNick;
                    [JsonProperty("Сбрасывать автоматически цвет чата при окончании его прав")]
                    public bool UseDropColorChat;

                    [JsonProperty("При окончании префикса, установится данный префикс")]
                    public string PrefixDefault;
                    [JsonProperty("При окончании цвета ника, установится данный цвет")]
                    public string NickDefault;
                    [JsonProperty("При окончании цвета сообщения, установится данный цвета")]
                    public string MessageDefault;
                }
                internal class SetupAuto
                {
                    [JsonProperty("Устанавливать автоматически префикс при получении его прав")]
                    public bool UseSetupAutoPrefix;
                    [JsonProperty("Устанавливать автоматически цвет ника при получении его прав")]
                    public bool UseSetupAutoColorNick;
                    [JsonProperty("Устанавливать автоматически цвет чата при получении его прав")]
                    public bool UseSetupAutoColorChat;

                }
            }
            internal class MessageSettings
            {
                [JsonProperty("Включить форматирование сообщений")]
                public bool FormatingMessage;
                [JsonProperty("Включить личные сообщения")]
                public bool PMActivate;
                [JsonProperty("Включить игнор ЛС игрокам(/ignore nick)")]
                public bool IgnoreUsePM;
                [JsonProperty("Включить Анти-Спам")]
                public bool AntiSpamActivate;
                [JsonProperty("Скрыть из чата выдачу предметов Админу")]
                public bool HideAdminGave;
                [JsonProperty("Использовать список запрещенных слов?")]
                public bool UseBadWords;
                [JsonProperty("Включить возможность использовать несколько префиксов сразу")]
                public bool MultiPrefix;
                [JsonProperty("Переносить мут в командный чат(В случае мута,игрок не сможет писать даже в командный чат)")]
                public bool MuteTeamChat;
                [JsonProperty("Пермишенс для иммунитета к антиспаму")]
                public string PermAdminImmunitetAntispam;
                [JsonProperty("Наименование оповещения в чат")]
                public string BroadcastTitle;
                [JsonProperty("Цвет сообщения оповещения в чат")]
                public string BroadcastColor;
                [JsonProperty("На какое сообщение заменять плохие слова")]
                public string ReplaceBadWord;
                [JsonProperty("Звук при при получении личного сообщения")]
                public string SoundPM;            
                [JsonProperty("Время,через которое удалится сообщение с UI от администратора")]
                public int TimeDeleteAlertUI;
                [JsonProperty("Steam64ID для аватарки в чате")]
                public ulong Steam64IDAvatar;
                [JsonProperty("Время через которое игрок может отправлять сообщение (АнтиСпам)")]
                public int FloodTime;
                [JsonProperty("Список плохих слов")]
                public List<string> BadWords = new List<string>();
            }
            internal class InterfaceSettings
            {
                [JsonProperty("Значения для плавного появления")]
                public float FadeIn;
                [JsonProperty("Основной цвет UI")]
                public string MainColor;
                [JsonProperty("Дополнительный цвет UI")]
                public string TwoMainColor;
                [JsonProperty("Цвет кнопок")]
                public string ButtonColor;
                [JsonProperty("Цвет текста")]
                public string LabelColor;
                [JsonProperty("Цвет UI уведомления")]
                public string AlertColor;
                [JsonProperty("Настройка расположения UI уведомления")]
                public AlertInterfaceSettings AlertInterfaceSetting;

                internal class AlertInterfaceSettings
                {
                    [JsonProperty("AnchorMin")]
                    public string AnchorMin;
                    [JsonProperty("AnchorMax")]
                    public string AnchorMax;
                    [JsonProperty("OffsetMin")]
                    public string OffsetMin;
                    [JsonProperty("OffsetMax")]
                    public string OffsetMax;
                }
            }
            internal class AlertSetting
            {
                [JsonProperty("Включить случайное сообщение зашедшему игроку")]
                public bool WelcomeMessageUse;
                [JsonProperty("Список сообщений игроку при входе")]
                public List<string> WelcomeMessage = new List<string>();
                [JsonProperty("Уведомлять о входе игрока в чат")]
                public bool ConnectedAlert;
                [JsonProperty("Включить случайные уведомления о входе игрока из списка")]
                public bool ConnectionAlertRandom;
                [JsonProperty("Случайные уведомления о входе игрока({0} - ник игрока, {1} - страна(если включено отображение страны)")]
                public List<string> RandomConnectionAlert = new List<string>();
                [JsonProperty("Отображать страну зашедшего игрока")]
                public bool ConnectedWorld;
                [JsonProperty("Уведомлять о выходе игрока в чат из списка")]
                public bool DisconnectedAlert;
                [JsonProperty("Включить случайные уведомления о входе игрока")]
                public bool DisconnectedAlertRandom;
                [JsonProperty("Случайные уведомления о входе игрока({0} - ник игрока, {1} - причина выхода(если включена причина)")]
                public List<string> RandomDisconnectedAlert = new List<string>();
                [JsonProperty("Отображать причину выхода игрока")]
                public bool DisconnectedReason;
                [JsonProperty("При уведомлении о входе/выходе игрока отображать его аватар напротив ника")]
                public bool ConnectedAvatarUse;
                [JsonProperty("Включить автоматические сообщения в чат")]
                public bool AlertMessage;
                [JsonProperty("Настройка отправки автоматических сообщений в чат")]
                public List<string> MessageList;
                [JsonProperty("Интервал отправки сообщений в чат(Броадкастер)")]
                public int MessageListTimer;
            }
            internal class OtherSettings
            {
                [JsonProperty("Использовать дискорд")]
                public bool UseDiscord;
                [JsonProperty("Вебхук для логирования чата в дискорд")]
                public string WebhooksChatLog;
                [JsonProperty("Вебхук для логирования информации о мутах в дискорде")]
                public string WebhooksMuteInfo;
            }

            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    PrefixList = new List<AdvancedFuncion>
                    {
                        new AdvancedFuncion
                        {
                            Permissions = "iqchat.default",
                            Argument = "<color=yellow><b>[+]</b></color>",
                        },
                        new AdvancedFuncion
                        {
                            Permissions = "iqchat.default",
                            Argument = "<color=yellow><b>[ИГРОК]</b></color>",
                        },
                        new AdvancedFuncion
                        {
                            Permissions = "iqchat.vip",
                            Argument = "<color=yellow><b>[VIP]</b></color>",
                        },
                    },
                    NickColorList = new List<AdvancedFuncion>
                    {
                        new AdvancedFuncion
                        {
                            Permissions = "iqchat.default",
                            Argument = "#DBEAEC",
                        },
                        new AdvancedFuncion
                        {
                            Permissions = "iqchat.default",
                            Argument = "#FFC428",
                        },
                        new AdvancedFuncion
                        {
                            Permissions = "iqchat.vip",
                            Argument = "#45AAB4",
                        },
                    },
                    MessageColorList = new List<AdvancedFuncion>
                    {
                        new AdvancedFuncion
                        {
                            Permissions = "iqchat.default",
                            Argument = "#DBEAEC",
                        },
                        new AdvancedFuncion
                        {
                            Permissions = "iqchat.default",
                            Argument = "#FFC428",
                        },
                        new AdvancedFuncion
                        {
                            Permissions = "iqchat.vip",
                            Argument = "#45AAB4",
                        },
                    },
                    AutoSetupSetting = new AutoSetups
                    {
                        ReturnDefaultSetting = new AutoSetups.ReturnDefault
                        {
                            UseDropColorChat = true,
                            UseDropColorNick = true,
                            UseDropPrefix = true,

                            PrefixDefault = "",
                            NickDefault = "",
                            MessageDefault = "",
                        },
                        SetupAutoSetting = new AutoSetups.SetupAuto
                        {
                            UseSetupAutoColorChat = true,
                            UseSetupAutoColorNick = true,
                            UseSetupAutoPrefix = true,
                        }
                    },
                    RustPlusSettings = new RustPlus
                    {
                        UseRustPlus = true,
                        DisplayNameAlert = "СУПЕР СЕРВЕР",
                    },
                    MessageSetting = new MessageSettings
                    {
                        UseBadWords = true,
                        HideAdminGave = true,
                        IgnoreUsePM = true,
                        MuteTeamChat = true,
                        PermAdminImmunitetAntispam = "iqchat.adminspam",
                        BroadcastTitle = "<color=#007FFF><b>[ОПОВЕЩЕНИЕ]</b></color>",
                        BroadcastColor = "#74ade1",
                        ReplaceBadWord = "Ругаюсь матом",
                        Steam64IDAvatar = 0,
                        TimeDeleteAlertUI = 5,
                        PMActivate = true,
                        SoundPM = "assets/bundled/prefabs/fx/notice/stack.world.fx.prefab",
                        AntiSpamActivate = true,
                        FloodTime = 5,
                        FormatingMessage = true,
                        MultiPrefix = true,
                        BadWords = new List<string> { "хуй", "гей", "говно", "бля", "тварь" }
                    },
                    ReasonListChat = new List<ReasonMuteChat>
                    {
                        new ReasonMuteChat
                        {
                            Reason = "Оскорбление родителей",
                            TimeMute = 1200,
                        },
                        new ReasonMuteChat
                        {
                            Reason = "Оскорбление игроков",
                            TimeMute = 100
                        }
                    },
                    RenamePermission = "iqchat.renameuse",                  
                    AlertSettings = new AlertSetting
                    {
                        MessageListTimer = 60,
                        WelcomeMessageUse = true,
                        ConnectionAlertRandom = false,
                        DisconnectedAlertRandom = false,
                        RandomConnectionAlert = new List<string>
                        {
                            "{0} влетел как дурачок из {1}",
                            "{0} залетел на сервер из {1}, соболезнуем",
                            "{0} прыгнул на сервачок"
                        },
                        RandomDisconnectedAlert = new List<string>
                        {
                            "{0} ушел в мир иной",
                            "{0} вылетел с сервера с причиной {1}",
                            "{0} пошел на другой сервачок"
                        },
                        ConnectedAlert = true,
                        ConnectedWorld = true,
                        DisconnectedAlert = true,
                        DisconnectedReason = true,
                        AlertMessage = true,
                        ConnectedAvatarUse = true,
                        MessageList = new List<string>
                        {
                        "Автоматическое сообщение #1",
                        "Автоматическое сообщение #2",
                        "Автоматическое сообщение #3",
                        "Автоматическое сообщение #4",
                        "Автоматическое сообщение #5",
                        "Автоматическое сообщение #6",
                        },
                        WelcomeMessage = new List<string>
                        {
                            "Добро пожаловать на сервер SUPERSERVER\nРады,что выбрал именно нас!",
                            "С возвращением на сервер!\nЖелаем тебе удачи",
                            "Добро пожаловать на сервер\nУ нас самые лучшие плагины",
                        },

                    },
                    InterfaceSetting = new InterfaceSettings
                    {
                        FadeIn = 0.2f,
                        MainColor = "#000000C0",
                        TwoMainColor = "#762424FF",
                        ButtonColor = "#802A2AFF",
                        LabelColor = "#D1C7BEFF",
                        AlertColor = "#802A2AFF",
                        AlertInterfaceSetting = new InterfaceSettings.AlertInterfaceSettings
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "0 -90",
                            OffsetMax = "320 -20"
                        }
                    }, 
                    OtherSetting = new OtherSettings
                    {
                        UseDiscord = false,
                        WebhooksChatLog = "",
                        WebhooksMuteInfo = "",
                    },
                    AnswerMessages = new AnswerMessage
                    {
                        UseAnswer = true,
                        AnswerMessageList = new Dictionary<string, string>
                        {
                            ["вайп"] = "Вайп будет 27.06",
                            ["wipe"] = "Вайп будет 27.06",
                            ["читер"] = "Нашли читера?Напиши /report и отправь жалобу"
                        }
                    },
                    ReferenceSetting = new ReferenceSettings
                    {
                        XDNotificationsSettings = new ReferenceSettings.XDNotifications
                        {                         
                            UseXDNotifications = false,
                            AlertDelete = 5,
                            Color = "#762424FF",
                            SoundEffect = "",
                        },
                        IQFakeActiveSettings = new ReferenceSettings.IQFakeActive
                        {
                            UseIQFakeActive = true,
                        },
                        IQRankSystems = new ReferenceSettings.IQRankSystem
                        {
                            UseRankSystem = false,
                            UseTimeStandart = true
                        }
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning("Ошибка #132" + $"чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }
            NextTick(SaveConfig);
        }

        void RegisteredPermissions()
        {
            for (int MsgColor = 0; MsgColor < config.MessageColorList.Count; MsgColor++)
                if (!permission.PermissionExists(config.MessageColorList[MsgColor].Permissions, this))
                    permission.RegisterPermission(config.MessageColorList[MsgColor].Permissions, this);

            for (int NickColorList = 0; NickColorList < config.NickColorList.Count; NickColorList++)
                if (!permission.PermissionExists(config.NickColorList[NickColorList].Permissions, this))
                    permission.RegisterPermission(config.NickColorList[NickColorList].Permissions, this);

            for (int PrefixList = 0; PrefixList < config.PrefixList.Count; PrefixList++)
                if (!permission.PermissionExists(config.PrefixList[PrefixList].Permissions, this))
                    permission.RegisterPermission(config.PrefixList[PrefixList].Permissions, this);

            permission.RegisterPermission(config.RenamePermission, this);
            permission.RegisterPermission(PermMuteMenu, this);
            permission.RegisterPermission(config.MessageSetting.PermAdminImmunitetAntispam,this);
            PrintWarning("Permissions - completed");
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region Data
        [JsonProperty("Дата с настройкой чата игрока")]
         public Dictionary<ulong, SettingUser> ChatSettingUser = new Dictionary<ulong, SettingUser>();
        [JsonProperty("Дата с Административной настройкой")] public AdminSettings AdminSetting = new AdminSettings();
        public class SettingUser
        {
            public string ChatPrefix;
            public List<string> MultiPrefix = new List<string>();
            public string NickColor;
            public string MessageColor;
            public double MuteChatTime;
            public double MuteVoiceTime;
            public List<ulong> IgnoredUsers = new List<ulong>();
        }

        public class AdminSettings
        {
            public bool MuteChatAll;
            public bool MuteVoiceAll;
            public Dictionary<ulong, string> RenameList = new Dictionary<ulong, string>()
;        }
        void ReadData()
        {
            ChatSettingUser = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, SettingUser>>("IQChat/IQUser");
            AdminSetting = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<AdminSettings>("IQChat/AdminSetting");
        }
        void WriteData()
        {
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQChat/IQUser", ChatSettingUser);
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQChat/AdminSetting", AdminSetting);
        }

        void RegisteredDataUser(BasePlayer player)
        {
            if (!ChatSettingUser.ContainsKey(player.userID))
                ChatSettingUser.Add(player.userID, new SettingUser
                {
                    ChatPrefix = config.AutoSetupSetting.ReturnDefaultSetting.PrefixDefault,
                    NickColor = config.AutoSetupSetting.ReturnDefaultSetting.NickDefault,
                    MessageColor = config.AutoSetupSetting.ReturnDefaultSetting.MessageDefault,
                    MuteChatTime = 0,
                    MuteVoiceTime = 0,
                    MultiPrefix = new List<string> { },
                    IgnoredUsers = new List<ulong> { },
                    
                });
        }

        #endregion

        #region Hooks     
        private bool OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel)
        {
            if (Interface.Oxide.CallHook("CanChatMessage", player, message) != null) return false;
            SeparatorChat(channel, player, message);
            return false;
        }
        private object OnServerMessage(string message, string name)
        {
            if (config.MessageSetting.HideAdminGave)
                if (message.Contains("gave") && name == "SERVER")
                    return true;
            return null;
        }
        void OnUserPermissionGranted(string id, string permName) => AutoSetupData(id, permName);
        private void OnUserGroupAdded(string id, string groupName)
        {
            var PermissionsGroup = permission.GetGroupPermissions(groupName);
            if (PermissionsGroup == null) return;
            foreach (var permName in PermissionsGroup)
                AutoSetupData(id, permName); 
        }
        void OnUserPermissionRevoked(string id, string permName) => AutoReturnDefaultData(id, permName);
        void OnUserGroupRemoved(string id, string groupName)
        {
            var PermissionsGroup = permission.GetGroupPermissions(groupName);
            if (PermissionsGroup == null) return;
            foreach (var permName in PermissionsGroup)
                AutoReturnDefaultData(id, permName);
        }
        object OnPlayerVoice(BasePlayer player, Byte[] data)
        {
            var DataPlayer = ChatSettingUser[player.userID];
            bool IsMuted = DataPlayer.MuteVoiceTime > CurrentTime() ? true : false;
            if (IsMuted)
                return false;
            return null;
        }

        private void OnServerInitialized()
        {
            ReadData();
            foreach (var p in BasePlayer.activePlayerList)
                RegisteredDataUser(p);

            RegisteredPermissions();
            WriteData();
            BroadcastAuto();
        }
        void OnPlayerConnected(BasePlayer player)
        {
            RegisteredDataUser(player);
            var Alert = config.AlertSettings;
            if (Alert.ConnectedAlert)
            {
                string Avatar = Alert.ConnectedAvatarUse ? player.UserIDString : "";
                string Message = string.Empty;
                if (config.AlertSettings.ConnectedWorld)
                {
                    webrequest.Enqueue("http://ip-api.com/json/" + player.net.connection.ipaddress.Split(':')[0], null, (code, response) =>
                    {
                        if (code != 200 || response == null)
                            return;

                        string country = JsonConvert.DeserializeObject<Response>(response).Country;

                        if (Alert.ConnectionAlertRandom)
                        {
                            sb.Clear();
                            int RandomIndex = UnityEngine.Random.Range(0, Alert.RandomConnectionAlert.Count);
                            Message = sb.AppendFormat(Alert.RandomConnectionAlert[RandomIndex], player.displayName, country).ToString();
                        }
                        else Message = GetLang("WELCOME_PLAYER_WORLD", player.UserIDString, player.displayName, country);
                        ReplyBroadcast(Message, "", Avatar);
                    }, this);
                }
                else
                {
                    if (Alert.ConnectionAlertRandom)
                    {
                        sb.Clear();
                        int RandomIndex = UnityEngine.Random.Range(0, Alert.RandomConnectionAlert.Count);
                        Message = sb.AppendFormat(Alert.RandomConnectionAlert[RandomIndex], player.displayName).ToString();
                    }
                    else Message = GetLang("WELCOME_PLAYER", player.UserIDString, player.displayName);
                    ReplyBroadcast(Message);
                }
            }
            if (Alert.WelcomeMessageUse)
            {
                int RandomMessage = UnityEngine.Random.Range(0, Alert.WelcomeMessage.Count);
                string WelcomeMessage = Alert.WelcomeMessage[RandomMessage];
                ReplySystem(Chat.ChatChannel.Global, player, WelcomeMessage);
            }
        }      
        void Unload() => WriteData();

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            var Alert = config.AlertSettings;
            if (Alert.DisconnectedAlert)
            {
                string Avatar = Alert.ConnectedAvatarUse ? player.UserIDString : "";
                string Message = string.Empty;
                if (Alert.DisconnectedAlertRandom)
                {
                    sb.Clear();
                    int RandomIndex = UnityEngine.Random.Range(0, Alert.RandomDisconnectedAlert.Count);
                    Message = sb.AppendFormat(Alert.RandomDisconnectedAlert[RandomIndex], player.displayName, reason).ToString();
                }
                else Message = config.AlertSettings.DisconnectedReason ? GetLang("LEAVE_PLAYER_REASON", player.UserIDString, player.displayName, reason) : GetLang("LEAVE_PLAYER", player.UserIDString, player.displayName);
                ReplyBroadcast(Message, "", Avatar);
            }
        }
        #endregion

        #region DiscordFunc

        #region FancyDiscord
        public class FancyMessage
        {
            public string content { get; set; }
            public bool tts { get; set; }
            public Embeds[] embeds { get; set; }

            public class Embeds
            {
                public string title { get; set; }
                public int color { get; set; }
                public List<Fields> fields { get; set; }
                public Footer footer { get; set; }
                public Authors author { get; set; }

                public Embeds(string title, int color, List<Fields> fields, Authors author, Footer footer)
                {
                    this.title = title;
                    this.color = color;
                    this.fields = fields;
                    this.author = author;
                    this.footer = footer;

                }
            }

            public FancyMessage(string content, bool tts, Embeds[] embeds)
            {
                this.content = content;
                this.tts = tts;
                this.embeds = embeds;
            }

            public string toJSON() => JsonConvert.SerializeObject(this);
        }

        public class Footer
        {
            public string text { get; set; }
            public string icon_url { get; set; }
            public string proxy_icon_url { get; set; }
            public Footer(string text, string icon_url, string proxy_icon_url)
            {
                this.text = text;
                this.icon_url = icon_url;
                this.proxy_icon_url = proxy_icon_url;
            }
        }

        public class Authors
        {
            public string name { get; set; }
            public string url { get; set; }
            public string icon_url { get; set; }
            public string proxy_icon_url { get; set; }
            public Authors(string name, string url, string icon_url, string proxy_icon_url)
            {
                this.name = name;
                this.url = url;
                this.icon_url = icon_url;
                this.proxy_icon_url = proxy_icon_url;
            }
        }

        public class Fields
        {
            public string name { get; set; }
            public string value { get; set; }
            public bool inline { get; set; }
            public Fields(string name, string value, bool inline)
            {
                this.name = name;
                this.value = value;
                this.inline = inline;
            }
        }

        private void Request(string url, string payload, Action<int> callback = null)
        {
            Dictionary<string, string> header = new Dictionary<string, string>();
            header.Add("Content-Type", "application/json");
            webrequest.Enqueue(url, payload, (code, response) =>
            {
                if (code != 200 && code != 204)
                {
                    if (response != null)
                    {
                        try
                        {
                            JObject json = JObject.Parse(response);
                            if (code == 429)
                            {
                                float seconds = float.Parse(Math.Ceiling((double)(int)json["retry_after"] / 1000).ToString());
                            }
                            else
                            {
                                PrintWarning($" Discord rejected that payload! Responded with \"{json["message"].ToString()}\" Code: {code}");
                            }
                        }
                        catch
                        {
                            PrintWarning($"Failed to get a valid response from discord! Error: \"{response}\" Code: {code}");
                        }
                    }
                    else
                    {
                        PrintWarning($"Discord didn't respond (down?) Code: {code}");
                    }
                }
                try
                {
                    callback?.Invoke(code);
                }
                catch (Exception ex) { }

            }, this, RequestMethod.POST, header);
        }
        #endregion

        void DiscordSendMessage(string key, string WebHooks, ulong userID = 0, params object[] args)
        {
            if (!config.OtherSetting.UseDiscord) return;
            if (String.IsNullOrWhiteSpace(WebHooks)) return;

            List<Fields> fields = new List<Fields>
                {
                    new Fields("IQChat", key, true),
                };

            FancyMessage newMessage = new FancyMessage(null, false, new FancyMessage.Embeds[1] { new FancyMessage.Embeds(null, 635133, fields, new Authors("IQChat", "https://vk.com/mir_inc", "https://i.imgur.com/ILk3uJc.png", null), new Footer("Author: Mercury[vk.com/mir_inc]", "https://i.imgur.com/ILk3uJc.png", null)) });
            Request($"{WebHooks}", newMessage.toJSON());
        }
        #endregion

        #region Func
        public bool IsMutedUser(ulong userID)
        {
            var DataPlayer = ChatSettingUser[userID];
            return DataPlayer.MuteChatTime > CurrentTime() ? true : false;
        }
        private void SeparatorChat(Chat.ChatChannel channel, BasePlayer player, string Message)
        {
            var DataPlayer = ChatSettingUser[player.userID];

            if (IsMutedUser(player.userID))
            {
                ReplySystem(Chat.ChatChannel.Global, player, GetLang("FUNC_MESSAGE_ISMUTED_TRUE", player.UserIDString, FormatTime(TimeSpan.FromSeconds(DataPlayer.MuteChatTime - CurrentTime()))));
                return;
            }

            var RankSettings = config.ReferenceSetting.IQRankSystems;
            var MessageSettings = config.MessageSetting;
            string OutMessage = Message;
            string PrefxiPlayer = "";
            string MessageSeparator = "";
            string ColorNickPlayer = DataPlayer.NickColor;
            string ColorMessagePlayer = DataPlayer.MessageColor;
            string DisplayName = AdminSetting.RenameList.ContainsKey(player.userID) ? AdminSetting.RenameList[player.userID] : player.displayName;

            if (MessageSettings.FormatingMessage)
                OutMessage = $"{Message.ToLower().Substring(0, 1).ToUpper()}{Message.Remove(0, 1).ToLower()}";

            if (MessageSettings.UseBadWords)
                foreach (var DetectedMessage in OutMessage.Split(' '))
                    if (MessageSettings.BadWords.Contains(DetectedMessage.ToLower()))
                    {
                        OutMessage = OutMessage.Replace(DetectedMessage, MessageSettings.ReplaceBadWord);
                        BadWords(player);
                    }

            if (MessageSettings.MultiPrefix)
            {
                if (DataPlayer.MultiPrefix != null)

                    for (int i = 0; i < DataPlayer.MultiPrefix.Count; i++)
                        PrefxiPlayer += DataPlayer.MultiPrefix[i];
            }
            else PrefxiPlayer = DataPlayer.ChatPrefix;

            string ModifiedNick = string.IsNullOrWhiteSpace(ColorNickPlayer) ? player.IsAdmin ? $"<color=#a8fc55>{DisplayName}</color>" : $"<color=#54aafe>{DisplayName}</color>" : $"<color={ColorNickPlayer}>{DisplayName}</color>";
            string ModifiedMessage = string.IsNullOrWhiteSpace(ColorMessagePlayer) ? OutMessage : $"<color={ColorMessagePlayer}>{OutMessage}</color>";
            string ModifiedChannel = channel == Chat.ChatChannel.Team ? "<color=#a5e664>[Team]</color>" : "";

            string Rank = string.Empty;
            string RankTime = string.Empty;
            if (IQRankSystem)
                if (RankSettings.UseRankSystem)
                {
                    if (RankSettings.UseTimeStandart)
                        RankTime = $"{IQRankGetTimeGame(player.userID)}";
                    Rank = $"{IQRankGetRank(player.userID)}";
                }
            MessageSeparator = !String.IsNullOrWhiteSpace(Rank) && !String.IsNullOrWhiteSpace(RankTime) ? $"{ModifiedChannel} [{RankTime}] [{Rank}] {PrefxiPlayer} {ModifiedNick}: {ModifiedMessage}" : !String.IsNullOrWhiteSpace(RankTime) ? $"{ModifiedChannel} [{RankTime}] {PrefxiPlayer} {ModifiedNick}: {ModifiedMessage}" : !String.IsNullOrWhiteSpace(Rank) ? $"{ModifiedChannel} [{Rank}] {PrefxiPlayer} {ModifiedNick}: {ModifiedMessage}" : $"{ModifiedChannel} {PrefxiPlayer} {ModifiedNick}: {ModifiedMessage}";


            if (config.RustPlusSettings.UseRustPlus)
                if (channel == Chat.ChatChannel.Team)
                {
                    RelationshipManager.PlayerTeam Team = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);
                    if (Team == null) return;
                    Util.BroadcastTeamChat(player.Team, player.userID, player.displayName, OutMessage, DataPlayer.MessageColor);
                }

            ReplyChat(channel, player, MessageSeparator);
            AnwserMessage(player, MessageSeparator.ToLower());
            Puts($"{player}: {OutMessage}");
            Log($"СООБЩЕНИЕ В ЧАТ : {player}: {ModifiedChannel} {OutMessage}");
            DiscordSendMessage(GetLang("DISCORD_SEND_LOG_CHAT", player.UserIDString, player.displayName, player.UserIDString, OutMessage, Message), config.OtherSetting.WebhooksChatLog, player.userID);

            RCon.Broadcast(RCon.LogType.Chat, new Chat.ChatEntry
            {
                Message = $"{player.displayName} : {OutMessage}",
                UserId = player.UserIDString,
                Username = player.displayName,
                Channel = channel,
                Time = (DateTime.UtcNow.Hour * 3600) + (DateTime.UtcNow.Minute * 60),
            });
        }

        public void AutoSetupData(string id, string perm)
        {
            var AutoSetup = config.AutoSetupSetting.SetupAutoSetting;
            if (String.IsNullOrWhiteSpace(id)) return;
            if (String.IsNullOrWhiteSpace(perm)) return;
            ulong userID;
            if (!ulong.TryParse(id, out userID)) return;

            if (!ChatSettingUser.ContainsKey(userID)) return;
            var DataPlayer = ChatSettingUser[userID];

            var Prefix = config.PrefixList.FirstOrDefault(x => x.Permissions == perm);
            var ColorChat = config.MessageColorList.FirstOrDefault(x => x.Permissions == perm);
            var ColorNick = config.NickColorList.FirstOrDefault(x => x.Permissions == perm);
            if (AutoSetup.UseSetupAutoPrefix)
                if (Prefix != null)
                {
                    if (!config.MessageSetting.MultiPrefix)
                        DataPlayer.ChatPrefix = Prefix.Argument;
                    else DataPlayer.MultiPrefix.Add(Prefix.Argument);

                    BasePlayer player = BasePlayer.FindByID(userID);
                    if (player != null)
                        ReplySystem(Chat.ChatChannel.Global, player, GetLang("PREFIX_SETUP", player.UserIDString, Prefix.Argument));
                }
            if (AutoSetup.UseSetupAutoColorChat)
                if (ColorChat != null)
                {
                    DataPlayer.MessageColor = ColorChat.Argument;

                    BasePlayer player = BasePlayer.FindByID(userID);
                    if (player != null)
                        ReplySystem(Chat.ChatChannel.Global, player, GetLang("COLOR_CHAT_SETUP", player.UserIDString, ColorChat.Argument));

                }
            if (AutoSetup.UseSetupAutoColorNick)
                if (ColorNick != null)
                {
                    DataPlayer.NickColor = ColorNick.Argument;

                    BasePlayer player = BasePlayer.FindByID(userID);
                    if (player != null)
                        ReplySystem(Chat.ChatChannel.Global, player, GetLang("COLOR_NICK_SETUP", player.UserIDString, ColorNick.Argument));
                }
        }
        public void AutoReturnDefaultData(string id, string perm)
        {
            var AutoReturn = config.AutoSetupSetting.ReturnDefaultSetting;
            if (String.IsNullOrWhiteSpace(id)) return;
            if (String.IsNullOrWhiteSpace(perm)) return;
            ulong userID;
            if (!ulong.TryParse(id, out userID)) return;
            if (!userID.IsSteamId()) return;
            if (!ChatSettingUser.ContainsKey(userID)) return;

            var DataPlayer = ChatSettingUser[userID];

            var Prefix = config.PrefixList.FirstOrDefault(x => x.Permissions == perm);
            var ColorChat = config.MessageColorList.FirstOrDefault(x => x.Permissions == perm);
            var ColorNick = config.NickColorList.FirstOrDefault(x => x.Permissions == perm);

            if (AutoReturn.UseDropPrefix)
                if (Prefix != null)
                {
                    if (config.MessageSetting.MultiPrefix)
                    {
                        if (DataPlayer.MultiPrefix.Contains(Prefix.Argument))
                        {
                            DataPlayer.MultiPrefix.Remove(Prefix.Argument);

                            BasePlayer player = BasePlayer.FindByID(userID);
                            if (player != null)
                                ReplySystem(Chat.ChatChannel.Global, player, GetLang("PREFIX_RETURNRED", player.UserIDString, Prefix.Argument));
                        }
                    }
                    else if (DataPlayer.ChatPrefix == Prefix.Argument)
                    {
                        DataPlayer.ChatPrefix = AutoReturn.PrefixDefault;

                        BasePlayer player = BasePlayer.FindByID(userID);
                        if (player != null)
                            ReplySystem(Chat.ChatChannel.Global, player, GetLang("PREFIX_RETURNRED", player.UserIDString, Prefix.Argument));
                    }
                }
            if (AutoReturn.UseDropColorChat)
                if (ColorChat != null)
                    if (DataPlayer.MessageColor == ColorChat.Argument)
                    {
                        DataPlayer.MessageColor = AutoReturn.MessageDefault;

                        BasePlayer player = BasePlayer.FindByID(userID);
                        if (player != null)
                        ReplySystem(Chat.ChatChannel.Global, player, GetLang("COLOR_CHAT_RETURNRED", player.UserIDString, ColorChat.Argument));

                    }
            if (AutoReturn.UseDropColorNick)
                if (ColorNick != null)
                    if (DataPlayer.NickColor == ColorNick.Argument)
                    {
                        DataPlayer.NickColor = AutoReturn.NickDefault;

                        BasePlayer player = BasePlayer.FindByID(userID);
                        if (player != null)
                            ReplySystem(Chat.ChatChannel.Global, player, GetLang("COLOR_NICK_RETURNRED", player.UserIDString, ColorNick.Argument));
                    }
        }   
        public void AnwserMessage(BasePlayer player, string Message)
        {
            var Anwser = config.AnswerMessages;
            if (!Anwser.UseAnswer) return;

            foreach (var Anwsers in Anwser.AnswerMessageList)
                if (Message.Contains(Anwsers.Key.ToLower()))
                    ReplySystem(Chat.ChatChannel.Global, player, Anwsers.Value);
        }

        public void BroadcastAuto()
        {
            var Alert = config.AlertSettings;
            if (Alert.AlertMessage)
            {
                timer.Every(Alert.MessageListTimer, () =>
                 {
                     var RandomMsg = Alert.MessageList[UnityEngine.Random.Range(0, Alert.MessageList.Count)];
                     ReplyBroadcast(RandomMsg);
                 });
            }
        }
        public void MutePlayer(BasePlayer player, string Format, int ReasonIndex, string ResonCustom = "",string TimeCustom = "", BasePlayer Initiator = null)
        {
            var cfg = config.ReasonListChat[ReasonIndex];
            string Reason = string.IsNullOrEmpty(ResonCustom) ? cfg.Reason : ResonCustom;
            float TimeMute = string.IsNullOrEmpty(TimeCustom) ? cfg.TimeMute : Convert.ToInt32(TimeCustom);
            string DisplayInititator = Initiator == null ? "Администратор" : Initiator.displayName;
            ulong UserIdInitiator = Initiator == null ? 0 : Initiator.userID;
            switch (Format)
            {
                case "mutechat":
                    {
                        ChatSettingUser[player.userID].MuteChatTime = TimeMute + CurrentTime();
                        ReplyBroadcast(GetLang("FUNC_MESSAGE_MUTE_CHAT", player.UserIDString, DisplayInititator, player.displayName, FormatTime(TimeSpan.FromSeconds(TimeMute)), Reason));
                        if (Initiator != null)
                            SetMute(Initiator);
                        DiscordSendMessage(GetLang("DISCORD_SEND_LOG_MUTE", player.UserIDString, DisplayInititator, UserIdInitiator, player.displayName, player.userID, Reason), config.OtherSetting.WebhooksMuteInfo);
                        break;
                    }
                case "unmutechat":
                    {
                        ChatSettingUser[player.userID].MuteChatTime = 0;
                        ReplyBroadcast(GetLang("FUNC_MESSAGE_UNMUTE_CHAT",player.UserIDString), DisplayInititator);
                        break;
                    }
                case "mutevoice":
                    {
                        ChatSettingUser[player.userID].MuteVoiceTime = TimeMute + CurrentTime();
                        ReplyBroadcast(GetLang("FUNC_MESSAGE_MUTE_VOICE", player.UserIDString, DisplayInititator, player.displayName, FormatTime(TimeSpan.FromSeconds(TimeMute)), Reason)); 
                        break;
                    }
            }
        }       
        public void MuteAllChatPlayer(BasePlayer player,float TimeMute = 86400) => ChatSettingUser[player.userID].MuteChatTime = TimeMute + CurrentTime();
        public void RenameFunc(BasePlayer player,string NewName)
        {
            if (permission.UserHasPermission(player.UserIDString, config.RenamePermission))
            {
                if (!AdminSetting.RenameList.ContainsKey(player.userID))
                    AdminSetting.RenameList.Add(player.userID, NewName);
                else AdminSetting.RenameList[player.userID] = NewName;
                ReplySystem(Chat.ChatChannel.Global, player, GetLang("COMMAND_RENAME_SUCCES", player.UserIDString, NewName));
            }
            else ReplySystem(Chat.ChatChannel.Global, player, GetLang("COMMAND_NOT_PERMISSION",player.UserIDString)); 
        }
        void AlertUI(BasePlayer player, string[] arg)
        {
            if (player != null)
                if (!player.IsAdmin) return;

            if (arg.Length == 0 || arg == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, GetLang("FUNC_MESSAGE_NO_ARG_BROADCAST", player.UserIDString));
                return;
            }
            string Message = "";
            foreach (var msg in arg)
                Message += " " + msg;

            foreach (BasePlayer p in BasePlayer.activePlayerList)
                UIAlert(p, Message);
        }
        void Alert(BasePlayer player, string[] arg)
        {
            if (player != null)
                if (!player.IsAdmin) return;

            if (arg.Length == 0 || arg == null)
            {
                if(player != null)
                ReplySystem(Chat.ChatChannel.Global, player, GetLang("FUNC_MESSAGE_NO_ARG_BROADCAST", player.UserIDString));
                return;
            }
            string Message = "";
            foreach (var msg in arg)
                Message += " " + msg;

            ReplyBroadcast(Message);
            if (config.RustPlusSettings.UseRustPlus)
                foreach(var playerList in BasePlayer.activePlayerList)
                    NotificationList.SendNotificationTo(playerList.userID, NotificationChannel.SmartAlarm, config.RustPlusSettings.DisplayNameAlert, Message, Util.GetServerPairingData());
        }

        #endregion

        #region Interface
        static string MAIN_PARENT = "MAIN_PARENT_UI";
        static string MUTE_MENU_PARENT = "MUTE_MENU_UI";
        static string ELEMENT_SETTINGS = "NEW_ELEMENT_SETTINGS";
        static string MAIN_ALERT_UI = "ALERT_UI_PLAYER";
        static string PANEL_ACTION = "PANEL_ACTION";
        static string PANEL_ACTION_HELPER = "PANEL_ACTION_HELPER";

        #region MainMenu

        public void UI_MainMenu(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, MAIN_PARENT);
            var Interface = config.InterfaceSetting;
            float FadeInGlobal = Interface.FadeIn;

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { FadeIn = FadeInGlobal, Color = "0 0 0 0"}
            }, "Overlay", MAIN_PARENT);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.81875 0.1768519", AnchorMax = "0.9869678 0.8814214" },   
                Image = { FadeIn = FadeInGlobal, Color = HexToRustFormat(Interface.TwoMainColor), Material = "assets/content/ui/uibackgroundblur.mat" }
            },  MAIN_PARENT, PANEL_ACTION);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.93", AnchorMax = "1 1" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("TITLE_TWO", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, PANEL_ACTION);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "0 -45", OffsetMax = "215 -5" },
                Button = { FadeIn = FadeInGlobal, Close = MAIN_PARENT, Color = HexToRustFormat(Interface.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_CLOSE_BTN", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Align = TextAnchor.MiddleCenter }
            }, PANEL_ACTION);

            #region ACTION BUTTON

            #region SettingPrefix

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.1243169 0.8383705", AnchorMax = "1 0.9179095" },
                Button = { FadeIn = FadeInGlobal, Command = "iq_chat setting prefix", Color = HexToRustFormat(Interface.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat"},
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_TEXT_PREFIX", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Align = TextAnchor.MiddleCenter }
            }, PANEL_ACTION, "PREFIX_SETTING");

            container.Add(new CuiElement
            {
                Parent = "PREFIX_SETTING",
                Components =
                    {
                        new CuiImageComponent { FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = "assets/icons/sign.png" },
                        new CuiRectTransformComponent { AnchorMin = "0.04236809 0.1937432", AnchorMax = "0.1696546 0.7884976" }
                    }
            });

            #endregion

            #region SettingColorNick

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.1243169 0.7371891", AnchorMax = "1 0.8167281" },
                Button = { FadeIn = FadeInGlobal, Command = "iq_chat setting nick", Color = HexToRustFormat(Interface.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_TEXT_COLOR_NICK", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Align = TextAnchor.MiddleCenter }
            }, PANEL_ACTION, "COLOR_NICK_SETTING");

            container.Add(new CuiElement
            {
                Parent = "COLOR_NICK_SETTING",
                Components =
                    {
                        new CuiImageComponent {FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = "assets/icons/sign.png"  },
                        new CuiRectTransformComponent { AnchorMin = "0.04236809 0.1937432", AnchorMax = "0.1696546 0.7884976" }
                    }
            });

            #endregion

            #region SettingText

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.1243169 0.6346937", AnchorMax = "1 0.7142327" },
                Button = { FadeIn = FadeInGlobal, Command = "iq_chat setting chat", Color = HexToRustFormat(Interface.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_TEXT_COLOR_MSG", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Align = TextAnchor.MiddleCenter }
            }, PANEL_ACTION, "TEXT_SETTING");

            container.Add(new CuiElement
            {
                Parent = "TEXT_SETTING",
                Components =
                    {
                        new CuiImageComponent { FadeIn = FadeInGlobal, Color = HexToRustFormat(Interface.LabelColor), Sprite = "assets/icons/sign.png" },
                        new CuiRectTransformComponent { AnchorMin = "0.04236809 0.1937432", AnchorMax = "0.1696546 0.7884976" }
                    }
            });

            #endregion

            #region SettingRank

            if (IQRankSystem)
                if (config.ReferenceSetting.IQRankSystems.UseRankSystem)
                {
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0.1243169 0.5282561", AnchorMax = "1 0.6077951" },
                        Button = { FadeIn = FadeInGlobal, Command = "iq_chat setting rank", Color = HexToRustFormat(Interface.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat" },
                        Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_TEXT_RANK", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Align = TextAnchor.MiddleCenter }
                    }, PANEL_ACTION, "RANK_SYSTEM");

                    container.Add(new CuiElement
                    {
                        Parent = "RANK_SYSTEM",
                        Components =
                    {
                        new CuiImageComponent {FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = "assets/icons/sign.png"  },
                        new CuiRectTransformComponent { AnchorMin = "0.04236809 0.1937432", AnchorMax = "0.1696546 0.7884976" }
                    }
                    });
                }
            #endregion

            #endregion

            #region ADMIN

            #region HELPERS
            if (permission.UserHasPermission(player.UserIDString, PermMuteMenu))
            {
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0.4323258", AnchorMax = "1 0.5171261" },
                    Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_TEXT_MODER_PANEL", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                }, PANEL_ACTION);

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.1243169 0.3298316", AnchorMax = "1 0.4093724" },
                    Button = { FadeIn = FadeInGlobal, Command = $"iq_chat mute menu", Color = HexToRustFormat(Interface.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat" },
                    Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_TEXT_MUTE_MENU_BTN", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Align = TextAnchor.MiddleCenter }
                }, PANEL_ACTION, "CHAT_SETTING_USER");

                container.Add(new CuiElement
                {
                    Parent = "CHAT_SETTING_USER",
                    Components =
                    {
                        new CuiImageComponent {FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = "assets/icons/subtract.png" },
                        new CuiRectTransformComponent { AnchorMin = "0.04236809 0.1937432", AnchorMax = "0.1696546 0.7884976" }
                    }
                });
            }
            #endregion

            #region OWNER
            if (player.IsAdmin)
            {
                string CommandChat = "iq_chat admin_chat";
                string TextMuteChatButton = AdminSetting.MuteChatAll ? "UI_TEXT_ADMIN_PANEL_UNMUTE_CHAT_ALL" : "UI_TEXT_ADMIN_PANEL_MUTE_CHAT_ALL";
                string CommandMuteChatButton = AdminSetting.MuteChatAll ? "unmutechat" : "mutechat";
                string CommandVoice = "iq_chat admin_voice";
                string TextMuteVoiceButton = AdminSetting.MuteVoiceAll ? "UI_TEXT_ADMIN_PANEL_UNMUTE_VOICE_ALL" : "UI_TEXT_ADMIN_PANEL_MUTE_VOICE_ALL";
                string CommandMuteVoiceButton = AdminSetting.MuteVoiceAll ? "unmutevoice" : "mutevoice";

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0.224706", AnchorMax = "1 0.3042471" },
                    Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_TEXT_ADMIN_PANEL", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                },  PANEL_ACTION);

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.1243169 0.1208954", AnchorMax = "1 0.200437" },
                    Button = { FadeIn = FadeInGlobal, Close = MAIN_PARENT, Command = $"{CommandChat} {CommandMuteChatButton}", Color = HexToRustFormat(Interface.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat"},
                    Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage(TextMuteChatButton, this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Align = TextAnchor.MiddleCenter }
                },  PANEL_ACTION, "CHAT_SETTING_ADMIN");

                container.Add(new CuiElement
                {
                    Parent = "CHAT_SETTING_ADMIN",
                    Components =
                    {
                        new CuiImageComponent {FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = "assets/icons/subtract.png" },
                        new CuiRectTransformComponent { AnchorMin = "0.04236809 0.1937432", AnchorMax = "0.1696546 0.7884976" }
                    }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.1243169 0.02496903", AnchorMax = "1 0.1045107" },
                    Button = { FadeIn = FadeInGlobal, Close = MAIN_PARENT, Command = $"{CommandVoice} {CommandMuteVoiceButton}", Color = HexToRustFormat(Interface.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat" },
                    Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage(TextMuteVoiceButton, this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Align = TextAnchor.MiddleCenter }
                },  PANEL_ACTION, "VOICE_SETTING_ADMIN");
            }
            container.Add(new CuiElement
            {
                Parent = "VOICE_SETTING_ADMIN",
                Components =
                    {
                        new CuiImageComponent { FadeIn = FadeInGlobal, Color = HexToRustFormat(Interface.LabelColor), Sprite = "assets/icons/subtract.png" },
                        new CuiRectTransformComponent { AnchorMin = "0.04236809 0.1937432", AnchorMax = "0.1696546 0.7884976" }
                    }
            });

            #endregion
            
            #endregion

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region PrefixSetting
        public void UI_PrefixSetting(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, ELEMENT_SETTINGS);
            CuiHelper.DestroyUi(player, MUTE_MENU_PARENT);
            CuiHelper.DestroyUi(player, PANEL_ACTION_HELPER);

            var Interface = config.InterfaceSetting;
            float FadeInGlobal = Interface.FadeIn;

            string Prefix = "";
            if (config.MessageSetting.MultiPrefix)
            {
                if (ChatSettingUser[player.userID].MultiPrefix != null)
                    for (int g = 0; g < ChatSettingUser[player.userID].MultiPrefix.Count; g++)
                        Prefix += ChatSettingUser[player.userID].MultiPrefix[g];
                else Prefix = ChatSettingUser[player.userID].ChatPrefix;
            }
            var PrefixList = config.PrefixList;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5020834 0.1148148", AnchorMax = "0.8150954 0.8814815" },
                Image = { FadeIn = FadeInGlobal, Color = HexToRustFormat(Interface.TwoMainColor), Material = "assets/content/ui/uibackgroundblur.mat" }
            }, MAIN_PARENT, ELEMENT_SETTINGS);

            int x = 0, y = 0, i = 0;
            foreach (var ElementPrefix in PrefixList)
            {
                if (!permission.UserHasPermission(player.UserIDString, ElementPrefix.Permissions)) continue;
                string LockStatus = "assets/icons/unlock.png";

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{0 + (x * 0.525)} {0.8514473 - (y * 0.1)}", AnchorMax = $"{0.4708602 + (x * 0.525)} {0.9245502 - (y * 0.1)}" },
                    Button = { FadeIn = FadeInGlobal, Command = $"iq_chat action prefix {ElementPrefix.Argument} {ElementPrefix.Permissions}", Color = HexToRustFormat(config.InterfaceSetting.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat"},
                    Text = { FadeIn = FadeInGlobal, Text = ElementPrefix.Argument, FontSize = 17, Color = HexToRustFormat(Interface.LabelColor), Align = TextAnchor.MiddleCenter }
                }, ELEMENT_SETTINGS, $"BUTTON_{i}");

                container.Add(new CuiElement
                {
                    Parent = $"BUTTON_{i}",
                    Components =
                    {
                        new CuiImageComponent { FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = LockStatus },
                        new CuiRectTransformComponent { AnchorMin = "0.03887215 0.1982514", AnchorMax = "0.1660901 0.7930056" }
                    }
                });

                x++;
                if (x == 2)
                {
                    y++;
                    x = 0;
                }
                i++;
            }

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.93", AnchorMax = "1 1" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_TITLE_NEW_PREFIX_ELEMENT", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, ELEMENT_SETTINGS);

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region NickSetting
        public void UI_NickSetting(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, ELEMENT_SETTINGS);
            CuiHelper.DestroyUi(player, MUTE_MENU_PARENT);
            CuiHelper.DestroyUi(player, PANEL_ACTION_HELPER);

            var Interface = config.InterfaceSetting;
            var ColorList = config.NickColorList;
            float FadeInGlobal = Interface.FadeIn;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5020834 0.1148148", AnchorMax = "0.8150954 0.8814815" },
                Image = { FadeIn = FadeInGlobal, Color = HexToRustFormat(Interface.TwoMainColor), Material = "assets/content/ui/uibackgroundblur.mat" }
            }, MAIN_PARENT, ELEMENT_SETTINGS);

            int x = 0, y = 0, i = 0;
            foreach (var ElementColor in ColorList)
            {
                if (!permission.UserHasPermission(player.UserIDString, ElementColor.Permissions)) continue;
                string LockStatus = "assets/icons/unlock.png";

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{0 + (x * 0.525)} {0.8514473 - (y * 0.1)}", AnchorMax = $"{0.4708602 + (x * 0.525)} {0.9245502 - (y * 0.1)}" },
                    Button = { FadeIn = FadeInGlobal, Command = $"iq_chat action nick {ElementColor.Argument} {ElementColor.Permissions}", Color = HexToRustFormat(config.InterfaceSetting.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat"},
                    Text = { FadeIn = FadeInGlobal, Text = $"<color={ElementColor.Argument}>{player.displayName}</color>", FontSize = 17, Color = HexToRustFormat(Interface.LabelColor), Align = TextAnchor.MiddleCenter }
                }, ELEMENT_SETTINGS, $"BUTTON_{i}");

                container.Add(new CuiElement
                {
                    Parent = $"BUTTON_{i}",
                    Components =
                    {
                        new CuiImageComponent { FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = LockStatus },
                        new CuiRectTransformComponent { AnchorMin = "0.03887215 0.1982514", AnchorMax = "0.1660901 0.7930056" }
                    }
                });

                x++;
                if (x == 2)
                {
                    y++;
                    x = 0;
                }
                i++;
            }

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.93", AnchorMax = "1 1" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_TITLE_NEW_NICK_COLOR_ELEMENT", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter}
            }, ELEMENT_SETTINGS);

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region ColorSetting
        public void UI_TextSetting(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, ELEMENT_SETTINGS);
            CuiHelper.DestroyUi(player, MUTE_MENU_PARENT);
            CuiHelper.DestroyUi(player, PANEL_ACTION_HELPER);

            var Interface = config.InterfaceSetting;
            var ColorList = config.MessageColorList;
            float FadeInGlobal = Interface.FadeIn;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5020834 0.1148148", AnchorMax = "0.8150954 0.8814815" },
                Image = { FadeIn = FadeInGlobal, Color = HexToRustFormat(Interface.TwoMainColor), Material = "assets/content/ui/uibackgroundblur.mat" }
            }, MAIN_PARENT, ELEMENT_SETTINGS);

            int x = 0, y = 0, i = 0;
            foreach (var ElementColor in ColorList)
            {
                if (!permission.UserHasPermission(player.UserIDString, ElementColor.Permissions)) continue;
                string LockStatus = "assets/icons/unlock.png";

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{0 + (x * 0.525)} {0.8514473 - (y * 0.1)}", AnchorMax = $"{0.4708602 + (x * 0.525)} {0.9245502 - (y * 0.1)}" },
                    Button = { FadeIn = FadeInGlobal, Command = $"iq_chat action chat {ElementColor.Argument} {ElementColor.Permissions}", Color = HexToRustFormat(config.InterfaceSetting.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat" },
                    Text = { FadeIn = FadeInGlobal, Text = $"<color={ElementColor.Argument}>Сообщение</color>", Align = TextAnchor.MiddleCenter }
                }, ELEMENT_SETTINGS, $"BUTTON_{i}");

                container.Add(new CuiElement
                {
                    Parent = $"BUTTON_{i}",
                    Components =
                    {
                        new CuiImageComponent { FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = LockStatus },
                        new CuiRectTransformComponent { AnchorMin = "0.03887215 0.1982514", AnchorMax = "0.1660901 0.7930056" }
                    }
                });
                x++;
                if (x == 2)
                {
                    y++;
                    x = 0;
                }
            }

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.93", AnchorMax = "1 1" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_TITLE_NEW_MESSAGE_COLOR_ELEMENT", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter}
            }, ELEMENT_SETTINGS);

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region RankSetting
        public void UI_RankSettings(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, ELEMENT_SETTINGS);
            CuiHelper.DestroyUi(player, MUTE_MENU_PARENT);
            CuiHelper.DestroyUi(player, PANEL_ACTION_HELPER);

            var Interface = config.InterfaceSetting;
            List<string> RankKeys = IQRankListKey(player.userID);
            float FadeInGlobal = Interface.FadeIn;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5020834 0.1148148", AnchorMax = "0.8150954 0.8814815" },
                Image = { FadeIn = FadeInGlobal, Color = HexToRustFormat(Interface.TwoMainColor), Material = "assets/content/ui/uibackgroundblur.mat" }
            }, MAIN_PARENT, ELEMENT_SETTINGS);

            int x = 0, y = 0, i = 0;
            foreach (var ElementRank in RankKeys.Where(r => IQRankUserAcces(player.userID, r)))
            {
                string LockStatus = "assets/icons/unlock.png";
                string RankName = IQRankGetNameRankKey(ElementRank);
                if (String.IsNullOrWhiteSpace(RankName)) continue;

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{0 + (x * 0.525)} {0.8514473 - (y * 0.1)}", AnchorMax = $"{0.4708602 + (x * 0.525)} {0.9245502 - (y * 0.1)}" },
                    Button = { FadeIn = FadeInGlobal, Command = $"iq_chat action rank {ElementRank}", Color = HexToRustFormat(config.InterfaceSetting.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat" },
                    Text = { FadeIn = FadeInGlobal, Text = $"{RankName}", Align = TextAnchor.MiddleCenter }
                }, ELEMENT_SETTINGS, $"BUTTON_{i}");

                container.Add(new CuiElement
                {
                    Parent = $"BUTTON_{i}",
                    Components =
                    {
                        new CuiImageComponent { FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = LockStatus },
                        new CuiRectTransformComponent { AnchorMin = "0.03887215 0.1982514", AnchorMax = "0.1660901 0.7930056" }
                    }
                });
                x++;
                if (x == 2)
                {
                    y++;
                    x = 0;
                }
            }

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.93", AnchorMax = "1 1" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_TITLE_NEW_MESSAGE_RANK_ELEMENT", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, ELEMENT_SETTINGS);

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region MuteMenu
        public void UI_MuteMenu(BasePlayer player, string TargetName = "")
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, MUTE_MENU_PARENT);
            CuiHelper.DestroyUi(player, ELEMENT_SETTINGS);
            CuiHelper.DestroyUi(player, PANEL_ACTION_HELPER);

            var Interface = config.InterfaceSetting;
            float FadeInGlobal = Interface.FadeIn;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.1546875 0.1148148", AnchorMax = "0.8150954 0.8814815" },
                Image = { FadeIn = FadeInGlobal, Color = HexToRustFormat(Interface.TwoMainColor) }
            }, MAIN_PARENT, MUTE_MENU_PARENT);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.9227053", AnchorMax = "1 1" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_MUTE_PANEL_TITLE", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            },  MUTE_MENU_PARENT);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.898551", AnchorMax = "1 0.9456524" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_MUTE_PANEL_TITLE_ACTION", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, MUTE_MENU_PARENT);

            string SearchName = "";
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.8417874", AnchorMax = "1 0.8961352" },
                Image = { FadeIn = FadeInGlobal, Color = HexToRustFormat(Interface.ButtonColor) }
            }, MUTE_MENU_PARENT, MUTE_MENU_PARENT + ".Input");

            container.Add(new CuiElement
            {
                Parent = MUTE_MENU_PARENT + ".Input",
                Name = MUTE_MENU_PARENT + ".Input.Current",
                Components =
                {
                    new CuiInputFieldComponent { Text = SearchName, FontSize = 14,Command = $"mute_search {SearchName}", Align = TextAnchor.MiddleCenter, Color = HexToRustFormat("#ffffffFF"), CharsLimit = 15},
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                }
            });

            int x = 0; int y = 0;
            foreach (var pList in BasePlayer.activePlayerList.Where(i => i.displayName.ToLower().Contains(TargetName.ToLower())))
            {
                string LockStatus = ChatSettingUser[pList.userID].MuteChatTime > CurrentTime() ? "assets/icons/lock.png" :
                                    ChatSettingUser[pList.userID].MuteVoiceTime > CurrentTime() ? "assets/icons/lock.png" : "assets/icons/unlock.png";
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{0.006797731 + (x * 0.165)} {0.7838164 - (y * 0.057)}", AnchorMax = $"{0.1661653 + (x * 0.165)} {0.8309178 - (y * 0.057)}" },
                    Button = { FadeIn = FadeInGlobal, Command = $"iq_chat mute actionmenu {pList.userID}", Color = HexToRustFormat(Interface.ButtonColor) },
                    Text = { FadeIn = FadeInGlobal, Text = "", Align = TextAnchor.MiddleCenter }
                }, MUTE_MENU_PARENT, $"BUTTON{player.userID}");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.1611373 0", AnchorMax = "1 1" },
                    Text = { FadeIn = FadeInGlobal, Text = pList.displayName.Replace(" ", ""), FontSize = 12, Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
                }, $"BUTTON{player.userID}");

                container.Add(new CuiElement
                {
                    Parent = $"BUTTON{player.userID}",
                    Components =
                    {
                        new CuiImageComponent { FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = LockStatus },
                        new CuiRectTransformComponent { AnchorMin = "0.02369668 0.2051285", AnchorMax = "0.1374408 0.820514" }
                    }
                });

                x++;
                if (y == 12 && x == 6) break;

                if (x == 6)
                {
                    y++;
                    x = 0;
                }

            };

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.02870133 0.05434785", AnchorMax = "0.3300647 0.08333336" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_MUTE_PANEL_TITLE_HELPS_LOCK",this, player.UserIDString), FontSize = 10, Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            },  MUTE_MENU_PARENT);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.02870133 0.01570053", AnchorMax = "0.3300647 0.04468608" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_MUTE_PANEL_TITLE_HELPS_UNLOCK", this, player.UserIDString), FontSize = 10, Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, MUTE_MENU_PARENT);

            container.Add(new CuiElement
            {
                Parent = MUTE_MENU_PARENT,
                Components =
                    {
                        new CuiImageComponent {FadeIn = FadeInGlobal,   Color = HexToRustFormat(Interface.LabelColor), Sprite = "assets/icons/lock.png" },
                        new CuiRectTransformComponent { AnchorMin = "0.006797716 0.05434785", AnchorMax = "0.02492483 0.08333336" }
                    }
            });

            container.Add(new CuiElement
            {
                Parent = MUTE_MENU_PARENT,
                Components =
                    {
                        new CuiImageComponent { FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = "assets/icons/unlock.png" },
                        new CuiRectTransformComponent { AnchorMin = "0.006797716 0.01449281", AnchorMax = "0.02492483 0.04347835" }
                    }
            });

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region MuteAction
        
        public void UI_MuteTakeAction(BasePlayer player,ulong userID)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, PANEL_ACTION_HELPER);
            var Interface = config.InterfaceSetting;
            float FadeInGlobal = Interface.FadeIn;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.01197916 0.1148148", AnchorMax = "0.1505208 0.8814214" },  
                Image = { FadeIn = FadeInGlobal, Color = HexToRustFormat(Interface.TwoMainColor), Material = "assets/content/ui/uibackgroundblur.mat" }
            },  MAIN_PARENT, PANEL_ACTION_HELPER);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.919082", AnchorMax = "1 1" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_MUTE_TAKE_ACTION_PANEL", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            },  PANEL_ACTION_HELPER);

            string LockStatus = ChatSettingUser[userID].MuteChatTime > CurrentTime() ? "assets/icons/unlock.png" :
                    ChatSettingUser[userID].MuteVoiceTime > CurrentTime() ? "assets/icons/unlock.png" : "assets/icons/lock.png";

            string ButtonChat = ChatSettingUser[userID].MuteChatTime > CurrentTime() ?  "UI_MUTE_TAKE_ACTION_CHAT_UNMUTE" : "UI_MUTE_TAKE_ACTION_CHAT";
            string ButtonVoice = ChatSettingUser[userID].MuteVoiceTime > CurrentTime() ? "UI_MUTE_TAKE_ACTION_VOICE_UNMUTE" : "UI_MUTE_TAKE_ACTION_VOICE";
            string ButtonCommandChat = ChatSettingUser[userID].MuteChatTime > CurrentTime() ? $"iq_chat mute action {userID} unmutechat" : $"iq_chat mute action {userID} mute mutechat";
            string ButtonCommandVoice = ChatSettingUser[userID].MuteVoiceTime > CurrentTime() ? $"iq_chat mute action {userID} unmutevoice" : $"iq_chat mute action {userID} mute mutevoice";

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0.8357491", AnchorMax = "0.903084 0.8961352" },
                Button = { FadeIn = FadeInGlobal, Command = ButtonCommandChat, Color = HexToRustFormat(Interface.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat"},
                Text = { FadeIn = FadeInGlobal, Text = "",  Align = TextAnchor.MiddleCenter }
            },  PANEL_ACTION_HELPER, "CHAT");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.1790024 0", AnchorMax = "1 1" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage(ButtonChat, this, player.UserIDString), FontSize = 10, Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, $"CHAT");

            container.Add(new CuiElement
            {
                Parent = $"CHAT",
                Components =
                    {
                        new CuiImageComponent { FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = LockStatus },
                        new CuiRectTransformComponent { AnchorMin = "0.02369668 0.2051285", AnchorMax = "0.1374408 0.820514" }
                    }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0.7620788", AnchorMax = "0.903084 0.8224649" },
                Button = { FadeIn = FadeInGlobal, Command = ButtonCommandVoice, Color = HexToRustFormat(Interface.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat"},
                Text = { FadeIn = FadeInGlobal, Text = "", Align = TextAnchor.MiddleCenter }
            },  PANEL_ACTION_HELPER, "VOICE");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.1790024 0", AnchorMax = "1 1" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage(ButtonVoice, this, player.UserIDString), FontSize = 10, Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, $"VOICE");

            container.Add(new CuiElement
            {
                Parent = $"VOICE",
                Components =
                    {
                        new CuiImageComponent { FadeIn = FadeInGlobal, Color = HexToRustFormat(Interface.LabelColor), Sprite = LockStatus },
                        new CuiRectTransformComponent { AnchorMin = "0.02369668 0.2051285", AnchorMax = "0.1374408 0.820514" }
                    }
            });

            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region ReasonMute
        void UI_ReasonMute(BasePlayer player,ulong userID, string MuteFormat)
        {
            CuiElementContainer container = new CuiElementContainer();
            var Interface = config.InterfaceSetting;
            float FadeInGlobal = Interface.FadeIn;

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.6702939", AnchorMax = "1 0.7512119" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_MUTE_TAKE_REASON_TITLE", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            },  PANEL_ACTION_HELPER);

            int i = 0;
            foreach(var Reason in config.ReasonListChat)
            {           
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0 {0.5942072 - (i * 0.07)}", AnchorMax = $"0.903084 {0.6545933 - (i * 0.07)}" },
                    Button = { FadeIn = FadeInGlobal, Command = $"iq_chat mute action {userID} mute_reason {MuteFormat} {i}", Color = HexToRustFormat(Interface.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat" },
                    Text = { FadeIn = FadeInGlobal, Text = "", Align = TextAnchor.MiddleCenter }
                },  PANEL_ACTION_HELPER, $"BUTTON{i}");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.1790024 0", AnchorMax = "1 1" },
                    Text = { FadeIn = FadeInGlobal, Text = Reason.Reason, FontSize = 10, Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
                },  $"BUTTON{i}");

                container.Add(new CuiElement
                {
                    Parent = $"BUTTON{i}",
                    Components =
                    {
                        new CuiImageComponent { FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = "assets/icons/favourite_servers.png" },
                        new CuiRectTransformComponent { AnchorMin = "0.02369668 0.2051285", AnchorMax = "0.1374408 0.820514" }
                    }
                });
                i++;
            }

            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region UpdateLabel
        public void UpdateLabel(BasePlayer player, SettingUser DataPlayer, string Rank = "")
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, "UPDATE_LABEL");

            string Prefix = "";
            if (config.MessageSetting.MultiPrefix)
            {
                if (DataPlayer.MultiPrefix != null)
                    for (int i = 0; i < DataPlayer.MultiPrefix.Count; i++)
                        Prefix += DataPlayer.MultiPrefix[i];
            }
            else Prefix = DataPlayer.ChatPrefix;
            string ResultNick = !String.IsNullOrEmpty(Rank) ? $"<b>[{Rank}] {Prefix}<color={DataPlayer.NickColor}>{player.displayName}</color> : <color={DataPlayer.MessageColor}> я лучший</color></b>" : $"<b>{Prefix}<color={DataPlayer.NickColor}>{player.displayName}</color> : <color={DataPlayer.MessageColor}> я лучший</color></b>";

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.07367153" },
                Text = { FadeIn = config.InterfaceSetting.FadeIn, Text = $"{ResultNick}", FontSize = 14, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf"}
            },  ELEMENT_SETTINGS, "UPDATE_LABEL");

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region UIAlert
        void UIAlert(BasePlayer player, string Message)
        {
            if (XDNotifications && config.ReferenceSetting.XDNotificationsSettings.UseXDNotifications)
            {
                AddNotify(player, lang.GetMessage("UI_ALERT_TITLE", this, player.UserIDString), Message);
                return;
            }
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, MAIN_ALERT_UI);
            var Interface = config.InterfaceSetting;
            var Transform = Interface.AlertInterfaceSetting;
            float FadeInGlobal = Interface.FadeIn;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = Transform.AnchorMin, AnchorMax = Transform.AnchorMax, OffsetMin = Transform.OffsetMin, OffsetMax = Transform.OffsetMax },
                Image = { FadeIn = FadeInGlobal, Color = HexToRustFormat(config.InterfaceSetting.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat" }
            }, "Overlay", MAIN_ALERT_UI);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.025 0.5523812", AnchorMax = "0.1 0.8952214" },  //
                Image = { FadeIn = FadeInGlobal, Color = HexToRustFormat(Interface.MainColor), Sprite = "assets/icons/upgrade.png" }
            }, MAIN_ALERT_UI);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.1125001 0.5037036", AnchorMax = "1 1" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_ALERT_TITLE", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, MAIN_ALERT_UI);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.5259256" },
                Text = { FadeIn = FadeInGlobal, Text = $"{Message}", FontSize = 12, Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, MAIN_ALERT_UI);

            CuiHelper.AddUi(player, container);

            timer.Once(config.MessageSetting.TimeDeleteAlertUI, () =>
            {
                CuiHelper.DestroyUi(player, MAIN_ALERT_UI);
            });
        }
        #endregion

        #endregion

        #region Command

        #region UsingCommand
        [ConsoleCommand("mute")]
        void MuteCustomAdmin(ConsoleSystem.Arg arg)
        {
            if (arg == null || arg.Args == null || arg.Args.Length != 3 || arg.Args.Length > 3)
            {
                PrintWarning("Неверный синтаксис,используйте : mute Steam64ID Причина Время(секунды)");
                return;
            }
            ulong userID = ulong.Parse(arg.Args[0]);
            if (!userID.IsSteamId())
            {
                PrintWarning("Неверный Steam64ID");
                return;
            }
            string Reason = arg.Args[1];
            string TimeMute = arg.Args[2];
            BasePlayer target = BasePlayer.FindByID(userID);
            if (target == null)
            {
                PrintWarning("Такого игрока нет на сервере");
                return;
            }
            MutePlayer(target, "mutechat", 0, Reason, TimeMute);
            Puts("Успешно");
        }
        [ConsoleCommand("unmute")]
        void UnMuteCustomAdmin(ConsoleSystem.Arg arg)
        {
            if (arg == null || arg.Args == null || arg.Args.Length != 1 || arg.Args.Length > 1)
            {
                PrintWarning("Неверный синтаксис,используйте : unmute Steam64ID");
                return;
            }
            ulong userID = ulong.Parse(arg.Args[0]);
            if (!userID.IsSteamId())
            {
                PrintWarning("Неверный Steam64ID");
                return;
            }
            BasePlayer target = BasePlayer.FindByID(userID);
            if (target == null)
            {
                PrintWarning("Такого игрока нет на сервере");
                return;
            }
            ChatSettingUser[target.userID].MuteChatTime = 0;
            ReplyBroadcast(GetLang("FUNC_MESSAGE_UNMUTE_CHAT",target.UserIDString, "Администратор", target.displayName));
            Puts("Успешно");
        }
        [ChatCommand("text")]
        void ChatCommandMenu(BasePlayer player) => UI_MainMenu(player);

        [ChatCommand("alert")]
        void ChatAlertPlayers(BasePlayer player, string cmd, string[] arg) => Alert(player, arg);

        [ChatCommand("alertui")]
        void ChatAlertPlayersUI(BasePlayer player, string cmd, string[] arg) => AlertUI(player, arg);

        [ChatCommand("rename")]
        void RenameMetods(BasePlayer player, string cmd, string[] arg)
        {
            if (arg.Length == 0 || arg == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("COMMAND_RENAME_NOTARG", this, player.UserIDString));
                return;
            }
            string NewName = "";
            foreach (var name in arg)
                NewName += " " + name;
            RenameFunc(player, NewName);
        }

        #region PM

        [ChatCommand("pm")]
        void PmChat(BasePlayer player, string cmd, string[] arg)
        {
            if (!config.MessageSetting.PMActivate) return;
            if (arg.Length == 0 || arg == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("COMMAND_PM_NOTARG", this, player.UserIDString));
                return;
            }
            string NameUser = arg[0];
            if (config.ReferenceSetting.IQFakeActiveSettings.UseIQFakeActive)
                if (IQFakeActive)
                    if (IsFake(NameUser))
                    {
                        ReplySystem(Chat.ChatChannel.Global, player, GetLang("COMMAND_PM_SUCCESS", player.UserIDString, string.Join(" ", arg.ToArray().ToArray()).Replace(NameUser, "")));
                        return;
                    }
            BasePlayer TargetUser = FindPlayer(NameUser);
            if (TargetUser == null || NameUser == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("COMMAND_PM_NOT_USER", this, player.UserIDString));
                return;
            }
            if (config.MessageSetting.IgnoreUsePM)
            {
                if (ChatSettingUser[TargetUser.userID].IgnoredUsers.Contains(player.userID))
                {
                    ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("IGNORE_NO_PM", this, player.UserIDString));
                    return;
                }
                if (ChatSettingUser[player.userID].IgnoredUsers.Contains(TargetUser.userID))
                {
                    ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("IGNORE_NO_PM_ME", this, player.UserIDString));
                    return;
                }
            }
            var argList = arg.ToArray();
            string Message = string.Join(" ", argList.ToArray()).Replace(NameUser, "");
            if (Message.Length > 125) return;
            if (Message.Length <= 0 || Message == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("COMMAND_PM_NOT_NULL_MSG", this, player.UserIDString));
                return;
            }

            PMHistory[TargetUser] = player;
            PMHistory[player] = TargetUser;
            var DisplayNick = AdminSetting.RenameList.ContainsKey(player.userID) ? AdminSetting.RenameList[player.userID] : player.displayName;

            ReplySystem(Chat.ChatChannel.Global, TargetUser, GetLang("COMMAND_PM_SEND_MSG", player.UserIDString, DisplayNick, Message));
            ReplySystem(Chat.ChatChannel.Global, player, GetLang("COMMAND_PM_SUCCESS", player.UserIDString, Message));
            Effect.server.Run(config.MessageSetting.SoundPM, TargetUser.GetNetworkPosition());
            Log($"ЛИЧНЫЕ СООБЩЕНИЯ : {player.userID}({DisplayNick}) отправил сообщение игроку - {TargetUser.displayName}\nСООБЩЕНИЕ : {Message}");

            RCon.Broadcast(RCon.LogType.Chat, new Chat.ChatEntry
            {
                Message = $"ЛИЧНЫЕ СООБЩЕНИЯ : {DisplayNick}({player.userID}) -> {TargetUser.displayName} : СООБЩЕНИЕ : {Message}",
                UserId = player.UserIDString,
                Username = player.displayName,
                Channel = Chat.ChatChannel.Global,
                Time = (DateTime.UtcNow.Hour * 3600) + (DateTime.UtcNow.Minute * 60),
                Color = "#3f4bb8",
            });
            PrintWarning($"ЛИЧНЫЕ СООБЩЕНИЯ : {DisplayNick}({player.userID}) -> {TargetUser.displayName} : СООБЩЕНИЕ : {Message}");
        }

        [ChatCommand("r")]
        void RChat(BasePlayer player, string cmd, string[] arg)
        {
            if (!config.MessageSetting.PMActivate) return;
            if (arg.Length == 0 || arg == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("COMMAND_R_NOTARG", this, player.UserIDString));
                return;
            }
            if (!PMHistory.ContainsKey(player))
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("COMMAND_R_NOTMSG", this, player.UserIDString));
                return;
            }
            BasePlayer RetargetUser = PMHistory[player];
            if (RetargetUser == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("COMMAND_PM_NOT_USER", this, player.UserIDString));
                return;
            }
            if (config.MessageSetting.IgnoreUsePM)
            {
                if (ChatSettingUser[RetargetUser.userID].IgnoredUsers.Contains(player.userID))
                {
                    ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("IGNORE_NO_PM", this, player.UserIDString));
                    return;
                }
                if (ChatSettingUser[player.userID].IgnoredUsers.Contains(RetargetUser.userID))
                {
                    ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("IGNORE_NO_PM_ME", this, player.UserIDString));
                    return;
                }
            }
            string Message = string.Join(" ", arg.ToArray());
            if (Message.Length > 125) return;
            if (Message.Length <= 0 || Message == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("COMMAND_PM_NOT_NULL_MSG", this, player.UserIDString));
                return;
            }
            PMHistory[RetargetUser] = player;
            var DisplayNick = AdminSetting.RenameList.ContainsKey(player.userID) ? AdminSetting.RenameList[player.userID] : player.displayName;

            ReplySystem(Chat.ChatChannel.Global, RetargetUser, GetLang("COMMAND_PM_SEND_MSG", player.UserIDString, DisplayNick, Message));
            ReplySystem(Chat.ChatChannel.Global, player, GetLang("COMMAND_PM_SUCCESS", player.UserIDString, Message));

            Effect.server.Run(config.MessageSetting.SoundPM, RetargetUser.GetNetworkPosition());
            Log($"ЛИЧНЫЕ СООБЩЕНИЯ : {player.displayName} отправил сообщение игроку - {RetargetUser.displayName}\nСООБЩЕНИЕ : {Message}");

            RCon.Broadcast(RCon.LogType.Chat, new Chat.ChatEntry
            {
                Message = $"ЛИЧНЫЕ СООБЩЕНИЯ : {DisplayNick}({player.userID}) -> {RetargetUser.displayName} : СООБЩЕНИЕ : {Message}",
                UserId = player.UserIDString,
                Username = player.displayName,
                Channel = Chat.ChatChannel.Global,
                Time = (DateTime.UtcNow.Hour * 3600) + (DateTime.UtcNow.Minute * 60),
                Color = "#3f4bb8",
            });
            PrintWarning($"ЛИЧНЫЕ СООБЩЕНИЯ : {DisplayNick}({player.userID}) -> {RetargetUser.displayName} : СООБЩЕНИЕ : {Message}");
        }

        [ChatCommand("ignore")]
        void IgnorePlayerPM(BasePlayer player, string cmd, string[] arg)
        {
            if (!config.MessageSetting.IgnoreUsePM) return;
            var ChatUser = ChatSettingUser[player.userID];
            if (arg.Length == 0 || arg == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("INGORE_NOTARG", this, player.UserIDString));
                return;
            }
            string NameUser = arg[0];
            BasePlayer TargetUser = FindPlayer(NameUser);
            if (TargetUser == null || NameUser == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("COMMAND_PM_NOT_USER", this, player.UserIDString));
                return;
            }

            string Lang = !ChatUser.IgnoredUsers.Contains(TargetUser.userID) ? GetLang("IGNORE_ON_PLAYER", player.UserIDString, TargetUser.displayName) : GetLang("IGNORE_OFF_PLAYER", player.UserIDString, TargetUser.displayName);
            ReplySystem(Chat.ChatChannel.Global, player, Lang);
            if (!ChatUser.IgnoredUsers.Contains(TargetUser.userID))
                ChatUser.IgnoredUsers.Add(TargetUser.userID);
            else ChatUser.IgnoredUsers.Remove(TargetUser.userID);
        }

        #endregion

        [ConsoleCommand("alert")]
        void ChatAlertPlayersCMD(ConsoleSystem.Arg arg) => Alert(arg.Player(), arg.Args);

        [ConsoleCommand("alertui")]
        void ChatAlertPlayersUICMD(ConsoleSystem.Arg arg) => AlertUI(arg.Player(), arg.Args);

        [ConsoleCommand("alertuip")]
        void CmodAlertOnlyUser(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length < 2)
            {
                PrintWarning("Используйте правильно ситаксис : alertuip Steam64ID Сообщение");
                return;
            }
            ulong SteamID = ulong.Parse(arg.Args[0]);
            var argList = arg.Args.ToArray();
            string Message = string.Join(" ", argList.ToArray().Skip(1));
            if (Message.Length > 125) return;
            if (Message.Length <= 0 || Message == null)
            {
                PrintWarning("Вы не указали сообщение игроку");
                return;
            }
            BasePlayer player = BasePlayer.FindByID(SteamID);
            if (player == null)
            {
                PrintWarning("Игрока нет в сети");
                return;
            }
            UIAlert(player, Message);
        }

        [ConsoleCommand("saybro")]
        void ChatAlertPlayerInPM(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length < 2)
            {
                PrintWarning("Используйте правильно ситаксис : saybro Steam64ID Сообщение");
                return;
            }
            ulong SteamID = ulong.Parse(arg.Args[0]);
            var argList = arg.Args.ToArray();
            string Message = string.Join(" ", argList.ToArray());
            if (Message.Length > 125) return;
            if (Message.Length <= 0 || Message == null)
            {
                PrintWarning("Вы не указали сообщение игроку");
                return;
            }
            BasePlayer player = BasePlayer.FindByID(SteamID);
            if(player == null)
            {
                PrintWarning("Игрока нет в сети");
                return;
            }
            ReplySystem(Chat.ChatChannel.Global, player, Message.Replace(SteamID.ToString(), ""));
        }

        [ConsoleCommand("set")]
        private void ConsolesCommandPrefixSet(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length != 3)
            {
                PrintWarning("Используйте правильно ситаксис : set [Steam64ID] [prefix/chat/nick/custom] [Argument]");
                return;
            }
            ulong Steam64ID = 0;
            BasePlayer player = null;
            if (ulong.TryParse(arg.Args[0], out Steam64ID))
                player = BasePlayer.FindByID(Steam64ID);
            if (player == null)
            {
                PrintWarning("Неверно указан SteamID игрока или ошибка в синтаксисе\nИспользуйте правильно ситаксис : set [Steam64ID] [prefix/chat/nick/custom] [Argument]");
                return;
            }
            var DataPlayer = ChatSettingUser[player.userID];

            switch (arg.Args[1].ToLower())
            {
                case "prefix":
                    {
                        string KeyPrefix = arg.Args[2];
                        foreach (var Prefix in config.PrefixList.Where(x => x.Permissions == KeyPrefix))
                            if (config.PrefixList.Contains(Prefix))
                            {
                                DataPlayer.ChatPrefix = Prefix.Argument;
                                Puts($"Префикс успешно установлен на - {Prefix.Argument}");
                            }
                            else Puts("Неверно указан Permissions от префикса");
                        break;
                    }
                case "chat":
                    {
                        string KeyChatColor = arg.Args[2];
                        foreach (var ColorChat in config.PrefixList.Where(x => x.Permissions == KeyChatColor))
                            if (config.MessageColorList.Contains(ColorChat))
                            {
                                DataPlayer.MessageColor = ColorChat.Argument;
                                Puts($"Цвет сообщения успешно установлен на - {ColorChat.Argument}");
                            }
                            else Puts("Неверно указан Permissions от префикса");
                        break;
                    }
                case "nick":
                    {
                        string KeyNickColor = arg.Args[2];
                        foreach (var ColorChat in config.NickColorList.Where(x => x.Permissions == KeyNickColor))
                            if (config.NickColorList.Contains(ColorChat))
                            {
                                DataPlayer.NickColor = ColorChat.Argument;
                                Puts($"Цвет ника успешно установлен на - {ColorChat.Argument}");
                            }
                            else Puts("Неверно указан Permissions от префикса");
                        break;
                    }
                case "custom":
                    {
                        string CustomPrefix = arg.Args[2];
                        DataPlayer.ChatPrefix = CustomPrefix;
                        Puts($"Кастомный префикс успешно установлен на - {CustomPrefix}");
                        break;
                    }
                default:
                    {
                        PrintWarning("Используйте правильно ситаксис : set [Steam64ID] [prefix/chat/nick/custom] [Argument]");
                        break;
                    }
            }

        }

        #endregion

        #region FuncCommand

        [ConsoleCommand("mute_search")]
        void ConsoleSearchMute(ConsoleSystem.Arg arg)
        {
            BasePlayer moder = arg.Player();
            if (arg.Args == null || arg.Args.Length == 0) return;
            string Searcher = arg.Args[0].ToLower();
            if (string.IsNullOrEmpty(Searcher) || Searcher.Length == 0 || Searcher.Length < 1) return;
            UI_MuteMenu(moder, Searcher);
        }                              
        
        [ConsoleCommand("iq_chat")]
        private void ConsoleCommandIQChat(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            var DataPlayer = ChatSettingUser[player.userID];

            switch (arg.Args[0])
            {
                #region Setting
                case "setting": 
                    {
                        switch(arg.Args[1])
                        {
                            case "prefix":
                                {
                                    UI_PrefixSetting(player);
                                    break;
                                }
                            case "nick":
                                {
                                    UI_NickSetting(player);
                                    break;
                                }
                            case "chat":
                                {
                                    UI_TextSetting(player);
                                    break;
                                }
                            case "rank":
                                {
                                    UI_RankSettings(player);
                                    break;
                                }
                        }
                        break;
                    }
                #endregion

                #region Action
                case "action": 
                    {
                        switch(arg.Args[1])
                        {
                            case "prefix":
                                {
                                    var Selected = arg.Args[2];
                                    var Permission = arg.Args[3];
                                    if (!permission.UserHasPermission(player.UserIDString, Permission)) return;

                                    if (config.MessageSetting.MultiPrefix)
                                    {
                                        if (!DataPlayer.MultiPrefix.Contains(Selected))
                                            DataPlayer.MultiPrefix.Add(Selected);
                                        else DataPlayer.MultiPrefix.Remove(Selected);
                                    }
                                    if (DataPlayer.ChatPrefix != Selected)
                                        DataPlayer.ChatPrefix = Selected;
                                    else DataPlayer.ChatPrefix = config.AutoSetupSetting.ReturnDefaultSetting.PrefixDefault;
                                    UpdateLabel(player, DataPlayer);
                                    break;
                                }
                            case "nick":
                                {
                                    var Selected = arg.Args[2];
                                    var Permission = arg.Args[3];
                                    if (!permission.UserHasPermission(player.UserIDString, Permission)) return;

                                    if (DataPlayer.NickColor != Selected)
                                        DataPlayer.NickColor = Selected;
                                    else DataPlayer.NickColor = config.AutoSetupSetting.ReturnDefaultSetting.NickDefault;
                                    UpdateLabel(player, DataPlayer);
                                    break;
                                }
                            case "chat":
                                {
                                    var Selected = arg.Args[2];
                                    var Permission = arg.Args[3];
                                    if (!permission.UserHasPermission(player.UserIDString, Permission)) return;

                                    if (DataPlayer.MessageColor != Selected)
                                        DataPlayer.MessageColor = Selected;
                                    else DataPlayer.MessageColor = config.AutoSetupSetting.ReturnDefaultSetting.MessageDefault;
                                    UpdateLabel(player, DataPlayer);
                                    break;
                                }
                            case "rank":
                                {
                                    string RankKey = arg.Args[2];
                                    IQRankSetRank(player.userID, RankKey);
                                    UpdateLabel(player, DataPlayer, IQRankGetNameRankKey(RankKey));
                                    break;
                                }
                        }
                        break;
                    }
                #endregion
                
                #region Mute
                case "mute":
                    {
                        string Action = arg.Args[1];
                        switch (Action)
                        {
                            case "menu":
                                {
                                    if (permission.UserHasPermission(player.UserIDString, PermMuteMenu))
                                        UI_MuteMenu(player);
                                    break;
                                }
                            case "actionmenu":
                                {
                                    BasePlayer target = BasePlayer.FindByID(ulong.Parse(arg.Args[2]));
                                    UI_MuteTakeAction(player, target.userID);
                                    break;
                                }
                            case "action": 
                                {
                                    BasePlayer target = BasePlayer.FindByID(ulong.Parse(arg.Args[2]));
                                    string MuteAction = arg.Args[3];
                                    switch (MuteAction)
                                    {
                                        case "mute":
                                            {
                                                string MuteFormat = arg.Args[4];
                                                UI_ReasonMute(player, target.userID, MuteFormat);
                                                break;
                                            }
                                        case "mute_reason":
                                            {
                                                CuiHelper.DestroyUi(player, MAIN_PARENT);
                                                string MuteFormat = arg.Args[4];
                                                int Index = Convert.ToInt32(arg.Args[5]);
                                                MutePlayer(target, MuteFormat, Index, "", "", player);
                                                break;
                                            }
                                        case "unmutechat":
                                            {
                                                CuiHelper.DestroyUi(player, MAIN_PARENT);
                                                ChatSettingUser[target.userID].MuteChatTime = 0;
                                                ReplyBroadcast(GetLang("FUNC_MESSAGE_UNMUTE_CHAT", player.UserIDString, player.displayName, target.displayName));
                                                break;
                                            }
                                        case "unmutevoice":
                                            {
                                                CuiHelper.DestroyUi(player, MAIN_PARENT);
                                                ChatSettingUser[target.userID].MuteVoiceTime = 0;
                                                ReplyBroadcast(GetLang("FUNC_MESSAGE_UNMUTE_VOICE", player.UserIDString, player.displayName, target.displayName));
                                                break;
                                            }
                                    }
                                    break;
                                }
                        }
                        break;
                    }              
                #endregion

                #region ADMIN
                case "admin_voice":
                    {
                        var Command = arg.Args[1];
                        switch(Command)
                        {
                            case "mutevoice":
                                {
                                    AdminSetting.MuteVoiceAll = true;
                                    foreach (var p in BasePlayer.activePlayerList)
                                        ChatSettingUser[p.userID].MuteVoiceTime = CurrentTime() + 86400;
                                    ReplyBroadcast(lang.GetMessage("FUNC_MESSAGE_MUTE_ALL_VOICE", this, player.UserIDString));
                                    break;
                                }
                            case "unmutevoice":
                                {
                                    AdminSetting.MuteVoiceAll = false;
                                    foreach (var p in BasePlayer.activePlayerList)
                                        ChatSettingUser[p.userID].MuteVoiceTime = 0;
                                    ReplyBroadcast(lang.GetMessage("FUNC_MESSAGE_UNMUTE_ALL_VOICE", this, player.UserIDString));
                                    break;
                                }
                        }
                        foreach (var p in BasePlayer.activePlayerList)
                            rust.RunServerCommand(Command, p.userID);
                        break;
                    }
                case "admin_chat":
                    {
                        var Command = arg.Args[1];
                        switch(Command)
                        {
                            case "mutechat":
                                {
                                    AdminSetting.MuteChatAll = true;
                                    foreach (var p in BasePlayer.activePlayerList)
                                        MuteAllChatPlayer(p);
                                    ReplyBroadcast(lang.GetMessage("FUNC_MESSAGE_MUTE_ALL_CHAT", this, player.UserIDString));
                                    break;
                                }
                            case "unmutechat":
                                {
                                    AdminSetting.MuteChatAll = false;
                                    foreach (var p in BasePlayer.activePlayerList)
                                        ChatSettingUser[p.userID].MuteChatTime = 0;
                                    ReplyBroadcast(lang.GetMessage("FUNC_MESSAGE_UNMUTE_ALL_CHAT", this, player.UserIDString));
                                    break;
                                }
                        }
                        break;
                    }
                    #endregion
            }
        }

        #endregion

        #endregion

        #region Lang
        private new void LoadDefaultMessages()
        {
            PrintWarning("Языковой файл загружается...");
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["TITLE_ONE"] = "<size=30><b>Chat SETTINGS</b></size>",
                ["TITLE_TWO"] = "<size=16><b>SELECT</b></size>",
                ["UI_CLOSE_BTN"] = "<size=20>CLOSE</size>",

                ["UI_TEXT_PREFIX"] = "<size=14>TAG</size>",
                ["UI_TEXT_COLOR_NICK"] = "<size=14>NICKNAME COLOR</size>",
                ["UI_TEXT_COLOR_MSG"] = "<size=14>TEXT COLOR</size>",
                ["UI_TEXT_RANK"] = "<size=23>RANKS</size>",
                ["UI_TEXT_VOTE_MENU"] = "<size=19>VOTED</size>",
                ["UI_TEXT_MUTE_MENU_BTN"] = "<size=14>MUTED PLAYERS</size>",

                ["UI_TEXT_ADMIN_PANEL"] = "<size=14><b>ADMIN PANEL</b></size>",
                ["UI_TEXT_MODER_PANEL"] = "<size=14><b>MOD PANEL</b></size>",
                ["UI_TEXT_ADMIN_PANEL_MUTE_CHAT_ALL"] = "<size=14>DISABLE CHAT</size>",
                ["UI_TEXT_ADMIN_PANEL_UNMUTE_CHAT_ALL"] = "<size=14>ENABLE CHAT</size>",
                ["UI_TEXT_ADMIN_PANEL_MUTE_VOICE_ALL"] = "<size=14>DISABLE VOICE</size>",
                ["UI_TEXT_ADMIN_PANEL_UNMUTE_VOICE_ALL"] = "<size=14>ENABLE VOICE</size>",

                ["UI_ALERT_TITLE"] = "<size=18><b>ATTENTION PLEASE</b></size>",

                ["UI_TITLE_NEW_PREFIX_ELEMENT"] = "<size=16><b>CHANGE TAG</b></size>",
                ["UI_TITLE_NEW_NICK_COLOR_ELEMENT"] = "<size=16><b>CHANGE NICKNAME COLOR</b></size>",
                ["UI_TITLE_NEW_MESSAGE_COLOR_ELEMENT"] = "<size=16><b>CHANGE TEXT COLOR</b></size>",
                ["UI_TITLE_NEW_MESSAGE_RANK_ELEMENT"] = "<size=16><b>CHANGER RANK</b></size>",

                ["FUNC_MESSAGE_MUTE_CHAT"] = "{0} muted {1} for {2}\nReason : {3}",
                ["FUNC_MESSAGE_UNMUTE_CHAT"] = "{0} unmuted {1}",
                ["FUNC_MESSAGE_MUTE_VOICE"] = "{0} muted voice to {1} for {2}\nReason : {3}",
                ["FUNC_MESSAGE_UNMUTE_VOICE"] = "{0} unmuted voice to {1}",
                ["FUNC_MESSAGE_MUTE_ALL_CHAT"] = "Chat disabled",
                ["FUNC_MESSAGE_UNMUTE_ALL_CHAT"] = "Chat enabled",
                ["FUNC_MESSAGE_MUTE_ALL_VOICE"] = "Voice chat disabled",
                ["FUNC_MESSAGE_UNMUTE_ALL_VOICE"] = "Voice chat enabled",

                ["FUNC_MESSAGE_ISMUTED_TRUE"] = "You can not send the messages {0}\nYou are muted",
                ["FUNC_MESSAGE_NO_ARG_BROADCAST"] = "You can not send an empty broadcast message!",

                ["UI_MUTE_PANEL_TITLE"] = "<size=20><b>MUTE PANEL</b></size>",
                ["UI_MUTE_PANEL_TITLE_ACTION"] = "<size=15>CHOOSE PLAYER OR SEARCH BY NICKNAME</size>",
                ["UI_MUTE_PANEL_TITLE_HELPS_LOCK"] = "<size=13><b>- PLAYER HAS DISABLED CHAT OR VOICECHAT</b></size>",
                ["UI_MUTE_PANEL_TITLE_HELPS_UNLOCK"] = "<size=13><b>- PLAYER HAS ENABLED CHAT OR VOICECHAT</b></size>",

                ["UI_MUTE_TAKE_ACTION_PANEL"] = "<size=18><b>SELECT\nACTION</b></size>",
                ["UI_MUTE_TAKE_ACTION_CHAT"] = "<size=12>MUTE\nCHAT</size>",
                ["UI_MUTE_TAKE_ACTION_CHAT_UNMUTE"] = "<size=12>UNMUTE\nCHAT</size>",
                ["UI_MUTE_TAKE_ACTION_VOICE"] = "<size=12>MUTE\nVOICE</size>",
                ["UI_MUTE_TAKE_ACTION_VOICE_UNMUTE"] = "<size=12>UNMUTE\nVOICE</size>",

                ["UI_MUTE_TAKE_REASON_TITLE"] = "<size=18><b>CHOOSE\nREASON</b></size>",

                ["COMMAND_NOT_PERMISSION"] = "You dont have permissions to use this command",
                ["COMMAND_RENAME_NOTARG"] = "For rename use : /rename New nickname",
                ["COMMAND_RENAME_SUCCES"] = "You have successful changed your name to {0}",

                ["COMMAND_PM_NOTARG"] = "To send pm use : /pm Nickname Message",
                ["COMMAND_PM_NOT_NULL_MSG"] = "Message is empty!",
                ["COMMAND_PM_NOT_USER"] = "User not found or offline",
                ["COMMAND_PM_SUCCESS"] = "Your private message sent successful\nMessage : {0}",
                ["COMMAND_PM_SEND_MSG"] = "Message from {0}\n{1}",

                ["COMMAND_R_NOTARG"] = "For reply use : /r Message",
                ["COMMAND_R_NOTMSG"] = "You dont have any private conversations yet!",

                ["FLOODERS_MESSAGE"] = "You're typing too fast! Please Wait {0} seconds",

                ["PREFIX_SETUP"] = "You have successfully removed the prefix {0}, it is already activated and installed",
                ["COLOR_CHAT_SETUP"] = "You have successfully picked up the <color={0}>chat color</color>, it is already activated and installed",
                ["COLOR_NICK_SETUP"] = "You have successfully taken the <color={0}>nickname color</color>, it is already activated and installed",

                ["PREFIX_RETURNRED"] = "Your prefix {0} expired, it was reset automatically",
                ["COLOR_CHAT_RETURNRED"] = "Action of your <color={0}>color chat</color> over, it is reset automatically",
                ["COLOR_NICK_RETURNRED"] = "Action of your <color={0}>color nick</color> over, it is reset automatically",

                ["WELCOME_PLAYER"] = "{0} came online",
                ["LEAVE_PLAYER"] = "{0} left",
                ["WELCOME_PLAYER_WORLD"] = "{0} came online. Country: {1}",
                ["LEAVE_PLAYER_REASON"] = "{0} left. Reason: {1}",

                ["IGNORE_ON_PLAYER"] = "You added {0} in black list",
                ["IGNORE_OFF_PLAYER"] = "You removed {0} from black list",
                ["IGNORE_NO_PM"] = "This player added you in black list. Your message has not been delivered.",
                ["IGNORE_NO_PM_ME"] = "You added this player in black list. Your message has not been delivered.",
                ["INGORE_NOTARG"] = "To ignore a player use : /ignore nickname",

                ["DISCORD_SEND_LOG_CHAT"] = "Player : {0}({1})\nFiltred message : {2}\nMessage : {3}",
                ["DISCORD_SEND_LOG_MUTE"] = "{0}({1}) give mute chat\nSuspect : {2}({3})\nReason : {4}",
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["TITLE_ONE"] = "<size=30><b>НАСТРОЙКА ЧАТА</b></size>",
                ["TITLE_TWO"] = "<size=16><b>ВЫБЕРИТЕ ДЕЙСТВИЕ</b></size>",
                ["UI_CLOSE_BTN"] = "<size=20>ЗАКРЫТЬ</size>",

                ["UI_TEXT_PREFIX"] = "<size=23>ПРЕФИКС</size>",
                ["UI_TEXT_COLOR_NICK"] = "<size=23>НИК</size>",
                ["UI_TEXT_COLOR_MSG"] = "<size=23>ТЕКСТ</size>",
                ["UI_TEXT_RANK"] = "<size=23>РАНГ</size>",
                ["UI_TEXT_MUTE_MENU_BTN"] = "<size=23>МУТЫ</size>",

                ["UI_TEXT_ADMIN_PANEL"] = "<size=17><b>ПАНЕЛЬ\nАДМИНИСТРАТОРА</b></size>",
                ["UI_TEXT_MODER_PANEL"] = "<size=17><b>ПАНЕЛЬ\nМОДЕРАТОРА</b></size>",
                ["UI_TEXT_ADMIN_PANEL_MUTE_CHAT_ALL"] = "<size=14>ВЫКЛЮЧИТЬ ЧАТ</size>",
                ["UI_TEXT_ADMIN_PANEL_UNMUTE_CHAT_ALL"] = "<size=14>ВКЛЮЧИТЬ ЧАТ</size>",
                ["UI_TEXT_ADMIN_PANEL_MUTE_VOICE_ALL"] = "<size=14>ВЫКЛЮЧИТЬ ГОЛОС</size>",
                ["UI_TEXT_ADMIN_PANEL_UNMUTE_VOICE_ALL"] = "<size=14>ВКЛЮЧИТЬ ГОЛОС</size>",

                ["UI_ALERT_TITLE"] = "<size=18><b>МИНУТОЧКУ ВНИМАНИЯ</b></size>",

                ["UI_TITLE_NEW_PREFIX_ELEMENT"] = "<size=16><b>ВЫБЕРИТЕ ПРЕФИКС</b></size>",
                ["UI_TITLE_NEW_NICK_COLOR_ELEMENT"] = "<size=16><b>ВЫБЕРИТЕ ЦВЕТ НИКА</b></size>",
                ["UI_TITLE_NEW_MESSAGE_COLOR_ELEMENT"] = "<size=16><b>ВЫБЕРИТЕ ЦВЕТ ТЕКСТА</b></size>",
                ["UI_TITLE_NEW_MESSAGE_RANK_ELEMENT"] = "<size=16><b>ВЫБЕРИТЕ СЕБЕ РАНГ</b></size>",

                ["FUNC_MESSAGE_MUTE_CHAT"] = "{0} заблокировал чат игроку {1} на {2}\nПричина : {3}",
                ["FUNC_MESSAGE_UNMUTE_CHAT"] = "{0} разблокировал чат игроку {1}",
                ["FUNC_MESSAGE_MUTE_VOICE"] = "{0} заблокировал голос игроку {1} на {2}\nПричина : {3}",
                ["FUNC_MESSAGE_UNMUTE_VOICE"] = "{0} разблокировал голос игроку {1}",
                ["FUNC_MESSAGE_MUTE_ALL_CHAT"] = "Всем игрокам был заблокирован чат",
                ["FUNC_MESSAGE_UNMUTE_ALL_CHAT"] = "Всем игрокам был разблокирован чат",
                ["FUNC_MESSAGE_MUTE_ALL_VOICE"] = "Всем игрокам был заблокирован голос",
                ["FUNC_MESSAGE_UNMUTE_ALL_VOICE"] = "Всем игрокам был разблокирован голос",

                ["FUNC_MESSAGE_ISMUTED_TRUE"] = "Вы не можете отправлять сообщения еще {0}\nВаш чат заблокирован",
                ["FUNC_MESSAGE_NO_ARG_BROADCAST"] = "Вы не можете отправлять пустое сообщение в оповещение!",

                ["UI_MUTE_PANEL_TITLE"] = "<size=20><b>ПАНЕЛЬ УПРАВЛЕНИЯ БЛОКИРОВКАМИ ЧАТА</b></size>",
                ["UI_MUTE_PANEL_TITLE_ACTION"] = "<size=15>ВЫБЕРИТЕ ИГРОКА ИЛИ ВВЕДИТЕ НИК В ПОИСКЕ</size>",
                ["UI_MUTE_PANEL_TITLE_HELPS_LOCK"] = "<size=13><b>- У ИГРОКА ЗАБЛОКИРОВАН ЧАТ ИЛИ ГОЛОС</b></size>",
                ["UI_MUTE_PANEL_TITLE_HELPS_UNLOCK"] = "<size=13><b>- У ИГРОКА РАЗБЛОКИРОВАН ЧАТ ИЛИ ГОЛОС</b></size>",

                ["UI_MUTE_TAKE_ACTION_PANEL"] = "<size=18><b>ВЫБЕРИТЕ\nДЕЙСТВИЕ</b></size>",
                ["UI_MUTE_TAKE_ACTION_CHAT"] = "<size=12>ЗАБЛОКИРОВАТЬ\nЧАТ</size>",
                ["UI_MUTE_TAKE_ACTION_CHAT_UNMUTE"] = "<size=12>РАЗБЛОКИРОВАТЬ\nЧАТ</size>",
                ["UI_MUTE_TAKE_ACTION_VOICE"] = "<size=12>ЗАБЛОКИРОВАТЬ\nГОЛОС</size>",
                ["UI_MUTE_TAKE_ACTION_VOICE_UNMUTE"] = "<size=12>РАЗБЛОКИРОВАТЬ\nГОЛОС</size>",

                ["UI_MUTE_TAKE_REASON_TITLE"] = "<size=18><b>ВЫБЕРИТЕ\nПРИЧИНУ</b></size>",

                ["COMMAND_NOT_PERMISSION"] = "У вас недостаточно прав для данной команды",
                ["COMMAND_RENAME_NOTARG"] = "Используйте команду так : /rename Новый Ник",
                ["COMMAND_RENAME_SUCCES"] = "Вы успешно изменили ник на {0}",

                ["COMMAND_PM_NOTARG"] = "Используйте команду так : /pm Ник Игрока Сообщение",
                ["COMMAND_PM_NOT_NULL_MSG"] = "Вы не можете отправлять пустое сообщение",
                ["COMMAND_PM_NOT_USER"] = "Игрок не найден или не в сети",
                ["COMMAND_PM_SUCCESS"] = "Ваше сообщение успешно доставлено\nСообщение : {0}",
                ["COMMAND_PM_SEND_MSG"] = "Сообщение от {0}\n{1}",

                ["COMMAND_R_NOTARG"] = "Используйте команду так : /r Сообщение",
                ["COMMAND_R_NOTMSG"] = "Вам или вы ещё не писали игроку в личные сообщения!",

                ["FLOODERS_MESSAGE"] = "Вы пишите слишком быстро! Подождите {0} секунд",

                ["PREFIX_SETUP"] = "Вы успешно забрали префикс {0}, он уже активирован и установлен",
                ["COLOR_CHAT_SETUP"] = "Вы успешно забрали <color={0}>цвет чата</color>, он уже активирован и установлен",
                ["COLOR_NICK_SETUP"] = "Вы успешно забрали <color={0}>цвет ника</color>, он уже активирован и установлен",

                ["PREFIX_RETURNRED"] = "Действие вашего префикса {0} окончено, он сброшен автоматически",
                ["COLOR_CHAT_RETURNRED"] = "Действие вашего <color={0}>цвета чата</color> окончено, он сброшен автоматически",
                ["COLOR_NICK_RETURNRED"] = "Действие вашего префикса <color={0}>цвет чата</color> окончено, он сброшен автоматически",

                ["WELCOME_PLAYER"] = "{0} зашел на сервер",
                ["LEAVE_PLAYER"] = "{0} вышел с сервера",
                ["WELCOME_PLAYER_WORLD"] = "{0} зашел на сервер.Из {1}",
                ["LEAVE_PLAYER_REASON"] = "{0} вышел с сервера.Причина {1}",

                ["IGNORE_ON_PLAYER"] = "Вы добавили игрока {0} в черный список",
                ["IGNORE_OFF_PLAYER"] = "Вы убрали игрока {0} из черного списка",
                ["IGNORE_NO_PM"] = "Данный игрок добавил вас в ЧС,ваше сообщение не будет доставлено",
                ["IGNORE_NO_PM_ME"] = "Вы добавили данного игрока в ЧС,ваше сообщение не будет доставлено",
                ["INGORE_NOTARG"] = "Используйте команду так : /ignore Ник Игрока",

                ["DISCORD_SEND_LOG_CHAT"] = "Игрок : {0}({1})\nФильтрованное сообщение : {2}\nИзначальное сообщение : {3}",
                ["DISCORD_SEND_LOG_MUTE"] = "{0}({1}) выдал блокировку чата\nИгрок : {2}({3})\nПричина : {4}",
            }, this, "ru");
           
            PrintWarning("Языковой файл загружен успешно");
        }
        #endregion

        #region Helpers
        public void Log(string LoggedMessage) => LogToFile("IQChatLogs", LoggedMessage, this);
        public static string FormatTime(TimeSpan time)
        {
            string result = string.Empty;
            if (time.Days != 0)
                result += $"{Format(time.Days, "дней", "дня", "день")} ";

            if (time.Hours != 0)
                result += $"{Format(time.Hours, "часов", "часа", "час")} ";

            if (time.Minutes != 0)
                result += $"{Format(time.Minutes, "минут", "минуты", "минут")} ";

            if (time.Seconds != 0)
                result += $"{Format(time.Seconds, "секунд", "секунды", "секунда")} ";

            return result;
        }
        private static string Format(int units, string form1, string form2, string form3)
        {
            var tmp = units % 10;

            if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                return $"{units} {form1}";

            if (tmp >= 2 && tmp <= 4)
                return $"{units} {form2}";

            return $"{units} {form3}";
        }
        private BasePlayer FindPlayer(string nameOrId)
        {
            foreach (var check in BasePlayer.activePlayerList.Where(x => x.displayName.ToLower().Contains(nameOrId.ToLower()) || x.UserIDString == nameOrId))
                return check;
            return null;
        }
        private static string HexToRustFormat(string hex)
        {
            Color color;
            ColorUtility.TryParseHtmlString(hex, out color);
            sb.Clear();
            return sb.AppendFormat("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a).ToString();
        }
        #endregion

        #region ChatFunc

        public Dictionary<ulong, double> Flooders = new Dictionary<ulong, double>();
        void ReplyChat(Chat.ChatChannel channel, BasePlayer player, string OutMessage)
        {
            var MessageSetting = config.MessageSetting;
            if (MessageSetting.AntiSpamActivate)
                if (!permission.UserHasPermission(player.UserIDString, MessageSetting.PermAdminImmunitetAntispam))
                {
                    if (!Flooders.ContainsKey(player.userID))
                        Flooders.Add(player.userID, CurrentTime() + MessageSetting.FloodTime);
                    else
                        if (Flooders[player.userID] > CurrentTime())
                        {
                            ReplySystem(Chat.ChatChannel.Global, player, GetLang("FLOODERS_MESSAGE", player.UserIDString, Convert.ToInt32(Flooders[player.userID] - CurrentTime())));
                            return;
                        }

                    Flooders[player.userID] = MessageSetting.FloodTime + CurrentTime();
                }

            if (channel == Chat.ChatChannel.Global)
            {
                foreach (BasePlayer p in BasePlayer.activePlayerList)
                {
                    p.SendConsoleCommand("chat.add", new object[] { (int)channel, player.userID, OutMessage });
                }
                PrintToConsole(OutMessage);
            }
            if (channel == Chat.ChatChannel.Team)
            {
                RelationshipManager.PlayerTeam Team = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);
                if (Team == null) return;
                foreach (var FindPlayers in Team.members)
                {
                    BasePlayer TeamPlayer = BasePlayer.FindByID(FindPlayers);
                    if (TeamPlayer == null) continue;

                    TeamPlayer.SendConsoleCommand("chat.add", channel, player.userID, OutMessage);
                }
            }
        }

        void ReplySystem(Chat.ChatChannel channel, BasePlayer player, string Message,string CustomPrefix = "", string CustomAvatar = "", string CustomHex = "")
        {
            string Prefix = string.IsNullOrEmpty(CustomPrefix) ? config.MessageSetting.BroadcastTitle : CustomPrefix;
            ulong Avatar = string.IsNullOrEmpty(CustomAvatar) ? config.MessageSetting.Steam64IDAvatar : ulong.Parse(CustomAvatar);
            string Hex = string.IsNullOrEmpty(CustomHex) ? config.MessageSetting.BroadcastColor : CustomHex;

            string FormatMessage = $"{Prefix}<color={Hex}>{Message}</color>";
            if (channel == Chat.ChatChannel.Global)
                player.SendConsoleCommand("chat.add", channel, Avatar, FormatMessage);         
        }

        void ReplyBroadcast(string Message, string CustomPrefix = "", string CustomAvatar = "")
        {
            foreach(var p in BasePlayer.activePlayerList)
                ReplySystem(Chat.ChatChannel.Global, p, Message, CustomPrefix, CustomAvatar);
        }

        static DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        static double CurrentTime() => DateTime.UtcNow.Subtract(epoch).TotalSeconds;

        #endregion

        #region API

        void API_SEND_PLAYER(BasePlayer player,string PlayerFormat, string Message, string Avatar, Chat.ChatChannel channel = Chat.ChatChannel.Global)
        {
            var MessageSettings = config.MessageSetting;
            string OutMessage = Message;

            if (MessageSettings.FormatingMessage)
                OutMessage = $"{Message.ToLower().Substring(0, 1).ToUpper()}{Message.Remove(0, 1).ToLower()}";

            if (MessageSettings.UseBadWords)
                foreach (var DetectedMessage in OutMessage.Split(' '))
                    if (MessageSettings.BadWords.Contains(DetectedMessage.ToLower()))
                        OutMessage = OutMessage.Replace(DetectedMessage, MessageSettings.ReplaceBadWord);

            player.SendConsoleCommand("chat.add", channel, ulong.Parse(Avatar), $"{PlayerFormat}: {OutMessage}");
        }
        void API_SEND_PLAYER_PM(BasePlayer player, string DisplayName, string Message)
        {
            ReplySystem(Chat.ChatChannel.Global, player, GetLang("COMMAND_PM_SEND_MSG", player.UserIDString, DisplayName, Message));
            Effect.server.Run(config.MessageSetting.SoundPM, player.GetNetworkPosition());
        }
        void API_SEND_PLAYER_CONNECTED(BasePlayer player, string DisplayName, string country, string userID)
        {
            var Alert = config.AlertSettings;
            if (Alert.ConnectedAlert)
            {
                string Avatar = Alert.ConnectedAvatarUse ? userID : "";
                if (config.AlertSettings.ConnectedWorld)
                     ReplyBroadcast(GetLang("WELCOME_PLAYER_WORLD", player.UserIDString, DisplayName, country), "", Avatar);   
                else ReplyBroadcast(GetLang("WELCOME_PLAYER", player.UserIDString, DisplayName), "", Avatar);
            }
        }
        void API_SEND_PLAYER_DISCONNECTED(BasePlayer player, string DisplayName, string reason, string userID)
        {
            var Alert = config.AlertSettings;
            if (Alert.DisconnectedAlert)
            {
                string Avatar = Alert.ConnectedAvatarUse ? userID : "";
                string LangLeave = config.AlertSettings.DisconnectedReason ? GetLang("LEAVE_PLAYER_REASON",player.UserIDString, DisplayName, reason) : GetLang("LEAVE_PLAYER", player.UserIDString, DisplayName);
                ReplyBroadcast(LangLeave, "", Avatar);
            }
        }
        void API_ALERT(string Message, Chat.ChatChannel channel = Chat.ChatChannel.Global, string CustomPrefix = "", string CustomAvatar = "", string CustomHex = "")
        {
            foreach (var p in BasePlayer.activePlayerList)
                ReplySystem(channel, p, Message, CustomPrefix, CustomAvatar, CustomHex);
        }
        void API_ALERT_PLAYER(BasePlayer player,string Message, string CustomPrefix = "", string CustomAvatar = "", string CustomHex = "") => ReplySystem(Chat.ChatChannel.Global, player, Message, CustomPrefix, CustomAvatar, CustomHex);
        void API_ALERT_PLAYER_UI(BasePlayer player, string Message) => UIAlert(player, Message);
        bool API_CHECK_MUTE_CHAT(ulong ID)
        {
            var DataPlayer = ChatSettingUser[ID];
            if (DataPlayer.MuteChatTime > CurrentTime())
                return true;
            else return false;
        }
        bool API_CHECK_VOICE_CHAT(ulong ID)
        {
            var DataPlayer = ChatSettingUser[ID];
            if (DataPlayer.MuteVoiceTime > CurrentTime())
                return true;
            else return false;
        }
        string API_GET_PREFIX(ulong ID)
        {
            var DataPlayer = ChatSettingUser[ID];
            return DataPlayer.ChatPrefix;
        }
        string API_GET_CHAT_COLOR(ulong ID)
        {
            var DataPlayer = ChatSettingUser[ID];
            return DataPlayer.MessageColor;
        }
        string API_GET_NICK_COLOR(ulong ID)
        {
            var DataPlayer = ChatSettingUser[ID];
            return DataPlayer.NickColor;
        }
        string API_GET_DEFUALT_PRFIX() => (string)config.AutoSetupSetting.ReturnDefaultSetting.PrefixDefault;
        string API_GET_DEFUALT_COLOR_NICK() => (string)config.AutoSetupSetting.ReturnDefaultSetting.NickDefault;
        string API_GET_DEFUALT_COLOR_CHAT() => (string)config.AutoSetupSetting.ReturnDefaultSetting.MessageDefault;
        #endregion
    }
}


// --- End of file: IQChat.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/InstantCraft.cs ---
// --- Original Local Path: TrashRust/InstantCraft.cs ---

using Newtonsoft.Json;
using System.Collections.Generic;
using Oxide.Core;

namespace Oxide.Plugins
{
    /*ПЛАГИН БЫЛ ПОФИКШЕН С ПОМОЩЬЮ ПРОГРАММЫ СКАЧАНОЙ С https://discord.gg/dNGbxafuJn */ [Info("Instant Craft", "https://discord.gg/dNGbxafuJn", "2.1.5")]
    [Description("Allows players to instantly craft items with features")]
    public class InstantCraft : RustPlugin
    {
        #region Vars

        private const string permUse = "instantcraft.use";

        #endregion
        
        #region Oxide Hooks

        private void Init()
        {
            permission.RegisterPermission(permUse, this);
        }
        
        private object OnItemCraft(ItemCraftTask item, BasePlayer player, Item item1)
        {
            return OnCraft(item, player);
        }

        #endregion

        #region Core

        private object OnCraft(ItemCraftTask task, BasePlayer player)
        {
            if (task.cancelled == true)
            {
                return null;
            }
            
            var target = task.blueprint.targetItem;
            var targetName = target.shortname;

            if (targetName.Contains("key"))
            {
                return null;
            }
            
            if (permission.UserHasPermission(player.UserIDString, permUse) == false)
            {
                return null;
            }

            if (IsBlocked(targetName))
            {
                task.cancelled = true;
                Message(player, "Blocked");
                GiveRefund(player, task.takenItems);
                return null;
            }

            var stacks = GetStacks(target, task.amount * task.blueprint.amountToCreate);
            var slots = FreeSlots(player);

            if (HasPlace(slots, stacks) == false)
            {
                task.cancelled = true;
                Message(player, "Slots", stacks.Count, slots);
                GiveRefund(player, task.takenItems);
                return null;
            }
            
            if (IsNormalItem(targetName))
            {
                Message(player, "Normal");
                return null;
            }
            
            GiveItem(player, task, target, stacks, task.skinID);
            task.cancelled = true;
            return null;
        }

        private void GiveItem(BasePlayer player, ItemCraftTask task, ItemDefinition def, List<int> stacks, int taskSkinID)
        {
            var skin = ItemDefinition.FindSkin(def.itemid, taskSkinID);
            
            if (config.split == false)
            {
                var final = 0;

                foreach (var stack in stacks)
                {
                    final += stack;
                }
                
                var item = ItemManager.Create(def, final, skin);
                player.GiveItem(item);
                Interface.CallHook("OnItemCraftFinished", task, item);
            }
            else
            {
                foreach (var stack in stacks)
                {
                    var item = ItemManager.Create(def, stack, skin);
                    player.GiveItem(item);
                    Interface.CallHook("OnItemCraftFinished", task, item);
                }
            }
        }

        private int FreeSlots(BasePlayer player)
        {
            var slots = player.inventory.containerMain.capacity + player.inventory.containerBelt.capacity;
            var taken = player.inventory.containerMain.itemList.Count + player.inventory.containerBelt.itemList.Count;
            return slots - taken;
        }

        private void GiveRefund(BasePlayer player, List<Item> items)
        {
            foreach (var item in items)
            {
                player.GiveItem(item);
            }
        }

        private List<int> GetStacks(ItemDefinition item, int amount) 
        {
            var list = new List<int>();
            var maxStack = item.stackable;

            if (maxStack == 0)
            {
                maxStack = 1;
            }

            while (amount > maxStack)
            {
                amount -= maxStack;
                list.Add(maxStack);
            }
            
            list.Add(amount);
            
            return list; 
        }

        private bool IsNormalItem(string name)
        {
            return config.normal?.Contains(name) ?? false;
        }

        private bool IsBlocked(string name)
        {
            return config.blocked?.Contains(name) ?? false;
        }

        private bool HasPlace(int slots, List<int> stacks)
        {
            if (config.checkPlace == false)
            {
                return true;
            }

            if (config.split && slots - stacks.Count < 0)
            {
                return false;
            }

            return slots > 0;
        }

        #endregion

        #region Localization 1.1.1
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Blocked", "Crafting of that item is blocked!"},
                {"Slots", "You don't have enough place to craft! Need {0}, have {1}!"},
                {"Normal", "Item will be crafted with normal speed."}
            }, this);
        }

        private void Message(BasePlayer player, string messageKey, params object[] args)
        {
            if (player == null)
            {
                return;
            }

            var message = GetMessage(messageKey, player.UserIDString, args);
            player.ChatMessage(message);
        }

        private string GetMessage(string messageKey, string playerID, params object[] args)
        {
            return string.Format(lang.GetMessage(messageKey, this, playerID), args);
        }

        #endregion
        
        #region Configuration 1.1.0

        private static ConfigData config;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Check for free place")]
            public bool checkPlace = false;
            
            [JsonProperty(PropertyName = "Split crafted stacks")]
            public bool split = false;
            
            [JsonProperty(PropertyName = "Normal Speed")]
            public string[] normal =
            {
                "hammer",
                "put item shortname here"
            };

            [JsonProperty(PropertyName = "Blacklist")]
            public string[] blocked =
            {
                "rock",
                "put item shortname here"
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();

                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                PrintError("Configuration file is corrupt! Unloading plugin...");
                Interface.Oxide.RootPluginManager.RemovePlugin(this);
                return;
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            config = new ConfigData();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
    }
}

// --- End of file: InstantCraft.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/NoEscape.cs ---
// --- Original Local Path: TrashRust/NoEscape.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("NoEscape", "OxideBro", "2.3.2")]
    public class NoEscape : RustPlugin
    {
        #region Class
        private static List<SphereComponent> BlockerList = new List<SphereComponent>();

        private class PlayerBlockStatus : FacepunchBehaviour
        {
            private BasePlayer Player;
            public SphereComponent CurrentBlocker;
            public double CurrentTime = config.BlockSettings.BlockLength;

            public static PlayerBlockStatus Get(BasePlayer player)
            {
                return player.GetComponent<PlayerBlockStatus>() ?? player.gameObject.AddComponent<PlayerBlockStatus>();
            }

            private void Awake()
            {
                Player = GetComponent<BasePlayer>();
            }

            private void ControllerUpdate()
            {
                if (CurrentBlocker != null)
                    UpdateUI();
                else
                    UnblockPlayer();
            }

            public void CreateUI()
            {
                CuiHelper.DestroyUi(Player, "NoEscape");
                CuiElementContainer container = new CuiElementContainer();
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = config.UISettings.AnchorMin, AnchorMax = config.UISettings.AnchorMax, OffsetMax = "0 0" },
                    Image = { Color = config.UISettings.InterfaceColorBP }
                }, "Hud", "NoEscape");
                CuiHelper.AddUi(Player, container);
                if (CurrentBlocker != null) UpdateUI();
            }

            public void BlockPlayer(SphereComponent blocker, bool justCreated)
            {
                if (ins.permission.UserHasPermission(Player.UserIDString, config.BlockSettings.PermissionToIgnore))
                {
                    UnblockPlayer();
                    return;
                }
                if (justCreated)
                    Player.ChatMessage(string.Format(ins.Messages["blockactiveAttacker"], NumericalFormatter.FormatTime(config.BlockSettings.BlockLength)));
                CurrentBlocker = blocker;
                CurrentTime = CurrentBlocker.CurrentTime;
                CreateUI();
                InvokeRepeating(ControllerUpdate, 1f, 1f);
            }

            public void UpdateUI()
            {
                CurrentTime++;
                CuiHelper.DestroyUi(Player, "NoEscape_update");
                CuiHelper.DestroyUi(Player, "NoEscape" + ".Info");

                CuiElementContainer container = new CuiElementContainer();
                container.Add(new CuiElement
                {
                    Parent = "NoEscape",
                    Name = "NoEscape_update",
                    Components =
                    {
                        new CuiImageComponent { Color = config.UISettings.InterfaceColor },
                        new CuiRectTransformComponent {AnchorMin = $"0 0", AnchorMax = $"{(float) (CurrentBlocker.TotalTime - CurrentBlocker.CurrentTime) / CurrentBlocker.TotalTime} 1", OffsetMin = "0 0", OffsetMax = "0 0"},
                    }
                });
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Text = { Text = string.Format(ins.Messages["guitimertext"], ins.GetFormatTime(TimeSpan.FromSeconds(CurrentBlocker.TotalTime - CurrentBlocker.CurrentTime))), Font = "robotocondensed-regular.ttf", Color = "1 1 1 0.9", FontSize = 8, Align = TextAnchor.MiddleCenter }
                }, "NoEscape", "NoEscape" + ".Info");

                CuiHelper.AddUi(Player, container);
                if (CurrentTime >= config.BlockSettings.BlockLength)
                    UnblockPlayer();
            }

            public void UnblockPlayer()
            {
                if (Player == null)
                {
                    Destroy(this);
                    return;
                }
                Player.ChatMessage(ins.Messages["blocksuccess"]);
                CancelInvoke(ControllerUpdate);
                CuiHelper.DestroyUi(Player, "NoEscape");
                CurrentBlocker = null;
            }
            private void OnDestroy()
            {
                CuiHelper.DestroyUi(Player, "NoEscape");
                Destroy(this);
            }
        }

        public class SphereComponent : FacepunchBehaviour
        {
            SphereCollider sphereCollider;
            public BasePlayer initPlayer;
            public List<ulong> Privilage = null;
            public ulong OwnerID;
            public double CurrentTime = 0;
            public double TotalTime = config.BlockSettings.BlockLength;
            void Awake()
            {
                var reply = 288;
                if (reply == 0) { }
                gameObject.layer = (int)Layer.Reserved1;
                sphereCollider = gameObject.AddComponent<SphereCollider>();
                sphereCollider.isTrigger = true;
                sphereCollider.radius = config.BlockSettings.BlockerDistance;
            }

            public void Init(BasePlayer player, ulong owner, List<ulong> privilage)
            {
                initPlayer = player;
                OwnerID = owner;
                Privilage = privilage;
            }

            private void OnTriggerEnter(Collider other)
            {
                var target = other.GetComponentInParent<BasePlayer>();
                if (target == null) return;

                if (PlayerBlockStatus.Get(target).CurrentBlocker != null && PlayerBlockStatus.Get(target).CurrentBlocker == this && PlayerBlockStatus.Get(target).CurrentTime > CurrentTime)
                {
                    PlayerBlockStatus.Get(target).CurrentTime = CurrentTime;
                    return;
                }
                if (PlayerBlockStatus.Get(target).CurrentBlocker != null && PlayerBlockStatus.Get(target).CurrentBlocker != this && PlayerBlockStatus.Get(target).CurrentTime > CurrentTime)
                {
                    target.ChatMessage(string.Format(ins.Messages["enterRaidZone"], NumericalFormatter.FormatTime(config.BlockSettings.BlockLength - CurrentTime)));
                    PlayerBlockStatus.Get(target).CurrentTime = CurrentTime;
                    PlayerBlockStatus.Get(target).CurrentBlocker = this;
                    return;
                }
                if (config.BlockSettings.ShouldBlockEnter && (PlayerBlockStatus.Get(target).CurrentBlocker == null || PlayerBlockStatus.Get(target).CurrentBlocker != this))
                {
                    PlayerBlockStatus.Get(target).BlockPlayer(this, false);
                    target.ChatMessage(string.Format(ins.Messages["enterRaidZone"], NumericalFormatter.FormatTime(config.BlockSettings.BlockLength - CurrentTime)));
                    return;
                }
            }

            private void OnTriggerExit(Collider other)
            {
                if (!config.BlockSettings.UnBlockExit) return;
                var target = other.GetComponentInParent<BasePlayer>();
                if (target != null && target.userID.IsSteamId() && PlayerBlockStatus.Get(target).CurrentBlocker == this)
                    PlayerBlockStatus.Get(target).UnblockPlayer();
            }

            public void FixedUpdate()
            {
                CurrentTime += Time.deltaTime;
                if (CurrentTime > TotalTime)
                {
                    if (BlockerList.Contains(this))
                        BlockerList.Remove(this);
                    Destroy(this);
                }
            }

            public void OnDestroy()
            {
                Destroy(this);
            }

            public bool IsInBlocker(BaseEntity player) => Vector3.Distance(player.transform.position, transform.position) < config.BlockSettings.BlockerDistance;
        }
        #endregion

        #region Variables

        static PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Благодарим за покупку плагина на сайте RustPlugin.ru. Если вы передадите этот плагин сторонним лицам знайте - это лишает вас гарантированных обновлений!");
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();

            if (config.PluginVersion < Version)
                UpdateConfigValues();

            Config.WriteObject(config, true);
        }

        void Loaded()
        {
            if (!config.PlayerBlockSettings.CanRepair) Unsubscribe(nameof(OnStructureRepair));
            else Subscribe(nameof(OnStructureRepair));
            if (!config.PlayerBlockSettings.CanUpgrade) Unsubscribe(nameof(CanAffordUpgrade));
            else Subscribe(nameof(CanAffordUpgrade));
            if (!config.PlayerBlockSettings.CanDefaultremove) Unsubscribe(nameof(OnStructureDemolish));
            else Subscribe(nameof(OnStructureDemolish));
            if (!config.PlayerBlockSettings.CanBuild && !config.PlayerBlockSettings.CanPlaceObjects) Unsubscribe(nameof(CanBuild));
            else Subscribe(nameof(CanBuild));
            permission.RegisterPermission(config.BlockSettings.PermissionToIgnore, this);
            permission.RegisterPermission(config.VkBotMessages.VkPrivilage, this);
            lang.RegisterMessages(Messages, this, "en");
            Messages = lang.GetMessages("en", this);
        }

        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (config.PluginVersion < Version)
            {
                PrintWarning("Config update detected! Updating config values...");

                if (config.PluginVersion < new VersionNumber(2, 2, 0))
                {
                    config.BlockSettings.WriteListDestroyEntity = new List<string>()
                    {
                        "barricade.metal",
                         "bed_deployed"
                    };
                    PrintWarning("Added Write List entity");
                }
                if (config.PluginVersion < new VersionNumber(2, 3, 1))
                {
                    config.PlayerBlockSettings.BlackListCommands = new List<string>()
                    {
                        "/bp",
                        "backpack.open",
                        "/trade"
                    };

                    PrintWarning("Added Black List commands");
                }
                PrintWarning("Config update completed!");
                config.PluginVersion = Version;
            }
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        public class UISettings
        {
            [JsonProperty("Цвет полосы активный полосы")]
            public string InterfaceColor = "0.121568628 0.419607848 0.627451 0.784313738";

            [JsonProperty("Цвет фона")]
            public string InterfaceColorBP = "1 1 1 0.3";

            [JsonProperty("Позиция AnchorMin")]
            public string AnchorMin = "0.3447913 0.112037";

            [JsonProperty("Позиция AnchorMax")]
            public string AnchorMax = "0.640625 0.1398148";
        }

        public class BlockSettings
        {
            [JsonProperty("Радиус зоны блокировки")]
            public float BlockerDistance = 150;

            [JsonProperty("Общее время блокировки в секундах")]
            public float BlockLength = 150;

            [JsonProperty("Блокировать создателя объекта какой разрушили, даже если он вне зоны рейда")]
            public bool BlockOwnersIfNotInZone = true;

            [JsonProperty("Блокировать игрока, который вошёл в активную зону блокировки")]
            public bool ShouldBlockEnter = true;

            [JsonProperty("Снимать блокировку с игрока если он вышел из зоны блокировки?")]
            public bool UnBlockExit = false;

            [JsonProperty("Не создавать блокировку если разрушенный объект не в зоне шкафа (Нету билды)")]
            public bool EnabledBuildingBlock = false;

            [JsonProperty("Блокировать всех игроков какие авторизаваны в шкафу (Если шкаф существует, и авторизованный игрок на сервере)")]
            public bool EnabledBlockAutCupboard = false;

            [JsonProperty("Привилегия, игроки с которой игнорируются РБ (на них он не действует")]
            public string PermissionToIgnore = "noescape.ignore";

            [JsonProperty("Белый список entity при разрушении каких не действует блокировка")]
            public List<string> WriteListDestroyEntity = new List<string>();
        }

        public class VkBotMessages
        {
            [JsonProperty("Включить отправку сообщения в ВК оффлайн игроку через VkBot")]
            public bool EnabledVkBOT = false;
            [JsonProperty("Сообщение какое будет отправлено игроку ({0} - Имя атакуещего, {1} - Квадрат на карте)")]
            public string Messages = "Внимание! Игрок {0} начал рейд вашего строения в квадрате {1} на сервере SERVERNAME.";
            [JsonProperty("Привилегия на использование оффлайн уведомления")]
            public string VkPrivilage = "noescape.vknotification";
        }

        public class PlayerBlockSettings
        {
            [JsonProperty("Блокировать использование китов")]
            public bool CanUseKits = true;

            [JsonProperty("Блокировать обмен между игроками (Trade)")]
            public bool CanUseTrade = true;

            [JsonProperty("Блокировать телепорты")]
            public bool CanTeleport = true;

            [JsonProperty("Блокировать удаление построек (CanRemove)")]
            public bool CanRemove = true;

            [JsonProperty("Блокировать улучшение построек (Upgrade, BuildingUpgrade и прочее)")]
            public bool CanBGrade = true;

            [JsonProperty("Блокировать удаление построек (стандартное)")]
            public bool CanDefaultremove = true;

            [JsonProperty("Блокировать строительство")]
            public bool CanBuild = true;

            [JsonProperty("Блокировать установку объектов")]
            public bool CanPlaceObjects = true;

            [JsonProperty("Блокировать ремонт построек (стандартный)")]
            public bool CanRepair = true;

            [JsonProperty("Блокировать улучшение построек (стандартное)")]
            public bool CanUpgrade = true;

            [JsonProperty("Белый список предметов какие можно строить при блокировке")]
            public List<string> WriteListBuildEntity = new List<string>();

            [JsonProperty("Черный список команд какие запрещены при рейд блоке (Чатовые и консольные)")]
            public List<string> BlackListCommands = new List<string>();

        }

        private class PluginConfig
        {
            [JsonProperty("Настройка UI")]
            public UISettings UISettings = new UISettings();

            [JsonProperty("Общая настройка блокировки")]
            public BlockSettings BlockSettings = new BlockSettings();

            [JsonProperty("Настройка запретов для игрока")]
            public PlayerBlockSettings PlayerBlockSettings = new PlayerBlockSettings();

            [JsonProperty("Настройка VkBOT")]
            public VkBotMessages VkBotMessages = new VkBotMessages();

            [JsonProperty("Версия конфигурации")]
            public VersionNumber PluginVersion = new VersionNumber();

            [JsonIgnore]
            [JsonProperty("Инициализация плагина")]
            public bool Init = false;

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig
                {
                    BlockSettings = new BlockSettings()
                    {
                        BlockerDistance = 150,
                        BlockLength = 150,
                        BlockOwnersIfNotInZone = true,
                        ShouldBlockEnter = true,
                        UnBlockExit = false,
                        EnabledBuildingBlock = false,
                        EnabledBlockAutCupboard = false,
                        PermissionToIgnore = "noescape.ignore",
                        WriteListDestroyEntity = new List<string>()
                        {
                            "barricade.metal",
                            "bed_deployed"
                        }
                    },
                    PlayerBlockSettings = new PlayerBlockSettings()
                    {
                        CanUseKits = true,
                        CanUseTrade = true,
                        CanTeleport = true,
                        CanRemove = true,
                        CanBGrade = true,
                        CanDefaultremove = true,
                        CanBuild = true,
                        CanPlaceObjects = true,
                        CanRepair = true,
                        CanUpgrade = true,
                        WriteListBuildEntity = new List<string>()
                        {
                             "wall.external.high.stone",
                             "barricade.metal"
                        }
                    },
                    UISettings = new UISettings()
                    {
                        InterfaceColor = "0.12 0.41 0.62 0.78",
                        InterfaceColorBP = "1 1 1 0.3",
                        AnchorMin = "0.3447913 0.112037",
                        AnchorMax = "0.640625 0.1398148",
                    },
                    VkBotMessages = new VkBotMessages()
                    {
                        EnabledVkBOT = false,
                        Messages = "Внимание! Игрок {0} начал рейд вашего строения в квадрате {1} на сервере SERVERNAME.",
                        VkPrivilage = "noescape.vknotification",
                    },
                    PluginVersion = new VersionNumber(),
                };
            }
        }

        #endregion

        #region Oxide⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        private static NoEscape ins;
        private void OnServerInitialized()
        {
            ins = this;
            config.Init = true;
            BasePlayer.activePlayerList.ToList().ForEach(OnPlayerConnected);
        }

        void OnPlayerSleepEnded(BasePlayer player)
        {
            SphereComponent ActiveRaidZone = GetRaidZone(player.transform.position);
            if (ActiveRaidZone == null)
            {
                if (config.BlockSettings.UnBlockExit)
                {
                    if (PlayerBlockStatus.Get(player).CurrentBlocker != null)
                        PlayerBlockStatus.Get(player).UnblockPlayer();
                }
                return;
            }

            if (PlayerBlockStatus.Get(player).CurrentBlocker != null)
            {

                if (PlayerBlockStatus.Get(player).CurrentBlocker != ActiveRaidZone)
                    PlayerBlockStatus.Get(player).BlockPlayer(ActiveRaidZone, false);
            }
            else
            {
                player.ChatMessage(string.Format(Messages["enterRaidZone"], NumericalFormatter.FormatTime(config.BlockSettings.BlockLength - ActiveRaidZone.CurrentTime)));
                PlayerBlockStatus.Get(player)?.BlockPlayer(ActiveRaidZone, false);
            }
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player.IsReceivingSnapshot)
            {
                timer.In(1f, () => OnPlayerConnected(player));
                return;
            }
            if (PlayerBlockStatus.Get(player).CurrentBlocker != null)
                PlayerBlockStatus.Get(player).CreateUI();
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
                if (PlayerBlockStatus.Get(player) != null)
                    UnityEngine.Object.Destroy(PlayerBlockStatus.Get(player));
            BlockerList.RemoveAll(x =>
            {
                UnityEngine.Object.Destroy(x);
                return true;
            });
        }

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (!config.Init) return;
            if (entity == null || info == null || info.InitiatorPlayer == null || !(entity is StabilityEntity || entity is ShopFront || entity is BuildingPrivlidge)
                || config.BlockSettings.EnabledBuildingBlock && entity.GetBuildingPrivilege() == null || entity.OwnerID == 0) return;
            if (entity is BuildingBlock && (entity as BuildingBlock).currentGrade.gradeBase.type == BuildingGrade.Enum.Twigs
                || info?.damageTypes.GetMajorityDamageType() == DamageType.Decay || config.BlockSettings.WriteListDestroyEntity.Contains(entity.ShortPrefabName)) return;
            var alreadyBlock = BlockerList.FirstOrDefault(p => Vector3.Distance(entity.transform.position, p.transform.position) < (config.BlockSettings.BlockerDistance / 2));
            if (alreadyBlock)
            {
                alreadyBlock.CurrentTime = 0;
                if (config.BlockSettings.BlockOwnersIfNotInZone)
                {
                    var OwnerPlayer = BasePlayer.FindByID(entity.OwnerID);
                    if (OwnerPlayer != null)
                        PlayerBlockStatus.Get(OwnerPlayer).BlockPlayer(alreadyBlock, false);
                }
                PlayerBlockStatus.Get(info.InitiatorPlayer).BlockPlayer(alreadyBlock, false);
                if (entity.GetBuildingPrivilege() != null && config.BlockSettings.EnabledBlockAutCupboard)
                {
                    foreach (var aplayer in entity.GetBuildingPrivilege().authorizedPlayers)
                    {
                        var AuthPlayer = BasePlayer.Find(aplayer.userid.ToString());
                        if (AuthPlayer != null && AuthPlayer != info.InitiatorPlayer && AuthPlayer.IsConnected)
                            PlayerBlockStatus.Get(AuthPlayer).BlockPlayer(alreadyBlock, false);
                        else if (AuthPlayer == null || !AuthPlayer.IsConnected) SendOfflineMessages(entity.transform.position, info.InitiatorPlayer.displayName, aplayer.userid);
                    }
                }
                var col = Vis.colBuffer;
                var count = Physics.OverlapSphereNonAlloc(alreadyBlock.transform.position, config.BlockSettings.BlockerDistance, col, LayerMask.GetMask("Player (Server)"));
                for (int i = 0; i < count; i++)
                {
                    var player = col[i].ToBaseEntity() as BasePlayer;
                    if (player == null) continue;
                    PlayerBlockStatus.Get(player).BlockPlayer(alreadyBlock, false);
                }
            }
            else
            {
                var obj = new GameObject();
                obj.transform.position = entity.transform.position;
                var sphere = obj.AddComponent<SphereComponent>();
                sphere.GetComponent<SphereComponent>().Init(info.InitiatorPlayer, entity.OwnerID, entity.GetBuildingPrivilege() != null ? entity.GetBuildingPrivilege().authorizedPlayers.Select(p => p.userid).ToList() : null);
                BlockerList.Add(sphere);
                PlayerBlockStatus.Get(info.InitiatorPlayer).BlockPlayer(sphere, true);
                var OwnerPlayer = BasePlayer.FindByID(entity.OwnerID);
                if (OwnerPlayer == null || !OwnerPlayer.IsConnected)
                {
                    SendOfflineMessages(entity.transform.position, info.InitiatorPlayer.displayName, entity.OwnerID);
                    return;
                }
                else if (OwnerPlayer != null && OwnerPlayer != info.InitiatorPlayer)
                {
                    if (config.BlockSettings.BlockOwnersIfNotInZone)
                    {
                        PlayerBlockStatus.Get(OwnerPlayer)?.BlockPlayer(sphere, false);
                        if (OwnerPlayer != info?.InitiatorPlayer) OwnerPlayer.ChatMessage(string.Format(Messages["blockactive"], GetGridString(entity.transform.position), NumericalFormatter.FormatTime(config.BlockSettings.BlockLength)));
                    }
                    else
                        OwnerPlayer.ChatMessage(string.Format(Messages["blockactiveOwner"], GetGridString(entity.transform.position)));
                }
                var col = Vis.colBuffer;
                var count = Physics.OverlapSphereNonAlloc(sphere.transform.position, config.BlockSettings.BlockerDistance, col, LayerMask.GetMask("Player (Server)"));
                for (int i = 0; i < count; i++)
                {
                    var player = col[i].ToBaseEntity() as BasePlayer;
                    if (player == null || !player.IsConnected) continue;
                    PlayerBlockStatus.Get(player).BlockPlayer(sphere, false);
                }

                if (entity.GetBuildingPrivilege() != null && config.BlockSettings.EnabledBlockAutCupboard)
                {
                    foreach (var aplayer in entity.GetBuildingPrivilege().authorizedPlayers)
                    {
                        var AuthPlayer = BasePlayer.Find(aplayer.userid.ToString());
                        if (AuthPlayer != null && AuthPlayer != info.InitiatorPlayer)
                            PlayerBlockStatus.Get(AuthPlayer).BlockPlayer(sphere, false);
                        else SendOfflineMessages(entity.transform.position, info.InitiatorPlayer.displayName, aplayer.userid);
                    }
                }
            }
        }

        object CanBuild(Planner planner, Construction prefab, Construction.Target target)
        {
            var player = planner.GetOwnerPlayer();
            if (player == null || !IsRaidBlocked(player)) return null;
            var shortname = prefab.hierachyName.Substring(prefab.hierachyName.IndexOf("/") + 1);
            if (config.PlayerBlockSettings.WriteListBuildEntity.Contains(shortname))
                return null;
            var component = PlayerBlockStatus.Get(player);
            if (component == null || component.CurrentBlocker == null) return null;
            player.ChatMessage(string.Format(Messages["blockbuld"], NumericalFormatter.FormatTime(component.CurrentBlocker.TotalTime - component.CurrentTime)));
            return false;
        }

        private object OnUserCommand(IPlayer ipl, string command, string[] args)
        {
            if (ipl == null || !ipl.IsConnected) return null;
            var player = ipl.Object as BasePlayer;
            command = command.Insert(0, "/");
            if (player == null || !IsRaidBlocked(player)) return null;
            if (config.PlayerBlockSettings.BlackListCommands.Contains(command.ToLower()))
            {
                var component = PlayerBlockStatus.Get(player);
                if (component == null || component.CurrentBlocker == null) return null;
                player.ChatMessage(string.Format(Messages["commandBlock"], NumericalFormatter.FormatTime(component.CurrentBlocker.TotalTime - component.CurrentTime)));
                return false;
            }
            return null;
        }

        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            var connection = arg.Connection;
            if (connection == null || string.IsNullOrEmpty(arg.cmd?.FullName)) return null;
            var player = arg.Player();
            if (player == null || !IsRaidBlocked(player)) return null;
            if (config.PlayerBlockSettings.BlackListCommands.Contains(arg.cmd.Name.ToLower()) || config.PlayerBlockSettings.BlackListCommands.Contains(arg.cmd.FullName.ToLower()))
            {
                var component = PlayerBlockStatus.Get(player);
                if (component == null || component.CurrentBlocker == null) return null;
                player.ChatMessage(string.Format(Messages["commandBlock"], NumericalFormatter.FormatTime(component.CurrentBlocker.TotalTime - component.CurrentTime)));
                return false;
            }
            return null;
        }

        #endregion

        #region Functions
        private string GetGridString(Vector3 pos)
        {
            char letter = 'A';
            var x = Mathf.Floor((pos.x + (ConVar.Server.worldsize / 2)) / 146.3f) % 26;
            var z = (Mathf.Floor(ConVar.Server.worldsize / 146.3f) - 1) - Mathf.Floor((pos.z + (ConVar.Server.worldsize / 2)) / 146.3f);
            letter = (char)(((int)letter) + x);
            return $"{letter}{z}";
        }

        private string NumberToString(int number)
        {
            bool a = number > 26;
            Char c = (Char)(65 + (a ? number - 26 : number));
            return a ? "A" + c : c.ToString();
        }

        [PluginReference] private Plugin RaidNotice;
        private static void SendOfflineMessages(Vector3 pos, string name, ulong playerid = 294912)
        {
            if (!ins.permission.UserHasPermission(playerid.ToString(), config.VkBotMessages.VkPrivilage)) return;
            ins.RaidNotice?.Call("SendOfflineMessage", config.VkBotMessages.Messages.Replace("{0}", name).Replace("{1}", ins.GetGridString(pos)), playerid);
        }

        private string GetFormatTime(TimeSpan timespan)
        {
            return string.Format(timespan.TotalHours >= 1 ? "{2:00}:{0:00}:{1:00}" : "{0:00}:{1:00}", timespan.Minutes, timespan.Seconds, System.Math.Floor(timespan.TotalHours));
        }

        private static class NumericalFormatter
        {
            private static string GetNumEndings(int origNum, string[] forms)
            {
                string result;
                var num = origNum % 100;
                if (num >= 11 && num <= 19)
                {
                    result = forms[2];
                }
                else
                {
                    num = num % 10;
                    switch (num)
                    {
                        case 1: result = forms[0]; break;
                        case 2:
                        case 3:
                        case 4:
                            result = forms[1]; break;
                        default:
                            result = forms[2]; break;
                    }
                }
                return string.Format("{0} {1} ", origNum, result);
            }

            private static string FormatSeconds(int seconds) =>
                GetNumEndings(seconds, new[] { "секунду", "секунды", "секунд" });
            private static string FormatMinutes(int minutes) =>
                GetNumEndings(minutes, new[] { "минуту", "минуты", "минут" });
            private static string FormatHours(int hours) =>
                GetNumEndings(hours, new[] { "час", "часа", "часов" });
            private static string FormatDays(int days) =>
                GetNumEndings(days, new[] { "день", "дня", "дней" });
            private static string FormatTime(TimeSpan timeSpan)
            {
                string result = string.Empty;
                if (timeSpan.Days > 0)
                    result += FormatDays(timeSpan.Days);
                if (timeSpan.Hours > 0)
                    result += FormatHours(timeSpan.Hours);
                if (timeSpan.Minutes > 0)
                    result += FormatMinutes(timeSpan.Minutes);
                if (timeSpan.Seconds > 0)
                    result += FormatSeconds(timeSpan.Seconds).TrimEnd(' ');
                return result;
            }

            public static string FormatTime(int seconds) => FormatTime(new TimeSpan(0, 0, seconds));
            public static string FormatTime(float seconds) => FormatTime((int)Math.Round(seconds));
            public static string FormatTime(double seconds) => FormatTime((int)Math.Round(seconds));
        }
        #endregion

        #region API

        private bool IsBlocked(BasePlayer player) => IsRaidBlocked(player);

        private List<Vector3> ApiGetOwnerRaidZones(ulong playerid)
        {
            var OwnerList = BlockerList.Where(p => p.OwnerID == playerid || p.Privilage != null && p.Privilage.Contains(playerid)).Select(p => p.transform.position).ToList();
            return OwnerList;
        }

        private List<Vector3> ApiGetAllRaidZones()
          => BlockerList.Select(p => p.transform.position).ToList();

        private bool IsRaidBlock(ulong userId) => IsRaidBlocked(userId.ToString());

        private bool IsRaidBlocked(BasePlayer player) => PlayerBlockStatus.Get(player)?.CurrentBlocker != null;

        private bool IsRaidBlocked(string player)
        {
            BasePlayer target = BasePlayer.Find(player);
            if (target == null) return false;

            return IsRaidBlocked(target);
        }

        private int ApiGetTime(ulong userId)
        {
            if (!IsRaidBlocked(userId.ToString())) return 0;
            var targetBlock = PlayerBlockStatus.Get(BasePlayer.Find(userId.ToString()));
            return (int)(targetBlock.CurrentBlocker.TotalTime - targetBlock.CurrentTime);
        }

        private string CanTeleport(BasePlayer player)
        {
            if (!config.PlayerBlockSettings.CanTeleport) return null;
            if (!IsRaidBlocked(player)) return null;
            var component = PlayerBlockStatus.Get(player);
            if (component == null) return null;
            return string.Format(Messages["blocktp"], NumericalFormatter.FormatTime(component.CurrentBlocker.TotalTime - component.CurrentTime));
        }

        private int? CanBGrade(BasePlayer player, int grade, BuildingBlock block, Planner plan)
        {
            if (!config.PlayerBlockSettings.CanBGrade) return null;
            if (!IsRaidBlocked(player)) return null;
            var component = PlayerBlockStatus.Get(player);
            if (component == null) return null;
            player.ChatMessage(string.Format(Messages["blockupgrade"], NumericalFormatter.FormatTime(component.CurrentBlocker.TotalTime - component.CurrentTime)));
            return 0;
        }

        private string CanTrade(BasePlayer player)
        {
            if (!config.PlayerBlockSettings.CanUseTrade) return null;
            if (!IsRaidBlocked(player)) return null;
            var component = PlayerBlockStatus.Get(player);
            if (component == null) return null;
            return string.Format(Messages["blocktrade"], NumericalFormatter.FormatTime(component.CurrentBlocker.TotalTime - component.CurrentTime));
        }

        private string canRemove(BasePlayer player)
        {

            if (!config.PlayerBlockSettings.CanRemove) return null;
            if (!IsRaidBlocked(player)) return null;
            var component = PlayerBlockStatus.Get(player);
            if (component == null) return null;
            return string.Format(Messages["blockremove"], NumericalFormatter.FormatTime(component.CurrentBlocker.TotalTime - component.CurrentTime));
        }

        private string canTeleport(BasePlayer player)
        {
            if (!config.PlayerBlockSettings.CanTeleport) return null;
            if (!IsRaidBlocked(player)) return null;
            var component = PlayerBlockStatus.Get(player);
            if (component == null) return null;
            return string.Format(Messages["blocktp"], NumericalFormatter.FormatTime(component.CurrentBlocker.TotalTime - component.CurrentTime));
        }

        object canRedeemKit(BasePlayer player)
        {
            if (!config.PlayerBlockSettings.CanUseKits) return null;

            if (!IsRaidBlocked(player)) return null;
            var component = PlayerBlockStatus.Get(player);
            if (component == null) return null;
            return string.Format(Messages["blockKits"], NumericalFormatter.FormatTime(component.CurrentBlocker.TotalTime - component.CurrentTime));
        }

        private bool? CanAffordUpgrade(BasePlayer player, BuildingBlock block, BuildingGrade.Enum grade)
        {
            if (!IsRaidBlocked(player)) return null;
            var component = PlayerBlockStatus.Get(player);
            if (component == null) return null;
            player.ChatMessage(string.Format(Messages["blockupgrade"], NumericalFormatter.FormatTime(component.CurrentBlocker.TotalTime - component.CurrentTime)));
            return false;
        }

        private bool? OnStructureRepair(BaseCombatEntity entity, BasePlayer player)
        {
            if (!config.PlayerBlockSettings.CanRepair) return null;
            if (!IsRaidBlocked(player)) return null;
            var component = PlayerBlockStatus.Get(player);
            if (component == null) return null;
            player.ChatMessage(string.Format(Messages["blockrepair"], NumericalFormatter.FormatTime(component.CurrentBlocker.TotalTime - component.CurrentTime)));
            return false;
        }

        object OnStructureDemolish(BaseCombatEntity entity, BasePlayer player)
        {
            if (!config.PlayerBlockSettings.CanDefaultremove) return null;
            if (player == null) return null;
            if (!IsRaidBlocked(player)) return null;
            var component = PlayerBlockStatus.Get(player);
            if (component == null) return null;
            player.ChatMessage(string.Format(Messages["blockremove"], NumericalFormatter.FormatTime(component.CurrentBlocker.TotalTime - component.CurrentTime)));
            return null;
        }

        private SphereComponent GetRaidZone(Vector3 pos) =>
             BlockerList.Where(p => Vector3.Distance(p.transform.position, pos) < config.BlockSettings.BlockerDistance).FirstOrDefault();

        #endregion

        #region Messages⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        Dictionary<string, string> Messages = new Dictionary<string, string>() {
                {
                "blocksuccess", "Блок деактивирован. Функции разблокированы"
            }
            , {
                "guitimertext", "<b>Блокировка:</b> Осталось {0}"
            }
            , {
                "blockactive", "Ваше строение в квадрате <color=#ECBE13>{0}</color> разрушено, активирован рейд блок на <color=#ECBE13>{1}</color>\nНекоторые функции временно недоступны."
            }
             , {
                "blockactiveOwner", "Внимание! Ваше строение в квадрате <color=#ECBE13>{0}</color> разрушено."
            }
             , {
                "enterRaidZone", "Внимание! Вы вошли в зону рейд блока, активирован блок на <color=#ECBE13>{0}</color>\nНекоторые функции временно недоступны."
            }
             , {
                "blockactiveAuthCup", "Внимание! Строение в каком вы проживаете в квадрате <color=#ECBE13>{0}</color> было разрушено, активирован рейд блок на <color=#ECBE13>{1}</color>\nНекоторые функции временно недоступны."
            }
            , {
                "blockactiveAttacker", "Вы уничтожили чужой объект, активирован рейд блок на <color=#ECBE13>{0}</color>\nНекоторые функции временно недоступны."
            }
            , {
                "blockrepair", "Вы не можете ремонтировать строения во время рейда, подождите {0}"
            }
            , {
                "blocktp", "Вы не можете использовать телепорт во время рейда, подождите {0}"
            }
            , {
                "blockremove", "Вы не можете удалить постройки во время рейда, подождите {0}"
            }
            , {
                "blockupgrade", "Вы не можете использовать улучшение построек во время рейда, подождите {0}"
            }
            , {
                "blockKits", "Вы не можете использовать киты во время рейда, подождите {0}"
            }
            , {
                "blockbuld", "Вы не можете строить во время рейда, подождите {0}"
            },
            {
                "raidremove", "Вы не можете удалять обьекты во время рейда, подождите {0}"
            },
            {
                "blocktrade", "Вы не можете использовать обмен во время рейда, подождите {0} "
            },
            {
                "commandBlock", "Вы не можете использовать данную команду во время рейда, подождите {0}"
            },
        };
        #endregion
    }
}

// --- End of file: NoEscape.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/GameStoresRUST.cs ---
// --- Original Local Path: TrashRust/GameStoresRUST.cs ---

﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using WebSocketSharp;

namespace Oxide.Plugins
{
    [Info("GameStoresRUST", "HOUGAN & Sstine # GAMESTORES", "0.3.5")]
    public class GameStoresRUST : RustPlugin
    {
        #region References

        [PluginReference] private Plugin ImageLibrary;

        #endregion

        #region Classes

        private static class Delays
        {
            [JsonProperty("Игроки с активными запросами к АПИ")]
            public static List<ulong> ItemList = new List<ulong>();
            [JsonProperty("Количество запросов за последнюю секунду")]
            public static int RequestPerSecond = 0;
            [JsonProperty("Ограничение запросов в секунду")]
            public static int RequestPerSecondLimit = 20;

            public static bool CanRequest(BasePlayer player)
            {
                if (RequestPerSecond > RequestPerSecondLimit)
                {
                    return false;
                }

                if (ItemList.Contains(player.userID))
                {
                    player.ChatMessage($"Пожалуйста, дождитесь <<окончания>> предыдущего действия!");
                    return false;
                }
                return true;
            }

            public static void FinishRequest(BasePlayer player)
            {
                if (ItemList.Contains(player.userID))
                    ItemList.Remove(player.userID);
            }

            public static IEnumerator MakeRequest(BasePlayer player)
            {
                RequestPerSecond++;

                if (ItemList.Contains(player.userID)) yield return null;
                ItemList.Add(player.userID);

                yield return new WaitForSeconds(3f);
                if (ItemList.Contains(player.userID))
                    ItemList.Remove(player.userID);
            }
        }

        private class Stats
        {

        }

        private class Configuration
        {
            public class API
            {
                [JsonProperty("ИД магазина в сервисе")]
                public string ShopID = "UNDEFINED";
                [JsonProperty("ИД сервера в сервисе")]
                public string ServerID = "UNDEFINED";
                [JsonProperty("Секретный ключ (не распространяйте его)")]
                public string SecretKey = "UNDEFINED";
            }

            public class Interface
            {
                [JsonProperty("Включить изображение корзины")]
                public bool BucketEnable = true;
                [JsonProperty("Включить отображение названий предметов")]
                public bool TextShow = true;
                [JsonProperty("Ссылка на изображение корзины (BUCKET - стандартное изображение)")]
                public string BucketURL = "BUCKET";
                [JsonProperty("Количество предметов на строке")]
                public int ItemOnString = 7;
                [JsonProperty("Количество строк в интерфейсе")]
                public int StringAmount = 3;
                [JsonProperty("Сторона одного предмета")]
                public int ItemSide = 150;
                [JsonProperty("Отступ между предметами")]
                public int ItemMargin = 5;
            }

            public class TOP
            {
                [JsonProperty("Отправлять данные топа игроков")]
                public bool UseTop = true;
            }

            [JsonProperty("Настройки API плагина")]
            public API APISettings = new API();
            [JsonProperty("Настройки интерфейса плагина")]
            public Interface InterfaceSettings = new Interface();
            [JsonProperty("Настройки статистики сервера")]
            public TOP TOPSettings = new TOP();
        }

        private class WItem
        {
            public string ID;
            public string Name;
            public int ItemID;
            public int Amount;
            public string ShortName;
            public string Command;
            public string ImageUrl;

            public bool Blocked;
            public double Block_Date = 0;
            public bool IsBlueprint;
            public bool IsCommand;
            public bool IsItem;

            public WItem(Dictionary<string, object> data, bool show = true)
            {
                try
                {
                    if (data.ContainsKey("id")) ID = data["id"].ToString();

                    if (data.ContainsKey("name")) Name = data["name"].ToString();
                    if (data.ContainsKey("item_id")) ItemID = System.Convert.ToInt32(data["item_id"]);
                    if (data.ContainsKey("amount")) Amount = System.Convert.ToInt32(data["amount"]);
                    if (data.ContainsKey("command")) Command = data["command"].ToString();
                    if (data.ContainsKey("img")) ImageUrl = data["img"].ToString();

                    if (data.ContainsKey("blocked")) Blocked = bool.Parse(data["blocked"].ToString());

                    if (data.ContainsKey("block_date") && data["block_date"] is int)
                    {
                        double.TryParse(data["block_date"].ToString(), out Block_Date);
                    }

                    if (data.ContainsKey("type"))
                    {
                        IsBlueprint = data["type"].ToString() == "bp";
                        IsCommand = data["type"].ToString() == "command";
                        IsItem = data["type"].ToString() == "item";
                    }

                    if (ItemID != 0)
                    {
                        var itemInfo = ItemManager.FindItemDefinition(ItemID);
                        if (itemInfo != null) ShortName = itemInfo.shortname;
                        else if (IDToShortName.ContainsKey(ItemID))
                        {
                            itemInfo = ItemManager.FindItemDefinition(IDToShortName[ItemID]);
                            if (itemInfo == null) return;

                            ShortName = itemInfo.shortname;
                        }
                    }

                    var imageLibrary = instance.plugins.Find("ImageLibrary");
                    if (imageLibrary != null)
                    {
                        if (ItemID == 0)
                        {
                            if ((bool)imageLibrary.Call("HasImage", $"IconGS.{ID}"))
                            {
                                string probablyId = (string)imageLibrary.Call("GetImage", $"IconGS.{ID}");
                                if (!probablyId.IsNullOrEmpty() && probablyId != instance.NoImageID && probablyId != instance.LoadingImageID)
                                    ImageUrl = probablyId;
                                return;
                            }

                            if (!ImageUrl.IsNullOrEmpty())
                            {
                                imageLibrary.Call("AddImage", ImageUrl.Replace("https", "http"), $"IconGS.{ID}");
                            }
                        }
                        else
                        {
                            string probablyId = (string)imageLibrary.Call("GetImage", ShortName);
                            if (!probablyId.IsNullOrEmpty() && probablyId != instance.NoImageID && probablyId != instance.LoadingImageID)
                                ImageUrl = probablyId;
                        }
                    }
                }
                catch (NullReferenceException e)
                {
                    Interface.Oxide.LogError(JsonConvert.SerializeObject(data));
                }
            }
        }

        #endregion

        #region Variables

        private static bool initialization = false;
        private static bool Initialized = false;
        private static GameStoresRUST instance;
        private static Configuration Settings = new Configuration();
        private string ShopURL = "UNDEFINED";
        private int StartBalance = 0;
        public string NoImageID = "";
        public string LoadingImageID = "";
        private Coroutine LoadingCoroutine;
        private Dictionary<int, Dictionary<ulong, int>> ListTimeOutCommand = new Dictionary<int, Dictionary<ulong, int>>();
        private Dictionary<ulong, List<int>> playersBasketCache = new Dictionary<ulong, List<int>>();
        private HashSet<ulong> ListBannedCommandUserID = new HashSet<ulong>();
        private Timer TimerCheckInstant;
        private string MainApiLink = $"https://gamestores.ru/api/";
        private string ReserveApiLink = $"https://gs.gamestores.ru/api/";
        //private string BaseRequest => $"https://gamestores.ru/api/?shop_id={Settings.APISettings.ShopID}&secret={Settings.APISettings.SecretKey}{(!Settings.APISettings.ServerID.IsNullOrEmpty() && Settings.APISettings.ServerID != "0" && Settings.APISettings.ServerID != "1" && Settings.APISettings.ServerID != "UNDEFINED" ? $"&server={Settings.APISettings.ServerID}" : "")}";
        private string BaseRequestParams => $"?shop_id={Settings.APISettings.ShopID}&secret={Settings.APISettings.SecretKey}{(!Settings.APISettings.ServerID.IsNullOrEmpty() && Settings.APISettings.ServerID != "0" && Settings.APISettings.ServerID != "1" && Settings.APISettings.ServerID != "UNDEFINED" ? $"&server={Settings.APISettings.ServerID}" : "")}";
        private string BaseRequest = "";
        #endregion

        #region Interface

        private int TryImageCounter = 0;
        [PluginReference] Plugin XMenu;
        Timer TimerInitialize;

        public const string MenuLayer = "XMenu";
        public const string MenuItemsLayer = "XMenu.MenuItems";
        public const string MenuSubItemsLayer = "XMenu.MenuSubItems";
        public const string MenuContent = "XMenu.Content";

        private void OnServerInitialized()
        {
            BaseRequest = MainApiLink + BaseRequestParams;
            if (Settings.APISettings.ServerID != "0" && Settings.APISettings.ServerID != "UNDEFINED")
            {
                TimerCheckInstant = timer.Repeat(20, 0, CheckInstant);
            } else
            {
                LogAction(null, $"Некорректный ServerID, автоматическая выдача команд невозможна");
                PrintError($"Incorrect ServerID, reciving auto commands (Products) disabled");
            }
            TimerInitialize = timer.Every(5f, () =>
            {
                if (XMenu.IsLoaded)
                {
                    XMenu.Call("API_RegisterMenu", this.Name, "Store", "assets/icons/bite.png", "RenderStore", null);

                    cmd.AddChatCommand("store", this, (p, cmd, args) => rust.RunClientCommand(p, "custommenu true Store"));
                    TimerInitialize.Destroy();
                }
            });

            if (!ImageLibrary)
            {
                if (TryImageCounter < 3)
                {
                    LogAction(null, $"ImageLibrary is not initialized, try again in 1 sec.", true);
                    TryImageCounter++;

                    timer.Once(1, OnServerInitialized);
                    return;
                }
                else LogAction(null, $"Starting without ImageLibrary", true);
            }

            if (ImageLibrary)
            {
                NoImageID = (string)ImageLibrary.Call("GetImage", "NONE");
                LoadingImageID = (string)ImageLibrary.Call("GetImage", "LOADING");
            }

            if (Settings.InterfaceSettings.BucketURL.Contains("http") && plugins.Find("ImageLibrary") != null)
            {
                ImageLibrary.Call("AddImage", Settings.InterfaceSettings.BucketURL, "GameStoresRUSTBucket");
                LoadingCoroutine = ServerMgr.Instance.StartCoroutine(WaitForLoad());
            }
            else
            {
                //BasePlayer.activePlayerList.ForEach(OnPlayerInit);
                for (var i = 0; i < BasePlayer.activePlayerList.Count; i++)
                {
                    OnPlayerConnected(BasePlayer.activePlayerList[i]);
                }
            }

            instance = this;
            if (!Settings.TOPSettings.UseTop) Unsubscribe(nameof(OnEntityDeath));
            if (!Settings.TOPSettings.UseTop) Unsubscribe(nameof(OnPlayerDisconnected));

            if (Settings.APISettings.ShopID == "UNDEFINED" || Settings.APISettings.SecretKey == "UNDEFINED")
            {
                LogAction(null, $"Verify that plugin is installed correct! Some of API settings are 'UNDEFINED'", true, true);
                return;
            }

            timer.Once(2, FetchShopUrl);

            timer.Every(1, () => Delays.RequestPerSecond = 0);

            ListTimeOutCommand[0] = new Dictionary<ulong, int>();
            ListTimeOutCommand[1] = new Dictionary<ulong, int>();
            ListTimeOutCommand[2] = new Dictionary<ulong, int>();

            int totalTick = 0;
            int tick = 0;
            timer.Repeat(2, 0, () =>
            {
                if (totalTick == 30)
                {
                    totalTick = 0;
                    ListBannedCommandUserID.Clear();
                }
                ListTimeOutCommand[0].Clear();
                if (tick == 3 || tick == 6)
                {
                    ListTimeOutCommand[1].Clear();
                }

                if (tick == 6)
                {
                    tick = 0;
                    ListTimeOutCommand[2].Clear();
                }
                tick++;
                totalTick++;
            });
        }

        private IEnumerator WaitForLoad()
        {
            while (!(bool)ImageLibrary.Call("HasImage", "GameStoresRUSTBucket"))
            {
                PrintError($"Image of bucket is loading!");
                yield return new WaitForSeconds(1);
            }

            PrintWarning("Image of bucket loaded correct!");
            //BasePlayer.activePlayerList.ForEach(OnPlayerInit);
            for (var i = 0; i < BasePlayer.activePlayerList.Count; i++)
            {
                OnPlayerConnected(BasePlayer.activePlayerList[i]);
            }
            yield return 0;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                Settings = Config.ReadObject<Configuration>();
                if (Settings?.APISettings == null) LoadDefaultConfig();
            }
            catch
            {
                LogAction(null, $"Error reading config, creating one new config!", true, true);
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig()
        {
            Settings = new Configuration();
        }

        protected override void SaveConfig() => Config.WriteObject(Settings);

        private void Unload()
        {
            //if (Initialized) StatHandler.SendStats();

            if (LoadingCoroutine != null) ServerMgr.Instance.StopCoroutine(LoadingCoroutine);
            //BasePlayer.activePlayerList.ForEach(p => CuiHelper.DestroyUi(p, IconLayer));
            //BasePlayer.activePlayerList.ForEach(p => CuiHelper.DestroyUi(p, StoreLayer));
            foreach (var pl in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(pl, IconLayer);
                CuiHelper.DestroyUi(pl, StoreLayer);
                OnPlayerConnected(pl);
            }
        }

        #endregion

        #region Hooks

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            StatHandler.AddStat(new StatHandler.TimeStat(player));
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player.IsReceivingSnapshot)
            {
                NextTick(() => OnPlayerConnected(player));
                return;
            }

            if (Settings.InterfaceSettings.BucketEnable)
                InitializeIcon(player);
        }

        #endregion

        #region Stats

        private static class StatHandler
        {
            internal class Stat
            {
                [JsonProperty("dataType")]
                public string DataType;
            }
            internal class KillStat : Stat
            {
                [JsonProperty("player_id")]
                public string PlayerUserId;
                [JsonProperty("victim_id")]
                public string VictimUserID;
                [JsonProperty("type")]
                public string Type;
                [JsonProperty("time")]
                public string Time;
            }
            internal class TimeStat : Stat
            {
                [JsonProperty("player_id")]
                public string PlayerID;
                [JsonProperty("username")]
                public string PlayerName;
                [JsonProperty("played")]
                public string Played;
                [JsonProperty("time")]
                public string Time;

                public TimeStat(BasePlayer player)
                {
                    PlayerID = player.UserIDString;
                    PlayerName = player.displayName;
                    DataType = "leave";
                    Played = player.secondsConnected.ToString();
                    Time = CurrentTime().ToString();
                }
            }

            private static List<Stat> Stats = new List<Stat>();
            public static void AddStat(Stat stat)
            {
                Stats.Add(stat);
                if (Stats.Count > 10)
                {
                    SendStats();
                    Stats.Clear();
                }
            }

            public static void SendStats()
            {
                try
                {


                    if (!Initialized)
                    {
                        instance.LogAction(null, $"Sending stats error! Plugin not initialized", true, true);
                        return;
                    }
                    if (Stats.Count == 0)
                    {
                        instance.LogAction(null, $"Nothing to send", true);
                        return;
                    }

                    var obj = JsonConvert.SerializeObject(Stats);
                    RequestPost($"&method=topData&data={obj}", (i, s) => {
                        if (i != 200)
                            return;

                        Dictionary<string, object> response = JsonConvert.DeserializeObject<Dictionary<string, object>>(s, new KeyValuesConverter());
                        if (response.ContainsKey("result") && response["result"].ToString() == "success")
                        {
                            instance.LogAction(null, $"GameStores sent stats successful!", true);
                            Stats.Clear();
                        }
                        else
                        {
                            instance.LogAction(null, $"Sending stats error!", true, true);
                        }
                    });


                }
                catch
                {
                    // ignored 
                }
            }
        }

        [ConsoleCommand("sendtop")]
        private void CmdSendTop(ConsoleSystem.Arg args)
        {
            if (args.Player() != null && !args.Player().IsAdmin) return;

            StatHandler.SendStats();
        }

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null || info == null || info.Initiator == null)
                return;
            if (Settings.TOPSettings.UseTop)
            {
                BaseEntity initiator = info.Initiator;

                if (entity as BasePlayer == null && initiator as BasePlayer == null)
                    return;
                StatHandler.KillStat stat = new StatHandler.KillStat();

                if (initiator as BasePlayer != null) stat.PlayerUserId = initiator.ToPlayer().UserIDString;
                else if (initiator.PrefabName.Contains("agents")) stat.PlayerUserId = "1";
                else return;

                if (entity as BasePlayer != null)
                {
                    stat.VictimUserID = entity.ToPlayer().UserIDString;
                    stat.Type = entity.ToPlayer().IsSleeping() ? "sleeper" : "kill";
                }
                else if (entity.PrefabName.Contains("agents"))
                {
                    stat.VictimUserID = "1";
                    stat.Type = "kill";
                }
                else
                {
                    return;
                }

                stat.DataType = "death";

                stat.Time = CurrentTime().ToString();
                StatHandler.AddStat(stat);
            }
        }

        #endregion

        #region Commands

        [ChatCommand("store")]
        private void CmdChatStore(BasePlayer player, string command, string[] args)
        {
            if (player == null || player.Connection == null || player.IsSleeping())
            {
                return;
            }

            if (!Initialized)
            {
                errorsReq++;
                player.ChatMessage($"Плагин магазина запущен не корретно");
                return;

            }

            if (args.Length == 1 && args[0].ToLower() == "hide")
            {
                CuiHelper.DestroyUi(player, IconLayer);
            }
            else
            {
                if (!Delays.CanRequest(player)) return;
                //InitializeStore(player, 0, true);
            }
        }

        [ConsoleCommand("UI_GameStoresRUST")]
        private void CmdConsoleCommand(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (player == null) return;

            if (ListBannedCommandUserID.Contains(player.userID))
            {
                player.ChatMessage("Вы сделали слишком много запросов. Отдохните немного, скоро возможность выполнять действие к вам вернется.");
                return;
            }

            if (ListTimeOutCommand[0].ContainsKey(player.userID) == false)
                ListTimeOutCommand[0][player.userID] = 1;
            else
                ListTimeOutCommand[0][player.userID] = ListTimeOutCommand[0][player.userID] + 1;

            if (ListTimeOutCommand[1].ContainsKey(player.userID) == false)
                ListTimeOutCommand[1][player.userID] = 1;
            else
                ListTimeOutCommand[1][player.userID] = ListTimeOutCommand[1][player.userID] + 1;

            if (ListTimeOutCommand[2].ContainsKey(player.userID) == false)
                ListTimeOutCommand[2][player.userID] = 1;
            else
                ListTimeOutCommand[2][player.userID] = ListTimeOutCommand[2][player.userID] + 1;

            if (ListTimeOutCommand[0][player.userID] >= 10 || ListTimeOutCommand[1][player.userID] >= 20 || ListTimeOutCommand[2][player.userID] >= 30)
            {
                this.ListBannedCommandUserID.Add(player.userID);
            }

            if (!args.HasArgs(1))
            {
                player.SendConsoleCommand("chat.say /store");
                return;
            }

            switch (args.Args[0].ToLower())
            {
                case "page":
                    {
                        int page = 0;
                        if (!args.HasArgs(2) || !int.TryParse(args.Args[1], out page)) return;
                        InitializeStore(player, null, page, false);
                        break;
                    }
                case "help":
                    {
                        string helpLayer = StoreLayer + ".Help";
                        CuiHelper.DestroyUi(player, helpLayer);
                        CuiHelper.DestroyUi(player, StoreLayer);

                        CuiElementContainer container = new CuiElementContainer();
                        container.Add(new CuiPanel
                        {
                            CursorEnabled = true,
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                            Image = { Color = "0 0 0 0.5" },
                        }, MenuContent, helpLayer);

                        container.Add(new CuiLabel
                        {
                            RectTransform = { AnchorMin = "0 0.6", AnchorMax = "1 0.78", OffsetMax = "0 0" },
                            Text = { Text = "ИНСТРУКЦИЯ ПОЛЬЗОВАТЕЛЯ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 34 }
                        }, helpLayer);

                        container.Add(new CuiLabel
                        {
                            RectTransform = { AnchorMin = "0 0.3", AnchorMax = "1 0.72", OffsetMax = "0 0" },
                            Text = { Text = $"Здесь вы можете забрать товары приобретенные у нас в магазине!\n" +
                                                     $"Пополнить счёт можно различными способами: электронные кошельки, карты и т.д.\n" +
                                                     $"Авторизация в магазине происходит при помощи вашего аккаунта STEAM",
                                Font = "robotocondensed-regular.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter
                        }
                        }, helpLayer);

                        string addText = StartBalance > 0 ? $"\n<size=18>При первой авторизации вы получите в подарок <b>{StartBalance} рублей</b>!</size>" : "";
                        container.Add(new CuiLabel
                        {
                            RectTransform = { AnchorMin = "0 0.1", AnchorMax = "1 0.48", OffsetMax = "0 0" },
                            Text = { Text = $"" +
                                                     $"{addText}\n{ShopURL.ToUpper()}", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 32}
                        }, helpLayer);
                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                            Button = { Color = "0 0 0 0", Close = helpLayer, Command = "chat.say /store" },
                            Text = { Text = "" }
                        }, helpLayer);

                        CuiHelper.AddUi(player, container);
                        break;
                    }
                case "take":
                    {
                       
                        if (!args.HasArgs(3)) return;

                        int index = 0, id = 0;
                        if (!int.TryParse(args.Args[1], out index) || !int.TryParse(args.Args[2], out id)) return;

                        if (!playersBasketCache.ContainsKey(player.userID))
                        {
                            player.ChatMessage("Предмет не найден, попробуйте перезапустить корзину");
                            return;
                        } else if (!playersBasketCache[player.userID].Contains(id))
                        {
                            player.ChatMessage("Предмет не найден, попробуйте перезапустить корзину");
                            return;
                        }
                                            
                        if (args.HasArgs(5) && args.Args[3].ToLower() == "blocked")
                        {
                            double left = 0;
                            if (!double.TryParse(args.Args[4], out left)) return;

                            TimeSpan span = TimeSpan.FromSeconds(left);

                            string text = "";
                            if (span.Days >= 1)
                                text += $"{span.Days} дн. ";
                            if (span.Hours >= 1)
                                text += $"{span.Hours} ч. ";
                            if (span.Minutes >= 1)
                                text += $"{span.Minutes} мин. ";
                            if (span.Seconds >= 1)
                                text += $"{span.Seconds} сек.";

                            ShowNotify(player, "Вы не можете забрать этот предмет из корзины!\n" +
                                               $"До его разблокировки осталось: {text}");
                            return;
                        }

                        ShowNotify(player, "Подождите, ваш запрос обрабатывается!");
                        CuiElementContainer container = new CuiElementContainer();

                        if (!Delays.CanRequest(player))
                        {
                            ShowNotify(player, "Подождите, ваш предыдущий запрос ещё обрабатывается!");
                            container.Add(new CuiButton
                            {
                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                Button = { Color = "1 1 1 0.2", Close = StoreLayer + ".BlockPanel." + index + ".Open", Command = $"UI_GameStoresRUST take {index} {id}" },
                                Text = { Text = "ПОДОЖДИТЕ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", Color = "1 1 1 0.4", FontSize = 24 }
                            }, StoreLayer + ".BlockPanel." + index, StoreLayer + ".BlockPanel." + index + ".Open");

                            CuiHelper.AddUi(player, container);
                            return;
                        }

                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                            Button = { FadeIn = 1f, Color = "1 1 1 0.2", Close = StoreLayer + ".BlockPanel." + index + ".Open", Command = $"UI_GameStoresRUST take {index} {id}", Material = "" },
                            Text = { Text = "ПОДОЖДИТЕ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", Color = "1 1 1 0.4", FontSize = 24 }
                        }, StoreLayer + ".BlockPanel." + index, StoreLayer + ".BlockPanel." + index + ".Open");
                        CuiHelper.AddUi(player, container);

                        LogAction(null, $"---------------------------------");
                        LogAction(player, $"Запрос на получение предмета: {id}");
                        Request($"&item=true&steam_id={player.UserIDString}&id={id}", (i, s) =>
                        {
                            switch (i)
                            {
                                case 0:
                                    LogAction(player, $"API не ответило на запрос: {id}");
                                    PrintError("Api does not responded to a request");
                                    if (player != null)
                                    {
                                        player.ChatMessage($"Непредвиденная ошибка со стороны сервера, просим прощения!");
                                        CuiHelper.DestroyUi(player, StoreLayer);
                                    }
                                    break;
                                case 200:
                                    Dictionary<string, object> response = JsonConvert.DeserializeObject<Dictionary<string, object>>(s, new KeyValuesConverter());
                                    if (!response.ContainsKey("data"))
                                    {
                                        LogAction(player, $"Ошибка получения товара, отсутствует Data [{id}]");

                                        container.Clear();
                                        CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel." + index + ".Open");
                                        container.Add(new CuiButton
                                        {
                                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                            Button = { FadeIn = 1f, Color = "1 0.5 0.5 0.2", Close = StoreLayer + ".BlockPanel." + index + ".Open", Command = $"UI_GameStoresRUST take {index} {id}", Material = "" },
                                            Text = { Text = "ОШИБКА\nПОЛУЧЕНИЯ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", Color = "1 0.7 0.7 1", FontSize = 24 }
                                        }, StoreLayer + ".BlockPanel." + index, StoreLayer + ".BlockPanel." + index + ".Open");
                                        ShowNotify(player, "Произошла непредвиденная ошибка, попробуйте позже!\n" +
                                                           "Ваш предмет в безопасности, не переживайте!");
                                        CuiHelper.AddUi(player, container);
                                        return;
                                    }

                                    LogAction(player, $"Товар отмечен полученным [{id}]");
                                    Request($"&gived=true&id={id}", (code, newResponse) =>
                                    {
                                        if (code != 200 || JsonConvert.DeserializeObject<JObject>(newResponse)["result"].ToString() != "success")
                                        {
                                            container.Clear();
                                            CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel." + index + ".Open");
                                            container.Add(new CuiButton
                                            {
                                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                                Button = { FadeIn = 1f, Color = "1 0.5 0.5 0.2", Close = StoreLayer + ".BlockPanel." + index + ".Open", Command = $"UI_GameStoresRUST take {index} {id}", Material = "" },
                                                Text = { Text = "ОШИБКА\nПОЛУЧЕНИЯ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", Color = "1 0.7 0.7 1", FontSize = 24 }
                                            }, StoreLayer + ".BlockPanel." + index, StoreLayer + ".BlockPanel." + index + ".Open");
                                            ShowNotify(player, "Произошла непредвиденная ошибка, попробуйте позже!\n" +
                                                               "Ваш предмет в безопасности, не переживайте!");
                                            CuiHelper.AddUi(player, container);
                                            return;
                                        }
                                        ProcessTake(player, response["data"] as Dictionary<string, object>);
                                    }, player);

                                    container.Clear();
                                    CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel." + index + ".Open");
                                    container.Add(new CuiButton
                                    {
                                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                        Button = { FadeIn = 1f, Color = "0.5 1 0.5 0.2", Material = "" },
                                        Text = { Text = "УСПЕШНО\nПОЛУЧЕНО", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", Color = "0.7 1 0.7 1", FontSize = 24 }
                                    }, StoreLayer + ".BlockPanel." + index, StoreLayer + ".BlockPanel." + index + ".Open");

                                    if (playersBasketCache.ContainsKey(player.userID) && playersBasketCache[player.userID].Contains(id))
                                        playersBasketCache[player.userID].RemoveAt(playersBasketCache[player.userID].IndexOf(id));

                                    CuiHelper.AddUi(player, container);
                                    break;
                                case 404:
                                    LogAction(player, $"Сайт не ответил на запрос: {id}");
                                    player.ChatMessage($"Непредвиденная ошибка со стороны сервера, просим прощения!");
                                    CuiHelper.DestroyUi(player, StoreLayer);
                                    LogAction(null, "Response code: 404, please check your configurations", true);
                                    break;
                            }
                        }, player);
                        break;
                    }
            }
        }

        #endregion

        #region Interface

        private static string StoreLayer = "UI_GameStoresRUST_Store";

        private void RenderStore(ulong userID, object[] objects)
        {
            CuiElementContainer Container = (CuiElementContainer)objects[0];
            bool FullRender = (bool)objects[1];
            string Name = (string)objects[2];
            int ID = (int)objects[3];
            int Page = (int)objects[4];

            Container.Add(new CuiElement
            {
                Name = MenuContent,
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0 0 0 0",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-430 -230",
                            OffsetMax = "490 270"
                        },
                    }
            });

            InitializeStore(BasePlayer.FindByID(userID), Container, 0);
        }

        private void InitializeStore(BasePlayer player, CuiElementContainer container, int page, bool first = true)
        {
            bool arg = false;
            if (container == null)
            {
                container = new CuiElementContainer();
                arg = true;
            }

            if (first)
            {
                CuiHelper.DestroyUi(player, StoreLayer);
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Image = { Color = "0 0 0 0.5" },
                }, MenuContent, StoreLayer);

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.3 0.9", AnchorMax = "0.7 1", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0" },
                    Text = { Text = "<b>КОРЗИНА СЕРВЕРА</b>", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 32, Color = "1 1 1 0.7" }
                }, StoreLayer, StoreLayer + ".ITT");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "0 -25", OffsetMax = "0 0" },
                    Text = { Text = "Это ваша корзина с покупками, вы можете забрать их в любой момент", Align = TextAnchor.UpperCenter, Font = "robotocondensed-regular.ttf", Color = "1 1 1 0.4" }
                }, StoreLayer + ".ITT");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.85 0.9", AnchorMax = "0.99 1", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0", Command = "UI_GameStoresRUST help" },
                    Text = { Text = "ПОМОЩЬ", Align = TextAnchor.MiddleLeft, Font = "robotocondensed-regular.ttf", FontSize = 24 }
                }, StoreLayer);
            }

            CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel");
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.9", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0" }
            }, StoreLayer, StoreLayer + ".BlockPanel");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1.1", OffsetMax = "0 0" },
                Text = { Text = "Подождите, мы обрабатываем ваш запрос...", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 34 }
            }, StoreLayer + ".BlockPanel", StoreLayer + ".BlockPanel.Text");

            if (arg)
            {
                CuiHelper.AddUi(player, container);
            }

            NextTick(() => 
            {
            Request($"&method=basket&steam_id={player.UserIDString}", (code, response) =>
            {
                switch (code)
                {
                    case 0:
                        {
                            CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel.Text");
                            CuiElementContainer secondContainer = new CuiElementContainer();
                            secondContainer.Add(new CuiLabel
                            {
                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                Text = { Text = "Корзина временно недоступна, попробуйте позже", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 38 }
                            }, StoreLayer + ".BlockPanel", StoreLayer + ".BlockPanel.Text");
                            CuiHelper.AddUi(player, secondContainer);
                            break;
                        }
                    case 200:
                        {
                            var firstInfo = JsonConvert.DeserializeObject<Dictionary<string, object>>(response, new KeyValuesConverter());
                            if (firstInfo.ContainsKey("result"))
                            {
                                if (firstInfo["result"].ToString() == "fail")
                                {
                                    if (firstInfo["code"].ToString() == "104")
                                    {
                                        CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel.Text");
                                        CuiElementContainer secondContainer = new CuiElementContainer();
                                        secondContainer.Add(new CuiLabel
                                        {
                                            RectTransform = { AnchorMin = "0 0.1", AnchorMax = "1 1", OffsetMax = "0 0" },
                                            Text = { Text = "Ваша корзина пуста", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 34 }
                                        }, StoreLayer + ".BlockPanel", StoreLayer + ".BlockPanel.Text");
                                        CuiHelper.AddUi(player, secondContainer);
                                    }
                                    if (firstInfo["code"].ToString() == "105")
                                    {
                                        CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel.Text");
                                        CuiElementContainer secondContainer = new CuiElementContainer();
                                        secondContainer.Add(new CuiLabel
                                        {
                                            RectTransform = { AnchorMin = "0 0.1", AnchorMax = "1 1", OffsetMax = "0 0" },
                                            Text = { Text = "Вы не авторизованы в магазине!\n" +
                                                        "Ссылку на авторизацию вы можете найти в разделе 'помощь'", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 34 }
                                        }, StoreLayer + ".BlockPanel", StoreLayer + ".BlockPanel.Text");
                                        CuiHelper.AddUi(player, secondContainer);
                                    }
                                }
                                else
                                {
                                    CuiElementContainer secondContainer = new CuiElementContainer();

                                    if (!(firstInfo["data"] is List<object>))
                                    {
                                        PrintError("Unkown error #1");
                                        CuiHelper.DestroyUi(player, StoreLayer);
                                        return;
                                    }
                                    List<object> data = firstInfo["data"] as List<object>;
                                    List<WItem> wItems = new List<WItem>();

                                    foreach (var check in data.Skip(page * 21).Take(21))
                                    {
                                        wItems.Add(new WItem(check as Dictionary<string, object>));

                                    }
                                    if (playersBasketCache.ContainsKey(player.userID))
                                        playersBasketCache[player.userID].Clear();

                                    foreach (Dictionary<string, object> product in data)
                                    {
                                        if (product.ContainsKey("id"))
                                        {
                                            if (!playersBasketCache.ContainsKey(player.userID))
                                                playersBasketCache.Add(player.userID, new List<int>());

                                            playersBasketCache[player.userID].Add(Convert.ToInt32(product["id"]));
                                        }
                                            
                                    }
                                    secondContainer.Add(new CuiLabel
                                    {
                                        RectTransform = { AnchorMin = "0.4 0.14", AnchorMax = "0.4 0.14", OffsetMin = "82.5 -125", OffsetMax = "102.5 40" },
                                        Text = { Text = (page + 1).ToString(), Align = TextAnchor.MiddleCenter, FontSize = 20 }
                                    }, StoreLayer + ".BlockPanel");

                                    secondContainer.Add(new CuiButton
                                    {
                                        RectTransform = { AnchorMin = "0.4 0.14", AnchorMax = "0.4 0.14", OffsetMin = "-20 -125", OffsetMax = "125 40" },
                                        Button = { Color = "0 0 0 0", Material = "", Command = page > 0 ? $"UI_GameStoresRUST page {page - 1}" : "" },
                                        Text = { Text = "<", Color = page > 0 ? "1 1 1 1" : "1 1 1 0.2", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 24 }
                                    }, StoreLayer + ".BlockPanel");

                                    secondContainer.Add(new CuiButton
                                    {
                                        RectTransform = { AnchorMin = "0.6 0.14", AnchorMax = "0.6 0.14", OffsetMin = "-125 -125", OffsetMax = "20 40" },
                                        Button = { Color = "0 0 0 0", Material = "", Command = (page + 1) * 21 < data.Count ? $"UI_GameStoresRUST page {page + 1}" : "" },
                                        Text = { Text = ">", Color = (page + 1) * 21 < data.Count ? "1 1 1 1" : "1 1 1 0.2", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 24 }
                                    }, StoreLayer + ".BlockPanel");


                                    double xSwitch = 0;
                                    double ySwitch = 0;
                                    for (int i = 0; i < Settings.InterfaceSettings.ItemOnString * Settings.InterfaceSettings.StringAmount; i++)
                                    {
                                        UI_RecountPosition(ref xSwitch, ref ySwitch, i, Settings.InterfaceSettings.ItemOnString * Settings.InterfaceSettings.StringAmount);

                                        secondContainer.Add(new CuiButton
                                        {
                                            RectTransform = { AnchorMin = "0.495 0.55", AnchorMax = "0.495 0.55", OffsetMin = $"{xSwitch} {ySwitch - Settings.InterfaceSettings.ItemSide}", OffsetMax = $"{xSwitch + Settings.InterfaceSettings.ItemSide} {ySwitch}" },
                                            Button = { Color = "1 1 1 0.2", Command = $"" },
                                            Text = { Text = "" }
                                        }, StoreLayer + ".BlockPanel", StoreLayer + $".BlockPanel.{i}");
                                    }

                                    /*if (player.IsAdmin) 
                                    {
                                        LogToFile("Test", "123 - " + JsonConvert.SerializeObject(wItems), this);  
                                    } */
                                    foreach (var check in wItems.Select((i, t) => new { A = i, B = t }))
                                    {
                                        if (check.A.IsBlueprint)
                                        {
                                            if (plugins.Find("ImageLibrary") != null)
                                            {
                                                secondContainer.Add(new CuiElement
                                                {
                                                    Parent = StoreLayer + ".BlockPanel." + check.B,
                                                    Components =
                                                {
                                                    new CuiRawImageComponent { Png = (string) plugins.Find("ImageLibrary").Call("GetImage", "blueprintbase") },
                                                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                                                }
                                                });
                                            }
                                            else
                                            {
                                                secondContainer.Add(new CuiElement
                                                {
                                                    Parent = StoreLayer + ".BlockPanel." + check.B,
                                                    Components =
                                                {
                                                    new CuiRawImageComponent { Url = "https://gamestores.ru/img/games/rust/blueprintbase.png" },
                                                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                                                }
                                                });
                                            }
                                        }
                                        if (!check.A.ImageUrl.Contains("http"))
                                        {
                                            secondContainer.Add(new CuiElement
                                            {
                                                Parent = StoreLayer + ".BlockPanel." + check.B,
                                                Components =
                                            {
                                                new CuiRawImageComponent { Png = check.A.ImageUrl },
                                                new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                                            }
                                            });
                                        }
                                        else
                                        {
                                            secondContainer.Add(new CuiElement
                                            {
                                                Parent = StoreLayer + ".BlockPanel." + check.B,
                                                Components =
                                            {
                                                new CuiRawImageComponent { Url = check.A.ImageUrl },
                                                new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                                            }
                                            });
                                        }

                                        if (check.A.Amount > 1)
                                        {
                                            secondContainer.Add(new CuiLabel
                                            {
                                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 5", OffsetMax = "-5 0" },
                                                Text = { Text = "x" + check.A.Amount, Align = TextAnchor.LowerRight, Font = "robotocondensed-regular.ttf", FontSize = 24 }
                                            }, StoreLayer + ".BlockPanel." + check.B);
                                        }

                                        if (check.A.Blocked)
                                        {
                                            double left = check.A.Block_Date - CurrentTime();

                                            secondContainer.Add(new CuiButton
                                            {
                                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                                Button = { Color = "1 0.5 0.5 0.2", Command = $"UI_GameStoresRUST take {check.B} {check.A.ID} blocked {left}" },
                                                Text = { Text = "", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 38 }
                                            }, StoreLayer + ".BlockPanel." + check.B, StoreLayer + ".BlockPanel." + check.B + ".Open");
                                        }
                                        else
                                        {
                                            secondContainer.Add(new CuiButton
                                            {
                                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                                Button = { Color = "0 0 0 0", Close = StoreLayer + ".BlockPanel." + check.B + ".Open", Command = $"UI_GameStoresRUST take {check.B} {check.A.ID}" },
                                                Text = { Text = "" }
                                            }, StoreLayer + ".BlockPanel." + check.B, StoreLayer + ".BlockPanel." + check.B + ".Open");
                                        }

                                        secondContainer.Add(new CuiLabel
                                        {
                                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "0 -22.5", OffsetMax = "0 0" },
                                            Text = { Text = check.A.Name, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 16, Color = "1 1 1 0.8" }
                                        }, StoreLayer + ".BlockPanel." + check.B);
                                    }

                                    CuiHelper.AddUi(player, secondContainer);
                                    CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel.Text");
                                }
                            }
                            break;
                        }
                }
            }, player);
            });
        }

        private string IconLayer = "UI_GameStoresRUST_Bucket";
        private void InitializeIcon(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, IconLayer);
            CuiElementContainer container = new CuiElementContainer();
            if (Settings.InterfaceSettings.BucketURL.Contains("http"))
            {
                if (ImageLibrary)
                {
                    container.Add(new CuiElement
                    {
                        Parent = "Overlay",
                        Name = IconLayer,
                        Components =
                        {
                            new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", "GameStoresRUSTBucket") },
                            new CuiRectTransformComponent { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "8 -40", OffsetMax = "43 -6" }
                        }
                    });

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                        Button = { Color = "0 0 0 0", Command = "chat.say /store" },
                        Text = { Text = "" }
                    }, IconLayer);
                }
                else
                {
                    container.Add(new CuiElement
                    {
                        Parent = "Overlay",
                        Name = IconLayer,
                        Components =
                        {
                            new CuiRawImageComponent { Url = Settings.InterfaceSettings.BucketURL },
                            new CuiRectTransformComponent { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "8 -40", OffsetMax = "43 -6" }
                        }
                    });

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                        Button = { Color = "0 0 0 0", Command = "chat.say /store" },
                        Text = { Text = "" }
                    }, IconLayer);
                }
            }
            else
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "8 -40", OffsetMax = "43 -6" },
                    Button = { Color = "1 1 1 0.6", Sprite = "assets/icons/open.png", Command = "chat.say /store" },
                    Text = { Text = "" }
                }, "Overlay", IconLayer);
            }

            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region Utils

        private void ShowNotify(BasePlayer player, string text)
        {
            CuiHelper.DestroyUi(player, StoreLayer + ".Notify");
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.76", AnchorMax = "1 0.86", OffsetMax = "0 0" },
                Text = { FadeIn = 1f, Text = text, Align = TextAnchor.UpperCenter, Font = "robotocondensed-regular.ttf", FontSize = 16 }
            }, StoreLayer, StoreLayer + ".Notify");

            CuiHelper.AddUi(player, container);
        }

        private void ProcessTake(BasePlayer player, Dictionary<string, object> obj)
        {
            //foreach (var check in obj)
            //   PrintError(check.Key + " -> " + check.Value); 
            LogAction(player, $"Начало обработки товара");
            WItem itemInfo = new WItem(obj);
            try
            {
                if (itemInfo.IsItem)
                {
                    LogAction(player, $"Попытка получения предмета: {itemInfo.ShortName} [{itemInfo.Amount}]");
                    var info = ItemManager.FindItemDefinition(itemInfo.ShortName);
                    if (info == null) return;

                    var item = ItemManager.Create(info, itemInfo.Amount);
                    if (!player.inventory.GiveItem(item))
                    {
                        LogAction(player, $"У игрока не было места для получения предмета, предмет выброшен {itemInfo.ShortName} [{itemInfo.Amount} {player.transform.position}]");

                        item.Drop(player.transform.position, Vector3.down * 3);
                        ShowNotify(player, $"Вы успешно получили предмет  › <size=20>{info.displayName.english}</size> ‹\n" +
                                           $"У вас недостаточно места в инвентаре, <b>предмет брошен</b> под ноги!");
                    }
                    else
                    {
                        LogAction(player, $"Предмет выдан игроку в инвентарь");
                        ShowNotify(player, $"Вы успешно получили предмет  › <size=20>{info.displayName.english}</size> ‹");
                    }
                }

                if (itemInfo.IsCommand)
                {
                    LogAction(player, $"Попытка получения команды");

                    string command = itemInfo.Command.Replace("\n", "|").Replace("%steamid%", player.UserIDString, StringComparison.OrdinalIgnoreCase).Replace("%username%", player.displayName, StringComparison.OrdinalIgnoreCase);
                    foreach (var check in command.Split('|'))
                    {
                        LogAction(player, $"Исполнение команды: {check}");
                        Server.Command(check);
                    }


                    ShowNotify(player, $"Вы успешно получили предмет  › <size=20>{itemInfo.Name}</size> ‹\n" +
                                       $"Теперь вам доступны новые привилегии!");
                }

                if (itemInfo.IsBlueprint)
                {
                    LogAction(player, $"Попытка получения рецепта {itemInfo.ShortName}");
                    Item create = ItemManager.CreateByItemID(-996920608);

                    var info = ItemManager.FindItemDefinition(itemInfo.ShortName);
                    create.blueprintTarget = info.itemid;

                    if (!player.inventory.GiveItem(create))
                    {
                        create.Drop(player.transform.position, Vector3.down * 3);
                        ShowNotify(player, $"Вы успешно получили рецепт предмета  › <size=20>{info.displayName.english}</size> ‹\n" +
                                           $"У вас недостаточно места в инвентаре, <b>предмет брошен</b> под ноги!");
                    }
                    else
                    {
                        LogAction(player, $"У игрока не было места для получения рецепта, рецепт выброшен {itemInfo.ShortName} [{itemInfo.Amount} {player.transform.position}]");

                        LogAction(player, $"Рецепт выдан игроку в инвентарь");
                        LogAction(player, $"Вы успешно получили рецепт предмета  › <size=20>{info.displayName.english}</size> ‹");
                    }
                }
            } catch (Exception e)
            {
                LogAction(player, $"Ошибка получения товара [{itemInfo.ID}][{itemInfo.Name}]");
                LogToFile("!Errors", $"{DateTime.Now.ToShortTimeString()}| Error: '{e.ToString()}'", this);
                PrintError($"Error receiving product [{itemInfo.ID}], info saved to log");
            }
            
        }

        private static readonly Dictionary<int, string> IDToShortName = new Dictionary<int, string> { [-1461508848] = "rifle.ak", [2115555558] = "ammo.handmade.shell", [-533875561] = "ammo.pistol", [1621541165] = "ammo.pistol.fire", [-422893115] = "ammo.pistol.hv", [815896488] = "ammo.rifle", [805088543] = "ammo.rifle.explosive", [449771810] = "ammo.rifle.incendiary", [1152393492] = "ammo.rifle.hv", [1578894260] = "ammo.rocket.basic", [1436532208] = "ammo.rocket.fire", [542276424] = "ammo.rocket.hv", [1594947829] = "ammo.rocket.smoke", [-1035059994] = "ammo.shotgun", [1818890814] = "ammo.shotgun.fire", [1819281075] = "ammo.shotgun.slug", [1685058759] = "antiradpills", [93029210] = "apple", [-1565095136] = "apple.spoiled", [-1775362679] = "arrow.bone", [-1775249157] = "arrow.fire", [-1280058093] = "arrow.hv", [-420273765] = "arrow.wooden", [563023711] = "autoturret", [790921853] = "axe.salvaged", [-337261910] = "bandage", [498312426] = "barricade.concrete", [504904386] = "barricade.metal", [-1221200300] = "barricade.sandbags", [510887968] = "barricade.stone", [-814689390] = "barricade.wood", [1024486167] = "barricade.woodwire", [2021568998] = "battery.small", [97329] = "bbq", [1046072789] = "trap.bear", [97409] = "bed", [-1480119738] = "tool.binoculars", [1611480185] = "black.raspberries", [-1386464949] = "bleach", [93832698] = "blood", [-1063412582] = "blueberries", [-1887162396] = "blueprintbase", [-55660037] = "rifle.bolt", [919780768] = "bone.club", [-365801095] = "bone.fragments", [68998734] = "botabag", [-853695669] = "bow.hunting", [271534758] = "box.wooden.large", [-770311783] = "box.wooden", [-1192532973] = "bucket.water", [-307490664] = "building.planner", [707427396] = "burlap.shirt", [707432758] = "burlap.shoes", [-2079677721] = "cactusflesh", [-1342405573] = "tool.camera", [-139769801] = "campfire", [-1043746011] = "can.beans", [2080339268] = "can.beans.empty", [-171664558] = "can.tuna", [1050986417] = "can.tuna.empty", [-1693683664] = "candycaneclub", [523409530] = "candycane", [1300054961] = "cctv.camera", [-2095387015] = "ceilinglight", [1428021640] = "chainsaw", [94623429] = "chair", [1436001773] = "charcoal", [1711323399] = "chicken.burned", [1734319168] = "chicken.cooked", [-1658459025] = "chicken.raw", [-726947205] = "chicken.spoiled", [-341443994] = "chocholate", [1540879296] = "xmasdoorwreath", [94756378] = "cloth", [3059095] = "coal", [3059624] = "corn", [2045107609] = "clone.corn", [583366917] = "seed.corn", [2123300234] = "crossbow", [1983936587] = "crude.oil", [1257201758] = "cupboard.tool", [-1144743963] = "diving.fins", [-1144542967] = "diving.mask", [-1144334585] = "diving.tank", [1066729526] = "diving.wetsuit", [-1598790097] = "door.double.hinged.metal", [-933236257] = "door.double.hinged.toptier", [-1575287163] = "door.double.hinged.wood", [-2104481870] = "door.hinged.metal", [-1571725662] = "door.hinged.toptier", [1456441506] = "door.hinged.wood", [1200628767] = "door.key", [-778796102] = "door.closer", [1526866730] = "xmas.door.garland", [1925723260] = "dropbox", [1891056868] = "ducttape", [1295154089] = "explosive.satchel", [498591726] = "explosive.timed", [1755466030] = "explosives", [726730162] = "facialhair.style01", [-1034048911] = "fat.animal", [252529905] = "femalearmpithair.style01", [471582113] = "femaleeyebrow.style01", [-1138648591] = "femalepubichair.style01", [305916740] = "female_hairstyle_01", [305916742] = "female_hairstyle_03", [305916744] = "female_hairstyle_05", [1908328648] = "fireplace.stone", [-2078972355] = "fish.cooked", [-533484654] = "fish.raw", [1571660245] = "fishingrod.handmade", [1045869440] = "flamethrower", [1985408483] = "flameturret", [97513422] = "flare", [1496470781] = "flashlight.held", [1229879204] = "weapon.mod.flashlight", [-1722829188] = "floor.grill", [1849912854] = "floor.ladder.hatch", [-1266285051] = "fridge", [-1749787215] = "boots.frog", [28178745] = "lowgradefuel", [-505639592] = "furnace", [1598149413] = "furnace.large", [-1779401418] = "gates.external.high.stone", [-57285700] = "gates.external.high.wood", [98228420] = "gears", [1422845239] = "geiger.counter", [277631078] = "generator.wind.scrap", [115739308] = "burlap.gloves", [-522149009] = "gloweyes", [3175989] = "glue", [718197703] = "granolabar", [384204160] = "grenade.beancan", [-1308622549] = "grenade.f1", [-217113639] = "fun.guitar", [-1580059655] = "gunpowder", [-1832205789] = "male_hairstyle_01", [305916741] = "female_hairstyle_02", [936777834] = "attire.hide.helterneck", [-1224598842] = "hammer", [-1976561211] = "hammer.salvaged", [-1406876421] = "hat.beenie", [-1397343301] = "hat.boonie", [1260209393] = "bucket.helmet", [-1035315940] = "burlap.headwrap", [-1381682752] = "hat.candle", [696727039] = "hat.cap", [-2128719593] = "coffeecan.helmet", [-1178289187] = "deer.skull.mask", [1351172108] = "heavy.plate.helmet", [-450738836] = "hat.miner", [-966287254] = "attire.reindeer.headband", [340009023] = "riot.helmet", [124310981] = "hat.wolf", [1501403549] = "wood.armor.helmet", [698310895] = "hatchet", [523855532] = "hazmatsuit", [2045246801] = "clone.hemp", [583506109] = "seed.hemp", [-148163128] = "attire.hide.boots", [-132588262] = "attire.hide.skirt", [-1666761111] = "attire.hide.vest", [-465236267] = "weapon.mod.holosight", [-1211618504] = "hoodie", [2133577942] = "hq.metal.ore", [-1014825244] = "humanmeat.burned", [-991829475] = "humanmeat.cooked", [-642008142] = "humanmeat.raw", [661790782] = "humanmeat.spoiled", [-1440143841] = "icepick.salvaged", [569119686] = "bone.armor.suit", [1404466285] = "heavy.plate.jacket", [-1616887133] = "jacket.snow", [-1167640370] = "jacket", [-1284735799] = "jackolantern.angry", [-1278649848] = "jackolantern.happy", [776005741] = "knife.bone", [108061910] = "ladder.wooden.wall", [255101535] = "trap.landmine", [-51678842] = "lantern", [-789202811] = "largemedkit", [516382256] = "weapon.mod.lasersight", [50834473] = "leather", [-975723312] = "lock.code", [1908195100] = "lock.key", [-1097452776] = "locker", [146685185] = "longsword", [-1716193401] = "rifle.lr300", [193190034] = "lmg.m249", [371156815] = "pistol.m92", [3343606] = "mace", [825308669] = "machete", [830965940] = "mailbox", [1662628660] = "male.facialhair.style02", [1662628661] = "male.facialhair.style03", [1662628662] = "male.facialhair.style04", [-1832205788] = "male_hairstyle_02", [-1832205786] = "male_hairstyle_04", [1625090418] = "malearmpithair.style01", [-1269800768] = "maleeyebrow.style01", [429648208] = "malepubichair.style01", [-1832205787] = "male_hairstyle_03", [-1832205785] = "male_hairstyle_05", [107868] = "map", [997973965] = "mask.balaclava", [-46188931] = "mask.bandana", [-46848560] = "metal.facemask", [-2066726403] = "bearmeat.burned", [-2043730634] = "bearmeat.cooked", [1325935999] = "bearmeat", [-225234813] = "deermeat.burned", [-202239044] = "deermeat.cooked", [-322501005] = "deermeat.raw", [-1851058636] = "horsemeat.burned", [-1828062867] = "horsemeat.cooked", [-1966381470] = "horsemeat.raw", [968732481] = "meat.pork.burned", [991728250] = "meat.pork.cooked", [-253819519] = "meat.boar", [-1714986849] = "wolfmeat.burned", [-1691991080] = "wolfmeat.cooked", [179448791] = "wolfmeat.raw", [431617507] = "wolfmeat.spoiled", [688032252] = "metal.fragments", [-1059362949] = "metal.ore", [1265861812] = "metal.plate.torso", [374890416] = "metal.refined", [1567404401] = "metalblade", [-1057402571] = "metalpipe", [-758925787] = "mining.pumpjack", [-1411620422] = "mining.quarry", [88869913] = "fish.minnows", [-2094080303] = "smg.mp5", [843418712] = "mushroom", [-1569356508] = "weapon.mod.muzzleboost", [-1569280852] = "weapon.mod.muzzlebrake", [449769971] = "pistol.nailgun", [590532217] = "ammo.nailgun.nails", [3387378] = "note", [1767561705] = "burlap.trousers", [106433500] = "pants", [-1334615971] = "heavy.plate.pants", [-135651869] = "attire.hide.pants", [-1595790889] = "roadsign.kilt", [-459156023] = "pants.shorts", [106434956] = "paper", [-578028723] = "pickaxe", [-586116979] = "jar.pickle", [-1379225193] = "pistol.eoka", [-930579334] = "pistol.revolver", [548699316] = "pistol.semiauto", [142147109] = "planter.large", [148953073] = "planter.small", [102672084] = "attire.hide.poncho", [640562379] = "pookie.bear", [-1732316031] = "xmas.present.large", [-2130280721] = "xmas.present.medium", [-1725510067] = "xmas.present.small", [1974032895] = "propanetank", [-225085592] = "pumpkin", [509654999] = "clone.pumpkin", [466113771] = "seed.pumpkin", [2033918259] = "pistol.python", [2069925558] = "target.reactive", [-1026117678] = "box.repair.bench", [1987447227] = "research.table", [540154065] = "researchpaper", [1939428458] = "riflebody", [-288010497] = "roadsign.jacket", [-847065290] = "roadsigns", [3506021] = "rock", [649603450] = "rocket.launcher", [3506418] = "rope", [569935070] = "rug.bear", [113284] = "rug", [1916127949] = "water.salt", [-1775234707] = "salvaged.cleaver", [-388967316] = "salvaged.sword", [2007564590] = "santahat", [-1705696613] = "scarecrow", [670655301] = "hazmatsuit_scientist", [1148128486] = "hazmatsuit_scientist_peacekeeper", [-141135377] = "weapon.mod.small.scope", [109266897] = "scrap", [-527558546] = "searchlight", [-1745053053] = "rifle.semiauto", [1223860752] = "semibody", [-419069863] = "sewingkit", [-1617374968] = "sheetmetal", [2057749608] = "shelves", [24576628] = "shirt.collared", [-1659202509] = "shirt.tanktop", [2107229499] = "shoes.boots", [191795897] = "shotgun.double", [-1009492144] = "shotgun.pump", [2077983581] = "shotgun.waterpipe", [378365037] = "guntrap", [-529054135] = "shutter.metal.embrasure.a", [-529054134] = "shutter.metal.embrasure.b", [486166145] = "shutter.wood.a", [1628490888] = "sign.hanging.banner.large", [1498516223] = "sign.hanging", [-632459882] = "sign.hanging.ornate", [-626812403] = "sign.pictureframe.landscape", [385802761] = "sign.pictureframe.portrait", [2117976603] = "sign.pictureframe.tall", [1338515426] = "sign.pictureframe.xl", [-1455694274] = "sign.pictureframe.xxl", [1579245182] = "sign.pole.banner.large", [-587434450] = "sign.post.double", [-163742043] = "sign.post.single", [-1224714193] = "sign.post.town", [644359987] = "sign.post.town.roof", [-1962514734] = "sign.wooden.huge", [-705305612] = "sign.wooden.large", [-357728804] = "sign.wooden.medium", [-698499648] = "sign.wooden.small", [1213686767] = "weapon.mod.silencer", [386382445] = "weapon.mod.simplesight", [1859976884] = "skull_fire_pit", [960793436] = "skull.human", [1001265731] = "skull.wolf", [1253290621] = "sleepingbag", [470729623] = "small.oil.refinery", [1051155022] = "stash.small", [865679437] = "fish.troutsmall", [927253046] = "smallwaterbottle", [109552593] = "smg.2", [-2092529553] = "smgbody", [691633666] = "snowball", [-2055888649] = "snowman", [621575320] = "shotgun.spas12", [-2118132208] = "spear.stone", [-1127699509] = "spear.wooden", [-685265909] = "spikes.floor", [552706886] = "spinner.wheel", [1835797460] = "metalspring", [-892259869] = "sticks", [-1623330855] = "stocking.large", [-1616524891] = "stocking.small", [789892804] = "stone.pickaxe", [-1289478934] = "stonehatchet", [-892070738] = "stones", [-891243783] = "sulfur", [889398893] = "sulfur.ore", [-1625468793] = "supply.signal", [1293049486] = "surveycharge", [1369769822] = "fishtrap.small", [586484018] = "syringe.medical", [110115790] = "table", [1490499512] = "targeting.computer", [3552619] = "tarp", [1471284746] = "techparts", [456448245] = "smg.thompson", [110547964] = "torch", [1588977225] = "xmas.decoration.baubels", [918540912] = "xmas.decoration.candycanes", [-471874147] = "xmas.decoration.gingerbreadmen", [205978836] = "xmas.decoration.lights", [-1044400758] = "xmas.decoration.pinecone", [-2073307447] = "xmas.decoration.star", [435230680] = "xmas.decoration.tinsel", [-864578046] = "tshirt", [1660607208] = "tshirt.long", [260214178] = "tunalight", [-1847536522] = "vending.machine", [-496055048] = "wall.external.high.stone", [-1792066367] = "wall.external.high", [562888306] = "wall.frame.cell.gate", [-427925529] = "wall.frame.cell", [995306285] = "wall.frame.fence.gate", [-378017204] = "wall.frame.fence", [447918618] = "wall.frame.garagedoor", [313836902] = "wall.frame.netting", [1175970190] = "wall.frame.shopfront", [525244071] = "wall.frame.shopfront.metal", [-1021702157] = "wall.window.bars.metal", [-402507101] = "wall.window.bars.toptier", [-1556671423] = "wall.window.bars.wood", [61936445] = "wall.window.glass.reinforced", [112903447] = "water", [1817873886] = "water.catcher.large", [1824679850] = "water.catcher.small", [-1628526499] = "water.barrel", [547302405] = "waterjug", [1840561315] = "water.purifier", [-460592212] = "xmas.window.garland", [3655341] = "wood", [1554697726] = "wood.armor.jacket", [-1883959124] = "wood.armor.pants", [-481416622] = "workbench1", [-481416621] = "workbench2", [-481416620] = "workbench3", [-1151126752] = "xmas.lightstring", [-1926458555] = "xmas.tree" };

        private void UI_RecountPosition(ref double xSwitch, ref double ySwitch, int count, int max)
        {
            var stringAmount = Math.Ceiling((double)max / Settings.InterfaceSettings.ItemOnString);
            var currentString = Math.Floor((double)count / Settings.InterfaceSettings.ItemOnString);
            var currentPosition = count % Settings.InterfaceSettings.ItemOnString;


            var topYPosition = 0 + (float)stringAmount / 2 * Settings.InterfaceSettings.ItemSide + ((float)stringAmount / 2 - 1) * Settings.InterfaceSettings.ItemMargin;
            var topXPosition = 0 - (float)Settings.InterfaceSettings.ItemOnString / 2 * Settings.InterfaceSettings.ItemSide - ((float)Settings.InterfaceSettings.ItemOnString / 2 - 1) * Settings.InterfaceSettings.ItemMargin;

            var curYPosition = topYPosition - currentString * Settings.InterfaceSettings.ItemSide - (currentString) * (Settings.InterfaceSettings.ItemMargin + (Settings.InterfaceSettings.TextShow ? 20 : 0));
            var curXPosition = topXPosition + currentPosition * Settings.InterfaceSettings.ItemSide + (currentPosition) * Settings.InterfaceSettings.ItemMargin;

            xSwitch = curXPosition;
            ySwitch = curYPosition;
        }

        public static bool CheckInstantWork = false;
        public Timer CheckInstantWorkGlobalTimer = null;

        private void CheckInstant()
        {
            if (CheckInstantWork == true)
                return;

            CheckInstantWork = true;
            if (CheckInstantWorkGlobalTimer != null)
                CheckInstantWorkGlobalTimer.Destroy();

            CheckInstantWorkGlobalTimer = timer.Once(300, () => { CheckInstantWork = false; });

            Request($"&method=basket.commands.instant", (code, response) =>
            {
                switch (code)
                {
                    case 0:
                        {
                            LogAction(null, $"Ошибка выполнения запроса для выдачи автоматических команд");
                            CheckInstantWork = false;
                            break;
                        }
                    case 200:
                        {
                            var firstInfo = JsonConvert.DeserializeObject<Dictionary<string, object>>(response, new KeyValuesConverter());
                            if (firstInfo.ContainsKey("result"))
                            {
                                if (firstInfo["result"].ToString() == "success")
                                {
                                    List<object> data = firstInfo["data"] as List<object>;
                                    int i = 1;
                                    timer.Once(data.Count + 2, () => { CheckInstantWork = false; });

                                    foreach (Dictionary<string, object> product in data)
                                    {
                                        if (product.ContainsKey("id"))
                                        {
                                            timer.Once(i, () => { TakeInstant(Convert.ToInt32(product["id"]), product["steam_id"].ToString()); } );                                             
                                            i++;
                                        }

                                    }                                  
                                } else CheckInstantWork = false;
                            } else CheckInstantWork = false;
                            break;
                        }
                    default:
                        {
                            LogAction(null, $"Ошибка выполнения запроса для выдачи автоматических команд");
                            CheckInstantWork = false;
                            break;
                        }
                }
            }, null); 
        }

        private void TakeInstant(int GsProductId, string SteamId)
        {
            LogAction(null, $"---------------------------------");
            LogAction(null, $"[AutoCommands] Запрос на получение товара [{GsProductId}][{SteamId}]");
            Request($"&item=true&id={GsProductId}", (i, s) =>
            {
                switch (i)
                {
                    case 0:
                        LogAction(null, $"[AutoCommands] API не ответило на запрос: {GsProductId}");
                        PrintError("Api does not responded to a request");
                        break;
                    case 200:
                        Dictionary<string, object> response = JsonConvert.DeserializeObject<Dictionary<string, object>>(s, new KeyValuesConverter());
                        if (!response.ContainsKey("data"))
                        {
                            LogAction(null, $"[AutoCommands] Ошибка получения товара, отсутствует Data [{GsProductId}]");
                            return;
                        } else
                        {
                            Request($"&gived=true&id={GsProductId}", (code, newResponse) =>
                            {
                                if (code != 200 || JsonConvert.DeserializeObject<JObject>(newResponse)["result"].ToString() != "success")
                                {
                                    LogAction(null, $"[AutoCommands] Ошибка получения товара [{GsProductId}][{SteamId}]");
                                    return;
                                }
                                else
                                {
                                    WItem itemInfo = new WItem(response["data"] as Dictionary<string, object>);
                                    if (itemInfo.IsCommand)
                                    {
                                        LogAction(null, $"[AutoCommands] Товар отмечен полученным [{GsProductId}][{SteamId}]");
                                        string command = itemInfo.Command.Replace("\n", "|").Replace("%steamid%", SteamId, StringComparison.OrdinalIgnoreCase);
                                        foreach (var check in command.Split('|'))
                                        {
                                            LogAction(null, $"[AutoCommands] Исполнение команды: {check} [{GsProductId}][{SteamId}]");
                                            Server.Command(check);
                                        }
                                    }
                                    else
                                    {
                                        LogAction(null, $"[AutoCommands] Ошибка получения (товар не является командой) [{GsProductId}][{SteamId}]");
                                    }
                                }
                            }, null);
                        }
                       
                        break;
                    case 404:
                        LogAction(null, $"[AutoCommands] Api не ответило на запрос: {GsProductId}");
                        LogAction(null, "Response code: 404, please check your configurations", true);
                        break;
                }
            }, null);
        }

        private Timer RestartTimer = null;
        private void SetReserveApiLink()
        {
            if (BaseRequest.Contains(MainApiLink))
            {
                LogAction(null, $"Trying use reserve api link", true);
                BaseRequest = ReserveApiLink + BaseRequestParams;
                if (!Initialized)
                    FetchShopUrl();
                timer.Once(300, () => {
                    TryChangeLink();
                });
            } else
            {
                LogAction(null, $"Plugin will automatically restart after 10 minutes", true);
                RestartTimer = timer.Once(600, () => { LogAction(null, $"Restarting...", true); Server.Command("o.reload GameStoresRUST"); });
            }                         
        }

        private void TryChangeLink()
        {
            string newLink = ReserveApiLink + BaseRequestParams;
            if (BaseRequest.Contains(ReserveApiLink))
            {
                newLink = MainApiLink + BaseRequestParams;
            }
            CheckRequest($"{newLink}&info=true", (code, response) =>
            {
                switch (code)
                {
                    case 200:
                        {
                            if (response.Length < 1)
                            {
                                return;
                            }
                            var firstInfo = JsonConvert.DeserializeObject<Dictionary<string, object>>(response, new KeyValuesConverter());
                            if (!firstInfo.ContainsKey("data"))
                            {
                                initialization = false;
                            }
                            else
                            {
                                if (RestartTimer != null)
                                {
                                    LogAction(null, $"Restart was canceled");
                                    RestartTimer.Destroy();
                                    RestartTimer = null;
                                }
                                LogAction(null, $"API link was changed", true);
                                BaseRequest = newLink;
                                if (!Initialized)
                                    FetchShopUrl();
                                if (BaseRequest.Contains(ReserveApiLink))
                                    timer.Once(600, () => { TryChangeLink(); });
                            }
                            break;
                        }
                    default:
                        break;

                }
            });
        }

        private void FetchShopUrl()
        {
            initialization = true;
            timer.Once(5, () => { initialization = false; });
            Request($"&info=true", (code, response) =>
            {
                LogAction(null, $"-----------------------------", true);
                LogAction(null, $" GameStores {Version} (c) 2019", true);
                try
                {
                    if (response.Length < 1)
                    {
                        LogToFile("!Errors", $"{DateTime.Now.ToShortTimeString()}| Response: '{response}'", this);
                        LogAction(null, " Incorrect API response! Saved to log!", true, true);
                        LogAction(null, $"-----------------------------", true);
                        SetReserveApiLink();
                        initialization = false;
                        return;
                    }
                    var firstInfo = JsonConvert.DeserializeObject<Dictionary<string, object>>(response, new KeyValuesConverter());
                    if (!firstInfo.ContainsKey("data"))
                    {
                        LogAction(null, $"     Wrong Secret Key", true, true);
                        LogAction(null, $"-----------------------------", true);
                        initialization = false;
                    }
                    else
                    { 
                        firstInfo = firstInfo["data"] as Dictionary<string, object>;
                        ShopURL = firstInfo["link"].ToString();
                        StartBalance = int.Parse(firstInfo["default_balance"].ToString());
                        LogAction(null, "      Initialized - OK", true);
                        LogAction(null, $"-----------------------------", true);
                        //BasePlayer.activePlayerList.ForEach(OnPlayerInit);
                        foreach (var pl in BasePlayer.activePlayerList)
                        {
                            OnPlayerConnected(pl);
                        }

                        Initialized = true;
                        initialization = false;
                    }
                }
                catch (JsonException e)
                {
                    
                    LogToFile("Errors", $"{DateTime.Now.ToShortTimeString()}| JsonError | Response: '{response}'", this);
                    LogAction(null, " JSON Error! Saved to log!", true, true);
                    LogAction(null, $"-----------------------------", true);
                    SetReserveApiLink();
                    initialization = false;
                }

            });
        }

        private static int errorsReq = 0;
        private static void Request(string ask, Action<int, string> callback, BasePlayer player = null, bool cancel = true)
        {
            if (player != null && !Delays.CanRequest(player))
            {
                instance.ShowNotify(player, "Вы делаете слишком много запросов к серверу!\n" +
                    "Подождите <b>одну секунду</b>!");
                instance.timer.Once(1f, () =>
                {
                    CuiHelper.DestroyUi(player, StoreLayer + ".Notify");
                    Request(ask, callback, player, cancel);
                });

                return;
            };
            if (player != null) ServerMgr.Instance.StartCoroutine(Delays.MakeRequest(player));
            Dictionary<string, string> reqHeaders = new Dictionary<string, string>{{ "User-Agent", "GameStores Plugin" }};
            
            instance.webrequest.Enqueue(instance.BaseRequest + ask, "", (code, response) =>
            {
                if (instance == null) return;
                
                switch (code)
                {
                    case 200:
                        {
                            break;
                        }
                    default:
                        {
                            instance.LogAction(null, $"Time out waiting for GS API #1");
                            errorsReq++;
                            
                            if (errorsReq >= 10)
                            {
                                errorsReq = 0;
                                instance.TryChangeLink();
                            }
                            
                            break;
                        }
                    case 404:
                        {
                            instance.LogAction(null, $"Please check your configuration! [404] #2", true);
                            break;
                        }
                }

                if (player != null && cancel) Delays.FinishRequest(player);

                callback?.Invoke(code, response);
            }, instance, RequestMethod.GET, reqHeaders);
                      
        }
        private static void CheckRequest(string link, Action<int, string> callback)
        {   
            Dictionary<string, string> reqHeaders = new Dictionary<string, string> { { "User-Agent", "GameStores Plugin" } };
            instance.webrequest.Enqueue(link, "", (code, response) =>
            {
                if (instance == null) return;

                switch (code)
                {
                    case 0:
                        {
                            
                            break;
                        }
                    case 404:
                        {
                            
                            break;
                        }
                }

                callback?.Invoke(code, response);
            }, instance, RequestMethod.GET, reqHeaders);

        }

        private static void RequestPost(string ask, Action<int, string> callback, BasePlayer player = null, bool cancel = true)
        {
            if (player != null && !Delays.CanRequest(player))
            {
                instance.ShowNotify(player, "Вы делаете слишком много запросов к серверу!\n" +
                    "Подождите <b>одну секунду</b>!");
                instance.timer.Once(1f, () =>
                {
                    CuiHelper.DestroyUi(player, StoreLayer + ".Notify");
                    RequestPost(ask, callback, player, cancel);
                });
                return;
            };
            if (player != null) ServerMgr.Instance.StartCoroutine(Delays.MakeRequest(player));
            string body, reqLink;
            int pos = instance.BaseRequest.IndexOf("?");
            if (pos < 0)
            {
                body = ask;
                reqLink = instance.BaseRequest;
            }
            else
            {
                reqLink = instance.BaseRequest.Substring(0, pos);
                body = $"{instance.BaseRequest.Substring(pos + 1)}{ask}";
            }
            Dictionary<string, string> reqHeaders = new Dictionary<string, string> { { "User-Agent", "GameStores Plugin" } };
            instance.webrequest.Enqueue(reqLink, body, (code, response) =>
            {
                if (instance == null) return;

                switch (code)
                {
                    case 0:
                        {
                            instance.PrintError($"Time out waiting for GS API #1");
                            break;
                        }
                    case 404:
                        {
                            instance.PrintError($"Plese check your configuration! [404] #2");
                            break;
                        }
                }
                if (player != null && cancel) Delays.FinishRequest(player);

                callback?.Invoke(code, response);
            }, instance, RequestMethod.POST, reqHeaders);
        }

        private void LogAction(BasePlayer player, string text, bool printToConsole = false, bool printError = false)
        {
            LogToFile($"!global", $"{DateTime.Now.ToShortTimeString()} {(player != null ? "[" + player.userID + "]" : " ")}{text}", this);

            if (printToConsole)
                if (printError)
                    instance.PrintError($"{text}");
                else 
                    PrintWarning($"{text}");
            if (player != null)
                LogPlayerAction(player, text);
        }
        private void LogPlayerAction(BasePlayer player, string text) => LogToFile($"{player.userID}", $"{DateTime.Now.ToShortTimeString()} {text}", this);
        private static double CurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1)).TotalSeconds;

        #endregion
    }
}

// --- End of file: GameStoresRUST.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/TimedPermissions.cs ---
// --- Original Local Path: TrashRust/TimedPermissions.cs ---

using System.Text.RegularExpressions;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using Newtonsoft.Json.Linq;
using System.Linq;
using System;
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using System.Globalization;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Timed Permissions", "LaserHydra", "1.4.0", ResourceId = 1926)]
    [Description("Allows you to grant permissions or groups for a specific time")]
    internal class TimedPermissions : CovalencePlugin
    {
        [PluginReference] Plugin XMenu;
        private const string AdminPermission = "timedpermissions.use";
        private const string AdvancedAdminPermission = "timedpermissions.advanced";

        private static TimedPermissions _instance;
        private static List<Player> _players = new List<Player>();

        private Configuration _config;
        
        #region Hooks & Loading

        private void Loaded()
        {
            _instance = this;

            MigrateData();

            LoadData(ref _players);

            if (_players == null)
            {
                _players = new List<Player>();
                SaveData(_players);
            }
        }

        #region Layers
        public const string MenuLayer = "XMenu";
        public const string MenuItemsLayer = "XMenu.MenuItems";
        public const string MenuSubItemsLayer = "XMenu.MenuSubItems";
        public const string MenuContent = "XMenu.Content";
        #endregion

        public Dictionary<string, string> NicePerms = new Dictionary<string, string>()
        {
            ["blueprintmanager.all"] = "Это название я сам настроил"
        };

        Timer TimerInitialize;
        private void OnServerInitialized()
        {
            NicePerms = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, string>>("NicePerms");
            TimerInitialize = timer.Every(5f, () =>
            {
                if (XMenu.IsLoaded)
                {
                    XMenu.Call("API_RegisterSubMenu", this.Name, "Main", "Привилегии", "RenderPermissions", null);
                    TimerInitialize.Destroy();
                }
            });
        }

        private void Unload()
        {
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("NicePerms", NicePerms);
        }

        private void RenderPermissions(ulong userID, object[] objects)
        {
            CuiElementContainer Container = (CuiElementContainer)objects[0];
            bool FullRender = (bool)objects[1];
            string Name = (string)objects[2];
            int ID = (int)objects[3];
            int Page = (int)objects[4];

            Container.Add(new CuiElement
            {
                Name = MenuContent,
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0 0 0 0",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-215 -230",
                            OffsetMax = "500 270"
                        },
                    }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info",
                Parent = MenuContent,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat("#0000007f"),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "80 -460",
                            OffsetMax = "630 -10"
                        }
                    }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Title",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"<color=#1d71ff>Список ваших привилегий</color>",
                                Align = TextAnchor.MiddleCenter,
                                FontSize = 24,
                                Font = "robotocondensed-bold.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.05 0.9",
                                AnchorMax = "0.975 0.975",
                            },
                            new CuiOutlineComponent()
                            {
                                 Color = "0 0 0 1",
                                 Distance = "0.5 -0.5"
                            }
                        }
            });
            Player player = Player.Get(userID.ToString());
            if (player != null)
            {
                int j = 1;
                for (int i = 0; i < player.Groups.Count; i++)
                {
                    if (!player.Groups.ElementAt(i).Expired)
                    { 
                        Container.Add(new CuiElement
                        {
                            Parent = MenuContent + ".Info",
                            Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = $"{j}. <color=#1d71ff>" + (NicePerms.ContainsKey(player.Groups.ElementAt(i).Value) ? NicePerms[player.Groups.ElementAt(i).Value] : player.Groups.ElementAt(i).Value) + "</color> до " + player.Groups.ElementAt(i).ExpireDate.ToString("dd/MM/yyyy HH:mm"),
                                    Align = TextAnchor.MiddleLeft,
                                    FontSize = 16,
                                    Font = "robotocondensed-bold.ttf",
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1",
                                    AnchorMax = "0 1",
                                    OffsetMin = $"30 {-50 - j * 25}",
                                    OffsetMax = $"550 {-25 - j * 25}"
                                }
                            }
                        });
                        j++;
                    }
                }

                for (int i = 0; i < player.Permissions.Count; i++)
                {
                    if (!player.Permissions.ElementAt(i).Expired)
                    {
                        Container.Add(new CuiElement
                        {
                            Parent = MenuContent + ".Info",
                            Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = $"{j}. <color=#90BD47>" + (NicePerms.ContainsKey(player.Permissions.ElementAt(i).Value) ? NicePerms[player.Permissions.ElementAt(i).Value] : player.Permissions.ElementAt(i).Value) + "</color> до " + player.Permissions.ElementAt(i).ExpireDate.ToString("dd/MM/yyyy HH:mm"),
                                    Align = TextAnchor.MiddleLeft,
                                    FontSize = 16,
                                    Font = "robotocondensed-bold.ttf",
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1",
                                    AnchorMax = "0 1",
                                    OffsetMin = $"30 {-50 - j * 25}",
                                    OffsetMax = $"550 {-25 - j * 25}"
                                }
                            }
                        });
                        j++;
                    }
                }
            }
        }

        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }

        private void OnNewSave(string filename)
        {
            LoadConfig(); // Ensure config is loaded at this point

            if (_config.WipeDataOnNewSave)
            {
                string backupFileName;
                ResetAllAccess(out backupFileName);

                PrintWarning($"New save file detected: all groups and permissions revoked and data cleared. Backup created at {backupFileName}");
            }
        }

        private void MigrateData()
        {
            List<JObject> data = new List<JObject>();
            LoadData(ref data);

            if (data == null)
                return;

            foreach (JObject playerData in data)
            {
                if (playerData["permissions"] != null)
                {
                    JArray permissions = (JArray) playerData["permissions"];
                    
                    foreach (JObject obj in permissions)
                    {
                        if (obj["permission"] != null)
                        {
                            obj["Value"] = obj["permission"]; 
                            obj.Remove("permission");
                        }

                        if (obj["_expireDate"] != null)
                        {
                            string expireDate = obj["_expireDate"].Value<string>();
                            
                            int[] date = (from val in expireDate.Split('/') select Convert.ToInt32(val)).ToArray(); 
                            obj["ExpireDate"] = new DateTime(date[4], date[3], date[2], date[1], date[0], 0);

                            obj.Remove("_expireDate");
                        }
                    }
                    
                    playerData["Permissions"] = permissions;
                    playerData.Remove("permissions");
                }

                if (playerData["groups"] != null)
                {
                    JArray permissions = (JArray)playerData["groups"];
                    
                    foreach (JObject obj in permissions)
                    {
                        if (obj["group"] != null)
                        {
                            obj["Value"] = obj["group"];
                            obj.Remove("group");
                        }

                        if (obj["_expireDate"] != null)
                        {
                            string expireDate = obj["_expireDate"].Value<string>();

                            int[] date = (from val in expireDate.Split('/') select Convert.ToInt32(val)).ToArray();
                            obj["ExpireDate"] = new DateTime(date[4], date[3], date[2], date[1], date[0], 0);

                            obj.Remove("_expireDate"); 
                        }
                    }

                    playerData["Groups"] = permissions;
                    playerData.Remove("groups");
                }

                if (playerData["steamID"] != null)
                {
                    playerData["Id"] = playerData["steamID"];
                    playerData.Remove("steamID");
                }

                if (playerData["name"] != null)
                {
                    playerData["Name"] = playerData["name"];
                    playerData.Remove("name");
                }
            }

            SaveData(data);
        }

        #endregion

        #region Commands

        [Command("pinfo")]
        private void CmdPlayerInfo(IPlayer player, string cmd, string[] args)
        {
            IPlayer target;

            if (args.Length == 0 || !player.HasPermission(AdminPermission))
                target = player;
            else
                target = FindPlayer(args[0], player);

            if (target == null)
                return;

            var pl = Player.Get(target.Id);

            if (pl == null)
                player.Reply(GetMessage("Player Has No Info", player.Id));
            else
            {
                string msg = GetMessage("Player Info", player.Id);

                msg = msg.Replace("{player}", $"{pl.Name} ({pl.Id})");
                msg = msg.Replace("{groups}", string.Join(", ", (from g in pl.Groups select $"{g.Value} until {g.ExpireDate.ToLongDateString() + " " + g.ExpireDate.ToShortTimeString()} UTC").ToArray()));
                msg = msg.Replace("{permissions}", string.Join(", ", (from p in pl.Permissions select $"{p.Value} until {p.ExpireDate.ToLongDateString() + " " + p.ExpireDate.ToShortTimeString()} UTC").ToArray()));

                player.Reply(msg);
            }
        }

        [Command("revokeperm"), Permission(AdminPermission)]
        private void CmdRevokePerm(IPlayer player, string cmd, string[] args)
        {
            if (args.Length != 2)
            {
                player.Reply($"Syntax: {(player.LastCommand == CommandType.Console ? string.Empty : "/")}revokeperm <player|steamid> <permission>");
                return;
            }

            IPlayer target = FindPlayer(args[0], player);

            if (target == null)
                return;

            Player pl = Player.Get(target.Id);
            
            if (pl == null || !pl.Permissions.Any(p => p.Value == args[1].ToLower()))
            {
                player.Reply(GetMessage("User Doesn't Have Permission", player.Id).Replace("{target}", target.Name).Replace("{permission}", args[1].ToLower()));
                return;
            }

            pl.RemovePermission(args[1].ToLower());
        }

        [Command("grantperm"), Permission(AdminPermission)]
        private void CmdGrantPerm(IPlayer player, string cmd, string[] args)
        {
            if (args.Length != 3)
            {
                player.Reply($"Syntax: {(player.LastCommand == CommandType.Console ? string.Empty : "/")}grantperm <player|steamid> <permission> <time Ex: 1d12h30m>");
                return;
            }

            IPlayer target = FindPlayer(args[0], player);
            TimeSpan duration;

            if (target == null)
                return;

            if (!TryParseTimeSpan(args[2], out duration))
            {
                player.Reply(GetMessage("Invalid Time Format", player.Id));
                return;
            }

            Player.GetOrCreate(target).AddPermission(args[1].ToLower(), DateTime.UtcNow + duration);
        }

        [Command("removegroup"), Permission(AdminPermission)]
        private void CmdRemoveGroup(IPlayer player, string cmd, string[] args)
        {
            if (args.Length != 2)
            {
                player.Reply($"Syntax: {(player.LastCommand == CommandType.Console ? string.Empty : "/")}removegroup <player|steamid> <group>");
                return;
            }

            IPlayer target = FindPlayer(args[0], player);

            if (target == null)
                return;

            Player pl = Player.Get(target.Id);

            if (pl == null || !pl.Groups.Any(p => p.Value == args[1].ToLower()))
            {
                player.Reply(GetMessage("User Isn't In Group", player.Id).Replace("{target}", target.Name).Replace("{group}", args[1].ToLower()));
                return;
            }

            pl.RemoveGroup(args[1].ToLower());
        }

        [Command("addgroup"), Permission(AdminPermission)]
        private void CmdAddGroup(IPlayer player, string cmd, string[] args)
        {
            if (args.Length != 3)
            {
                player.Reply($"Syntax: {(player.LastCommand == CommandType.Console ? string.Empty : "/")}addgroup <player|steamid> <group> <time Ex: 1d12h30m>");
                return;
            }

            IPlayer target = FindPlayer(args[0], player);
            TimeSpan duration;

            if (target == null)
                return;

            if (!TryParseTimeSpan(args[2], out duration))
            {
                player.Reply(GetMessage("Invalid Time Format", player.Id));
                return;
            }

            Player.GetOrCreate(target).AddGroup(args[1], DateTime.UtcNow + duration);
        }

        [Command("timedpermissions_resetaccess"), Permission(AdvancedAdminPermission)]
        private void CmdResetAccess(IPlayer player, string cmd, string[] args)
        {
            if (args.Length != 1 || !args[0].Equals("yes", StringComparison.InvariantCultureIgnoreCase))
            {
                player.Reply("Syntax: timedpermissions_resetaccess [yes]");
                player.Reply("This command will reset all access data and create a backup. Please confirm by calling the command with 'yes' as parameter");

                return;
            }

            string backupFileName;
            ResetAllAccess(out backupFileName);

            player.Reply($"All groups and permissions revoked and data cleared. Backup created at {backupFileName}");
        }

        [Command("timedpermissions_ensureaccess"), Permission(AdvancedAdminPermission)]
        private void CmdEnsureAccess(IPlayer player, string cmd, string[] args)
        {
            if (args.Length != 1 || !args[0].Equals("yes", StringComparison.InvariantCultureIgnoreCase))
            {
                player.Reply("Syntax: timedpermissions_ensureaccess [yes]");
                player.Reply("This command will ensure every player has their permissions and groups assigned. Please confirm by calling the command with 'yes' as parameter");

                return;
            }

            foreach (Player playerInformation in _players)
                playerInformation.EnsureAllAccess();

            player.Reply("All players were ensured to have their permissions and groups assigned.");
        }

        #endregion

        #region Helper Methods

        private void ResetAllAccess(out string backupFileName)
        {
            backupFileName = $"{nameof(TimedPermissions)}_Backups/{DateTime.UtcNow.Date:yyyy-MM-dd}_{DateTime.UtcNow:T}";
            SaveData(_players, backupFileName); // create backup of current data

            foreach (Player playerInformation in _players)
                playerInformation.RemoveAllAccess();

            _players = new List<Player>();
            SaveData(_players);
        }

        #region Time Helper

        private bool TryParseTimeSpan(string source, out TimeSpan date)
        {
            int minutes = 0;
            int hours = 0;
            int days = 0;

            Match m = new Regex(@"(\d+?)m", RegexOptions.IgnoreCase).Match(source);
            Match h = new Regex(@"(\d+?)h", RegexOptions.IgnoreCase).Match(source);
            Match d = new Regex(@"(\d+?)d", RegexOptions.IgnoreCase).Match(source);

            if (m.Success)
                minutes = Convert.ToInt32(m.Groups[1].ToString());

            if (h.Success)
                hours = Convert.ToInt32(h.Groups[1].ToString());

            if (d.Success)
                days = Convert.ToInt32(d.Groups[1].ToString());

            source = source.Replace(minutes + "m", string.Empty);
            source = source.Replace(hours + "h", string.Empty);
            source = source.Replace(days + "d", string.Empty);

            if (!string.IsNullOrEmpty(source) || (!m.Success && !h.Success && !d.Success))
            {
                date = default(TimeSpan);
                return false;
            }

            date = new TimeSpan(days, hours, minutes, 0);
            return true;
        }

        #endregion

        #region Finding Helper

        private IPlayer FindPlayer(string nameOrId, IPlayer player)
        {
            if (IsConvertibleTo<ulong>(nameOrId) && nameOrId.StartsWith("7656119") && nameOrId.Length == 17)
            {
                IPlayer result = players.All.ToList().Find(p => p.Id == nameOrId);

                if (result == null)
                    player.Reply($"Could not find player with ID '{nameOrId}'");

                return result;
            }

            List<IPlayer> foundPlayers = new List<IPlayer>();

            foreach (IPlayer current in players.Connected)
            {
                if (string.Equals(current.Name, nameOrId, StringComparison.CurrentCultureIgnoreCase))
                    return current;

                if (current.Name.ToLower().Contains(nameOrId.ToLower()))
                    foundPlayers.Add(current);
            }

            switch (foundPlayers.Count)
            {
                case 0:
                    player.Reply($"Could not find player with name '{nameOrId}'");
                    break;

                case 1:
                    return foundPlayers[0];

                default:
                    string[] names = (from current in foundPlayers select current.Name).ToArray();
                    player.Reply("Multiple matching players found: \n" + string.Join(", ", names));
                    break;
            }

            return null;
        }

        #endregion

        #region Conversion Helper

        private static bool IsConvertibleTo<T>(object s)
        {
            try
            {
                var parsed = (T)Convert.ChangeType(s, typeof(T));
                return true;
            }
            catch
            {
                return false;
            }
        }

        #endregion

        #region Data Helper

        private static void LoadData<T>(ref T data, string filename = null) =>
            data = Core.Interface.Oxide.DataFileSystem.ReadObject<T>(filename ?? nameof(TimedPermissions));

        private static void SaveData<T>(T data, string filename = null) =>
            Core.Interface.Oxide.DataFileSystem.WriteObject(filename ?? nameof(TimedPermissions), data);

        #endregion

        #region Message Wrapper

        public static string GetMessage(string key, string id) => _instance.lang.GetMessage(key, _instance, id);

        #endregion

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"No Permission", "You don't have permission to use this command."},
                {"Invalid Time Format", "Invalid Time Format: Ex: 1d12h30m | d = days, h = hours, m = minutes"},
                {"Player Has No Info", "There is no info about this player."},
                {"Player Info", $"Info about <color=#C4FF00>{{player}}</color>:{Environment.NewLine}<color=#C4FF00>Groups</color>: {{groups}}{Environment.NewLine}<color=#C4FF00>Permissions</color>: {{permissions}}"},
                {"User Doesn't Have Permission", "{target} does not have permission '{permission}'."},
                {"User Isn't In Group", "{target} isn't in group '{group}'."},
            }, this);
        }

        #endregion

        #region Configuration

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();
            SaveConfig();
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config);

        private class Configuration
        {
            [JsonProperty("Wipe Data on New Save (Limited to Certain Games)")]
            public bool WipeDataOnNewSave { get; private set; } = false;
        }

        #endregion

        #region Data Structures

        // TODO: do general refactoring & improvements
        private class Player
        {
            public readonly List<TimedAccessValue> Permissions = new List<TimedAccessValue>();
            public readonly List<TimedAccessValue> Groups = new List<TimedAccessValue>();
            public string Name = "unknown";
            public string Id = "0";

            internal static Player Get(string steamId) => _players.Find(p => p.Id == steamId);

            internal static Player GetOrCreate(IPlayer player)
            {
                Player pl = Get(player.Id);

                if (pl == null)
                {
                    pl = new Player(player);

                    _players.Add(pl);
                    SaveData(_players);
                }

                return pl;
            }

            public TimedAccessValue GetTimedPermission(string permission) => Permissions.Find(p => p.Value == permission);

            public TimedAccessValue GetTimedGroup(string group) => Groups.Find(g => g.Value == group);

            public void AddPermission(string permission, DateTime expireDate)
            {
                TimedAccessValue existingPermission = GetTimedPermission(permission);

                if (existingPermission != null)
                {
                    existingPermission.ExpireDate += expireDate - DateTime.UtcNow;

                    _instance.Puts($"----> {Name} ({Id}) - Permission Extended: {permission} to {existingPermission.ExpireDate - DateTime.UtcNow}" + Environment.NewLine);
                }
                else
                {
                    Permissions.Add(new TimedAccessValue(permission, expireDate));
                    _instance.permission.GrantUserPermission(Id, permission, null);

                    _instance.Puts($"----> {Name} ({Id}) - Permission Granted: {permission} for {expireDate - DateTime.UtcNow}" + Environment.NewLine);
                }

                SaveData(_players);
            }

            internal void AddGroup(string group, DateTime expireDate)
            {
                TimedAccessValue existingGroup = GetTimedGroup(group);

                if (existingGroup != null)
                {
                    existingGroup.ExpireDate += expireDate - DateTime.UtcNow;

                    _instance.Puts($"----> {Name} ({Id}) - Group Time Extended: {group} to {existingGroup.ExpireDate - DateTime.UtcNow}" + Environment.NewLine);
                }
                else
                {
                    Groups.Add(new TimedAccessValue(group, expireDate));
                    _instance.permission.AddUserGroup(Id, group);

                    _instance.Puts($"----> {Name} ({Id}) - Added to Group: {group} for {expireDate - DateTime.UtcNow}" + Environment.NewLine);
                }

                SaveData(_players);
            }

            internal void RemovePermission(string permission)
            {
                Permissions.Remove(GetTimedPermission(permission));
                _instance.permission.RevokeUserPermission(Id, permission);

                _instance.Puts($"----> {Name} ({Id}) - Permission Expired: {permission}" + Environment.NewLine);

                if (Groups.Count == 0 && Permissions.Count == 0)
                    _players.Remove(this);

                SaveData(_players);
            }

            internal void RemoveGroup(string group)
            {
                Groups.Remove(GetTimedGroup(group));
                _instance.permission.RemoveUserGroup(Id, group);

                _instance.Puts($"----> {Name} ({Id}) - Group Expired: {group}" + Environment.NewLine);

                if (Groups.Count == 0 && Permissions.Count == 0)
                    _players.Remove(this);

                SaveData(_players);
            }

            public void RemoveAllAccess()
            {
                foreach (TimedAccessValue group in Groups)
                    _instance.permission.RemoveUserGroup(Id, group.Value);

                Groups.Clear();

                foreach (TimedAccessValue permission in Permissions)
                    _instance.permission.RevokeUserPermission(Id, permission.Value);

                Permissions.Clear();
            }

            public void EnsureAllAccess()
            {
                foreach (TimedAccessValue group in Groups)
                    _instance.permission.AddUserGroup(Id, group.Value);

                foreach (TimedAccessValue permission in Permissions)
                    _instance.permission.GrantUserPermission(Id, permission.Value, null);
            }

            private void Update()
            {
                foreach (TimedAccessValue perm in Permissions.ToList())
                    if (perm.Expired)
                        RemovePermission(perm.Value);

                foreach (TimedAccessValue group in Groups.ToList())
                    if (group.Expired)
                        RemoveGroup(group.Value);
            }

            public override int GetHashCode() => Id.GetHashCode();

            private Player(IPlayer player)
            {
                Id = player.Id;
                Name = player.Name;

                _instance.timer.Repeat(60, 0, Update);
            }

            public Player()
            {
                _instance.timer.Repeat(60, 0, Update);
            }
        }

        // TODO: do general refactoring & improvements
        private class TimedAccessValue
        {
            public string Value = string.Empty;
            public DateTime ExpireDate;

            internal bool Expired => DateTime.Compare(DateTime.UtcNow, ExpireDate) > 0;

            public override int GetHashCode() => Value.GetHashCode();

            internal TimedAccessValue(string value, DateTime expireDate)
            {
                Value = value;
                ExpireDate = expireDate;
            }

            public TimedAccessValue()
            {
            }
        }

        #endregion
    }
}

// --- End of file: TimedPermissions.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/AnimalSpawn.cs ---
// --- Original Local Path: TrashRust/AnimalSpawn.cs ---

using System;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
using Oxide.Core.Libraries;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.SceneManagement;
using Facepunch;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    /*ПЛАГИН БЫЛ ПОФИКШЕН С ПОМОЩЬЮ ПРОГРАММЫ СКАЧАНОЙ С https://discord.gg/dNGbxafuJn */ [Info("AnimalSpawn", "https://discord.gg/dNGbxafuJn", "1.0.2")]
    class AnimalSpawn : RustPlugin
    {																											

		#region Variables				
		
		private AnimalDataInfo AnimalData;
		private bool IsSpawning = false;
		private Dictionary<string, float> SaveOrigSpawn = new Dictionary<string, float>();
		private int GroundLayer = LayerMask.GetMask("Terrain", "World", "Construction", "Deployable", "Deployed", "Default", "Tree", "Resource", "Water");
		
		private class AnimalDataInfo
		{
			public int SquareSideSize;			
			public Dictionary<int, SquareInfo> Squares = new Dictionary<int, SquareInfo>();
			public List<AnimalInfo> AnimalBody = new List<AnimalInfo>();			
		}
		
		private class SquareInfo
		{
			public int minX;
			public int maxX;
			public int minY;
			public int maxY;			
			public SquareInfo(int minX, int maxX, int minY, int maxY) { this.minX = minX; this.maxX = maxX; this.minY = minY; this.maxY = maxY; }
			public bool noNeedSpawn;
		}
		
		private class AnimalInfo
		{
			[JsonIgnore]
			public BaseEntity entity;
			public ulong id;
			public string type;
			public int square;
		}
		
		#endregion
	
		#region Hooks
	
		private void Init() 
		{
			LoadVariables();
			LoadData();
		}
		
		private void OnServerInitialized()
        {   
			SaveOrigSpawn.Add("bear", Bear.Population);
			SaveOrigSpawn.Add("boar", Boar.Population);
			SaveOrigSpawn.Add("wolf", Wolf.Population);
			SaveOrigSpawn.Add("stag", Stag.Population);
			SaveOrigSpawn.Add("horse", Horse.Population);
			SaveOrigSpawn.Add("chicken", Chicken.Population);
			SaveOrigSpawn.Add("zombie", Zombie.Population);
			SaveOrigSpawn.Add("ridablehorse", RidableHorse.Population);
			
			Bear.Population = 0f;
			Boar.Population = 0f;
			Wolf.Population = 0f;
			Stag.Population = 0f;
			Horse.Population = 0f;
			Chicken.Population = 0f;
			Zombie.Population = 0f;
			RidableHorse.Population = 0f;
			
			var delAllAnimals = new HashSet<BaseEntity>(BaseNetworkable.serverEntities.OfType<BaseEntity>().Where(b => configData.AnimalsBySquare.ContainsKey(b.PrefabName)));
			foreach(var animal in delAllAnimals)
			{
				if (animal == null || animal.IsDestroyed) continue;
				animal.KillMessage();
			}						
			
            if (AnimalData == null || AnimalData.SquareSideSize == 0)
			{
				if (AnimalData == null)
					AnimalData = new AnimalDataInfo();												
				
				int count = 0;				
				AnimalData.SquareSideSize = configData.SquareSideSize;
				
				for(int ii=0;ii<(int)Math.Round((decimal)World.Size/configData.SquareSideSize);ii++)
					for(int jj=0;jj<(int)Math.Round((decimal)World.Size/configData.SquareSideSize);jj++)
					{
						SquareInfo si = new SquareInfo(configData.SquareSideSize*ii-(int)World.Size/2, configData.SquareSideSize*ii+(configData.SquareSideSize-1)-(int)World.Size/2, configData.SquareSideSize*jj-(int)World.Size/2, configData.SquareSideSize*jj+(configData.SquareSideSize-1)-(int)World.Size/2);						
						AnimalData.Squares.Add(count, si);
						count++;
					}
					
				SaveData();	
			}			
			
			timer.Once(50f, CheckSpawn);
        }				
		
		private void Unload()
        {   
			IsSpawning = true;
			
            foreach (var animal in AnimalData.AnimalBody.ToList())            
                if (animal.entity != null)
                {
                    UnityEngine.Object.Destroy(animal.entity.GetComponent<NPCController>());
                    animal.entity.KillMessage();				
                }			            
			
			AnimalData.AnimalBody.Clear();
			
            var objects = UnityEngine.Object.FindObjectsOfType<NPCController>();
            if (objects != null)
                foreach (var gameObj in objects)
                    UnityEngine.Object.Destroy(gameObj);
					
			SaveData();		
			
			Bear.Population = SaveOrigSpawn["bear"];
			Boar.Population = SaveOrigSpawn["boar"];
			Wolf.Population = SaveOrigSpawn["wolf"];
			Stag.Population = SaveOrigSpawn["stag"];
			Horse.Population = SaveOrigSpawn["horse"];
			Chicken.Population = SaveOrigSpawn["chicken"];
			Zombie.Population = SaveOrigSpawn["zombie"];
			RidableHorse.Population = SaveOrigSpawn["ridablehorse"];
        }
		
		private void OnNewSave()
		{								
			AnimalData.SquareSideSize = 0;
			AnimalData.Squares.Clear();
			SaveData();
		}
		
		#endregion
		
		#region Main
		
		private void CheckSpawn()
		{			
			if (!IsSpawning)
			{
				ClearDieAnimals();
				CommunityEntity.ServerInstance.StartCoroutine(SpawnAnimals());			
			}
			
			timer.Once(configData.RespawnTime, CheckSpawn);
		}
		
		private void ClearDieAnimals()
		{			
			foreach (var animal in AnimalData.AnimalBody.ToList())            
                if (animal.entity == null || animal.entity.IsDestroyed)
					AnimalData.AnimalBody.Remove(animal);							
		}
		
		private IEnumerator SpawnAnimals()
		{
			IsSpawning = true;			
			foreach(var square in AnimalData.Squares.ToDictionary(x=>x.Key, x=>x.Value))
			{
				if (square.Value.noNeedSpawn) continue;
				
				foreach(var animalCfg in configData.AnimalsBySquare)
				{
					var count = AnimalData.AnimalBody.Where(x=>x.square == square.Key && x.type == animalCfg.Key).Count();
					
					for(int ii=count;ii<animalCfg.Value;ii++)
					{
						BaseEntity entity = null;
						var result = TrySpawnAnimal(animalCfg.Key, square.Value, ref entity);						
						AnimalData.Squares[square.Key].noNeedSpawn = !result;
												
						if (entity != null)
							AnimalData.AnimalBody.Add(new AnimalInfo() {entity = entity, id = entity.net.ID.Value, type = animalCfg.Key, square = square.Key});							
						
						yield return new WaitForSeconds(0.15f);
					}					
				}
				SaveData();
			}			
			IsSpawning = false;
		}

		private bool TrySpawnAnimal(string type, SquareInfo square, ref BaseEntity entity)
		{
			Vector3 newPos = default(Vector3);
			
			for(int ii=0;ii<configData.MaxTryFindSpawn;ii++)
			{
				var x = UnityEngine.Random.Range(square.minX, square.maxX);
				var z = UnityEngine.Random.Range(square.minY, square.maxY);								
				
				if (IsPlaceNorm(x, z, ref newPos))
				{
					var tmp = SpawnAnimal(type, newPos);
					if (tmp != null)					
					{
						entity = tmp;
						return true;					
					}
				}
			}
			
			return false;
		}
		
		private bool IsNobodyNear(Vector3 pos)
		{
			var distance = configData.MinDistanceSpawn * configData.MinDistanceSpawn;
			foreach(var player in BasePlayer.activePlayerList)			
				if ((pos-player.transform.position).sqrMagnitude <= distance)
					return false;
			
			return true;
		}
		
		private bool IsFlatPlace(Vector3 pos)
		{
			RaycastHit hitInfo;			
			
			var posTmp = pos + new Vector3(-1f,500f,0f);
			if (Physics.Raycast(posTmp, Vector3.down, out hitInfo, 1000f, GroundLayer))
			{
				if (Math.Abs(pos.y - hitInfo.point.y) >= configData.SpawnDelta)
					return false;
			}
			else
				return false;
			
			posTmp = pos + new Vector3(0f,500f,-1f);
			if (Physics.Raycast(posTmp, Vector3.down, out hitInfo, 1000f, GroundLayer))
			{
				if (Math.Abs(pos.y - hitInfo.point.y) >= configData.SpawnDelta)
					return false;
			}
			else
				return false;
			
			posTmp = pos + new Vector3(1f,500f,0f);
			if (Physics.Raycast(posTmp, Vector3.down, out hitInfo, 1000f, GroundLayer))
			{
				if (Math.Abs(pos.y - hitInfo.point.y) >= configData.SpawnDelta)
					return false;
			}
			else
				return false;
			
			posTmp = pos + new Vector3(0f,500f,1f);
			if (Physics.Raycast(posTmp, Vector3.down, out hitInfo, 1000f, GroundLayer))
			{
				if (Math.Abs(pos.y - hitInfo.point.y) >= configData.SpawnDelta)
					return false;
			}
			else
				return false;
			
			return true;
		}	
		
		private bool IsPlaceNorm(int x, int z, ref Vector3 newPos)
		{
			Vector3 pos = new Vector3(x, 500f, z);
			RaycastHit hitInfo;
			
			var result = Physics.SphereCast(pos, 2f, Vector3.down, out hitInfo, 1000, GroundLayer);						
			
			if (!result) 
				return false;
			
			if (hitInfo.collider.name != "Terrain")
				return false;
			
			if (hitInfo.point.y < 0)
				return false;
			
			newPos = new Vector3(x, hitInfo.point.y, z);
			
			if (!IsNobodyNear(newPos))
				return false;

			if (!IsFlatPlace(newPos))
				return false;
			
			return true;
		}
		
		private BaseEntity SpawnAnimal(string type, Vector3 newPos)
		{			
			if (newPos == default(Vector3)) return null;
			
			BaseEntity entity = InstantiateEntity(type, newPos);
			entity.Spawn();
			var npc = entity.gameObject.AddComponent<NPCController>();
			npc.SetHome(newPos);
			
			return entity;			
		}				
		
		private BaseEntity InstantiateEntity(string type, Vector3 position)
        {
            var gameObject = Instantiate.GameObject(GameManager.server.FindPrefab(type), position, Quaternion.Euler(0, UnityEngine.Random.Range(0.0f, 360.0f), 0));
            gameObject.name = type;

            SceneManager.MoveGameObjectToScene(gameObject, Rust.Server.EntityScene);

            UnityEngine.Object.Destroy(gameObject.GetComponent<Spawnable>());

            if (!gameObject.activeSelf)
                gameObject.SetActive(true);

            BaseEntity component = gameObject.GetComponent<BaseEntity>();
            return component;
        }
		
		private class NPCController : MonoBehaviour
        {
            public BaseNpc npc;
			public BaseVehicle vcl;
            private Vector3 homePos;

            private void Awake()
            {
                npc = GetComponent<BaseNpc>();
				vcl = GetComponent<BaseVehicle>();
                enabled = false;
            }
			
            private void OnDestroy() => InvokeHandler.CancelInvoke(this, CheckLocation);            
			
            public void SetHome(Vector3 homePos)
            {
				if (npc == null) return;
				
                this.homePos = homePos;
                InvokeHandler.InvokeRepeating(this, CheckLocation, 1f, 20f);
            }

            private void CheckLocation()
            {
				if (npc == null) 
				{
					Destroy(this);
					return;
				}
				
				if (npc.NavAgent == null)
				{					
					npc.KillMessage();
					Destroy(this);
					return;
				}
				
                if (Vector3.Distance(npc.transform.position, homePos) > 100)                
                    npc.UpdateDestination(homePos);                
            }
        }
		
		private void Output(BasePlayer player, string output, string text)
		{
			if (output == "chat")
				SendReply(player, text);
			else
				if (output == "console")
					PrintToConsole(player, text);
				else
					Puts(text);		
		}
		
		#endregion
		
		#region Command		

		[Oxide.Plugins.ChatCommand("animal.tp")]
        private void TpCommand(BasePlayer player, string command, string[] args)
        {
			if (!player.IsAdmin) return;
			
			var list = UnityEngine.Object.FindObjectsOfType<BaseEntity>().Where(x=> x.ShortPrefabName == args[0]).ToList();
			
			if (list == null || list.Count==0) 
			{
				SendReply(player, "Указанные животные не найдены !");
				return;
			}	
			
            player.Teleport(list.GetRandom().transform.position); 
        }
		
		[ConsoleCommand("animal.count")]
        private void CountCommand(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
			if (player != null && !player.IsAdmin) return;
			
			Dictionary<string, int> diff = new Dictionary<string, int>();
			var npcs = new HashSet<BaseEntity>(BaseNetworkable.serverEntities.OfType<BaseEntity>().Where(b => configData.AnimalsBySquare.ContainsKey(b.PrefabName)));
			
            foreach(var npc in npcs)
			{
				if (!diff.ContainsKey(npc.ShortPrefabName))				
					diff.Add(npc.ShortPrefabName, 1);					
				else
					diff[npc.ShortPrefabName]++;
			}
			
			if (diff.Count == 0)
				Output(player, player != null ? "console" : "", "Животные не найдены !");
			else			
				foreach(var npc in diff)
					Output(player, player != null ? "console" : "", string.Format("Тип NPC '{0}' - {1} шт.", npc.Key, npc.Value));								
		}
		
		#endregion
		
		#region Config        				
		
        private static ConfigData configData;
		
        private class ConfigData
        {            
			[JsonProperty(PropertyName = "Ширина стороны одного квадрата сетки спавна животных (метры)")]
			public int SquareSideSize;
			[JsonProperty(PropertyName = "Частота возрождения животных (секунды)")]
			public int RespawnTime;
			[JsonProperty(PropertyName = "Минимальное расстояние от игрока до места где может заспавнится животное (метры)")]
			public int MinDistanceSpawn;
			[JsonProperty(PropertyName = "Максимальное количество попыток найти подходящий спавн в заданном квадрате (50-500)")]
			public int MaxTryFindSpawn;
			[JsonProperty(PropertyName = "Допустимая величина отклонения неровности поверхности спавна")]
			public float SpawnDelta;
			[JsonProperty(PropertyName = "Количество животных на один квадрат сетки (целое число)")]
			public Dictionary<string, int> AnimalsBySquare;			
        }
		
        private void LoadVariables() => configData = Config.ReadObject<ConfigData>();        
		
        protected override void LoadDefaultConfig()
        {
            configData = new ConfigData
            {
                SquareSideSize = 1000,
				RespawnTime = 120,
				MinDistanceSpawn = 30,
				MaxTryFindSpawn = 100,
				SpawnDelta = 0.25f,
				AnimalsBySquare = new Dictionary<string, int>()
				{
					{"assets/rust.ai/agents/zombie/zombie.prefab", 0},
					{"assets/rust.ai/agents/bear/bear.prefab", 3},
					{"assets/rust.ai/agents/boar/boar.prefab", 3},
					{"assets/rust.ai/agents/chicken/chicken.prefab", 4},
					{"assets/rust.ai/agents/horse/horse.prefab", 2},
					{"assets/rust.ai/agents/stag/stag.prefab", 3},
					{"assets/rust.ai/agents/wolf/wolf.prefab", 2},
					{"assets/rust.ai/nextai/testridablehorse.prefab", 2},
				}				
            };
            SaveConfig(configData);
			timer.Once(0.1f, ()=> SaveConfig(configData));
        }        
		
        private void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
		
        #endregion				
		
		#region Data				
		
		private void LoadData() 
		{
			AnimalData = Interface.GetMod().DataFileSystem.ReadObject<AnimalDataInfo>("AnimalSpawnData");							
			
			if (AnimalData == null)
				AnimalData = new AnimalDataInfo();
			
			if (AnimalData.Squares == null)
				AnimalData.Squares = new Dictionary<int, SquareInfo>();
			
			if (AnimalData.AnimalBody == null)
				AnimalData.AnimalBody = new List<AnimalInfo>();
		}
		
		private void SaveData() => Interface.GetMod().DataFileSystem.WriteObject("AnimalSpawnData", AnimalData);				
		
		#endregion
		
	}
	
}	

// --- End of file: AnimalSpawn.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/ScrapHelicopterFix.cs ---
// --- Original Local Path: TrashRust/ScrapHelicopterFix.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;
namespace Oxide.Plugins
{
    [Info("ScrapHelicopterFix", "", "0.1.1")]
    [Description("Fixes scrap copters, and their elements")]
    class ScrapHelicopterFix : RustPlugin
    {
        static PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Thank you for downloading the plugin from RustPlugin.ru. <3 OxideBro");
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();

            if (config.PluginVersion < Version)
                UpdateConfigValues();
            Config.WriteObject(config, true);
        }

        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (config.PluginVersion < Version)
            {
                if (config.PluginVersion < new VersionNumber(0, 1, 1))
                {
                    PrintWarning("Config update detected! Updating config values...");
                    config.configMinicopter = new ConfigMinicopter()
                    {
                        DisabledEffectsMinicopter = false,
                        DisableFireBallsMinicopter = false
                    };
                    PrintWarning("Config update completed!");
                }

                config.PluginVersion = Version;
            }
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }


        public class ConfigMinicopter
        {
            [JsonProperty("Не создавать огонь при взрыве Миникоптера | Do not create fire when the Minicopters explodes")]
            public bool DisableFireBallsMinicopter = false;

            [JsonProperty("Убрать еффект врзыва Миникоптера при его разрушении | Remove the effect of the Minicopters burst when it is destroyed")]
            public bool DisabledEffectsMinicopter = false;
        }

        private class PluginConfig
        {
            [JsonProperty("Не создавать огонь при взрыве коптера | Do not create fire when the ScrapHelicopter explodes")]
            public bool DisableFireBalls = false;

            [JsonProperty("Исправление позиции огня при разрушении коптера | Correcting the position of FireBalls when destroying the ScrapHelicopter")]
            public bool EnabledFixesFireBalls = false;

            [JsonProperty("Количество созданных fireballs (Если включен фикс позиции, стандарт 12) | Count of fireballs created (If fixed position is enabled, default 12)")]
            public int FireBallsCount = 12;

            [JsonProperty("Убрать части коптера при его разрушении | Remove server gibs of the ScrapHelicopter when it is destroyed")]
            public bool DisableServerGibs = false;

            [JsonProperty("Убрать еффект врзыва коптера при его разрушении | Remove the effect of the ScrapHelicopter burst when it is destroyed")]
            public bool DisabledEffects = false;



            [JsonProperty("Настройки разрушения Миникоптера | Minicopter destruction settings")]
            public ConfigMinicopter configMinicopter;


            [JsonProperty("Configuration version")]
            public VersionNumber PluginVersion = new VersionNumber();
            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig
                {
                    PluginVersion = new VersionNumber(),
                    configMinicopter = new ConfigMinicopter()
                };
            }
        }
        void OnEntityDeath(Minicopter entity, HitInfo info)
        {
            if (entity == null || entity?.net.ID == null || info == null) return;
            if (entity is ScrapTransportHelicopter)
            {
                if (entity.fireBall != null)
                {
                    if (config.DisableFireBalls || config.EnabledFixesFireBalls)
                    {
                        entity.fireBall.guid = null;
                        if (config.EnabledFixesFireBalls && config.FireBallsCount > 0)
                        {
                            for (int i = 0; i < config.FireBallsCount; i++)
                            {
                                BaseEntity fireballs = GameManager.server.CreateEntity("assets/bundled/prefabs/oilfireballsmall.prefab", entity.transform.position);
                                if (fireballs)
                                {
                                    fireballs.enableSaving = false;
                                    fireballs.transform.position += new Vector3(UnityEngine.Random.Range(-4f, 4f), 1.5f, UnityEngine.Random.Range(-4f, 4f));
                                    fireballs.Spawn();
                                }
                            }
                        }
                    }
                    if (config.DisableServerGibs && entity.serverGibs != null)
                        entity.serverGibs.guid = null;
                    if (entity.explosionEffect != null && config.DisabledEffects)
                        entity.explosionEffect.guid = null;
                }
                return;
            }

            if (entity.explosionEffect != null && config.configMinicopter.DisabledEffectsMinicopter || config.configMinicopter.DisableFireBallsMinicopter && entity.fireBall != null)
            {
                if (entity.explosionEffect != null && config.configMinicopter.DisabledEffectsMinicopter)
                    entity.explosionEffect.guid = null;
                if (entity.fireBall != null && config.configMinicopter.DisableFireBallsMinicopter)
                    entity.fireBall.guid = null;
            }
        }
    }
}

// --- End of file: ScrapHelicopterFix.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/Notifications.cs ---
// --- Original Local Path: TrashRust/Notifications.cs ---

﻿using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Text;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Notifications", "VooDoo", "1.0.0")]
    [Description("Notifications Api")]
    public class Notifications : RustPlugin
    {
        class UINotification
        {
            public string text { get; set; }

            public UINotification(string text)
            {
                this.text = text;
            }
        }

        private static Dictionary<ulong, DateTime> hideList = new Dictionary<ulong, DateTime>();

        #region API
        bool AddInHideList(ulong userID)
        {
            hideList[userID] = DateTime.Now;

            BasePlayer player = BasePlayer.FindByID(userID);
            return true;
        }

        bool RemoveFromHideList(ulong userID)
        {
            hideList.Remove(userID);
            BasePlayer player = BasePlayer.FindByID(userID);

            return true;
        }

        bool ContainsInHideList(ulong userID)
        {
            if (hideList.ContainsKey(userID))
                return true;
            return false;
        }
        #endregion

        Dictionary<BasePlayer, Timer> UITimers = new Dictionary<BasePlayer, Timer>();
        Dictionary<ulong, List<UINotification>> UIUsers = new Dictionary<ulong, List<UINotification>>();

        void API_AddUINote(ulong userID, string message)
        {
            if (hideList.ContainsKey(userID))
                return;

            UIUsers[userID].Insert(0, new UINotification(message));

            if (UIUsers[userID].Count > 5)
                UIUsers[userID].Remove(UIUsers[userID].LastOrDefault());

            BasePlayer player = BasePlayer.FindByID(userID);
            Effect effect = new Effect("assets/bundled/prefabs/fx/notice/item.select.fx.prefab", player, 0, Vector3.zero, Vector3.forward);
            EffectNetwork.Send(effect, player.net.connection);

            API_UpdateUINote(BasePlayer.FindByID(userID));
            UpdateTimer(player);
            player.SendConsoleCommand("echo " + message);
        }

        void OnServerInitialized()
        {
            hideList = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, DateTime>>("Notification");
            
            List<ulong> cacheList = new List<ulong>();
            foreach (var ignore in hideList)
            {
                if (hideList[ignore.Key].AddDays(14) < DateTime.Now)
                    cacheList.Add(ignore.Key);
            }

            foreach (var userID in cacheList)
                hideList.Remove(userID);

            foreach(var player in BasePlayer.activePlayerList)
				OnPlayerConnected(player);
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.Once(2, () => OnPlayerConnected(player));
                return;
            }

            if (hideList.ContainsKey(player.userID))
                hideList[player.userID] = DateTime.Now;


            UIUsers[player.userID] = new List<UINotification>();
        }

        void UpdateTimer(BasePlayer player)
        {
            if (UITimers.ContainsKey(player) && UITimers[player] != null)
                UITimers[player].Destroy();

            UITimers[player] = timer.In(5f, () => 
            {
                if (player == null) UITimers[player].Destroy();

                if (UIUsers[player.userID].Count > 0)
                {
                    UIUsers[player.userID].Remove(UIUsers[player.userID].LastOrDefault());
                    API_UpdateUINote(player);
                    UpdateTimer(player);
                }
                else
                {
                    UITimers[player].Destroy();
                }
            });
        }

        #region UI
        public const string UILayer = "Notification";
        private void API_UpdateUINote(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, UILayer + $".{UIUsers[player.userID].Count}");
            for (int i = 0; i < UIUsers[player.userID].Count; i++)
            {
                CuiHelper.DestroyUi(player, UILayer + $".{i}");
                CuiElementContainer Container = new CuiElementContainer();
                Container.Add(new CuiElement
                {
                    Name = UILayer + $".{i}",
                    Parent = "Overlay",
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0 0 0 0",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                        }
                    }
                });
                Container.Add(new CuiElement
                {
                    Name = UILayer + $".{i}.Type",
                    Parent = UILayer + $".{i}",
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Color = "0 0 0 0.5",
                            Sprite = "assets/content/materials/highlight.png",
                            Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat"
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = $"6 {-85 - i * 40}",
                            OffsetMax = $"36 {-55- i * 40}",
                        }
                    }
                });
                Container.Add(new CuiElement
                {
                    Name = UILayer + $".{i}.Type",
                    Parent = UILayer + $".{i}.Type",
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Color = "1 1 1 1",
                            Material = "assets/icons/iconmaterial.mat",
                            Sprite = "assets/icons/info.png",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.2 0.2",
                            AnchorMax = "0.8 0.8",
                        }
                    }
                });
                Container.Add(new CuiElement
                {
                    Name = UILayer + $".{i}.Text",
                    Parent = UILayer + $".{i}",
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Color = "1 1 1 0.1",
                            Sprite = "assets/content/materials/highlight.png",
                            Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat"
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = $"{36} {-85 - i * 40}",
                            OffsetMax = $"{41 + GetStringWidth(UIUsers[player.userID].ElementAt(i).text, "Roboto Condensed", 9)} {-55 - i * 40}",
                        }
                    }
                });
                Container.Add(new CuiElement
                {
                    Name = UILayer + $".{i}.Text",
                    Parent = UILayer + $".{i}.Text",
                    Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"<color=#fff9f9>{UIUsers[player.userID].ElementAt(i).text}</color>",
                                Align = TextAnchor.MiddleLeft,
                                FontSize = 9,
                                Font = "robotocondensed-regular.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0 0",
                                AnchorMax = "1 1",
                                OffsetMin = "5 0",
                                OffsetMax = "5 0",
                            },
                            new CuiOutlineComponent
                            {
                                 Color = "0 0 0 1",
                                 Distance = "-0.5 0.5"
                            }
                        }
                });
                CuiHelper.AddUi(player, Container);
            }
        }
        #endregion

        #region GetStringWidth
        public double GetStringWidth(string message, string font, int fontSize)
        {
            System.Drawing.Font stringFont = new System.Drawing.Font(font, fontSize, System.Drawing.FontStyle.Regular);
            using (System.Drawing.Bitmap tempImage = new System.Drawing.Bitmap(200, 200))
            {
                System.Drawing.SizeF stringSize = System.Drawing.Graphics.FromImage(tempImage).MeasureString(message, stringFont);
                return stringSize.Width * 0.65;
            }
        }
        #endregion
    }
}


// --- End of file: Notifications.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/MachiningTools.cs ---
// --- Original Local Path: TrashRust/MachiningTools.cs ---

using Facepunch;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("MachiningTools", "Vlad-00003", "1.2.2", ResourceId = 89)]
    [Description("Creates tools that would gather refined materials from the resource nodes")]
    /*
     * Author info:
     *   E-mail: Vlad-00003@mail.ru
     *   Vk: vk.com/vlad_00003
     */
    class MachiningTools : RustPlugin
    {
        #region Vars⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        private PluginConfig _config;
        private readonly Dictionary<ItemDefinition, ItemDefinition> _itemToCookable = new Dictionary<ItemDefinition, ItemDefinition>();
        #endregion

        #region Config⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        private class Tool
        {
            [JsonProperty("Короткое имя предмета")]
            public string ShortName;
            [JsonProperty("ID скина предмета (Поддерживается Workshop)")]
            public ulong SkinId;
            [JsonProperty("Название предмета (Выводится в описании предмета в инвентаре)")]
            public string Name;
            [JsonProperty("Можно ли ремонтировать предмет")]
            public bool CanRepair;
            [JsonProperty("Можно ли перерабатывать предмет")]
            public bool CanRecycle;
            [JsonProperty("Настройки переработки")]
            public Transmutations Transmutation;

            private ItemDefinition _info;

            public bool ItemExists()
            {
                _info = ItemManager.FindItemDefinition(ShortName);
                if (_info == null)
                    return false;

                var itemModEntity = _info.GetComponent<ItemModEntity>();
                if (itemModEntity == null)
                    return false;

                var baseMelee = GameManager.server.FindPrefab(itemModEntity.entityPrefab?.resourcePath)?.GetComponent<BaseMelee>();
                return baseMelee != null;
            }

            public Item Create(int amount = 1)
            {
                Item item = ItemManager.Create(_info,amount, SkinId);
                item.name = Name;
                return item;
            }

            public int GetCustomHash()
            {
                unchecked
                {
                    return (string.IsNullOrEmpty(ShortName) ? 0 : ShortName.GetHashCode() * 397) ^ SkinId.GetHashCode();
                }
            }

            public static int GetCustomHash(Item item)
            {
                unchecked
                {
                    if (item == null)
                        return 0;
                    return (string.IsNullOrEmpty(item.info.shortname) ? 0 : item.info.shortname.GetHashCode() * 397) ^ item.skin.GetHashCode();
                }
            }
        }
        private class Transmutations
        {
            [JsonProperty("Перерабатывать дерево в уголь")]
            private bool _wood;
            [JsonProperty("Перерабатывать руду МВК в металл")]
            private bool _hqm;
            [JsonProperty("Перерабатывать металлическую руду в фрагменты")]
            private bool _metal;
            [JsonProperty("Перерабатывать серную руду в серу")]
            private bool _sulfur;
            [JsonProperty("Перерабатывать мясо медведя в жаренное")]
            private bool _bear;
            [JsonProperty("Перерабатывать свинину в жаренную")]
            private bool _boar;
            [JsonProperty("Перерабатывать мясо курицы в жаренное")]
            private bool _chicken;
            [JsonProperty("Перерабатывать мясо лошади в жаренное")]
            private bool _horse;
            [JsonProperty("Перерабатывать мясо волка в жаренное")]
            private bool _wolf;
            [JsonProperty("Перерабатывать мясо оленя в жаренное")]
            private bool _deer;
            [JsonProperty("Перерабатывать человеческое мясо в жаренное")]
            private bool _human;

            #region Default Config⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

            public static Transmutations DefaultPick => new Transmutations
            {
                _wood = false,
                _hqm = true,
                _metal = true,
                _sulfur = true,
                _bear = false,
                _boar = false,
                _chicken = false,
                _wolf = false,
                _deer = false,
                _human = false,
                _horse = false
            };

            public static Transmutations DefaultAxe => new Transmutations
            {
                _wood = true,
                _hqm = false,
                _metal = false,
                _sulfur = false,
                _bear = true,
                _boar = true,
                _chicken = true,
                _wolf = true,
                _deer = true,
                _human = true,
                _horse = true
            };

            #endregion
            
            // ReSharper disable StringLiteralTypo
            private IEnumerable<string> Settings
            {
                get
                {
                    if(_human)
                        yield return "humanmeat.raw";
                    if(_bear)
                        yield return "bearmeat";
                    if(_chicken)
                        yield return "chicken.raw";
                    if(_boar)
                        yield return "meat.boar";
                    if(_deer)
                        yield return "deermeat.raw";
                    if(_wolf)
                        yield return "wolfmeat.raw";
                    if(_sulfur)
                        yield return "sulfur.ore";
                    if(_metal)
                        yield return "metal.ore";
                    if(_wood)
                        yield return "wood";
                    if(_horse)
                        yield return "horsemeat.raw";
                    if(_hqm)
                        yield return "hq.metal.ore";
                }
            }
            // ReSharper restore StringLiteralTypo
            public bool ShouldCook(Item item)
            {
                return Settings.Any(x => item.info.shortname == x);
            }

        }
        private class PluginConfig
        {
            [JsonProperty("Привилегия для использования команд")]
            public string Permission;
            [JsonProperty("Команда(чат/консоль)")]
            public string Command;
            [JsonProperty("Список инструментов")]
            private Dictionary<string, Tool> _tools;

            [JsonIgnore] 
            private readonly Dictionary<int,KeyValuePair<string, Tool>> _toolsByHash = new Dictionary<int, KeyValuePair<string, Tool>>();
            [JsonIgnore]
            public readonly Dictionary<string, Tool> ToolsByKey = new Dictionary<string, Tool>();

            #region Default Config⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

            public static PluginConfig DefaultConfig => new PluginConfig
            {
                Permission = nameof(MachiningTools)+".use",
                Command = "GiveTool",
                _tools = new Dictionary<string, Tool>
                {
                    ["hatchet"] = new Tool
                    {
                        ShortName = "hatchet",
                        Name = "Магический топор",
                        CanRepair = true,
                        CanRecycle = true,
                        SkinId = 901876821,
                        Transmutation = Transmutations.DefaultAxe
                    },
                    ["pickaxe"] = new Tool
                    {
                        ShortName = "pickaxe",
                        Name = "Магическая кирка",
                        CanRepair = true,
                        CanRecycle = true,
                        SkinId = 902892485,
                        Transmutation = Transmutations.DefaultPick
                    },
                    ["icepick"] = new Tool
                    {
                        ShortName = "icepick.salvaged",
                        Name = "Магический ледоруб",
                        CanRepair = false,
                        CanRecycle = false,
                        SkinId = 804307574,
                        Transmutation = Transmutations.DefaultPick
                    },
                    ["axe"] = new Tool
                    {
                        ShortName = "axe.salvaged",
                        Name = "Магический топор",
                        CanRepair = false,
                        CanRecycle = false,
                        SkinId = 2057227617,
                        Transmutation = Transmutations.DefaultAxe
                    },
                    ["chainsaw"] = new Tool
                    {
                        ShortName = "chainsaw",
                        Name = "Магическая бензопила",
                        CanRepair = false,
                        CanRecycle = false,
                        SkinId = 2057228026,
                        Transmutation = Transmutations.DefaultAxe
                    },
                    ["jackhammer"] = new Tool
                    {
                        ShortName = "jackhammer",
                        Name = "Магический отбойный молоток",
                        CanRepair = false,
                        CanRecycle = false,
                        SkinId = 2057228546,
                        Transmutation = Transmutations.DefaultPick
                    }
                }

            };

            #endregion

            public string CheckConfig(RustPlugin plugin)
            {
                List<string> result = Pool.GetList<string>();
                foreach (var pair in _tools)
                {
                    //version < 1.2.0
                    var canRecycle = plugin.Config["Список инструментов", pair.Key, "Можно ли перерабатывать пердмет"];
                    if (canRecycle != null)
                    {
                        pair.Value.CanRecycle = plugin.Config.ConvertValue<bool>(canRecycle);
                        result.Add($"Typo in the property of item {pair.Key} fixed.");
                    }

                    if (!pair.Value.ItemExists())
                    {
                        result.Add($"Item {pair.Key} not found in the game or not BaseMelee and would not be used.");
                        continue;
                    }

                    KeyValuePair<string, Tool> defined;
                    var customHash = pair.Value.GetCustomHash();

                    if(TryGet(customHash, out defined))
                    {
                        result.Add($"Item {pair.Key} is using the same skin that was already defined by {defined.Key} and would not be used.");
                        continue;
                    }
                    ToolsByKey[pair.Key] = pair.Value;
                    _toolsByHash[customHash] = pair;
                }

                var res = result.Count > 0 ? string.Join("\n", result) : null;
                Pool.FreeList(ref result);
                return res;
            }

            public bool TryGet(Item item, out Tool tool)
            {
                tool = null;
                var customItemHash = Tool.GetCustomHash(item);
                if (customItemHash == 0)
                    return false;
                KeyValuePair<string, Tool> toolData;
                if (!TryGet(customItemHash, out toolData))
                    return false;
                tool = toolData.Value;
                return true;
            }

            private bool TryGet(int hash, out KeyValuePair<string, Tool> pair) =>
                _toolsByHash.TryGetValue(hash, out pair);
        }
        #endregion

        #region Config handling⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Благодарим за приобретение плагина на сайте RustPlugin.ru. Если вы приобрели этот плагин на другом ресурсе знайте - это лишает вас гарантированных обновлений!");
            _config = PluginConfig.DefaultConfig;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<PluginConfig>();

            var checkResult = _config.CheckConfig(this);
            if (checkResult == null) 
                return;
            PrintWarning(checkResult);
            SaveConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }
        #endregion

        #region Init and quiting⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        void Init()
        {
            AddCovalenceCommand(_config.Command, "GiveToolsCommand", _config.Permission);
        }

        void OnServerInitialized()
        {
            foreach (var itemDefinition in ItemManager.GetItemDefinitions())
            {
                var cookable = itemDefinition.GetComponent<ItemModCookable>();
                if (cookable)
                    _itemToCookable[itemDefinition] = cookable.becomeOnCooked;
            }
            _itemToCookable.Add(ItemManager.FindItemDefinition("wood"), ItemManager.FindItemDefinition("charcoal"));
        }

        #endregion

        #region Oxide Hooks⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        object OnItemSkinChange(int skin, Item item, RepairBench bench, BasePlayer player)
        {
            if (!IsMachiningToolItem(item))
                return null;
            Reply(player, "Can't change skin");
            return false;
        }

        object OnItemRepair(BasePlayer player, Item item)
        {

            Tool tool;
            if (!_config.TryGet(item, out tool))
                return null;
            if (tool.CanRepair)
                return null;
            Reply(player, "Can't repair");
            return false;
        }

        object CanRecycle(Recycler recycler, Item item)
        {
            Tool tool;
            if (!_config.TryGet(item, out tool))
                return null;
            return tool.CanRecycle ? (object) null : false;
        }

        void OnDispenserGather(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            if (!player)
                return;
            var activeItem = player?.GetActiveItem();
            if (activeItem == null)
                return;

            Tool tool;
            if (!_config.TryGet(activeItem, out tool))
                return;

            if (tool.Transmutation.ShouldCook(item)) 
                Transmute(item);
        }

        void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            ulong playerid = 294912;
            OnDispenserGather(dispenser, player, item);
        }

        #endregion

        #region Localization⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        private void Reply(IPlayer player, string langKey, params object[] args)
        {
            var format = GetMsg(langKey, player.Id);
            player.Reply(args.Length != 0 ? string.Format(format, args) : format);
        }

        private void Reply(BasePlayer player, string langKey, params object[] args)
        {
            var reply = 288;
            var format = GetMsg(langKey, player.UserIDString);
            player.ChatMessage(args.Length != 0 ? string.Format(format, args) : format);
        }

        private string GetMsg(string langKey, string userId = null) => lang.GetMessage(langKey, this, userId);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Syntax"] = "Incorrect syntax! Use: {0} <NameOrID> item [item2] [item3] ...",
                ["No items"] = "The following items don't exist in the config, none of the items were given to the player \"{0}\":\n{1}",
                ["No player"] = "Player \"{0}\" could not be found",
                ["Not on server"] = "Player \"{0}\" is not on the server",
                ["Multiply players"] = "Found multiply players:\n{0}",
                ["Successful"] = "Successfully gave player \"{0}\" tools:\n{1}",
                ["Can't repair"] = "You can not repair this tool!",
                ["Can't change skin"] = "You can not change skin of this tool!"
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Syntax"] = "Неверный синтаксис! Используйте: {0} <ИмяИлиID> предмет [предмет2] [предмет3] ...",
                ["No items"] = "Следующие предметы из списка не найдены, ни один предмет не выдан игроку \"{0}\":\n{1}",
                ["No player"] = "Игрок \"{0}\" не найден",
                ["Not on server"] = "Игрок \"{0}\" не находится на сервере",
                ["Multiply players"] = "Найдено несколько игроков:\n{0}",
                ["Successful"] = "Успешно выдали игроку \"{0}\" предметы:\n{1}",
                ["Can't repair"] = "Данный предмет не подлежит ремонту!",
                ["Can't change skin"] = "Вы не можете изменить скин этого инструмента!"
            }, this, "ru");
        }
        #endregion

        #region Command⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        private void GiveToolsCommand(IPlayer player, string command, string[] args)
        {
            if (args.Length < 2)
            {
                Reply(player, "Syntax", _config.Command);
                return;
            }
            var targets =  covalence.Players.FindPlayers(args[0]).ToList();
            if (targets.Count == 0)
            {
                Reply(player, "No player", args[0]);
                return;
            }
            if (targets.Count > 1)
            {
                Reply(player, "Multiply players", string.Join("\n", targets.Select(p => $"{p.Name} [{p.Id}]")));
                return;
            }
            var target = targets[0].Object as BasePlayer;
            if (!target || !target.IsAlive())
            {
                Reply(player, "Not on server", target);
                return;
            }

            var configNames = args.Skip(1).ToList();
            var wrongNames = string.Join(", ",configNames.Where(x => !_config.ToolsByKey.ContainsKey(x)));
            if (!string.IsNullOrEmpty(wrongNames))
            {
                Reply(player, "No items", target, wrongNames);
                return;
            }

            foreach (var configName in configNames)
            {
                Tool tool = _config.ToolsByKey[configName];
                target.GiveItem(tool.Create());
            }
            Reply(player, "Successful", target, string.Join(", ", configNames));
        }
        #endregion

        #region API⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        [HookMethod("IsMachiningToolItem")]
        bool IsMachiningToolItem(Item item)
        {
            if (item == null)
                return false;
            Tool tool;
            return _config.TryGet(item, out tool);
        }

        #endregion

        #region Helpers⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        private void Transmute(Item item)
        {
            if (!_itemToCookable.ContainsKey(item.info))
            {
                PrintWarning($"[MachiningTools.Transmute] Unhandled item - {item.info.displayName.english}!\nPlease contact developer: https://vk.com/vlad_00003");
                return;
            }
            item.info = _itemToCookable[item.info];
        }
        #endregion
    }
}
///////////////////////////////////////////////////////////


// --- End of file: MachiningTools.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/TreePlanter.cs ---
// --- Original Local Path: TrashRust/TreePlanter.cs ---

using System.Collections.Generic;
using System.Text;
using UnityEngine;
using Oxide.Core.Plugins;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Tree Planter", "Bazz3l", "1.1.2")]
    [Description("Buy and plant trees in building authed areas using in-game currency.")]
    class TreePlanter : RustPlugin
    {
        [PluginReference]
        Plugin ServerRewards, Economics;

        #region Fields
        const string _permUse = "treeplanter.use";
        ConfigData _config;
        #endregion

        #region Config
        ConfigData GetDefaultConfig()
        {
            return new ConfigData {
                UseServerRewards = true,
                UseEconomics = false,
                UseCurrency = false,
                OwnerOnly = false,
                CurrencyItemID = -932201673,
                Items = new List<TreeConfig> {
                    new TreeConfig("oak", new List<string> {
                        "assets/bundled/prefabs/autospawn/resource/v2_temp_field_large/oak_a.prefab",
                        "assets/bundled/prefabs/autospawn/resource/v2_temp_field_large/oak_b.prefab",
                        "assets/bundled/prefabs/autospawn/resource/v2_temp_field_large/oak_c.prefab"
                    }),
                    new TreeConfig("birch", new List<string> {
                        "assets/bundled/prefabs/autospawn/resource/v2_temp_forest/birch_small_temp.prefab",
                        "assets/bundled/prefabs/autospawn/resource/v2_temp_forest/birch_medium_temp.prefab",
                        "assets/bundled/prefabs/autospawn/resource/v2_temp_forest/birch_large_temp.prefab"
                    }),
                    new TreeConfig("douglas", new List<string> {
                        "assets/bundled/prefabs/autospawn/resource/v2_arctic_forest/douglas_fir_a_snow.prefab",
                        "assets/bundled/prefabs/autospawn/resource/v2_arctic_forest/douglas_fir_b_snow.prefab",
                        "assets/bundled/prefabs/autospawn/resource/v2_arctic_forest/douglas_fir_c_snow.prefab"
                    }),
                    new TreeConfig("swamp", new List<string> {
                        "assets/bundled/prefabs/autospawn/resource/swamp-trees/swamp_tree_a.prefab",
                        "assets/bundled/prefabs/autospawn/resource/swamp-trees/swamp_tree_b.prefab",
                        "assets/bundled/prefabs/autospawn/resource/swamp-trees/swamp_tree_c.prefab"
                    }),
                    new TreeConfig("palm", new List<string> {
                        "assets/bundled/prefabs/autospawn/resource/v2_arid_forest/palm_tree_small_c_entity.prefab",
                        "assets/bundled/prefabs/autospawn/resource/v2_arid_forest/palm_tree_med_a_entity.prefab",
                        "assets/bundled/prefabs/autospawn/resource/v2_arid_forest/palm_tree_tall_a_entity.prefab"
                    }),
                    new TreeConfig("pine", new List<string> {
                        "assets/bundled/prefabs/autospawn/resource/v2_arctic_forest_snow/pine_a_snow.prefab",
                        "assets/bundled/prefabs/autospawn/resource/v2_arctic_forest_snow/pine_b snow.prefab",
                        "assets/bundled/prefabs/autospawn/resource/v2_arctic_forest_snow/pine_c_snow.prefab"
                    })
                }
            };
        }

        class ConfigData
        {
            public bool UseServerRewards;
            public bool UseEconomics;
            public bool UseCurrency;
            public bool OwnerOnly;
            public int CurrencyItemID;
            public List<TreeConfig> Items;

            public TreeConfig FindItemByName(string name) => Items.Find(x => x.Name == name);
        }

        class TreeConfig
        {
            public string Name;
            public int Cost = 10;
            public int Amount = 1;
            public List<string> Prefabs;

            public TreeConfig(string name, List<string> prefabs)
            {
                Name = name;
                Prefabs = prefabs;
            }
        }
        #endregion

        #region Oxide
        protected override void LoadDefaultConfig() => Config.WriteObject(GetDefaultConfig(), true);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string> {
                {"Prefix", "<color=#DC143C>Tree Planter</color>:"},
                {"NoPermission", "No permission"},
                {"Balance", "You do not have enough for that."},
                {"Planted", "You planted a tree."},
                {"Authed", "You must have build privlage."},
                {"Planter", "Can not be placed in a planter."},
                {"Given", "You received {0} ({1})."},
                {"Cost", "\n{0}"},
                {"Error", "Something went wrong."},
                {"Invalid", "Invalid type."},
            }, this);
        }

        void OnServerInitialized()
        {
            permission.RegisterPermission(_permUse, this);
        }

        void Init()
        {
            _config = Config.ReadObject<ConfigData>();
        }

        object OnMeleeAttack(BasePlayer player, HitInfo info)
        {
            BaseEntity ent = info?.HitEntity;

            if (ent == null || ent.OwnerID == 0UL || !IsTree(ent.ShortPrefabName))
            {
                return null;
            }

            if (_config.OwnerOnly && !IsOwner(player.userID, ent.OwnerID))
            {
                info.damageTypes.ScaleAll(0.0f);

                return false;
            }

            return null;
        }

        void OnEntityBuilt(Planner plan, GameObject seed)
        {
            BasePlayer player = plan.GetOwnerPlayer();
            if (player == null || !permission.UserHasPermission(player.UserIDString, _permUse))
            {
                return;
            }

            GrowableEntity plant = seed.GetComponent<GrowableEntity>();
            if (plant == null)
            {
                return;
            }

            Item item = player.GetActiveItem();
            if (item == null)
            {
                return;
            }

            TreeConfig tree = _config.FindItemByName(item.name);
            if (tree == null)
            {
                return;
            }

            NextTick(() => {
                if (plant.GetParentEntity() is PlanterBox)
                {
                    RefundItem(player, item.name);

                    plant?.Kill(BaseNetworkable.DestroyMode.None);

                    player.ChatMessage(Lang("Planter", player.UserIDString));
                    return;
                }

                if (!player.IsBuildingAuthed())
                {
                    RefundItem(player, item.name);

                    plant?.Kill(BaseNetworkable.DestroyMode.None);

                    player.ChatMessage(Lang("Authed", player.UserIDString));
                    return;
                }

                PlantTree(player, plant, tree.Prefabs.GetRandom());
            });
        }
		
		[ConsoleCommand("derevogive")]
		private void GiveCommand(ConsoleSystem.Arg arg)
		{
            if (arg.IsServerside)
            {
                TreeConfig tree = _config.FindItemByName(string.Join(" ", arg.Args.Skip(1)));
                Item item = CreateItem(tree.Name, tree.Amount);

                BasePlayer player = BasePlayer.FindByID(ulong.Parse(arg.Args[0]));
                if(player != null && tree != null)
                {
                    player.GiveItem(item);
                }
            }
		}

        [ChatCommand("derevogive")]
        void BuyCommand(BasePlayer player, string cmd, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, _permUse))
            {
                player.ChatMessage(Lang("NoPermission", player.UserIDString));
                return;
            }

            if (args.Length != 1)
            {
                StringBuilder sb = new StringBuilder();

                sb.Append(Lang("Prefix", player.UserIDString));

                foreach (TreeConfig tc in _config.Items)
                {
                    sb.Append(Lang("Cost", player.UserIDString, tc.Name, tc.Cost));
                }

                player.ChatMessage(sb.ToString());
                return;
            }

            TreeConfig tree = _config.FindItemByName(string.Join(" ", args));
            if (tree == null)
            {
                player.ChatMessage(Lang("Invalid", player.UserIDString));
                return;
            }

            if (!CheckBalance(player, tree.Cost))
            {
                player.ChatMessage(Lang("Balance", player.UserIDString));
                return;
            }

            Item item = CreateItem(tree.Name, tree.Amount);
            if (item == null)
            {
                player.ChatMessage(Lang("Error", player.UserIDString));
                return;
            }

            BalanceTake(player, tree.Cost);

            player.GiveItem(item);

            player.ChatMessage(Lang("Given", player.UserIDString, tree.Amount, tree.Name));
        }
        #endregion

        #region Core
        void PlantTree(BasePlayer player, GrowableEntity plant, string prefabName)
        {
            BaseEntity entity = GameManager.server.CreateEntity(prefabName, plant.transform.position, Quaternion.identity);
            if (entity == null)
            {
                return;
            }

            entity.OwnerID = player.userID;
            entity.Spawn();

            plant?.Kill();

            player.ChatMessage(Lang("Planted", player.UserIDString));
        }

        bool CheckBalance(BasePlayer player, int cost)
        {
            if (_config.UseServerRewards && ServerRewards?.Call<int>("CheckPoints", player.userID) >= cost)
            {
                return true;
            }

            if (_config.UseEconomics && Economics?.Call<double>("Balance", player.userID) >= (double) cost)
            {
                return true;
            }

            if (_config.UseCurrency && player.inventory.GetAmount(_config.CurrencyItemID) >= cost)
            {
                return true;
            }

            return false;
        }

        void BalanceTake(BasePlayer player, int cost)
        {
            if (_config.UseServerRewards)
            {
                ServerRewards?.Call<object>("TakePoints", player.userID, cost, null);
            }

            if (_config.UseEconomics)
            {
                Economics?.Call<object>("Withdraw", player.userID, (double) cost);
            }

            if (_config.UseCurrency)
            {
                player.inventory.Take(new List<Item>(), _config.CurrencyItemID, cost);
            }
        }

        Item CreateItem(string treeType, int treeAmount = 1)
        {
            Item item = ItemManager.CreateByName("clone.hemp", treeAmount);
            item.name = treeType;
            item.info.stackable = 1;
            return item;
        }

        void RefundItem(BasePlayer player, string treeType)
        {
            Item refundItem = CreateItem(treeType);

            if (refundItem == null)
            {
                player.ChatMessage(Lang("Error", player.UserIDString));
                return;
            }

            player.GiveItem(refundItem);
        }

        bool IsOwner(ulong userID, ulong ownerID)
        {
            return userID == ownerID;
        }

        bool IsTree(string prefab)
        {
            if (prefab.Contains("oak_") 
            || prefab.Contains("birch_") 
            || prefab.Contains("douglas_") 
            || prefab.Contains("swamp_") 
            || prefab.Contains("palm_") 
            || prefab.Contains("pine_"))
            {
                return true;
            }

            return false;
        }
        #endregion

        #region Helpers
        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
        #endregion
    }
}

// --- End of file: TreePlanter.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/BanSystem.cs ---
// --- Original Local Path: TrashRust/BanSystem.cs ---

﻿using System.Collections.Generic;
using Newtonsoft.Json;
using System;
using System.Linq;
using Network;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("BanSystem", "RusskiIvan", "1.0.6")]
    [Description("BanSystem")]
    public class BanSystem : RustPlugin
    {
        [PluginReference] private Plugin DiscordMessages;

        #region Variables

        private static Oxide.Core.MySql.Libraries.MySql Sql = Interface.Oxide.GetLibrary<Oxide.Core.MySql.Libraries.MySql>();
        private static Core.Database.Connection Sql_conn;
        private List<ulong> CheckSumList = new List<ulong>();
        private bool DiscordNotification;
        private string _database = "ServerBans";
        private ConfigData _config;
        private string DiscordAlertWebhookURL;
        private string DiscordBanWebhookURL;
        private string DiscordDebugWebhookURL;
        private string _moderatorID = "70000000000000000";
        private string _moderatorName = "Server";
        private DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        private const string PlayerStr = "http://api.steampowered.com/ISteamUser/GetPlayerSummaries/v0002/?key={0}&steamids={1}";

        #endregion

        #region Configuration

        private class ConfigData
        {
            [JsonProperty("Привилегии")] public Permissions permissions { get; set; }
            [JsonProperty("Настройки")] public Settings settings { get; set; }
            [JsonProperty("База данных MySQL")] public MySQL mySQL { get; set; }
        }

        public class Permissions
        {
            [JsonProperty("Забанить игрока")] public string PermissionBan { get; set; }
            [JsonProperty("Разбанить игрока")] public string PermissionUnban { get; set; }
            [JsonProperty("Забанить модератора")] public string PermissionBanModerator { get; set; }
        }

        public class Settings
        {
            [JsonProperty("Название сервера")]
            public string Server { get; set; }

            [JsonProperty("SteamID модераторов и их ники для записи в базу (если модератора нет в списке пишется его имя в игре")]
            public Dictionary<string, string> moderatorList { get; set; }
            [JsonProperty("Звук бана игрока")] public string Ban_sound { get; set; }
            [JsonProperty("Причина бана")] public string BanDefaultReason { get; set; }

            [JsonProperty("Сообщение в чат при бане игрока")]
            public bool Ban_Broadcast { get; set; }

            [JsonProperty("Логировать бан игроков")]
            public bool Ban_Log { get; set; }

            [JsonProperty("Discord оповещение")] public bool Discord_use { get; set; }
            [JsonProperty("Discord hook")] public string Discord_Webhook { get; set; }
            [JsonProperty("Steam api key (для поиска имен игроков в оффлайне)")] public string SteamApi { get; set; }

            [JsonProperty("Список белых IP (другие игроки с этих адресов не будут блокироваться)")]
            public List<string> NoBlockIpList { get; set; }
        }

        public class MySQL
        {
            [JsonProperty("Адрес хоста")] public string MySQL_Host { get; set; }
            [JsonProperty("Порт")] public int MySQL_Port { get; set; }
            [JsonProperty("База данных")] public string MySQL_DB { get; set; }
            [JsonProperty("Пользователь")] public string MySQL_User { get; set; }
            [JsonProperty("Пароль")] public string MySQL_Pass { get; set; }
        }

        protected override void LoadDefaultConfig()
        {
            ConfigData config = new ConfigData
            {
                settings = new Settings()
                {
                    Server = ConVar.Server.hostname.Split('[')[0],
                    Ban_sound = "assets/bundled/prefabs/fx/player/howl.prefab",
                    SteamApi = "",
                    BanDefaultReason = "Banned",
                    Ban_Broadcast = true,
                    Ban_Log = true,
                    Discord_use = true,
                    Discord_Webhook = "",
                    moderatorList = new Dictionary<string, string>()
                    {
                        {"STEAMID", "Name"}
                    },
                    NoBlockIpList = new List<string>()
                    {
                        "ip"
                    }
                },

                permissions = new Permissions()
                {
                    PermissionBan = $"{Name}.ban".ToLower(),
                    PermissionBanModerator = $"{Name}.mainmoder".ToLower(),
                    PermissionUnban = Name + $"{Name}.unban".ToLower()
                },
                mySQL = new MySQL()
                {
                    MySQL_Host = "ip",
                    MySQL_Port = 0,
                    MySQL_DB = "rust",
                    MySQL_User = "rust",
                    MySQL_Pass = "passwd",
                }
            };
            SaveConfig(config);
            PrintWarning("Creating default a configuration file ...");
        }

        private void LoadConfigVariables() => _config = Config.ReadObject<ConfigData>();
        private void SaveConfig(ConfigData config) => Config.WriteObject(config, true);

        #endregion

        #region Commands

        [ConsoleCommand("player.ban")]
        private void ConsoleCmdBan(ConsoleSystem.Arg arg)
        {
            ulong targetID;
            int duration = 0;
            var player = arg.Player();
            if (player != null && !permission.UserHasPermission(player.UserIDString, _config.permissions.PermissionBan.ToLower()))
            {
                SendReply(player,
                    Msg("NoAccess", player.UserIDString));
                return;
            }
            var reason = "";
            if (!arg.HasArgs())
            {
                PrintWarning(Msg("BanSyntax"));
                return;
            }
            if (arg.Args.Length < 2)
            {
                PrintWarning(Msg("BanSyntax"));
                return;
            }
            if (ulong.TryParse(arg.Args[0], out targetID) && targetID < 76560000000000000)
            {
                PrintWarning(Msg("BanSyntax"));
                return;
            }
            if (player != null)
            {
                ServerUsers.User user = ServerUsers.Get(targetID);
                if (user != null && user.@group == ServerUsers.UserGroup.Owner)
                {
                    SendToPlayer(string.Format(Msg("CantBanOwner", player.UserIDString), targetID), player);
                    return;
                }
                if (user != null && user.@group == ServerUsers.UserGroup.Moderator && !permission.UserHasPermission(player.UserIDString, _config.permissions.PermissionBanModerator.ToLower()))
                {
                    SendToPlayer(string.Format(Msg("CantBanModerator", player.UserIDString), targetID), player);
                    return;
                }
            }
            if (arg.Args.Length == 2) reason = arg.Args[1];
            else
            {
                var length = arg.Args.Length;
                if (int.TryParse(arg.Args[arg.Args.Length - 1], out duration)) length = arg.Args.Length - 1;
                for (int i = 1; i < length; i++)
                {
                    if (!string.IsNullOrEmpty(reason)) reason += " ";
                    reason += arg.Args[i];
                }
            }
            var target = BasePlayer.FindByID(targetID);
            var moderatorName = _moderatorName;
            var moderatorID = _moderatorID;
            if (player != null)
            {
                moderatorName = ModeratorName(player.userID);
                moderatorID = player.UserIDString;
            }
            var message = duration == 0
                ? Msg("ExitMessagePermBan", targetID.ToString())
                : string.Format(Msg("ExitMessageTempBan", targetID.ToString()), "<color=#FFA500>" + duration + Msg("day", targetID.ToString()) + "</color>");
            if (target == null)
            {
                //Puts($"Offline BAN: {targetID.ToString()}, {player.userID}, {moderatorName}, {reason}, {duration}");
                OfflineBan(targetID.ToString(), moderatorID, moderatorName, message, reason, duration);
                return;
            }
            var ip = GetIPAddress(target.net.connection.ipaddress);
            //Puts($"online BAN: {target}, {player.userID}, {player.displayName}, {ip}, {message}, {reason}, {duration}");

            BanPlayer(target, moderatorID, moderatorName, ip, message, reason, duration, true);
        }

        [ConsoleCommand("player.unban")]
        private void ConsoleCmdUnban(ConsoleSystem.Arg arg)
        {
            ulong targetID;
            var player = arg.Player();
            if (player != null && !permission.UserHasPermission(player.UserIDString, _config.permissions.PermissionUnban.ToLower()))
            {
                SendReply(player,
                    Msg("NoAccess", player.UserIDString));
                return;
            }
            if (!arg.HasArgs())
            {
                PrintWarning(Msg("UnbanSyntax"));
                return;
            }
            if (arg.Args.Length > 1)
            {
                PrintWarning(Msg("UnbanSyntax"));
                return;
            }
            if (ulong.TryParse(arg.Args[0], out targetID) && targetID < 76560000000000000)
            {
                PrintWarning(Msg("UnbanSyntax"));
                return;
            }

            if (player != null)
            {
                UnBanPlayer(targetID, player);
            }
            else
            {
                UnBanPlayer(targetID);
            }

        }

        [ChatCommand("ban")]
        private void ChatCmdBan(BasePlayer player, string command, string[] arg)
        {
            if (!permission.UserHasPermission(player.UserIDString, _config.permissions.PermissionBan.ToLower()))
            {
                SendReply(player,
                    Msg("NoAccess", player.UserIDString));
                return;
            }
            if (arg == null)
            {
                SendReply(player, Msg("BanSyntax", player.UserIDString));
                return;
            }
            if (arg.Length < 2)
            {
                SendReply(player, Msg("BanSyntax", player.UserIDString));
                return;
            }
            int duration = 0;
            var reason = "";
            ulong targetID;
            if (ulong.TryParse(arg[0], out targetID) && targetID < 76560000000000000)
            {
                SendReply(player, Msg("BanSyntax", player.UserIDString));
                return;
            }
            ServerUsers.User user = ServerUsers.Get(targetID);
            if (user != null && user.@group == ServerUsers.UserGroup.Owner)
            {
                SendToPlayer(string.Format(Msg("CantBanOwner", player.UserIDString), targetID), player);
                return;
            }
            if (user != null && user.@group == ServerUsers.UserGroup.Moderator && !permission.UserHasPermission(player.UserIDString, _config.permissions.PermissionBanModerator.ToLower()))
            {
                SendToPlayer(string.Format(Msg("CantBanModerator", player.UserIDString), targetID), player);
                return;
            }
            if (arg.Length == 2) reason = arg[1];
            else
            {
                var length = arg.Length;
                if (int.TryParse(arg[arg.Length - 1], out duration)) length = arg.Length - 1;
                for (int i = 1; i < length; i++)
                {
                    if (!string.IsNullOrEmpty(reason)) reason += " ";
                    reason += arg[i];
                }
            }
            var target = BasePlayer.FindByID(targetID);
            var moderatorName = ModeratorName(player.userID);
            var message = duration == 0
                ? Msg("ExitMessagePermBan", targetID.ToString())
                : string.Format(Msg("ExitMessageTempBan", targetID.ToString()), "<color=#FFA500>" + duration + Msg("day", targetID.ToString()) + "</color>");
            if (target == null)
            {
                //Puts($"Offline BAN: {targetID.ToString()}, {player.userID}, {moderatorName}, {reason}, {duration}");
                OfflineBan(targetID.ToString(), player.UserIDString, moderatorName, message, reason, duration);
                return;
            }
            var ip = GetIPAddress(target.net.connection.ipaddress);
            //Puts($"online BAN: {target}, {player.userID}, {player.displayName}, {ip}, {message}, {reason}, {duration}");
            BanPlayer(target, player.UserIDString, moderatorName, ip, message, reason, duration, true);
        }

        [ChatCommand("unban")]
        private void ChatCmdUnan(BasePlayer player, string command, string[] arg)
        {
            ulong targetID;
            if (!permission.UserHasPermission(player.UserIDString, _config.permissions.PermissionUnban.ToLower()))
            {
                SendReply(player,
                    Msg("NoAccess", player.UserIDString));
                return;
            }
            if (arg == null)
            {
                PrintWarning(Msg("UnbanSyntax"));
                return;
            }
            if (arg.Length > 1)
            {
                PrintWarning(Msg("UnbanSyntax"));
                return;
            }
            if (ulong.TryParse(arg[0], out targetID) && targetID < 76560000000000000)
            {
                PrintWarning(Msg("UnbanSyntax"));
                return;
            }
            UnBanPlayer(targetID, player);
        }

        #endregion

        #region Oxide

        private void Loaded() => LoadConfigVariables();
        private void OnClientAuth(Connection connection, object AddQueue) => CheckPlayer(connection);
        private void OnPlayerConnected(BasePlayer player) => CheckSharedAcc(player, player.net.connection.ownerid, GetIPAddress(player.net.connection.ipaddress));
        private void Init() => Unsubscribe("OnServerCommand");

        [HookMethod("OnServerCommand")]
        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            string command = arg.cmd?.Name;
            if (command == null)
            {
                return null;
            }
            switch (command)
            {
                case "ban":
                    ConsoleCmdBan(arg);
                    return false;
                case "banid":
                    ConsoleCmdBan(arg);
                    return false;
                case "unban":
                    ConsoleCmdUnban(arg);
                    return false;
                default:
                    return null;
            }
        }

        private void OnServerInitialized()
        {
            RegisterPermissions();
            LoadDatabase();
            Subscribe("OnServerCommand");
            DiscordBanWebhookURL = _config.settings.Discord_Webhook;
            DiscordAlertWebhookURL = _config.settings.Discord_Webhook;
            DiscordDebugWebhookURL = _config.settings.Discord_Webhook;
            DiscordNotification = DiscordNotify();
        }

        #endregion

        #region Helpers

        private string SplitIP(string ip)
        {
            var ipSplit = ip.Split('.');
            return ipSplit[0] + "." + ipSplit[1] + "." + ipSplit[2];
        }
        private void KickPlayer(Connection connection, string reason)
        {
            Net.sv.Kick(connection, reason);
        }
        private bool DiscordNotify()
        {
            if (!DiscordMessages) return false;
            if (!_config.settings.Discord_use) return false;
            if (string.IsNullOrEmpty(_config.settings.Discord_Webhook)) return false;
            return true;
        }
        private enum ResponseCode
        {
            Valid = 200,
            InvalidKey = 403,
            Unavailable = 503,
        }
        private bool IsValidRequest(ResponseCode code)
        {
            switch (code)
            {
                case ResponseCode.Valid:
                    return true;

                case ResponseCode.InvalidKey:
                    Puts("ErrorInvalidKey");
                    return false;

                case ResponseCode.Unavailable:
                    Puts("ErrorServiceUnavailable");
                    return false;

                default:
                    Puts("ErrorUnknown");
                    return false;
            }
        }
        private void GetResponce<T>(string url, Action<T> callback)
        {
            webrequest.Enqueue(url, null, (code, response) =>
            {
                try
                {
                    T query = JsonConvert.DeserializeObject<T>(response, new JsonSerializerSettings());
                    if (query == null)
                    {
                        if (IsValidRequest((ResponseCode)code)) return;
                        Puts($"Ошибка соединения с сервером {url} ...[{IsValidRequest((ResponseCode)code)}]");
                    }
                    else
                    {
                        callback.Invoke(query);
                    }
                }
                catch { }
            }, this);
        }
        private void SendNotification(string targetID, string targetName, string moderatorID, string moderatorName, string reason, string ip, int duration = 0)
        {
            if (_config.settings.Ban_Broadcast)
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    var serverMessage = duration == 0
                        ? string.Format(Msg("PlayerBanned", player.UserIDString), targetName, reason)
                        : string.Format(Msg("PlayerBannedTemp", player.UserIDString), targetName, duration + Msg("day", player.UserIDString), reason);
                    SendReply(player, $"{serverMessage}");
                    if (!string.IsNullOrEmpty(_config.settings.Ban_sound)) Effect.server.Run("assets/bundled/prefabs/fx/player/howl.prefab", player.transform.position);
                }
            }
            if (!DiscordNotification) return;
            var expire = "НИКОГДА";
            if (string.IsNullOrEmpty(ip)) ip = "не указан";
            if (duration != 0)
            {
                expire = DateTime.Now.AddDays(duration).ToString("dd.MM.yyyy HH:mm:ss");
            }
            var text = moderatorName == _moderatorName ? $"{_moderatorName}" : $"{moderatorName} [{moderatorID}]";
            var fields = new List<SendList>
            {
                new SendList()
                {
                    name = $":technologist: {targetName}",
                    inline = true,
                    value = $"[{targetID}]"
                },
                new SendList()
                {
                    name = ":file_cabinet: IP:",
                    inline = true,
                    value = ip
                },
                new SendList()
                {
                    name = ":clock8: Дата:",
                    inline = true,
                    value = $"[{DateTime.Now:dd.MM.yyyy HH:mm:ss}]"
                },
                new SendList()
                {
                    name = ":link: Ссылки:",
                    inline = true,
                    value = $"\n[Профиль Steam](https://steamcommunity.com/profiles/{targetID})\n[База чекера](https://rustcheatcheck.ru/panel/player/{targetID})"
                },
                new SendList()
                {
                    name = ":scales: Причина:",
                    inline = true,
                    value = "``" + reason + "``"
                },
                new SendList()
                {
                    name = ":stopwatch: Бан истекает:",
                    inline = true,
                    value = $"[{expire}]"
                },
                new SendList()
                {
                    name = ":judge: Забанил:",
                    inline = false,
                    value = text
                },

            };
            DiscordMessages.Call("API_SendFancyMessage", DiscordBanWebhookURL, ":no_entry: БАН на " + _config.settings.Server, 11111199, JsonConvert.SerializeObject(fields.Cast<object>().ToArray()));
            fields.Clear();
        }
        private void SendToPlayer(string message, BasePlayer player = null)
        {
            if (player != null) SendReply(player, message);
            else PrintWarning(message);
        }
        private string GetSignature(string reason, ulong id, string signature = null)
        {
            if (reason == null) return _config.settings.BanDefaultReason;
            if (!string.IsNullOrEmpty(signature)) return $"{reason} | {signature}";
            foreach (var data in _config.settings.moderatorList.Where(data => data.Key == id.ToString()))
            {
                signature = data.Value;
            }
            return string.IsNullOrEmpty(signature) ? $"{reason} | AutoBan" : $"{reason} | by {signature}";
        }
        private string ModeratorName(ulong id)
        {
            return _config.settings.moderatorList.ContainsKey(id.ToString()) ? _config.settings.moderatorList[id.ToString()] : BasePlayer.FindByID(id).ToString();
        }
        private void IPValidate(Connection connection, string ip)
        {
            if (!DiscordNotification) return;
            if (string.IsNullOrEmpty(ip)) return;
            Sql.Query(
                    Core.Database.Sql.Builder.Append(
                        $"SELECT `steamid`, `date`, `name`, `ip`, `moderatorid`, `reason`, `expire`, `moderatorName` FROM {_database} WHERE `ip`LIKE '%{SplitIP(ip)}%'"), Sql_conn,
                    responseID =>
                    {
                        if (responseID.Count == 0) return;
                        var field = new List<SendList>();
                        field.Add(new SendList
                        {
                            name = $":technologist: {connection.username}\n[{connection.userid}]",
                            inline = true,
                            value = $"\n[Профиль Steam](https://steamcommunity.com/profiles/{connection.userid})\n[База чекера](https://rustcheatcheck.ru/panel/player/{connection.userid})"
                        });
                        field.Add(new SendList
                        {
                            name = "Возможно пользователь смен