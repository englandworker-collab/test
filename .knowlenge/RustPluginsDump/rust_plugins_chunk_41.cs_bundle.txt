ил IP адрес",
                            inline = true,
                            value = $":exclamation: :exclamation: :exclamation: :exclamation: :exclamation: :exclamation:"
                        });
                        field.Add(new SendList
                        {
                            name = "IP:",
                            inline = true,
                            value = $"{ip} [[Локация]](https://ip-api.com/#{ip})"
                        });
                        field.Add(new SendList
                        {
                            name = "АККАУНТ В БАНЕ:",
                            inline = false,
                            value = ":point_down: :point_down: :point_down: :point_down:"
                        });
                        foreach (var data in responseID)
                        {
                            var name = data["name"].ToString();
                            var id = data["steamid"].ToString();
                            var date = data["date"].ToString();
                            var text = data["moderatorName"].ToString() == _moderatorName
                                ? $"{_moderatorName}"
                                : $"{data["moderatorName"]} [{data["moderatorid"]}]";
                            var expire = "НИКОГДА";
                            var duration = int.Parse(data["expire"].ToString());
                            if (int.Parse(data["expire"].ToString()) != 0) expire = epoch.AddSeconds(duration).ToString();
                            field.Add(new SendList
                            {
                                name = $":technologist: {name}",
                                inline = true,
                                value = $"[{id}]"
                            });
                            field.Add(new SendList
                            {
                                name = ":file_cabinet: IP:",
                                inline = true,
                                value = $"{data["ip"]} [[Локация]](https://ip-api.com/#{data["ip"]})"
                            });
                            field.Add(new SendList
                            {
                                name = ":clock8: Дата:",
                                inline = true,
                                value = $"[{date}]"
                            });
                            field.Add(new SendList
                            {
                                name = ":link: Ссылки:",
                                inline = true,
                                value =
                                    $"\n[Профиль Steam](https://steamcommunity.com/profiles/{id})\n[База чекера](https://rustcheatcheck.ru/panel/player/{id})"
                            });
                            field.Add(new SendList
                            {
                                name = ":scales: Причина:",
                                inline = true,
                                value = "``" + data["reason"] + "``"
                            });
                            field.Add(new SendList
                            {
                                name = ":stopwatch: Бан истекает:",
                                inline = true,
                                value = $"[{expire}]"
                            });
                            field.Add(new SendList
                            {
                                name = ":judge: Забанил:",
                                inline = false,
                                value = text
                            });
                        }
                        DiscordMessages.Call("API_SendFancyMessage", DiscordAlertWebhookURL,
                                "!!!" + _config.settings.Server, 11111199,
                                JsonConvert.SerializeObject(field.Cast<object>().ToArray()));
                        field.Clear();
                    });
        }

        [HookMethod("GetIPAddress")]
        private string GetIPAddress(string ip)
        {
            var IP = ip.Split(':')[0];
            if (_config.settings.NoBlockIpList.Contains(IP)) IP = "";
            return IP;
        }
        private BasePlayer FindPlayerName(ulong userId)
        {
            BasePlayer player = BasePlayer.FindByID(userId);
            if (player) return player;
            player = BasePlayer.FindSleeping(userId);
            if (player) return player;
            BasePlayer target = covalence.Players.FindPlayer(userId.ToString()) as BasePlayer;
            return target != null ? target : null;
        }
        private string GetExpiredTime(string target, int timestamp)
        {
            if (timestamp == 0) return null;
            var timeLeft = (epoch.AddSeconds(timestamp) - DateTime.Now).ToString().Split('.');
            if (timeLeft.Length != 3 && timeLeft.Length != 2) return null;
            var days = timeLeft.Length == 3 ? timeLeft[0] + " " + Msg("day", target) : "";
            var time = timeLeft.Length == 3 ? timeLeft[1] : timeLeft[0];
            var text = "";
            text = time == "00:00:00"
                ? days
                : days + " " + time;
            return text;
        }

        #endregion


        #region Functions
        private void RegisterPermissions()
        {
            if (!permission.PermissionExists(_config.permissions.PermissionBan.ToLower()))
                permission.RegisterPermission(_config.permissions.PermissionBan.ToLower(), this);
            if (!permission.PermissionExists(_config.permissions.PermissionBanModerator.ToLower()))
                permission.RegisterPermission(_config.permissions.PermissionBanModerator.ToLower(), this);
            if (!permission.PermissionExists(_config.permissions.PermissionUnban.ToLower()))
                permission.RegisterPermission(_config.permissions.PermissionUnban.ToLower(), this);
        }
        private void CheckSharedAcc(BasePlayer target, ulong sharedID, string ip)
        {
            if (!CheckSumList.Contains(target.userID))
            {
                var field = new List<SendList>();
                field.Add(new SendList
                {
                    name = $":technologist: {target.displayName}\n[{target.userID}]",
                    inline = true,
                    value = $"\n[Профиль Steam](https://steamcommunity.com/profiles/{target.userID})\n[База чекера](https://rustcheatcheck.ru/panel/player/{target.userID})"
                });
                field.Add(new SendList
                {
                    name = "ИГРОК НЕ БЫЛ ПРОВЕРЕН В БАН ЛИСТЕ!",
                    inline = true,
                    value = $":exclamation: :exclamation: :exclamation: :exclamation: :exclamation: :exclamation:"
                });
                field.Add(new SendList
                {
                    name = "IP:",
                    inline = true,
                    value = $"{ip} [[Локация]](https://ip-api.com/#{ip})"
                });

                DiscordMessages.Call("API_SendFancyMessage", DiscordAlertWebhookURL,
                        "!!! ОШИБКА " + _config.settings.Server, 11111199,
                        JsonConvert.SerializeObject(field.Cast<object>().ToArray()));
                field.Clear();
            }
            else
                CheckSumList.Remove(target.userID);

            if (target.userID == sharedID) return;
            try
            {
                Sql.Query(Core.Database.Sql.Builder.Append($"SELECT `expire`, `reason`, `ip`, `moderatorid`, `moderatorName` FROM {_database} WHERE `steamid` = @0", sharedID), Sql_conn, responseID =>
                {
                    if (responseID.Count == 0) return;
                    var expireID = int.Parse(responseID[0]["expire"].ToString());
                    //Puts("++++Игрок есть в базе!");
                    //Puts("++++Забанить игрока на сервере");
                    var message = expireID == 0
                        ? Msg("ExitMessagePermBan", target.UserIDString)
                        : string.Format(Msg("ExitMessageTempBan", target.UserIDString), "<color=#FFA500>" + GetExpiredTime(target.UserIDString, expireID)) + "</color>";
                    BanPlayer(target, _moderatorID, _moderatorName, ip, message, $"Owner: {sharedID}", expireID, true);
                    if (expireID != 0) ChangeExpire(null, sharedID.ToString(), responseID[0]["reason"] + "| MultiAcc");
                });
            }
            catch (Exception e)
            {
                PrintError(e.Message);
            }
        }
        private void CheckPlayer(Connection connection, bool checkIp = true)
        {
            var moderatorid = _moderatorID;
            var moderatorName = _moderatorName;
            var currentIP = "";
            var listIP = new List<string>();
            var sqlAdd = false;
            if (checkIp) currentIP = GetIPAddress(connection.ipaddress);
            string message;
            try
            {
                Sql.Query(Core.Database.Sql.Builder.Append($"SELECT `expire`, `reason`, `ip`, `moderatorid`, `moderatorName` FROM {_database} WHERE `steamid` = @0", connection.userid), Sql_conn, responseID =>
                {
                    if (responseID.Count == 0)
                    {
                        //("++++ID игрока нету в базе"); 
                        if (string.IsNullOrEmpty(currentIP))
                        {
                            //("++++ip адрес в white листе");
                            //ShtirlitzTime(connection);
                            if (!CheckSumList.Contains(connection.userid)) CheckSumList.Add(connection.userid);
                            return;
                        }
                        Sql.Query(Core.Database.Sql.Builder.Append($"SELECT `expire`, `reason`, `steamid`, `moderatorid` FROM {_database} WHERE `ip` = @0", currentIP), Sql_conn,
                            responseIP =>
                            {
                                if (responseIP.Count == 0)
                                {
                                    //Puts("++++IP игрока нету в базе");
                                    //ShtirlitzTime(connection);
                                    if (!CheckSumList.Contains(connection.userid)) CheckSumList.Add(connection.userid);
                                    //Puts("++++Запущена проверка IP на совпадения");
                                    if (DiscordNotification) IPValidate(connection, currentIP);
                                    return;
                                }
                                var reasonIPDB = responseIP[0]["reason"].ToString();
                                var expireIPDB = int.Parse(responseIP[0]["expire"].ToString());
                                if (expireIPDB != 0 && DateTime.Now.Subtract(epoch).TotalSeconds < expireIPDB)
                                {
                                    Sql.Query(
                                        Core.Database.Sql.Builder.Append(
                                            $"SELECT `expire`, `reason`, `ip`, `moderatorid`, `moderatorName` FROM {_database} WHERE `steamid` = @0",
                                            responseIP[0]["steamid"].ToString()), Sql_conn,
                                        response =>
                                        {
                                            var reasonDB = response[0]["reason"];
                                            message = string.Format(Msg("ExitMessagePermBan", connection.userid.ToString()), reasonIPDB);
                                            KickPlayer(connection, message + "<color=#FFA500>" + GetSignature(reasonDB + " | " + Msg("BanEvade", connection.userid.ToString()), ulong.Parse(_moderatorID)) + ". </color>" + Msg("InformMessage", connection.userid.ToString()));
                                            ChangeExpire(moderatorid, responseIP[0]["steamid"].ToString(), reasonDB + " | " + Msg("BanEvade", connection.userid.ToString()));
                                            AddToDatabase(connection.userid.ToString(), connection.username, moderatorid,
                                                moderatorName, currentIP, reasonDB + " | " + Msg("BanEvade", connection.userid.ToString()));
                                            //Puts("++++Игрок есть в базе и зашел с другого аккаунта во время временной блокировки. Забанить все аккаунты игрока навсегда за попытку обхода. Сообщение попытка обхода бана");
                                        });
                                    return;
                                }
                                if (expireIPDB != 0 && DateTime.Now.Subtract(epoch).TotalSeconds >= expireIPDB)
                                {
                                    if (DiscordNotification) IPValidate(connection, currentIP);
                                    UnBanPlayer(connection.userid);
                                    //Puts("++++Время игровой блокировки вышло! Разбанить игрока");
                                    //ShtirlitzTime(connection);
                                    if (!CheckSumList.Contains(connection.userid)) CheckSumList.Add(connection.userid);
                                    return;
                                }
                                Sql.Query(
                                    Core.Database.Sql.Builder.Append(
                                        $"SELECT `expire`, `reason`, `ip`, `moderatorid`, `moderatorName` FROM {_database} WHERE `steamid` = @0",
                                        responseIP[0]["steamid"].ToString()), Sql_conn,
                                    response =>
                                    {
                                        message = string.Format(Msg("ExitMessagePermBan", connection.userid.ToString()), reasonIPDB);
                                        KickPlayer(connection, message + "<color=#FFA500>" + GetSignature(Msg("MultiAcc", connection.userid.ToString()), ulong.Parse(_moderatorID)) + ". </color>" + Msg("InformMessage", connection.userid.ToString()));

                                        foreach (var data in response.Where(data => !listIP.Contains(data["ip"].ToString())))
                                            listIP.Add(data["ip"].ToString());

                                        if (listIP.Contains(currentIP))
                                            AddToDatabase(connection.userid.ToString(), connection.username, moderatorid,
                                            moderatorName, currentIP, Msg("MultiAcc", connection.userid.ToString()), expireIPDB);
                                        //Puts("++++Игрок есть в базе и зашел с другого аккаунта. Забанить новый id игрока за попытку обхода блокировки. Сообщение мульти акк");
                                        listIP.Clear();
                                    });
                            });
                        return;
                    }
                    var expireIDDB = int.Parse(responseID[0]["expire"].ToString());
                    var reasonIDDB = responseID[0]["reason"].ToString();
                    var ipDB = responseID[0]["ip"].ToString();
                    var ModeratorIDDB = ulong.Parse(responseID[0]["moderatorid"].ToString());
                    //Puts("++++Игрок есть в базе!");
                    if (expireIDDB != 0 && DateTime.Now.Subtract(epoch).TotalSeconds >= expireIDDB)
                    {
                        if (DiscordNotification) IPValidate(connection, currentIP);
                        UnBanPlayer(connection.userid);
                        if (!CheckSumList.Contains(connection.userid)) CheckSumList.Add(connection.userid);
                        //Puts("++++Время игровой блокировки вышло! Разбанить игрока");
                        return;
                    }
                    //Puts("++++Забанить игрока на сервере");
                    message = expireIDDB == 0
                        ? Msg("ExitMessagePermBan", connection.userid.ToString())
                        : string.Format(Msg("ExitMessageTempBan", connection.userid.ToString()), "<color=#FFA500>" + GetExpiredTime(connection.userid.ToString(), expireIDDB)) + "</color>";
                    KickPlayer(connection, message + "<color=#FFA500>" + GetSignature(reasonIDDB, ModeratorIDDB) + ". </color>" + Msg("InformMessage", connection.userid.ToString()));
                    foreach (var data in responseID.Where(data => !listIP.Contains(data["ip"].ToString())))
                    {
                        listIP.Add(data["ip"].ToString());
                    }
                    //Если игрок зашел с ip, отличного от указанного в базе
                    if (!string.IsNullOrEmpty(currentIP) && !string.IsNullOrEmpty(ipDB) && currentIP != ipDB && !listIP.Contains(currentIP))
                        AddToDatabase(connection.userid.ToString(), connection.username, _moderatorID, _moderatorName,
                            currentIP, reasonIDDB, expireIDDB);

                    //Если в базе нету ip и игрок зашел с ip не из white листа
                    if (!string.IsNullOrEmpty(currentIP) && string.IsNullOrEmpty(ipDB))
                        ChangePlayerData(connection.userid.ToString(), ModeratorIDDB,
                            responseID[0]["moderatorName"].ToString(), reasonIDDB, currentIP, expireIDDB);
                    listIP.Clear();
                });
            }
            catch (Exception e)
            {
                PrintError(e.Message);
            }
        }

        private void ChangePlayerData(string targetID, ulong moderatorID, string moderatorName, string reason, string ip = null, int duration = 0)
        {
            Sql.Insert(Core.Database.Sql.Builder.Append($"UPDATE {_database} SET `moderatorName`=@0, `moderatorid`=@1, `expire`=@2, `reason`=@3, `ip`=@4 WHERE steamid=@5", moderatorName, moderatorID, duration, reason, ip, targetID), Sql_conn, i =>
            {
                Puts($"MySQL - изменено записей: [{i}]");
                if (_config.settings.Ban_Log) LogToFile(Name, $"[{DateTime.Now.ToString("HH:mm:ss")}] Изменение данных для {targetID}: Модератор: {moderatorName}[{moderatorID}], причина {reason}, ip {ip}, duration {duration}", this);
            });
        }

        private void ChangeExpire(string moderatorID, string targetID, string reason, int duration = 0)
        {
            Sql.Insert(Core.Database.Sql.Builder.Append($"UPDATE {_database} SET `expire`=@0, `reason`=@1 WHERE steamid=@2", duration, reason, targetID), Sql_conn,
                i =>
                {
                    ulong playerID;
                    var text = duration == 0 ? Msg("Permanent", moderatorID) : GetExpiredTime(targetID, duration);
                    if (!ulong.TryParse(moderatorID, out playerID)) return;
                    var player = BasePlayer.FindByID(playerID);
                    var textMsg = Msg("PlayerNotFound");
                    if (player != null)
                    {
                        textMsg = Msg("Changed", playerID.ToString());
                    }

                    SendToPlayer(string.Format(textMsg, targetID, text), player);
                    Puts($"MySQL - изменено записей: [{i}]");
                    if (_config.settings.Ban_Log) LogToFile(Name, $"[{DateTime.Now.ToString("HH:mm:ss")}] Изменение времени бана для {targetID}: Модератор: [{moderatorID}], причина {reason}, duration {duration}", this);
                });
        }
        private void UnBanPlayer(ulong target, BasePlayer player = null)
        {
            Sql.Query(Core.Database.Sql.Builder.Append($"SELECT `expire`, `ip` FROM {_database} WHERE `steamid` = @0", target), Sql_conn,
                responseID =>
                {

                    if (responseID.Count == 0)
                    {
                        var text = Msg("PlayerNotFound");
                        if (player != null)
                        {
                            text = Msg("PlayerNotFound", player.UserIDString);
                        }
                        SendToPlayer(string.Format(text, target), player);
                        return;
                    }
                    if (responseID.Count == 1)
                    {
                        DeleteFromDatabase(player, target);
                        return;
                    }
                    var ipList = new List<string>();
                    foreach (var data in responseID.Where(data => string.IsNullOrEmpty(data["ip"].ToString()) && !ipList.Contains(data["ip"].ToString())))
                    {
                        ipList.Add(data["ip"].ToString());
                    }
                    var idlist = new List<string> { target.ToString() };
                    foreach (var ip in ipList)
                    {
                        Sql.Query(
                            Core.Database.Sql.Builder.Append($"SELECT `steamid` FROM {_database} WHERE `ip` = @0",
                                ip), Sql_conn,
                            responseIP =>
                            {
                                foreach (var data in responseIP.Where(data => !idlist.Contains(data["steamid"].ToString())))
                                {
                                    idlist.Add(data["steamid"].ToString());
                                }
                            });
                    }
                    if (idlist.Count == 1)
                    {
                        DeleteFromDatabase(player, target);
                        return;
                    }
                    var message = "";
                    foreach (var id in idlist)
                    {
                        if (string.IsNullOrEmpty(message)) message += "\n";
                        message += id;
                    }
                    SendReply(player, string.Format(Msg("PlayerDefinition", player.UserIDString), message));
                });
        }
        private void DeleteFromDatabase(BasePlayer player, ulong target)
        {
            Sql.Insert(Core.Database.Sql.Builder.Append($"DELETE FROM {_database} WHERE steamid=@0", target), Sql_conn,
                responseID =>
                {
                    Puts($"MySQL - удалено записей: [{responseID}]");
                    if (_config.settings.Ban_Log) LogToFile(Name, $"[{DateTime.Now.ToString("HH:mm:ss")}] Игрок {target} разбанен: Инициатор: {player}", this);

                    if (player == null)
                        PrintWarning(string.Format(Msg("UnbanMessage"), target));
                    else
                        SendReply(player, string.Format(Msg("UnbanMessage", player.UserIDString), target));
                });

        }

        private void AddToDatabase(string targetID, string targetName, string moderatorID, string moderatorName, string ip, string reason, int duration = 0)
        {
            /*Sql.Query(
                Core.Database.Sql.Builder.Append($"SELECT `expire`, `ip` FROM {_database} WHERE `steamid` = @0",
                    targetID), Sql_conn,
                responseID =>
                {*/
            Sql.Insert(
                    Core.Database.Sql.Builder.Append(
                        $"INSERT INTO {_database} (`steamid`,`name`,`ip`,`reason`,`moderatorid`,`moderatorName`, `server`, `expire` ) VALUES ( @0, @1, @2, @3, @4, @5, @6, @7)",
                        targetID, targetName, ip, reason, moderatorID, moderatorName,
                        _config.settings.Server, duration), Sql_conn,
                    i => Puts($"MySQL - добавлено записей: [{i}]"));
            if (_config.settings.Ban_Log) LogToFile(Name, $"[{DateTime.Now.ToString("HH:mm:ss")}] Добавлен пользователь {targetName}[{targetID}]: Модератор: {moderatorName}[{moderatorID}], причина {reason}, ip {ip}, duration {duration}", this);
            // });
        }
        private void BanPlayer(BasePlayer target, string moderatorID, string moderatorName, string ip, string message, string reason, int duration = 0, bool sqlAdd = false, int chatDuration = 0)
        {
            var expire = duration == 0 ? 0 : (int)DateTime.Now.AddDays(duration).Subtract(epoch).TotalSeconds;
            var player = BasePlayer.FindByID(ulong.Parse(moderatorID));
            Sql.Query(Core.Database.Sql.Builder.Append($"SELECT `expire`, `ip` FROM {_database} WHERE `steamid` = @0", target.userID), Sql_conn,
                responseID =>
                {
                    if (responseID.Count != 0)
                    {
                        if (responseID[0]["expire"].ToString() == expire.ToString())
                        {
                            var text = Msg("PlayerAlreadyBanned");
                            if (player != null)
                            {
                                text = Msg("PlayerAlreadyBanned", player.UserIDString);
                            }
                            SendToPlayer(string.Format(text, target), player);
                        }
                        else
                        {
                            ChangeExpire(moderatorID, target.UserIDString, reason, expire);
                        }
                        KickPlayer(target.net.connection, message + "<color=#FFA500>" + GetSignature(reason, ulong.Parse(moderatorID)) + ". </color>" + Msg("InformMessage", target.UserIDString));
                        return;
                    }
                    var id = target.UserIDString;
                    var name = target.displayName;
                    if (sqlAdd)
                    {
                        AddToDatabase(target.UserIDString, target.displayName, moderatorID, moderatorName, ip, reason, expire);
                        if (target.net.connection.ownerid != target.userID) OfflineBan(target.net.connection.ownerid.ToString(), moderatorID, moderatorName, message, reason, expire);
                    }
                    KickPlayer(target.net.connection, message + "<color=#FFA500>" + GetSignature(reason, ulong.Parse(moderatorID)) + ". </color>" + Msg("InformMessage", target.UserIDString));
                    if (_config.settings.Ban_Log) LogToFile(Name, $"[{DateTime.Now.ToString("HH:mm:ss")}] Добавлен онлайн пользователь {target}: Модератор: {moderatorName}[{moderatorID}], причина {reason}, ip {ip}, duration {duration}", this);
                    SendNotification(id, name, moderatorID, moderatorName, reason + $"|by {moderatorName}", ip, duration);
                });

        }
        private void OfflineBan(string targetID, string moderatorID, string moderatorName, string message, string reason, int duration = 0)
        {
            var expire = duration == 0 ? 0 : (int)DateTime.Now.AddDays(duration).Subtract(epoch).TotalSeconds;
            var textReason = GetSignature(reason, ulong.Parse(moderatorID));
            var target = ulong.Parse(targetID);
            Sql.Query(
                Core.Database.Sql.Builder.Append(
                    $"SELECT `expire` FROM {_database} WHERE `steamid` = @0",
                    targetID), Sql_conn,
                responseID =>
                {
                    var player = BasePlayer.FindByID(ulong.Parse(moderatorID));
                    if (responseID.Count != 0)
                    {
                        if (responseID[0]["expire"].ToString() == duration.ToString())
                        {
                            var text = Msg("PlayerAlreadyBanned");
                            if (player != null)
                            {
                                text = Msg("PlayerAlreadyBanned", player.UserIDString);
                            }

                            SendToPlayer(string.Format(text, target), player);
                        }
                        else
                        {
                            ChangeExpire(moderatorID, targetID, reason, expire);
                        }
                        return;
                    }

                    if (string.IsNullOrEmpty(_config.settings.SteamApi))
                    {
                        //Puts("SteamApi не задан");
                        var targetName = "Негодяй" + DateTime.Now.Millisecond;
                        AddToDatabase(targetID, targetName, moderatorID, moderatorName, "", reason, expire);
                        if (_config.settings.Ban_Log) LogToFile(Name, $"[{DateTime.Now.ToString("HH:mm:ss")}] Добавлен оффлайн пользователь [{target}]: Модератор: {moderatorName}[{moderatorID}], причина {reason}, duration {duration}", this);
                        SendNotification(targetID, targetName, moderatorID, moderatorName, textReason, "---", duration);
                        return;
                    }
                    //Puts("Запрос имени игрока в Steam");
                    GetResponce(string.Format(PlayerStr, _config.settings.SteamApi, targetID), (PlayerInfo.Summaries _summaries) =>
                    {
                        var targetName = _summaries.response.Players[0].PersonaName ?? "HiddenName";
                        AddToDatabase(targetID, targetName, moderatorID, moderatorName, "", reason, expire);
                        if (_config.settings.Ban_Log) LogToFile(Name, $"[{DateTime.Now.ToString("HH:mm:ss")}] Добавлен оффлайн пользователь {targetName}[{targetID}]: Модератор: {moderatorName}[{moderatorID}], причина {reason}, duration {duration}", this);
                        SendNotification(targetID, targetName, moderatorID, moderatorName, textReason, "---", duration);
                    });
                });
        }
        #endregion


        #region <MySQL>
        private void LoadDatabase()
        {
            var fields = new List<SendList>();
            try
            {
                Sql_conn = Sql.OpenDb($"server={_config.mySQL.MySQL_Host}; port={_config.mySQL.MySQL_Port}; database={_config.mySQL.MySQL_DB}; user={_config.mySQL.MySQL_User}; password={_config.mySQL.MySQL_Pass}; charset= utf8", this);
                if (Sql_conn == null || Sql_conn.Con == null)
                {
                    fields.Add(new SendList
                    {
                        name = ":exclamation::exclamation::exclamation: Ошибка :exclamation::exclamation::exclamation:",
                        inline = true,
                        value = $"Couldn't open the MySQL PlayerDatabase: [{Sql_conn.Con.State}]"
                    });
                    PrintError("Couldn't open the MySQL PlayerDatabase: {0}", Sql_conn.Con.State.ToString());
                    return;
                }
                Sql.Insert(Core.Database.Sql.Builder.Append($"CREATE TABLE IF NOT EXISTS {_database} (`id` int(11) NOT NULL AUTO_INCREMENT, `steamid` BIGINT(17), `name` VARCHAR(32),`ip` VARCHAR(15),`reason` VARCHAR(32),`moderatorid` BIGINT(17),`moderatorName` VARCHAR(32), `server` VARCHAR(25), `expire` int(11) NOT NULL, `date` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (`id`));"), Sql_conn);
                Puts($"Database {_database} loaded");
                Sql.Query(Core.Database.Sql.Builder.Append($"SELECT `id` FROM {_database} WHERE 1"), Sql_conn, response =>
                {
                    fields.Add(new SendList
                    {
                        name = $":sunny: База банов загружена! :sunny:",
                        inline = true,
                        value = $":card_box: Количество записей: [{response.Count}]"
                    });
                    DiscordMessages.Call("API_SendFancyMessage", DiscordDebugWebhookURL, "BAN SYSTEM", 11111199, JsonConvert.SerializeObject(fields.Cast<object>().ToArray()));
                    fields.Clear();
                });
            }
            catch (Exception e)
            {
                fields.Add(new SendList
                {
                    name = ":exclamation::exclamation::exclamation: Ошибка :exclamation::exclamation::exclamation:",
                    inline = true,
                    value = $"[{e.Message}]"
                });
                PrintError(e.Message);
                DiscordMessages.Call("API_SendFancyMessage", DiscordDebugWebhookURL, "БАНЫ " + _config.settings.Server, 11111199, JsonConvert.SerializeObject(fields.Cast<object>().ToArray()));
                fields.Clear();
            }


        }
        #endregion


        #region Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"NoAccess","<color=#FF0000>[LF]</color><color=#FFFFFF> You don't have the permission to use this command</color>" },
                {"UnbanMessage","Player [{0}] is unbanned!" },
                {"UnbanSyntax","Syntax: unban < SteamID >" },
                {"BanSyntax","Syntax: ban < SteamID > < reason > < time in days(optional) > " },
                { "PlayerNotFound", "Player {0} was not found in database.\n" },
                { "PlayerDefinition", "Игрока нельзя разбанить без согласования с админом!\nСвязанные SteamID: {0}" },
                { "PlayerAlreadyBanned", "Player {0} is already banned.\n" },
                { "Changed", "Ban duration for player {0} changed to {1}" },
                { "day", "d." },
                { "Permanent", "permanent" },
                { "BanEvade", "Ban evade" },
                { "CantBanOwner", "Нельзя забанить Админа\n" },
                { "CantBanModerator", "Нельзя забанить модератора\n" },
                { "PlayerBanned", "<color=#FF0000>[LF]</color><color=#FFFFFF> Player <color=#FF0000>{0}</color> was permanently banned! Reason: <color=#FF0000>{1}</color></color>" },
                { "PlayerBannedTemp", "<color=#FF0000>[LF]</color><color=#FFFFFF> Player <color=#FF0000>{0}</color> was banned for <color=#FF0000>{1}</color> Reason: <color=#FF0000>{2}</color></color>" },
                { "DatabaseError", "Database receiving error: list.Count != 1!\n" },
                { "InformMessage", "If you believe that the ban was received unfairly, you can apply for a unban <color=#FFA500>vk.com/lifefinerust</color>" },
                { "ExitMessagePermBan", "You are permanently banned!\nReason:" },
                { "ExitMessageTempBan", "The ban expires after {0} Reason: " }
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"NoAccess","<color=#FF0000>[LF]</color><color=#FFFFFF> У вас нету привилегии для использования команды</color>" },
                {"UnbanMessage","Игрок [{0}] разбанен!" },
                {"UnbanSyntax","Синтаксис: unban < SteamID >" },
                {"BanSyntax","Синтаксис: ban < SteamID > < причина > < дни бана (необязательно) > " },
                { "PlayerNotFound", "Игрок {0} не найден в базе банов\n" },
                { "PlayerDefinition", "Игрока нельзя разбанить без согласования с админом!\nСвязанные SteamID: {0}</color></color>" },
                { "PlayerAlreadyBanned", "Игрок {0} уже забанен.\n" },
                { "CantBanOwner", "Нельзя забанить Админа\n" },
                { "CantBanModerator", "Нельзя забанить модератора\n" },
                { "Changed", "Продолжительность бана для игрока {0} изменена на {1}</color></color>" },
                { "day", "дн." },
                { "Permanent", "пожизненное" },
                { "BanEvade", "Обход бана" },
                { "PlayerBanned", "<color=#FF0000>[LF]</color><color=#FFFFFF> Игрок <color=#FF0000>{0}</color> был навсегда забанен на сервере! Причина: <color=#FF0000>{1}</color></color>" },
                { "PlayerBannedTemp", "<color=#FF0000>[LF]</color><color=#FFFFFF> Игрок <color=#FF0000>{0}</color> был забанен на <color=#FF0000>{1}</color> Причина: <color=#FF0000>{2}</color></color>" },
                { "DatabaseError", "Database receiving error: list.Count != 1!\n" },
                { "InformMessage", "Незаслуженный бан? Подайте заявку на <color=#FFA500>vk.com/lifefinerust</color>" },
                { "ExitMessagePermBan", "Вы забанены НАВСЕГДА!\nПричина: " },
                { "ExitMessageTempBan", "Вы получили временный бан! Осталось: {0} Причина: " }
            }, this, "ru");
        }
        private string Msg(string key, string userID = null) =>
            lang.GetMessage(key, this, userID);
        #endregion


        #region Json

        private PlayerInfo.Summaries _summaries;

        private class SendList
        {
            public string name { get; set; }
            public bool inline { get; set; }
            public string value { get; set; }
        }

        public class PlayerInfo
        {
            public List<Summaries> summaries = new List<Summaries>();
            public class Summaries
            {
                [JsonProperty("response")] public Content response;

                public class Content
                {
                    [JsonProperty("players")] public Player[] Players;

                    public class Player
                    {
                        [JsonProperty("personaname")] public string PersonaName;

                    }
                }
            }
        }

        #endregion


    }
}

// --- End of file: BanSystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/XMenu.cs ---
// --- Original Local Path: TrashRust/XMenu.cs ---

#define DEBUG

using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using UnityEngine;


namespace Oxide.Plugins
{
    [Info("XMenu", "VooDoo", "1.0.0")]
    [Description("C# Constructor menu")]

    public class XMenu : RustPlugin
    {
        private static XMenu instance;

        #region ImageLibrary Addon
        [PluginReference] Plugin ImageLibrary;
        bool AddImage(string url, string imageName, ulong imageId, Action callback = null) => (bool)ImageLibrary.Call("AddImage", url, imageName, imageId, callback);
        string GetImage(string imageName, ulong imageId = 0, bool returnUrl = false) => (string)ImageLibrary.Call("GetImage", imageName, imageId, returnUrl);
        #endregion

        #region Menu
        private List<MenuItem> MenuItems = new List<MenuItem>();
        public class MenuItem
        {
            public string Name { get; set; }
            public string Path { get; set; }
            public List<SubMenuItem> Items { get; set; }
            public PluginResponse PluginResponse { get; set; }

            public MenuItem(string PluginName, string Name, string Path, string Command = "", CuiElementContainer Container = null)
            {
                this.Name = Name;
                this.Path = Path;
                this.Items = new List<SubMenuItem>();

                if (!string.IsNullOrEmpty(Command) || Container != null)
                    this.PluginResponse = new PluginResponse(PluginName, Command, Container);

                instance.MenuItems.Add(this);
            }
        }

        public class SubMenuItem
        {
            public string Title { get; set; }
            public MenuItem Parent { get; set; }
            public PluginResponse PluginResponse { get; set; }

            public SubMenuItem(string PluginName, string Name, string Title, string Command = "", CuiElementContainer Container = null)
            {
                this.Parent = instance.MenuItems.Where(x => x.Name == Name).FirstOrDefault();
                if (Parent != null)
                {
                    this.Title = Title;
                    if (!string.IsNullOrEmpty(Command) || Container != null)
                        this.PluginResponse = new PluginResponse(PluginName, Command, Container);

                    Parent.Items.Add(this);
                }
            }
        }

        public class PluginResponse
        {
            private Plugin Plugin;
            private CuiElementContainer Container;
            private string Command;

            public PluginResponse(string PluginName, string Command, CuiElementContainer Container)
            {
                this.Plugin = string.IsNullOrEmpty(PluginName) ? null : instance.Manager.GetPlugin(PluginName);
                this.Command = Command;
                this.Container = Container;
            }

            public CuiElementContainer GetContainer() => Container;
            public void PluginCall(ulong userID, params object[] args) => Plugin.Call(Command, userID, args);
            public bool IsContainer => Container != null && Container.Count > 0;
            public bool IsCommand => !string.IsNullOrEmpty(Command);
        }
        #endregion

        #region Config
        private PluginConfig config;
        private class PluginConfig
        {
            public ColorConfig colorConfig;
            public class ColorConfig
            {
                public string outlineColor;
                public string backgroundColor;
                public string menuItemsColor;
                public string subMenuItemsColor;
                public string subMenuSelectedItemsColor;
                public string subMenuItemsTextColor;
                public string menuContentHighlighting;
                public string menuContentHighlightingalternative;

                public string gradientColor;
            }

            public string welcomeMsg;
        }

        private void Init()
        {
            config = Config.ReadObject<PluginConfig>();
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                colorConfig = new PluginConfig.ColorConfig()
                {
                    outlineColor = "#2C2E29D9",
                    backgroundColor = "#595A21FF",
                    menuItemsColor = "#FFFFFAD9",
                    subMenuItemsColor = "#00000000",
                    subMenuSelectedItemsColor = "#171717",
                    subMenuItemsTextColor = "#FFFFFF",
                    menuContentHighlighting = "#00000073",
                    menuContentHighlightingalternative = "#00000040",

                    gradientColor = "#000000E6",
                },
                welcomeMsg = $""
            };
        }
        #endregion

        #region Layers
        public const string MenuLayer = "XMenu";
        public const string MenuItemsLayer = "XMenu.MenuItems";
        public const string MenuSubItemsLayer = "XMenu.MenuSubItems";
        public const string MenuContent = "XMenu.Content";
        #endregion

        #region RenderTemplate
        public void Render(CuiElementContainer Container)
        {
            #region Close
            Container.Add(new CuiElement
            {
                Name = MenuLayer,
                Parent = "Overlay",
                Components =
                    {
                        new CuiRawImageComponent
                        {
                            Sprite = "assets/content/ui/ui.background.tiletex.psd",
                            Material = "assets/content/ui/uibackgroundblur.mat",
                            Color = "0 0 0 0"
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1",
                        },
                        new CuiNeedsCursorComponent()
                    }
            });
            Container.Add(new CuiElement
            {
                Name = MenuLayer + ".Close",
                Parent = MenuLayer,
                Components =
                    {
                        new CuiButtonComponent
                        {
                            Color = "0 0 0 0",
                            Close = MenuLayer
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1"
                        },
                    }
            });
            #endregion

            Container.Add(new CuiElement
            {
                Name = MenuLayer + ".Outline",
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.outlineColor),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-510 -250",
                            OffsetMax = "510 290"
                        },
                    }
            });
            Container.Add(new CuiElement
            {
                Name = MenuLayer + ".Background",
                Parent = MenuLayer,
                Components =
                    {
                        new CuiRawImageComponent
                        {
                            Sprite = "assets/content/textures/generic/fulltransparent.tga"
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-500 -240",
                            OffsetMax = "500 280"
                        },
                    }
            });
            Container.Add(new CuiElement
            {
                Name = MenuLayer + ".Line",
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.outlineColor),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-450 -240",
                            OffsetMax = "-440 280"
                        },
                    }
            });
            Container.Add(new CuiElement
            {
                Name = MenuLayer + ".Gradient",
                Parent = MenuLayer,
                Components =
                    {
                        new CuiRawImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.gradientColor),
                            Sprite = "assets/content/ui/ui.background.transparent.radial.psd",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-510 -250",
                            OffsetMax = "510 290"
                        }
                    }
            });
        }
        #endregion

        #region Menu
        public void RenderMenu(CuiElementContainer Container)
        {
            Container.Add(new CuiElement
            {
                Name = MenuItemsLayer,
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0 0 0 0",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-500 -240",
                            OffsetMax = "-450 280"
                        }
                    }
            });

            for (int i = 0; i < instance.MenuItems.Count; i++) // ICONS
            {
                if (instance.MenuItems[i].Path.StartsWith("assets/"))
                {
                    Container.Add(new CuiElement
                    {
                        Name = MenuItemsLayer + $".{i}",
                        Parent = MenuItemsLayer,
                        Components =
                        {
                            new CuiImageComponent
                            {
                                Color = HexToRustFormat(config.colorConfig.menuItemsColor),
                                Sprite = instance.MenuItems[i].Path,
                                Material = "assets/icons/iconmaterial.mat",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0 1",
                                AnchorMax = "0 1",
                                OffsetMin = $"5 {-45 - i * 50}",
                                OffsetMax = $"45 {-5 - i * 50}"
                            },
                            new CuiOutlineComponent
                            {
                                Color = "0 0 0 1",
                                Distance = "-1 1"
                            }
                        }
                    });
                }
                else
                {
                    Container.Add(new CuiElement
                    {
                        Name = MenuItemsLayer + $".{i}",
                        Parent = MenuItemsLayer,
                        Components =
                        {
                            new CuiRawImageComponent
                            {
                                Color = HexToRustFormat(config.colorConfig.menuItemsColor),
                                Png = GetImage(instance.MenuItems[i].Path),
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0 1",
                                AnchorMax = "0 1",
                                OffsetMin = $"5 {-45 - i * 50}",
                                OffsetMax = $"45 {-5 - i * 50}"
                            },
                            new CuiOutlineComponent
                            {
                                Color = "0 0 0 1",
                                Distance = "-1 1"
                            }
                        }
                    });
                }
                Container.Add(new CuiElement
                {
                    Name = MenuItemsLayer + $".{i}",
                    Parent = MenuItemsLayer,
                    Components =
                        {
                            new CuiButtonComponent
                            {
                                Color = "0 0 0 0",
                                Command = $"custommenu false {instance.MenuItems.ElementAt(i).Name} 0"
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = $"0 1",
                                AnchorMax = $"0 1",
                                OffsetMin = $"5 {-45 - i * 50}",
                                OffsetMax = $"45 {-5 - i * 50}"
                            },
                        }
                });
            }
        }
        #endregion

        #region SubMenu
        public void RenderSubMenu(CuiElementContainer Container, MenuItem menuItem, int selectedMenu)
        {
            Container.Add(new CuiElement
            {
                Name = MenuSubItemsLayer,
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0 0 0 0",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-400 -240",
                            OffsetMax = "-295 230"
                        },
                    }
            });

            for (int i = 0; i < menuItem.Items.Count; i++)
            {
                if (selectedMenu == i)
                {
                    Container.Add(new CuiElement
                    {
                        Name = MenuSubItemsLayer + ".TitleGradient",
                        Parent = MenuSubItemsLayer,
                        Components =
                            {
                                new CuiImageComponent
                                {
                                    Color = HexToRustFormat(config.colorConfig.subMenuSelectedItemsColor),
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1.05",
                                    AnchorMax = "0 1.05",
                                    OffsetMin = $"30 {(50 + i * 45) * -1}",
                                    OffsetMax = $"185 {(0 + i * 45) * -1}"
                                }
                            }
                    });
                }

                Container.Add(new CuiElement
                {
                    Name = MenuSubItemsLayer + $".MenuLabel.{i}",
                    Parent = MenuSubItemsLayer,
                    Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"<color={config.colorConfig.subMenuItemsTextColor}>{menuItem.Items[i].Title}</color>",
                                Align = TextAnchor.MiddleRight,
                                FontSize = 24,
                                Font = "robotocondensed-bold.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0 1.05",
                                AnchorMax = "0 1.05",
                                OffsetMin = $"0 {(50 + i * 45) * -1}",
                                OffsetMax = $"175 {(0 + i * 45) * -1}"
                            },
                            new CuiOutlineComponent()
                            {
                                 Color = "0 0 0 1",
                                 Distance = "0.5 -0.5"
                            }
                        }
                });

                if (selectedMenu != i)
                {
                    Container.Add(new CuiElement
                    {
                        Name = MenuSubItemsLayer + $".Button_{i}",
                        Parent = MenuSubItemsLayer,
                        Components =
                        {
                            new CuiButtonComponent
                            {
                                Color = HexToRustFormat(config.colorConfig.subMenuItemsColor),
                                Command = $"custommenu false {menuItem.Name} {i}"
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0 1.05",
                                AnchorMax = "0 1.05",
                                OffsetMin = $"0 {(50 + i * 45) * -1}",
                                OffsetMax = $"185 {(0 + i * 45) * -1}"
                            },
                        }
                    });
                }
            }
        }
        #endregion

        #region Main Page
        public CuiElementContainer JSON_MainPage()
        {
            CuiElementContainer Container = new CuiElementContainer();
            Container.Add(new CuiElement
            {
                Name = MenuContent,
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0 0 0 0",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-215 -240",
                            OffsetMax = "500 280"
                        },
                    }
            });

            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Logo",
                Parent = MenuContent,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "80 -187.5",
                            OffsetMax = "630 -50"
                        }
                    }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Logo" + ".Img",
                Parent = MenuContent + ".Logo",
                Components =
                    {
                        new CuiRawImageComponent
                        {
                            Color = "1 1 1 1",
                            Sprite = "assets/content/ui/menuui/rustlogo-blurred.png",
                            FadeIn = 0.5f,
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1",
                        }
                    }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info",
                Parent = MenuContent,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "80 -470",
                            OffsetMax = "630 -200"
                        }
                    }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Title",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"<color=#fff9f9AA>ДОБРО ПОЖАЛОВАТЬ НА СЕРВЕР\n<size=58><b>TRASH <color=#1d71ff>RUST</color> X20</b></size>\nОзнакомиться с сервером, узнать команды, особенности и другую полезную информацию вы сможете в данном меню.\nОбязательно прочитайте правила сервера!\n\nIP-Адрес сервера: <color=#1d71ff>127.0.0.1:28015</color>\nНаш магазин: <color=#1d71ff>https://devplugins.ru/</color>\nНаша группа дискорд : <color=#1d71ff>https://discord.gg/fdAgBkhQGx</color></color>",
                                Align = TextAnchor.UpperCenter,
                                FontSize = 20,
                                Font = "robotocondensed-bold.ttf",
                                FadeIn = 0.5f,
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.025 0.025",
                                AnchorMax = "0.975 0.975",
                            },
                            new CuiOutlineComponent()
                            {
                                 Color = "0 0 0 1",
                                 Distance = "0.5 -0.5"
                            }
                        }
            });
            return Container;
        }
        #endregion

        #region CMD
        [ConsoleCommand("custommenuclose")]
        void CmdClose(ConsoleSystem.Arg arg)
        {
            CuiHelper.DestroyUi(arg.Player(), MenuLayer);
        }

        [ConsoleCommand("custommenu")]
        void CmdShow(ConsoleSystem.Arg arg)
        {
            CuiElementContainer Container = new CuiElementContainer();

            bool FullRender = true;
            string Name = MenuItems[0].Name;
            int ID = 0;
            int Page = 0;
            string Args = string.Empty;

            if (arg.HasArgs(1)) FullRender = bool.Parse(arg.Args[0]);
            if (arg.HasArgs(2)) Name = arg.Args[1];
            if (arg.HasArgs(3)) ID = int.Parse(arg.Args[2]);
            if (arg.HasArgs(4)) Page = int.Parse(arg.Args[3]);
            if (arg.HasArgs(5)) Args = string.Join(" ", arg.Args.Skip(4));

            if (FullRender)
            {
                CuiHelper.DestroyUi(arg.Player(), MenuLayer);

                Render(Container);
                RenderMenu(Container);
            }
            else
            {
                CuiHelper.DestroyUi(arg.Player(), MenuSubItemsLayer);
                CuiHelper.DestroyUi(arg.Player(), MenuContent);
            }

            MenuItem menuItem = MenuItems.Where(x => x.Name == Name).FirstOrDefault();

            if (menuItem.PluginResponse == null)
                RenderSubMenu(Container, menuItem, ID);


            if (menuItem.Items.Count > 0)
            {
                if (menuItem.Items[ID].PluginResponse.IsContainer)
                    Container.AddRange(menuItem.Items[ID].PluginResponse.GetContainer());
                else
                    menuItem.Items[ID].PluginResponse.PluginCall(arg.Connection.userid, (object)Container, (object)FullRender, (object)Name, (object)ID, (object)Page, (object)Args);
            }
            else
            {
                if (menuItem.PluginResponse.IsContainer)
                    Container.AddRange(menuItem.PluginResponse.GetContainer());
                else
                    menuItem.PluginResponse.PluginCall(arg.Connection.userid, (object)Container, (object)FullRender, (object)Name, (object)ID, (object)Page, (object)Args);
            }

            CuiHelper.AddUi(arg.Player(), Container);
        }
        #endregion

        #region uModHook's

        private List<string> pluginsQueue = new List<string>();
        void OnServerInitialized()
        {
            instance = this;

            new MenuItem(this.Name, "Main", "assets/icons/gear.png");
            new SubMenuItem(this.Name, "Main", "Главная", "", JSON_MainPage());
            cmd.AddChatCommand("menu", this, (p, cmd, args) => rust.RunClientCommand(p, "custommenu true Main"));

            foreach (var menuItem in MenuItems)
            {
                if (!menuItem.Path.StartsWith("assets/"))
                {
                    AddImage(menuItem.Path, menuItem.Path, 0);
                    PrintError(menuItem.Path);
                }
            }

            pluginsQueue = Interface.Oxide.DataFileSystem.ReadObject<List<string>>("PluginsQueue");
            for (int i = 0; i < pluginsQueue.Count; i++)
            {
                int x = i;
                timer.In(1f + 0.5f * i, () => rust.RunServerCommand($"o.reload {pluginsQueue.ElementAt(x)}"));
            }
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (player == null)
                return;

            if (player.IsReceivingSnapshot)
            {
                timer.In(1f, () => OnPlayerConnected(player));
                return;
            }

            rust.RunClientCommand(player, "custommenu");
        }

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
                CuiHelper.DestroyUi(player, MenuLayer);

            Interface.Oxide.DataFileSystem.WriteObject<List<string>>("PluginsQueue", pluginsQueue);
        }
        #endregion

        #region API
        void API_RegisterMenu(string PluginName, string Name, string Path, string Command = "", object Container = null)
        {
            if (instance.MenuItems.Where(x => x.Name == Name).Count() > 0)
                instance.MenuItems.Remove(instance.MenuItems.Where(x => x.Name == Name).FirstOrDefault());

            new MenuItem(PluginName, Name, Path, Command, (Container != null) ? (Container as CuiElementContainer) : null);

            if (!pluginsQueue.Contains(PluginName))
                pluginsQueue.Add(PluginName);
        }
        void API_RegisterSubMenu(string PluginName, string Name, string Title, string Command = "", object Container = null)
        {
            if (instance.MenuItems.Where(x => x.Name == Name).Count() > 0)
            {
                if (instance.MenuItems.Where(x => x.Name == Name).FirstOrDefault().Items.Where(x => x.Title == Title).Count() > 0)
                    instance.MenuItems.Where(x => x.Name == Name).FirstOrDefault().Items.Remove(instance.MenuItems.Where(x => x.Name == Name).FirstOrDefault().Items.Where(x => x.Title == Title).FirstOrDefault());

                new SubMenuItem(PluginName, Name, Title, Command, ((Container != null) ? (Container as CuiElementContainer) : null));

                if (!pluginsQueue.Contains(PluginName))
                    pluginsQueue.Add(PluginName);
            }
        }
        int API_GetSubMenuID(string Name, string Title) => MenuItems.Where(x => x.Name == Name).FirstOrDefault().Items.IndexOf(MenuItems.Where(x => x.Name == Name).FirstOrDefault().Items.Where(z => z.Title == Title).FirstOrDefault());
        #endregion

        #region Utils
        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }
        #endregion
    }
}

// --- End of file: XMenu.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/DoorsControl.cs ---
// --- Original Local Path: TrashRust/DoorsControl.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;
using System;
using System.Reflection;
using System.Text;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    /*ПЛАГИН БЫЛ ПОФИКШЕН С ПОМОЩЬЮ ПРОГРАММЫ СКАЧАНОЙ С https://discord.gg/dNGbxafuJn */ [Info("DoorsControl", "https://discord.gg/dNGbxafuJn", "1.0.4")]
    [Description("DoorsControl")]
    public class DoorsControl : RustPlugin
    {
        [PluginReference] private Plugin Clans;

        #region Variables

        private StoredData _data;
        private ConfigData _config;

        private readonly FieldInfo _serverInput = typeof(BasePlayer).GetField("serverInput",
            (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));

        private readonly Vector3 _eyesAdjust = new Vector3(0f, 1.5f, 0f);
        private bool _dataLoaded;

        private readonly FieldInfo _hasCode = typeof(CodeLock).GetField("hasCode",
            (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));

        #endregion

        #region Configuration

        private class ConfigData
        {
            [JsonProperty("Команда для замков")] public string codelockCommand { get; set; }
            [JsonProperty("Команда для дверей ")] public string doorsCommand { get; set; }
            [JsonProperty("Привилегии")] public Permissions permissions { get; set; }
            [JsonProperty("Настройки")] public Settings settings { get; set; }
        }

        private class Permissions
        {
            [JsonProperty("Привилегия для дверей")]
            public string permissionDeployDoor { get; set; }

            [JsonProperty("Привилегия для ящиков")]
            public string permissionDeployBox { get; set; }

            [JsonProperty("Привилегия для шкафов с одеждой")]
            public string permissionDeployLocker { get; set; }

            [JsonProperty("Привилегия для шкафа")] public string permissionDeployCupboard { get; set; }

            [JsonProperty("Привилегия для автозакрытия замка")]
            public string permissionAutoLock { get; set; }

            [JsonProperty("Привилегия для установки замка без замка :)")]
            public string permissionNoLockNeed { get; set; }

            [JsonProperty("Привилегия для автозакрывания двери")]
            public string permissionAutoCloseDoor { get; set; }

            [JsonProperty("Привилегия для умного дома")]
            public string permissionSmartHome { get; set; }
        }

        private class Settings
        {
            [JsonProperty("Автозакрытие замка")] public bool AutoLock { get; set; }

            [JsonProperty("Авто установка на двери")]
            public bool DeployDoor { get; set; }

            [JsonProperty("Авто установка на ящики")]
            public bool DeployBox { get; set; }

            [JsonProperty("Авто установка на шкафы с одеждой")]
            public bool DeployLocker { get; set; }

            [JsonProperty("Авто установка на шкаф")]
            public bool DeployCupboard { get; set; }

            [JsonProperty("Задержка закрытия двери")]
            public float defaultDelay { get; set; }

            [JsonProperty("Автозакрытие дверей")] public bool autoDoor { get; set; }
        }

        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                codelockCommand = "code",
                doorsCommand = "ad",
                permissions = new Permissions
                {
                    permissionDeployDoor = Name + ".deploydoor",
                    permissionDeployBox = Name + ".deploybox",
                    permissionDeployLocker = Name + ".deploylocker",
                    permissionDeployCupboard = Name + ".deploycup",
                    permissionAutoLock = Name + ".autolock",
                    permissionNoLockNeed = Name + ".nolockneed",
                    permissionAutoCloseDoor = Name + ".autoclose",
                    permissionSmartHome = Name + ".smarthome",

                },
                settings = new Settings
                {
                    AutoLock = true,
                    DeployDoor = true,
                    DeployBox = true,
                    DeployLocker = true,
                    DeployCupboard = true,
                    autoDoor = true,
                    defaultDelay = 5f
                }
            };
            SaveConfig(config);
            PrintWarning("Creating default a configuration file ...");
        }

        private void LoadConfigVariables() => _config = Config.ReadObject<ConfigData>();
        private void SaveConfig(ConfigData config) => Config.WriteObject(config, true);

        #endregion

        #region Oxide
        
        private void Loaded()
        {
            LoadConfigVariables();
            cmd.AddChatCommand(_config.codelockCommand, this, "CodeLockCommand");
            cmd.AddChatCommand(_config.doorsCommand, this, "AutoDoorCommand");
        }

        private void OnServerInitialized()
        {
            if (!_dataLoaded) LoadData();
            RegisterPermissions();
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (!_data.PlayerInfo.ContainsKey(player.userID)) AddNewPlayer(player);
            }
        }

        private void OnPlayerConnected(BasePlayer player)    
        {
            if (!_data.PlayerInfo.ContainsKey(player.userID)) AddNewPlayer(player);
        }

        private void OnDoorOpened(Door door, BasePlayer player)
        {
            if (door == null || player == null) return;
            if (!permission.UserHasPermission(player.UserIDString, _config.permissions.permissionAutoCloseDoor))
            {
                //Puts(permission.UserHasPermission(player.UserIDString, _config.permissions.permissionAutoCloseDoor).ToString());
                return;
            }
            if (door.GetComponentInChildren<DoorCloser>() != null) return;
            if (_data.DoorsList.Contains(door.net.ID.Value)) return;
            var time = 0f;
            if (_data.PlayerInfo.ContainsKey(player.userID))
            {
                if (!_data.PlayerInfo[player.userID].AutoDoor) return;
                time = _data.PlayerInfo[player.userID].DefaultDelay;
            }
            else
            {
                if (!_config.settings.AutoLock) return;
                time = _config.settings.defaultDelay;
            }

            if (time == 0f) return;
            timer.Once(time, () => CloseDoor(door));

        }

        private void OnItemDeployed(Deployer deployer, BaseEntity entity)
        {
            if (deployer.GetOwnerPlayer() == null || deployer.GetModDeployable() == null ||
                deployer.GetModDeployable().name == "doorcloser.item" || !entity.HasSlot(BaseEntity.Slot.Lock) ||
                !(entity.GetSlot(BaseEntity.Slot.Lock) is CodeLock)) return;
            var owner = deployer.GetOwnerPlayer();
            if (!permission.UserHasPermission(owner.UserIDString, _config.permissions.permissionAutoLock) ||
                !_data.PlayerInfo[owner.userID].AutoLock) return;
            var codelock = entity.GetSlot(BaseEntity.Slot.Lock) as CodeLock;
            if (codelock == null) return;
            codelock.code = Convert.ToString(_data.PlayerInfo[owner.userID].Password != 0
                ? _data.PlayerInfo[owner.userID].Password
                : UnityEngine.Random.Range(1234, 9876));
            _hasCode.SetValue(codelock, true);
            codelock.whitelistPlayers.Add(owner.userID);
            codelock.SetFlag(BaseEntity.Flags.Locked, true);
            Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.updated.prefab",
                entity.transform.position);
            var code = codelock.code;
            if (owner.net.connection.info.GetBool("global.streamermode")) code = "****";
            SendReply(owner, string.Format(Msg("CodeAuth", owner), code)); //Изменено
        }

        private void OnEntityBuilt(Planner planner, GameObject obj)
        {
            if (planner == null || planner.GetOwnerPlayer() == null ||
                obj.GetComponent<BaseEntity>() == null || obj.GetComponent<BaseEntity>().OwnerID == 0) return;
            var entity = obj.GetComponent<BaseEntity>();
            var player = planner.GetOwnerPlayer();
            if (player == null || !_data.PlayerInfo.ContainsKey(player.userID)) return;
            if (entity is Door && (entity as Door).canTakeLock)
            {
                if (permission.UserHasPermission(player.UserIDString, _config.permissions.permissionDeployDoor) &&
                    _data.PlayerInfo[player.userID].DeployDoor) LockPlacing(player, entity);
            }
            else if (entity is BoxStorage && entity.HasSlot(BaseEntity.Slot.Lock))
            {
                if (permission.UserHasPermission(player.UserIDString, _config.permissions.permissionDeployBox) &&
                    _data.PlayerInfo[player.userID].DeployBox) LockPlacing(player, entity);
            }
            else if (entity is Locker && entity.HasSlot(BaseEntity.Slot.Lock))
            {
                if (permission.UserHasPermission(player.UserIDString, _config.permissions.permissionDeployLocker) &&
                    _data.PlayerInfo[player.userID].DeployLocker) LockPlacing(player, entity);
            }
            else if (entity is BuildingPrivlidge && entity.HasSlot(BaseEntity.Slot.Lock))
            {
                if (permission.UserHasPermission(player.UserIDString, _config.permissions.permissionDeployCupboard) &&
                    _data.PlayerInfo[player.userID].DeployCupboard) LockPlacing(player, entity);
            }
        }

        private void OnNewSave()
        {
            LoadData();
            _data.DoorsList.Clear();
            SaveData();
        }

        private void OnServerSave() => SaveData();

        private void Unload() => SaveData();

        #endregion

        #region Functions
        bool IsClanMember(ulong playerid = 294912, ulong targetID = 0) => (bool)(Clans?.Call("HasFriend", playerid, targetID) ?? false);

        private void CloseDoor(BaseEntity door)
        {
            if (door == null || !door.IsOpen()) return;
            door.SetFlag(BaseEntity.Flags.Open, false);
            door.SendNetworkUpdateImmediate();
        }

        private static BaseEntity DoRay(Vector3 pos, Vector3 aim)
        {
            var hits = Physics.RaycastAll(pos, aim);
            var distance = 3f;
            BaseEntity target = null;
            foreach (var hit in hits)
            {
                if (!(hit.distance < distance)) continue;
                distance = hit.distance;
                target = hit.GetEntity();
            }

            return target;
        }
    
        private void AutoDoorCommand(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;
            if (!permission.UserHasPermission(player.UserIDString, _config.permissions.permissionAutoCloseDoor))
            {
                SendReply(player,
                    Msg("NoAccess", player));
                return;
            }

            SetDoor(player);
        }

        private void SetDoor(BasePlayer player)
        {
            var input = _serverInput.GetValue(player) as InputState;
            if (input == null) return;
            var currentRot = Quaternion.Euler(input.current.aimAngles) * Vector3.forward;
            var entity = DoRay(player.transform.position + _eyesAdjust, currentRot);
            var door = entity as Door;
            if (door == null)
            {
                if (!_data.PlayerInfo.ContainsKey(player.userID)) AddNewPlayer(player);
                _data.PlayerInfo[player.userID].AutoDoor = !_data.PlayerInfo[player.userID].AutoDoor;
                SaveData();
                SendReply(player,
                    _data.PlayerInfo[player.userID].AutoDoor
                        ? Msg("AllAutoCloseEnabled", player)
                        : Msg("AllAutoCloseDisabled", player));
                return;
            }

            SwitchDoor(player, door);
        }

        private void SwitchDoor(BasePlayer player, BaseNetworkable door)
        {
            if (door == null || door.net == null) return;
            if (!permission.UserHasPermission(player.UserIDString, _config.permissions.permissionAutoCloseDoor)) return;

            if (_data.DoorsList.Contains(door.net.ID.Value))
            {
                _data.DoorsList.Remove(door.net.ID.Value);
                SendReply(player,
                    Msg("AutoCloseEnabled", player));
            }
            else
            {
                _data.DoorsList.Add(door.net.ID.Value);
                SendReply(player,
                    Msg("AutoCloseDisabled", player));
            }

            SaveData();
        }

        private void RegisterPermissions()
        {
            if (!permission.PermissionExists(_config.permissions.permissionDeployDoor))
                permission.RegisterPermission(_config.permissions.permissionDeployDoor, this);
            if (!permission.PermissionExists(_config.permissions.permissionAutoLock))
                permission.RegisterPermission(_config.permissions.permissionAutoLock, this);
            if (!permission.PermissionExists(_config.permissions.permissionDeployBox))
                permission.RegisterPermission(_config.permissions.permissionDeployBox, this);
            if (!permission.PermissionExists(_config.permissions.permissionDeployLocker))
                permission.RegisterPermission(_config.permissions.permissionDeployLocker, this);
            if (!permission.PermissionExists(_config.permissions.permissionDeployCupboard))
                permission.RegisterPermission(_config.permissions.permissionDeployCupboard, this);
            if (!permission.PermissionExists(_config.permissions.permissionAutoCloseDoor))
                permission.RegisterPermission(_config.permissions.permissionAutoCloseDoor, this);
            if (!permission.PermissionExists(_config.permissions.permissionNoLockNeed))
                permission.RegisterPermission(_config.permissions.permissionNoLockNeed, this);
            if (!permission.PermissionExists(_config.permissions.permissionSmartHome))
                permission.RegisterPermission(_config.permissions.permissionSmartHome, this);
        }

        private void AddNewPlayer(BasePlayer player)
        {
            if (_data.PlayerInfo.ContainsKey(player.userID)) return;

            var info = new PlayerInfo
            {
                AutoLock = _config.settings.AutoLock,
                DeployDoor = _config.settings.DeployDoor,
                DeployBox = _config.settings.DeployBox,
                DeployLocker = _config.settings.DeployLocker,
                DeployCupboard = _config.settings.DeployCupboard,
                AutoDoor = _config.settings.autoDoor,
                DefaultDelay = _config.settings.defaultDelay,
                Password = UnityEngine.Random.Range(1000, 9999)
            };
            _data.PlayerInfo.Add(player.userID, info);
            SaveData();
        }

        private void SetPlayerData(BasePlayer player, int Code, bool AutoLock = true, bool DeployDoor = true,
            bool DeployBox = true, bool DeployLocker = true, bool DeployCupboard = true, bool autoDoor = true,
            float defaultDelay = 5f)
        {
            if (player == null) return;
            if (_data.PlayerInfo.ContainsKey(player.userID)) _data.PlayerInfo.Remove(player.userID);
            var info = new PlayerInfo
            {
                AutoLock = AutoLock,
                DeployDoor = DeployDoor,
                DeployBox = DeployBox,
                DeployLocker = DeployLocker,
                DeployCupboard = DeployCupboard,
                AutoDoor = autoDoor,
                DefaultDelay = defaultDelay,
                Password = Code == 0 ? UnityEngine.Random.Range(1000, 9999) : Code
            };
            _data.PlayerInfo.Add(player.userID, info);
            SaveData();
        }

        private PlayerInfo GetPlayerData(BasePlayer player)
        {
            if (player == null) return null;
            if (!_data.PlayerInfo.ContainsKey(player.userID)) AddNewPlayer(player);
            return _data.PlayerInfo[player.userID];
        }

        private void LockPlacing(BasePlayer player, BaseEntity entity)
        {
            if (!permission.UserHasPermission(player.UserIDString, _config.permissions.permissionNoLockNeed) &&
                player.inventory.Take(null, 1159991980, 1) == 0)
            {
                return;
            }

            var codeLock = GameManager.server.CreateEntity("assets/prefabs/locks/keypad/lock.code.prefab",
                new Vector3(), new Quaternion(), true) as CodeLock;
            if (codeLock == null) return;
            codeLock.gameObject.Identity();
            codeLock.SetParent(entity, entity.GetSlotAnchorName(BaseEntity.Slot.Lock));
            //codeLock.OnDeployed(entity, player);
            codeLock.Spawn();
            entity.SetSlot(BaseEntity.Slot.Lock, codeLock);
            if (!permission.UserHasPermission(player.UserIDString, _config.permissions.permissionAutoLock) ||
                !_data.PlayerInfo[player.userID].AutoLock) return;
            codeLock.code = Convert.ToString(_data.PlayerInfo[player.userID].Password != 0
                ? _data.PlayerInfo[player.userID].Password
                : UnityEngine.Random.Range(1234, 9876));
            _hasCode.SetValue(codeLock, true);
            codeLock.whitelistPlayers.Add(player.userID);
            var clanList = Clans?.Call<List<string>>("GetClanMembers", player.userID);
            if (clanList != null && clanList.Count > 0)
            {
                foreach (var clanuser in clanList)
                {
                    codeLock.whitelistPlayers.Add(ulong.Parse(clanuser));
                } 
            }
            else
            {
                codeLock.whitelistPlayers.Add(player.userID);
            }
            if (RelationshipManager.ServerInstance.FindPlayersTeam(player.userID) != null)
            {
                foreach (var playerID in player.Team.members)
                {
                    codeLock.whitelistPlayers.Add(playerID);

                }
            }
            codeLock.SetFlag(BaseEntity.Flags.Locked, true);
            Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.updated.prefab",
                entity.transform.position);
            var code = codeLock.code;
            if (player.net.connection.info.GetBool("global.streamermode")) code = "****";
            SendReply(player, string.Format(Msg("CodeAuth", player), code));
        }

        private void CodeLockCommand(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, _config.permissions.permissionAutoLock) &&
                !permission.UserHasPermission(player.UserIDString, _config.permissions.permissionDeployDoor) &&
                !permission.UserHasPermission(player.UserIDString, _config.permissions.permissionDeployBox) &&
                !permission.UserHasPermission(player.UserIDString, _config.permissions.permissionDeployLocker) &&
                !permission.UserHasPermission(player.UserIDString, _config.permissions.permissionDeployCupboard))
            {
                SendReply(player,
                    Msg("NoAccess", player));
                return;
            }

            if (args.Length == 0)
            {
                var sb = new StringBuilder();
                sb.AppendLine(string.Format(Msg("CommandUsage", player), _config.codelockCommand));
                if (permission.UserHasPermission(player.UserIDString, _config.permissions.permissionAutoLock))
                    sb.AppendLine(String.Format(Msg("CommandAutolock", player), "auto", _data.PlayerInfo[player.userID].AutoLock
                                      ? "ON"
                                      : "OFF"));
                var pin = Convert.ToString(_data.PlayerInfo[player.userID].Password);
                if (player.net.connection.info.GetBool("global.streamermode")) pin = "****";
                sb.AppendLine(String.Format(Msg("CommandPinCode", player),"pin", _data.PlayerInfo[player.userID].Password > 0
                    ? pin
                    : Msg("CommandPinCodeNotSet", player)));
                SendReply(player, sb.ToString().TrimEnd());
                return;
            }

            switch (args[0].ToLower())
            {
                case "auto":
                    _data.PlayerInfo[player.userID].AutoLock = !_data.PlayerInfo[player.userID].AutoLock;
                        SendReply(player,
                            (_data.PlayerInfo[player.userID].AutoLock
                                ? Msg("AutoLockEnabled", player)
                                : Msg("AutoLockDisabled", player)));//Изменено
                    break;
               case "pin":
                    int pin;
                    if (args.Length != 2) goto case "noaccess";
                    //Puts(int.TryParse(args[1], out pin).ToString());
                    if (int.TryParse(args[1], out pin) == false || int.Parse(args[1]) > 9999 || int.Parse(args[1]) < 1000) goto case "badargument";
                    _data.PlayerInfo[player.userID].Password = pin;
                    SendReply(player, string.Format(Msg("CommandPinCodeSetTo", player), pin));
                    break;
                case "noaccess":
                    SendReply(player, string.Format(Msg("CommandPinCodeHelp", player), _config.codelockCommand));
                    break;
                 case "badargument":
                     SendReply(player, string.Format(Msg("BadFormatPin", player), args[1]));
                    break;
                    
                default:
                    SendReply(player, string.Format(Msg("NotSupported", player), args[0]));
                    break;
            }
        }
        
        #endregion

        #region Data
        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, _data);

        private void LoadData()
        {
            try
            {
                _data = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            }
            catch (Exception e)
            {
                PrintError(e.ToString());
            }

            if (_data == null) _data = new StoredData();
            _dataLoaded = true;
        }
        class StoredData
        {
            public Dictionary<ulong, PlayerInfo> PlayerInfo = new Dictionary<ulong, PlayerInfo>();
            public List<ulong> DoorsList = new List<ulong>();
        }
        
        class PlayerInfo
        {
            public bool AutoLock;
            public bool DeployDoor;
            public bool DeployBox;
            public bool DeployLocker;
            public bool DeployCupboard;
            public int Password;
            public bool AutoDoor;
            public float DefaultDelay;
        }
        #endregion

        #region Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(
                new Dictionary<string, string>
                {
                    {"AllAutoCloseEnabled", "<color=#00FFFF></color><color=#FFFFFF> Automatic doors closing for you is enabled</color>"},
                    {"AllAutoCloseDisabled", "<color=#00FFFF></color><color=#FFFFFF> Automatic doors closing for you is disabled</color>"},
                    {"BadFormatPin", "<color=#00FFFF></color><color=#FFFFFF> Error syntax pin: <color=#FF0000>{0}</color></color>"},
                    {"AutoCloseEnabled", "<color=#00FFFF></color><color=#FFFFFF> Automatic closing of <color=#00FF00>THIS DOOR</color> for all authorized players is enabled</color>"},
                    {"AutoCloseDisabled", "<color=#00FFFF></color><color=#FFFFFF> Automatic closing of <color=#FF0000>THIS DOOR</color> for all authorized players is disabled</color>"},
                    {"AutoLockEnabled", "<color=#00FFFF></color><color=#FFFFFF> CodeLock automation (secure and lock) enabled</color>"},
                    {"AutoLockDisabled", "<color=#00FFFF></color><color=#FFFFFF> CodeLock automation disabled</color>"},
                    {"DeployLockDoorEnabled", "<color=#00FFFF></color><color=#FFFFFF> Doors will include codelocks on deploy</color>"},
                    {"DeployLockDoorDisabled", "<color=#00FFFF></color><color=#FFFFFF> Doors will not include codelocks on deploy</color>"},
                    {"DeployLockBoxEnabled", "<color=#00FFFF></color><color=#FFFFFF> Boxes will include codelocks on deploy</color>"},
                    {"DeployLockBoxDisabled", "<color=#00FFFF></color><color=#FFFFFF> Boxes will not include codelocks on deploy</color>"},
                    {"DeployLockLockerEnabled", "<color=#00FFFF></color><color=#FFFFFF> Locker will include codelocks on deploy</color>"},
                    {"DeployLockLockerDisabled", "<color=#00FFFF></color><color=#FFFFFF> Locker will not include codelocks on deploy</color>"},
                    {"DeployLockCupEnabled", "<color=#00FFFF></color><color=#FFFFFF> Cupboards will include codelocks on deploy</color>"},
                    {"DeployLockCupDisabled", "<color=#00FFFF></color><color=#FFFFFF> Cupboards will not include codelocks on deploy</color>"},
                    {"CodeAuth", "<color=#00FFFF></color><color=#FFFFFF> CodeLock secured and locked with <color=#00FF00>{0}</color></color>"},
                    {"NoAccess", "<color=#00FFFF></color><color=#FFFFFF> You are not granted for this feature</color>"},
                    {"NotSupported", "<color=#00FFFF></color><color=#FFFFFF> The specific function <color=#FF0000>{0}</color> is not available</color>"},
                    {"CommandUsage", "<color=#FFFFFF>Command usage: <color=#00FF00>{0}</color></color>"},
                    {"CommandToggle", "<color=#FFFFFF>All switches toggle their setting (on<>off)</color>"},
                    {"CommandAutolock", "<color=#FFFFFF><color=#00FF00>{0}</color> - Autolock feature: <color=#00FF00>{1}</color></color>"}, 
                    {"CommandPinCode", "<color=#FFFFFF><color=#00FF00>{0}</color> - Your current PIN: <color=#00FF00>{1}</color></color>"},
                    {"CommandPinCodeNotSet", "<color=#FFFFFF>Random 8-Digits</color>"},
                    {"CommandPinCodeSetTo", "<color=#00FFFF></color><color=#FFFFFF> Your Pin was succesful set to: <color=#00FF00>{0}</color></color>"},
                    {"CommandPinCodeHelp", "<color=#00FFFF></color><color=#FFFFFF> Set your PIN with <color=#00FF00>/{1} pin 1234</color> (4-Digits)"},
                    {"CommandDeployDoor", "<color=#FFFFFF> Deploy with Door:</color>"}, 
                    {"CommandDeployBox", "<color=#FFFFFF> Deploy with Box:</color>"},
                    {"CommandDeployLocker", "<color=#FFFFFF> Deploy with Locker:</color>"}, 
                    {"CommandDeployCupboard", "<color=#FFFFFF> Deploy with Cupboard:</color>"},
                }, this);
        lang.RegisterMessages(
                new Dictionary<string, string>
                {
                    {"AllAutoCloseEnabled", "<color=#00FFFF></color><color=#FFFFFF> Автоматическое закрытие всех дверей для Вас <color=#00FF00>ВКЛЮЧЕНО</color></color>"},
                    {"AllAutoCloseDisabled", "<color=#00FFFF></color><color=#FFFFFF> Автоматическое закрытие всех дверей для Вас <color=#FF0000>ВЫКЛЮЧЕНО</color></color>"},
                    {"BadFormatPin", "<color=#00FFFF></color><color=#FFFFFF> Неправильный формат пароля: <color=#FF0000>{0}</color></color>"},
                    {"AutoCloseEnabled", "<color=#00FFFF></color><color=#FFFFFF> Автоматическое закрытие <color=#00FF00>ЭТОЙ ДВЕРИ</color> для всех авторизованных игроков <color=#00FF00>ВКЛЮЧЕНО</color></color>"},
                    {"AutoCloseDisabled", "<color=#00FFFF></color><color=#FFFFFF> Автоматическое закрытие <color=#FF0000>ЭТОЙ ДВЕРИ</color> для всех авторизованных игроков <color=#FF0000>ВЫКЛЮЧЕНО</color></color>"},
                    {"AutoLockEnabled", "<color=#00FFFF></color><color=#FFFFFF> Автоматическая установка замка с паролем <color=#00FF00>ВКЛЮЧЕНА</color></color>"},
                    {"AutoLockDisabled", "<color=#00FFFF></color><color=#FFFFFF> Автоматическая установка замка с паролем <color=#FF0000>ВЫКЛЮЧЕНА</color></color>"},
                    {"DeployLockDoorEnabled", "<color=#00FFFF></color><color=#FFFFFF> Замки <color=#00FF00>будут</color> автоматически устанавливаться на двери</color>"},
                    {"DeployLockDoorDisabled", "<color=#00FFFF></color><color=#FFFFFF> Замки <color=#FF0000>не будут</color> автоматически устанавливаться на двери</color>"},
                    {"DeployLockBoxEnabled", "<color=#00FFFF></color><color=#FFFFFF> Замки <color=#00FF00>будут</color> автоматически устанавливаться на ящики</color>"},
                    {"DeployLockBoxDisabled", "<color=#00FFFF></color><color=#FFFFFF> Замки <color=#FF0000>не будут</color> автоматически устанавливаться на ящики</color>"},
                    {"DeployLockLockerEnabled", "<color=#00FFFF></color><color=#FFFFFF> Замки <color=#00FF00>будут</color> автоматически устанавливаться на шкафы с одеждой</color>"},
                    {"DeployLockLockerDisabled", "<color=#00FFFF></color><color=#FFFFFF> Замки <color=#FF0000>не будут</color> автоматически устанавливаться на шкафы с одеждой</color>"},
                    {"DeployLockCupEnabled", "<color=#00FFFF></color><color=#FFFFFF> Замки <color=#00FF00>будут</color> автоматически устанавливаться на шкафы</color>"},
                    {"DeployLockCupDisabled", "<color=#00FFFF></color><color=#FFFFFF> Замки <color=#FF0000>не будут</color> автоматически устанавливаться на шкафы</color>"},
                    {"CodeAuth", "<color=#00FFFF></color><color=#FFFFFF> Замок установлен! Пароль <color=#00FF00>{0}</color></color>"},
                    {"NoAccess", "<color=#00FFFF></color><color=#FFFFFF> У вас нету привилегии для использования команды</color>"},
                    {"NotSupported", "<color=#00FFFF></color><color=#FFFFFF> Функция <color=#FF0000>{0}</color> недоступна!</color>"},
                    {"CommandUsage", "<color=#FFFFFF>Команда: <color=#00FF00>{0}</color></color>"},
                    {"CommandToggle", "<color=#FFFFFF>Используется переключение <color=#00FF00>ON/OFF</color></color>"},
                    {"CommandAutolock", "<color=#FFFFFF><color=#00FF00>{0}</color> - значение: <color=#00FF00>{1}</color></color>"}, 
                    {"CommandPinCode", "<color=#FFFFFF><color=#00FF00>{0}</color> - Текущий пароль: <color=#00FF00>{1}</color></color>"},    
                    {"CommandPinCodeNotSet", "<color=#FFFFFF>Случайные 8 цифр</color>"},
                    {"CommandPinCodeSetTo", "<color=#00FFFF></color><color=#FFFFFF> Ваш пароль: <color=#00FF00>{0}</color>"},
                    {"CommandPinCodeHelp", "<color=#00FFFF></color><color=#FFFFFF> Установить пароль <color=##00FF00>/{1} pin 1234</color> (4 цифры)</color>"},
                    {"CommandDeployDoor", "<color=#FFFFFF> Установка на двери:</color>"}, 
                    {"CommandDeployBox", "<color=#FFFFFF> Установка на ящики:</color>"},
                    {"CommandDeployLocker", "<color=#FFFFFF> Установка на шкаф с одеждой:</color>"}, 
                    {"CommandDeployCupboard", "<color=#FFFFFF> Установка на шкаф:</color>"},
                }, this, "ru");
        }    
        private string Msg(string key, BasePlayer player = null) =>
            lang.GetMessage(key, this, player.UserIDString);
        #endregion    
        
    }
}

// --- End of file: DoorsControl.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/VehicleManager.cs ---
// --- Original Local Path: TrashRust/VehicleManager.cs ---

using Oxide.Core;
using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using Network;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
	[Info("Vehicle Manager", "rostov114", "0.2.3")]
	class VehicleManager : RustPlugin
	{
		#region Variables
		private static Configuration _config;
		public static VehicleManager _instance;
		#endregion

		#region Configuration
		public class Configuration
		{
			[JsonProperty("Разрешить подъем транспорта киянкой")]
			public bool allowPickupVehicle;

			[JsonProperty("shortname объекта который держит игрок при установке транспорта")]
			public string vehicleShortPrefabName;

			[JsonProperty("Список транспорта")]
			public List<VehicleInfo> vehicles;
		}

		protected override void LoadConfig()
		{
			base.LoadConfig();
			try
			{
				_config = Config.ReadObject<Configuration>();
				this.SaveConfig();
			}
			catch
			{
				PrintError("Error reading config, please check!");
			}
		}

		protected override void LoadDefaultConfig()
		{
			_config = new Configuration();

			_config.allowPickupVehicle = true;
			_config.vehicleShortPrefabName = "box.wooden.large";
			_config.vehicles = new List<VehicleInfo>()
			{
				new VehicleInfo("boat", "assets/content/vehicles/boats/rowboat/rowboat.prefab", 2189173891, "assets/bundled/prefabs/fx/build/promote_TopTier.prefab"),
				new VehicleInfo("rhib", "assets/content/vehicles/boats/rhib/rhib.prefab", 2189175322, "assets/bundled/prefabs/fx/build/promote_TopTier.prefab"),
				new VehicleInfo("minicopter", "assets/content/vehicles/minicopter/minicopter.entity.prefab", 2189176096, "assets/bundled/prefabs/fx/build/promote_TopTier.prefab"),
				new VehicleInfo("balloon", "assets/prefabs/deployable/hot air balloon/hotairballoon.prefab", 2189176712, "assets/bundled/prefabs/fx/build/promote_TopTier.prefab"),
				new VehicleInfo("sedan", "assets/content/vehicles/sedan_a/sedantest.entity.prefab", 2189177307, "assets/bundled/prefabs/fx/build/promote_TopTier.prefab"),
				new VehicleInfo("horse", "assets/rust.ai/nextai/testridablehorse.prefab", 2189177940, "assets/bundled/prefabs/fx/build/promote_TopTier.prefab"),
				new VehicleInfo("ch47", "assets/prefabs/npc/ch47/ch47.entity.prefab", 2189180720, "assets/bundled/prefabs/fx/build/promote_TopTier.prefab"),
				new VehicleInfo("scraptransportheli", "assets/content/vehicles/scrap heli carrier/scraptransporthelicopter.prefab", 2189181296, "assets/bundled/prefabs/fx/build/promote_TopTier.prefab"),
				new VehicleInfo("2module_car", "assets/content/vehicles/modularcar/2module_car_spawned.entity.prefab", 2162472804, "assets/bundled/prefabs/fx/build/promote_TopTier.prefab"),
				new VehicleInfo("3module_car", "assets/content/vehicles/modularcar/3module_car_spawned.entity.prefab", 2162478030, "assets/bundled/prefabs/fx/build/promote_TopTier.prefab"),
				new VehicleInfo("4module_car", "assets/content/vehicles/modularcar/4module_car_spawned.entity.prefab", 2162478376, "assets/bundled/prefabs/fx/build/promote_TopTier.prefab")
			};
		}

		protected override void SaveConfig()
		{
			Config.WriteObject(_config);
		}
		#endregion

		#region VehicleInfo Class
		public class VehicleInfo
		{
			[JsonProperty("Короткое имя транспорта")]
			public string shortname;

			[JsonProperty("prefab транспорта")]
			public string prefab;

			[JsonProperty("skinID транспорта")]
			public ulong skinID;

			[JsonProperty("Effect который проигрывается при установке транспорта")]
			public string placementEffect;

			public VehicleInfo(string shortname, string prefab, ulong skinID, string placementEffect = null)
			{
				this.shortname			= shortname;
				this.prefab				= prefab;
				this.skinID				= skinID;
				this.placementEffect	= placementEffect;
			}

			public string Give(BasePlayer player, string shortname, string text = null, BaseVehicle vehicle = null)
			{
				Item item = ItemManager.CreateByName(shortname, 1, this.skinID);
				if (item != null)
				{
					item.name = _instance._(player, this.shortname);

					if (!string.IsNullOrEmpty(text))
						item.text = text;

					Interface.Oxide.CallHook("OnGiveVehicle", player, item);

					if (text == "pickup" && vehicle != null)
						Interface.Oxide.CallHook("OnPickupVehicle", player, item, vehicle);

					player.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);
					return item.name;
				}

				return null;
			}

			public BaseEntity Spawn(Vector3 position, Quaternion rotation, BasePlayer player, Item ownerItem)
			{
				BaseEntity entity = GameManager.server.CreateEntity(this.prefab, position, rotation) as BaseEntity;

				if (entity != null)
				{
					entity.transform.Rotate(0, 90, 0);

					Interface.Oxide.CallHook("OnSpawnVehicle", player, entity, ownerItem);

					entity.Spawn();

					return entity;
				}

				return null;
			}

			public static VehicleInfo FindByShortname(string shortname)
			{
				if (shortname == null)
					return null;

				List<VehicleInfo> _vehicle = _config.vehicles.Where(v => v.shortname.Contains(shortname)).ToList();
				if (_vehicle != null && _vehicle.Count > 0)
					return _vehicle.First();

				return null;
			}

			public static VehicleInfo FindByPrefab(string prefab)
			{
				if (prefab == null)
					return null;

				List<VehicleInfo> _vehicle = _config.vehicles.Where(v => v.prefab == prefab).ToList();
				if (_vehicle != null && _vehicle.Count > 0)
					return _vehicle.First();

				return null;
			}

			public static VehicleInfo FindBySkinID(ulong skinID)
			{
				if (skinID == 0 || skinID == null)
					return null;

				List<VehicleInfo> _vehicle = _config.vehicles.Where(v => v.skinID == skinID).ToList();
				if (_vehicle != null && _vehicle.Count > 0)
					return _vehicle.First();

				return null;
			}

			public static List<string> ShortNameList() // Я хлебушек, мне так можно
			{
				List<string> _vehicles = new List<string>();
				foreach (VehicleInfo _vehicle in _config.vehicles)
					_vehicles.Add(_vehicle.shortname);

				return _vehicles;
			}
		}
		#endregion

		#region Language
		private void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<string, string>
			{
				["rhib"] = "RHIB",
				["minicopter"] = "MiniCopter",
				["boat"] = "Boat",
				["balloon"] = "Air balloon",
				["sedan"] = "Car",
				["horse"] = "Horse",
				["scraptransportheli"] = "Transport Helicopter",
				["ch47"] = "Chinook",
				["2module_car"] = "Small chassis",
				["3module_car"] = "Medium chassis",
				["4module_car"] = "Large chassis",

				["ConsoleSyntax"] = "Syntax: vehicle.give <steamid|username> <{0}> [shortname] [comment]",
				["PlayerNotFound"] = "Player '{0}' not found!",
				["VehicleNotFound"] = "Vehicle '{0}' not found!",
				["ShortnameNotFound"] = "Item shortname '{0}' not found!",
				["SuccessfullyGive"] = "Transport '{0}' successfully give to '{1}'",
			}, this);

			lang.RegisterMessages(new Dictionary<string, string>
			{
				["rhib"] = "Военный катер",
				["minicopter"] = "MiniCopter",
				["boat"] = "Лодка",
				["balloon"] = "Воздушный шар",
				["sedan"] = "Автомобиль",
				["horse"] = "Лошадь",
				["scraptransportheli"] = "Транспортный вертолет",
				["ch47"] = "Чинук",
				["2module_car"] = "Маленькое шасси",
				["3module_car"] = "Среднее шасси",
				["4module_car"] = "Большое шасси",

				["ConsoleSyntax"] = "Синтаксис: vehicle.give <steamid|username> <{0}> [shortname] [comment]",
				["PlayerNotFound"] = "Игрок с никнеймом '{0}' не найден!",
				["VehicleNotFound"] = "Транспорт с названием '{0}' не найден!",
				["ShortnameNotFound"] = "Item с shortname '{0}' не найден!",
				["SuccessfullyGive"] = "Транспорт '{0}' успешно выдан игроку '{1}'",
			}, this, "ru");
		}

		private string _(BasePlayer player, string key, params object[] args)
		{
			return string.Format(lang.GetMessage(key, this, player?.UserIDString), args);
		}
		#endregion

		#region Init
		private void OnServerInitialized()
		{
			_instance = this;

			foreach (BasePlayer player in BasePlayer.activePlayerList)
				foreach (Item item in player.inventory.AllItems())
					this.ChangeVehicleName(item, player);
		}

		private void Unload()
		{
			_instance = null;
			_config   = null;
		}
		#endregion

		#region OxideHooks
		private void OnPlayerConnected(BasePlayer player) 
		{
			player.inventory.AllItems().ToList().ForEach(it => this.ChangeVehicleName(it, player));
		}

		private void OnItemAddedToContainer(ItemContainer container, Item item) 
		{
			if (container == null || item == null || container.playerOwner == null)
				return;

			this.ChangeVehicleName(item, container.playerOwner);
		}

		private object CanNpcGiveSoldItem(NPCVendingMachine vending, Item soldItem, BasePlayer buyer) // Vending Old School
		{
			if (soldItem.skin > 0)
			{
				VehicleInfo vehicle = VehicleInfo.FindBySkinID(soldItem.skin);
				if (vehicle != null)
				{
					return true;
				}
			}

			return null;
		}

		private object OnNpcGiveSoldItem(NPCVendingMachine vending, Item soldItem, BasePlayer buyer) 
		{
			if (soldItem.skin > 0)
			{
				VehicleInfo vehicle = VehicleInfo.FindBySkinID(soldItem.skin);
				if (vehicle != null)
				{
					vehicle.Give(buyer, _config.vehicleShortPrefabName, "npcvending");
					return true;
				}
			}

			return null;
		}

		private object CanBuild(Planner plan, Construction construction, Construction.Target target) 
		{
			if (construction.fullName.Contains(_config.vehicleShortPrefabName))
			{
				Item ownerItem = plan.GetItem();
				if (ownerItem != null && ownerItem.info.shortname == _config.vehicleShortPrefabName)
				{
					VehicleInfo vehicle = VehicleInfo.FindBySkinID(ownerItem.skin);
					if (vehicle == null)
						return null;

					if (Interface.Oxide.CallHook("CanSpawnVehicle", target.player, ownerItem, plan, construction, target) != null)
						return true;

					BaseEntity baseEntity = construction.CreateConstruction(target, true);
					BaseEntity entity = vehicle.Spawn(baseEntity.transform.position, baseEntity.transform.rotation, target.player, ownerItem);
					entity.skinID = ownerItem.skin;

					NextTick(() =>
					{
						Interface.Oxide.CallHook("OnDoSpawnVehicle", target.player, entity, ownerItem);

						plan.PayForPlacement(target.player, construction);

						baseEntity.Kill();
					});

					if (!string.IsNullOrEmpty(vehicle.placementEffect))
						Effect.server.Run(vehicle.placementEffect, entity, 0u, Vector3.zero, Vector3.zero, null, false);

					return true;
				}
			}

			return null;
		}

		private object OnHammerHit(BasePlayer player, HitInfo info) 
		{
			if (!_config.allowPickupVehicle || player == null || info == null || info?.HitEntity == null) 
				return null;

			if (player.serverInput.IsDown(BUTTON.FIRE_SECONDARY))
			{
				BaseVehicle hvehicle = null;

				if (info.HitEntity is BaseVehicle)
				{
					hvehicle = info.HitEntity as BaseVehicle;
				}

				if (info.HitEntity is BaseVehicleModule)
				{
					hvehicle = (info.HitEntity as BaseVehicleModule).Vehicle;
				}

				if (hvehicle != null)
				{
					VehicleInfo vehicle = VehicleInfo.FindBySkinID(hvehicle.skinID);
					if (vehicle == null)
					{
						vehicle = VehicleInfo.FindByPrefab(hvehicle.PrefabName);
						if (vehicle == null)
							return null;
					}

					if (Interface.Oxide.CallHook("CanPickupVehicle", player, hvehicle) != null)
						return true;

					vehicle.Give(player, _config.vehicleShortPrefabName, "pickup", hvehicle);

					NextTick(() =>
					{
						hvehicle.Kill();
					});

					return false;
				}
			}

			return null;
		}

		private object OnItemCustomName(int itemID, ulong skinID, string language = "ru") 
		{
			if (itemID == -932201673 && skinID == 0 && language == "ru")
			{
				return "Металлолом";
			}

			VehicleInfo vehicle = VehicleInfo.FindBySkinID(skinID);
			if (vehicle == null)
				return null;

			Dictionary<string, string>  messages = lang.GetMessages(language, this);
			if (!messages.ContainsKey(vehicle.shortname))
				return null;

			return messages[vehicle.shortname];
		}

		private void OnPlayerSetInfo(Connection connection, string key, string val)
		{
			if (key == "global.language")
			{
				NextTick(() =>
				{
					BasePlayer player = Player.FindById(connection.userid);
					if (player != null)
					{
						this.OnPlayerConnected(player);
					}
				});
			}
		}
		#endregion

		#region Console Hooks
		[ConsoleCommand("vehicle.give")]
		void ConsoleCommand_vehicleshop_give(ConsoleSystem.Arg arg)
		{
			BasePlayer p = arg?.Player() ?? null; 
			if (p != null && !p.IsAdmin) 
				return;

			if (!arg.HasArgs(2))
			{
				SendReply(arg, _(p, "ConsoleSyntax", string.Join("|",  VehicleInfo.ShortNameList())));
				return;
			}

			BasePlayer player = BasePlayer.Find(arg.GetString(0));
			if (player == null)
			{
				SendReply(arg, _(p, "PlayerNotFound", arg.GetString(0)));
				return;
			}

			VehicleInfo vehicle = VehicleInfo.FindByShortname(arg.GetString(1));
			if (vehicle == null)
			{
				SendReply(arg, _(p, "VehicleNotFound", arg.GetString(1)));
				SendReply(arg, _(p, "ConsoleSyntax", string.Join("|",  VehicleInfo.ShortNameList())));
				return;
			}

			string shortname = _config.vehicleShortPrefabName;
			if (arg.HasArgs(3) && arg.GetString(2) != "default")
			{
				ItemDefinition info = ItemManager.FindItemDefinition(arg.GetString(2));
				if (info == null) 
				{
					SendReply(arg, _(p, "ShortnameNotFound", arg.GetString(2)));
					return;
				}

				shortname = info.shortname;
			}

			SendReply(arg, _(p, "SuccessfullyGive", vehicle.Give(player, shortname, arg.GetString(3, "console")), player.displayName));
		}
		#endregion

		#region Helpers
		private void ChangeVehicleName(Item item, BasePlayer player) 
		{
			if (item == null || player == null || item?.info == null || item.info.shortname != _config.vehicleShortPrefabName || item.skin == 0)
				return;

			VehicleInfo vehicle = VehicleInfo.FindBySkinID(item.skin);
			if (vehicle == null)
				return;

			item.name = _(player, vehicle.shortname);
			player.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
		}
		#endregion
	}
}

// --- End of file: VehicleManager.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/XCraft.cs ---
// --- Original Local Path: TrashRust/XCraft.cs ---

﻿using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("XCraft", "VooDoo", "1.0")]
    [Description("Craft tab for XMenu")]
    public class XCraft : RustPlugin
    {
        [PluginReference] Plugin XMenu;
        [PluginReference] Plugin Notifications;

        #region Image Library
        [PluginReference] Plugin ImageLibrary;
        bool AddImage(string url, string imageName, ulong imageId, Action callback = null) => (bool)ImageLibrary.Call("AddImage", url, imageName, imageId, callback);
        string GetImage(string imageName, ulong imageId = 0, bool returnUrl = false) => (string)ImageLibrary.Call("GetImage", imageName, imageId, returnUrl);
        #endregion

        #region Config
        private PluginConfig config;
        private class PluginConfig
        {
            public ColorConfig colorConfig;
            public class ColorConfig
            {
                public string menuContentHighlighting;
                public string menuContentHighlightingalternative;

                public string gradientColor;
            }
        }

        private void Init()
        {
            config = Config.ReadObject<PluginConfig>();
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                colorConfig = new PluginConfig.ColorConfig()
                {
                    menuContentHighlighting = "#0000007f",
                    menuContentHighlightingalternative = "#FFFFFF10",

                    gradientColor = "#00000099",
                }
            };
        }
        #endregion

        #region Data
        private Dictionary<string, int> categoryID = new Dictionary<string, int>();
        public Dictionary<string, Category> CategoryList = new Dictionary<string, Category>();
        public Dictionary<string, Category> CategoryListCache = new Dictionary<string, Category>();

        public class Category
        {
            public string CategoryName;
            public Dictionary<string, ItemMK2> Items;
        }

        public class ItemMK2
        {
            public string DisplayName;
            public string DisplayDescription;
            public string DisplayImage;

            public int WorkbenchLevel;
            public List<Ingredient> Ingredients;

            public string ItemResult;
            public string CommandResult;
        }

        public class Ingredient
        {
            public string DisplayName;
            public string ShortName;
            public int Amount;
            public ulong SkinID;
        }
        #endregion

        #region Initialize
        Timer TimerInitialize;
        private void OnServerInitialized()
        {
            CategoryList = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, Category>>("CraftData");

            foreach (var category in CategoryList)
            {
                foreach (var itemMk2 in category.Value.Items)
                {
                    if (itemMk2.Value.DisplayImage.StartsWith("http"))
                        AddImage(itemMk2.Value.DisplayImage, itemMk2.Value.DisplayImage, 0);
                }
            }

            TimerInitialize = timer.Every(5f, () =>
            {
                if (XMenu.IsLoaded)
                {
                    XMenu.Call("API_RegisterMenu", this.Name, "CraftMenu", "assets/icons/player_carry.png", null, null);
                    foreach (var Category in CategoryList)
                        XMenu.Call("API_RegisterSubMenu", this.Name, "CraftMenu", Category.Key, $"RenderCraftMenu", null);

                    foreach (var Category in CategoryList)
                        categoryID.Add(Category.Key, (int)XMenu.Call("API_GetSubMenuID", "CraftMenu", Category.Key));

                    cmd.AddChatCommand("craft", this, (p, cmd, args) => rust.RunClientCommand(p, "custommenu true CraftMenu"));
                    TimerInitialize.Destroy();
                }
            });
        }
        #endregion

        #region Layers
        public const string MenuLayer = "XMenu";
        public const string MenuItemsLayer = "XMenu.MenuItems";
        public const string MenuSubItemsLayer = "XMenu.MenuSubItems";
        public const string MenuContent = "XMenu.Content";
        #endregion

        #region UI
        private void RenderCraftMenu(ulong userID, object[] objects)
        {
            BasePlayer player = BasePlayer.FindByID(userID);
            CuiElementContainer Container = (CuiElementContainer)objects[0];
            string Title = CategoryList.ElementAt((int)objects[3]).Key;
            string Name = string.Empty;
            int itemCount = 1;

            if (!string.IsNullOrEmpty((string)objects[5]))
            {
                itemCount = int.Parse(((string)objects[5]).Split(' ')[0]);
                Name = string.Join(" ", ((string)objects[5]).Split(' ').Skip(1));
            }

            Container.Add(new CuiElement
            {
                Name = MenuContent,
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0 0 0 0",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-215 -230",
                            OffsetMax = "500 270"
                        },
                    }
            });

            if (string.IsNullOrEmpty(Name))
            {
                for (int i = 0, x = 0, y = 0; i < CategoryList[Title].Items.Count; i++, x++)
                {
                    if (x > 5)
                    {
                        x = 0;
                        y++;
                    }

                    Container.Add(new CuiElement
                    {
                        Name = MenuContent + "." + CategoryList[Title].Items.ElementAt(i).Key,
                        Parent = MenuContent,
                        Components =
                        {
                            new CuiImageComponent
                            {
                                Color = "0 0 0 0.5",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0 1",
                                AnchorMax = "0 1",
                                OffsetMin = $"{62.5 + x * 100} {-140 - y * 100}",
                                OffsetMax = $"{152.5 + x * 100} {-50 - y * 100}"
                            }
                        }
                    });

                    Container.Add(new CuiButton
                    {
                        Button = { Color = "0 0 0 0", Command = $"custommenu false CraftMenu {categoryID[Title]} 0 1 {CategoryList[Title].Items.ElementAt(i).Key}", },
                        RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = $"{62.5 + x * 100} {-140 - y * 100}", OffsetMax = $"{152.5 + x * 100} {-50 - y * 100}" },
                        Text = { Text = "", Align = TextAnchor.MiddleCenter, FontSize = 20 }
                    }, MenuContent, MenuContent + "." + CategoryList[Title].Items.ElementAt(i).Key + ".Btn");

                    Container.Add(new CuiElement
                    {
                        Name = MenuContent + "." + CategoryList[Title].Items.ElementAt(i).Key + ".Img",
                        Parent = MenuContent + "." + CategoryList[Title].Items.ElementAt(i).Key,
                        Components =
                        {
                            new CuiImageComponent
                            {
                                Color = "1 1 1 0.05",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.10 0.10",
                                AnchorMax = "0.90 0.90",
                            }
                        }
                    });

                    if (!string.IsNullOrEmpty(CategoryList[Title].Items.ElementAt(i).Value.ItemResult))
                    {
                        Container.Add(new CuiElement
                        {
                            Name = MenuContent + "." + CategoryList[Title].Items.ElementAt(i).Key + ".Img",
                            Parent = MenuContent + "." + CategoryList[Title].Items.ElementAt(i).Key + ".Img",
                            Components =
                            {
                                new CuiRawImageComponent
                                {
                                    Png = GetImage(CategoryList[Title].Items.ElementAt(i).Value.ItemResult),
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0.10 0.10",
                                    AnchorMax = "0.90 0.90",
                                }
                            }
                        });
                    }
                    else
                    {
                        Container.Add(new CuiElement
                        {
                            Name = MenuContent + "." + CategoryList[Title].Items.ElementAt(i).Key + ".Img",
                            Parent = MenuContent + "." + CategoryList[Title].Items.ElementAt(i).Key + ".Img",
                            Components =
                            {
                                new CuiRawImageComponent
                                {
                                    Png = GetImage(CategoryList[Title].Items.ElementAt(i).Value.DisplayImage)
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0.10 0.10",
                                    AnchorMax = "0.90 0.90",
                                }
                            }
                        });
                    }
                }
            }
            else
            {
                bool canCraft = HaveResourcesForItem(player, CategoryList[Title].Items[Name], itemCount);
                Container.Add(new CuiElement
                {
                    Name = MenuContent,
                    Parent = MenuContent,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0 0 0 0.5",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "62.5 -500",
                            OffsetMax = "650 -50"
                        }
                    }
                });
                Container.Add(new CuiElement
                {
                    Name = MenuContent + ".Title",
                    Parent = MenuContent,
                    Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"Крафт предмета <color=#90BD47>{Name}</color>",
                                Align = TextAnchor.MiddleCenter,
                                FontSize = 18,
                                Font = "robotocondensed-regular.ttf",
                                FadeIn = 0.5f,
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.1 0.875",
                                AnchorMax = "0.9 0.975",
                            }
                        }
                });
                Container.Add(new CuiElement
                {
                    Name = MenuContent + "." + Name,
                    Parent = MenuContent,
                    Components =
                        {
                            new CuiImageComponent
                            {
                                Color = "0 0 0 0.5",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.420 0.675",
                                AnchorMax = "0.580 0.875",
                            }
                        }
                });

                if (CategoryList[Title].Items[Name].WorkbenchLevel > 0)
                {
                    Container.Add(new CuiElement
                    {
                        Name = MenuContent + ".Workbench",
                        Parent = MenuContent,
                        Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = $"<color=#FF0000AA>Для крафта требуется верстак {CategoryList[Title].Items[Name].WorkbenchLevel} уровня</color>",
                                    Align = TextAnchor.MiddleCenter,
                                    FontSize = 14,
                                    Font = "robotocondensed-regular.ttf",
                                    FadeIn = 0.5f,
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0.1 0.625",
                                    AnchorMax = "0.9 0.675",
                                }
                            }
                    });
                }

                Container.Add(new CuiElement
                {
                    Name = MenuContent + "." + Name + ".Img",
                    Parent = MenuContent + "." + Name,
                    Components =
                        {
                            new CuiImageComponent
                            {
                                Color = "1 1 1 0.05",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.10 0.10",
                                AnchorMax = "0.90 0.90",
                            }
                        }
                });

                if (!string.IsNullOrEmpty(CategoryList[Title].Items[Name].ItemResult))
                {
                    Container.Add(new CuiElement
                    {
                        Name = MenuContent + "." + Name + ".Img",
                        Parent = MenuContent + "." + Name + ".Img",
                        Components =
                            {
                                new CuiRawImageComponent
                                {
                                    Png = GetImage(CategoryList[Title].Items[Name].ItemResult),
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0.10 0.10",
                                    AnchorMax = "0.90 0.90",
                                }
                            }
                    });
                }
                else
                {
                    Container.Add(new CuiElement
                    {
                        Name = MenuContent + "." + Name + ".Img",
                        Parent = MenuContent + "." + Name + ".Img",
                        Components =
                            {
                                new CuiRawImageComponent
                                {
                                    Png = GetImage(CategoryList[Title].Items[Name].DisplayImage)
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0.10 0.10",
                                    AnchorMax = "0.90 0.90",
                                }
                            }
                    });
                }

                Container.Add(new CuiElement
                {
                    Name = MenuContent + ".Title",
                    Parent = MenuContent,
                    Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"{CategoryList[Title].Items[Name].DisplayDescription}",
                                Align = TextAnchor.MiddleCenter,
                                FontSize = 12,
                                Font = "robotocondensed-regular.ttf",
                                FadeIn = 0.5f,
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.1 0.425",
                                AnchorMax = "0.9 0.625",
                            }
                        }
                });

                if (!canCraft)
                {
                    Container.Add(new CuiElement
                    {
                        Name = MenuContent + ".Title",
                        Parent = MenuContent,
                        Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = $"<color=#FF0000FF>У вас не хватает ресурсов для крафта {Name}</color>",
                                    Align = TextAnchor.MiddleCenter,
                                    FontSize = 12,
                                    Font = "robotocondensed-regular.ttf",
                                    FadeIn = 0.5f,
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0.1 0.025",
                                    AnchorMax = "0.9 0.075",
                                }
                            }
                    });
                }

                for (int i = 0; i < CategoryList[Title].Items[Name].Ingredients.Count; i++)
                {
                    string name = string.IsNullOrEmpty(CategoryList[Title].Items[Name].Ingredients.ElementAt(i).DisplayName) ? ItemManager.itemDictionaryByName[CategoryList[Title].Items[Name].Ingredients.ElementAt(i).ShortName].displayName.english : CategoryList[Title].Items[Name].Ingredients.ElementAt(i).DisplayName;
                    Container.Add(new CuiElement
                    {
                        Name = MenuContent + ".TableCount" + i,
                        Parent = MenuContent,
                        Components =
                        {
                            new CuiImageComponent
                            {
                                Color = "1 1 1 0.05",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = $"0.1 {0.251 - i * 0.05}",
                                AnchorMax = $"0.2 {0.301 - i * 0.05}",
                            }
                        }
                    });
                    Container.Add(new CuiElement
                    {
                        Name = MenuContent + ".TableCount" + i + ".Title",
                        Parent = MenuContent + ".TableCount" + i,
                        Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"<color=#FFFFFFAA>{CategoryList[Title].Items[Name].Ingredients.ElementAt(i).Amount}</color>",
                                Align = TextAnchor.MiddleRight,
                                FontSize = 10,
                                Font = "robotocondensed-regular.ttf",
                                FadeIn = 0.5f,
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.05 0",
                                AnchorMax = "0.95 1",
                            }
                        }
                    });
                    Container.Add(new CuiElement
                    {
                        Name = MenuContent + ".TableName" + i,
                        Parent = MenuContent,
                        Components =
                        {
                            new CuiImageComponent
                            {
                                Color = "1 1 1 0.05",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = $"0.201 {0.251 - i * 0.05}",
                                AnchorMax = $"0.7 {0.301 - i * 0.05}",
                            }
                        }
                    });
                    Container.Add(new CuiElement
                    {
                        Name = MenuContent + ".TableName" + i + ".Title",
                        Parent = MenuContent + ".TableName" + i,
                        Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"<color=#FFFFFFAA>{name}</color>",
                                Align = TextAnchor.MiddleLeft,
                                FontSize = 10,
                                Font = "robotocondensed-regular.ttf",
                                FadeIn = 0.5f,
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.05 0",
                                AnchorMax = "0.95 1",
                            }
                        }
                    });

                    Container.Add(new CuiElement
                    {
                        Name = MenuContent + ".TableCountM" + i,
                        Parent = MenuContent,
                        Components =
                        {
                            new CuiImageComponent
                            {
                                Color = "1 1 1 0.05",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = $"0.701 {0.251 - i * 0.05}",
                                AnchorMax = $"0.8 {0.301 - i * 0.05}",
                            }
                        }
                    });
                    Container.Add(new CuiElement
                    {
                        Name = MenuContent + ".TableCountM" + i + ".Title",
                        Parent = MenuContent + ".TableCountM" + i,
                        Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"<color=#FFFFFFAA>{CategoryList[Title].Items[Name].Ingredients.ElementAt(i).Amount * itemCount}</color>",
                                Align = TextAnchor.MiddleLeft,
                                FontSize = 10,
                                Font = "robotocondensed-regular.ttf",
                                FadeIn = 0.5f,
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.05 0",
                                AnchorMax = "0.95 1",
                            }
                        }
                    });

                    Container.Add(new CuiElement
                    {
                        Name = MenuContent + ".TableCountH" + i,
                        Parent = MenuContent,
                        Components =
                        {
                            new CuiImageComponent
                            {
                                Color = "1 1 1 0.05",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = $"0.801 {0.251 - i * 0.05}",
                                AnchorMax = $"0.9 {0.301 - i * 0.05}",
                            }
                        }
                    });
                    Container.Add(new CuiElement
                    {
                        Name = MenuContent + ".TableCountH" + i + ".Title",
                        Parent = MenuContent + ".TableCountH" + i,
                        Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"<color=#FFFFFFAA>{GetItemAmount(player, CategoryList[Title].Items[Name].Ingredients.ElementAt(i).ShortName, CategoryList[Title].Items[Name].Ingredients.ElementAt(i).SkinID)}</color>",
                                Align = TextAnchor.MiddleLeft,
                                FontSize = 10,
                                Font = "robotocondensed-regular.ttf",
                                FadeIn = 0.5f,
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.05 0",
                                AnchorMax = "0.95 1",
                            }
                        }
                    });
                }

                if (itemCount > 1)
                {
                    Container.Add(new CuiElement
                    {
                        Name = MenuContent + ".BackTitle",
                        Parent = MenuContent,
                        Components =
                        {
                            new CuiImageComponent
                            {
                                Color = "0 0 0 0.5",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0 1",
                                AnchorMax = "0 1",
                                OffsetMin = "0 -300",
                                OffsetMax = "30 -270"
                            }
                        }
                    });
                    Container.Add(new CuiButton
                    {
                        Button = { Color = "0 0 0 0", Command = $"custommenu false CraftMenu {categoryID[Title]} 0 {itemCount - 1} {Name}", },
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                        Text = { Text = "<", Align = TextAnchor.MiddleCenter, FontSize = 20 }
                    }, MenuContent + ".BackTitle", MenuContent + ".BackTitleBtn");
                }

                if (canCraft && !(player.currentCraftLevel < CategoryList[Title].Items[Name].WorkbenchLevel))
                {
                    Container.Add(new CuiElement
                    {
                        Name = MenuContent + ".NextTitle",
                        Parent = MenuContent,
                        Components =
                        {
                            new CuiImageComponent
                            {
                                Color = "0 0 0 0.5",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0 1",
                                AnchorMax = "0 1",
                                OffsetMin = "205 -300",
                                OffsetMax = "395 -270"
                            }
                        }
                    });
                    Container.Add(new CuiButton
                    {
                        Button = { Color = "0 0 0 0", Command = $"excraft {Title} {itemCount} {Name}" },
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                        Text = { Text = "Скрафтить", Align = TextAnchor.MiddleCenter, FontSize = 16 }
                    }, MenuContent + ".NextTitle", MenuContent + ".NextTitleBtn");
                }

                if (true)
                {
                    Container.Add(new CuiElement
                    {
                        Name = MenuContent + ".NextTitle",
                        Parent = MenuContent,
                        Components =
                        {
                            new CuiImageComponent
                            {
                                Color = "0 0 0 0.5",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0 1",
                                AnchorMax = "0 1",
                                OffsetMin = "560 -300",
                                OffsetMax = "590 -270"
                            }
                        }
                    });
                    Container.Add(new CuiButton
                    {
                        Button = { Color = "0 0 0 0", Command = $"custommenu false CraftMenu {categoryID[Title]} 0 {itemCount + 1} {Name}", },
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                        Text = { Text = ">", Align = TextAnchor.MiddleCenter, FontSize = 20 }
                    }, MenuContent + ".NextTitle", MenuContent + ".NextTitleBtn");
                }
            }
        }
        #endregion

        [ConsoleCommand("excraft")]
        void CmdCraft(ConsoleSystem.Arg arg)
        {
            string Title = arg.Args[0];
            string ItemName = string.Join(" ", arg.Args.Skip(2));
            int Amount = int.Parse(arg.Args[1]);

            ItemMK2 item = CategoryList[Title].Items[ItemName];
            if (!HaveResourcesForItem(arg.Player(), item, Amount))
            {
                Notifications.Call("API_AddUINote", arg.Connection.userid, $"У вас не хватает ресурсов для крафта {ItemName}");
                return;
            }

            if (arg.Player().currentCraftLevel < item.WorkbenchLevel)
            {
                Notifications.Call("API_AddUINote", arg.Connection.userid, $"Вы должны стоять у верстака {item.WorkbenchLevel} уровня для крафта {ItemName}");
                return;
            }

            GetResourcesForItem(arg.Player(), item, Amount);

            if (!string.IsNullOrEmpty(item.ItemResult))
            {
                var result = ItemManager.CreateByName(item.ItemResult, Amount);
                if (!result.MoveToContainer(arg.Player().inventory.containerMain))
                    result.Drop(arg.Player().transform.position, Vector3.up);
            }
            else if (!string.IsNullOrEmpty(item.CommandResult))
                for (int i = 0; i < Amount; i++)
                    rust.RunServerCommand(string.Format(item.CommandResult, arg.Player().userID));

            rust.RunClientCommand(arg.Player(), $"custommenu false CraftMenu {categoryID[Title]} 0 {(int)Amount} {ItemName}");
        }

        #region Get/Have Resources for Craft
        private void GetResourcesForItem(BasePlayer player, ItemMK2 itemMk2, int piec)
        {
            foreach (var itemcraft in itemMk2.Ingredients)
                TakeItem(player, itemcraft.ShortName, itemcraft.SkinID, itemcraft.Amount * piec);
        }

        private bool HaveResourcesForItem(BasePlayer player, ItemMK2 itemMk2, int? piec)
        {
            foreach (var itemcraft in itemMk2.Ingredients)
            {
                if (GetItemAmount(player, itemcraft.ShortName, itemcraft.SkinID) < itemcraft.Amount * piec)
                    return false;
            }
            return true;
        }
        #endregion

        #region GetAmount & Take Items (Items with SkinID)
        public static int GetItemAmount(BasePlayer player, string shortName, ulong skinID)
        {
            int amount = 0;
            player.inventory.containerMain.itemList.ForEach(item =>
            {
                if (item.info.shortname == shortName && item.skin == skinID)
                    amount += item.amount;
            });

            return amount;
        }

        public static bool TakeItem(BasePlayer player, string shortName, ulong skinID, int amount)
        {
            Dictionary<Item, int> itemAmount = new Dictionary<Item, int>();
            player.inventory.containerMain.itemList.ForEach(item =>
            {
                if (item.info.shortname == shortName && item.skin == skinID)
                    itemAmount.Add(item, player.inventory.containerMain.itemList.IndexOf(item));
            });

            foreach (var item in itemAmount)
            {
                if (amount > 0)
                {
                    if (item.Key.amount > amount)
                    {
                        player.inventory.containerMain.itemList[item.Value].amount -= amount;
                        amount -= amount;
                        player.inventory.containerMain.itemList[item.Value].MarkDirty();
                    }
                    else
                    {
                        amount -= item.Key.amount;
                        player.inventory.containerMain.itemList[item.Value].Remove();
                        player.inventory.containerMain.MarkDirty();
                    }
                }
            }

            return true;
        }
        #endregion

        #region Utils
        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }
        #endregion
    }
}


// --- End of file: XCraft.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/HitIcon.cs ---
// --- Original Local Path: TrashRust/HitIcon.cs ---

using UnityEngine;
using System;
using Oxide.Game.Rust.Cui;
using System.Collections;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Plugins;
using System.IO;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    /*ПЛАГИН БЫЛ ПОФИКШЕН С ПОМОЩЬЮ ПРОГРАММЫ СКАЧАНОЙ С https://discord.gg/dNGbxafuJn */ [Info("HitIcon", "https://discord.gg/dNGbxafuJn", "2.0.0")]
    [Description("Configurable precached icon when you hit player | friend | clan member | headshot")]
    class HitIcon : RustPlugin
    {

        [PluginReference] Plugin Friends, Clans;

        #region Variables
        private bool _friendAPI;
        private bool _clansAPI;
        private ImageCache _imageAssets;
        private GameObject _hitObject;
        private StoredData _storedData;
        private Dictionary<ulong, UIHandler> _playersUIHandler = new Dictionary<ulong, UIHandler>();
        #endregion

        #region Oxide
        private void OnServerInitialized()
        {
            if (!configData.ConfigSettings.showDeathSkull && !configData.ConfigSettings.showNpc)
                Unsubscribe("OnEntityDeath");
            CacheImage();
            InitializeAPI();
            foreach (var player in BasePlayer.activePlayerList)
                GetUIHandler(player);
        }

        private void Loaded()
        {
            LoadData();
            InitLanguage();
        }

        private void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                player.GetComponent<UIHandler>()?.Destroy();
                CuiHelper.DestroyUi(player, "hitpng");
                CuiHelper.DestroyUi(player, "hitdmg");
            }
            SaveData();
            UnityEngine.Object.Destroy(_hitObject);
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            UIHandler value;
            if (!_playersUIHandler.TryGetValue(player.userID, out value)) return;
            _playersUIHandler[player.userID]?.Destroy();
            _playersUIHandler.Remove(player.userID);
        }

        private void OnPlayerAttack(BasePlayer attacker, HitInfo hitinfo) => SendHit(attacker, hitinfo);

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info) => SendDeath(entity, info);
        #endregion

        #region API
        private void InitializeAPI()
        {
            if (Friends != null)
            {
                _friendAPI = true;
                PrintWarning("Plugin Friends work with HitIcon");
            }

            if (Clans != null)
            {
                _clansAPI = true;
                PrintWarning("Plugin Clans work with HitIcon");
            }
        }
        private bool AreFriends(string playerId, string friendId)
        {
            try
            {
                bool result = (bool)Friends?.CallHook("AreFriends", playerId, friendId);
                return result;
            }
            catch
            {
                return false;
            }
        }
        private bool AreClanMates(ulong playerID, ulong victimID)
        {
            var playerTag = Clans?.Call<string>("GetClanOf", playerID);
            var victimTag = Clans?.Call<string>("GetClanOf", victimID);
            if (playerTag != null)
                if (victimTag != null)
                    if (playerTag == victimTag)
                        return true;
            return false;
        }
        #endregion

        #region ImageDownloader
        private void CacheImage()
        {
            _hitObject = new GameObject();
            _imageAssets = _hitObject.AddComponent<ImageCache>();
            _imageAssets.imageFiles.Clear();
            string dataDirectory = "file://" + Interface.Oxide.DataDirectory + Path.DirectorySeparatorChar;
            _imageAssets.GetImage("hitimage", dataDirectory + "hit.png");
            _imageAssets.GetImage("deathimage", dataDirectory + "death.png");
            Download();
        }

        class ImageCache : MonoBehaviour
        {
            public Dictionary<string, string> imageFiles = new Dictionary<string, string>();
            private List<Queue> queued = new List<Queue>();
            class Queue
            {
                public string Url { get; set; }
                public string Name { get; set; }
            }

            public void OnDestroy()
            {
                foreach (var value in imageFiles.Values)
                {
                    FileStorage.server.RemoveEntityNum(new NetworkableId(ulong.MaxValue), Convert.ToUInt32(value));
                }
            }

            public void GetImage(string name, string url)
            {
                queued.Add(new Queue
                {
                    Url = url,
                    Name = name
                });
            }

            IEnumerator WaitForRequest(Queue queue)
            {
                using (var www = new WWW(queue.Url))
                {
                    yield return www;

                    if (string.IsNullOrEmpty(www.error))
                        imageFiles.Add(queue.Name, FileStorage.server.Store(www.bytes, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID).ToString());
                    else
                    {
                        Debug.LogWarning("\n\n!!!!!!!!!!!!!!!!!!!!!\n\nError downloading image files (death.png and hit.png)\nThey must be in your oxide/data/ !\n\n!!!!!!!!!!!!!!!!!!!!!\n\n");
                        ConsoleSystem.Run(ConsoleSystem.Option.Unrestricted, "oxide.unload HitIcon");
                    }
                }
            }
            public void Process()
            {
                for (int i = 0; i < 2; i++)
                    StartCoroutine(WaitForRequest(queued[i]));
            }
        }

        private string FetchImage(string name)
        {
            string result;
            if (_imageAssets.imageFiles.TryGetValue(name, out result))
                return result;
            return string.Empty;
        }

        private void Download() => _imageAssets.Process();
        #endregion

        #region CUI
        private void Png(BasePlayer player, string name, string image, string start, string end, string color)
        {
            CuiElementContainer container = new CuiElementContainer();
            container.Add(new CuiElement
            {
                Name = name,
                Components =
                {
                    new CuiRawImageComponent
                    {
                        Png = image,
                        Color = color,
                        Sprite = "assets/content/textures/generic/fulltransparent.tga"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = start,
                        AnchorMax = end
                    }
                }
            });
            CuiHelper.AddUi(player, container);
        }

        private void Dmg(BasePlayer player, string name, string text, string start, string end, string color, int size)
        {
            CuiElementContainer container = new CuiElementContainer();
            container.Add(new CuiElement
            {
                Name = name,
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = text,
                        FontSize = size,
                        Font = configData.ConfigSettings.dmgFont,
                        Color = color,
                        Align = TextAnchor.MiddleCenter
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = start,
                        AnchorMax = end
                    },
                    new CuiOutlineComponent
                    {
                        Color = configData.ConfigSettings.dmgOutlineColor,
                        Distance = configData.ConfigSettings.dmgOutlineDistance
                    }
                }
            });
            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region GuiHandler
        class UIHandler : MonoBehaviour
        {
            public BasePlayer player;
            public bool isDestroyed = false;
            private void Awake()
            {
                player = GetComponent<BasePlayer>();
            }
            public void DestroyUI()
            {
                if (!isDestroyed)
                {
                    CancelInvoke("DestroyUI");
                    CuiHelper.DestroyUi(player, "hitdmg");
                    CuiHelper.DestroyUi(player, "hitpng");
                    Invoke("DestroyUI", configData.ConfigSettings.timeToDestroy);
                    isDestroyed = true;
                    return;
                }
                CuiHelper.DestroyUi(player, "hitdmg");
                CuiHelper.DestroyUi(player, "hitpng");
            }
            public void Destroy() => UnityEngine.Object.Destroy(this);
        }
        #endregion

        #region Helpers
        private void SendHit(BasePlayer attacker, HitInfo info)
        {
            if (info == null || attacker == null || !attacker.IsConnected)
                return;

            if (_storedData.DisabledUsers.Contains(attacker.userID))
                return;

            if (info.HitEntity is BaseNpc && configData.ConfigSettings.showNpc)
            {
                GuiDisplay(attacker, configData.ColorSettings.colorNpc, info);
                return;
            }

            var victim = info.HitEntity as BasePlayer;
            if (victim == null)
                return;

            if (victim == attacker)
                return;

            if (configData.ConfigSettings.useClans && _clansAPI)
            {
                if (AreClanMates(attacker.userID, victim.userID))
                {
                    GuiDisplay(attacker, configData.ColorSettings.colorClan, info, false, "clans");
                    if (configData.ConfigSettings.useSound)
                        EffectNetwork.Send(new Effect(configData.ConfigSettings.mateSound, attacker.transform.position, Vector3.zero), attacker.net.connection);
                    return;
                }
            }

            if (_friendAPI && configData.ConfigSettings.useFriends && AreFriends(victim.userID.ToString(), attacker.userID.ToString()))
            {
                GuiDisplay(attacker, configData.ColorSettings.colorFriend, info, false, "friends");
                if (configData.ConfigSettings.useSound)
                    EffectNetwork.Send(new Effect(configData.ConfigSettings.mateSound, attacker.transform.position, Vector3.zero), attacker.net.connection);
                return;
            }

            if (info.isHeadshot)
            {
                GuiDisplay(attacker, configData.ColorSettings.colorHead, info, false, "", true);
                return;
            }

            GuiDisplay(attacker, configData.ColorSettings.colorBody, info);
        }

        private void SendDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (info == null || entity == null)
                return;

            if (!configData.ConfigSettings.showDeathSkull)
                return;

            var initiator = (info?.Initiator as BasePlayer);
            if (initiator == null)
                return;

            if (_storedData.DisabledUsers.Contains(initiator.userID))
                return;

            var npc = (entity as BaseNpc);
            if (npc != null)
            {
                if (configData.ConfigSettings.showNpc)
                {
                    NextTick(() => GuiDisplay(initiator, configData.ColorSettings.colorBody, info, true));
                    return;
                }
            }
            var player = entity as BasePlayer;
            if (player == null)
                return;

            if (player == initiator)
                return;

            NextTick(() => GuiDisplay(initiator, configData.ColorSettings.colorBody, info, true));
        }

        private void GuiDisplay(BasePlayer player, string color, HitInfo hitinfo, bool isKill = false, string whatIsIt = "", bool isHead = false)
        {
            var uiHandler = GetUIHandler(player);
            uiHandler.isDestroyed = false;
            uiHandler.DestroyUI();

            if (isKill)
            {
                CuiHelper.DestroyUi(player, "hitdmg");
                Png(player, "hitpng", FetchImage("deathimage"), "0.487 0.482", "0.513 0.518", configData.ColorSettings.colorDeath);
            }
            if (configData.ConfigSettings.showHit && !isKill)
                Png(player, "hitpng", FetchImage("hitimage"), "0.492 0.486", "0.507 0.513", color);

            if (configData.ConfigSettings.showDamage)
            {
                NextTick(() => {
                    if (hitinfo.HitEntity == null)
                        return;

                    if ((hitinfo.HitEntity as BaseCombatEntity).IsDead())
                        return;

                    if (whatIsIt == "clans" && !configData.ConfigSettings.showClanDamage)
                        return;

                    if (whatIsIt == "friends" && !configData.ConfigSettings.showFriendDamage)
                        return;

                    if (!isKill && !configData.ConfigSettings.showDeathSkull || !isKill)
                    {
                        CuiHelper.DestroyUi(player, "hitdmg");
                        Dmg(player, "hitdmg", $"-{(int)hitinfo.damageTypes.Total()}", "0.45 0.45", "0.55 0.50", !isHead ? configData.ColorSettings.colorDamage : configData.ColorSettings.colorHeadDamage, configData.ConfigSettings.dmgTextSize);
                    }
                });
            }
        }

        private UIHandler GetUIHandler(BasePlayer player)
        {
            UIHandler value;
            if (!_playersUIHandler.TryGetValue(player.userID, out value))
            {
                _playersUIHandler[player.userID] = player.gameObject.AddComponent<UIHandler>();
                return _playersUIHandler[player.userID];
            }
            return value;
        }
        #endregion

        #region ChatCommand
        [ChatCommand("hit")]
        private void ToggleHit(BasePlayer player)
        {
            if (!_storedData.DisabledUsers.Contains(player.userID))
            {
                _storedData.DisabledUsers.Add(player.userID);
                PrintToChat(player, lang.GetMessage("Disabled", this, player.UserIDString));
            }
            else
            {
                _storedData.DisabledUsers.Remove(player.userID);
                PrintToChat(player, lang.GetMessage("Enabled", this, player.UserIDString));
            }
        }
        #endregion

        #region Config
        private static ConfigData configData;
        private class ConfigData
        {
            [JsonProperty(PropertyName = "Color")]
            public ColorOptions ColorSettings { get; set; }
            [JsonProperty(PropertyName = "Configuration")]
            public ConfigOptions ConfigSettings { get; set; }

            public class ColorOptions
            {
                [JsonProperty(PropertyName = "Hit clan member color")]
                public string colorClan { get; set; }
                [JsonProperty(PropertyName = "Hit friend color")]
                public string colorFriend { get; set; }
                [JsonProperty(PropertyName = "Hit head color")]
                public string colorHead { get; set; }
                [JsonProperty(PropertyName = "Hit body color")]
                public string colorBody { get; set; }
                [JsonProperty(PropertyName = "Hit NPC body color")]
                public string colorNpc { get; set; }
                [JsonProperty(PropertyName = "Hit Death body color")]
                public string colorDeath { get; set; }
                [JsonProperty(PropertyName = "Text damage color")]
                public string colorDamage { get; set; }
                [JsonProperty(PropertyName = "Text head damage color")]
                public string colorHeadDamage { get; set; }
            }

            public class ConfigOptions
            {
                [JsonProperty(PropertyName = "Damage text size")]
                public int dmgTextSize { get; set; }
                [JsonProperty(PropertyName = "Show clan member damage")]
                public bool showClanDamage { get; set; }
                [JsonProperty(PropertyName = "Show damage")]
                public bool showDamage { get; set; }
                [JsonProperty(PropertyName = "Show death kill")]
                public bool showDeathSkull { get; set; }
                [JsonProperty(PropertyName = "Show friend damage")]
                public bool showFriendDamage { get; set; }
                [JsonProperty(PropertyName = "Show hit icon")]
                public bool showHit { get; set; }
                [JsonProperty(PropertyName = "Show hits/deaths on NPC (Bears, wolfs, etc.)")]
                public bool showNpc { get; set; }
                [JsonProperty(PropertyName = "Text Font")]
                public string dmgFont { get; set; }
                [JsonProperty(PropertyName = "Text Outline Color")]
                public string dmgOutlineColor { get; set; }
                [JsonProperty(PropertyName = "Text Outline Distance")]
                public string dmgOutlineDistance { get; set; }
                [JsonProperty(PropertyName = "Time to destroy")]
                public float timeToDestroy { get; set; }
                [JsonProperty(PropertyName = "Use Clans")]
                public bool useClans { get; set; }
                [JsonProperty(PropertyName = "Use Friends")]
                public bool useFriends { get; set; }
                [JsonProperty(PropertyName = "Use sound when clan/friends get attacked")]
                public bool useSound { get; set; }
                [JsonProperty(PropertyName = "When clan/friends get attacked sound fx")]
                public string mateSound { get; set; }

            }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                ColorSettings = new ConfigData.ColorOptions
                {
                    colorClan = "0 1 0 1",
                    colorFriend = "0 1 0 1",
                    colorHead = "1 0 0 1",
                    colorBody = "1 1 1 1",
                    colorNpc = "1 1 1 1 ",
                    colorDeath = "1 0 0 1",
                    colorDamage = "1 1 1 1",
                    colorHeadDamage = "1 0 0 1"
                },
                ConfigSettings = new ConfigData.ConfigOptions
                {
                    dmgTextSize = 15,
                    dmgFont = "robotocondensed-regular.ttf",
                    dmgOutlineColor = "0 0 0 1",
                    dmgOutlineDistance = "-0.4 0.4",
                    useFriends = true,
                    useClans = true,
                    showHit = true,
                    useSound = false,
                    showNpc = true,
                    showDamage = true,
                    showClanDamage = false,
                    showFriendDamage = true,
                    showDeathSkull = true,
                    mateSound = "assets/prefabs/instruments/guitar/effects/guitarpluck.prefab",
                    timeToDestroy = 0.45f
                },
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (configData.Version < new Core.VersionNumber(2, 0, 0))
                configData = baseConfig;

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }

        T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null) return defaultValue;
            return (T)Convert.ChangeType(Config[name], typeof(T));
        }
        #endregion

        #region StoreData
        private class StoredData
        {
            public List<ulong> DisabledUsers = new List<ulong>();
        }

        private void SaveData() => Interface.GetMod().DataFileSystem.WriteObject("HitIcon", _storedData);

        private void LoadData()
        {
            try
            {
                _storedData = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("HitIcon");
            }
            catch
            {
                _storedData = new StoredData();
            }
        }
        #endregion

        #region Localization
        private void InitLanguage()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Enabled", "Hit icon was <color=green>enabled</color>"},
                {"Disabled", "Hit icon was <color=red>disabled</color>"}
            }, this);
        }
        #endregion        
    }
}

// --- End of file: HitIcon.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/Stats.cs ---
// --- Original Local Path: TrashRust/Stats.cs ---

using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Database;
using Oxide.Core.Plugins;
using Oxide.Core.SQLite.Libraries;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Stats", "", "1.0.0")]
    [Description("Player's stats")]
    public class Stats : RustPlugin
    {
        public static Stats instance;
        [PluginReference] Plugin XMenu;

        public static SQLite SQLite = Interface.Oxide.GetLibrary<SQLite>();
        public static Connection SQLiteConnection;
        public static string DataBase = "Stats.db";

        #region Config
        private PluginConfig config;
        private class PluginConfig
        {
            public ColorConfig colorConfig;
            public class ColorConfig
            {
                public string menuContentHighlighting;
                public string menuContentHighlightingalternative;

                public string menuContentText;
                public string menuContentTextAlternative;

                public string gradientColor;
            }
        }

        private void Init()
        {
            config = Config.ReadObject<PluginConfig>();
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                colorConfig = new PluginConfig.ColorConfig()
                {
                    menuContentHighlighting = "#0000007f",
                    menuContentHighlightingalternative = "#FFFFFF10",

                    menuContentTextAlternative = "#90BD47",
                    menuContentText = "#FFFFFFAA",

                    gradientColor = "#00000099",
                },
            };
        }
        #endregion

        #region U'Mod Hook's
        Timer TimerInitialize;
        private void OnServerInitialized()
        {
            instance = this;
            TimerInitialize = timer.Every(5f, () =>
            {
                if (XMenu.IsLoaded)
                {
                    XMenu.Call("API_RegisterMenu", this.Name, "Stats", "assets/icons/market.png", "RenderStats", null);

                    cmd.AddChatCommand("stats", this, (p, cmd, args) => rust.RunClientCommand(p, "custommenu true Stats"));
                    TimerInitialize.Destroy();
                }
            });

            #region Initialize
            try
            {
                SQLiteConnection = SQLite.OpenDb(DataBase, this);
                if (SQLiteConnection == null)
                {
                    PrintWarning($"Couldn't open DataBase");
                }
                else
                {
                    SQLite.Insert(Core.Database.Sql.Builder.Append("CREATE TABLE IF NOT EXISTS Stats (" +
                              "id INTEGER PRIMARY KEY AUTOINCREMENT, " +
                              "steamid BIGINT(17) UNIQUE, " +
                              "name VARCHAR(256), " +
                              "kills INTEGER, " +
                              "death INTEGER, " +
                              "suicides INTEGER, " +
                              "killanimal INTEGER, " +
                              "killnpc INTEGER, " +
                              "killhelicopter INTEGER, " +
                              "killbradley INTEGER, " +
                              "wood INTEGER, " +
                              "stones INTEGER, " +
                              "metalore INTEGER, " +
                              "sulfurore INTEGER, " +
                              "hqmetalore INTEGER, " +
                              "resources INTEGER);"), SQLiteConnection);
                }

                timer.Once(3f, () => { foreach (var p in BasePlayer.activePlayerList) { OnPlayerConnected(p); } });
            }
            catch (Exception e)
            {
                PrintWarning(e.Message);
            }
            #endregion
        }

        void Unload()
        {
            SQLite.CloseDb(SQLiteConnection);
        }

        void OnPlayerConnected(BasePlayer player)
        {
            InsertDataBase(player);
        }

        #region Insert/Update
        void InsertDataBase(BasePlayer player)
        {
            try
            {
                string displayName = player.displayName.Replace("\'", "").Replace("\"", "").Replace("@", "");
                SQLite.Insert(Core.Database.Sql.Builder.Append($"INSERT OR IGNORE into Stats ( steamid, name, kills, death, suicides, killanimal, killnpc, killhelicopter, killbradley, wood, stones, metalore, sulfurore, hqmetalore, resources ) values ( {player.userID}, '{Name}', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );"), SQLiteConnection);
                SQLite.Insert(Core.Database.Sql.Builder.Append($@"UPDATE Stats SET name = '{displayName}' WHERE steamid={player.userID};"), SQLiteConnection);
            }
            catch (Exception e)
            {
                PrintWarning(e.Message);
            }
        }

        void UpdateDataBase(BasePlayer player, string Name, int Value)
        {
            try
            {
                string ValueName = Name.Replace(".", "").Replace("@", "");
                SQLite.Insert(Core.Database.Sql.Builder.Append($"UPDATE Stats SET {ValueName} = {ValueName} + {Value} WHERE steamid={player.userID};"), SQLiteConnection);
            }
            catch (Exception e)
            {
                PrintWarning(e.Message);
            }
        }
        #endregion

        #region OnEntityDeath
        private Dictionary<ulong, BasePlayer> lastHelicopterAttack = new Dictionary<ulong, BasePlayer>();
        private Dictionary<ulong, BasePlayer> lastBradleyAttack = new Dictionary<ulong, BasePlayer>();
        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity is BaseHelicopter && info.InitiatorPlayer != null)
                lastHelicopterAttack[entity.net.ID.Value] = info.InitiatorPlayer;

            if (entity is BradleyAPC && info.InitiatorPlayer != null)
                lastBradleyAttack[entity.net.ID.Value] = info.InitiatorPlayer;
        }

        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (info == null)
                return;

            try
            {
                if (entity is BaseAnimalNPC)
                {
                    if (info.InitiatorPlayer != null)
                    {
                        UpdateDataBase(info.InitiatorPlayer, "killanimal", 1);
                    }
                    return;
                }
                if (entity is NPCPlayer)
                {
                    if (info != null && info.InitiatorPlayer != null)
                    {
                        UpdateDataBase(info.InitiatorPlayer, "killnpc", 1);
                    }
                    return;
                }
                if (entity is BasePlayer)
                {
                    if (info.InitiatorPlayer != null && !(info.InitiatorPlayer is NPCPlayer))
                    {
                        if ((entity as BasePlayer).userID == info.InitiatorPlayer.userID)
                        {
                            UpdateDataBase(info.InitiatorPlayer, "suicides", 1);
                        }
                        else
                        {
                            UpdateDataBase(info.InitiatorPlayer, "kills", 1);
                            UpdateDataBase((entity as BasePlayer), "death", 1);
                        }
                    }
                    else
                    {
                        UpdateDataBase((entity as BasePlayer), "death", 1);
                    }
                    return;
                }

                if (entity is BaseHelicopter || entity is CH47Helicopter)
                {
                    if (info.InitiatorPlayer != null)
                    {
                        UpdateDataBase(info.InitiatorPlayer, "killhelicopter", 1);
                    }
                    else
                    {
                        if (lastHelicopterAttack.ContainsKey(entity.net.ID.Value))
                        {
                            UpdateDataBase(lastHelicopterAttack[entity.net.ID.Value], "killhelicopter", 1);
                        }
                    }
                    return;
                }

                if (entity is BradleyAPC)
                {
                    if (info.InitiatorPlayer != null)
                    {
                        UpdateDataBase(info.InitiatorPlayer, "killbradley", 1);
                    }
                    else
                    {
                        if (lastBradleyAttack.ContainsKey(entity.net.ID.Value))
                        {
                            UpdateDataBase(lastHelicopterAttack[entity.net.ID.Value], "killbradley", 1);
                        }
                    }
                    return;
                }
            }
            catch (Exception ex)
            {
                PrintWarning(entity.PrefabName + "\n" + (info != null ? "info != null" : "info == null"));
                PrintWarning(entity.PrefabName + "\n" + (info.InitiatorPlayer != null ? $"{info.InitiatorPlayer.displayName} Initiator player != null" : "initiator player == null"));
                PrintWarning(entity.PrefabName + "\n" + ex.ToString());
            }
        }
        #endregion

        #region Resources
        void OnPlayerGather(BasePlayer player, Item item)
        {
            if (player == null) return;

            switch (item.info.shortname)
            {
                case "wood": UpdateDataBase(player, "wood", item.amount); break;
                case "stones": UpdateDataBase(player, "stones", item.amount); break;
                case "sulfur.ore": UpdateDataBase(player, "sulfurore", item.amount); break;
                case "metal.ore": UpdateDataBase(player, "metalore", item.amount); break;
                case "hq.metal.ore": UpdateDataBase(player, "hqmetalore", item.amount); break;
            }
            UpdateDataBase(player, "resources", item.amount);
        }

        void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item) => OnPlayerGather(entity?.ToPlayer(), item);

        void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item) => OnPlayerGather(player, item);

        void OnGrowableGather(GrowableEntity plant, Item item, BasePlayer player) => OnPlayerGather(player, item);

        void OnCollectiblePickup(Item item, BasePlayer player) => OnPlayerGather(player, item);
        #endregion
        #endregion

        #region UI
        #region Layers
        public const string MenuLayer = "XMenu";
        public const string MenuItemsLayer = "XMenu.MenuItems";
        public const string MenuSubItemsLayer = "XMenu.MenuSubItems";
        public const string MenuContent = "XMenu.Content";
        #endregion

        private void RenderStats(ulong userID, object[] objects)
        {
            CuiElementContainer Container = (CuiElementContainer)objects[0];
            bool FullRender = (bool)objects[1];
            string Name = (string)objects[2];
            int ID = (int)objects[3];
            int Page = (int)objects[4];
            string StatName = string.IsNullOrEmpty((string)objects[5]) ? "Kills" : (string)objects[5];

            BasePlayer player = BasePlayer.FindByID(userID);
            Container.Add(new CuiElement
            {
                Name = MenuContent,
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0 0 0 0",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-430 -230",
                            OffsetMax = "490 270"
                        },
                    }
            });

            #region Table
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Title",
                Parent = MenuContent,
                Components =
                    {
                        new CuiTextComponent
                        {
                            Text = $"<color={config.colorConfig.menuContentText}><b>СТАТИСТИКА ЛУЧШИХ ИГРОКОВ СЕРВЕРА TRASH <color=#1d71ff>RUST</color> X20</b></color>",
                            Align = TextAnchor.MiddleCenter,
                            FontSize = 32,
                            Font = "robotocondensed-bold.ttf"
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = $"0 -50",
                            OffsetMax = $"920 0",
                        }
                    }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Content.Stats.Name",
                Parent = MenuContent,
                Components =
                            {
                                new CuiImageComponent
                                {
                                    Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1",
                                    AnchorMax = "0 1",
                                    OffsetMin = $"77.5 -85",
                                    OffsetMax = $"190 -60"
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Content.Stats.NameTitle",
                Parent = MenuContent + $".Content.Stats.Name",
                Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = $"<color={config.colorConfig.menuContentText}>Никнейм</color>",
                                    Align = TextAnchor.MiddleCenter,
                                    FontSize = 14,
                                    Font = "robotocondensed-regular.ttf"
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 0",
                                    AnchorMax = "1 1",
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Content.Stats.Kills",
                Parent = MenuContent,
                Components =
                            {
                                new CuiImageComponent
                                {
                                    Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1",
                                    AnchorMax = "0 1",
                                    OffsetMin = $"193 -85",
                                    OffsetMax = $"263 -60"
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Content.Stats.KillsTitle",
                Parent = MenuContent + $".Content.Stats.Kills",
                Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = $"<color={config.colorConfig.menuContentText}>Убийств</color>",
                                    Align = TextAnchor.MiddleCenter,
                                    FontSize = 14,
                                    Font = "robotocondensed-regular.ttf"
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 0",
                                    AnchorMax = "1 1",
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Content.Stats.Deaths",
                Parent = MenuContent,
                Components =
                            {
                                new CuiImageComponent
                                {
                                    Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1",
                                    AnchorMax = "0 1",
                                    OffsetMin = $"266 -85",
                                    OffsetMax = $"336 -60"
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Content.Stats.DeathsTitle",
                Parent = MenuContent + $".Content.Stats.Deaths",
                Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = $"<color={config.colorConfig.menuContentText}>Смертей</color>",
                                    Align = TextAnchor.MiddleCenter,
                                    FontSize = 14,
                                    Font = "robotocondensed-regular.ttf"
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 0",
                                    AnchorMax = "1 1",
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Content.Stats.KillNPC",
                Parent = MenuContent,
                Components =
                            {
                                new CuiImageComponent
                                {
                                    Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1",
                                    AnchorMax = "0 1",
                                    OffsetMin = $"339 -85",
                                    OffsetMax = $"409 -60"
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Content.Stats.KillNPCTitle",
                Parent = MenuContent + $".Content.Stats.KillNPC",
                Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = $"<color={config.colorConfig.menuContentText}>Ученых</color>",
                                    Align = TextAnchor.MiddleCenter,
                                    FontSize = 14,
                                    Font = "robotocondensed-regular.ttf"
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 0",
                                    AnchorMax = "1 1",
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Content.Stats.KillAnimals",
                Parent = MenuContent,
                Components =
                            {
                                new CuiImageComponent
                                {
                                    Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1",
                                    AnchorMax = "0 1",
                                    OffsetMin = $"412 -85",
                                    OffsetMax = $"482 -60"
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Content.Stats.KillAnimalsTitle",
                Parent = MenuContent + $".Content.Stats.KillAnimals",
                Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = $"<color={config.colorConfig.menuContentText}>Животных</color>",
                                    Align = TextAnchor.MiddleCenter,
                                    FontSize = 14,
                                    Font = "robotocondensed-regular.ttf"
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 0",
                                    AnchorMax = "1 1",
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Content.Stats.MetalOre",
                Parent = MenuContent,
                Components =
                            {
                                new CuiImageComponent
                                {
                                    Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1",
                                    AnchorMax = "0 1",
                                    OffsetMin = $"485 -85",
                                    OffsetMax = $"555 -60"
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Content.Stats.MetalOreTitle",
                Parent = MenuContent + $".Content.Stats.MetalOre",
                Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = $"<color={config.colorConfig.menuContentText}>Металл</color>",
                                    Align = TextAnchor.MiddleCenter,
                                    FontSize = 14,
                                    Font = "robotocondensed-regular.ttf"
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 0",
                                    AnchorMax = "1 1",
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Content.Stats.SulfurOre",
                Parent = MenuContent,
                Components =
                            {
                                new CuiImageComponent
                                {
                                    Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1",
                                    AnchorMax = "0 1",
                                    OffsetMin = $"558 -85",
                                    OffsetMax = $"628 -60"
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Content.Stats.SulfurOreTitle",
                Parent = MenuContent + $".Content.Stats.SulfurOre",
                Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = $"<color={config.colorConfig.menuContentText}>Сера</color>",
                                    Align = TextAnchor.MiddleCenter,
                                    FontSize = 14,
                                    Font = "robotocondensed-regular.ttf"
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 0",
                                    AnchorMax = "1 1",
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Content.Stats.HQMetal",
                Parent = MenuContent,
                Components =
                            {
                                new CuiImageComponent
                                {
                                    Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1",
                                    AnchorMax = "0 1",
                                    OffsetMin = $"631 -85",
                                    OffsetMax = $"701 -60"
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Content.Stats.HQMetalTitle",
                Parent = MenuContent + $".Content.Stats.HQMetal",
                Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = $"<color={config.colorConfig.menuContentText}>МВК</color>",
                                    Align = TextAnchor.MiddleCenter,
                                    FontSize = 14,
                                    Font = "robotocondensed-regular.ttf"
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 0",
                                    AnchorMax = "1 1",
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Content.Stats.Res",
                Parent = MenuContent,
                Components =
                            {
                                new CuiImageComponent
                                {
                                    Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1",
                                    AnchorMax = "0 1",
                                    OffsetMin = $"704 -85",
                                    OffsetMax = $"822.5 -60"
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Content.Stats.ResTitle",
                Parent = MenuContent + $".Content.Stats.Res",
                Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = $"<color={config.colorConfig.menuContentText}>Всего ресурсов</color>",
                                    Align = TextAnchor.MiddleCenter,
                                    FontSize = 14,
                                    Font = "robotocondensed-regular.ttf"
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 0",
                                    AnchorMax = "1 1",
                                }
                            }
            });
            #endregion

            #region Buttons
            int y = 0;
            Container.Add(new CuiButton
            {
                Button = { Color = "0 0 0 0", Command = $"" },
                RectTransform = {   AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"77.5 {-85 - y * 35}",
                                        OffsetMax = $"190 {-60 - y * 35}" },
                Text = { Text = "", Align = TextAnchor.MiddleCenter }
            }, MenuContent, MenuContent + $".Content.Stats.Btn.Name");
            Container.Add(new CuiButton
            {
                Button = { Color = "0 0 0 0", Command = $"custommenu false Stats 0 0 kills" },
                RectTransform = {   AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"193 {-85 - y * 35}",
                                        OffsetMax = $"263 {-60 - y * 35}" },
                Text = { Text = "", Align = TextAnchor.MiddleCenter }
            }, MenuContent, MenuContent + $".Content.Stats.Btn.Kills");
            Container.Add(new CuiButton
            {
                Button = { Color = "0 0 0 0", Command = $"custommenu false Stats 0 0 death" },
                RectTransform = {   AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"266 {-85 - y * 35}",
                                        OffsetMax = $"336 {-60 - y * 35}" },
                Text = { Text = "", Align = TextAnchor.MiddleCenter }
            }, MenuContent, MenuContent + $".Content.Stats.Btn.Deaths");
            Container.Add(new CuiButton
            {
                Button = { Color = "0 0 0 0", Command = $"custommenu false Stats 0 0 killnpc" },
                RectTransform = {   AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"339 {-85 - y * 35}",
                                        OffsetMax = $"409 {-60 - y * 35}" },
                Text = { Text = "", Align = TextAnchor.MiddleCenter }
            }, MenuContent, MenuContent + $".Content.Stats.Btn.KillNPC");
            Container.Add(new CuiButton
            {
                Button = { Color = "0 0 0 0", Command = $"custommenu false Stats 0 0 killanimal" },
                RectTransform = {   AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"412 {-85 - y * 35}",
                                        OffsetMax = $"482 {-60 - y * 35}" },
                Text = { Text = "", Align = TextAnchor.MiddleCenter }
            }, MenuContent, MenuContent + $".Content.Stats.Btn.KillAnimals");
            Container.Add(new CuiButton
            {
                Button = { Color = "0 0 0 0", Command = $"custommenu false Stats 0 0 metalore" },
                RectTransform = {   AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"485 {-85 - y * 35}",
                                        OffsetMax = $"555 {-60 - y * 35}" },
                Text = { Text = "", Align = TextAnchor.MiddleCenter }
            }, MenuContent, MenuContent + $".Content.Stats.Btn.MetalOre");
            Container.Add(new CuiButton
            {
                Button = { Color = "0 0 0 0", Command = $"custommenu false Stats 0 0 sulfurore" },
                RectTransform = {   AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"558 {-85 - y * 35}",
                                        OffsetMax = $"628 {-60 - y * 35}" },
                Text = { Text = "", Align = TextAnchor.MiddleCenter }
            }, MenuContent, MenuContent + $".Content.Stats.Btn.SulfurOre");
            Container.Add(new CuiButton
            {
                Button = { Color = "0 0 0 0", Command = $"custommenu false Stats 0 0 hqmetalore" },
                RectTransform = {   AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"631 {-85 - y * 35}",
                                        OffsetMax = $"701 {-60 - y * 35}" },
                Text = { Text = "", Align = TextAnchor.MiddleCenter }
            }, MenuContent, MenuContent + $".Content.Stats.Btn.HQMetal");
            Container.Add(new CuiButton
            {
                Button = { Color = "0 0 0 0", Command = $"custommenu false Stats 0 0 resources" },
                RectTransform = {   AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"704 {-85 - y * 35}",
                                        OffsetMax = $"822.5 {-60 - y * 35}" },
                Text = { Text = "", Align = TextAnchor.MiddleCenter }
            }, MenuContent, MenuContent + $".Content.Stats.Btn.Res");
            #endregion

            SelectDataBase(player, StatName, 12, 0);
            SelectPlayer(player);
        }

        public void SelectDataBase(BasePlayer player, string Name, int count, int offset)
        {
            try
            {
                CuiElementContainer Container = new CuiElementContainer();
                string ValueName = Name.Replace(".", "");
                var SQLString = Core.Database.Sql.Builder.Append($"SELECT * FROM Stats ORDER BY {ValueName} DESC LIMIT {count} OFFSET {offset};");
                SQLite.Query(SQLString, SQLiteConnection, obj =>
                {
                    if (obj != null)
                    {
                        for (int i = 0, y = 0; i < obj.Count; i++, y++)
                        {
                            string color = HexToRustFormat(config.colorConfig.menuContentHighlighting);
                            if (instance.IsEven(y)) color = HexToRustFormat(config.colorConfig.menuContentHighlightingalternative);
                            Container.Add(new CuiElement
                            {
                                Name = MenuLayer + $".Content.Stats.{i}",
                                Parent = MenuContent,
                                Components =
                                {
                                    new CuiImageComponent
                                    {
                                        Color = color,
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"77.5 {-120 - y * 30}",
                                        OffsetMax = $"822.5 {-95 - y * 30}"
                                    }
                                }
                            });
                            Container.Add(new CuiElement
                            {
                                Name = MenuContent + $".Content.Stats.Name.{i}",
                                Parent = MenuContent,
                                Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color={config.colorConfig.menuContentText}>{obj.ElementAt(i)["name"]}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 10,
                                        Font = "robotocondensed-regular.ttf"
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"77.5 {-120 - y * 30}",
                                        OffsetMax = $"190 {-95 - y * 30}"
                                    }
                                }
                            });
                            Container.Add(new CuiElement
                            {
                                Name = MenuContent + $".Content.Stats.Kills.{i}",
                                Parent = MenuContent,
                                Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color={config.colorConfig.menuContentText}>{obj.ElementAt(i)["kills"]}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-regular.ttf"
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"193 {-120 - y * 30}",
                                        OffsetMax = $"263 {-95 - y * 30}"
                                    }
                                }
                            });
                            Container.Add(new CuiElement
                            {
                                Name = MenuContent + $".Content.Stats.Deaths.{i}",
                                Parent = MenuContent,
                                Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color={config.colorConfig.menuContentText}>{obj.ElementAt(i)["death"]}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-regular.ttf"
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"266 {-120 - y * 30}",
                                        OffsetMax = $"336 {-95 - y * 30}"
                                    }
                                }
                            });
                            Container.Add(new CuiElement
                            {
                                Name = MenuContent + $".Content.Stats.KillNPC.{i}",
                                Parent = MenuContent,
                                Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color={config.colorConfig.menuContentText}>{obj.ElementAt(i)["killnpc"]}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-regular.ttf"
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"339 {-120 - y * 30}",
                                        OffsetMax = $"409 {-95 - y * 30}"
                                    }
                                }
                            });
                            Container.Add(new CuiElement
                            {
                                Name = MenuContent + $".Content.Stats.KillAnimals.{i}",
                                Parent = MenuContent,
                                Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color={config.colorConfig.menuContentText}>{obj.ElementAt(i)["killanimal"]}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-regular.ttf"
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"412 {-120 - y * 30}",
                                        OffsetMax = $"482 {-95 - y * 30}"
                                    }
                                }
                            });
                            Container.Add(new CuiElement
                            {
                                Name = MenuContent + $".Content.Stats.MetalOre.{i}",
                                Parent = MenuContent,
                                Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color={config.colorConfig.menuContentText}>{obj.ElementAt(i)["metalore"]}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-regular.ttf"
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"485 {-120 - y * 30}",
                                        OffsetMax = $"555 {-95 - y * 30}"
                                    }
                                }
                            });
                            Container.Add(new CuiElement
                            {
                                Name = MenuContent + $".Content.Stats.SulfurOre.{i}",
                                Parent = MenuContent,
                                Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color={config.colorConfig.menuContentText}>{obj.ElementAt(i)["sulfurore"]}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-regular.ttf"
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"558 {-120 - y * 30}",
                                        OffsetMax = $"628 {-95 - y * 30}"
                                    }
                                }
                            });
                            Container.Add(new CuiElement
                            {
                                Name = MenuContent + $".Content.Stats.HQMeta;.{i}",
                                Parent = MenuContent,
                                Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color={config.colorConfig.menuContentText}>{obj.ElementAt(i)["hqmetalore"]}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-regular.ttf"
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"631 {-120 - y * 30}",
                                        OffsetMax = $"701 {-95 - y * 30}"
                                    }
                                }
                            });
                            Container.Add(new CuiElement
                            {
                                Name = MenuContent + $".Content.Stats.Res.{i}",
                                Parent = MenuContent,
                                Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color={config.colorConfig.menuContentText}>{obj.ElementAt(i)["resources"]}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-regular.ttf"
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"704 {-120 - y * 30}",
                                        OffsetMax = $"822.5 {-95 - y * 30}"
                                    }
                                }
                            });
                        }
                        CuiHelper.AddUi(player, Container);
                    }
                });
            }
            catch (Exception e)
            {
                instance.PrintWarning(e.Message);
            }
        }

        public void SelectPlayer(BasePlayer player)
        {
            try
            {
                CuiElementContainer Container = new CuiElementContainer();
                string ValueName = instance.Name.Replace(".", "");
                var SQLString = Core.Database.Sql.Builder.Append($"SELECT * FROM Stats WHERE steamid='{player.userID}';");
                SQLite.Query(SQLString, SQLiteConnection, obj =>
                {
                    if (obj == null) return;
                    for (int i = 0, y = 12; i < obj.Count; i++, y++)
                    {
                        string color = HexToRustFormat(config.colorConfig.menuContentHighlighting);
                        if (instance.IsEven(y)) color = HexToRustFormat(config.colorConfig.menuContentHighlightingalternative);
                        Container.Add(new CuiElement
                        {
                            Name = MenuContent + $".Content.Stats.{i}",
                            Parent = MenuContent,
                            Components =
                                {
                                    new CuiImageComponent
                                    {
                                        Color = color,
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"77.5 {-120 - y * 30}",
                                        OffsetMax = $"822.5 {-95 - y * 30}"
                                    }
                                }
                        });
                        Container.Add(new CuiElement
                        {
                            Name = MenuContent + $".Content.Stats.Name.{i}",
                            Parent = MenuContent,
                            Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color={config.colorConfig.menuContentTextAlternative}>Ваша статистика:</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-regular.ttf"
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"77.5 {-120 - y * 30}",
                                        OffsetMax = $"190 {-95 - y * 30}"
                                    }
                                }
                        });
                        Container.Add(new CuiElement
                        {
                            Name = MenuContent + $".Content.Stats.Kills.{i}",
                            Parent = MenuContent,
                            Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color={config.colorConfig.menuContentTextAlternative}>{obj.ElementAt(i)["kills"]}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-regular.ttf"
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"193 {-120 - y * 30}",
                                        OffsetMax = $"263 {-95 - y * 30}"
                                    }
                                }
                        });
                        Container.Add(new CuiElement
                        {
                            Name = MenuContent + $".Content.Stats.Deaths.{i}",
                            Parent = MenuContent,
                            Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color={config.colorConfig.menuContentTextAlternative}>{obj.ElementAt(i)["death"]}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-regular.ttf"
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"266 {-120 - y * 30}",
                                        OffsetMax = $"336 {-95 - y * 30}"
                                    }
                                }
                        });
                        Container.Add(new CuiElement
                        {
                            Name = MenuContent + $".Content.Stats.KillNPC.{i}",
                            Parent = MenuContent,
                            Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color={config.colorConfig.menuContentTextAlternative}>{obj.ElementAt(i)["killnpc"]}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-regular.ttf"
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"339 {-120 - y * 30}",
                                        OffsetMax = $"409 {-95 - y * 30}"
                                    }
                                }
                        });
                        Container.Add(new CuiElement
                        {
                            Name = MenuContent + $".Content.Stats.KillAnimals.{i}",
                            Parent = MenuContent,
                            Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color={config.colorConfig.menuContentTextAlternative}>{obj.ElementAt(i)["killanimal"]}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-regular.ttf"
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"412 {-120 - y * 30}",
                                        OffsetMax = $"482 {-95 - y * 30}"
                                    }
                                }
                        });
                        Container.Add(new CuiElement
                        {
                            Name = MenuContent + $".Content.Stats.MetalOre.{i}",
                            Parent = MenuContent,
                            Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color={config.colorConfig.menuContentTextAlternative}>{obj.ElementAt(i)["metalore"]}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-regular.ttf"
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"485 {-120 - y * 30}",
                                        OffsetMax = $"555 {-95 - y * 30}"
                                    }
                                }
                        });
                        Container.Add(new CuiElement
                        {
                            Name = MenuContent + $".Content.Stats.SulfurOre.{i}",
                            Parent = MenuContent,
                            Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color={config.colorConfig.menuContentTextAlternative}>{obj.ElementAt(i)["sulfurore"]}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-regular.ttf"
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"558 {-120 - y * 30}",
                                        OffsetMax = $"628 {-95 - y * 30}"
                                    }
                                }
                        });
                        Container.Add(new CuiElement
                        {
                            Name = MenuContent + $".Content.Stats.HQMeta;.{i}",
                            Parent = MenuContent,
                            Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color={config.colorConfig.menuContentTextAlternative}>{obj.ElementAt(i)["hqmetalore"]}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-regular.ttf"
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"631 {-120 - y * 30}",
                                        OffsetMax = $"701 {-95 - y * 30}"
                                    }
                                }
                        });
                        Container.Add(new CuiElement
                        {
                            Name = MenuContent + $".Content.Stats.Res.{i}",
                            Parent = MenuContent,
                            Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color={config.colorConfig.menuContentTextAlternative}>{obj.ElementAt(i)["resources"]}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-regular.ttf"
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"704 {-120 - y * 30}",
                                        OffsetMax = $"822.5 {-95 - y * 30}"
                                    }
                                }
                        });
                    }
                    CuiHelper.AddUi(player, Container);
                });
            }
            catch (Exception e)
            {
                instance.PrintWarning(e.Message);
            }
        }
        #endregion

        #region Helpers
        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }

        private bool IsEven(int a)
        {
            return (a % 2) == 0;
        }
        #endregion
    }
}

// --- End of file: Stats.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/NeverWear.cs ---
// --- Original Local Path: TrashRust/NeverWear.cs ---

﻿using System.Collections.Generic;
using Oxide.Core.Plugins;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("NeverWear", "k1lly0u", "0.1.5")]
    class NeverWear : RustPlugin
    {
        [PluginReference] Plugin MachiningTools;

		void Loaded() => RegisterPermissions();
        void OnServerInitialized() => LoadVariables();

		private void RegisterPermissions()
        {
            permission.RegisterPermission("neverwear.use", this);
            permission.RegisterPermission("neverwear.attire", this);
            permission.RegisterPermission("neverwear.weapons", this);
            permission.RegisterPermission("neverwear.tools", this);
        }

        private bool HasPerm(BasePlayer player, string perm)
        {
            if (permission.UserHasPermission(player.UserIDString, perm)) return true;
            return false;
        }

		private bool IsNeverWear(Item item)
        {
            var check = MachiningTools?.Call("IsMachiningToolItem", item);
            if (check != null && (bool)check) return true;
            return false;
        }

        void OnLoseCondition(Item item, ref float amount)
        {
            if (item != null)
            {
                if (IsNeverWear(item))
					return;

				BasePlayer player;

				if (item.GetOwnerPlayer() == null)
                {
                    if (item?.info == null)
						return;

                    if (!item.info.shortname.Contains("mod"))
						return;

                    player = item?.GetRootContainer()?.GetOwnerPlayer();
                    if (player == null)
                        return;
                }
                else
					player = item.GetOwnerPlayer();
                    if (player != null)
                    {
                        var def = ItemManager.FindItemDefinition(item.info.itemid);
                        if ((configData.useWhiteList && configData.WhitelistedItems.Contains(def.shortname) && HasPerm(player, "neverwear.use"))
                            || (def.category == ItemCategory.Weapon && configData.useWeapons && HasPerm(player, "neverwear.weapons"))
                            || (def.category == ItemCategory.Attire && configData.useAttire && HasPerm(player, "neverwear.attire"))
                            || (def.category == ItemCategory.Tool && configData.useTools && HasPerm(player, "neverwear.tools")))
                            if (item.hasCondition)
                                item.RepairCondition(amount);
                    }
            }          
            return;
        }

        #region Config        

		private ConfigData configData;

		class ConfigData
        {
            public bool useWeapons { get; set; }
            public bool useTools { get; set; }            
            public bool useAttire { get; set; }
            public bool useWhiteList { get; set; }
            public List<string> WhitelistedItems { get; set; }
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                useTools = true,
                useAttire = false,
                useWeapons = false,
                useWhiteList = false,
                WhitelistedItems = new List<string>
                {
                    "hatchet",
                    "pickaxe",
                    "rifle.bolt",
                    "rifle.ak"
                }
            };
            SaveConfig(config);
        }

        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
		void SaveConfig(ConfigData config) => Config.WriteObject(config, true);

		#endregion
    }
}


// --- End of file: NeverWear.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/ExtendedRecycler.cs ---
// --- Original Local Path: TrashRust/ExtendedRecycler.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    /*ПЛАГИН БЫЛ ПОФИКШЕН С ПОМОЩЬЮ ПРОГРАММЫ СКАЧАНОЙ С https://discord.gg/dNGbxafuJn */ [Info("Extended Recycler", "https://discord.gg/dNGbxafuJn", "1.1.0")]
    [Description("Extend recyclers for personal use and more")]
    public class ExtendedRecycler : RustPlugin
    {
        #region Vars

        private const ulong skinID = 1594245394;
        private const string prefab = "assets/bundled/prefabs/static/recycler_static.prefab";
        private static ExtendedRecycler plugin;
        private const string permUse = "extendedrecycler.use";

        #endregion

        #region Config

        private static ConfigData config;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "1. Pickup settings:")]
            public OPickup pickup;

            [JsonProperty(PropertyName = "2. Craft settings:")]
            public OCraft craft;

            [JsonProperty(PropertyName = "3. Destroy settings:")]
            public ODestroy destroy;

            public class OPickup
            {
                [JsonProperty(PropertyName = "1. Enabled for personal recyclers (placed by player)")]
                public bool personal;

                [JsonProperty(PropertyName = "2. Check ability to build for pickup")]
                public bool privilege;

                [JsonProperty(PropertyName = "3. Only owner can pickup")]
                public bool onlyOwner;
            }

            public class OCraft
            {
                [JsonProperty(PropertyName = "1. Enabled")]
                public bool enabled;

                [JsonProperty(PropertyName = "2. Cost (shortname - amount):")]
                public Dictionary<string, int> cost;
            }

            public class ODestroy
            {
                [JsonProperty(PropertyName = "1. Check ground for recyclers (destroy on missing)")]
                public bool checkGround;

                [JsonProperty(PropertyName = "2. Give item on destroy recycler")]
                public bool destroyItem;

                [JsonProperty(PropertyName = "3. Effects on destroy recycler")]
                public List<string> effects;
            }
        }

        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                pickup = new ConfigData.OPickup
                {
                    personal = false,
                    privilege = true,
                    onlyOwner = false
                },
                craft = new ConfigData.OCraft
                {
                    enabled = true,
                    cost = new Dictionary<string, int>
                    {
                        {"scrap", 500},
                        {"metal.fragments", 5000},
                        {"metal.refined", 50},
                        {"gears", 10}
                    }
                },
                destroy = new ConfigData.ODestroy
                {
                    checkGround = true,
                    destroyItem = true,
                    effects = new List<string>
                    {
                        "assets/bundled/prefabs/fx/item_break.prefab",
                        "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                    }
                }
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();
            }
            catch
            {
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintError("Configuration file is corrupt(or not exists), creating new one!");
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion

        #region Language

        private Dictionary<string, string> EN = new Dictionary<string, string>
        {
            {"Name", "Recycler"},
            {"Pickup", "You picked up recycler!"},
            {"Receive", "You received recycler!"},
            {"Disabled", "Pickup disabled!"},
            {"Build", "You must have ability to build to do that!"},
            {"Damaged", "Recycler was recently damaged, you can pick it up in next 30s!"},
            {"NoCraft", "Craft disabled!"},
            {"Owner", "Only owner can pickup recycler!"},
            {"Craft", "For craft you need more resources:\n{0}"},
            {"Permission", "You need permission to do that!"}
        };

        private void message(BasePlayer player, string key, params object[] args)
        {
            if (player == null)
            {
                return;
            }
            
            var message = string.Format(lang.GetMessage(key, this, player.UserIDString), args);
            player.ChatMessage(message);
        }

        #endregion

        #region Oxide Hooks

        private void OnEntityBuilt(Planner plan, GameObject go)
        {
            CheckDeploy(go.ToBaseEntity());
        }

        private void OnServerInitialized()
        {
            plugin = this;
            lang.RegisterMessages(EN, this);
            permission.RegisterPermission(permUse, this);
            CheckRecyclers();
        }

        private void OnHammerHit(BasePlayer player, HitInfo info)
        {
            CheckHit(player, info?.HitEntity);
        }

        #endregion

        #region Core

        private void SpawnRecycler(Vector3 position, Quaternion rotation = default(Quaternion), ulong ownerID = 0)
        {
            var recycler = GameManager.server.CreateEntity(prefab, position, rotation);
            if (recycler == null)
            {
                return;
            }

            recycler.skinID = skinID;
            recycler.OwnerID = ownerID;
            recycler.gameObject.AddComponent<ExtendedRecyclerComponent>();
            recycler.Spawn();
        }

        private void CheckRecyclers()
        {
            foreach (var recycler in UnityEngine.Object.FindObjectsOfType<Recycler>())
            {
                if (recycler.OwnerID != 0 && recycler.GetComponent<ExtendedRecyclerComponent>() == null)
                {
                    recycler.gameObject.AddComponent<ExtendedRecyclerComponent>();
                }
            }
        }

        private void GiveRecycler(BasePlayer player, bool pickup = false)
        {
            var item = CreateItem();
            if (item != null && player != null)
            {
                player.GiveItem(item);
                message(player, pickup ? "Pickup" : "Receive");
            }
        }

        private void GiveRecycler(Vector3 position)
        {
            var item = CreateItem();
            item?.Drop(position, Vector3.down);
        }

        private Item CreateItem()
        {
            var item = ItemManager.CreateByName("box.repair.bench", 1, skinID);
            if (item != null)
            {
                item.name = plugin?.GetRecyclerName();
            }
           
            return item;
        }

        private void CheckDeploy(BaseEntity entity)
        {
            if (entity == null)
            {
                return;
            }

            if (!IsRecycler(entity.skinID))
            {
                return;
            }

            var transform = entity.transform;
            SpawnRecycler(transform.position, transform.rotation, entity.OwnerID);
            entity.transform.position -= new Vector3(0, 3, 0);
            entity.SendNetworkUpdate();
            timer.Once(1f, () =>
            {
                if (entity.IsValid() == true && entity.IsDestroyed == false)
                {
                    entity.Kill();
                }
            });
        }

        private void CheckHit(BasePlayer player, BaseEntity entity)
        {
            if (entity == null)
            {
                return;
            }

            if (!IsRecycler(entity.skinID))
            {
                return;
            }

            timer.Once(1f, () =>
            {
                if (entity.IsValid() == true)
                {
                    entity.GetComponent<ExtendedRecyclerComponent>()?.TryPickup(player);
                }
            });
        }

        [ChatCommand("recycler.craft")]
        private void Craft(BasePlayer player)
        {
            if (CanCraft(player))
            {
                GiveRecycler(player);
            }
        }

        private bool CanCraft(BasePlayer player)
        {
            if (!config.craft.enabled)
            {
                message(player, "NoCraft");
                return false;
            }

            if (!permission.UserHasPermission(player.UserIDString, permUse))
            {
                message(player, "Permission");
                return false;
            }

            var recipe = config.craft.cost;
            var more = new Dictionary<string, int>();

            foreach (var component in recipe)
            {
                var name = component.Key;
                var has = player.inventory.GetAmount(ItemManager.FindItemDefinition(component.Key).itemid);
                var need = component.Value;
                if (has < component.Value)
                {
                    if (!more.ContainsKey(name))
                    {
                        more.Add(name, 0);
                    }

                    more[name] += need;
                }
            }

            if (more.Count == 0)
            {
                foreach (var item in recipe)
                {
                    player.inventory.Take(null, ItemManager.FindItemDefinition(item.Key).itemid, item.Value);
                }

                return true;
            }
            else
            {
                var text = "";

                foreach (var item in more)
                {
                    text += $" * {item.Key} x{item.Value}\n";
                }

                player.ChatMessage(string.Format(lang.GetMessage("Craft", this), text));
                return false;
            }
        }

        #endregion

        #region Helpers

        private string GetRecyclerName()
        {
            return lang.GetMessage("Name", this);
        }

        private bool IsRecycler(ulong skin)
        {
            return skin != 0 && skin == skinID;
        }

        #endregion

        #region Command

        [ConsoleCommand("recycler.give")]
        private void Cmd(ConsoleSystem.Arg arg)
        {
            if (arg.IsAdmin && arg.Args?.Length > 0)
            {
                var player = BasePlayer.Find(arg.Args[0]) ?? BasePlayer.FindSleeping(arg.Args[0]);
                if (player == null)
                {
                    PrintWarning($"We can't find player with that name/ID! {arg.Args[0]}");
                    return;
                }

                GiveRecycler(player);
            }
        }

        #endregion

        #region Scripts

        private class ExtendedRecyclerComponent : MonoBehaviour
        {
            private Recycler recycler;

            private void Awake()
            {
                recycler = GetComponent<Recycler>();

                if (config.destroy.checkGround)
                {
                    InvokeRepeating("CheckGround", 5f, 5f);
                }
            }

            private void CheckGround()
            {
                RaycastHit rhit;
                var cast = Physics.Raycast(recycler.transform.position + new Vector3(0, 0.1f, 0), Vector3.down,
                    out rhit, 4f, LayerMask.GetMask("Terrain", "Construction"));
                var distance = cast ? rhit.distance : 3f;

                if (distance > 0.2f)
                {
                    GroundMissing();
                }
            }

            private void GroundMissing()
            {
                recycler.Kill();

                if (config.destroy.destroyItem)
                {
                    plugin.GiveRecycler(recycler.transform.position);
                }

                foreach (var effect in config.destroy.effects)
                {
                    Effect.server.Run(effect, recycler.transform.position);
                }
            }

            public void TryPickup(BasePlayer player)
            {
                if (config.pickup.personal == false)
                {
                    plugin.message(player, "Disabled");
                    return;
                }

                if (config.pickup.privilege && !player.CanBuild())
                {
                    plugin.message(player, "Build");
                    return;
                }

                if (config.pickup.onlyOwner && recycler.OwnerID != player.userID)
                {
                    plugin.message(player, "Owner");
                    return;
                }

                if (recycler.SecondsSinceDealtDamage < 30f)
                {
                    plugin.message(player, "Damaged");
                    return;
                }


                recycler.DropItems();
                recycler.Kill();
                plugin.GiveRecycler(player, true);
            }

            public void DoDestroy()
            {
                Destroy(this);
            }
        }

        #endregion
    }
}

// --- End of file: ExtendedRecycler.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/Stacks.cs ---
// --- Original Local Path: TrashRust/Stacks.cs ---

using System.Collections.Generic;
using System.Linq;
using System;
using UnityEngine;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
namespace Oxide.Plugins
{
    [Info("Stacks", "Nimant", "2.0.4")]
    public class Stacks : RustPlugin
    {
        [PluginReference] private Plugin FurnaceSplitter;
        private static Dictionary<string, int> jXuGEdXFJIzIUWQOpYOZNIJ = new Dictionary<string, int>();
        private static Dictionary<string, int> XAXfVFPbfUI = new Dictionary<string, int>() {
      {
        "Attire",
        2
      }, {
        "Tool",
        1
      }, {
        "Weapon",
        1
      }
    };
        private void Init()
        {
            MFbOuyfXAqPnQUkGOaKBezo();
            var yIhMaLVxgmbLicchecoXJfdGI = false;
            if (HGJfIWGOkTcdLbGIFiAb.RSjYaftfLwPnVesiMQltPxD == null)
            {
                HGJfIWGOkTcdLbGIFiAb.RSjYaftfLwPnVesiMQltPxD = new List<string>();
                yIhMaLVxgmbLicchecoXJfdGI = true;
            }
            if (HGJfIWGOkTcdLbGIFiAb.yBPzMbzsaiBVjicaXFqsmEjTwwvjd == null)
            {
                HGJfIWGOkTcdLbGIFiAb.yBPzMbzsaiBVjicaXFqsmEjTwwvjd = new List<string>() {
          "Blue Keycard",
          "Green Keycard",
          "Red Keycard"
        };
                yIhMaLVxgmbLicchecoXJfdGI = true;
            }
            if (HGJfIWGOkTcdLbGIFiAb.eyEnBlUwiSVEbqTYsOoAWSlbYAKqY == null)
            {
                HGJfIWGOkTcdLbGIFiAb.eyEnBlUwiSVEbqTYsOoAWSlbYAKqY = new List<ulong>();
                yIhMaLVxgmbLicchecoXJfdGI = true;
            }
            if (HGJfIWGOkTcdLbGIFiAb.SUMgbOLYXEWqWGNauhbgEajpmt == null)
            {
                HGJfIWGOkTcdLbGIFiAb.SUMgbOLYXEWqWGNauhbgEajpmt = new List<string>();
                yIhMaLVxgmbLicchecoXJfdGI = true;
            }
            if (yIhMaLVxgmbLicchecoXJfdGI) qqOsjhDfbcTCbeFmh(HGJfIWGOkTcdLbGIFiAb);
        }
        private void OnServerInitialized()
        {
            var gnvHnEcTiZI = ItemManager.itemList.ToList();
            List<string> iYVmINDpHhehYOadREWmaW = new List<string>();
            List<string> CBVPeybAMYQDADFiPvmfOMFv = new List<string>();
            foreach (var mCDDdYSVLSWfHUkXrtG in gnvHnEcTiZI.OrderBy(r => r.category))
            {
                var lRpcAWHnInDrkWHzVhePfu = mCDDdYSVLSWfHUkXrtG.category.ToString();
                var YYvmAiPUeXEYGpFzwLxLNVypVAW = mCDDdYSVLSWfHUkXrtG.displayName.english;
                if (!HGJfIWGOkTcdLbGIFiAb.AqfUFopQwAbfNey.ContainsKey(lRpcAWHnInDrkWHzVhePfu))
                {
                    HGJfIWGOkTcdLbGIFiAb.AqfUFopQwAbfNey.Add(lRpcAWHnInDrkWHzVhePfu, new Dictionary<string, int> {
            {
              YYvmAiPUeXEYGpFzwLxLNVypVAW,
              mCDDdYSVLSWfHUkXrtG.stackable
            }
          });
                    iYVmINDpHhehYOadREWmaW.Add($"'{YYvmAiPUeXEYGpFzwLxLNVypVAW}' в категории '{lRpcAWHnInDrkWHzVhePfu}'");
                }
                else if (!HGJfIWGOkTcdLbGIFiAb.AqfUFopQwAbfNey[lRpcAWHnInDrkWHzVhePfu].ContainsKey(YYvmAiPUeXEYGpFzwLxLNVypVAW))
                {
                    HGJfIWGOkTcdLbGIFiAb.AqfUFopQwAbfNey[lRpcAWHnInDrkWHzVhePfu].Add(YYvmAiPUeXEYGpFzwLxLNVypVAW, mCDDdYSVLSWfHUkXrtG.stackable);
                    iYVmINDpHhehYOadREWmaW.Add($"'{YYvmAiPUeXEYGpFzwLxLNVypVAW}' в категории '{lRpcAWHnInDrkWHzVhePfu}'");
                }
                if (!jXuGEdXFJIzIUWQOpYOZNIJ.ContainsKey(lRpcAWHnInDrkWHzVhePfu + "|" + YYvmAiPUeXEYGpFzwLxLNVypVAW)) jXuGEdXFJIzIUWQOpYOZNIJ.Add(lRpcAWHnInDrkWHzVhePfu + "|" + YYvmAiPUeXEYGpFzwLxLNVypVAW, mCDDdYSVLSWfHUkXrtG.stackable);
                mCDDdYSVLSWfHUkXrtG.stackable = HGJfIWGOkTcdLbGIFiAb.AqfUFopQwAbfNey[lRpcAWHnInDrkWHzVhePfu][YYvmAiPUeXEYGpFzwLxLNVypVAW];
            }
            foreach (var aDLTPabOlfgxA in HGJfIWGOkTcdLbGIFiAb.AqfUFopQwAbfNey.Keys)
            {
                foreach (var mCDDdYSVLSWfHUkXrtG in HGJfIWGOkTcdLbGIFiAb.AqfUFopQwAbfNey[aDLTPabOlfgxA].ToDictionary(x => x.Key, x => x.Value))
                {
                    if (!gnvHnEcTiZI.Exists(x => x.displayName.english == mCDDdYSVLSWfHUkXrtG.Key && x.category.ToString() == aDLTPabOlfgxA))
                    {
                        HGJfIWGOkTcdLbGIFiAb.AqfUFopQwAbfNey[aDLTPabOlfgxA].Remove(mCDDdYSVLSWfHUkXrtG.Key);
                        CBVPeybAMYQDADFiPvmfOMFv.Add($"'{mCDDdYSVLSWfHUkXrtG.Key}' из категории '{aDLTPabOlfgxA}'");
                    }
                }
                if (HGJfIWGOkTcdLbGIFiAb.AqfUFopQwAbfNey[aDLTPabOlfgxA].Count == 0) HGJfIWGOkTcdLbGIFiAb.AqfUFopQwAbfNey.Remove(aDLTPabOlfgxA);
            }
            if (iYVmINDpHhehYOadREWmaW.Count == 0 && CBVPeybAMYQDADFiPvmfOMFv.Count == 0) return;
            qqOsjhDfbcTCbeFmh(HGJfIWGOkTcdLbGIFiAb);
            if (iYVmINDpHhehYOadREWmaW.Count > 0)
            {
                PrintWarning("В конфигурационный файл были добавлены новые предметы:");
                foreach (var mCDDdYSVLSWfHUkXrtG in iYVmINDpHhehYOadREWmaW) PrintWarning(mCDDdYSVLSWfHUkXrtG);
            }
            if (CBVPeybAMYQDADFiPvmfOMFv.Count > 0)
            {
                PrintWarning("Конфигурационный файл был очищен от устаревших предметов:");
                foreach (var mCDDdYSVLSWfHUkXrtG in CBVPeybAMYQDADFiPvmfOMFv) PrintWarning(mCDDdYSVLSWfHUkXrtG);
            }
        }
        private void Unload()
        {
            foreach (var mCDDdYSVLSWfHUkXrtG in ItemManager.itemList) mCDDdYSVLSWfHUkXrtG.stackable = jXuGEdXFJIzIUWQOpYOZNIJ[mCDDdYSVLSWfHUkXrtG.category.ToString() + "|" + mCDDdYSVLSWfHUkXrtG.displayName.english];
        }
        private ItemContainer.CanAcceptResult? CanAcceptItem(ItemContainer unsgxNVqXKqqECsXQrG, Item YjlEoVwLrCFlMZxGRUgOwaQjuF, int targetPos)
        {
            if (unsgxNVqXKqqECsXQrG == null || YjlEoVwLrCFlMZxGRUgOwaQjuF == null || unsgxNVqXKqqECsXQrG.playerOwner == null) return null;
            if (HGJfIWGOkTcdLbGIFiAb.RSjYaftfLwPnVesiMQltPxD.Contains(YjlEoVwLrCFlMZxGRUgOwaQjuF.info.displayName.english) || HGJfIWGOkTcdLbGIFiAb.RSjYaftfLwPnVesiMQltPxD.Contains(YjlEoVwLrCFlMZxGRUgOwaQjuF.info.shortname)) return null;
            if (unsgxNVqXKqqECsXQrG.playerOwner.inventory.containerBelt == unsgxNVqXKqqECsXQrG)
            {
                if (tcChzNBoJCMHBaBQGcpnAUGuamBU(YjlEoVwLrCFlMZxGRUgOwaQjuF.info) && ((HGJfIWGOkTcdLbGIFiAb.yBPzMbzsaiBVjicaXFqsmEjTwwvjd.Contains(YjlEoVwLrCFlMZxGRUgOwaQjuF.info.displayName.english) || HGJfIWGOkTcdLbGIFiAb.yBPzMbzsaiBVjicaXFqsmEjTwwvjd.Contains(YjlEoVwLrCFlMZxGRUgOwaQjuF.info.shortname)) || XAXfVFPbfUI.ContainsKey(YjlEoVwLrCFlMZxGRUgOwaQjuF.info.category.ToString()) && XAXfVFPbfUI[YjlEoVwLrCFlMZxGRUgOwaQjuF.info.category.ToString()] == 1))
                {
                    if (YjlEoVwLrCFlMZxGRUgOwaQjuF.amount > 1 || PVhltAKgoQ(unsgxNVqXKqqECsXQrG, YjlEoVwLrCFlMZxGRUgOwaQjuF, targetPos)) return ItemContainer.CanAcceptResult.CannotAccept;
                }
            }
            if (unsgxNVqXKqqECsXQrG.playerOwner.inventory.containerWear == unsgxNVqXKqqECsXQrG)
            {
                if ((HGJfIWGOkTcdLbGIFiAb.yBPzMbzsaiBVjicaXFqsmEjTwwvjd.Contains(YjlEoVwLrCFlMZxGRUgOwaQjuF.info.displayName.english) || HGJfIWGOkTcdLbGIFiAb.yBPzMbzsaiBVjicaXFqsmEjTwwvjd.Contains(YjlEoVwLrCFlMZxGRUgOwaQjuF.info.shortname)) || XAXfVFPbfUI.ContainsKey(YjlEoVwLrCFlMZxGRUgOwaQjuF.info.category.ToString()) && XAXfVFPbfUI[YjlEoVwLrCFlMZxGRUgOwaQjuF.info.category.ToString()] == 2)
                {
                    if (YjlEoVwLrCFlMZxGRUgOwaQjuF.amount > 1 || PVhltAKgoQ(unsgxNVqXKqqECsXQrG, YjlEoVwLrCFlMZxGRUgOwaQjuF, targetPos)) return ItemContainer.CanAcceptResult.CannotAccept;
                }
            }
            return null;
        }
        private bool? CanStackItem(Item YjlEoVwLrCFlMZxGRUgOwaQjuF, Item mCDDdYSVLSWfHUkXrtG)
        {
            if (HGJfIWGOkTcdLbGIFiAb.eyEnBlUwiSVEbqTYsOoAWSlbYAKqY.Contains(YjlEoVwLrCFlMZxGRUgOwaQjuF.skin) || HGJfIWGOkTcdLbGIFiAb.eyEnBlUwiSVEbqTYsOoAWSlbYAKqY.Contains(mCDDdYSVLSWfHUkXrtG.skin)) return null;
            if (HGJfIWGOkTcdLbGIFiAb.SUMgbOLYXEWqWGNauhbgEajpmt.Contains(YjlEoVwLrCFlMZxGRUgOwaQjuF.info.displayName.english) || HGJfIWGOkTcdLbGIFiAb.SUMgbOLYXEWqWGNauhbgEajpmt.Contains(mCDDdYSVLSWfHUkXrtG.info.displayName.english)) return null;
            if (HGJfIWGOkTcdLbGIFiAb.SUMgbOLYXEWqWGNauhbgEajpmt.Contains(YjlEoVwLrCFlMZxGRUgOwaQjuF.info.shortname) || HGJfIWGOkTcdLbGIFiAb.SUMgbOLYXEWqWGNauhbgEajpmt.Contains(mCDDdYSVLSWfHUkXrtG.info.shortname)) return null;
            if (YjlEoVwLrCFlMZxGRUgOwaQjuF == mCDDdYSVLSWfHUkXrtG) return false;
            if (YjlEoVwLrCFlMZxGRUgOwaQjuF.info.stackable <= 1 || mCDDdYSVLSWfHUkXrtG.info.stackable <= 1) return false;
            if (YjlEoVwLrCFlMZxGRUgOwaQjuF.info.itemid != mCDDdYSVLSWfHUkXrtG.info.itemid) return false;
            if ((YjlEoVwLrCFlMZxGRUgOwaQjuF.hasCondition || mCDDdYSVLSWfHUkXrtG.hasCondition) && YjlEoVwLrCFlMZxGRUgOwaQjuF.condition != mCDDdYSVLSWfHUkXrtG.condition) return false;
            if (YjlEoVwLrCFlMZxGRUgOwaQjuF.skin != mCDDdYSVLSWfHUkXrtG.skin) return false;
            if (YjlEoVwLrCFlMZxGRUgOwaQjuF.name != mCDDdYSVLSWfHUkXrtG.name) return false;
            if (!YjlEoVwLrCFlMZxGRUgOwaQjuF.IsValid()) return false;
            if (YjlEoVwLrCFlMZxGRUgOwaQjuF.IsBlueprint() && YjlEoVwLrCFlMZxGRUgOwaQjuF.blueprintTarget != mCDDdYSVLSWfHUkXrtG.blueprintTarget) return false;
            return true;
        }
        private bool? CanCombineDroppedItem(DroppedItem drItem, DroppedItem anotherDrItem)
        {
            var item = drItem.item;
            var anotherItem = anotherDrItem.item;
            return CanStackItem(item, anotherItem) == false ? false : (bool?)null;
        }
        private Item OnItemSplit(Item YjlEoVwLrCFlMZxGRUgOwaQjuF, int amount)
        {
            if (HGJfIWGOkTcdLbGIFiAb.eyEnBlUwiSVEbqTYsOoAWSlbYAKqY.Contains(YjlEoVwLrCFlMZxGRUgOwaQjuF.skin)) return null;
            if (HGJfIWGOkTcdLbGIFiAb.SUMgbOLYXEWqWGNauhbgEajpmt.Contains(YjlEoVwLrCFlMZxGRUgOwaQjuF.info.displayName.english)) return null;
            if (HGJfIWGOkTcdLbGIFiAb.SUMgbOLYXEWqWGNauhbgEajpmt.Contains(YjlEoVwLrCFlMZxGRUgOwaQjuF.info.shortname)) return null;
            YjlEoVwLrCFlMZxGRUgOwaQjuF.amount = YjlEoVwLrCFlMZxGRUgOwaQjuF.amount - amount;
            Item AHeQIspHDiVUzImA = ItemManager.CreateByItemID(YjlEoVwLrCFlMZxGRUgOwaQjuF.info.itemid, 1, YjlEoVwLrCFlMZxGRUgOwaQjuF.skin);
            AHeQIspHDiVUzImA.amount = amount;
            AHeQIspHDiVUzImA.condition = YjlEoVwLrCFlMZxGRUgOwaQjuF.condition;
            AHeQIspHDiVUzImA.name = YjlEoVwLrCFlMZxGRUgOwaQjuF.name;
            if (YjlEoVwLrCFlMZxGRUgOwaQjuF.IsBlueprint()) AHeQIspHDiVUzImA.blueprintTarget = YjlEoVwLrCFlMZxGRUgOwaQjuF.blueprintTarget;
            YjlEoVwLrCFlMZxGRUgOwaQjuF.MarkDirty();
            return AHeQIspHDiVUzImA;
        }
        private object CanMoveItem(Item YjlEoVwLrCFlMZxGRUgOwaQjuF, PlayerInventory GSTUBUXwFSqBtKpaHlcmtUFsMoMGO, uint unsgxNVqXKqqECsXQrG, int eXWOKZqloRYeEsnBgGstPrs, int qwsSuJWipQvJCvxZUC)
        {
            if (YjlEoVwLrCFlMZxGRUgOwaQjuF == null || GSTUBUXwFSqBtKpaHlcmtUFsMoMGO == null || YjlEoVwLrCFlMZxGRUgOwaQjuF.amount < UInt16.MaxValue || !HGJfIWGOkTcdLbGIFiAb.DUEChqBZGepQiXogDYihyz) return null;
            ItemContainer RuRhvPvkhs = GSTUBUXwFSqBtKpaHlcmtUFsMoMGO.FindContainer(unsgxNVqXKqqECsXQrG);
            if (RuRhvPvkhs == null) return null;
            ItemContainer bSfvWepLNmkebpSjeqBmmZKFzuf = GSTUBUXwFSqBtKpaHlcmtUFsMoMGO.GetContainer(PlayerInventory.Type.Main);
            BasePlayer UmdgJUdsICQjCLNCmVpJFPpCG = bSfvWepLNmkebpSjeqBmmZKFzuf?.GetOwnerPlayer();
            if (UmdgJUdsICQjCLNCmVpJFPpCG != null && FurnaceSplitter != null)
            {
                bool pcmqfqqQKjmfuGgPcn = true;
                bool pgPvNLEKEGR = false;
                bool UalgdHChFvtGdlJe = true;
                try
                {
                    pgPvNLEKEGR = (bool)FurnaceSplitter?.CallHook("GetEnabled", UmdgJUdsICQjCLNCmVpJFPpCG);
                    UalgdHChFvtGdlJe = (bool)FurnaceSplitter?.CallHook("HasPermission", UmdgJUdsICQjCLNCmVpJFPpCG);
                }
                catch
                {
                    pcmqfqqQKjmfuGgPcn = false;
                }
                if (pcmqfqqQKjmfuGgPcn && pgPvNLEKEGR && UalgdHChFvtGdlJe)
                {
                    BaseEntity opShpkXtBmBzygHxpNSnNeWg = RuRhvPvkhs.entityOwner;
                    if (opShpkXtBmBzygHxpNSnNeWg is BaseOven && (opShpkXtBmBzygHxpNSnNeWg as BaseOven).inventory.capacity > 1) return null;
                }
            }
            bool CeVnlKlOajCsMbMtjfSTzgDBpwWq = false;
            int rsibjVgyWEwINPELZzHUqRHhBWXPS = HGJfIWGOkTcdLbGIFiAb.AqfUFopQwAbfNey[YjlEoVwLrCFlMZxGRUgOwaQjuF.info.category.ToString()][YjlEoVwLrCFlMZxGRUgOwaQjuF.info.displayName.english];
            if (YjlEoVwLrCFlMZxGRUgOwaQjuF.amount > rsibjVgyWEwINPELZzHUqRHhBWXPS) CeVnlKlOajCsMbMtjfSTzgDBpwWq = true;
            if (qwsSuJWipQvJCvxZUC + YjlEoVwLrCFlMZxGRUgOwaQjuF.amount / UInt16.MaxValue == YjlEoVwLrCFlMZxGRUgOwaQjuF.amount % UInt16.MaxValue)
            {
                if (CeVnlKlOajCsMbMtjfSTzgDBpwWq)
                {
                    Item mCDDdYSVLSWfHUkXrtG = YjlEoVwLrCFlMZxGRUgOwaQjuF.SplitItem(rsibjVgyWEwINPELZzHUqRHhBWXPS);
                    if (!mCDDdYSVLSWfHUkXrtG.MoveToContainer(RuRhvPvkhs, eXWOKZqloRYeEsnBgGstPrs, true))
                    {
                        YjlEoVwLrCFlMZxGRUgOwaQjuF.amount += mCDDdYSVLSWfHUkXrtG.amount;
                        mCDDdYSVLSWfHUkXrtG.Remove(0f);
                    }
                    ItemManager.DoRemoves();
                    GSTUBUXwFSqBtKpaHlcmtUFsMoMGO.ServerUpdate(0f);
                    return true;
                }
                YjlEoVwLrCFlMZxGRUgOwaQjuF.MoveToContainer(RuRhvPvkhs, eXWOKZqloRYeEsnBgGstPrs, true);
                var KUmjsLKQxNcXUdjHocfeMAHh = "{DarkPluginsID}";
                return true;
            }
            else if (qwsSuJWipQvJCvxZUC + (YjlEoVwLrCFlMZxGRUgOwaQjuF.amount / 2) / UInt16.MaxValue == (YjlEoVwLrCFlMZxGRUgOwaQjuF.amount / 2) % UInt16.MaxValue + YjlEoVwLrCFlMZxGRUgOwaQjuF.amount % 2)
            {
                if (CeVnlKlOajCsMbMtjfSTzgDBpwWq)
                {
                    Item QBoFejCxYuHtQXGaNeODbDRTaq;
                    if (rsibjVgyWEwINPELZzHUqRHhBWXPS > YjlEoVwLrCFlMZxGRUgOwaQjuF.amount / 2) QBoFejCxYuHtQXGaNeODbDRTaq = YjlEoVwLrCFlMZxGRUgOwaQjuF.SplitItem(Convert.ToInt32(YjlEoVwLrCFlMZxGRUgOwaQjuF.amount) / 2);
                    else QBoFejCxYuHtQXGaNeODbDRTaq = YjlEoVwLrCFlMZxGRUgOwaQjuF.SplitItem(rsibjVgyWEwINPELZzHUqRHhBWXPS);
                    if (!QBoFejCxYuHtQXGaNeODbDRTaq.MoveToContainer(RuRhvPvkhs, eXWOKZqloRYeEsnBgGstPrs, true))
                    {
                        YjlEoVwLrCFlMZxGRUgOwaQjuF.amount += QBoFejCxYuHtQXGaNeODbDRTaq.amount;
                        QBoFejCxYuHtQXGaNeODbDRTaq.Remove(0f);
                    }
                    ItemManager.DoRemoves();
                    GSTUBUXwFSqBtKpaHlcmtUFsMoMGO.ServerUpdate(0f);
                    return true;
                }
                Item mCDDdYSVLSWfHUkXrtG = YjlEoVwLrCFlMZxGRUgOwaQjuF.SplitItem(YjlEoVwLrCFlMZxGRUgOwaQjuF.amount / 2);
                if ((YjlEoVwLrCFlMZxGRUgOwaQjuF.amount + mCDDdYSVLSWfHUkXrtG.amount) % 2 != 0)
                {
                    mCDDdYSVLSWfHUkXrtG.amount++;
                    YjlEoVwLrCFlMZxGRUgOwaQjuF.amount--;
                }
                if (!mCDDdYSVLSWfHUkXrtG.MoveToContainer(RuRhvPvkhs, eXWOKZqloRYeEsnBgGstPrs, true))
                {
                    YjlEoVwLrCFlMZxGRUgOwaQjuF.amount += mCDDdYSVLSWfHUkXrtG.amount;
                    mCDDdYSVLSWfHUkXrtG.Remove(0f);
                }
                ItemManager.DoRemoves();
                GSTUBUXwFSqBtKpaHlcmtUFsMoMGO.ServerUpdate(0f);
                return true;
            }
            return null;
        }
        private static bool tcChzNBoJCMHBaBQGcpnAUGuamBU(ItemDefinition DedPMrncJeUMztmDCKZLnpLDRqmdZ)
        {
            if (DedPMrncJeUMztmDCKZLnpLDRqmdZ == null) return false;
            return DedPMrncJeUMztmDCKZLnpLDRqmdZ.condition.enabled && DedPMrncJeUMztmDCKZLnpLDRqmdZ.condition.max > 0f;
        }
        private bool PVhltAKgoQ(ItemContainer unsgxNVqXKqqECsXQrG, Item mCDDdYSVLSWfHUkXrtG, int targetPos)
        {
            foreach (var item in unsgxNVqXKqqECsXQrG.itemList.Where(x => x != null && (targetPos == -1 || targetPos == x.position)))
            {
                if (CanStackItem(item, mCDDdYSVLSWfHUkXrtG) == true) return true;
            }
            return false;
        }
        private Dictionary<string, Dictionary<string, int>> ifyKXmaPzFnpcsUnGeoC()
        {
            var wJtvQOWXkUHbZbbWCpdvQNDUoSEu = new Dictionary<string,
              Dictionary<string, int>>();
            var VrMWZJkfdoElpJhbWIEDRDKd = ItemCategory.Weapon;
            var kvbKJrUQRpGKuFuEXXg = new Dictionary<string,
              int>();
            foreach (var mCDDdYSVLSWfHUkXrtG in ItemManager.itemList.OrderBy(r => r.category))
            {
                if (VrMWZJkfdoElpJhbWIEDRDKd != mCDDdYSVLSWfHUkXrtG.category && kvbKJrUQRpGKuFuEXXg.Count > 0)
                {
                    wJtvQOWXkUHbZbbWCpdvQNDUoSEu.Add($"{VrMWZJkfdoElpJhbWIEDRDKd}", new Dictionary<string, int>(kvbKJrUQRpGKuFuEXXg.OrderBy(x => x.Key)));
                    kvbKJrUQRpGKuFuEXXg.Clear();
                }
                if (!kvbKJrUQRpGKuFuEXXg.ContainsKey(mCDDdYSVLSWfHUkXrtG.displayName.english)) kvbKJrUQRpGKuFuEXXg.Add(mCDDdYSVLSWfHUkXrtG.displayName.english, mCDDdYSVLSWfHUkXrtG.stackable);
                VrMWZJkfdoElpJhbWIEDRDKd = mCDDdYSVLSWfHUkXrtG.category;
            }
            if (kvbKJrUQRpGKuFuEXXg.Count > 0) wJtvQOWXkUHbZbbWCpdvQNDUoSEu.Add($"{VrMWZJkfdoElpJhbWIEDRDKd}", new Dictionary<string, int>(kvbKJrUQRpGKuFuEXXg));
            return wJtvQOWXkUHbZbbWCpdvQNDUoSEu.OrderBy(x => x.Key).ToDictionary(x => x.Key, x => x.Value);
        }
        private static mnGUBGwBziEpAOYoFxtHiEXpYHzc HGJfIWGOkTcdLbGIFiAb;
        private class mnGUBGwBziEpAOYoFxtHiEXpYHzc
        {
            [JsonProperty(PropertyName = "Разрешить корректный перенос стаков больше 64К")] public bool DUEChqBZGepQiXogDYihyz;
            [JsonProperty(PropertyName = "Стаки предметов по категориям")] public Dictionary<string, Dictionary<string, int>> AqfUFopQwAbfNey;
            [JsonProperty(PropertyName = "Предметы которым принудительно разрешено стакаться в слотах быстрого доступа")] public List<string> RSjYaftfLwPnVesiMQltPxD;
            [JsonProperty(PropertyName = "Предметы которым принудительно запрещено стакаться в слотах быстрого доступа")] public List<string> yBPzMbzsaiBVjicaXFqsmEjTwwvjd;
            [JsonProperty(PropertyName = "Скины предметов которые не нужно обрабатывать плагином при стаке и разделении (для исключения конфликтов)")] public List<ulong> eyEnBlUwiSVEbqTYsOoAWSlbYAKqY;
            [JsonProperty(PropertyName = "Названия предметов которые не нужно обрабатывать плагином при стаке и разделении (для исключения конфликтов)")] public List<string> SUMgbOLYXEWqWGNauhbgEajpmt;
        }
        private void MFbOuyfXAqPnQUkGOaKBezo() => HGJfIWGOkTcdLbGIFiAb = Config.ReadObject<mnGUBGwBziEpAOYoFxtHiEXpYHzc>();
        protected override void LoadDefaultConfig()
        {
            if (ItemManager.itemList == null)
            {
                timer.Once(5f, () => LoadDefaultConfig());
                return;
            }
            HGJfIWGOkTcdLbGIFiAb = new mnGUBGwBziEpAOYoFxtHiEXpYHzc
            {
                DUEChqBZGepQiXogDYihyz = true,
                AqfUFopQwAbfNey = ifyKXmaPzFnpcsUnGeoC(),
                RSjYaftfLwPnVesiMQltPxD = new List<string>(),
                yBPzMbzsaiBVjicaXFqsmEjTwwvjd = new List<string>() {
          "Blue Keycard",
          "Green Keycard",
          "Red Keycard"
        },
                eyEnBlUwiSVEbqTYsOoAWSlbYAKqY = new List<ulong>(),
                SUMgbOLYXEWqWGNauhbgEajpmt = new List<string>()
            };
            qqOsjhDfbcTCbeFmh(HGJfIWGOkTcdLbGIFiAb);
            timer.Once(0.1f, () => qqOsjhDfbcTCbeFmh(HGJfIWGOkTcdLbGIFiAb));
        }
        private void qqOsjhDfbcTCbeFmh(mnGUBGwBziEpAOYoFxtHiEXpYHzc pnkxntVfNGmAQWTSSYCf) => Config.WriteObject(pnkxntVfNGmAQWTSSYCf, true);
    }
}

// --- End of file: Stacks.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/SystemRPG.cs ---
// --- Original Local Path: TrashRust/SystemRPG.cs ---

using System;
using System.Collections;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Imaging;
using System.Globalization;
using System.IO;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;
using Oxide.Core.Plugins;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using ProtoBuf;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("SystemRPG", "Mareloy", "1.0.1")]

    public class SystemRPG : RustPlugin
    {
		private static ConfigData configData;
        private class ConfigData
        {
			[JsonProperty("ОСНОВНЫЕ НАСТРОЙКИ")]
            public BasicSetting OptionsBasic = new BasicSetting();
			[JsonProperty("НАСТРОЙКИ ПОЛУЧЕНИЯ ОПЫТА")]
            public ActionPoints ActionSettings = new ActionPoints();
			[JsonProperty("НАСТРОЙКИ ОПЫТА И ОПИСАНИЕ")]
            public Dictionary<string, Skill> SkillList = new Dictionary<string, Skill>();

            internal class BasicSetting 
            {
				[JsonProperty("Текст в шапке")]
                public string Descript = "Название сервера";
				[JsonProperty("Стартовое количество очков у игрока")]
                public int BasePoints = 0;
				[JsonProperty("Количество выдаваемого опыта каждую минуту")]
                public float TimePoints = 0.0f;
                [JsonProperty("Ссылка на картинку слева")]
                public string UrlImgLeft = "https://i.imgur.com/uMJxkcx.png";
                [JsonProperty("Ссылка на картинку с права")]
                public string UrlImgRight = "https://i.imgur.com/KSnYPLm.png";
			}

			internal class ActionPoints
            {
                [JsonProperty("Количество выдаваемого опыта за добычу ресурсов отбойным молотком")]
                public float GatherHitChainsaw = 0.00001f;
                [JsonProperty("Количество выдаваемого опыта за добычу ресурсов бензопилой")]
                public float GatherHitJackhammer = 0.00001f;
                [JsonProperty("Количество выдаваемого опыта за попадание по вертолёту")]
                public float HeliDamage = 0.0005f;
                [JsonProperty("Количество выдаваемого опыта за улучшение построек")]
                public float Upgrade = 0.005f;
                [JsonProperty("Количество выдаваемого опыта за попадание по танку")]
                public float TankDamage = 0.0005f;
                [JsonProperty("Количество выдаваемого опыта за убийство животных")]
                public float AnimalKill = 0.03f;
                [JsonProperty("Количество выдаваемого опыта за поднятие предмета")]
                public float PickUp = 0.001f;
                [JsonProperty("Количество выдаваемого опыта за добычу ресурсов")]
                public float GatherHit = 0.0002f;
                [JsonProperty("Количество выдаваемого опыта за убийство игрока")]
                public float PlayerKill = 0.02f;
				[JsonProperty("Количество выдаваемого опыта за разбитие бочек")]
				public float BarrelKill = 0.0002f;
                [JsonProperty("Количество выдаваемого опыта за убийство NPC")]
                public float NPCKill = 0.02f;

				// [JsonProperty("Количество выдаваемого стартового опыта за улучшение")]
                // public float BaseLearn = 0.002f;
                // [JsonProperty("Множитель за уровень чертежа")]
                // public float LearnIncrease = 0.0002f;
            }

            internal class Skill
            {
                [JsonProperty("Отображаемое название опыта")]
                public string DisplayName;
                [JsonProperty("Описание опыта")]
                public string Description;
                [JsonProperty("Поместить данный опыт в верху")]
                public bool IsSkill;
                [JsonProperty("Ссылка на картинку опыта")]
                public string SkillURL;
                [JsonProperty("Рейт опыта при повышении уровня |Кол-во уровней|")]
                public List<float> Increase = new List<float>();
            }

            public float GetIncreaseOf(string name, int level)
            {
                if (SkillList.ContainsKey(name))
                {
                    if (SkillList[name].Increase.Count >= level)
						return SkillList[name].Increase.ElementAt(level);
                }
                Interface.Oxide.LogWarning($"Try to get {level}LVL of {name} that is not exists!");
                return 0f;
            }

            public ConfigData()
            {
                ActionSettings = new ActionPoints();
				OptionsBasic = new BasicSetting();

				SkillList = new Dictionary<string, Skill>
                {
                    ["ШАХТЁР"] = new Skill
                    {
                        DisplayName = "ШАХТЁР",
                        Description = "С каждым уровнем увеличивается количество добываемых ресурсов киркой, чем выше уровень, \nтем больше вы будете добывать ресурсов.",
                        SkillURL = "https://imgur.com/ixHJgXc.png",
                        IsSkill = true,
                        Increase = new List<float>
                        {
                            1.0f, 1.05f, 1.1f, 1.15f, 1.2f, 1.25f, 1.3f, 1.35f, 1.4f, 1.45f, 1.5f, 1.55f, 1.6f, 1.65f, 1.7f,
							1.75f, 1.8f, 1.85f, 1.9f, 1.95f, 2.0f, 2.05f, 2.1f, 2.15f, 2.2f, 2.25f, 2.3f, 2.35f, 2.4f, 2.45f,
							2.5f, 2.55f, 2.6f, 2.65f, 2.7f, 2.75f, 2.8f, 2.85f, 2.9f, 2.95f, 3.0f, 3.05f, 3.1f, 3.15f, 3.2f,
							3.25f, 3.3f, 3.35f, 3.4f, 3.45f, 3.5f, 3.55f, 3.6f, 3.65f, 3.7f, 3.75f, 3.8f, 3.85f, 3.9f, 3.95f,
							4.0f, 4.05f, 4.1f, 4.15f, 4.2f, 4.25f, 4.3f, 4.35f, 4.4f, 4.45f, 4.5f, 4.55f, 4.6f, 4.65f, 4.7f,
                            4.75f, 4.8f, 4.85f, 4.9f, 4.95f, 5.0f
                        }
                    },
                    ["ДРОВОСЕК"] = new Skill
                    {
                        DisplayName = "ДРОВОСЕК",
                        Description = "Каждый уровень увеличивает количество добываемого дерева, \nчем выше ваш уровень, тем больше вы будете добывать дерева.",
                        SkillURL = "https://imgur.com/O5HCgDq.png",
                        IsSkill = true,
                        Increase = new List<float>
                        {
                            1.0f, 1.05f, 1.1f, 1.15f, 1.2f, 1.25f, 1.3f, 1.35f, 1.4f, 1.45f, 1.5f, 1.55f, 1.6f, 1.65f, 1.7f,
							1.75f, 1.8f, 1.85f, 1.9f, 1.95f, 2.0f, 2.05f, 2.1f, 2.15f, 2.2f, 2.25f, 2.3f, 2.35f, 2.4f, 2.45f,
							2.5f, 2.55f, 2.6f, 2.65f, 2.7f, 2.75f, 2.8f, 2.85f, 2.9f, 2.95f, 3.0f, 3.05f, 3.1f, 3.15f, 3.2f,
							3.25f, 3.3f, 3.35f, 3.4f, 3.45f, 3.5f, 3.55f, 3.6f, 3.65f, 3.7f, 3.75f, 3.8f, 3.85f, 3.9f, 3.95f,
							4.0f, 4.05f, 4.1f, 4.15f, 4.2f, 4.25f, 4.3f, 4.35f, 4.4f, 4.45f, 4.5f, 4.55f, 4.6f, 4.65f, 4.7f,
                            4.75f, 4.8f, 4.85f, 4.9f, 4.95f, 5.0f
                        }
                    },
                    ["ПЕЧНИК"] = new Skill
                    {
                        DisplayName = "ПЕЧНИК",
                        Description = "Скаждым уровнем увеличивается скорость плавки в печах, \nчем выше ваш уровень, тем быстрее работает печь.",
                        SkillURL = "https://imgur.com/UEYt0uM.png",
                        IsSkill = true,
                        Increase = new List<float>
                        {
                            1.0f, 1.05f, 1.1f, 1.15f, 1.2f, 1.25f, 1.3f, 1.35f, 1.4f, 1.45f, 1.5f, 1.55f, 1.6f, 1.65f, 1.7f,
							1.75f, 1.8f, 1.85f, 1.9f, 1.95f, 2.0f, 2.05f, 2.1f, 2.15f, 2.2f, 2.25f, 2.3f, 2.35f, 2.4f, 2.45f,
							2.5f, 2.55f, 2.6f, 2.65f, 2.7f, 2.75f, 2.8f, 2.85f, 2.9f, 2.95f, 3.0f, 3.05f, 3.1f, 3.15f, 3.2f,
							3.25f, 3.3f, 3.35f, 3.4f, 3.45f, 3.5f, 3.55f, 3.6f, 3.65f, 3.7f, 3.75f, 3.8f, 3.85f, 3.9f, 3.95f,
							4.0f, 4.05f, 4.1f, 4.15f, 4.2f, 4.25f, 4.3f, 4.35f, 4.4f, 4.45f, 4.5f, 4.55f, 4.6f, 4.65f, 4.7f,
                            4.75f, 4.8f, 4.85f, 4.9f, 4.95f, 5.0f
                        }
                    },
                    ["ОХОТНИК"] = new Skill
                    {
                        DisplayName = "ОХОТНИК",
                        Description = "Прокачка этого навыка позволит вам получать больше ресурсов, \nпри разделке животных.",
                        SkillURL = "https://imgur.com/BLQZBem.png",
                        IsSkill = true,
                        Increase = new List<float>
                        {
                            1.0f, 1.05f, 1.1f, 1.15f, 1.2f, 1.25f, 1.3f, 1.35f, 1.4f, 1.45f, 1.5f, 1.55f, 1.6f, 1.65f, 1.7f,
							1.75f, 1.8f, 1.85f, 1.9f, 1.95f, 2.0f, 2.05f, 2.1f, 2.15f, 2.2f, 2.25f, 2.3f, 2.35f, 2.4f, 2.45f,
							2.5f, 2.55f, 2.6f, 2.65f, 2.7f, 2.75f, 2.8f, 2.85f, 2.9f, 2.95f, 3.0f, 3.05f, 3.1f, 3.15f, 3.2f,
							3.25f, 3.3f, 3.35f, 3.4f, 3.45f, 3.5f, 3.55f, 3.6f, 3.65f, 3.7f, 3.75f, 3.8f, 3.85f, 3.9f, 3.95f,
							4.0f, 4.05f, 4.1f, 4.15f, 4.2f, 4.25f, 4.3f, 4.35f, 4.4f, 4.45f, 4.5f, 4.55f, 4.6f, 4.65f, 4.7f,
                            4.75f, 4.8f, 4.85f, 4.9f, 4.95f, 5.0f
                        }
                    },
                    ["ФЕРМЕР"] = new Skill
                    {
                        DisplayName = "ФЕРМЕР",
                        Description = "С каждым следующем уровнем вы будете получать больше ресурсов \nпри подборе их с земли.",
                        SkillURL = "https://imgur.com/Z81unSg.png",
                        IsSkill = true,
                        Increase = new List<float>
                        {
                            1.0f, 1.05f, 1.1f, 1.15f, 1.2f, 1.25f, 1.3f, 1.35f, 1.4f, 1.45f, 1.5f, 1.55f, 1.6f, 1.65f, 1.7f,
							1.75f, 1.8f, 1.85f, 1.9f, 1.95f, 2.0f, 2.05f, 2.1f, 2.15f, 2.2f, 2.25f, 2.3f, 2.35f, 2.4f, 2.45f,
							2.5f, 2.55f, 2.6f, 2.65f, 2.7f, 2.75f, 2.8f, 2.85f, 2.9f, 2.95f, 3.0f, 3.05f, 3.1f, 3.15f, 3.2f,
							3.25f, 3.3f, 3.35f, 3.4f, 3.45f, 3.5f, 3.55f, 3.6f, 3.65f, 3.7f, 3.75f, 3.8f, 3.85f, 3.9f, 3.95f,
							4.0f, 4.05f, 4.1f, 4.15f, 4.2f, 4.25f, 4.3f, 4.35f, 4.4f, 4.45f, 4.5f, 4.55f, 4.6f, 4.65f, 4.7f,
                            4.75f, 4.8f, 4.85f, 4.9f, 4.95f, 5.0f
                        }
                    },
                    ["СТРЕЛОК"] = new Skill
                    {
                        DisplayName = "СТРЕЛОК",
                        Description = "Каждый новый уровень вам даст способность наносить \nбольше урона игрокам при перестрелке.",
                        SkillURL = "https://imgur.com/mnHB2JQ.png",
                        IsSkill = false,
                        Increase = new List<float>
                        {
                            1.0f, 1.03f, 1.06f, 1.09f, 1.12f, 1.15f,
							1.18f, 1.21f, 1.24f, 1.27f, 1.3f, 1.33f,
							1.36f, 1.39f, 1.42f, 1.45f, 1.48f, 1.51f,
							1.54f, 1.57f, 1.6f
                        }
                    },
                    ["ЛОВКОСТЬ"] = new Skill
                    {
                        DisplayName = "ЛОВКОСТЬ",
                        Description = "Каждый уровень дает больше шанса уклониться от получения урона \nЧем выше ваш уровень, тем больше шанс уклона от пуль.",
                        SkillURL = "https://imgur.com/fJFd5ds.png",
                        IsSkill = false,
                        Increase = new List<float>
                        {
                            0.0f, 0.01f, 0.02f, 0.03f, 0.04f, 0.05f,
							0.06f, 0.07f, 0.08f, 0.09f, 0.1f,  0.11f,
							0.12f,  0.13f,  0.14f,  0.15f,  0.16f,
							0.17f,  0.18f,  0.19f,  0.25f
                        }
                    },
                    ["СИЛА"] = new Skill
                    {
                        DisplayName = "СИЛА",
                        Description = "С каждым новым уровнем вы будете получать меньше \nурона который вам наносят игроки и НПС.",
                        SkillURL = "https://imgur.com/q3rrvuK.png",
                        IsSkill = false,
                        Increase = new List<float>
                        {
                            0.0f, 0.01f, 0.02f, 0.03f, 0.04f, 0.05f, 0.06f, 0.07f, 0.08f, 0.09f, 0.1f,
                            0.11f, 0.12f, 0.13f, 0.14f, 0.15f, 0.16f, 0.17f, 0.18f, 0.19f, 0.25f
                        }
                    },
                    //["ИНТЕЛЛЕКТ"] = new Skill
                    //{
                    //    DisplayName = "ИНТЕЛЛЕКТ",
                    //    Description = "Улучшая эту способность вы получаете возможность \nбыстрее крафтить предметы. \nБесполезный навык на нашем сервере.",
                    //    SkillURL = "https://imgur.com/l75dJCH.png",
                    //    IsSkill = false,
                    //    Increase = new List<float>
                    //    {
                    //        0.0f, 0.03f, 0.06f, 0.09f, 0.12f, 0.15f, 0.18f, 0.21f, 0.24f, 0.27f, 0.3f,
                    //        0.33f, 0.36f, 0.39f, 0.42f, 0.45f, 0.48f, 0.51f, 0.54f, 0.57f, 0.6f
                    //    }
                    //},
					["МЕТАБОЛИЗМ"] = new Skill
                    {
                        DisplayName = "МЕТАБОЛИЗМ",
                        Description = "Улучшая эту способность вы получаете возможность \nбыстрее крафтить предметы. \nБесполезный навык на нашем сервере.",
                        SkillURL = "https://imgur.com/l75dJCH.png",
                        IsSkill = false,
                        Increase = new List<float>
                        {
                            0.0f, 0.03f, 0.06f, 0.09f, 0.12f, 0.15f, 0.18f, 0.21f, 0.24f, 0.27f, 0.3f,
                            0.33f, 0.36f, 0.39f, 0.42f, 0.45f, 0.48f, 0.51f, 0.54f, 0.57f, 0.6f
                        }
                    },
                    ["ВАМПИРИЗМ"] = new Skill
                    {
                        DisplayName = "ВАМПИРИЗМ",
                        Description = "Каждый новый уровень вам даст способность регенирировать \nсвое здоровье при нанесении урона игрокам.",
                        SkillURL = "https://imgur.com/myVICVD.png",
                        IsSkill = false,
                        Increase = new List<float>
                        {
                            0.0f, 1.0f, 1.5f, 2.0f, 2.5f, 3.0f, 3.5f, 4.0f, 4.5f, 5.0f, 5.5f,
							6.0f, 6.5f, 7.0f, 7.5f, 8.0f, 8.5f, 9.0f, 9.5f, 10.0f
                        }
                    },
                };
            }
        }

     #region Variables

        private static Dictionary<ulong, PlayerInfo> PlayerInfos = new Dictionary<ulong, PlayerInfo>();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData?.SkillList == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Ошибка чтения конфигурации 'oxide/configData/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }
        protected override void LoadDefaultConfig() => configData = new ConfigData();
        protected override void SaveConfig() => Config.WriteObject(configData);

     #endregion
     #region Classes

        private class PlayerInfo
        {
            internal class SkillInfo
            {
                public Dictionary<string, int> Skills = new Dictionary<string, int>();
                public float GetCurrentIncrease(string name) => configData.GetIncreaseOf(name, Skills[name]);
            }

            public float CurrentPoints;
            public SkillInfo SkillsInfo = new SkillInfo();

            public void AddPoints(BasePlayer player, float increase)
            {
                CurrentPoints += increase;
                if (player != null)
                {
                    UI_DrawCurrentInfo(player, Math.Floor(CurrentPoints) > Math.Floor(CurrentPoints - increase));
                }
            }

            public bool AddLevel(BasePlayer player, string name)
            {
                if (CurrentPoints < 1)
                {
                    UI_DrawResearch(player, name + "ERROR");
                    return false;
                }

                if (SkillsInfo.Skills[name] + 1 >= configData.SkillList[name].Increase.Count)
                {
                    UI_DrawResearch(player, name + "UPER");
                    return false;
                }

                SkillsInfo.Skills[name]++;
                UI_DrawResearch(player, name);
                CurrentPoints--;
                return true;
            }
        }

     #endregion
     #region Initialization

	    static SystemRPG ins;
        [PluginReference] Plugin XMenu;
        Timer TimerInitialize;
        private void OnServerInitialized()
        {
            ins = this;
            if (Interface.Oxide.DataFileSystem.ExistsDatafile("PluginDataBase/SystemRPG/SystemRPG_Player"))
				PlayerInfos = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, PlayerInfo>>("PluginDataBase/SystemRPG/SystemRPG_Player");

            TimerInitialize = timer.Every(5f, () =>
            {
                if (XMenu.IsLoaded)
                {
                    XMenu.Call("API_RegisterMenu", this.Name, "rpg", "assets/icons/study.png", "RenderRpg", null);

                    cmd.AddChatCommand("rpg", this, (p, cmd, args) => rust.RunClientCommand(p, "custommenu true rpg"));
                    TimerInitialize.Destroy();
                }
            });

            InitFileManager();
			ServerMgr.Instance.StartCoroutine(LoadImages());

            foreach (var check in BasePlayer.activePlayerList)
                OnPlayerConnected(check);

            if (configData.OptionsBasic.TimePoints > 0)
            {
                timer.Every(60, () =>
                {
                    foreach (var basePlayer in BasePlayer.activePlayerList.Where(p => !p.IsReceivingSnapshot))
                    {
                        PlayerInfos[basePlayer.userID].AddPoints(basePlayer, configData.OptionsBasic.TimePoints);
                    }
                });
            }

            foreach (var imagesKey in configData.SkillList)
            {
                if (!string.IsNullOrEmpty(imagesKey.Value.SkillURL))
                    ServerMgr.Instance.StartCoroutine(m_FileManager.LoadFile(imagesKey.Key, imagesKey.Value.SkillURL));
            }
        }

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject("PluginDataBase/SystemRPG/SystemRPG_Player", PlayerInfos);
        void OnServerSave() => SaveData();

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, "GUI_SystemRPG_Lvl");
                CuiHelper.DestroyUi(player, "GUI_SystemRPG_Menu");
                CuiHelper.DestroyUi(player, "GUI_SystemRPG_Lvl" + ".CE");
                CuiHelper.DestroyUi(player, "GUI_SystemRPG_Lvl" + ".CL");
            }
            SaveData();
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player.IsReceivingSnapshot)
            {
                timer.In(1f, () => OnPlayerConnected(player));
                return;
            }

            if (!PlayerInfos.ContainsKey(player.userID))
            {
                PlayerInfos.Add(player.userID, new PlayerInfo { CurrentPoints = configData.OptionsBasic.BasePoints });
                PlayerInfos[player.userID].SkillsInfo.Skills = configData.SkillList.ToDictionary(p => p.Key, p => 0); // 1
            }

            CuiHelper.DestroyUi(player, LayerInfo);
            CuiElementContainer container = new CuiElementContainer();

			container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-235 16", OffsetMax = "-210 98" },
                Button = { Color = HexToRustFormat("#8E8E8E40"), Command = "chat.say /rpg" },
                Text = { Text = "" }
            }, "Hud", LayerInfo);

			timer.Once(5f, () =>
			{
			    CuiHelper.AddUi(player, container);
			    UI_DrawCurrentInfo(player);
			});
        }

     #endregion
     #region Hooks

        // private void OnItemCraftFinished(ItemCraftTask task, Item item)
        // {
        //     if (task.owner != null)
        //     {
        //         BasePlayer player = task.owner;
        //         if (PlayerInfos.ContainsKey(player.userID))
        //         {
        //             PlayerInfos[player.userID].AddPoints(player, configData.ActionSettings.BaseLearn * configData.ActionSettings.LearnIncrease * task.blueprint.workbenchLevelRequired);
        //         }
        //     }
        //     return;
        // }

        //object OnItemCraft(ItemCraftTask task, BasePlayer crafter)
        //{
        //    if (PlayerInfos.ContainsKey(crafter.userID))
        //    {
        //        var curvalue = PlayerInfos[crafter.userID].SkillsInfo.GetCurrentIncrease("ИНТЕЛЛЕКТ");
        //        var craftingTime = task.blueprint.time;
        //        var amountToReduce = task.blueprint.time * curvalue;
        //        craftingTime -= amountToReduce;
        //
        //        if (craftingTime < 0)
        //            craftingTime = 0;
        //
        //        if (!task.blueprint.name.Contains("(Clone)"))
        //            task.blueprint = UnityEngine.Object.Instantiate(task.blueprint);
        //
        //        task.blueprint.time = craftingTime;
        //        return null;
        //    }
        //    return null;
        //}

        object OnOvenToggle(BaseOven oven, BasePlayer player)
        {
            if (oven.HasFlag(BaseEntity.Flags.On)) return null;

            if (oven.ShortPrefabName.Contains("furnace"))
            {
                double rate = PlayerInfos[player.userID].SkillsInfo.GetCurrentIncrease("ПЕЧНИК");
                StartCooking(oven, oven.GetComponent<BaseEntity>(), rate);
                return false;
            }
            return null;
        }

        void StartCooking(BaseOven oven, BaseEntity entity, double ovenMultiplier)
        {
            if (FindBurnable(oven) == null)
                return;
            oven.inventory.temperature = 1000f;
            oven.UpdateAttachmentTemperature();
            InvokeHandler.CancelInvoke(entity.GetComponent<MonoBehaviour>(), new Action(oven.Cook));
            InvokeHandler.InvokeRepeating(entity.GetComponent<MonoBehaviour>(), new Action(oven.Cook), (float)(1f / ovenMultiplier), (float)(1f / ovenMultiplier));
            entity.SetFlag(BaseEntity.Flags.On, true, false);
        }

        Item FindBurnable(BaseOven oven)
        {
            if (oven.inventory == null)
                return null;
            foreach (Item current in oven.inventory.itemList)
            {
                ItemModBurnable component = current.info.GetComponent<ItemModBurnable>();
                if (component && (oven.fuelType == null || current.info == oven.fuelType))
                    return current;
            }
            return null;
        }

        List<LootContainer> handledContainers = new List<LootContainer>();
        private void CanAffordUpgrade(BasePlayer player, BuildingBlock block, BuildingGrade.Enum grade)
        {
            if (PlayerInfos.ContainsKey(player.userID))
            {
                PlayerInfos[player.userID].AddPoints(player, configData.ActionSettings.Upgrade);
            }
        }

        private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity is BasePlayer && entity.GetComponent<NPCPlayer>() == null && !entity.IsNpc)
            {
                BasePlayer player = entity as BasePlayer;
                var attacker = info.InitiatorPlayer;
                if (UnityEngine.Random.Range(0f, 1f) < PlayerInfos[player.userID].SkillsInfo.GetCurrentIncrease("ЛОВКОСТЬ"))
                {
                    info.damageTypes.ScaleAll(0);
                    return false;
                }
                if (PlayerInfos.ContainsKey(player.userID))
                {
                    float decrease = PlayerInfos[player.userID].SkillsInfo.GetCurrentIncrease("СИЛА");
                    info.damageTypes.ScaleAll(1 - decrease);
                }
            }
            if (info.InitiatorPlayer != null && PlayerInfos.ContainsKey(info.InitiatorPlayer.userID))
            {
                if (entity is LootContainer || entity is BuildingBlock) return null;
                float increase = PlayerInfos[info.InitiatorPlayer.userID].SkillsInfo.GetCurrentIncrease("ВАМПИРИЗМ");
                NextTick(() =>
                {
                    var damage = System.Convert.ToInt32(Math.Round(info.damageTypes.Total(), 0, MidpointRounding.AwayFromZero));
                    var heal = damage * (increase/100);
                    info.InitiatorPlayer.health += heal;
                });

            }
            if (info != null && info.Initiator is BasePlayer && !info.Initiator.IsNpc && info.Initiator.GetComponent<NPCPlayer>() == null)
            {
                if (PlayerInfos.ContainsKey(info.Initiator.GetComponent<BasePlayer>().userID))
                {
					if (entity as BaseCorpse != null)
                        return null;
                    BasePlayer player = info.Initiator.GetComponent<BasePlayer>();
                    float increase = PlayerInfos[player.userID].SkillsInfo.GetCurrentIncrease("СТРЕЛОК");
                    info.damageTypes.ScaleAll(increase);

                    if (entity is BaseHelicopter)
                    {
                        PlayerInfos[player.userID].AddPoints(player, configData.ActionSettings.HeliDamage);
                    }
                    if (entity is BradleyAPC)
                    {
                        PlayerInfos[player.userID].AddPoints(player, configData.ActionSettings.TankDamage);
                    }
                }
            }
            return null;
        }

		private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            if (entity != null && entity is BasePlayer)
            {
                BasePlayer player = entity as BasePlayer;
                if (PlayerInfos.ContainsKey(player.userID))
                {
					float increase = 1f;

					var activeitem = player.GetActiveItem();
				    if (activeitem != null && activeitem.info.shortname.Contains("jackhammer"))
					{
						PlayerInfos[player.userID].AddPoints(player, configData.ActionSettings.GatherHitJackhammer);
						if (dispenser.gatherType == ResourceDispenser.GatherType.Tree)
                        {
                            increase = PlayerInfos[player.userID].SkillsInfo.GetCurrentIncrease("ДРОВОСЕК");
                        }
                        else if (dispenser.gatherType == ResourceDispenser.GatherType.Ore)
                        {
                            increase = PlayerInfos[player.userID].SkillsInfo.GetCurrentIncrease("ШАХТЁР");
                        }
                        item.amount = (int)Math.Floor(item.amount * increase);
					}
					if (activeitem != null && activeitem.info.shortname.Contains("chainsaw"))
					{
						PlayerInfos[player.userID].AddPoints(player, configData.ActionSettings.GatherHitChainsaw);
						if (dispenser.gatherType == ResourceDispenser.GatherType.Tree)
                        {
                            increase = PlayerInfos[player.userID].SkillsInfo.GetCurrentIncrease("ДРОВОСЕК");
                        }
                        else if (dispenser.gatherType == ResourceDispenser.GatherType.Ore)
                        {
                            increase = PlayerInfos[player.userID].SkillsInfo.GetCurrentIncrease("ШАХТЁР");
                        }
                        item.amount = (int)Math.Floor(item.amount * increase);
					}

					PlayerInfos[player.userID].AddPoints(player, configData.ActionSettings.GatherHit);
                    if (dispenser.gatherType == ResourceDispenser.GatherType.Tree)
                    {
                        increase = PlayerInfos[player.userID].SkillsInfo.GetCurrentIncrease("ДРОВОСЕК");
                    }
                    else if (dispenser.gatherType == ResourceDispenser.GatherType.Ore)
                    {
                        increase = PlayerInfos[player.userID].SkillsInfo.GetCurrentIncrease("ШАХТЁР");
                    }
                    else if (dispenser.gatherType == ResourceDispenser.GatherType.Flesh)
                    {
                        increase = PlayerInfos[player.userID].SkillsInfo.GetCurrentIncrease("ОХОТНИК");
                    }
                    item.amount = (int)Math.Floor(item.amount * increase);
                }
            }
            return;
        }

        void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            if (PlayerInfos.ContainsKey(player.userID))
            {
                PlayerInfos[player.userID].AddPoints(player, configData.ActionSettings.GatherHit);

                float increase = 1f;
                if (dispenser.gatherType == ResourceDispenser.GatherType.Tree)
                {
                    increase = PlayerInfos[player.userID].SkillsInfo.GetCurrentIncrease("ДРОВОСЕК");
                }
                else if (dispenser.gatherType == ResourceDispenser.GatherType.Ore)
                {
                    increase = PlayerInfos[player.userID].SkillsInfo.GetCurrentIncrease("ШАХТЁР");
                }
                else if (dispenser.gatherType == ResourceDispenser.GatherType.Flesh)
                {
                    increase = PlayerInfos[player.userID].SkillsInfo.GetCurrentIncrease("ОХОТНИК");
                }

                item.amount = (int)Math.Floor(item.amount * increase);
            }
            return;
        }

        private void OnCollectiblePickup(Item item, BasePlayer player)
        {
            PlayerInfos[player.userID].AddPoints(player, configData.ActionSettings.PickUp);
            float increase = PlayerInfos[player.userID].SkillsInfo.GetCurrentIncrease("ФЕРМЕР");
            item.amount = (int)Math.Floor(item.amount * increase);
            return;
        }

        void OnGrowableGather(GrowableEntity plant, Item item, BasePlayer player)
        {
            PlayerInfos[player.userID].AddPoints(player, configData.ActionSettings.PickUp);
            float increase = PlayerInfos[player.userID].SkillsInfo.GetCurrentIncrease("ФЕРМЕР");
            item.amount = (int)Math.Floor(item.amount * increase);
            return;
        } 

        void OnQuarryGather(MiningQuarry quarry, Item item)
        {
            if (quarry.OwnerID == 0) return;
            int newAmount = (int)(item.amount * PlayerInfos[quarry.OwnerID].SkillsInfo.GetCurrentIncrease("ШАХТЁР"));
            item.amount = newAmount > 1 ? newAmount : 1;
        }

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (info != null && info.Initiator is BasePlayer && !info.Initiator.IsNpc && info.Initiator.GetComponent<BasePlayer>().IsConnected)
            {
                BasePlayer initiator = info.Initiator as BasePlayer;
				if(info.InitiatorPlayer != null && info.InitiatorPlayer == entity)
                    return;
                if (entity is BasePlayer && !entity.IsNpc)
                    PlayerInfos[initiator.userID].AddPoints(initiator, configData.ActionSettings.PlayerKill);
                if (entity.GetComponent<BaseAnimalNPC>() != null)
                    PlayerInfos[initiator.userID].AddPoints(initiator, configData.ActionSettings.AnimalKill);
                if (entity.GetComponent<BaseNPC>() != null || entity.GetComponent<NPCPlayer>() != null || entity.ShortPrefabName == "scarecrow")
                    PlayerInfos[initiator.userID].AddPoints(initiator, configData.ActionSettings.NPCKill);

                if (entity.ShortPrefabName.Contains("barrel"))
                {
                    PlayerInfos[initiator.userID].AddPoints(initiator, configData.ActionSettings.BarrelKill);
                }
            }
        }

		private void OnPlayerRespawned(BasePlayer player)
        {
            if (PlayerInfos.ContainsKey(player.userID))
            {
			    float increase = PlayerInfos[player.userID].SkillsInfo.GetCurrentIncrease("МЕТАБОЛИЗМ");
			    double Health = increase;
			    player.health += (float) Health;
			}
			return;
        }

     #endregion
     #region Interface

        private const string LayerInfo = "GUI_SystemRPG_Lvl";
        private static void UI_DrawCurrentInfo(BasePlayer player, bool fadeIn = false)
        {
            PlayerInfo playerInfo = PlayerInfos[player.userID];
            CuiElementContainer container = new CuiElementContainer();
            float percents = (float)(playerInfo.CurrentPoints - Math.Floor(playerInfo.CurrentPoints));

            CuiHelper.DestroyUi(player, LayerInfo + ".CE");
            CuiHelper.DestroyUi(player, LayerInfo + ".CL");

            container.Add(new CuiElement
            {
                FadeOut = fadeIn ? 1f : 0f, Parent = LayerInfo, Name = LayerInfo + ".CE",
                Components =
                {
                    new CuiImageComponent { Color = HexToRustFormat("#A7330DE6") },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = $"1 {percents}", OffsetMin = "1 1", OffsetMax = "-1 -1" },
                }
            });
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.458", AnchorMax = "1 0.645" },
                Text = { Text = $"{((percents) * 100).ToString("F0")}%", FontSize = 11, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter, Color = "1 1 1 0.6" }
            }, LayerInfo, LayerInfo + ".CL");

			CuiHelper.AddUi(player, container);
        }

        public const string MenuLayer = "XMenu";
        public const string MenuItemsLayer = "XMenu.MenuItems";
        public const string MenuSubItemsLayer = "XMenu.MenuSubItems";
        public const string MenuContent = "XMenu.Content";

        private void RenderRpg(ulong userID, object[] objects)
        {
            CuiElementContainer Container = (CuiElementContainer)objects[0];
            bool FullRender = (bool)objects[1];
            string Name = (string)objects[2];
            int ID = (int)objects[3];
            int Page = (int)objects[4];

            UI_DrawResearch(BasePlayer.FindByID(userID), "", null, Container);
        }

        private static void UI_DrawResearch(BasePlayer player, string update = "", ConfigData.Skill skill = null, CuiElementContainer container = null)
        {
            PlayerInfo playerInfo = PlayerInfos[player.userID];

            if (container == null)
                container = new CuiElementContainer();

            if (update != null && string.IsNullOrEmpty(update))
            {
                CuiHelper.DestroyUi(player, MenuContent);

                container.Add(new CuiElement
                {
                    Name = MenuContent,
                    Parent = MenuLayer,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0 0 0 0",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-430 -230",
                            OffsetMax = "490 270"
                        },
                    }
                });

				container.Add(new CuiButton
				{
					RectTransform = { AnchorMin = "0.25 0.1", AnchorMax = "0.75 0.9" },
					Button = { FadeIn = 0.1f, Color = HexToRustFormat("#8E8E8E00") },
					Text = { Text = "" }
				}, MenuContent);
				
				container.Add(new CuiLabel
				{
					RectTransform = { AnchorMin = "0 0.88", AnchorMax = "0.25 0.95" },
					Text = { Text = $"<size=14><color=#ABFF01>[ ФЕРМЕР ]</color></size>", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", }
				}, MenuContent);
				
				container.Add(new CuiLabel
				{
					RectTransform = { AnchorMin = "0.75 0.88", AnchorMax = "1 0.95" },
					Text = { Text = $"<size=14><color=#ABDDFF>[ КИЛЛЕР ]</color></size>", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", }
				}, MenuContent);

				container.Add(new CuiLabel
				{
					RectTransform = { AnchorMin = "0.15 0.9", AnchorMax = "0.85 1" },
					Text = { Text = $"<size=30><b><color=#FFFFFFB3>"+ configData.OptionsBasic.Descript +"</color></b></size>", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FadeIn = 0.1f }
				}, MenuContent);

                // Logo
                container.Add(new CuiElement
                {
                    Parent = MenuContent,
                    Components =
                        {
                            new CuiRawImageComponent { Png = ins.UrlImagesLeft },
                            new CuiRectTransformComponent { AnchorMin = "0 0.1", AnchorMax = "0.25 0.9" },
                        }
                });
                container.Add(new CuiElement
                {
                    Parent = MenuContent,
                    Components =
                        {
                            new CuiRawImageComponent { Png = ins.UrlImagesRight },
                            new CuiRectTransformComponent { AnchorMin = "0.75 0.1", AnchorMax = "1 0.9" },
                        }
                });

                container.Add(new CuiButton
				{
					RectTransform = { AnchorMin = "0.25 0.30", AnchorMax = "0.75 0.70" },
					Button = { FadeIn = 0.1f, Color = HexToRustFormat("#8E8E8E2D") },
                    Text = {
						Text = $"<size=15><b>\nКОЛИЧЕСТВО ВАШИХ RPG ОЧКОВ - <size=24>[<color=#ABFF01> {Math.Floor(playerInfo.CurrentPoints).ToString("F0")} </color>]</size> шт.</b></size>\n"+
						          $"________________________________________________________________________________________________\n"+
						  $"Система прокачки навыков игрока (RPG), вы можете прокачать все предоставленные навыки, \n"+
						   $"благодаря которым развитие станет немного быстрее, интереснее и разнообразнее. \n"+
						    $"Улучшение навыков происходит за полученный опыт, который вы можете получить добывая ресурсы,\n"+
						     $"лутая бочки/ящики, убивая игроков, ботов, животных и за проведенное время играя на сервере. \n"+
						      $"Нажав на знак вопроса который есть на каждом из окон опыта вы получите \n"+
						       $"полное описание, так же информацию о прокачке и текущем вашем опыте. \n"+
							     $"Для того что бы закрыть окно с описанием опыта, нажмите на него, а для \n"+
								   $"закрытия меню прокачки нажмите на любое свободное место. \n"+
						     $"\n\n<color=#ABFF01>Вайп навыков происходит при глобальном вайпе. (Просмотреть календарь - /wipe)</color>",
					    Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 11, FadeIn = 0.1f }
				}, MenuContent);



                var skillHeight = 80f;
                var skillMargin = 20;
                 
				var currentList = configData.SkillList.Where(p => p.Value.IsSkill);
                float minPosition = 0 - currentList.Count() / 2 * skillHeight - (currentList.Count() - 1) / 2 * skillMargin;

                foreach (var check in currentList)
                {
                    var image = ins.m_FileManager.GetPng(check.Key);
                    if (!string.IsNullOrEmpty(image))

					// картинки в рамках
					container.Add(new CuiElement
                    {
						Name = MenuContent + $".{check.Key}", Parent = MenuContent,
						Components =
						{
							new CuiRawImageComponent { Png = image },
							new CuiRectTransformComponent { AnchorMin = "0.4555 0.83", AnchorMax = "0.4555 0.83", OffsetMin = $"{minPosition} -{skillHeight / 2}", OffsetMax = $"{minPosition + skillHeight} {skillHeight / 2}" }
						}
					});
					// Окна
                    container.Add(new CuiButton
                    {
                        RectTransform =
						{
							AnchorMin = "0.4555 0.83", AnchorMax = "0.4555 0.83",
							OffsetMin = $"{minPosition} -{skillHeight / 2}", OffsetMax = $"{minPosition + skillHeight} {skillHeight / 2}"
						},
                        Button = { FadeIn = 0.1f, Color = HexToRustFormat("#8E8E8E2D"), Command = $"GUI_SystemRPG description {check.Key}" },
                        Text = { Text = "" }
                    }, MenuContent, MenuContent + $".{check.Key}");

					// Текст в кнопках
                    container.Add(new CuiLabel
					{
						RectTransform = { AnchorMin = "0 0.8", AnchorMax = "1 1.006667", OffsetMax = "0 0" },
						Text = { FadeIn = 0.1f, Text = $"Уровень - [<b><size=12><color=#ABFF01> {playerInfo.SkillsInfo.Skills[check.Key].ToString()} </color></size></b>]", Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.MiddleCenter }
					}, MenuContent + $".{check.Key}", MenuContent + $".{check.Key}.Level");  
					container.Add(new CuiLabel
					{
						RectTransform = { AnchorMin = "0 0.110", AnchorMax = "1 1.0", OffsetMax = "0 0" },
						Text = { Text = "?", FontSize = 35, Align = TextAnchor.MiddleCenter, Color = HexToRustFormat("#FFFFFF80") }
					}, MenuContent + $".{check.Key}");

					// Текст названий окон
                    container.Add(new CuiLabel
					{
						RectTransform = { AnchorMin = "0 0.05334239", AnchorMax = "1 0.3600006", OffsetMax = "0 0" },
						Text = { FadeIn = 0.1f, Text = "<b>" + check.Value.DisplayName.ToUpper() + "</b>", Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.MiddleCenter }
					}, MenuContent + $".{check.Key}");

                    string text = "<size=13><b>ПОДНЯТЬ</b></size>";
					string colorText = "#CFE0D3FF";
					string btnText = "#719A46FF";

                    if (playerInfo.SkillsInfo.Skills[check.Key] + 1 >= check.Value.Increase.Count)
					{
						text = "<size=13><b>УЛУЧШЕНО</b></size>"; colorText = "#CFCFE0FF"; btnText = "#6B5252FF";
					}
					else
						if (playerInfo.CurrentPoints < 1)
						{
							text = "<size=13><b>НЕХВАТАЕТ</b></size>"; colorText = "#E0CFCFFF"; btnText = "#6A5151FF";
						}

					// Текст увеличить уровень
                    container.Add(new CuiButton
					{
						RectTransform = { AnchorMin = "0 -0.226", AnchorMax = "1 -0.0133", OffsetMax = "0 0" },
						Button = { FadeIn = 0.1f, Color = HexToRustFormat(btnText), Command = $"GUI_SystemRPG increase {check.Key}" },
						Text = { FadeIn = 0.1f, Text = text, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", Color = HexToRustFormat(colorText) }
					}, MenuContent + $".{check.Key}");
                    minPosition += skillHeight; minPosition += skillMargin;
                }

                currentList = configData.SkillList.Where(p => !p.Value.IsSkill);
                minPosition = 0 - currentList.Count() / 2 * skillHeight - (currentList.Count() - 1) / 2 * skillMargin;

                foreach (var check in currentList)
                {
                    var image = ins.m_FileManager.GetPng(check.Key);
                    if (!string.IsNullOrEmpty(image))

					// картинки окон нижних
					container.Add(new CuiElement
					{
						Name = MenuContent + $".{check.Key}", Parent = MenuContent,
						Components =
						{
							new CuiRawImageComponent { Png = image },
							new CuiRectTransformComponent { AnchorMin = "0.4555 0.21", AnchorMax = "0.4555 0.21", OffsetMin = $"{minPosition} -{skillHeight / 2}", OffsetMax = $"{minPosition + skillHeight} {skillHeight / 2}" }
						}
					});

					// окна нижние
                    container.Add(new CuiButton
					{
						RectTransform = { AnchorMin = "0.4555 0.21", AnchorMax = "0.4555 0.21", OffsetMin = $"{minPosition} -{skillHeight / 2}", OffsetMax = $"{minPosition + skillHeight} {skillHeight / 2}" },
						Button = { FadeIn = 0.1f, Color = HexToRustFormat("#8E8E8E2D"), Command = $"GUI_SystemRPG description {check.Key}" },
						Text = { Text = "" }
					}, MenuContent, MenuContent + $".{check.Key}");

					// текст в нижних кнопок
                    container.Add(new CuiLabel
					{
						RectTransform = { AnchorMin = "0 0.8", AnchorMax = "1 1.006667", OffsetMax = "0 0" },
						Text = { FadeIn = 0.1f, Text = $"Уровень - [<b><size=12><color=#ABFF01> {playerInfo.SkillsInfo.Skills[check.Key].ToString()} </color></size></b>]", Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.MiddleCenter }
					}, MenuContent + $".{check.Key}", MenuContent + $".{check.Key}.Level");
					container.Add(new CuiLabel
					{
						RectTransform = { AnchorMin = "0 0.110", AnchorMax = "1 1.0", OffsetMax = "0 0" },
						Text = { Text = "?", FontSize = 35, Align = TextAnchor.MiddleCenter, Color = HexToRustFormat("#FFFFFF80") }
					}, MenuContent + $".{check.Key}");

					// текст названий нижних окон
                    container.Add(new CuiLabel
					{
						RectTransform = { AnchorMin = "0 0.05334239", AnchorMax = "1 0.3600006", OffsetMax = "0 0" },
						Text = { FadeIn = 0.1f, Text = "<b>" + check.Value.DisplayName.ToUpper() + "</b>", Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.MiddleCenter }
					}, MenuContent + $".{check.Key}");

                    string text = "<size=13><b>ПОДНЯТЬ</b></size>";
					string colorText = "#CFE0D3FF";
					string btnText = "#719A46FF";

                    if (playerInfo.SkillsInfo.Skills[check.Key] + 1 >= check.Value.Increase.Count)
					{
						text = "<size=13><b>УЛУЧШЕНО</b></size>"; colorText = "#CFCFE0FF"; btnText = "#6B5252FF";
					}
                    else
						if (playerInfo.CurrentPoints < 1)
						{
							text = "<size=13><b>НЕХВАТАЕТ</b></size>"; colorText = "#E0CFCFFF"; btnText = "#6A5151FF";
						}

					// Нижние кнопки увилечения уровня
                    container.Add(new CuiButton
					{
						RectTransform = { AnchorMin = "0 -0.226", AnchorMax = "1 -0.0133", OffsetMax = "0 0" },
						Button = { FadeIn = 0.1f, Color = HexToRustFormat(btnText), Command = $"GUI_SystemRPG increase {check.Key}" },
						Text = { FadeIn = 0.1f, Text = text, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", Color = HexToRustFormat(colorText) }
					}, MenuContent + $".{check.Key}");
                    minPosition += skillHeight; minPosition += skillMargin;
                }
            }

            if (!string.IsNullOrEmpty(update))
            {
                if (!update.Contains("ERROR") && !update.Contains("UPER"))
                {
                    CuiHelper.DestroyUi(player, MenuContent + $".{update}.Level");

                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0 0.8", AnchorMax = "1 1.006667", OffsetMax = "0 0" },
                        Text =
						{
							FadeIn = 0.1f,
							Text = $"[<b>Уровень - <size=12><color=#ABFF01> {playerInfo.SkillsInfo.Skills[update].ToString()} </color></size></b>]",
							Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.MiddleCenter
						}
                    }, MenuContent + $".{update}", MenuContent + $".{update}.Level");
					container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0 0.110", AnchorMax = "1 1.0", OffsetMax = "0 0" },
                        Text = { Text = "?", FontSize = 35, Align = TextAnchor.MiddleCenter, Color = HexToRustFormat("#FFFFFF80") }
                    }, MenuContent + $".{update}");
                    UI_DrawCurrentInfo(player);
                }
				else
					if (update.Contains("ERROR"))
                    {
                        CuiHelper.DestroyUi(player, MenuContent + $".{update}.Level");
				    
                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = "0 -0.226", AnchorMax = "1 -0.0133", OffsetMax = "0 0" },
                            Button = { FadeIn = 0.1f, Color = HexToRustFormat("#6A5151FF"), Command = $"GUI_SystemRPG increase {update.Replace("ERROR", "")}" },
                            Text = { FadeIn = 0.1f, Text = "<size=13><b>НЕХВАТАЕТ</b></size>", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", Color = HexToRustFormat("#E0CFCFFF") }
                        }, MenuContent + $".{update.Replace("ERROR", "")}", MenuContent + $".{update.Replace("ERROR", "")}.Upgrade");
                    }
                // обновление максимального окна
				else
					if (update.Contains("UPER"))
                    {
                        CuiHelper.DestroyUi(player, MenuContent + $".{update}.Level");
				    
                        container.Add(new CuiButton
                        {
				    		RectTransform = { AnchorMin = "0 -0.226", AnchorMax = "1 -0.0133", OffsetMax = "0 0" },
				    		Button = { FadeIn = 0.1f, Color = HexToRustFormat("#6B5252FF"), Command = $"GUI_SystemRPG increase {update.Replace("UPER", "")}" },
                            Text = { FadeIn = 0.1f, Text = "<size=13><b>УЛУЧШЕНО</b></size>", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", Color = HexToRustFormat("#CFCFE0FF") }
                        }, MenuContent + $".{update.Replace("UPER", "")}", MenuContent + $".{update.Replace("UPER", "")}.Upgrade");
                    }
                CuiHelper.AddUi(player, container);
            }

            if (skill != null)
            {
                CuiHelper.DestroyUi(player, MenuContent + ".Description");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.25 0.30", AnchorMax = "0.75 0.70" },
                    Button = { FadeIn = 0.1f, Color = "0.29 0.29 0.27 0.95", Material = "assets/content/ui/uibackgroundblur.mat", Close = MenuContent + ".Description" },
					Text =
					{
						FadeIn = 0.1f,
						Text = skill.Description,
						Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 12
					}
                }, MenuContent, MenuContent + ".Description");
				container.Add(new CuiLabel
				{
					RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.3" },
					Text = { FadeIn = 1f, Text = $"--------------------------\nВаш текущий уровень: <color=#AAF415><b>{playerInfo.SkillsInfo.Skills[skill.DisplayName]}</b></color>"+ $"\nВаш текущий рейт способности: <color=#AAF415>"+ $"<b>{(skill.DisplayName != "ВАМПИРИЗМ" ? playerInfo.SkillsInfo.GetCurrentIncrease(skill.DisplayName) : playerInfo.SkillsInfo.GetCurrentIncrease(skill.DisplayName))}</b></color>", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 12 }
				}, MenuContent + ".Description");
                CuiHelper.AddUi(player, container);
            }
            UI_DrawCurrentInfo(player);
        }

     #endregion
     #region Commands

        [ConsoleCommand("system.points")]
        private void CmdAdminHandler(ConsoleSystem.Arg args)
        {
            if (args.Player() != null || !args.HasArgs(2))
                return;

            ulong targetID;
            int amount;
            if (ulong.TryParse(args.Args[0], out targetID))
            {
                BasePlayer target = BasePlayer.FindByID(targetID);
                if (int.TryParse(args.Args[1], out amount))
                {
                    if (PlayerInfos.ContainsKey(targetID))
                    {
                        PlayerInfos[targetID].AddPoints(target, amount);
                        PrintWarning($"Successful added {amount} to {targetID}");

                        if (target != null && target.IsConnected)
                            target.ChatMessage($"Вы получили {amount} очков, вы можете потратить их в меню!");
                    }
                }
            }
        }

        [ChatCommand("rpg")]
        private void CmdChatCommand(BasePlayer player, string command, string[] args)
        {
            player.SendConsoleCommand("GUI_SystemRPG open");
        }

        [ConsoleCommand("GUI_SystemRPG")]
        private void CmdConsoleHandler(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (player != null && args.HasArgs(1))
            {
                switch (args.Args[0].ToLower())
                {
                    case "increase":
                    {
                        if (args.HasArgs(2) && configData.SkillList.ContainsKey(args.Args[1]))
                        {
                            PlayerInfos[player.userID].AddLevel(player, args.Args[1]);
                        }
                        break;
                    }
                    case "open":
                    {
                        UI_DrawResearch(player);
                        break;
                    }
                    case "description":
                    {
                        if (args.HasArgs(2))
                        {
                            string codeName = args.Args[1];
                            if (configData.SkillList.ContainsKey(codeName))
                            {
                                UI_DrawResearch(player, null, configData.SkillList[codeName]);
                                return;
                            }
                        }

                        break;
                    }
                }
            }
        }

     #endregion
     #region Utils       

        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');
            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            UnityEngine.Color color = new Color32(r, g, b, a);
            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }

     #endregion
     #region LoadImages

		bool init;
        private GameObject FileManagerObject;
        private FileManager m_FileManager;
        private string UrlImagesLeft;
        private string UrlImagesRight;

		IEnumerator LoadImages()
        {
            if (!string.IsNullOrEmpty(configData.OptionsBasic.UrlImgLeft))
            {
                UrlImagesLeft = configData.OptionsBasic.UrlImgLeft;
                yield return m_FileManager.StartCoroutine(m_FileManager.LoadFile(UrlImagesLeft, UrlImagesLeft));
                UrlImagesLeft = m_FileManager.GetPng(UrlImagesLeft);
            }
			//else
            //{
            //    UrlImagesLeft = "https://imgur.com/BdDbsOW.png";
            //    yield return m_FileManager.StartCoroutine(m_FileManager.LoadFile(UrlImagesLeft, UrlImagesLeft));
            //    UrlImagesLeft = m_FileManager.GetPng(UrlImagesLeft);
            //}

			if (!string.IsNullOrEmpty(configData.OptionsBasic.UrlImgRight))
            {
                UrlImagesRight = configData.OptionsBasic.UrlImgRight;
                yield return m_FileManager.StartCoroutine(m_FileManager.LoadFile(UrlImagesRight, UrlImagesRight));
                UrlImagesRight = m_FileManager.GetPng(UrlImagesRight);
            }
			//else
            //{
            //    UrlImagesRight = "https://imgur.com/PsopjNT.png";
            //    yield return m_FileManager.StartCoroutine(m_FileManager.LoadFile(UrlImagesRight, UrlImagesRight));
            //    UrlImagesRight = m_FileManager.GetPng(UrlImagesRight);
            //}
        }

        void InitFileManager()
        {
            FileManagerObject = new GameObject("FileManagerObject");
            m_FileManager = FileManagerObject.AddComponent<FileManager>();
        }

        class FileManager : MonoBehaviour
        {
            int loaded = 0;
            int needed = 0;
            public bool IsFinished => needed == loaded;
            const ulong MaxActiveLoads = 10;
            Dictionary<string, FileInfo> files = new Dictionary<string, FileInfo>();

            private class FileInfo
            {
                public string Url;
                public string Png;
            }

            public string GetPng(string name)
            {
                if (files.ContainsKey(name))
                    return files[name].Png;
                return null;
            }

            public IEnumerator LoadFile(string name, string url, int size = -1)
            {
                if (files.ContainsKey(name) && files[name].Url == url && !string.IsNullOrEmpty(files[name].Png)) yield break;
                files[name] = new FileInfo() { Url = url };
                needed++;
                yield return StartCoroutine(LoadImageCoroutine(name, url, size));
            }
            IEnumerator LoadImageCoroutine(string name, string url, int size = -1)
            {
                using (WWW www = new WWW(url))
                {
                    yield return www;
                    if (string.IsNullOrEmpty(www.error))
                    {
                        var bytes = size == -1 ? www.bytes : Resize(www.bytes, size);
                        var entityId = CommunityEntity.ServerInstance.net.ID;
                        var crc32 = FileStorage.server.Store(bytes, FileStorage.Type.png, entityId).ToString();
                        files[name].Png = crc32;
                    }

                }
                loaded++;
                ins.init = true;
            }
            static byte[] Resize(byte[] bytes, int size)
            {
                Image img = (Bitmap)(new ImageConverter().ConvertFrom(bytes));
                Bitmap cutPiece = new Bitmap(size, size);
                System.Drawing.Graphics graphic = System.Drawing.Graphics.FromImage(cutPiece);
                graphic.DrawImage(img, new Rectangle(0, 0, size, size), 0, 0, img.Width, img.Height, GraphicsUnit.Pixel);
                graphic.Dispose();
                MemoryStream ms = new MemoryStream();
                cutPiece.Save(ms, ImageFormat.Jpeg);
                return ms.ToArray();
            }
        }
     #endregion
    }
}

// --- End of file: SystemRPG.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/ChatEvent.cs ---
// --- Original Local Path: TrashRust/ChatEvent.cs ---

using UnityEngine;
using System;
using Oxide.Core;
using Newtonsoft.Json;
using ConVar;
namespace Oxide.Plugins
{
    [Info("ChatEvent", "", "1.0.12")]
    class ChatEvent : RustPlugin
    {
		string answer, mp;
		bool active, ovh = false;

		object OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel)
        {
            if (active && message.ToLower().Equals(answer.ToLower()) && player != null)
            {
                PrintToChat($"Первым правильно ответил игрок <color=#{_conf.Settings.msgcolor}>{player.displayName}</color>\nПравильный ответ: <color=#{_conf.Settings.msgcolor}>{answer}</color>\nНаграда: <color=#{_conf.Settings.msgcolor}>3 RUB</color>");
				active = false;
				if (!plugins.Find("RustStore") && !plugins.Find("GameStoresRUST"))
				{
					PrintError("Не найден плагин магазина, выдаём предмет");
					Item item = ItemManager.CreateByName(_conf.Settings.itemshortname, _conf.Settings.itemcount);
					if (item == null)
					{
						PrintError("item == null");
						return null;
					}
					Interface.Oxide.LogDebug($"Игрок {player.displayName} ({player.userID}) получил {_conf.Settings.prize} x {_conf.Settings.itemcount.ToString()}");
					SendReply(player, $"Ошибка зачисления в магазин!\nВы получили <color=#{_conf.Settings.msgcolor}>{item.amount}</color> x <color=#{_conf.Settings.msgcolor}>{item.info.displayName.english}</color>");
					player.GiveItem(item);
					return null;
				}
				if (ovh)
				{
					plugins.Find("RustStore").CallHook("APIChangeUserBalance", player.userID, _conf.Settings.prize, new Action<string>((result) =>
					{
						if (result == "SUCCESS")
						{
							Interface.Oxide.LogDebug($"Игрок {player.displayName} ({player.userID}) получил {_conf.Settings.prize} RUB за верный ответ");
							SendReply(player, $"<color=#{_conf.Settings.msgcolor}>{_conf.Settings.prize} RUB</color> успешно зачислены на Ваш баланс!");
							return;
						}
						if (result != "SUCCESS")
						{
							Item item = ItemManager.CreateByName(_conf.Settings.itemshortname, _conf.Settings.itemcount);
							if (item == null)
							{
								PrintError("item == null");
								return;
							}
							Interface.Oxide.LogDebug($"Игрок {player.displayName} ({player.userID}) получил {_conf.Settings.prize} x {_conf.Settings.itemcount.ToString()}");
							SendReply(player, $"Ошибка зачисления в магазин!\nВы получили <color=#{_conf.Settings.msgcolor}>{item.amount}</color> x <color=#{_conf.Settings.msgcolor}>{item.info.displayName.english}</color>");
							player.GiveItem(item);
						}
					}));
				}
				else
				{
					webrequest.EnqueueGet($"https://gamestores.ru/api/?shop_id={_conf.Settings.shopid}&secret={_conf.Settings.secretkey}&action=moneys&type=plus&steam_id={player.userID}&amount={_conf.Settings.prize}", (otvet, err) =>
					{
						if (otvet == 200)
						{
							Interface.Oxide.LogDebug($"Игрок {player.displayName} ({player.userID}) получил {_conf.Settings.prize} RUB за верный ответ");
							SendReply(player, $"<color=#{_conf.Settings.msgcolor}>{_conf.Settings.prize} RUB</color> успешно зачислены на Ваш баланс!");
							return;
						}
						if (otvet != 200)
						{
							Item item = ItemManager.CreateByName(_conf.Settings.itemshortname, _conf.Settings.itemcount);
							if (item == null)
							{
								PrintError("item == null");
								return;
							}
							Interface.Oxide.LogDebug($"Игрок {player.displayName} ({player.userID}) получил {_conf.Settings.prize} x {_conf.Settings.itemcount.ToString()}");
							SendReply(player, $"Ошибка зачисления в магазин!\nВы получили <color=#{_conf.Settings.msgcolor}>{item.amount}</color> x <color=#{_conf.Settings.msgcolor}>{item.info.displayName.english}</color>");
							player.GiveItem(item);
						}
					}, this);
				}
            }
            return null;
        }
		
		[ChatCommand("sev")]
		void CmdStartEv(BasePlayer player)
		{
			if (!player.IsAdmin) return;
			StartEvent();
		}
void StartEvent()
		{
			if (active)
			{
				PrintToChat($"Ивент <color=#{_conf.Settings.msgcolor}>{mp}</color> был завершён, никто не успел дать правильный ответ{(mp == "Быстрописание" ? "" : " ("+answer.ToLower()+")")}");
			}
			active = true;
			var type = UnityEngine.Random.Range(1, 3);
			var ans = string.Empty;
			switch (type)
			{
				case 1: 
				{
					mp = "Быстрописание";
					answer = words.GetRandom();
					ans = answer;
					break;
				}
				case 2: 
				{
					mp = "Математика";
					switch (UnityEngine.Random.Range(1, 3))
					{
						case 1: 
						{
							var a = UnityEngine.Random.Range(1500, 9999);
							var b = UnityEngine.Random.Range(100, 9999);
							ans = $"{a} + {b}";
							answer = (a+b).ToString();
							break;
						}
						case 2: 
						{
							var a = UnityEngine.Random.Range(2, 12);
							var b = UnityEngine.Random.Range(4, 15);
							ans = $"{a} * {b}";
							answer = (a*b).ToString();
							break;
						}
					}
					break;
				}
				default: return;
			}
			
			PrintToChat($"Начался ивент <color=#{_conf.Settings.msgcolor}>{mp}</color>, {(type == 1 ? "слово" : "выражение")}: <color=#{_conf.Settings.msgcolor}>{ans}</color>");
		}		
		private void OnServerInitialized()
        {	
			if (plugins.Find("RustStore"))
			{
				ovh = true;
				PrintWarning("Плагин загружен. Работаем с магазином Moscow.OVH");
			}
			else if (plugins.Find("GameStoresRUST"))
			{
				ovh = false;
				PrintWarning("Плагин загружен. Работаем с магазином GameStores");
				if (_conf.Settings.shopid == "666666" || _conf.Settings.secretkey == "j8q5c5c1043se4w9uedp82c3x7eeudnu")
				{
					PrintError("Укажите верный номер магазина и секретный ключ в конфиг-файле");
					Interface.Oxide.UnloadPlugin(Title);
					return;
				}
			}
			else
			{
				PrintError("Не найден плагин магазина (Moscow.OVH/GameStores)");
				Interface.Oxide.UnloadPlugin(Title);
				return;
			}
				
            timer.Every(_conf.Settings.timer*60, StartEvent);
        }
		
		private _Conf _conf; 
		
        class _Conf
        {          
            [JsonProperty(PropertyName = "Настройки")]
            public Options Settings { get; set; }
			
            public class Options
            {
                [JsonProperty(PropertyName = "Сколько рублей выдавать игроку на баланс магазина за правильный ответ")]
                public int prize { get; set; }
				[JsonProperty(PropertyName = "Раз во сколько минут запускать ивент (60 = каждый час)")]
                public int timer { get; set; }
				[JsonProperty(PropertyName = "Цвет сообщений")]
                public string msgcolor { get; set; }
				[JsonProperty(PropertyName = "Какой выдать item, если не получилось выдать деньги")]
                public string itemshortname { get; set; }
				[JsonProperty(PropertyName = "Количество выдаваемого")]
                public int itemcount { get; set; }
                [JsonProperty(PropertyName = "Номер магазина GameStores (если другой магазин - не менять)")]
                public string shopid { get; set; }
                [JsonProperty(PropertyName = "Секретный ключ GameStores (если другой магазин - не менять)")]
                public string secretkey { get; set; }
            }
        }
		
        protected override void LoadConfig()
        {
            base.LoadConfig();
            _conf = Config.ReadObject<_Conf>();

            Config.WriteObject(_conf, true);
        }

        protected override void LoadDefaultConfig()
		{
			_conf = SetDefaultConfig();
			PrintWarning("Создаём конфиг-файл...");
		}

        private _Conf SetDefaultConfig()
        {
            return new _Conf
            {
                Settings = new _Conf.Options
                {
                    prize = 5,
					timer = 60,
					msgcolor = "ffd700",
					itemshortname = "sulfur",
					itemcount = 5000,
                    shopid = "66666",
                    secretkey = "j8q5c5c1043se4w9uedp82c3x7eeudnu"
                }              
            };
        }

        protected override void SaveConfig() => Config.WriteObject(_conf, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Updating config file...");

            _Conf baseConfig = SetDefaultConfig();
        }
		
		string[] words =
        {
            "Физиолог", 
			"Эффективность", 
			"Распространитель", 
			"Вакуумметр", 
			"Общезначимость", 
			"Навигатор", 
			"Расположение", 
			"Выслушивание", 
			"Кибернетизация", 
			"Триод", 
			"Аритмия", 
			"Социалист", 
			"Неупорядоченность", 
			"Орлянка", 
			"Примосток", 
			"Набивщик", 
			"Белозор", 
			"Пуло", 
			"Малица", 
			"Крюйт-Камера", 
			"Мерзлотовед", 
			"Трезвенник", 
			"Кипятильня", 
			"Вакуумирование", 
			"Прапрадедушка", 
			"Псалмодия", 
			"Рассмотрение", 
			"Остранение", 
			"Гипотермия", 
			"Иеродьяконство", 
			"Неосновательность", 
			"Жостер", 
			"Перемотчица", 
			"Неподготовленность", 
			"Направляющая", 
			"Перекупщик", 
			"Батыр", 
			"Пелена", 
			"Хуление", 
			"Исполнительница", 
			"Гидропресс", 
			"Самописец", 
			"Ижица", 
			"Приехавший", 
			"Кингстон", 
			"Шквара", 
			"Времяисчисление", 
			"Щипальщица", 
			"Шкаф", 
			"Заверение", 
			"Теплотворность", 
			"Мартинизм", 
			"Филогенезис", 
			"Сортосмена", 
			"Льнокомбайн", 
			"Появление", 
			"Ориентировка", 
			"Палеоген", 
			"Родословная", 
			"Корригирование", 
			"Присучальщик", 
			"Накладка", 
			"Патриаршество", 
			"Духоборство", 
			"Сифонофора", 
			"Ручница", 
			"Халиф", 
			"Раздвоенность", 
			"Тщательность", 
			"Угадыватель", 
			"Монотонность", 
			"Парасанга", 
			"Рейхстаг", 
			"Вспахивание", 
			"Маловыгодность", 
			"Разминовка", 
			"Живица", 
			"Баркас", 
			"Культя", 
			"Анестезин", 
			"Игривость", 
			"Оценка", 
			"Квинтильон", 
			"Формальдегид", 
			"Арбуз", 
			"Перегнаивание", 
			"Препятствие", 
			"Силач", 
			"Скиния", 
			"Ветродвигатель", 
			"Прибивка", 
			"Компилятивность", 
			"Разрисовщик", 
			"Колика", 
			"Злонамеренность", 
			"Фокусирование", 
			"Кинематографист", 
			"Кроликоматка", 
			"Крепостничество", 
			"Недуг", 
			"Рябоватость", 
			"Пиретрум", 
			"Экзогамия", 
			"Изнурение", 
			"Псевдоромантик", 
			"Подгрузка", 
			"Миксер", 
			"Доение", 
			"Томпак", 
			"Второгодничество", 
			"Малаец", 
			"Деятель", 
			"Урчание", 
			"Фотохроника", 
			"Полумысль", 
			"Расчленённость", 
			"Любительство", 
			"Душистость", 
			"Выпадение", 
			"Полубог", 
			"Коксование", 
			"Канонир", 
			"Передавливание", 
			"Подменивание", 
			"Мост", 
			"Пемза", 
			"Донг", 
			"Краснолесье", 
			"Прокатка", 
			"Крематорий", 
			"Сифилис", 
			"Кардан", 
			"Адъютантская", 
			"Кринка", 
			"Мануфактур-Советник", 
			"Медитация", 
			"Семявход", 
			"Сталагмит", 
			"Рисунок", 
			"Спидвей", 
			"Подспорье", 
			"Приближённая", 
			"Выработанность", 
			"Бордюр", 
			"Шарлах", 
			"Протеид", 
			"Ланка", 
			"Отсортировка", 
			"Экзистенциалистка", 
			"Шихта", 
			"Осолаживание", 
			"Обжалование", 
			"Тенденциозность", 
			"Закусочная", 
			"Авиастроение", 
			"Медалистка", 
			"Баррикада", 
			"Заступничество", 
			"Конферанс", 
			"Луговодство", 
			"Прошивальщик", 
			"Бивак", 
			"Недоедание", 
			"Гастролёр", 
			"Сейсмография", 
			"Барибал", 
			"Фабрикатор", 
			"Вертлявость", 
			"Краниометрия", 
			"Монохорд", 
			"Быстрота", 
			"Антивитамин", 
			"Сердцевидка", 
			"Вуалехвост", 
			"Обрезок", 
			"Замешательство", 
			"Иглодержатель", 
			"Колет", 
			"Ловкость", 
			"Фидель", 
			"Сирость", 
			"Мощь", 
			"Смятенность", 
			"Сливкоотделитель", 
			"Рябая", 
			"Расформирование", 
			"Заикание", 
			"Наколачивание", 
			"Шумовка", 
			"Деловитость", 
			"Нелюбовь", 
			"Лазурит", 
			"Дубление", 
			"Зраза", 
			"Малоформист", 
			"Индивидуалист", 
			"Отточка", 
			"Пантовар", 
			"Космонавт", 
			"Биссектриса", 
			"Воровство", 
			"Воздевание", 
			"Клей", 
			"Центровщица", 
			"Вздувание", 
			"Поздравительница", 
			"Взлом", 
			"Чертовка", 
			"Отрастание", 
			"Гастролёрство", 
			"Наукоподобность", 
			"Грузовик", 
			"Плотоспуск", 
			"Консистенция", 
			"Оснастка", 
			"Потравщик", 
			"Отчаливание", 
			"Миопия", 
			"Меломан", 
			"Рассрочивание", 
			"Сонность", 
			"Буртоукладчик", 
			"Кордовой", 
			"Понимание", 
			"Выведывание", 
			"Муст", 
			"Старшекурсник", 
			"Мальтиец", 
			"Теобромин", 
			"Отметина", 
			"Нейрит", 
			"Обконопачивание", 
			"Медеплавильщик", 
			"Прогребание", 
			"Трипаносома", 
			"Ивняк", 
			"Бруствер", 
			"Подзол", 
			"Темпограф", 
			"Гипертермия", 
			"Выдача", 
			"Курчатовий", 
			"Сбруйник", 
			"Бром", 
			"Семибоярщина", 
			"Мушкетон", 
			"Отщепление", 
			"Замолачивание", 
			"Выбуравливание", 
			"Сатинировка", 
			"Кайман", 
			"Перезимовка", 
			"Хитон", 
			"Регистрация", 
			"Сокрушитель", 
			"Монополия", 
			"Подлавочье", 
			"Разрезание", 
			"Умоисступление", 
			"Аксакал", 
			"Педфак", 
			"Размолка", 
			"Футуристка", 
			"Связанность", 
			"Сенотаска", 
			"Артиллерист", 
			"Нумизматика", 
			"Потолочина", 
			"Найтов", 
			"Запонь", 
			"Фальшфейерник", 
			"Прикручивание", 
			"Лыжня", 
			"Неудобоваримость", 
			"Нормативность", 
			"Катион", 
			"Скаутинг", 
			"Обшивание", 
			"Несгибаемость", 
			"Аккордеон", 
			"Неутешительность", 
			"Финикийка", 
			"Спурт", 
			"Эпигонство", 
			"Пельвеция", 
			"Миниатюристка", 
			"Бляха", 
			"Ванна", 
			"Порфирит", 
			"Искуситель", 
			"Неусыпность", 
			"Дифирамб", 
			"Уклон", 
			"Яд", 
			"Сладострастница", 
			"Ехидность", 
			"Агул", 
			"Ванилин", 
			"Отступничество", 
			"Невыезд", 
			"Оттенение", 
			"Лорд-Мэр", 
			"Отфильтровывание", 
			"Обсаживание", 
			"Протезирование", 
			"Тета", 
			"Девушка", 
			"Присевание", 
			"Промышленность", 
			"Фотолюминесценция", 
			"Страдалец", 
			"Разочарование", 
			"Матрац", 
			"Шанц", 
			"Отстой", 
			"Самозванство", 
			"Игрок", 
			"Кайла", 
			"Отслойка", 
			"Подрегент", 
			"Конституционализм", 
			"Арматурщик", 
			"Напучивание", 
			"Интервент", 
			"Архитрав", 
			"Укатывание", 
			"Старозаветность", 
			"Круча", 
			"Анамнез", 
			"Изуверка", 
			"Струна", 
			"Истощение", 
			"Отчество", 
			"Несуетливость", 
			"Тутоводство", 
			"Мрачность", 
			"Верноподданство", 
			"Поддвигание", 
			"Запиливание", 
			"Необходимое", 
			"Лангуста", 
			"Неугомонность", 
			"Многолюдность", 
			"Отрешённость", 
			"Откопка", 
			"Сыноубийство", 
			"Подпор", 
			"Сочевичник", 
			"Разрабатывание", 
			"Несовременность", 
			"Дерзостность", 
			"Празем", 
			"Своенравие", 
			"Нагромождение", 
			"Болгарка", 
			"Фактограф", 
			"Каноничность", 
			"Семиборье", 
			"Брынза", 
			"Издание", 
			"Конверторник", 
			"Проварка", 
			"Диетолог", 
			"Ноктюрн", 
			"Чистосердечие", 
			"Призванный", 
			"Кираса", 
			"Капрал", 
			"Подбалочник", 
			"Ранец", 
			"Серьёзное", 
			"Ледообразование", 
			"Рабовладение", 
			"Моторика", 
			"Колодезь", 
			"Диссертантка", 
			"Черенкование", 
			"Гомосексуализм", 
			"Кровать", 
			"Отметка", 
			"Опреснение", 
			"Тоннелестроение", 
			"Южноамериканец", 
			"Пища", 
			"Самоконтроль", 
			"Акация", 
			"Машинальность", 
			"Убор", 
			"Второкурсница", 
			"Анкерок", 
			"Бороздование", 
			"Дождливость", 
			"Очистка", 
			"Обезлесение", 
			"Тефлон", 
			"Точило", 
			"Парафразирование", 
			"Струнобетон", 
			"Казначей", 
			"Болото", 
			"Обтирка", 
			"Державность", 
			"Смолосеменник", 
			"Участница", 
			"Тройня", 
			"Лощило", 
			"Периптер", 
			"Тетрарх", 
			"Горбоносость", 
			"Чащоба", 
			"Металлопромышленность", 
			"Манчестерство", 
			"Доброжелатель", 
			"Концовка", 
			"Игольчатость", 
			"Солонина", 
			"Домогательство", 
			"Тремор", 
			"Укрывательство", 
			"Брандмауэр", 
			"Приглашение", 
			"Отстирывание", 
			"Измятость", 
			"Въездное", 
			"Электролиз", 
			"Щитоноска", 
			"Малахай", 
			"Штандарт", 
			"Переупаковывание", 
			"Недруг", 
			"Гидрометрия", 
			"Крапп", 
			"Циркулирование", 
			"Правдоподобие", 
			"Воспламенение", 
			"Осязаемость", 
			"Курсив", 
			"Капер", 
			"Высматривание", 
			"Отлучение", 
			"Рой", 
			"Колдовство", 
			"Запутанность", 
			"Водоочиститель", 
			"Акваланг", 
			"Переступание", 
			"Оружейник", 
			"Сенокос", 
			"Монархизм", 
			"Содрогание", 
			"Потенциал", 
			"Кондиционирование", 
			"Цивилизованность", 
			"Сопельщик", 
			"Ватерполистка", 
			"Цветистость", 
			"Послелог", 
			"Идеал", 
			"Непорядок", 
			"Мезентерий", 
			"Табурет", 
			"Кювет", 
			"Октаэдр", 
			"Кокаинист", 
			"Криз", 
			"Реяние", 
			"Семасиолог", 
			"Домащивание", 
			"Пифагореец", 
			"Башкирец", 
			"Некомплект", 
			"Пряжа", 
			"Пандемия", 
			"Чистопсовость", 
			"Аккредитив", 
			"Раскрадывание", 
			"Перештукатуривание", 
			"Единоборец", 
			"Рдест", 
			"Потворствование", 
			"Антабус", 
			"Таракан", 
			"Факультативность", 
			"Септиктанк", 
			"Поношение", 
			"Рафинирование", 
			"Чувячник", 
			"Командирование", 
			"Ломка", 
			"Иппология", 
			"Джентльменство", 
			"Радиация", 
			"Углежжение", 
			"Голбчик", 
			"Заступник", 
			"Разряжённость", 
			"Черкеска", 
			"Зелёнка", 
			"Пифос", 
			"Самовзрывание", 
			"Эколог", 
			"Нелюдим", 
			"Милосердие", 
			"Иммобильность", 
			"Местонахождение", 
			"Дактилология", 
			"Клиентела", 
			"Бурсак", 
			"Ген", 
			"Дериват", 
			"Выполировывание", 
			"Графомания", 
			"Неволя", 
			"Метод", 
			"Обеспеченность", 
			"Дриада", 
			"Интернационализация", 
			"Моток", 
			"Ретина", 
			"Тележечник", 
			"Проливание", 
			"Полевица", 
			"Нейропатия", 
			"Никонианец", 
			"Офтальмоскоп", 
			"Конногвардеец", 
			"Бердан", 
			"Сытность", 
			"Замусоривание", 
			"Утлегарь", 
			"Вельможность", 
			"Реборда", 
			"Оскрёбок", 
			"Неродовитость", 
			"Штык-Болт", 
			"Варежка", 
			"Генеалогия", 
			"Пасмурность", 
			"Электропильщик", 
			"Косач", 
			"Сахаризация", 
			"Догматика", 
			"Самооплодотворение", 
			"Выбойщик", 
			"Солильня", 
			"Шапка", 
			"Извилистость", 
			"Словник", 
			"Разброс", 
			"Дочь", 
			"Подлисок", 
			"Индиец", 
			"Магнитометр", 
			"Клешня", 
			"Интриган", 
			"Борщ", 
			"Красильщик", 
			"Вдовствование", 
			"Приёмка", 
			"Мерзлотность", 
			"Вкладыш", 
			"Ранетка", 
			"Платинотипия", 
			"Безуспешность", 
			"Мелизма", 
			"Поддувание", 
			"Изогнутость", 
			"Аттестат", 
			"Перевоспитание", 
			"Энотера", 
			"Сова", 
			"Слухач", 
			"Третирование", 
			"Тетрил", 
			"Импульсивность", 
			"Каракульча", 
			"Пустотность", 
			"Граттаж", 
			"Самоуглубление", 
			"Повой", 
			"Мундир", 
			"Черва", 
			"Шалунья", 
			"Иждивенец", 
			"Шагомер", 
			"Салфетка", 
			"Геологоразведчик", 
			"Сожжение", 
			"Стенание", 
			"Обременительность", 
			"Звуконоситель", 
			"Верблюжина", 
			"Подобострастность", 
			"Опубликование", 
			"Бездействие", 
			"Трудотерапия", 
			"Продух", 
			"Ослушание", 
			"Двойчатка", 
			"Занавеска", 
			"Отгнивание", 
			"Надувание", 
			"Вольнодумство", 
			"Заслуженность", 
			"Подшибание", 
			"Рефрактометр", 
			"Мутон", 
			"Одухотворение", 
			"Платинка", 
			"Хлеборез", 
			"Власть", 
			"Расистка", 
			"Банчок", 
			"Райграс", 
			"Евангелик", 
			"Наркомафия", 
			"Перекатчица", 
			"Миома", 
			"Сыпнотифозная", 
			"Сексуальность", 
			"Подбережник", 
			"Волкодав", 
			"Глухарёнок", 
			"Многопрограммность", 
			"Ульч", 
			"Новокаин", 
			"Рыболовство", 
			"Мания", 
			"Бог", 
			"Смолильщик", 
			"Капитанство", 
			"Цыплёнок", 
			"Сброд", 
			"Нансук", 
			"Живность", 
			"Перезимовывание", 
			"Вагоновожатый", 
			"Перепонка", 
			"Пульпопровод", 
			"Текстолит", 
			"Неотчуждаемость", 
			"Трисель", 
			"Нашест", 
			"Скептичность", 
			"Правозаступник", 
			"Регбист", 
			"Завалина", 
			"Наусник", 
			"Уретроскоп", 
			"Рядно", 
			"Анестезиология", 
			"Бессмертник", 
			"Плодоножка", 
			"Евангеличка", 
			"Разбойница", 
			"Полшага", 
			"Самостил", 
			"Вожжа", 
			"Отрывистость", 
			"Жестер", 
			"Вковывание", 
			"Расточитель", 
			"Командир", 
			"Обглядывание", 
			"Комингс", 
			"Дебильность", 
			"Лесоразработка", 
			"Анкета", 
			"Вторжение", 
			"Рудокоп", 
			"Пораженец", 
			"Плющильня", 
			"Гармонизация", 
			"Шнурование", 
			"Специальность", 
			"Самобытник", 
			"Загс", 
			"Полубогиня", 
			"Антропософия", 
			"Термоэлемент", 
			"Преемник", 
			"Купальник", 
			"Триба", 
			"Пемзовка", 
			"Техника", 
			"Искроуловитель", 
			"Замшелость", 
			"Смётывание", 
			"Трал", 
			"Полумрак", 
			"Узуальность", 
			"Шпиндель", 
			"Лигнин", 
			"Инкорпорирование", 
			"Пемзовщик", 
			"Угольщица", 
			"Бугор", 
			"Опытность", 
			"Поселение", 
			"Штилевание", 
			"Расклеивание", 
			"Адсорбция", 
			"Ясновидение", 
			"Плаз", 
			"Перевивка", 
			"Десикация", 
			"Картонаж", 
			"Дополучение", 
			"Филантроп", 
			"Конвоирование", 
			"Лодка", 
			"Шурпа", 
			"Веяльщик", 
			"Всовывание", 
			"Осанка", 
			"Интриганство", 
			"Троякость", 
			"Ясность", 
			"Гандболистка", 
			"Прусик", 
			"Родовспоможение", 
			"Лелеяние", 
			"Должник", 
			"Диалектика", 
			"Сакман", 
			"Хлопкоочистка", 
			"Бесприютность", 
			"Пейсик", 
			"Растягивание", 
			"Перекомплектование", 
			"Кронпринц", 
			"Обвязка", 
			"Револьверщик", 
			"Фидеист", 
			"Голяшка", 
			"Термофил", 
			"Подстожье", 
			"Недовыпуск", 
			"Выколотчик", 
			"Магнетизация", 
			"Типизирование", 
			"Сутолока", 
			"Электрокарщик", 
			"Кресс-Салат", 
			"Фабрика", 
			"Заглавие", 
			"Штыка", 
			"Беззастенчивость", 
			"Шенкель", 
			"Горилла", 
			"Жрец", 
			"Венгерское", 
			"Эсер", 
			"Акушерство", 
			"Шовинизм", 
			"Вабик", 
			"Авиаматка", 
			"Хамит", 
			"Окоченение", 
			"Приутюжка", 
			"Кармазин", 
			"Пигмейка", 
			"Речка", 
			"Нюхание", 
			"Нетрезвость", 
			"Бивень", 
			"Наган", 
			"Рогалик", 
			"Ирригация", 
			"Молян", 
			"Слоевище", 
			"Засмаливание", 
			"Пялка", 
			"Приборостроение", 
			"Охранник", 
			"Термидорианство", 
			"Парализатор", 
			"Мяльщик", 
			"Архивист", 
			"Землеустройство", 
			"Звукоуловитель", 
			"Промётка", 
			"Начернение", 
			"Старьё", 
			"Жонглёр", 
			"Насмешка", 
			"Черноокая", 
			"Разведка", 
			"Маштак", 
			"Крушина", 
			"Багорщик", 
			"Аполитичность", 
			"Гомология", 
			"Свидетель", 
			"Гальваностегия", 
			"Бейсболка", 
			"Ханжество", 
			"Перемазанец", 
			"Прогул", 
			"Продолжательница", 
			"Какофония", 
			"Растюковка", 
			"Имеретинка", 
			"Отоскоп", 
			"Развеивание", 
			"Самотёк", 
			"Демарш", 
			"Пародия", 
			"Протрёпывание", 
			"Змееборец", 
			"Шлакобетон", 
			"Перигей", 
			"Восприятие", 
			"Берег", 
			"Низкоурожайность", 
			"Прошедшее", 
			"Итальянизм", 
			"Хлебоуборка", 
			"Регулировка", 
			"Славословящий", 
			"Дар", 
			"Австерия", 
			"Блюститель", 
			"Прибрежница", 
			"Коммерция", 
			"Счётчица", 
			"Цитатничество", 
			"Перхоть", 
			"Азбучность", 
			"Наймодатель", 
			"Триера", 
			"Общепринятость", 
			"Дело", 
			"Вопросник", 
			"Ром", 
			"Дуновение", 
			"Гидромонитор", 
			"Бегония", 
			"Паремейник", 
			"Рукопись", 
			"Грязовик", 
			"Выползание", 
			"Данность", 
			"Стерлядь", 
			"Бродильня", 
			"Приукрашение", 
			"Скепсис", 
			"Крючник", 
			"Старпом", 
			"Шелест", 
			"Завёрстка", 
			"Порожистость", 
			"Прорезка", 
			"Нищание", 
			"Водогрязелечебница", 
			"Позиционность", 
			"Несовершенство", 
			"Выразитель", 
			"Шампанист", 
			"Рыбоводство", 
			"Безгласность", 
			"Грузоподъёмность", 
			"Гридень", 
			"Циперус", 
			"Фасад", 
			"Стакан", 
			"Радиоэлектроника", 
			"Экзекватура", 
			"Доверительность", 
			"Экстракция", 
			"Конфирмация", 
			"Княженика", 
			"Варшавянка", 
			"Невыполнимость", 
			"Выщербление", 
			"Надежда", 
			"Дальтонизм", 
			"Плакирование", 
			"Филипповка", 
			"Ополячение", 
			"Каткование", 
			"Задраивание", 
			"Жаворонок", 
			"Подпруда", 
			"Букет", 
			"Колодезник", 
			"Штуковщик", 
			"Суверенитет", 
			"Дыра", 
			"Истязательница", 
			"Усопшая", 
			"Антиядро", 
			"Трепетание", 
			"Сеноподъёмник", 
			"Бензопила", 
			"Звукоусиление", 
			"Разнуздывание", 
			"Привальное", 
			"Сечевик", 
			"Зюйд-Ост", 
			"Клизма", 
			"Часослов", 
			"Декалькирование", 
			"Выколотка", 
			"Своевольная", 
			"Линотипия", 
			"Подкапок", 
			"Воплотительница", 
			"Джинн", 
			"Идиома", 
			"Впадина", 
			"Частокол", 
			"Серология", 
			"Незнакомец", 
			"Светокопирование", 
			"Бурлеска", 
			"Перекомкивание", 
			"Ботиночек", 
			"Скудность", 
			"Священник", 
			"Проявление", 
			"Гидросамолёт", 
			"Бронхит", 
			"Обменивание", 
			"Истечение", 
			"Нейтрализация", 
			"Хризопраз", 
			"Сутяжничество", 
			"Хозяйка", 
			"Приводнение", 
			"Включённость", 
			"Помертвение", 
			"Ощутимость", 
			"Вязка", 
			"Петуния", 
			"Толокно", 
			"Единообразие", 
			"Автодорожник", 
			"Перевоспитывание", 
			"Шагистика", 
			"Шиллинг", 
			"Рвота", 
			"Брандер", 
			"Секира", 
			"Помада", 
			"Совок", 
			"Протокольность", 
			"Олень", 
			"Интурист", 
			"Гридница", 
			"Гематома", 
			"Главреж", 
			"Катер", 
			"Соарендатор", 
			"Стереобат", 
			"Четверть", 
			"Хиромантка", 
			"Кизильник", 
			"Гетера", 
			"Неплательщица", 
			"Цифрация", 
			"Всесторонность", 
			"Разъёмность", 
			"Парадигма", 
			"Листоед", 
			"Грибоед", 
			"Трубопроводчик", 
			"Лесопильщик", 
			"Начерчивание", 
			"Пахарь", 
			"Домностроение", 
			"Вчерчивание", 
			"Закрепощение", 
			"Обрушение", 
			"Дипломница", 
			"Пояснение", 
			"Седловка", 
			"Хамса", 
			"Обзор", 
			"Черешня", 
			"Сортность", 
			"Шхуна", 
			"Экспонент", 
			"Очарование", 
			"Блюз", 
			"Междупутье", 
			"Рациональность", 
			"Постреливание", 
			"Браковщица", 
			"Антисемит", 
			"Покушение", 
			"Космополитка", 
			"Филигранщик", 
			"Горечавка", 
			"Скот", 
			"Предвозвестник", 
			"Вслушивание", 
			"Несоответственность", 
			"Папство", 
			"Доказывание", 
			"Рафинёрщица", 
			"Центроплан", 
			"Переутомление", 
			"Символ", 
			"Высвобождение", 
			"Подвержение", 
			"Тропик", 
			"Картвелка", 
			"Приводка", 
			"Наказуемость", 
			"Аэровокзал", 
			"Маршрутизация", 
			"Острослов", 
			"Дракон", 
			"Звеньевая", 
			"Триперстка", 
			"Прилегание", 
			"Нагребальщица", 
			"Хлопковод", 
			"Линкруст", 
			"Имеретинец", 
			"Генплан", 
			"Кочевница", 
			"Пропиловка", 
			"Доконопачивание", 
			"Трансплантология", 
			"Фила", 
			"Имбирь", 
			"Выпяливание", 
			"Таджик", 
			"Изъедание", 
			"Неспособность", 
			"Старт", 
			"Сифилидология", 
			"Зенитчица", 
			"Иносказательность", 
			"Подделка", 
			"Сзывание", 
			"Гадальщица", 
			"Каштан", 
			"Командующий", 
			"Разрисовывание", 
			"Дышло", 
			"Чабарня", 
			"Обнюхивание", 
			"Милиционер", 
			"Агрофизик", 
			"Гастрит", 
			"Химерность", 
			"Портплед", 
			"Необоснованность", 
			"Мещеряк", 
			"Винодел", 
			"Мезоглея", 
			"Ликвидирование", 
			"Телекс", 
			"Бурильщик", 
			"Навевание", 
			"Жеребец", 
			"Каротель", 
			"Ужимание", 
			"Усвояемость", 
			"Пирога", 
			"Фенолог"
        };
    }
}


// --- End of file: ChatEvent.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/ImageLibrary.cs ---
// --- Original Local Path: TrashRust/ImageLibrary.cs ---

//Reference: Facepunch.Sqlite
//Reference: UnityEngine.UnityWebRequestModule
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Steamworks;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Networking;

namespace Oxide.Plugins
{
    [Info("Image Library", "Absolut & K1lly0u", "2.0.62")]
    [Description("Plugin API for downloading and managing images")]
    class ImageLibrary : RustPlugin
    {
        #region Fields

        private ImageIdentifiers imageIdentifiers;
        private ImageURLs imageUrls;
        private SkinInformation skinInformation;
        private DynamicConfigFile identifiers;
        private DynamicConfigFile urls;
        private DynamicConfigFile skininfo;

        private static ImageLibrary il;
        private ImageAssets assets;

        private Queue<LoadOrder> loadOrders = new Queue<LoadOrder>();
        private bool orderPending;
        private bool isInitialized;

        private JsonSerializerSettings errorHandling = new JsonSerializerSettings { Error = (se, ev) => { ev.ErrorContext.Handled = true; } };

        private const string STEAM_API_URL = "https://api.steampowered.com/ISteamRemoteStorage/GetPublishedFileDetails/v1/";
        private const string STEAM_AVATAR_URL = "https://api.steampowered.com/ISteamUser/GetPlayerSummaries/v0002/?key={0}&steamids={1}";

        private string[] itemShortNames;

        #endregion Fields

        #region Oxide Hooks

        private void Loaded()
        {
            identifiers = Interface.Oxide.DataFileSystem.GetFile("ImageLibrary/image_data");
            
            urls = Interface.Oxide.DataFileSystem.GetFile("ImageLibrary/image_urls");
            skininfo = Interface.Oxide.DataFileSystem.GetFile("ImageLibrary/skin_data");

            il = this;
            LoadData();
        }

        private void OnServerInitialized()
        {
            itemShortNames = ItemManager.itemList.Select(x => x.shortname).ToArray();

            foreach (ItemDefinition item in ItemManager.itemList)
            {
                string workshopName = item.displayName.english.ToLower().Replace("skin", "").Replace(" ", "").Replace("-", "");
                if (!workshopNameToShortname.ContainsKey(workshopName))
                    workshopNameToShortname.Add(workshopName, item.shortname);
            }

            AddDefaultUrls();

            CheckForRefresh();

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);
        }
    
        private void OnPlayerConnected(BasePlayer player) => GetPlayerAvatar(player?.UserIDString);

        private void Unload()
        {
            SaveData();
            UnityEngine.Object.Destroy(assets);
            il = null;
        }

        #endregion Oxide Hooks

        #region Functions
        private IEnumerator ProcessLoadOrders()
        {
            yield return new WaitWhile(() => !isInitialized);

            if (loadOrders.Count > 0)
            {
                if (orderPending)
                    yield break;

                LoadOrder nextLoad = loadOrders.Dequeue();
                if (!nextLoad.loadSilent)
                    Puts("Starting order " + nextLoad.loadName);

                if (nextLoad.imageList != null && nextLoad.imageList.Count > 0)
                {
                    foreach (KeyValuePair<string, string> item in nextLoad.imageList)
                        assets.Add(item.Key, item.Value);
                }
                if (nextLoad.imageData != null && nextLoad.imageData.Count > 0)
                {
                    foreach (KeyValuePair<string, byte[]> item in nextLoad.imageData)
                        assets.Add(item.Key, null, item.Value);
                }

                orderPending = true;

                assets.RegisterCallback(nextLoad.callback);

                assets.BeginLoad(nextLoad.loadSilent ? string.Empty : nextLoad.loadName);
            }
        }

        private void GetPlayerAvatar(string userId)
        {
            if (!configData.StoreAvatars || string.IsNullOrEmpty(userId) || string.IsNullOrEmpty(configData.SteamAPIKey) || HasImage(userId, 0))
                return;

            webrequest.Enqueue(string.Format(STEAM_AVATAR_URL, configData.SteamAPIKey, userId), null, (code, response) =>
            {
                if (response != null && code == 200)
                {
                    try
                    {
                        AvatarRoot rootObject = JsonConvert.DeserializeObject<AvatarRoot>(response, errorHandling);
                        if (rootObject?.response?.players?.Length > 0)
                        {
                            string avatarUrl = rootObject.response.players[0].avatarmedium;
                            if (!string.IsNullOrEmpty(avatarUrl))                            
                                AddImage(avatarUrl, userId, 0);                               
                        }                        
                    }
                    catch { }
                }
            }, this);
        }

        private void RefreshImagery()
        {
            imageIdentifiers.imageIds.Clear();
            imageIdentifiers.lastCEID = CommunityEntity.ServerInstance.net.ID.Value;

            AddImage("http://i.imgur.com/sZepiWv.png", "NONE", 0);
            AddImage("http://i.imgur.com/lydxb0u.png", "LOADING", 0);
            foreach (KeyValuePair<string, string> image in configData.UserImages)
            {
                if (!string.IsNullOrEmpty(image.Value))
                    AddImage(image.Value, image.Key, 0);
            }

            if ((Steamworks.SteamInventory.Definitions?.Length ?? 0) == 0)
            {
                PrintWarning("Waiting for Steamworks to update item definitions....");
                Steamworks.SteamInventory.OnDefinitionsUpdated += GetItemSkins;
            }
            else GetItemSkins();
        }

        private void CheckForRefresh()
        {
            if (assets == null)
                assets = new GameObject("WebObject").AddComponent<ImageAssets>();

            isInitialized = true;

            if (imageIdentifiers.lastCEID != CommunityEntity.ServerInstance.net.ID.Value)
            {
                if (imageIdentifiers.imageIds.Count < 2)
                {
                    RefreshImagery();
                }
                else
                {
                    PrintWarning("The CommunityEntity instance ID has changed! Due to the way CUI works in Rust all previously stored images must be removed and re-stored using the new ID as reference so clients can find the images. These images will be added to a new load order. Interupting this process will result in being required to re-download these images from the web");
                    RestoreLoadedImages();
                }
            }
        }

        private void RestoreLoadedImages()
        {
            orderPending = true;

            try
            {
                Facepunch.Sqlite.Database db = new Facepunch.Sqlite.Database();
                db.Open(string.Concat(ConVar.Server.rootFolder, "/", "sv.files.", Rust.Protocol.save - 1, ".db"));                
                if (db.TableExists("data"))
                {
                    Dictionary<string, byte[]> oldFiles = new Dictionary<string, byte[]>();
                    int failed = 0;

                    for (int i = imageIdentifiers.imageIds.Count - 1; i >= 0; i--)
                    {
                        KeyValuePair<string, string> image = imageIdentifiers.imageIds.ElementAt(i);

                        uint imageId;
                        if (!uint.TryParse(image.Value, out imageId))
                            continue;

                        byte[] bytes = db.Query<byte[], int, int, int>("SELECT data FROM data WHERE crc = ? AND filetype = ? AND entid = ? LIMIT 1", (int)imageId, 0, (int)imageIdentifiers.lastCEID );
                        if (bytes != null)
                            oldFiles.Add(image.Key, bytes);
                        else
                        {
                            failed++;
                            imageIdentifiers.imageIds.Remove(image.Key);
                        }
                    }

                    if (oldFiles.Count > 0)
                    {
                        loadOrders.Enqueue(new LoadOrder("Image restoration from previous database", oldFiles));
                        PrintWarning($"{imageIdentifiers.imageIds.Count - failed} images queued for restoration from previous image db, {failed} images failed");
                    }

                }
                db.Close();
            }
            catch
            {
                PrintError("Failed to open previous image database. Unable to clone previous image data");
            }
            //Facepunch.Sqlite.Database db = new Facepunch.Sqlite.Database();
            //try
            //{
            //    db.Open($"{ConVar.Server.rootFolder}/sv.files.0.db");
            //    db.Execute("DELETE FROM data WHERE entid = ?", imageIdentifiers.lastCEID);
            //    db.Close();
            //}
            //catch { }

            //loadOrders.Enqueue(new LoadOrder("Image restoration from previous database", oldFiles));
            //PrintWarning($"{imageIdentifiers.imageIds.Count - failed} images queued for restoration, {failed} images failed");
            imageIdentifiers.lastCEID = CommunityEntity.ServerInstance.net.ID.Value;
            SaveData();

            orderPending = false;
            ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
        }

        #endregion Functions

        #region Workshop Names and Image URLs
        private void AddDefaultUrls()
        {
            foreach (ItemDefinition itemDefinition in ItemManager.itemList)
            {
                string identifier = $"{itemDefinition.shortname}_0";
                if (!imageUrls.URLs.ContainsKey(identifier))
                    imageUrls.URLs.Add(identifier, $"{configData.ImageURL}{itemDefinition.shortname}.png");
                else imageUrls.URLs[identifier] = $"{configData.ImageURL}{itemDefinition.shortname}.png";
            }
            
            SaveUrls();

            LoadInbuiltSkinLookup();
        }

        private void LoadInbuiltSkinLookup()
        {
            const string LOOKUP_TABLE = "https://raw.githubusercontent.com/k1lly0u/Oxide/master/il_inbuilt_skins.json";

            try
            {
                Debug.Log("Loading inbuilt skin manifest from GitHub...");
                webrequest.Enqueue(LOOKUP_TABLE, string.Empty, (int code, string response) =>
                {
                    Dictionary<string, string> collection = JsonConvert.DeserializeObject<Dictionary<string, string>>(response);

                    foreach (ItemSkinDirectory.Skin skin in ItemSkinDirectory.Instance.skins)
                    {
                        if (skin.invItem == null || string.IsNullOrEmpty(skin.invItem.itemname))
                            continue;

                        string filename;
                        if (collection.TryGetValue(skin.name, out filename))
                        {
                            string identifier = $"{skin.invItem.itemname}_{skin.id}";

                            if (!imageUrls.URLs.ContainsKey(identifier))
                                imageUrls.URLs.Add(identifier, $"{configData.ImageURL}{filename}.png");
                            else imageUrls.URLs[identifier] = $"{configData.ImageURL}{filename}.png";
                        }
                    }

                    Debug.Log("Skin manifest imported successfully");
                    SaveUrls();
                }, this);
            }
            catch
            {
                Debug.LogError("Failed to download inbuilt skin manifest from GitHub. Unable to gather inbuilt skin list");
            }
        }

        private readonly Dictionary<string, string> workshopNameToShortname = new Dictionary<string, string>
        {
            {"longtshirt", "tshirt.long" },
            {"cap", "hat.cap" },
            {"beenie", "hat.beenie" },
            {"boonie", "hat.boonie" },
            {"balaclava", "mask.balaclava" },
            {"pipeshotgun", "shotgun.waterpipe" },
            {"woodstorage", "box.wooden" },
            {"ak47", "rifle.ak" },
            {"bearrug", "rug.bear" },
            {"boltrifle", "rifle.bolt" },
            {"bandana", "mask.bandana" },
            {"hideshirt", "attire.hide.vest" },
            {"snowjacket", "jacket.snow" },
            {"buckethat", "bucket.helmet" },
            {"semiautopistol", "pistol.semiauto" },
            {"burlapgloves", "burlap.gloves" },
            {"roadsignvest", "roadsign.jacket" },
            {"roadsignpants", "roadsign.kilt" },
            {"burlappants", "burlap.trousers" },
            {"collaredshirt", "shirt.collared" },
            {"mp5", "smg.mp5" },
            {"sword", "salvaged.sword" },
            {"workboots", "shoes.boots" },
            {"vagabondjacket", "jacket" },
            {"hideshoes", "attire.hide.boots" },
            {"deerskullmask", "deer.skull.mask" },
            {"minerhat", "hat.miner" },
            {"lr300", "rifle.lr300" },
            {"lr300.item", "rifle.lr300" },
            {"burlap.gloves", "burlap.gloves.new"},
            {"leather.gloves", "burlap.gloves"},
            {"python", "pistol.python" },
            {"m39", "rifle.m39"},
            {"woodendoubledoor", "door.double.hinged.wood"}
        };

        #endregion Workshop Names and Image URLs

        #region API

        [HookMethod("AddImage")]
        public bool AddImage(string url, string imageName, ulong imageId, Action callback = null)
        {
            loadOrders.Enqueue(new LoadOrder(imageName, new Dictionary<string, string> { { $"{imageName}_{imageId}", url } }, true, callback));
            if (!orderPending)
                ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
            return true;
        }

        [HookMethod("AddImageData")]
        public bool AddImageData(string imageName, byte[] array, ulong imageId, Action callback = null)
        {
            loadOrders.Enqueue(new LoadOrder(imageName, new Dictionary<string, byte[]> { { $"{imageName}_{imageId}", array } }, true, callback));
            if (!orderPending)
                ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
            return true;
        }

        [HookMethod("GetImageURL")]
        public string GetImageURL(string imageName, ulong imageId = 0)
        {
            string identifier = $"{imageName}_{imageId}";
            string value;
            if (imageUrls.URLs.TryGetValue(identifier, out value))
                return value;
            return string.Empty;
        }

        [HookMethod("GetImage")]
        public string GetImage(string imageName, ulong imageId = 0, bool returnUrl = false)
        {
            string identifier = $"{imageName}_{imageId}";
            string value;
            if (imageIdentifiers.imageIds.TryGetValue(identifier, out value))
                return value;
            else
            {                
                if (imageUrls.URLs.TryGetValue(identifier, out value))
                {
                    AddImage(value, imageName, imageId);
                    return imageIdentifiers.imageIds["LOADING_0"];
                }
            }

            if (returnUrl && !string.IsNullOrEmpty(value))
                return value;

            return imageIdentifiers.imageIds["NONE_0"];
        }

        [HookMethod("GetImageList")]
        public List<ulong> GetImageList(string name)
        {
            List<ulong> skinIds = new List<ulong>();
            string[] matches = imageUrls.URLs.Keys.Where(x => x.StartsWith(name)).ToArray();
            for (int i = 0; i < matches.Length; i++)
            {
                int index = matches[i].IndexOf("_");
                if (matches[i].Substring(0, index) == name)
                {
                    ulong skinID;
                    if (ulong.TryParse(matches[i].Substring(index + 1), out skinID))
                        skinIds.Add(ulong.Parse(matches[i].Substring(index + 1)));
                }
            }
            return skinIds;
        }

        [HookMethod("GetSkinInfo")]
        public Dictionary<string, object> GetSkinInfo(string name, ulong id)
        {
            Dictionary<string, object> skinInfo;
            if (skinInformation.skinData.TryGetValue($"{name}_{id}", out skinInfo))
                return skinInfo;
            return null;
        }

        [HookMethod("HasImage")]
        public bool HasImage(string imageName, ulong imageId)
        {
            string key = $"{imageName}_{imageId}";
            string value;

            if (imageIdentifiers.imageIds.TryGetValue(key, out value) && IsInStorage(uint.Parse(value)))            
                return true;            

            return false;
        }

        public bool IsInStorage(uint crc) => FileStorage.server.Get(crc, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID) != null;

        [HookMethod("IsReady")]
        public bool IsReady() => loadOrders.Count == 0 && !orderPending;

        [HookMethod("ImportImageList")]
        public void ImportImageList(string title, Dictionary<string, string> imageList, ulong imageId = 0, bool replace = false, Action callback = null)
        {
            Dictionary<string, string> newLoadOrder = new Dictionary<string, string>();
            foreach (KeyValuePair<string, string> image in imageList)
            {
                if (!replace && HasImage(image.Key, imageId))
                    continue;
                newLoadOrder[$"{image.Key}_{imageId}"] = image.Value;
            }
            if (newLoadOrder.Count > 0)
            {
                loadOrders.Enqueue(new LoadOrder(title, newLoadOrder, false, callback));
                if (!orderPending)
                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
            }
            else
            {
                if (callback != null)
                    callback.Invoke();
            }
        }

        [HookMethod("ImportItemList")]
        public void ImportItemList(string title, Dictionary<string, Dictionary<ulong, string>> itemList, bool replace = false, Action callback = null)
        {
            Dictionary<string, string> newLoadOrder = new Dictionary<string, string>();
            foreach (KeyValuePair<string, Dictionary<ulong, string>> image in itemList)
            {
                foreach (KeyValuePair<ulong, string> skin in image.Value)
                {
                    if (!replace && HasImage(image.Key, skin.Key))
                        continue;
                    newLoadOrder[$"{image.Key}_{skin.Key}"] = skin.Value;
                }
            }
            if (newLoadOrder.Count > 0)
            {
                loadOrders.Enqueue(new LoadOrder(title, newLoadOrder, false, callback));
                if (!orderPending)
                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
            }
            else
            {
                if (callback != null)
                    callback.Invoke();
            }
        }

        [HookMethod("ImportImageData")]
        public void ImportImageData(string title, Dictionary<string, byte[]> imageList, ulong imageId = 0, bool replace = false, Action callback = null)
        {
            Dictionary<string, byte[]> newLoadOrder = new Dictionary<string, byte[]>();
            foreach (KeyValuePair<string, byte[]> image in imageList)
            {
                if (!replace && HasImage(image.Key, imageId))
                    continue;
                newLoadOrder[$"{image.Key}_{imageId}"] = image.Value;
            }
            if (newLoadOrder.Count > 0)
            {
                loadOrders.Enqueue(new LoadOrder(title, newLoadOrder, false, callback));
                if (!orderPending)
                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
            }
            else
            {
                if (callback != null)
                    callback.Invoke();
            }
        }

        [HookMethod("LoadImageList")]
        public void LoadImageList(string title, List<KeyValuePair<string, ulong>> imageList, Action callback = null)
        {
            Dictionary<string, string> newLoadOrderURL = new Dictionary<string, string>();
            List<KeyValuePair<string, ulong>> workshopDownloads = new List<KeyValuePair<string, ulong>>();

            foreach (KeyValuePair<string, ulong> image in imageList)
            {
                if (HasImage(image.Key, image.Value))                
                    continue;

                string identifier = $"{image.Key}_{image.Value}";

                if (imageUrls.URLs.ContainsKey(identifier) && !newLoadOrderURL.ContainsKey(identifier))
                {
                    newLoadOrderURL.Add(identifier, imageUrls.URLs[identifier]);
                }
                else
                {
                    workshopDownloads.Add(new KeyValuePair<string, ulong>(image.Key, image.Value));
                }
            }

            if (workshopDownloads.Count > 0)
            {
                QueueWorkshopDownload(title, newLoadOrderURL, workshopDownloads, 0, callback);
                return;
            }

            if (newLoadOrderURL.Count > 0)
            {
                loadOrders.Enqueue(new LoadOrder(title, newLoadOrderURL, null, false, callback));
                if (!orderPending)
                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
            }
            else
            {
                if (callback != null)
                    callback.Invoke();
            }
        }

        [HookMethod("RemoveImage")]
        public void RemoveImage(string imageName, ulong imageId)
        {
            if (!HasImage(imageName, imageId))
                return;

            uint crc = uint.Parse(GetImage(imageName, imageId));
            FileStorage.server.Remove(crc, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID);
        }

        [HookMethod("SendImage")]
        public void SendImage(BasePlayer player, string imageName, ulong imageId = 0)
        {
            if (!HasImage(imageName, imageId) || player?.net?.connection == null)
                return;

            uint crc = uint.Parse(GetImage(imageName, imageId));
            byte[] array = FileStorage.server.Get(crc, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID);

            if (array == null)
                return;

            CommunityEntity.ServerInstance.ClientRPCEx<uint, uint, byte[]>(new Network.SendInfo(player.net.connection)
            {
                channel = 2,
                method = Network.SendMethod.Reliable
            }, null, "CL_ReceiveFilePng", crc, (uint)array.Length, array);
        }
        #endregion API

        #region Steam API
        private List<ulong> BuildApprovedItemList()
        {
            List<ulong> list = new List<ulong>();

            foreach (InventoryDef item in Steamworks.SteamInventory.Definitions)
            {
                string shortname = item.GetProperty("itemshortname");
                ulong workshopid;

                if (item == null || string.IsNullOrEmpty(shortname))
                    continue;

                if (workshopNameToShortname.ContainsKey(shortname))
                    shortname = workshopNameToShortname[shortname];

                if (item.Id < 100)
                    continue;

                if (!ulong.TryParse(item.GetProperty("workshopid"), out workshopid))
                    continue;

                if (HasImage(shortname, workshopid))
                    continue;

                list.Add(workshopid);
            }

            return list;
        }

        private string BuildDetailsString(List<ulong> list, int page)
        {            
            int totalPages = Mathf.CeilToInt((float)list.Count / 100f);
            int index = page * 100;
            int limit = Mathf.Min((page + 1) * 100, list.Count);
            string details = string.Format("?key={0}&itemcount={1}", configData.SteamAPIKey, (limit - index));

            for (int i = index; i < limit; i++)            
                details += string.Format("&publishedfileids[{0}]={1}", i - index, list[i]);
            
            return details;
        }

        private string BuildDetailsString(List<ulong> list)
        {            
            string details = string.Format("?key={0}&itemcount={1}", configData.SteamAPIKey, list.Count);

            for (int i = 0; i < list.Count; i++)
                details += string.Format("&publishedfileids[{0}]={1}", i, list[i]);

            return details;
        }

        private bool IsValid(PublishedFileDetails item)
        {
            if (string.IsNullOrEmpty(item.preview_url))
                return false;

            if (item.tags == null)
                return false;

            return true;
        }

        private void GetItemSkins()
        {
            Steamworks.SteamInventory.OnDefinitionsUpdated -= GetItemSkins;

            PrintWarning("Retrieving item skin lists...");

            GetApprovedItemSkins(BuildApprovedItemList(), 0);
        }

        private void QueueFileQueryRequest(string details, Action<PublishedFileDetails[]> callback)
        {
            webrequest.Enqueue(STEAM_API_URL, details, (code, response) =>
            {
                try
                {
                    QueryResponse query = JsonConvert.DeserializeObject<QueryResponse>(response, errorHandling);
                    if (query == null || query.response == null || query.response.publishedfiledetails.Length == 0)
                    {
                        if (code != 200)
                            PrintError($"There was a error querying Steam for workshop item data : Code ({code})\n{details}");
                        return;
                    }
                    else
                    {
                        if (query?.response?.publishedfiledetails?.Length > 0)
                            callback.Invoke(query.response.publishedfiledetails);
                    }
                }
                catch { }
            }, this, Core.Libraries.RequestMethod.POST);
        }

        private void GetApprovedItemSkins(List<ulong> itemsToDownload, int page)
        {
            if (itemsToDownload.Count < 1)
            {
                Puts("Approved skins loaded");

                SaveUrls();
                SaveSkinInfo();

                if (!orderPending)
                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
                return;
            }

            int totalPages = Mathf.CeilToInt((float)itemsToDownload.Count / 100f) - 1;

            string details = BuildDetailsString(itemsToDownload, page);

            QueueFileQueryRequest(details, (PublishedFileDetails[] items) =>
            {
                ServerMgr.Instance.StartCoroutine(ProcessApprovedBlock(itemsToDownload, items, page, totalPages));
            });
        }

        private IEnumerator ProcessApprovedBlock(List<ulong> itemsToDownload, PublishedFileDetails[] items, int page, int totalPages)
        {
            PrintWarning($"Processing approved skins; Page {page + 1}/{totalPages + 1}");

            Dictionary<string, Dictionary<ulong, string>> loadOrder = new Dictionary<string, Dictionary<ulong, string>>();

            foreach (PublishedFileDetails item in items)
            {
                if (!IsValid(item))
                    continue;

                foreach (PublishedFileDetails.Tag tag in item.tags)
                {
                    if (string.IsNullOrEmpty(tag.tag))
                        continue;

                    ulong workshopid = Convert.ToUInt64(item.publishedfileid);

                    string adjTag = tag.tag.ToLower().Replace("skin", "").Replace(" ", "").Replace("-", "").Replace(".item", "");
                    if (workshopNameToShortname.ContainsKey(adjTag))
                    {
                        string shortname = workshopNameToShortname[adjTag];

                        string identifier = $"{shortname}_{workshopid}";

                        if (!imageUrls.URLs.ContainsKey(identifier))
                            imageUrls.URLs.Add(identifier, item.preview_url.Replace("https", "http"));

                        skinInformation.skinData[identifier] = new Dictionary<string, object>
                                {
                                    {"title", item.title },
                                    {"votesup", 0 },
                                    {"votesdown", 0 },
                                    {"description", item.file_description },
                                    {"score", 0 },
                                    {"views", 0 },
                                    {"created", new DateTime() },
                                };
                    }
                }
            }

            yield return CoroutineEx.waitForEndOfFrame;
            yield return CoroutineEx.waitForEndOfFrame;

            if (page < totalPages)
                GetApprovedItemSkins(itemsToDownload, page + 1);
            else
            {
                itemsToDownload.Clear();

                Puts("Approved skins loaded");

                SaveUrls();
                SaveSkinInfo();

                if (!orderPending)
                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
            }
        }

        private void QueueWorkshopDownload(string title, Dictionary<string, string> newLoadOrderURL, List<KeyValuePair<string, ulong>> workshopDownloads, int page = 0, Action callback = null)
        {
            int rangeMin = page * 100;
            int rangeMax = (page + 1) * 100;

            if (rangeMax > workshopDownloads.Count)
                rangeMax = workshopDownloads.Count;

            List<ulong> requestedSkins = workshopDownloads.GetRange(rangeMin, rangeMax - rangeMin).Select(x => x.Value).ToList();

            int totalPages = Mathf.CeilToInt((float)workshopDownloads.Count / 100f) - 1;

            string details = BuildDetailsString(requestedSkins);

            try
            {
                webrequest.Enqueue(STEAM_API_URL, details, (code, response) =>
                {
                    QueryResponse query = JsonConvert.DeserializeObject<QueryResponse>(response, errorHandling);
                    if (query == null || query.response == null || query.response.publishedfiledetails.Length == 0)
                    {
                        if (code != 200)
                            PrintError($"There was a error querying Steam for workshop item data : Code ({code})");

                        if (page < totalPages)
                            QueueWorkshopDownload(title, newLoadOrderURL, workshopDownloads, page + 1, callback);
                        else
                        {
                            if (newLoadOrderURL.Count > 0)
                            {
                                loadOrders.Enqueue(new LoadOrder(title, newLoadOrderURL, null, false, page < totalPages ? null : callback));
                                if (!orderPending)
                                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
                            }
                            else
                            {
                                if (callback != null)
                                    callback.Invoke();
                            }
                        }
                        return;
                    }
                    else
                    {
                        if (query.response.publishedfiledetails.Length > 0)
                        {
                            Dictionary<string, Dictionary<ulong, string>> loadOrder = new Dictionary<string, Dictionary<ulong, string>>();

                            foreach (PublishedFileDetails item in query.response.publishedfiledetails)
                            {
                                if (!string.IsNullOrEmpty(item.preview_url))
                                {
                                    ulong skinId = Convert.ToUInt64(item.publishedfileid);

                                    KeyValuePair<string, ulong>? kvp = workshopDownloads.Find(x => x.Value == skinId);

                                    if (kvp.HasValue)
                                    {
                                        string identifier = $"{kvp.Value.Key}_{kvp.Value.Value}";

                                        if (!newLoadOrderURL.ContainsKey(identifier))
                                            newLoadOrderURL.Add(identifier, item.preview_url);

                                        if (!imageUrls.URLs.ContainsKey(identifier))
                                            imageUrls.URLs.Add(identifier, item.preview_url);

                                        skinInformation.skinData[identifier] = new Dictionary<string, object>
                                        {
                                            {"title", item.title },
                                            {"votesup",  0 },
                                            {"votesdown", 0 },
                                            {"description", item.file_description },
                                            {"score", 0 },
                                            {"views", item.views },
                                            {"created", new DateTime(item.time_created) },
                                        };

                                        requestedSkins.Remove(skinId);
                                    }
                                }
                            }

                            SaveUrls();
                            SaveSkinInfo();

                            if (requestedSkins.Count != 0)
                            {
                                Puts($"{requestedSkins.Count} workshop skin ID's for image batch ({title}) are invalid! They may have been removed from the workshop\nIDs: {requestedSkins.ToSentence()}");
                            }
                        }

                        if (page < totalPages)
                            QueueWorkshopDownload(title, newLoadOrderURL, workshopDownloads, page + 1, callback);
                        else
                        {
                            if (newLoadOrderURL.Count > 0)
                            {
                                loadOrders.Enqueue(new LoadOrder(title, newLoadOrderURL, null, false, page < totalPages ? null : callback));
                                if (!orderPending)
                                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
                            }
                            else
                            {
                                if (callback != null)
                                    callback.Invoke();
                            }
                        }
                    }
                },
                this,
                Core.Libraries.RequestMethod.POST);
            }
            catch { }
        }

        #region JSON Response Classes
        public class QueryResponse
        {
            public Response response;
        }

        public class Response
        {
            public int total;
            public PublishedFileDetails[] publishedfiledetails;
        }

        public class PublishedFileDetails
        {
            public int result;
            public string publishedfileid;
            public string creator;
            public int creator_appid;
            public int consumer_appid;
            public int consumer_shortcutid;
            public string filename;
            public string file_size;
            public string preview_file_size;
            public string file_url;
            public string preview_url;
            public string url;
            public string hcontent_file;
            public string hcontent_preview;
            public string title;
            public string file_description;
            public int time_created;
            public int time_updated;
            public int visibility;
            public int flags;
            public bool workshop_file;
            public bool workshop_accepted;
            public bool show_subscribe_all;
            public int num_comments_public;
            public bool banned;
            public string ban_reason;
            public string banner;
            public bool can_be_deleted;
            public string app_name;
            public int file_type;
            public bool can_subscribe;
            public int subscriptions;
            public int favorited;
            public int followers;
            public int lifetime_subscriptions;
            public int lifetime_favorited;
            public int lifetime_followers;
            public string lifetime_playtime;
            public string lifetime_playtime_sessions;
            public int views;
            public int num_children;
            public int num_reports;
            public Preview[] previews;
            public Tag[] tags;
            public int language;
            public bool maybe_inappropriate_sex;
            public bool maybe_inappropriate_violence;

            public class Tag
            {
                public string tag;
                public bool adminonly;
            }

        }

        public class Preview
        {
            public string previewid;
            public int sortorder;
            public string url;
            public int size;
            public string filename;
            public int preview_type;
            public string youtubevideoid;
            public string external_reference;
        }
        #endregion
        #endregion

        #region Commands

        [ConsoleCommand("cancelstorage")]
        private void cmdCancelStorage(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null || arg.Connection.authLevel > 0)
            {
                if (!orderPending)
                    PrintWarning("No images are currently being downloaded");
                else
                {
                    assets.ClearList();
                    loadOrders.Clear();
                    PrintWarning("Pending image downloads have been cancelled!");
                }
            }
        }

        private List<ulong> pendingAnswers = new List<ulong>();

        [ConsoleCommand("refreshallimages")]
        private void cmdRefreshAllImages(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null || arg.Connection.authLevel > 0)
            {
                SendReply(arg, "Running this command will wipe all of your ImageLibrary data, meaning every registered image will need to be re-downloaded. Are you sure you wish to continue? (type yes or no)");

                ulong userId = arg.Connection == null || arg.IsRcon ? 0U : arg.Connection.userid;
                if (!pendingAnswers.Contains(userId))
                {
                    pendingAnswers.Add(userId);
                    timer.In(5, () =>
                    {
                        if (pendingAnswers.Contains(userId))
                            pendingAnswers.Remove(userId);
                    });
                }
            }
        }

        [ConsoleCommand("yes")]
        private void cmdRefreshAllImagesYes(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null || arg.Connection.authLevel > 0)
            {
                ulong userId = arg.Connection == null || arg.IsRcon ? 0U : arg.Connection.userid;
                if (pendingAnswers.Contains(userId))
                {
                    PrintWarning("Wiping ImageLibrary data and redownloading ImageLibrary specific images. All plugins that have registered images via ImageLibrary will need to be re-loaded!");
                    RefreshImagery();

                    pendingAnswers.Remove(userId);
                }
            }
        }

        [ConsoleCommand("no")]
        private void cmdRefreshAllImagesNo(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null || arg.Connection.authLevel > 0)
            {
                ulong userId = arg.Connection == null || arg.IsRcon ? 0U : arg.Connection.userid;

                if (pendingAnswers.Contains(userId))
                {
                    SendReply(arg, "ImageLibrary data wipe aborted!");
                    pendingAnswers.Remove(userId);
                }
            }
        }

        #endregion Commands

        #region Image Storage

        private struct LoadOrder
        {
            public string loadName;
            public bool loadSilent;

            public Dictionary<string, string> imageList;
            public Dictionary<string, byte[]> imageData;

            public Action callback;

            public LoadOrder(string loadName, Dictionary<string, string> imageList, bool loadSilent = false, Action callback = null)
            {
                this.loadName = loadName;
                this.imageList = imageList;
                this.imageData = null;
                this.loadSilent = loadSilent;
                this.callback = callback;
            }
            public LoadOrder(string loadName, Dictionary<string, byte[]> imageData, bool loadSilent = false, Action callback = null)
            {
                this.loadName = loadName;
                this.imageList = null;
                this.imageData = imageData;
                this.loadSilent = loadSilent;
                this.callback = callback;
            }
            public LoadOrder(string loadName, Dictionary<string, string> imageList, Dictionary<string, byte[]> imageData, bool loadSilent = false, Action callback = null)
            {
                this.loadName = loadName;
                this.imageList = imageList;
                this.imageData = imageData;
                this.loadSilent = loadSilent;
                this.callback = callback;
            }
        }

        private class ImageAssets : MonoBehaviour
        {
            private Queue<QueueItem> queueList = new Queue<QueueItem>();
            private bool isLoading;
            private double nextUpdate;
            private int listCount;
            private string request;

            private Action callback;

            private void OnDestroy()
            {
                queueList.Clear();
            }

            public void Add(string name, string url = null, byte[] bytes = null)
            {
                queueList.Enqueue(new QueueItem(name, url, bytes));
            }

            public void RegisterCallback(Action callback) => this.callback = callback;

            public void BeginLoad(string request)
            {
                this.request = request;
                nextUpdate = UnityEngine.Time.time + il.configData.UpdateInterval;
                listCount = queueList.Count;
                Next();
            }

            public void ClearList()
            {
                queueList.Clear();
                il.orderPending = false;
            }

            private void Next()
            {
                if (queueList.Count == 0)
                {
                    il.orderPending = false;
                    il.SaveData();
                    if (!string.IsNullOrEmpty(request))
                        print($"Image batch ({request}) has been stored successfully");

                    request = string.Empty;
                    listCount = 0;

                    if (callback != null)
                        callback.Invoke();

                    StartCoroutine(il.ProcessLoadOrders());
                    return;
                }
                if (il.configData.ShowProgress && listCount > 1)
                {
                    float time = UnityEngine.Time.time;
                    if (time > nextUpdate)
                    {
                        int amountDone = listCount - queueList.Count;
                        print($"{request} storage process at {Math.Round((amountDone / (float)listCount) * 100, 0)}% ({amountDone}/{listCount})");
                        nextUpdate = time + il.configData.UpdateInterval;
                    }
                }
                isLoading = true;

                QueueItem queueItem = queueList.Dequeue();
                if (!string.IsNullOrEmpty(queueItem.url))
                    StartCoroutine(DownloadImage(queueItem));
                else StoreByteArray(queueItem.bytes, queueItem.name);
            }

            private IEnumerator DownloadImage(QueueItem info)
            {
                UnityWebRequest www = UnityWebRequest.Get(info.url);

                yield return www.SendWebRequest();
                if (il == null) yield break;
                if (www.isNetworkError || www.isHttpError)
                {
                    print(string.Format("Image failed to download! Error: {0} - Image Name: {1} - Image URL: {2}", www.error, info.name, info.url));
                    www.Dispose();
                    isLoading = false;
                    Next();
                    yield break;
                }

                if (www?.downloadHandler?.data != null)
                {
                    Texture2D texture = new Texture2D(2, 2);
                    texture.LoadImage(www.downloadHandler.data);
                    if (texture != null)
                    {
                        bool shouldStore = true;
                        byte[] bytes = texture.EncodeToPNG();

                        if (bytes.Length > 3145728)
                        {
                            Debug.Log($"[ImageLibrary] Failed to store image data for image : {info.name} for equest {request}\nURL: {info.url}\n{bytes.Length} bytes is larger then the allowed transferable size of 3145728 bytes");
                            shouldStore = false;
                        }

                        DestroyImmediate(texture);

                        if (shouldStore)
                            StoreByteArray(bytes, info.name);
                    }
                }
                www.Dispose();
            }

            private void StoreByteArray(byte[] bytes, string name)
            {
                if (bytes != null)
                    il.imageIdentifiers.imageIds[name] = FileStorage.server.Store(bytes, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID).ToString();
                isLoading = false;
                Next();
            }

            private class QueueItem
            {
                public byte[] bytes;
                public string url;
                public string name;
                public QueueItem(string name, string url = null, byte[] bytes = null)
                {
                    this.bytes = bytes;
                    this.url = url;
                    this.name = name;
                }
            }
        }

        #endregion Image Storage

        #region Config

        private ConfigData configData;

        class ConfigData
        {
            [JsonProperty(PropertyName = "Avatars - Store player avatars")]
            public bool StoreAvatars { get; set; }

            [JsonProperty(PropertyName = "Steam API key (get one here https://steamcommunity.com/dev/apikey)")]
            public string SteamAPIKey { get; set; }

            [JsonProperty(PropertyName = "URL to web folder containing all item icons")]
            public string ImageURL { get; set; }

            [JsonProperty(PropertyName = "Progress - Show download progress in console")]
            public bool ShowProgress { get; set; }

            [JsonProperty(PropertyName = "Progress - Time between update notifications")]
            public int UpdateInterval { get; set; }
            
            [JsonProperty(PropertyName = "User Images - Manually define images to be loaded")]
            public Dictionary<string, string> UserImages { get; set; }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                ShowProgress = true,
                SteamAPIKey = string.Empty,
                StoreAvatars = false,
                UpdateInterval = 20,
                ImageURL = "https://www.rustedit.io/images/imagelibrary/",
                UserImages = new Dictionary<string, string>(),
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (configData.Version < new VersionNumber(2, 0, 47))
                configData = baseConfig;

            if (configData.Version < new VersionNumber(2, 0, 53))
                configData.StoreAvatars = false;

            if (configData.Version < new VersionNumber(2, 0, 55))
                configData.ImageURL = baseConfig.ImageURL;

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion Config

        #region Data Management

        private void SaveData() => identifiers.WriteObject(imageIdentifiers);

        private void SaveSkinInfo() => skininfo.WriteObject(skinInformation);

        private void SaveUrls() => urls.WriteObject(imageUrls);

        private void LoadData()
        {
            try
            {
                imageIdentifiers = identifiers.ReadObject<ImageIdentifiers>();
            }
            catch
            {
                imageIdentifiers = new ImageIdentifiers();
            }
            try
            {
                skinInformation = skininfo.ReadObject<SkinInformation>();
            }
            catch
            {
                skinInformation = new SkinInformation();
            }
            try
            {
                imageUrls = urls.ReadObject<ImageURLs>();
            }
            catch
            {
                imageUrls = new ImageURLs();
            }
            if (skinInformation == null)
                skinInformation = new SkinInformation();
            if (imageIdentifiers == null)
                imageIdentifiers = new ImageIdentifiers();
            if (imageUrls == null)
                imageUrls = new ImageURLs();
        }

        private class ImageIdentifiers
        {
            public ulong lastCEID;
            public Hash<string, string> imageIds = new Hash<string, string>();
        }

        private class SkinInformation
        {
            public Hash<string, Dictionary<string, object>> skinData = new Hash<string, Dictionary<string, object>>();
        }

        private class ImageURLs
        {
            public Hash<string, string> URLs = new Hash<string, string>();
        }


        public class AvatarRoot
        {
            public Response response { get; set; }

            public class Response
            {
                public Player[] players { get; set; }

                public class Player
                {
                    public string steamid { get; set; }
                    public int communityvisibilitystate { get; set; }
                    public int profilestate { get; set; }
                    public string personaname { get; set; }
                    public int lastlogoff { get; set; }
                    public string profileurl { get; set; }
                    public string avatar { get; set; }
                    public string avatarmedium { get; set; }
                    public string avatarfull { get; set; }
                    public int personastate { get; set; }
                    public string realname { get; set; }
                    public string primaryclanid { get; set; }
                    public int timecreated { get; set; }
                    public int personastateflags { get; set; }
                }
            }
        }
        #endregion Data Management
    }
}


// --- End of file: ImageLibrary.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/SpawnToRoad.cs ---
// --- Original Local Path: TrashRust/SpawnToRoad.cs ---

﻿using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("SpawnToRoad", "Mercury", "0.0.1")]
    [Description("Модальное меню")]
    class SpawnToRoad : RustPlugin
    {
        public List<float> RandomShift = new List<float>
        {
            9f,
            -9f,
            -9.5f,
            9.5f,
            8f,
            -8f,
            10f,
            -10f
        };
        public List<Vector3> SpawnPoints = new List<Vector3>();

        #region Hooks
        private void OnServerInitialized() => NextTick(() => { GetRoads(); Puts($"Найдено позиций : {SpawnPoints.Count}"); });
        object OnPlayerRespawn(BasePlayer player)
        {
            Vector3 NewPositionSpawn = SpawnPoints.GetRandom();
            BasePlayer.SpawnPoint spawnPoint = new BasePlayer.SpawnPoint();
            spawnPoint.pos = NewPositionSpawn;
            return spawnPoint;
        }
        #endregion

        #region Metods

        bool GetCheckPositiont(Vector3 Position)
        {
            if (Physics.CheckSphere(Position, 15f, LayerMask.GetMask("Construction", "Default", "Deployed", "Trigger")))
                return false;
            return true;
        }

        void GetRoads()
        {
            foreach (PathList x in TerrainMeta.Path.Roads)
                foreach (var point in x.Path.Points.Where(p => GetCheckPositiont(p)))
                {
                    Vector3 SpawnPosition = new Vector3(point.x + RandomShift.GetRandom(), point.y, point.z + RandomShift.GetRandom());
                    SpawnPosition.y = TerrainMeta.HeightMap.GetHeight(SpawnPosition);
                    SpawnPoints.Add(SpawnPosition);
                }
        }

        #endregion
    }
}


// --- End of file: SpawnToRoad.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/TreeLimit.cs ---
// --- Original Local Path: TrashRust/TreeLimit.cs ---

using System.Collections.Generic;
using System.Collections;
using System.Linq;
using System;
using Oxide.Core;
using UnityEngine;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    /*ПЛАГИН БЫЛ ПОФИКШЕН С ПОМОЩЬЮ ПРОГРАММЫ СКАЧАНОЙ С https://discord.gg/dNGbxafuJn */ [Info("TreeLimit", "https://discord.gg/dNGbxafuJn", "1.0.5")]    
    public class TreeLimit : RustPlugin
    {						
		
		#region Variables
		
		private static float MinDistance = 6f * 6f;
		private static bool WasRestart = false;
		
		private static Dictionary<string, int> SaveTreeLimit = new Dictionary<string, int>()
		{
			{ "v2_temp_forest", 10000 },
			{ "v2_temp_forest_small", 10000 },
			{ "v2_tundra_forest", 10000 },
			{ "v2_tundra_forest_small", 2000 },
			{ "v2_arctic_forest", 1500 },
			{ "v2_arctic_forest_snow", 3500 },
			{ "v2_arid_cactus", 2000 },
			{ "v2_arid_palms_dense", 3000 },
			{ "v2_arid_palms_light", 600 },
			{ "v2_arid_palms_superdense", 10000 },
			{ "v2_temp_beachforest_small", 5000 },
			{ "v2_temp_field_small", 1750 },
			{ "v2_arid_palm_beach", 8000 },
			{ "v2_temp_field_large", 100 },
			{ "v2_temp_forest_deciduous", 10000 },
			{ "v2_temp_forest_small_deciduous", 10000 }		
		};
		
		private class TreeInfo
		{
			public TreeEntity tree;
			public Vector2 pos;
			public bool isNeedDel;
		}
		
		#endregion
		
		#region Hooks
	
		private void Init() 
		{
			LoadVariables();
			MinDistance = configData.MinDistance * configData.MinDistance;
		}

		private void OnTerrainInitialized() => WasRestart = true;		
		
		private void OnServerInitialized() 
		{				
			if (!WasRestart) return;
			WasRestart = false;
			timer.Once(configData.StartClearTime, ()=> ReFillTree());
		}
		
		#endregion
		
		#region Main
		
		private void ReFillTree() => ServerMgr.Instance.StartCoroutine(SpawnFill());
		
		private IEnumerator SpawnFill()
        {
			Puts($"Поиск близко стоящих деревьев");
			
            var allSpawnPopulations = SpawnHandler.Instance.AllSpawnPopulations;
            SpawnHandler.Instance.StopCoroutine("SpawnTick");            
                        			
			SpawnDistribution[] spawndists = SpawnHandler.Instance.SpawnDistributions;
			for (int i = 0; i < allSpawnPopulations.Length; i++)
			{
				if (!(allSpawnPopulations[i] == null) && allSpawnPopulations[i].name.Contains("v2_"))
				{
					if ((allSpawnPopulations[i] as DensitySpawnPopulation)._targetDensity <= 1f && SaveTreeLimit.ContainsKey(allSpawnPopulations[i].name))
						(allSpawnPopulations[i] as DensitySpawnPopulation)._targetDensity = SaveTreeLimit[allSpawnPopulations[i].name];
					
					(allSpawnPopulations[i] as DensitySpawnPopulation)._targetDensity = (float)Math.Round((configData.DensityPercent/100f) * (allSpawnPopulations[i] as DensitySpawnPopulation)._targetDensity);					
					SpawnHandler.Instance.SpawnInitial(allSpawnPopulations[i], spawndists[i]);					
				}
			}			
            
            SpawnHandler.Instance.StartCoroutine("SpawnTick");						
			
			var trees_ = BaseNetworkable.serverEntities.OfType<TreeEntity>().ToList();	
			var trees = trees_.Select(x=> new TreeInfo() { tree = x, isNeedDel = false, pos = new Vector2(x.transform.position.x, x.transform.position.z) }).ToList();
			int tCount = trees.Count, gIndex = 0;
			int lastPerc = -1;
						
			for (int ii = 0; ii < tCount; ii++)
			{
				if (trees[ii].tree != null && !trees[ii].isNeedDel)
				{
					for (int jj = ii + 1; jj < tCount; jj++)
					{
						if (trees[ii].tree == null || trees[ii].isNeedDel || trees[jj].tree == null || trees[jj].isNeedDel) continue; 
						
						if ((trees[ii].pos - trees[jj].pos).sqrMagnitude <= MinDistance)
							trees[jj].isNeedDel = true;
						
						gIndex++;
						
						if (gIndex % 150000 == 0)
							yield return new WaitForEndOfFrame();
					}
				}
				
				var perc = (int)Math.Round((100f * ii) / tCount);
					
				if (lastPerc != perc)
				{
					if (perc % 10 == 0)
						Puts($"обработано {perc}%");
					
					lastPerc = perc;					
				}
			}
			
			Puts($"Поиск близко стоящих деревьев завершен");
			Puts($"Удаление близко стоящих деревьев [было {trees_.Count()} шт]");	
			
			gIndex = 0;
			foreach(var info in trees.Where(x=> x.isNeedDel && x.tree != null && !x.tree.IsDestroyed))
			{
				info.tree.Kill();
				
				if (gIndex % 150 == 0)
					yield return new WaitForEndOfFrame();
				
				gIndex++;
			}						

			trees_ = BaseNetworkable.serverEntities.OfType<TreeEntity>().ToList();	
			Puts($"Удаление близко стоящих деревьев завершено [стало {trees_.Count()} шт]");
        }
		
		#endregion
		
		#region Commands
		
		[ConsoleCommand("tl.count")] 
		private void CmdTreeCount(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null) return;        
			var trees = BaseNetworkable.serverEntities.OfType<TreeEntity>().ToList();	
			Puts($"Всего деревьев на сервере: {trees.Count()}");
        }
		
		[ConsoleCommand("tl.refill")] 
		private void CmdReFillTree(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null) return;  
			ReFillTree();
        }
		
		#endregion
		
		#region Config        				
		
        private static ConfigData configData;
		
        private class ConfigData
        {
			[JsonProperty(PropertyName = "Задержка запуска чистки после старта сервера (секунды)")]
			public float StartClearTime;
			[JsonProperty(PropertyName = "Минимальное расстояние между деревьями (метры)")]
			public float MinDistance;
			[JsonProperty(PropertyName = "Какой процент деревьев от оригинала оставить")]
			public float DensityPercent;
        }
		
        private void LoadVariables() => configData = Config.ReadObject<ConfigData>();        
		
        protected override void LoadDefaultConfig()
        {
            configData = new ConfigData
            {
				StartClearTime = 30f,
                MinDistance = 6f,
				DensityPercent = 30f
            };
            SaveConfig(configData);
			timer.Once(0.1f, ()=> SaveConfig(configData));
        }        
		
        private void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
		
        #endregion				
		
    }
}


// --- End of file: TreeLimit.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/RatesController.cs ---
// --- Original Local Path: TrashRust/RatesController.cs ---

using Network;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using UnityEngine;
using Formatter = Oxide.Core.Libraries.Covalence.Formatter;

namespace Oxide.Plugins
{
    /*ПЛАГИН БЫЛ ПОФИКШЕН С ПОМОЩЬЮ ПРОГРАММЫ СКАЧАНОЙ С https://discord.gg/dNGbxafuJn */ [Info("RatesController", "https://discord.gg/dNGbxafuJn", "3.0.4")]
    [Description("All-in-one customizable rate system for the server")]
    /*
     * Author info:
     *   E-mail: Vlad-00003@mail.ru
     *   Vk: vk.com/vlad_00003
     */
    class RatesController : RustPlugin
    {
        #region Vars⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        private static PluginConfig _config;
        private static RatesController _ratesController;
        private PluginData _data;
        private bool _isDay = true;
        private Dictionary<ItemModCookable, float> _smeltRatesBackup = new Dictionary<ItemModCookable, float>();
        private Dictionary<ulong,string> _quarryOwners = new Dictionary<ulong, string>();
        private Dictionary<Item, CustomCookable> _customCookables = new Dictionary<Item, CustomCookable>();
        private CoalConfig _defaultCoal;

        private static class Constants
        {
            public const string ExcavatorArmPrefab = "assets/content/structures/excavator/prefabs/excavator_yaw.prefab";
        }

        #endregion

        #region Configuration⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        #region Rates⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        private sealed class RateType
        {
            private readonly string _name;

            private RateType(string name)
            {
                _name = name;
            }
            public override string ToString()
            {
                return _name;
            }

            public static implicit operator string(RateType type) => type._name;

            public static readonly RateType Quarry = new RateType("Добываемые ресурсы в карьере");
            public static readonly RateType Excavator = new RateType("Добываемые ресурсы в экскаваторе");
            public static readonly RateType Gather = new RateType("Добываемые ресурсы");
            public static readonly RateType Loot = new RateType("Получаемый лут");
            public static readonly RateType Pickup = new RateType("Подбираемые ресурсы");
            public static readonly RateType OvenSpeed = new RateType("Скорость печей");
            public static readonly RateType[] Available = {Quarry, Excavator, Gather, Loot, Pickup, OvenSpeed};
        }

        private class Rates
        {
            [JsonProperty("Днём")]
            private Dictionary<string, float> _day = new Dictionary<string, float>();
            [JsonProperty("Ночью")]
            private Dictionary<string, float> _night = new Dictionary<string, float>();

            public float GetRate(RateType type, bool day = true)
            {
                var dict = day ? _day : _night;
                float val;
                return dict.TryGetValue(type, out val) ? val : 1f;
            }
            
            #region Default Сonfig⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

            public static Rates Default => DefaultWith(1f);

            public static Rates DefaultWith(float rate) => new Rates
            {
                _day = RateType.Available.ToDictionary(x => (string) x, x => rate),
                _night = RateType.Available.ToDictionary(x => (string) x, x => rate)
            };

            #endregion
        }

        #endregion

        #region Server Time Config⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        private class SavedDateConfig
        {
            [JsonProperty("Устанавливать дату при запуске плагина")]
            public bool Use;
            [JsonProperty("День")]
            private int _day;
            [JsonProperty("Месяц")]
            private int _month;
            [JsonProperty("Год")]
            private int _year;
            [JsonProperty("Час")]
            private int _hour;
            [JsonProperty("Минута")]
            private int _minute;
            [JsonProperty("Секунда")]
            private int _second;

            [JsonIgnore]
            public DateTime Date;

            #region Default Config⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

            public static SavedDateConfig DefaultConfig
            {
                get
                {
                    var now = DateTime.Now;
                    return new SavedDateConfig
                    {
                        Use = false,
                        _day = now.Day,
                        _month = now.Month,
                        _year = now.Year,
                        _hour = 12,
                        _minute = 0,
                        _second = 0
                    };
                }
            }

            #endregion
            
            [OnDeserialized]
            internal void OnDeserializedMethod(StreamingContext context)
            {
                Date = new DateTime(_year,_month,_day,_hour,_minute,_second);
            }
        }

        private class DayNightSwitchConfig
        {
            [JsonProperty("Рассчитывать время по закату/восходу (false - по часам)")]
            public bool UseSun;
            
            [JsonProperty("Час начала дня (игровое время)")]
            public int DayStartHour;
            
            [JsonProperty("Час начала ночи (игровое время)")]
            public int NightStartHour;

            #region Default Config⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

            public static DayNightSwitchConfig DefaultConfig => new DayNightSwitchConfig
            {
                UseSun = true,
                DayStartHour = 6,
                NightStartHour = 18
            };

            #endregion

            [JsonIgnore]
            public float DayMultiplier;
            [JsonIgnore]
            public float NightMultiplier;
            
            [OnDeserialized]
            internal void OnDeserializedMethod(StreamingContext context)
            {
                DayMultiplier = 24.0f / (NightStartHour - DayStartHour);
                NightMultiplier = 24.0f / (24.0f - (NightStartHour - DayStartHour));
            }
        }
        
        private class TimeConfig
        {
            [JsonProperty("Длина дня (в минутах)")]
            public int DayLength;

            [JsonProperty("Длина ночи (в минутах)")]
            public int NightLength;

            [JsonProperty("Настройки смены дня/ночи")]
            public DayNightSwitchConfig DayNightSwitchConfig;
            
            [JsonProperty("Восстанавливать состояние времени при запуске плагина")]
            public bool RestoreState;

            [JsonProperty("Устанавливаемая при запуске плагина дата")]
            public SavedDateConfig SavedDateConfig;
            
            #region Default Config⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

            public static TimeConfig DefaultConfig => new TimeConfig
            {
                DayLength = 30,
                NightLength = 30,
                DayNightSwitchConfig = DayNightSwitchConfig.DefaultConfig,
                RestoreState = true,
                SavedDateConfig = SavedDateConfig.DefaultConfig
            };

            #endregion
        }

        #endregion

        #region General Options⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        private class ChatConfig
        {
            [JsonProperty("Выводить сообщения в чат о начале дня или ночи")]
            public bool NotifyTod;

            [JsonProperty("Формат сообщений в чате")]
            private string _chatFormat;

            [JsonIgnore]
            public string ChatFormat;

            #region Default Config⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

            public static ChatConfig DefaultConfig => new ChatConfig
            {
                NotifyTod = true,
                _chatFormat = "<color=#ff0000>[RatesController]</color>: {0}"
            };

            #endregion
            
            [OnDeserialized]
            internal void OnDeserializedMethod(StreamingContext context)
            {
                ChatFormat =  Formatter.ToUnity(_chatFormat);
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class DefaultModifiers
        {
            [JsonProperty("Время переработки ресурсов (в секундах)")]
            public Dictionary<string, float> SmeltRates;
            [JsonProperty("Множители добываемых ресурсов")]
            private Dictionary<string, float> _gatherRates;
            [JsonProperty("Множители добываемых ресурсов в карьере")]
            private Dictionary<string, float> _quarryRates;
            [JsonProperty("Множители добываемых ресурсов в экскаваторе")]
            private Dictionary<string, float> _excavatorRates;
            [JsonProperty("Множители подбираемых ресурсов")]
            private Dictionary<string, float> _pickupRates;
            
            #region Default Config⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

            public static DefaultModifiers DefaultConfig
            {
                get
                {
                    var modifiers = new DefaultModifiers
                    {
                        SmeltRates = new Dictionary<string, float>(),
                        _gatherRates = new Dictionary<string, float>
                        {
                            ["Animal Fat"] = 1.0f,
                            ["Bear Meat"] = 1.0f,
                            ["Bone Fragments"] = 1.0f,
                            ["Cloth"] = 1.0f,
                            ["High Quality Metal Ore"] = 1.0f,
                            ["Human Skull"] = 1.0f,
                            ["Leather"] = 1.0f,
                            ["Metal Ore"] = 1.0f,
                            ["Pork"] = 1.0f,
                            ["Raw Chicken Breast"] = 1.0f,
                            ["Raw Human Meat"] = 1.0f,
                            ["Raw Wolf Meat"] = 1.0f,
                            ["Stones"] = 1.0f,
                            ["Sulfur Ore"] = 1.0f,
                            ["Wolf Skull"] = 1.0f,
                            ["Wood"] = 1.0f,
                            ["Raw Deer Meat"] = 1.0f,
                            ["Cactus Flesh"] = 1.0f
                        },
                        _quarryRates = new Dictionary<string, float>
                        {
                            ["High Quality Metal Ore"] = 1.0f,
                            ["Sulfur Ore"] = 1.0f,
                            ["Stones"] = 1.0f,
                            ["Metal Fragments"] = 1.0f,
                            ["Crude Oil"] = 1.0f
                        },
                        _excavatorRates = GameManager.server.FindPrefab(Constants.ExcavatorArmPrefab)
                            .GetComponent<ExcavatorArm>()?.resourcesToMine
                            .ToDictionary(x => x.itemDef.displayName.english, x => 1f),
                        _pickupRates = new Dictionary<string, float>
                        {
                            ["Metal Ore"] = 1.0f,
                            ["Stones"] = 1.0f,
                            ["Sulfur Ore"] = 1.0f,
                            ["Wood"] = 1.0f,
                            ["Hemp Seed"] = 1.0f,
                            ["Corn Seed"] = 1.0f,
                            ["Pumpkin Seed"] = 1.0f,
                            ["Cloth"] = 1.0f,
                            ["Pumpkin"] = 1.0f,
                            ["Corn"] = 1.0f,
                            ["Wolf Skull"] = 1.0f
                        }
                    };

                    ItemManager.GetItemDefinitions().ForEach(def =>
                    {
                        var cookable = def.GetComponent<ItemModCookable>();
                        if (!cookable)
                            return;
                        modifiers.SmeltRates[def.displayName.english] = cookable.cookTime;
                    });

                    return modifiers;
                }
            }


            #endregion

            public float GetModifier(RateType type, Item item)
            {
                if (type == RateType.Gather)
                    return GetModifier(item.info, _gatherRates);
                if (type == RateType.Quarry)
                    return GetModifier(item.info, _quarryRates);
                if (type == RateType.Excavator)
                    return GetModifier(item.info, _excavatorRates);
                if (type == RateType.Pickup)
                    return GetModifier(item.info, _pickupRates);
                return 1f;
            }

            private float GetModifier(ItemDefinition def, Dictionary<string, float> data)
            {
                float mod;
                if (data.TryGetValue(def.displayName.english, out mod) || data.TryGetValue(def.shortname, out mod))
                    return mod;
                return 1f;
            }
        }

        #endregion

        #region Coal and HQM⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

         private class HqmConfig
        {
            [JsonProperty("Добавить МВК в список бонусов всех рудных жил")]
            public bool AddHqm;

            [JsonProperty("Количество МВК в жиле")]
            private int _amount;

            [JsonIgnore]
            public ItemDefinition HqmDefinition;
            
            [JsonIgnore]
            public ItemAmount ItemAmount => new ItemAmount(HqmDefinition, _amount);

            #region Default Config⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

            public static HqmConfig DefaultConfig => new HqmConfig
            {
                AddHqm = false,
                _amount = 2
            };

            #endregion

            [OnDeserialized]
            internal void OnDeserializedMethod(StreamingContext context)
            {
                HqmDefinition = ItemManager.FindItemDefinition("hq.metal.ore");
            }
        }

        private class CoalConfig
        {
            [JsonProperty("Шанс производства")]
            private int _chance;
            [JsonProperty("Количество")]
            public int Amount;

            //UnityEngine.Random.Range(0f, 1f) > burnable.byproductChance
            [JsonIgnore]
            public float Chance;

            #region Default Config⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

            public static CoalConfig DefaultConfig
            {
                get
                {
                    var coal = ItemManager.FindItemDefinition("wood").GetComponent<ItemModBurnable>();
                    return new CoalConfig
                    {
                        _chance = Mathf.RoundToInt(100 - coal.byproductChance*100),
                        Amount = coal.byproductAmount
                    };
                }
            }

            #endregion

            public static CoalConfig Save()
            {
                var coal = ItemManager.FindItemDefinition("wood").GetComponent<ItemModBurnable>();
                return new CoalConfig
                {
                    Amount = coal.byproductAmount,
                    Chance = coal.byproductChance
                };
            }
            
            [OnDeserialized]
            internal void OnDeserializedMethod(StreamingContext context)
            {
                if (Amount < 0)
                    Amount = 0;
                if (_chance <= 0 || Amount <= 0)
                    Chance = 2;
                else
                    Chance = (100 - _chance) / 100f;
            }
        }

        private class CoalConfigs
        {
            [JsonProperty("Днём")]
            public CoalConfig Day;
            [JsonProperty("Ночью")]
            public CoalConfig Night;

            #region Default Config⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

            public static CoalConfigs DefaultConfig => new CoalConfigs
            {
                Day = CoalConfig.DefaultConfig,
                Night = CoalConfig.DefaultConfig
            };

            #endregion

            public CoalConfig Get(bool isDay) => isDay ? Day : Night;
        }

        #endregion

        #region Loot⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        
        private class AllowedItemsConfig
        {
            [JsonProperty("Тип списка (0 - никак не управлять предметами, 1 - чёрный список, 2 - белый список).")]
            private int _type;

            [JsonProperty("Список предметов")]
            public List<string> Items;
            
            #region Default Config⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

            public static AllowedItemsConfig DefaultConfig => new AllowedItemsConfig
            {
                _type = 1,
                Items = new List<string> { "Blueprint","Rotten Apple", "Spoiled Wolf Meat", "Spoiled Chicken", "Spoiled Human Meat"}
            };

            #endregion

            public bool ShouldChange(Item item)
            {
                switch (_type)
                {
                    case 1:
                        return !Items.Any(x => x == item.info.displayName.english || x == item.info.shortname);
                    case 2:
                        return Items.Any(x => x == item.info.displayName.english || x == item.info.shortname);
                    default:
                        return true;
                }
            }
        }

        private class LootConfig
        {
            [JsonProperty("Предметы, на которые действуют множители")]
            public AllowedItemsConfig AllowedItems;
            [JsonProperty("Предметы, которые не будут выпадать вообще")]
            public List<string> BlackList;

            #region Default Config⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

            public static LootConfig DefaultConfig => new LootConfig
            {
                AllowedItems = AllowedItemsConfig.DefaultConfig,
                BlackList = new List<string>{"Rotten Apple"}
            };

            #endregion

            public bool ShouldDrop(Item item) =>
                !BlackList.Any(x => x == item.info.displayName.english || x == item.info.shortname);
        }

        #endregion

        private class PluginConfig
        {
            [JsonProperty("Настройки сообщений в чате")]
            public ChatConfig ChatConfig;

            [JsonProperty("Настройки даты и времени")]
            public TimeConfig TimeConfig;

            [JsonProperty("Металл высокого качества")]
            public HqmConfig HqmConfig;

            [JsonProperty("Производство угля при сжигании дерева")]
            public CoalConfigs CoalConfigs;

            [JsonProperty("Настройки лута")]
            public LootConfig LootConfig;

            [JsonProperty("Общие множители")]
            public Rates DefaultRates;

            [JsonProperty("Множители по привилегиям")]
            public Dictionary<string, Rates> CustomRates;

            [JsonProperty("Множители ресурсов")]
            public DefaultModifiers DefaultModifiers;

            #region Default Config⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

            public static PluginConfig DefaultConfig => new PluginConfig
            {
                ChatConfig = ChatConfig.DefaultConfig,
                TimeConfig = TimeConfig.DefaultConfig,
                HqmConfig = HqmConfig.DefaultConfig,
                CoalConfigs = CoalConfigs.DefaultConfig,
                LootConfig = LootConfig.DefaultConfig,
                DefaultRates = Rates.Default,
                CustomRates = new Dictionary<string, Rates>
                {
                    [nameof(RatesController)+".vip"] = Rates.DefaultWith(2f),
                    [nameof(RatesController)+".premium"] = Rates.DefaultWith(3f)
                },
                DefaultModifiers = DefaultModifiers.DefaultConfig
            };
            #endregion
            
        }

        #endregion

        #region Data⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        private class PluginData
        {
            public bool IsFrozen;
        }

        #endregion

        #region Config and Data initialization⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        #region Data⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        private void LoadData()
        {
            try
            {
                _data = Interface.Oxide.DataFileSystem.ReadObject<PluginData>(Title);
            }
            catch (Exception ex)
            {
                PrintError($"Failed to load data (is the file corrupt?) - no previously created recycles would work ({ex.Message})");
                _data = new PluginData();
            }
        }
        private void SaveData()
        {
            if(TimeController.Initialized)
                _data.IsFrozen = TimeController.Instance.IsFrozen;
            Interface.Oxide.DataFileSystem.WriteObject(Title, _data);
        }

        #endregion

        #region Config⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<PluginConfig>();
           
            foreach (var customRate in _config.CustomRates)
            {
                permission.RegisterPermission(customRate.Key,this);
            }

            if (CheckConfig())
                SaveConfig();

            LoadData();
        }

        private bool CheckConfig()
        {
            bool res = false;
            if (_config.TimeConfig.DayLength < 0)
            {
                PrintWarning("Day length can't be less then 0, setting to 0");
                _config.TimeConfig.DayLength = 0;
                res = true;
            }

            if (_config.TimeConfig.NightLength < 0)
            {
                PrintWarning("Night length can't be less then 0, setting to 0");
                _config.TimeConfig.NightLength = 0;
                res = true;
            }

            if (_config.TimeConfig.DayLength == 0 && _config.TimeConfig.NightLength == 0)
            {
                PrintWarning("Both night and day length can't be 0 at the same time, setting day length to 30");
                _config.TimeConfig.DayLength = 30;
                res = true;
            }
            return res;
        }

        protected override void LoadDefaultConfig()
        {
            _config = PluginConfig.DefaultConfig;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        #endregion

        #endregion

        #region Localization⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        private static string GetMessage(string langKey, string playerId = null)
        {
            return _ratesController.lang.GetMessage(langKey, _ratesController, playerId);
        }

        private static string GetMessage(string langKey, string playerId = null, params object[] args)
        {
            return args.Length == 0 ? GetMessage(langKey, playerId) : string.Format(GetMessage(langKey, playerId), args);
        }

        private static void SendResponse(BasePlayer player, string langKey, params object[] args)
        {
            if (!player || !player.IsConnected)
                return;
            player.ChatMessage(string.Format(_config.ChatConfig.ChatFormat, GetMessage(langKey, player.UserIDString, args)));
        }

        private static void SendResponse(IPlayer player, string langKey, params object[] args)
        {
            player.Reply(string.Format(_config.ChatConfig.ChatFormat, GetMessage(langKey, player.Id, args)));
        }
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [RateType.Quarry] = "Quarry gather rates: {0}",
                [RateType.Excavator] = "Excavator gather rates: {0}",
                [RateType.Gather] = "Gather rates: {0}",
                [RateType.Loot] = "Loot rates: {0}",
                [RateType.Pickup] = "Pickup rates: {0}",
                [RateType.OvenSpeed] = "Oven speed: {0}",
                ["RatesPersonal"] = "Your personal rates:\n{0}",
                ["DayStarted"] = "The day has come!\n{0}",
                ["NightStarted"] ="The night has come!\n{0}",
                ["PositiveRate"] = "<color=green>{0:P0}</color>",
                ["NegativeRate"] = "<color=red>{0:P0}</color>",
                ["NeutralRate"] = "{0:P0}"
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [RateType.Quarry] = "Добываемые ресурсы в карьере: {0}",
                [RateType.Excavator] = "Добываемые ресурсы в экскаваторе: {0}",
                [RateType.Gather] = "Добываемые ресурсы: {0}",
                [RateType.Loot] = "Получаемый лут: {0}",
                [RateType.Pickup] = "Подбираемые ресурсы: {0}",
                [RateType.OvenSpeed] = "Скорость печей: {0}",
                ["RatesPersonal"] = "Ваши личные рейты:\n{0}",
                ["DayStarted"] = "Наступает день!\n{0}",
                ["NightStarted"] ="Наступает ночь!\n{0}",
                ["PositiveRate"] = "<color=green>{0:P0}</color>",
                ["NegativeRate"] = "<color=red>{0:P0}</color>",
                ["NeutralRate"] = "{0:P0}"
            }, this, "ru");

        }

        #endregion
        
        #region Time controller⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        
        private class TimeController: FacepunchBehaviour
        {
            private int _attempt;
            private TOD_Sky _sky;
            private TOD_Time _time;
            private bool _isDaySet;
            private float _lastKnownTime; //env.time set workaround
            private bool _initialized;

            public static TimeController Instance { get; private set; }
            public static bool Initialized => Instance && Instance._initialized;

            #region Instance public properties⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

            public bool IsFrozen
            {
                get { return !_time.ProgressTime; }
                set { _time.ProgressTime = !value; }
            }

            #endregion

            #region Private properties⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

            private bool IsDay => DayStart <= _sky.Cycle.Hour && _sky.Cycle.Hour < NightStart;

            private float DayStart
            {
                get
                {
                    if (!_config.TimeConfig.DayNightSwitchConfig.UseSun)
                        return _config.TimeConfig.DayNightSwitchConfig.DayStartHour;
                    return _sky.SunriseTime;
                }
            }

            private float NightStart
            {
                get
                {
                    if (!_config.TimeConfig.DayNightSwitchConfig.UseSun)
                        return _config.TimeConfig.DayNightSwitchConfig.NightStartHour;
                    return _sky.SunsetTime;
                }
            }

            private float DayLength
            {
                get
                {
                    if (!_config.TimeConfig.DayNightSwitchConfig.UseSun)
                        return _config.TimeConfig.DayLength * _config.TimeConfig.DayNightSwitchConfig.DayMultiplier;
                    return _config.TimeConfig.DayLength * (24.0f / (_sky.SunsetTime - _sky.SunriseTime));
                }
            }

            private float NightLength
            {
                get
                {
                    if (!_config.TimeConfig.DayNightSwitchConfig.UseSun)
                        return _config.TimeConfig.NightLength * _config.TimeConfig.DayNightSwitchConfig.NightMultiplier;
                    return _config.TimeConfig.NightLength * (24.0f / (24.0f - (_sky.SunsetTime - _sky.SunriseTime)));
                }
            }

            #endregion

            #region Initialization⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

            public void Initialize()
            {
                _sky = TOD_Sky.Instance;
                if (_sky == null)
                {
                    if (_attempt++ < 10)
                    {
                        Invoke(Initialize,1f);
                        return;
                    }
                    _ratesController.PrintError("Failed to get TOD_Sky instance in {0} attempts.");
                    return;
                }
                _ratesController.Puts("TOD_Sky found after {0} attempts", _attempt);
                _time = _sky.Components.Time;
                if (_time == null)
                {
                    _ratesController.PrintError("Can't find time component!");
                    return;
                }
                
                _initialized = true;

                SetData();
                
                if(IsDay)
                    OnDayStarted();
                else
                    OnNightStarted();
                _time.OnHour += OnHour;
            }
            
            private void SetData()
            {
                _time.UseTimeCurve = false;
                if (_config.TimeConfig.SavedDateConfig.Use)
                    _sky.Cycle.DateTime = _config.TimeConfig.SavedDateConfig.Date;
                if (_config.TimeConfig.RestoreState)
                    _time.ProgressTime = !_ratesController._data.IsFrozen;
                

                _lastKnownTime = _sky.Cycle.Hour;
            }

            #endregion
            
            #region Day/Night Switch⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
            
            private void OnDayStarted()
            {
                if (!Initialized)
                    return;
                var dayLength = DayLength;
                if (dayLength <= 0)
                {
                    print("Day skipped");
                    _sky.Cycle.Hour = NightStart;
                    _lastKnownTime = _sky.Cycle.Hour;
                    OnNightStarted();
                    return;
                }

                _time.DayLengthInMinutes = dayLength;
                Interface.CallHook("OnDayStarted");
                _isDaySet = true;
            }

            private void OnNightStarted()
            {
                if (!Initialized)
                    return;
                var nightLength = NightLength;
                if (nightLength <= 0)
                {
                    print("Night skipped");
                    _sky.Cycle.Hour += 24 - _sky.Cycle.Hour + DayStart;
                    _lastKnownTime = _sky.Cycle.Hour;
                    OnDayStarted();
                    return;
                }

                _time.DayLengthInMinutes = nightLength;
                Interface.CallHook("OnNightStarted");
                _isDaySet = false;
            }

            #endregion
            
            #region Actions⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
            private void OnHour()
            {
                if(IsDay && !_isDaySet)
                    OnDayStarted();
                if(!IsDay && _isDaySet)
                    OnNightStarted();
            }

            //env.time set workaround
            private void Update()
            {
                if (Math.Abs(_sky.Cycle.Hour - _lastKnownTime) > Time.deltaTime)
                    OnHour();
                _lastKnownTime = _sky.Cycle.Hour;
            }

            #endregion
          
            public void Kill()
            {
                _time.OnHour -= OnHour;
                Destroy(gameObject);
                Instance = null;
            }

            public static TimeController Create()
            {
                if (Instance)
                {
                    _ratesController.PrintWarning("TimeController wasn't destroyed");
                    Instance.Kill();
                }
                var go = new GameObject(nameof(RatesController) + "." + nameof(TimeController));
                DontDestroyOnLoad(go);
                Instance = go.AddComponent<TimeController>();
                return Instance;
            }
        }

        #endregion

        #region Initialization and quitting⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        private void Init()
        {
            _ratesController = this;
        }
        private void Unload()
        {
            OvenController.KillAll();
            LootController.KillAll();
            TimeController.Instance?.Kill();
            UpdateCoalRates(true);
            OnServerSave();
            foreach (var pair in _smeltRatesBackup)
                pair.Key.cookTime = pair.Value;
            
            _config = null;
            _ratesController = null;
            _data = null;
            _defaultCoal = null;
            _smeltRatesBackup.Clear();
            _smeltRatesBackup = null;
            _quarryOwners.Clear();
            _quarryOwners = null;
            _customCookables.Clear();
            _customCookables = null;
        }

        private void OnServerSave() =>  SaveData();
        private void OnServerInitialized()
        {
            _defaultCoal = CoalConfig.Save();
            TimeController.Create().Initialize();
            ItemManager.GetItemDefinitions().ForEach(SetCookableDefinition);
            UpdateCoalRates();
            foreach (var oven in BaseNetworkable.serverEntities.OfType<BaseOven>())
                OvenController.GetOrAdd(oven).TryRestart();

        }

        
        #endregion

        #region Time Hooks⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        
        private void OnDayStarted()
        {
            _isDay = true;
            OvenController.TryRestartAll();
            UpdateCoalRates();
            if (!_config.ChatConfig.NotifyTod)
                return;
            foreach (var player in BasePlayer.activePlayerList)
                SendRates(player, "DayStarted");
            
        }

        private void OnNightStarted()
        {
            _isDay = false;
            OvenController.TryRestartAll();
            UpdateCoalRates();
            if (!_config.ChatConfig.NotifyTod)
                return;
            foreach (var player in BasePlayer.activePlayerList)
                SendRates(player, "NightStarted");
        }

        #endregion
        
        #region Oxide Hooks (Sub)⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        void OnItemRemove(Item item)
        {
            _customCookables.Remove(item);
        }
        void OnQuarryToggled(MiningQuarry quarry, BasePlayer player)
        {
            if (!player || !quarry || !quarry.IsOn() || quarry.OwnerID != 0)
                return;
            _quarryOwners[quarry.net.ID.Value] = player.UserIDString;
        }
        void OnExcavatorResourceSet(ExcavatorArm arm, string resource, BasePlayer player)
        {
            if (!player || !arm || arm.OwnerID != 0)
                return;
            _quarryOwners[arm.net.ID.Value] = player.UserIDString;
        }

        private void CanMoveItem(Item item, PlayerInventory playerLoot, ulong targetContainer, int targetSlot, int amount)
        {
            var container = item.GetRootContainer()?.entityOwner as LootContainer;
            if (!container)
                return;
            LootController.GetOrAdd(container).OnMove(item.position, playerLoot,amount);
        }

        private void OnItemAddedToContainer(ItemContainer inventory, Item item)
        {
            var container = item.GetRootContainer()?.entityOwner as LootContainer;
            if (!container)
                return;
            LootController.GetOrAdd(container).OnRefill(inventory);
        }
        #endregion

        #region Oxide Hooks (Rates)⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        
        void OnQuarryGather(MiningQuarry quarry, Item item)
        {
            UpdateAmount(item, RateType.Quarry, GetQuarryOwner(quarry));
        } 
       
        void OnExcavatorGather(ExcavatorArm arm, Item item)
        {
            UpdateAmount(item, RateType.Excavator, GetQuarryOwner(arm));
        }

        void OnDispenserGather(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            UpdateAmount(item, RateType.Gather, player.UserIDString);
            if (!_config.HqmConfig.AddHqm || dispenser.gatherType != ResourceDispenser.GatherType.Ore)
                return;
            if (dispenser.finishBonus.Any(x => x.itemDef == _config.HqmConfig.HqmDefinition))
                return;
            dispenser.finishBonus.Add(_config.HqmConfig.ItemAmount);
        }

        void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            UpdateAmount(item, RateType.Gather, player.UserIDString);
        }

        void OnCollectiblePickup(Item item, BasePlayer player, CollectibleEntity collectible)
        {
            UpdateAmount(item, RateType.Pickup, player.UserIDString);
        }

        void OnGrowableGathered(GrowableEntity plant, Item item, BasePlayer player)
        {
            string owner = player.UserIDString;
            if (plant.OwnerID != 0)
                owner = plant.OwnerID.ToString();
            UpdateAmount(item, RateType.Pickup, owner);
        }
        private object OnOvenToggle(BaseOven oven, BasePlayer player)
        {
			if (oven.ShortPrefabName.Contains("furnace"))
			return null;
            return OvenController.GetOrAdd(oven).Switch(player);
        }
        private void OnLootEntity(BasePlayer player, LootContainer container)
        {
            LootController.GetOrAdd(container).OnOpen(player);
        }
        private void OnLootEntityEnd(BasePlayer player, LootContainer container)
        {
            LootController.GetOrAdd(container).OnClose(player);
        }

        private void OnContainerDropItems(ItemContainer container)
        {
            var lootContainer = container?.entityOwner as LootContainer;
            if (lootContainer == null)
                return;
            LootController.GetOrAdd(lootContainer).OnDropItems();
        }


        #endregion

        #region Console Commands⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        [ConsoleCommand("env.freeze")]
        private void FreezeCmd(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2) 
                return;
            if (!TimeController.Initialized)
                return;
            TimeController.Instance.IsFrozen = !TimeController.Instance.IsFrozen;
            arg.ReplyWith(TimeController.Instance.IsFrozen ? "Frozen" : "Unfrozen");
        }

        #endregion

        #region Chat Commands⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        [ChatCommand("Rates")]
        private void RatesCmd(BasePlayer player, string command, string[] args)
        {
            SendRates(player, "RatesPersonal");
        }

        #endregion

        #region CustomCookable (cooktimeLeft bypass)⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        private class CustomCookable
        {
            private float _cookTimeLeft;
            private readonly ItemModCookable _cookable;
            private readonly Item _item;

            public CustomCookable(Item item, ItemModCookable cookable)
            {
                _cookable = cookable;
                _cookTimeLeft = _cookable.cookTime;
                _item = item;
            }

            public void Cycle(float delta)
            {
                var temperature = _item.temperature;
                if (temperature < _cookable.lowTemp || temperature > _cookable.highTemp || _cookTimeLeft < 0f)
                {
                    if (_cookable.setCookingFlag && _item.HasFlag(global::Item.Flag.Cooking))
                    {
                        _item.SetFlag(global::Item.Flag.Cooking, false);
                        _item.MarkDirty();
                    }
                    return;
                }
                if (_cookable.setCookingFlag && !_item.HasFlag(global::Item.Flag.Cooking))
                {
                    _item.SetFlag(global::Item.Flag.Cooking, true);
                    _item.MarkDirty();
                }

                foreach (var step in SplitDeltaBy(delta, _cookable.cookTime))
                {
                    if (!InnerCycle(step))
                        return;
                }
            }

            #region Static methods

            public static CustomCookable GetOrCreate(Item item)
            {
                var component = item.info.GetComponent<ItemModCookable>();
                if (!component)
                    return null;
                CustomCookable cookable;
                if (_ratesController._customCookables.TryGetValue(item, out cookable))
                    return cookable;
                cookable = new CustomCookable(item,component);
                _ratesController._customCookables[item] = cookable;
                return cookable;
            }

            #endregion

            #region Private methods

            private bool InnerCycle(float delta)
            {
                _cookTimeLeft -= delta;
                if (_cookTimeLeft > 0f)
                    return true;
                
                if (_item.amount > 1)
                {
                    _cookTimeLeft += _cookable.cookTime;
                    _item.amount--;
                    _item.MarkDirty();
                    SpawnCookable();
                    return true;
                }
                _item.Remove();
                SpawnCookable();
                return false;
            }

            private void SpawnCookable()
            {
                if (_cookable.becomeOnCooked == null)
                    return;
                Item item2 = ItemManager.Create(_cookable.becomeOnCooked, _cookable.amountOfBecome);
                if (item2 == null || item2.MoveToContainer(_item.parent, _item.position) ||
                    item2.MoveToContainer(_item.parent)) 
                    return;
                item2.Drop(_item.parent.dropPosition, _item.parent.dropVelocity);
                if (!_item.parent.entityOwner) 
                    return;
                var controller = _item.parent.entityOwner.GetComponent<OvenController>();
                if (controller != null)
                {
                    controller.OvenFull();
                }
            }

            #endregion
            
        }
        #endregion

        #region Oven Controller⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        private class OvenController : FacepunchBehaviour
        {
            private static readonly Dictionary<BaseOven, OvenController> Controllers = new Dictionary<BaseOven, OvenController>();
            private BaseOven _oven;
            private float _speed;
            private string _ownerId;

            private bool IsFurnace => (int) _oven.temperature >= 2;

            #region Awake and destroy
            private void Awake()
            {
                _oven = (BaseOven)gameObject.ToBaseEntity();
                _ownerId = _oven.OwnerID.ToString();
            }
            
            private void Kill()
            {
                if(_oven.IsOn())
                {
                    StopCooking();
                    _oven.StartCooking();
                }
                Destroy(this);
            }
            #endregion

            #region Public methods
            
            public object Switch(BasePlayer player)
            {
                var reply = 288;
                if (!IsFurnace || _oven.needsBuildingPrivilegeToUse && !player.CanBuild())
                    return null;

                if (_oven.IsOn())
                    StopCooking();
                else
                {
                    _ownerId = _oven.OwnerID != 0 ? _oven.OwnerID.ToString() : player.UserIDString;
                    StartCooking();
                }
                return false;
            }

            public void TryRestart()
            {
                if (!_oven.IsOn())
                    return;
                _oven.CancelInvoke(_oven.Cook);
                StopCooking();
                StartCooking();
            }

            public void OvenFull()
            {
                StopCooking();
            }

            #endregion
            
            #region Static methods⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

            public static OvenController GetOrAdd(BaseOven oven)
            {
                OvenController controller;
                if (Controllers.TryGetValue(oven, out controller))
                    return controller;
                controller = oven.gameObject.AddComponent<OvenController>();
                Controllers[oven] = controller;
                return controller;
            }

            public static void TryRestartAll()
            {
                foreach (var pair in Controllers)
                {
                    pair.Value.TryRestart();
                }
            }
            public static void KillAll()
            {
                foreach (var pair in Controllers)
                {
                    pair.Value.Kill();
                }
                Controllers.Clear();
            }

            #endregion

            #region Private methods

            private void StartCooking()
            {
                if (_oven.FindBurnable() == null)
                    return;
                _speed = 0.5f * _ratesController.GetUserRate(RateType.OvenSpeed, _ownerId); 

                _oven.inventory.temperature = _oven.cookingTemperature;
                _oven.UpdateAttachmentTemperature();
                InvokeRepeating(Cook, 0.5f, 0.5f);
                _oven.SetFlag(BaseEntity.Flags.On, true);
            }

            private void StopCooking()
            {
                _oven.UpdateAttachmentTemperature();
                if (_oven.inventory != null)
                {
                    _oven.inventory.temperature = 15f;
                    foreach (Item item in _oven.inventory.itemList)
                    {
                        if (!item.HasFlag(global::Item.Flag.OnFire)) 
                            continue;
                        item.SetFlag(global::Item.Flag.OnFire, false);
                        item.MarkDirty();
                    }
                }
                CancelInvoke(Cook);
                _oven.SetFlag(BaseEntity.Flags.On, false);
            }

            #endregion

            #region Custom cooking
            
            private void Cook()
            {
                Item fuel = _oven.FindBurnable();
                if (!_oven.IsOn() || fuel == null || !fuel.IsValid())
                {
                    StopCooking();
                    return;
                }
                
                // ReSharper disable once ForCanBeConvertedToForeach
                for (var index = 0; index < _oven.inventory.itemList.Count; index++)
                {
                    var item = _oven.inventory.itemList[index];
                    if (item.IsValid())
                        CustomCookable.GetOrCreate(item)?.Cycle(_speed);
                }

                BaseEntity slot = _oven.GetSlot(BaseEntity.Slot.FireMod);
                if (slot)
                    slot.SendMessage("Cook", _speed, SendMessageOptions.DontRequireReceiver);

                if (!fuel.HasFlag(global::Item.Flag.OnFire))
                {
                    fuel.SetFlag(global::Item.Flag.OnFire, true);
                    fuel.MarkDirty();
                }
                
                var burnable = fuel.info.GetComponent<ItemModBurnable>();
                var requiredFuel = _speed * (_oven.cookingTemperature / 200f);

                if (fuel.fuel >= requiredFuel)
                {
                    fuel.fuel -= requiredFuel;
                    if (fuel.fuel <= 0f)
                        _oven.ConsumeFuel(fuel, burnable);
                    return;
                }

                var itemsRequired = Mathf.CeilToInt(requiredFuel / burnable.fuelAmount);
                for (var i = 0; i < itemsRequired; i++)
                {
                    requiredFuel -= fuel.fuel;
                    _oven.ConsumeFuel(fuel,burnable);
                    if (!fuel.IsValid())
                        return;
                }

                fuel.fuel -= requiredFuel;
            }

            #endregion

        }
        
        #endregion

        #region Loot Controller⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        
        private class LootController : FacepunchBehaviour
        {
            private static readonly Dictionary<LootContainer, LootController> LootControllers = new Dictionary<LootContainer, LootController>();
            private LootContainer _lootContainer;
            private Dictionary<BasePlayer, ItemContainer> _containers;
            private bool ShouldBeUpdated => _lootContainer.initialLootSpawn && _lootContainer.shouldRefreshContents;
            private bool _destroyOnEmpty;

            #region Awake and destroy⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

            private void Awake()
            {
                _lootContainer = (LootContainer)gameObject.ToBaseEntity();
                _containers = new Dictionary<BasePlayer, ItemContainer>();
                _destroyOnEmpty = _lootContainer.destroyOnEmpty;
                if(ShouldBeUpdated) _lootContainer.destroyOnEmpty = false;
            }

            private void OnDestroy()
            {
                LootControllers.Remove(_lootContainer);
                foreach (var pair in _containers)
                {
                    if (pair.Key?.inventory?.loot?.containers?.Remove(pair.Value) == true)
                        pair.Key.inventory.loot.SendImmediate();
                    
                    pair.Value.Kill();
                }
                _containers.Clear();
                _containers = null;
            }
            private void Kill()
            {
                if(ShouldBeUpdated) _lootContainer.destroyOnEmpty = _destroyOnEmpty;
                Destroy(this);
            }

            #endregion

            #region Static Methods⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

            public static LootController GetOrAdd(LootContainer container)
            {
                LootController controller;
                if (LootControllers.TryGetValue(container, out controller)) 
                    return controller;

                controller = container.gameObject.AddComponent<LootController>();
                LootControllers[container] = controller;
                return controller;
            }

            public static void KillAll()
            {
                foreach (var pair in LootControllers)
                {
                    pair.Value.Kill();
                }
                LootControllers.Clear();
            }

            #endregion
            
            #region Private Methods⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

            private void RefillAll()
            {
                foreach (var pair in _containers)
                {
                    Refill(pair.Value,pair.Key);
                }
            }
            private void Refill(ItemContainer container, BasePlayer player)
            {
                while (container.itemList.Count > 0)
                {
                    var item = container.itemList[0];
                    item.RemoveFromContainer();
                    item.Remove();
                }
                FillItems(container,player);
            }
            private void FillItems(ItemContainer container, BasePlayer player)
            {
                foreach (var item in _lootContainer.inventory.itemList)
                {
                    if (!_config.LootConfig.ShouldDrop(item))
                        continue;

                    var copy = CreateCopy(item);

                    if (_config.LootConfig.AllowedItems.ShouldChange(copy))
                        _ratesController.UpdateAmount(copy, RateType.Loot, player.UserIDString);
                    container.Insert(copy);
                }
            }
            
            private ItemContainer CopyInventory()
            {
                var container =new ItemContainer
                {
                    allowedContents = _lootContainer.inventory.allowedContents,
                    availableSlots =  new List<ItemSlot>(_lootContainer.inventory.availableSlots),
                    canAcceptItem = _lootContainer.inventory.canAcceptItem,
                    capacity =  _lootContainer.inventory.capacity,
                    dirty = _lootContainer.inventory.dirty,
                    entityOwner = _lootContainer,
                    flags = _lootContainer.inventory.flags,
                    isServer = true,
                    maxStackSize = _lootContainer.inventory.maxStackSize,
                    onItemAddedRemoved = _lootContainer.inventory.onItemAddedRemoved,
                    onlyAllowedItems =  _lootContainer.inventory.onlyAllowedItems,
                    onPreItemRemove = _lootContainer.inventory.onPreItemRemove,
                    parent = _lootContainer.inventory.parent,
                    playerOwner = _lootContainer.inventory.playerOwner,
                    temperature = _lootContainer.inventory.temperature
                };
                container.GiveUID();
                return container;
            }

            private ItemContainer GetContainer(BasePlayer player)
            {
                ItemContainer container;
                if (_containers.TryGetValue(player, out container)) 
                    return container;

                container = CopyInventory();
                _containers[player] = container;
                Refill(container,player);
                return container;
            }
            #endregion

            #region Public Methods⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

            public void OnDropItems()
            {
                if (!ShouldBeUpdated)
                    return;
                var player = _lootContainer.lastAttacker as BasePlayer;
                if (!player)
                    return;
                foreach (var item in _lootContainer.inventory.itemList.ToArray())
                {
                    if (!_config.LootConfig.ShouldDrop(item))
                        item.Remove();

                    if (_config.LootConfig.AllowedItems.ShouldChange(item))
                        _ratesController.UpdateAmount(item,RateType.Loot, player.UserIDString);
                }
            }
            public void OnOpen(BasePlayer player)
            {
                if (!ShouldBeUpdated)
                    return;
                
                player.inventory.loot.AddContainer(GetContainer(player));
            }

            public void OnClose(BasePlayer player)
            {
                if (!ShouldBeUpdated)
                    return;
                var container = GetContainer(player);
                if (_destroyOnEmpty && !_lootContainer.IsDestroyed && (container?.itemList == null || container.itemList.Count == 0))
                    _lootContainer.Kill();
            }

            public void OnMove(int position, PlayerInventory playerLoot, int amount)
            {
                if (!ShouldBeUpdated)
                    return;
                var player =  (BasePlayer)playerLoot.gameObject.ToBaseEntity();
                _lootContainer.inventory.GetSlot(position)?.UseItem(amount);
                foreach (var pair in _containers)
                {
                    if (pair.Key == player)
                        continue;
                    pair.Value.GetSlot(position)?.UseItem(amount);
                }
            }

            public void OnRefill(ItemContainer container)
            {
                if (!ShouldBeUpdated || !_lootContainer.BlockPlayerItemInput ||container != _lootContainer.inventory || IsInvoking(RefillAll))
                    return;
                Invoke(RefillAll, 0.1f);
            }

            #endregion
        }


        #endregion

        #region Helpers⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        
        #region Chat⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        private void SendRates(BasePlayer player, string headerKey)
        {
            var rates = RateType.Available.Select(x => FormatRates(x, player.UserIDString));
            SendResponse(player, headerKey, string.Join("\n", rates));
        }

        private string FormatRates(RateType type, string userId)
        {
            var rate = GetUserRate(type, userId);
            var rateFormat = rate > 1f ? "PositiveRate" : rate < 1f ? "NegativeRate" : "NeutralRate";
            return GetMessage(type, userId, GetMessage(rateFormat, userId, rate));
        }

        #endregion
        
        #region Quarry⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        public string GetQuarryOwner(BaseEntity quarry)
        {
            string owner;
            if (quarry.OwnerID != 0 || !_quarryOwners.TryGetValue(quarry.net.ID.Value, out owner))
                owner = quarry.OwnerID.ToString();
            return owner;
        }

        #endregion
        
        #region Definition updater⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        private void UpdateCoalRates(bool restore = false)
        {
            var coal = ItemManager.FindItemDefinition("wood").GetComponent<ItemModBurnable>();
            var config = restore ? _defaultCoal : _config.CoalConfigs.Get(_isDay);
            coal.byproductAmount = config.Amount;
            coal.byproductChance = config.Chance;
        }

        private void SetCookableDefinition(ItemDefinition def)
        {
            var cookable = def.GetComponent<ItemModCookable>();
            if (!cookable)
                return;
            _smeltRatesBackup[cookable] = cookable.cookTime;
            float time;
            if (_config.DefaultModifiers.SmeltRates.TryGetValue(def.displayName.english, out time) ||
                _config.DefaultModifiers.SmeltRates.TryGetValue(def.shortname, out time))
            {
                cookable.cookTime = time;
            }
        }

        #endregion

        #region Items

        private static Item CreateCopy(Item item)
        {
            var copy = new Item
            {
                isServer = true,
                info =  item.info,
                uid = new ItemId(Net.sv.TakeUID()),
                name = item.name,
                text = item.text,
                amount = item.amount,
                position = item.position,
                busyTime = item.busyTime,
                removeTime = item.removeTime,
                flags = item.flags,
                skin = item.skin,
                _condition = item._condition,
                _maxCondition = item._maxCondition
            };
            if (item.instanceData != null)
            {
                copy.instanceData = item.instanceData.Copy();
                copy.instanceData.ShouldPool = false;
            }
            copy.OnItemCreated();
            copy.OnVirginSpawn();
            return copy;
        }

        #endregion

        private static IEnumerable<float> SplitDeltaBy(float delta, float step)
        {
            for(var i =0; i < Mathf.FloorToInt(delta/step); i++)
                yield return step;
            var modulo = delta%step;
            if(modulo > 0)
                yield return modulo;
        }
        
        private void UpdateAmount(Item item, RateType type, string userId)
        {
            var modifier = GetUserRate(type, userId) * _config.DefaultModifiers.GetModifier(type, item);
            var amount = Mathf.RoundToInt(item.amount * modifier);
            amount = amount < 1 ? 1 : amount;
            item.amount = item.info.stackable <= amount ? item.info.stackable : amount;
        }

        private float GetUserRate(RateType rate, string userId)
        {
            ulong playerid = 294912;
            var possibleRates = _config.CustomRates.Where(x => permission.UserHasPermission(userId, x.Key))
                .Select(x => x.Value.GetRate(rate, _isDay));
            return possibleRates.DefaultIfEmpty(_config.DefaultRates.GetRate(rate, _isDay)).Max();
            //return possibleRates.Aggregate(_config.DefaultRates.GetRate(rate,_isDay), (x, y) => x > y ? x : y);
        }
        
        #endregion
    }
}


// --- End of file: RatesController.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/Crosshair.cs ---
// --- Original Local Path: TrashRust/Crosshair.cs ---

﻿using System.Collections.Generic;
using System.Globalization;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Crosshair", "MisterPixie", "3.1.0")]
    [Description("Allows the user to toggle a crosshair")]

    class Crosshair : RustPlugin
    {
        private string mainUI = "UI_MAIN";
        private CuiElementContainer _ui;
        private HashSet<string> _crosshairSettings = new HashSet<string>();
        private const string _usePerm = "crosshair.use";

        #region Classes
        private class UI
        {
            public static CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool cursor = false)
            {
                var newElement = new CuiElementContainer
                {
                    {
                        new CuiPanel
                        {
                            Image = {Color = color},
                            RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                            CursorEnabled = cursor
                        },
                        new CuiElement().Parent = "Hud",
                        panelName
                    }
                };

                return newElement;
            }

            public static void CreateLabel(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter, float fadein = 1f)
            {
                container.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, FadeIn = fadein, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                }, panel, CuiHelper.GetGuid());
            }
        }
        #endregion

        #region Methods
        private void ToggleCrosshair(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, _usePerm))
            {
                PrintToChat(player, Lang("No Permission", player.UserIDString));
                return;
            }

            if (_crosshairSettings.Contains(player.UserIDString))
            {
                DestroyCrosshair(player);
                _crosshairSettings.Remove(player.UserIDString);
                player.ChatMessage(Lang("CrosshairOff", player.UserIDString));
                return;
            }

            CuiHelper.AddUi(player, _ui);
            _crosshairSettings.Add(player.UserIDString);
            player.ChatMessage(Lang("CrosshairOn", player.UserIDString));

        }

        private void DestroyCrosshair(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, mainUI);
        }

        private void DestroyAllCommand(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null) return;

            DestroyCrosshair(player);
        }

        private void CreateUI()
        {
            var container = UI.CreateElementContainer(mainUI, $"{HexToColor("000000")} 0", "0.469 0.467", "0.53 0.53");
            UI.CreateLabel(ref container, mainUI, $"{HexToColor(configData.CrosshairColor)} 0.9", configData.CrosshairText, 16, "0 0", "1 1");
            _ui = container;
        }
        private static string HexToColor(string hexColor)
        {
            if (hexColor.IndexOf('#') != -1) hexColor = hexColor.Replace("#", "");

            var red = 0;
            var green = 0;
            var blue = 0;

            if (hexColor.Length == 6)
            {
                red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);
            }
            else if (hexColor.Length == 3)
            {
                red = int.Parse(hexColor[0] + hexColor[0].ToString(), NumberStyles.AllowHexSpecifier);
                green = int.Parse(hexColor[1] + hexColor[1].ToString(), NumberStyles.AllowHexSpecifier);
                blue = int.Parse(hexColor[2] + hexColor[2].ToString(), NumberStyles.AllowHexSpecifier);
            }

            return $"{(double)red / 255} {(double)green / 255} {(double)blue / 255}";
        }
        #endregion

        #region Hooks
        private void Init()
        {
            LoadVariables();
            permission.RegisterPermission("crosshair.use", this);
            cmd.AddChatCommand("crosshair", this, "ToggleCrosshair");
            cmd.AddConsoleCommand("ui_destroy", this, "DestroyAllCommand");
            CreateUI();
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                DestroyCrosshair(player);
            }
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            DestroyCrosshair(player);
            _crosshairSettings.Remove(player.UserIDString);
        }
        #endregion

        #region lang
        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"CrosshairOn", "Crosshair turned on."},
                {"CrosshairOff", "Crosshair turned off."},
                {"No Permission", "Error, you lack permission."}
            }, this);
        }
        #endregion

        #region Config
        private ConfigData configData;
        private class ConfigData
        {
            public string CrosshairColor;
            public string CrosshairText;
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                CrosshairColor = "#FF0000",
                CrosshairText = "·"
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion
    }
}

// --- End of file: Crosshair.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/SkinBox.cs ---
// --- Original Local Path: TrashRust/SkinBox.cs ---

using System;using System.Collections.Generic;using System.Collections;using System.Linq;using UnityEngine;using Rust;using Oxide.Core;using Oxide.Core.Libraries;using Oxide.Core.Plugins;using Newtonsoft.Json;using Newtonsoft.Json.Serialization;using Oxide.Game.Rust.Cui;namespace Oxide.Plugins {	/* Based on 1.10.2 version by Fujikura */    [Info("SkinBox", "Nimant", "1.0.10")]    class SkinBox : RustPlugin     {		private static SkinBox instance;		        private bool skinsLoaded;                private static SkinBox skinBox = null;        private bool isValidated = false;        		        private static Dictionary<string, LinkedList<ulong>> skinsCache = new Dictionary<string, LinkedList<ulong>>();                private static Dictionary<string, int> approvedSkinsCount = new Dictionary<string, int>();                private static Dictionary<string, DateTime> cooldownTimes = new Dictionary<string, DateTime>();        private static Dictionary<string, string> NameToItemName = new Dictionary<string, string>();        private static Dictionary<string, string> ItemNameToName = new Dictionary<string, string>();                private static List<ulong> excludedSkins = new List<ulong>();		private static Dictionary <string, List<ulong>> manualAddedSkins = new Dictionary <string, List<ulong>>();        private static List<object> excludedSkinsPre = new List<object>();        private static Dictionary <ulong, Vector3> activeBoxUsers = new Dictionary <ulong, Vector3>();		        		        Coroutine _validateManualSkins;        Coroutine _validateExcludedSkins;        		        private static Dictionary<string, object> missingWorkshopNames()         {            var dp = new Dictionary<string, object>();            dp.Add("rug", "Rug");            dp.Add("chair", "Chair");            dp.Add("rug.bear", "Bearskin Rug");            dp.Add("mask.bandana", "Bandana");            dp.Add("table", "Table");            dp.Add("fridge", "Fridge");            return dp;        }        		      		                                                     protected override void LoadDefaultMessages()         {            lang.RegisterMessages(new Dictionary<string, string>             {                                {"NoPermission", "Недостаточно прав!"},                                 {"CooldownTime", "Что бы повторно поменять скины, вам нужно подождать {0} секунд."}                            },this);        }                private void Init()        {            LoadVariables();            LoadDefaultMessages();			            cmd.AddChatCommand("skin", this, "cmdSkinBox");			cmd.AddChatCommand("skins", this, "cmdSkinBox");			cmd.AddChatCommand("skinbox", this, "cmdSkinBox");						foreach(var permissionUse in configData.permissionsUse)				if (!permission.PermissionExists(permissionUse)) 					permission.RegisterPermission(permissionUse, this);                                               				            skinsCache = new Dictionary<string, LinkedList<ulong>>();                        approvedSkinsCount = new Dictionary<string, int>();            NameToItemName = new Dictionary<string, string>();            ItemNameToName = new Dictionary<string, string>();                        activeBoxUsers = new Dictionary <ulong, Vector3>();            skinsLoaded = false;            skinBox = this;        }                private void OnServerInitialized()         {			instance = this;            UnsubscribeAll();            timer.Once(65f, ()=> OnServerInit());			        }                private void Unload()         {            var objs = UnityEngine.Object.FindObjectsOfType<SkinBoxHandler>().ToList();            if (objs.Count > 0) 				foreach (var obj in objs) 				{					if (obj.looter == null) continue;					obj.looter.EndLooting();					obj.PlayerStoppedLooting(obj.looter);					GameObject.Destroy(obj);				}							foreach (BasePlayer player in BasePlayer.activePlayerList)								CuiHelper.DestroyUi(player, "Buttons");			                        if (Interface.Oxide.IsShuttingDown) return;			            if (_validateManualSkins != null) ServerMgr.Instance.StopCoroutine(_validateManualSkins);            if (_validateExcludedSkins != null) ServerMgr.Instance.StopCoroutine(_validateExcludedSkins);                    }                private void OnServerInit()         {            foreach (var itemtype in Rust.Workshop.Approved.All.Select(x=> x.Value).ToList())             {                if (itemtype.Skinnable.Name == null || itemtype.Skinnable.Name == string.Empty) continue;                if (itemtype.Skinnable.ItemName == null || itemtype.Skinnable.ItemName == string.Empty) continue;                if (!NameToItemName.ContainsKey(itemtype.Skinnable.Name.ToLower())) NameToItemName.Add(itemtype.Skinnable.Name.ToLower(), itemtype.Skinnable.ItemName.ToLower());                if (!ItemNameToName.ContainsKey(itemtype.Skinnable.ItemName.ToLower()))                                     ItemNameToName.Add(itemtype.Skinnable.ItemName.ToLower(), itemtype.Skinnable.Name.ToLower());                                                            }                        var tempMissing = new Dictionary<string, object>(configData.missingSkinNames);            			tempMissing["rifle.lr300"] = "Lr300";            foreach (var skin in tempMissing)             {                var itemname = skin.Key.ToLower();                var itemDef = ItemManager.FindItemDefinition(itemname);                if (itemDef == null) continue;                var workshopname = ((string)skin.Value).ToLower();                NameToItemName[workshopname] = itemname;                ItemNameToName[itemname] = workshopname;            }                        foreach (var manual in configData.manualAddedSkinsPre) manualAddedSkins.Add(manual.Key.ToString(), (manual.Value as List<ulong>).ConvertAll(obj => Convert.ToUInt64(obj)));            excludedSkins = configData.excludedSkinsPre.ConvertAll(obj => Convert.ToUInt64(obj));            _validateManualSkins = ServerMgr.Instance.StartCoroutine(ValidateManualSkins(new Dictionary <string, List<ulong>>(manualAddedSkins), done =>             {                int result1 = manualAddedSkins.Values.Sum(list => list.Count);                int result2 = done.Values.Sum(list => list.Count);                if (result1 != result2)                 {                    manualAddedSkins = new Dictionary <string, List<ulong>>(done);                    configData.manualAddedSkinsPre = manualAddedSkins;                    SaveConfig(configData);                }                                _validateExcludedSkins = ServerMgr.Instance.StartCoroutine(ValidateExcludedSkins(new List<ulong>(excludedSkins), done2 =>                 {                    if (excludedSkins.Count != done2.Count)                     {                        excludedSkins = new List<ulong>(done2);                        configData.excludedSkinsPre = excludedSkins;                        SaveConfig();                    }                                        _validateExcludedSkins = null;                    isValidated = true;                    GetItemSkins();                }                                ));                _validateManualSkins = null;            }));        }                private IEnumerator ValidateManualSkins(Dictionary <string, List<ulong>> skinDict, System.Action<Dictionary <string, List<ulong>>> done)         {            done(skinDict);            yield return done;        }                private IEnumerator ValidateExcludedSkins(List<ulong> skinList, System.Action<List<ulong>> done)         {                        done(skinList);            yield return done;        }        		private static string GetFixedItemName(string name) => name == "lr300.item" ? "rifle.lr300" : name;		        private void GetItemSkins()         {            if (skinsLoaded) return;            int countInbuilt = 0;            foreach (var itemDef in ItemManager.GetItemDefinitions())             {                List<ulong> skins = new List<ulong>{0};                skins.AddRange(ItemSkinDirectory.ForItem(itemDef).Select(skin => Convert.ToUInt64(skin.id)));                skinsCache.Add(GetFixedItemName(itemDef.shortname), new LinkedList<ulong>(skins));                if (skins.Count > 1) countInbuilt += (skins.Count -1);            }                        if (configData.showLoadedSkinCounts) Puts($"Загружено {countInbuilt} встроенных скинов.");            if (configData.useManualAddedSkins)             {                int countManual = 0;                foreach (var manualskins in manualAddedSkins)                 {                    string shortname = GetFixedItemName(manualskins.Key);                    if (!ItemNameToName.ContainsKey(shortname)) continue;                    string itemname = ItemNameToName[shortname];                    List<ulong> fileids = manualskins.Value;                    foreach (var fileid in fileids)                     {                        if (!skinsCache.ContainsKey(shortname))                         {                            skinsCache.Add(shortname, new LinkedList<ulong>());                            skinsCache[shortname].AddLast(0);                        }                                                if (!skinsCache[shortname].Contains(fileid))                         {                            skinsCache[shortname].AddLast(fileid);                            countManual++;                        }                                                                    }                                                        }                                if (configData.showLoadedSkinCounts && countManual > 0) Puts($"Загружено {countManual} скинов, добавленных вручную.");            }                        			int countApproved = 0;			foreach (var shopskin in Rust.Workshop.Approved.All.Select(x=> x.Value).Where(skin => skin.Skinnable.ItemName != null)) 			{				var skinName = GetFixedItemName(shopskin.Skinnable.ItemName);				if (!approvedSkinsCount.ContainsKey(skinName)) approvedSkinsCount[skinName] = 0;                                       				if (!skinsCache.ContainsKey(skinName)) skinsCache[skinName] = new LinkedList<ulong>();				if (!skinsCache[skinName].Contains(shopskin.WorkshopdId)) 				{					skinsCache[skinName].AddLast(shopskin.WorkshopdId);					approvedSkinsCount[skinName]++;					countApproved++;				}                                        			}						if (configData.showLoadedSkinCounts) Puts($"Загружено {countApproved} одобренных скинов.");                        			Interface.CallHook("OnSkinCacheUpdate", skinsCache, true);			skinsLoaded = true;                    }                                		[ConsoleCommand("skins.open")] 		private void consoleSkinsOpen(ConsoleSystem.Arg arg) => consoleSkinboxOpen(arg);				        [ConsoleCommand("skinbox.open")] 		private void consoleSkinboxOpen(ConsoleSystem.Arg arg)         {            if (arg == null) return;            if (arg.Connection == null)             {				if (!skinsLoaded)				{					SendReply(arg, "Подождите, идет инициализация плагина.");                    return;				}				                if  (arg.Args == null || arg.Args.Length == 0)                 {                    SendReply(arg, $"Команда 'skinbox.open' требует наличия SteamId в качестве параметра.");                    return;                }                                ulong argId = 0uL;                if (!ulong.TryParse(arg.Args[0], out argId))                 {                    SendReply(arg, $"Указан некорректный SteamId: '{arg.Args[0]}'.");                    return;                }                                BasePlayer argPlayer = BasePlayer.FindByID(argId);                if (argPlayer == null)                 {                    SendReply(arg, $"Не найден указанный игрок: '{argId}'.");                    return;                }                                if (!argPlayer.inventory.loot.IsLooting()) OpenSkinBox(argPlayer);            }                        else if(arg.Connection != null && arg.Connection.player != null)             {                BasePlayer player = arg.Player();                if (player.inventory.loot.IsLooting()) return;				                if (!HasPermission(player))                 {                    player.ChatMessage(lang.GetMessage("NoPermission", this, player.UserIDString));                    return;                }								if (!skinsLoaded)				{					player.ChatMessage("Подождите, идет инициализация плагина.");                    return;				}                                                if (configData.enableCooldown && !player.IsAdmin)                {                    DateTime now = DateTime.UtcNow;                    DateTime time;                    var key = player.UserIDString + "-box";                    if (cooldownTimes.TryGetValue(key, out time))                     {                        if (time > now.AddSeconds(-configData.cooldownBox))                         {                            player.ChatMessage(string.Format(lang.GetMessage("CooldownTime", this, player.UserIDString),(time - now.AddSeconds(-configData.cooldownBox)).Seconds));                            return;                        }                                                                    }                                                        }                                OpenSkinBox(player);            }                                }                private void cmdSkinBox(BasePlayer player, string command, string[] args)         {            if (player.inventory.loot.IsLooting()) return;            if (!HasPermission(player))            {                player.ChatMessage(lang.GetMessage("NoPermission", this, player.UserIDString));                return;            }						if (!skinsLoaded)			{				player.ChatMessage("Подождите, идет инициализация плагина.");				return;			}                                    if (configData.enableCooldown && !player.IsAdmin)             {                DateTime now = DateTime.UtcNow;                DateTime time;                var key = player.UserIDString + "-box";                if (cooldownTimes.TryGetValue(key, out time))                 {                    if (time > now.AddSeconds(-configData.cooldownBox))                     {                        player.ChatMessage(string.Format(lang.GetMessage("CooldownTime", this, player.UserIDString),(time - now.AddSeconds(-configData.cooldownBox)).Seconds));                        return;                    }                                                        }                                            }                        timer.Once(0.2f, () =>             {                OpenSkinBox(player);            });        }      		private bool HasPermission(BasePlayer player) 		{			if (player.IsAdmin)				return true;						foreach(var permissionName in configData.permissionsUse)				if (!string.IsNullOrEmpty(permissionName) && permission.UserHasPermission(player.UserIDString, permissionName))					return true;						return false;		}	                private sealed class SkinBoxHandler : MonoBehaviour         {            public bool isCreating;            public bool isBlocked;            public bool isCleaning;            public bool isEmptied;			public bool isPaging;            public int itemId;            public Item item;            public BasePlayer looter;            public ItemContainer otherLoot;			public ItemContainer showLoot;            public BaseEntity entityOwner;            public ulong skinId;			public int page;			public float lastOpen;						public static List<SkinBoxHandler> SkinBoxes = new List<SkinBoxHandler>();			            void Awake()             {                isCreating = false;                isBlocked = false;                isCleaning = false;                isEmptied = false;				isPaging = false;                showLoot = GetComponent<DroppedItemContainer>().inventory;                entityOwner = showLoot.entityOwner;				page = 1;				otherLoot = new ItemContainer();				otherLoot.ServerInitialize(null, 1000);				otherLoot.GiveUID();				lastOpen = UnityEngine.Time.realtimeSinceStartup;								try { SkinBoxes.RemoveAll(x=> x == null); } catch {}				SkinBoxes.Add(this);            }                        public void PlayerStoppedLooting(BasePlayer player)             {				                activeBoxUsers.Remove(player.userID);                if (!isEmptied && item != null)                 {                    isEmptied = true;                    player.GiveItem(item);                }				ClearContainer(otherLoot);				CuiHelper.DestroyUi(looter, "Buttons");		                if (activeBoxUsers.Count() == 0 && !Interface.Oxide.IsShuttingDown) skinBox.UnsubscribeAll();                if (!GetComponent<BaseEntity>().IsDestroyed) GetComponent<BaseEntity>().Kill(BaseNetworkable.DestroyMode.None);                if (configData.enableCooldown) cooldownTimes[player.UserIDString + "-box"] = DateTime.UtcNow;            }                        void OnDestroy()             {											                activeBoxUsers.Remove(looter.userID);                if (!isEmptied && item!= null)                 {                    isEmptied = true;                    looter.GiveItem(item);                }								ClearContainer(otherLoot);				CuiHelper.DestroyUi(looter, "Buttons");		                looter.EndLooting();								if (entityOwner != null)					GameObject.Destroy(entityOwner);								/*if ((UnityEngine.Time.realtimeSinceStartup - lastOpen) <= 0.5f)				{					if (looter != null)						instance.OpenSkinBox(looter);				}*/            }                                }                                private void OpenSkinBox(BasePlayer player)         {			if (player == null) return;						var ret = Interface.CallHook("SkinsCanUseSkins", player) as object;			if (ret != null)			{				if (ret is string)					SendReply(player, (string)ret);				return;			}            if (activeBoxUsers.Count() == 0) SubscribeAll();            						var skinBox = GameManager.server.CreateEntity("assets/prefabs/misc/item drop/item_drop_backpack.prefab", new Vector3(player.transform.position.x, -60f + UnityEngine.Random.Range(-4f, 4f), player.transform.position.z));			            var drop = skinBox as DroppedItemContainer;			drop.playerName = configData.skinBoxTitle;				drop.playerSteamID = player.userID;									drop.Spawn();																	drop.inventory = new ItemContainer();            drop.inventory.ServerInitialize(null, 36);			drop.inventory.entityOwner = drop;            drop.inventory.GiveUID();						Rigidbody rigidBody = drop.GetComponent<Rigidbody>();			rigidBody.useGravity = false;			rigidBody.isKinematic = true;            			drop.SetFlag(BaseEntity.Flags.Open, true, false);									            drop.gameObject.AddComponent<SkinBoxHandler>().looter = player;                        drop.inventory.capacity = 36;						            drop.SetFlag(BaseEntity.Flags.Open, true, false);						player.inventory.loot.StartLootingEntity(drop, false);						            player.inventory.loot.AddContainer(drop.inventory);						            player.inventory.loot.SendImmediate();						player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", drop.lootPanelName);			            drop.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);			            activeBoxUsers[player.userID] = player.transform.position;        }                private void StartLootingEntity(PlayerLoot loot, BaseEntity targetEntity)         {                                    loot.Clear();            if (!targetEntity) return;            			loot.PositionChecks = false;            loot.entitySource = targetEntity;            loot.itemSource = null;            			loot.MarkDirty();        }                private static void ClearContainer(ItemContainer container)         {            while (container.itemList.Count > 0)             {                var item = container.itemList[0];                item.RemoveFromContainer();                item.Remove(0f);            }                                }                private object CanAcceptItem(ItemContainer container, Item item)         {            if (container == null || item == null || container.entityOwner == null || container.entityOwner.GetComponent<SkinBoxHandler>() == null || 				container.entityOwner != container.entityOwner.GetComponent<SkinBoxHandler>().entityOwner || 				container.entityOwner.GetComponent<SkinBoxHandler>().isCreating || container.entityOwner.GetComponent<SkinBoxHandler>().isPaging) 				return null;            			if (container.entityOwner.GetComponent<SkinBoxHandler>().isBlocked || item.amount > 1 || item.isBroken || 				!skinsCache.ContainsKey(item.info.shortname) || (skinsCache[item.info.shortname] as LinkedList<ulong>).Count <= 1) 				return ItemContainer.CanAcceptResult.CannotAccept;				            return null;        }                                private void OnItemAddedToContainer(ItemContainer container, Item item)         {            if (container == null || item == null || container.entityOwner == null || container.entityOwner.GetComponent<SkinBoxHandler>() == null || 				container.entityOwner != container.entityOwner.GetComponent<SkinBoxHandler>().entityOwner || 				container.entityOwner.GetComponent<SkinBoxHandler>().isCreating || container.entityOwner.GetComponent<SkinBoxHandler>().isPaging) 				return;				            var lootHandler = container.entityOwner.GetComponent<SkinBoxHandler>();            lootHandler.isCreating = true;            lootHandler.itemId = item.info.itemid;            lootHandler.isEmptied = false;            string shortname = item.info.shortname;            bool hasCondition = item.hasCondition;            float condition = item.condition;			//float fuel = item.fuel;						if (item.contents != null && item.contents.itemList.Count > 0)			{				var array = item.contents.itemList.ToArray();				for (int i = 0; i < array.Length; i++)				{					if (array[i].info.category == ItemCategory.Weapon) continue;					var item2 = array[i];					lootHandler.looter.inventory.GiveItem(item2, null);				}			}			            float maxCondition = item.maxCondition;            bool isWeapon = item.GetHeldEntity() != null && item.GetHeldEntity() is BaseProjectile;            bool hasMods = false;            int contents = 0;            int capacity = 0;            ItemDefinition ammoType = null;            Dictionary<int, float> itemMods = new Dictionary<int, float>();            LinkedList<ulong>  itemSkins = skinsCache[shortname] as LinkedList<ulong>;						            if (isWeapon)             {                contents = (item.GetHeldEntity() as BaseProjectile).primaryMagazine.contents;                capacity = (item.GetHeldEntity() as BaseProjectile).primaryMagazine.capacity;                ammoType = (item.GetHeldEntity() as BaseProjectile).primaryMagazine.ammoType;                if (item.contents != null && item.contents.itemList.Count > 0)                 {                    hasMods = true;                    foreach ( var mod in item.contents.itemList) itemMods.Add(mod.info.itemid, mod.condition);                }                                            }                        item.RemoveFromContainer();            lootHandler.skinId = item.skin;            lootHandler.item = item;            container.capacity = itemSkins.Count();            var itemDef = ItemManager.FindItemDefinition(shortname);			int pos = 0;			bool paged = false;									            foreach (var skin in itemSkins)             {                				                if (excludedSkins.Contains(skin) && !lootHandler.looter.IsAdmin) continue;                Item newItem = ItemManager.Create(itemDef, 1, skin);                				if (hasCondition)                 {                    newItem.condition = condition;                    newItem.maxCondition = maxCondition;                }								//newItem.fuel = fuel;                                if (isWeapon)                 {                    (newItem.GetHeldEntity() as BaseProjectile).primaryMagazine.contents = contents;                    (newItem.GetHeldEntity() as BaseProjectile).primaryMagazine.capacity = capacity;                    (newItem.GetHeldEntity() as BaseProjectile).primaryMagazine.ammoType = ammoType;                    if (hasMods)                     {                        foreach ( var mod in itemMods)                         {                            Item newMod = ItemManager.CreateByItemID((int)mod.Key, 1);                            newMod.condition = Convert.ToSingle(mod.Value);                            newMod.MoveToContainer(newItem.contents, -1, false);                        }                                                newItem.contents.SetFlag(ItemContainer.Flag.IsLocked, true);                        newItem.contents.SetFlag(ItemContainer.Flag.NoItemInput, true);                    }                                                        }                												if (container.itemList.Count < 36)					newItem.MoveToContainer(container, pos, false);									else				{						newItem.MoveToContainer(lootHandler.otherLoot, pos, false);		                					paged = true;				}									pos++;            }            			if (paged) ShowButtons(lootHandler.looter);			            lootHandler.isCreating = false;            lootHandler.isBlocked = true;        }                private void OnItemRemovedFromContainer(ItemContainer container, Item item)         {            if (container == null || item == null || container.entityOwner == null || container.entityOwner.GetComponent<SkinBoxHandler>() == null || 				container.entityOwner != container.entityOwner.GetComponent<SkinBoxHandler>().entityOwner || 				container.entityOwner.GetComponent<SkinBoxHandler>().isCreating || container.entityOwner.GetComponent<SkinBoxHandler>().isCleaning ||				container.entityOwner.GetComponent<SkinBoxHandler>().isPaging) 				return;												            var loothandler = container.entityOwner.GetComponent<SkinBoxHandler>();            if (item.GetHeldEntity() != null && item.GetHeldEntity() is BaseProjectile)             {                if (item.contents != null)                 {                    item.contents.SetFlag(ItemContainer.Flag.IsLocked, false);                    item.contents.SetFlag(ItemContainer.Flag.NoItemInput, false);                }                                            }                        loothandler.isCleaning = true;            ClearContainer(container);			ClearContainer(loothandler.otherLoot);			CuiHelper.DestroyUi(loothandler.looter, "Buttons");			loothandler.page = 1;            loothandler.isCleaning = false;						if (loothandler.skinId != item.skin)				Interface.CallHook("SkinsOnSkinChanged", loothandler.looter, item, loothandler.skinId);						            if (loothandler.item != null)             {                loothandler.item.Remove(0f);                loothandler.item = null;            }                        loothandler.isEmptied = true;            container.capacity = 36;            loothandler.isBlocked = false;            if (item.skin == 0uL)             {                loothandler.skinId = 0uL;                return;            }                                                if (configData.enableCooldown && configData.activateAfterSkinTaken && !loothandler.looter.IsAdmin && item.skin != loothandler.skinId)             {                activeBoxUsers.Remove(loothandler.looter.userID);                loothandler.looter.EndLooting();                cooldownTimes[loothandler.looter.UserIDString + "-box"] = DateTime.UtcNow;            }                        loothandler.skinId = 0uL;        }                private void UnsubscribeAll()         {			try { Unsubscribe(nameof(CanAcceptItem)); } catch { PrintWarning("Ошибка отписки хука CanAcceptItem"); }            try { Unsubscribe(nameof(OnItemAddedToContainer)); } catch { PrintWarning("Ошибка отписки хука OnItemAddedToContainer"); }            try { Unsubscribe(nameof(OnItemRemovedFromContainer)); } catch { PrintWarning("Ошибка отписки хука OnItemRemovedFromContainer"); }        }                private void SubscribeAll()         {            try { Subscribe(nameof(CanAcceptItem)); } catch { PrintWarning("Ошибка подписки хука CanAcceptItem"); }            try { Subscribe(nameof(OnItemAddedToContainer)); } catch { PrintWarning("Ошибка подписки хука OnItemAddedToContainer"); }            try { Subscribe(nameof(OnItemRemovedFromContainer)); } catch { PrintWarning("Ошибка подписки хука OnItemRemovedFromContainer"); }        }                private void SendReplyCl(ConsoleSystem.Arg arg, string format)         {            if (arg != null && arg.Connection != null) SendReply(arg, format);            Puts(format);        }        				#region ExtHooks		//void SkinsOnSkinChanged(BasePlayer player, Item item, ulong oldSkin);  - вызывается при смене скина у предмета				#endregion				#region GUI		private void ShowButtons(BasePlayer player)		{			if (player == null) return;						CuiHelper.DestroyUi(player, "Buttons");			CuiElementContainer container = new CuiElementContainer();            container.Add(new CuiElement            {                Name = "Buttons",				Parent = "Overlay",                Components =                {                    new CuiImageComponent { Color = "0 0 0 0" },										                    new CuiRectTransformComponent()										{                        AnchorMin = "0.655 0.070",                        AnchorMax = "0.71 0.103"						                    }                }            });                                   CreateButton(player, container, "0.01 0.01", "0.40 0.99", true);						            CreateButton(player, container, "0.60 0.01", "0.99 0.99", false);            														CuiHelper.AddUi(player, container); 		}				private void ShowDir(BasePlayer player, bool isLeft)		{						if (player == null) return;						var name = player.UserIDString + (isLeft ? "_leftin" : "_rightin");			CuiHelper.DestroyUi(player, name);			CuiElementContainer container = new CuiElementContainer();            container.Add(new CuiElement            {                				Name = name,                Parent = player.UserIDString + (isLeft ? "_left" : "_right"),                Components =                {                    					new CuiRawImageComponent 					{						Url = isLeft ? "https://i.imgur.com/OzJdfxx.png" : "https://i.imgur.com/oM5tS89.png",						Color = "1 1 0 0.6",						Sprite = "assets/content/textures/generic/fulltransparent.tga"                    },                    new CuiRectTransformComponent                    {                        AnchorMin = isLeft ? "0.15 0.2" : "0.07 0.2",                        AnchorMax = isLeft ? "0.9 0.8" : "0.82 0.8"                    }                }            });			CuiHelper.AddUi(player, container);			timer.Once(0.3f, ()=>CuiHelper.DestroyUi(player, name));		}				        private void CreateButton(BasePlayer player, CuiElementContainer container, string AnchorMin, string AnchorMax, bool isLeft)        {                        container.Add(new CuiElement            {                Name = player.UserIDString + (isLeft ? "_left" : "_right"),                Parent = "Buttons",                Components =                {                    					new CuiRawImageComponent 					{						Url = isLeft ? "https://i.imgur.com/a9ofmZk.png" : "https://i.imgur.com/5ZUL5Ao.png",						Color = "1 1 1 0.6",						Sprite = "assets/content/textures/generic/fulltransparent.tga"                    },                    new CuiRectTransformComponent                    {                        AnchorMin = AnchorMin,                        AnchorMax = AnchorMax                    }                }            });						            						container.Add(new CuiElement            {                Name = CuiHelper.GetGuid(),                Parent = player.UserIDString + (isLeft ? "_left" : "_right"),                Components =                {                    new CuiButtonComponent                    {                        Command = "button947283.select " + (isLeft ? "left" : "right"),                                                Color = "1 1 1 0"                    },                    new CuiRectTransformComponent()                                    }            });        }													[ConsoleCommand("button947283.select")]		private void ConsoleCmdSelect(ConsoleSystem.Arg arg)		{			if (arg.Connection != null)            {				string selectedButton = arg.Args[0];				var player = arg.Player();				if (player == null) return;                switch(selectedButton)                {                    case "left":						ShowDir(player, true);						foreach(var box in SkinBoxHandler.SkinBoxes.Where(x=> x != null).ToList())						{							if (box.looter == player)							{												if (box.page <= 1) return;																								int pageItemCount = 36;										box.showLoot.capacity = pageItemCount;																int pageReadPos = (box.page-2)*36;								int pageWritePos = (box.page-1)*36;																box.isPaging = true;								for(int ii=box.showLoot.itemList.Count-1;ii>=0;ii--)								{									var item = box.showLoot.itemList[ii];									item.MoveToContainer(box.otherLoot, pageWritePos + item.position, false);																	}									for(int ii=box.otherLoot.itemList.Count-1;ii>=0;ii--)								{									var item = box.otherLoot.itemList[ii];									if (item.position >= pageReadPos && item.position < pageReadPos + pageItemCount)																			item.MoveToContainer(box.showLoot, item.position - pageReadPos, false);																	}											box.page--;																box.isPaging = false;																break;							}						}						break;                    case "right":												ShowDir(player, false);								foreach(var box in SkinBoxHandler.SkinBoxes.Where(x=> x != null).ToList())						{							if (box.looter == player)							{																								int pageItemCount = (box.showLoot.itemList.Count+box.otherLoot.itemList.Count)-36*box.page > 36 ? 36 : (box.showLoot.itemList.Count+box.otherLoot.itemList.Count)-36*box.page;								if (pageItemCount <= 0) return;																													box.showLoot.capacity = pageItemCount;																int pageReadPos = box.page*36;								int pageWritePos = (box.page-1)*36;																box.isPaging = true;								for(int ii=box.showLoot.itemList.Count-1;ii>=0;ii--)								{									var item = box.showLoot.itemList[ii];									item.MoveToContainer(box.otherLoot, pageWritePos + item.position, false);																	}									for(int ii=box.otherLoot.itemList.Count-1;ii>=0;ii--)								{									var item = box.otherLoot.itemList[ii];									if (item.position >= pageReadPos && item.position < pageReadPos + pageItemCount)																			item.MoveToContainer(box.showLoot, item.position - pageReadPos, false);																	}																box.page++;								box.isPaging = false;																								break;							}						}						break;                                                        }                			}		}				#endregion				#region Config        								        private static ConfigData configData;						        private class ConfigData        {            															[JsonProperty(PropertyName = "Разрешать использовать вручную добавленные скины")]            public bool useManualAddedSkins;									[JsonProperty(PropertyName = "Надпись, отображаемая на панели скинов")]			public string skinBoxTitle;						[JsonProperty(PropertyName = "Список привилегий для смены скинов")]            public List<string> permissionsUse;						[JsonProperty(PropertyName = "Показывать счетчик загрузки скинов в консоле")]            public bool showLoadedSkinCounts;												[JsonProperty(PropertyName = "Включить задержку перед повторным использованием скинов")]			public bool enableCooldown;			[JsonProperty(PropertyName = "Длительность задержки перед повторным использованием скинов (в секундах)")]            public int cooldownBox;						[JsonProperty(PropertyName = "При использовании задержки разрешать менять только один скин")]                        public bool activateAfterSkinTaken;						[JsonProperty(PropertyName = "Список отсутствующих названий предметов, которым принадлежат скины")]            public Dictionary<string, object> missingSkinNames;							[JsonProperty(PropertyName = "Список скинов, добавленных вручную")]			public Dictionary<string, List<ulong>> manualAddedSkinsPre;						[JsonProperty(PropertyName = "Список скинов для исключения")]			public List<ulong> excludedSkinsPre;        }		        private void LoadVariables() => configData = Config.ReadObject<ConfigData>();        		        protected override void LoadDefaultConfig()        {            var config = new ConfigData            {                															useManualAddedSkins = true,												skinBoxTitle = "Перетащите предмет, чтобы изменить его модель",				permissionsUse = new List<string>() { "skinbox.access", "skins.change" },								showLoadedSkinCounts = true,																						enableCooldown = false,				cooldownBox = 60,													activateAfterSkinTaken = true,				missingSkinNames = missingWorkshopNames(),				manualAddedSkinsPre = new Dictionary<string, List<ulong>>(),				excludedSkinsPre = new List<ulong>()            };            SaveConfig(config);			timer.Once(0.1f, ()=> SaveConfig(config));        }        		        private void SaveConfig(ConfigData config) => Config.WriteObject(config, true);		        #endregion            }      }	

// --- End of file: SkinBox.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrashRust/Teleportation.cs ---
// --- Original Local Path: TrashRust/Teleportation.cs ---

using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using UnityEngine;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins
{
    [Info("Teleportation", "", "1.5.0")]
    class Teleportation : RustPlugin
    {
        [PluginReference] Plugin Clans;
        [PluginReference] Plugin Friends;
        Dictionary<ulong, Vector3> lastPositions = new Dictionary<ulong, Vector3>();
        Dictionary<BasePlayer, int> spectatingPlayers = new Dictionary<BasePlayer, int>();
        bool IsClanMember(ulong playerid = 294912, ulong targetID = 0) => (bool)(Clans?.Call("HasFriend", playerid, targetID) ?? false);
        bool IsFriends(ulong playerID = 0, ulong friendId = 0) => (bool)(Friends?.Call("AreFriends", playerID, friendId) ?? false);

        bool IsTeamate(BasePlayer player, ulong targetID)
        {
            if (player.currentTeam == 0) return false;
            var team = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);
            if (team == null) return false;
            var list = RelationshipManager.ServerInstance.FindTeam(player.currentTeam).members.Where(p => p == targetID).ToList();
            return list.Count > 0;
        }

        class TP
        {
            public BasePlayer Player;
            public BasePlayer Player2;
            public Vector3 pos;
            public float totalSeconds;
            public bool EnabledShip;
            public int seconds;
            public bool TPL;
            public TP(BasePlayer player, Vector3 Pos, int Seconds, bool EnabledShip1, bool tpl, BasePlayer player2 = null)
            {
                Player = player;
                pos = Pos;
                seconds = Seconds;
                totalSeconds = Seconds;
                EnabledShip = EnabledShip1;
                Player2 = player2;
                TPL = tpl;
            }
        }
        const string TPADMIN = "teleportation.admin";
        int homelimitDefault;
        Dictionary<string, int> homelimitPerms;
        int tpkdDefault;
        Dictionary<string, int> tpkdPerms;
        int tpkdhomeDefault;
        Dictionary<string, int> tpkdhomePerms;
        int teleportSecsDefault;
        int resetPendingTime;
        bool restrictCupboard;
        bool enabledTPR;
        bool homecupboard;
        bool homecupboardblock;
        bool adminsLogs;
        bool foundationOwner;
        bool foundationOwnerFC;

        bool restrictTPRCupboard;
        bool foundationEx;
        bool wipedData;
        bool createSleepingBug;
        string EffectPrefab1;
        string EffectPrefab;
        bool EnabledShipTP;
        bool EnabledBallonTP;
        bool CancelTPMetabolism;
        bool CancelTPCold;
        bool CancelTPRadiation;
        bool FriendsEnabled;
        bool CancelTPWounded;
        bool EnabledTPLForPlayers;
        int TPLCooldown;
        int TplPedingTime;
        bool TPLAdmin;
        string AutoTPAPermission;

        static DynamicConfigFile config;
        Dictionary<string, int> teleportSecsPerms;
        void OnNewSave()
        {
            if (wipedData)
            {
                PrintWarning("Обнаружен вайп. Очищаем данные с data/Teleportation");
                WipeData();
            }
        }
        void WipeData()
        {
            LoadData();
            tpsave = new List<TPList>();
            homes = new Dictionary<ulong, Dictionary<string, Vector3>>();
            SaveData();
        }
        protected override void LoadDefaultConfig()
        {
            GetVariable(Config, "Запрещать отправлять запрос на телепортацию в зоне действия чужого шкафа", out homecupboard, true);
            GetVariable(Config, "Удалять точку теоепртации если она в билде в какой не авторизован игрок", out homecupboard, true);
            GetVariable(Config, "Звук уведомления при получение запроса на телепорт (пустое поле = звук отключен)", out EffectPrefab1, "assets/prefabs/locks/keypad/effects/lock.code.unlock.prefab");
            GetVariable(Config, "Звук предупреждения (пустое поле = звук отключен)", out EffectPrefab, "assets/prefabs/locks/keypad/effects/lock.code.denied.prefab");
            GetVariable(Config, "Разрешать сохранять местоположение только на фундаменте", out foundationEx, true);
            GetVariable(Config, "Создавать объект при сохранении местоположения в виде Sleeping Bag", out createSleepingBug, true);
            GetVariable(Config, "Автоматический вайп данных при генерации новой карты", out wipedData, true);
            GetVariable(Config, "Запрещать принимать запрос на телепортацию в зоне действия чужого шкафа", out restrictCupboard, true);
            GetVariable(Config, "Запрещать сохранять местоположение если игрок не является владельцем фундамента", out foundationOwner, true);
            GetVariable(Config, "Привилегия на использование автоматического приёма телепорта", out AutoTPAPermission, "teleportation.autotpa");
            GetVariable(Config, "Разрешать сохранять местоположение если игрок является другом или соклановцем или тимейтом владельца фундамента ", out foundationOwnerFC, true);
            GetVariable(Config, "Логировать использование команд для администраторов", out adminsLogs, true);
            GetVariable(Config, "Включить телепортацию (TPR/TPA) только к друзьям, соклановкам или тимейту", out FriendsEnabled, true);
            GetVariable(Config, "Разрешить команду TPR игрокам (false = /tpr не будет работать)", out enabledTPR, true);
            GetVariable(Config, "Разрешить отправку и приём телепорта и телепорт домой на корабле", out EnabledShipTP, true);
            GetVariable(Config, "Разрешить отправку и приём телепорта на воздушном шаре", out EnabledBallonTP, true);
            GetVariable(Config, "Запрещать отправлять запрос на телепортацию в зоне действия чужого шкафа", out restrictTPRCupboard, true);
            GetVariable(Config, "Отмета телепорта игрока (Home/TP) если у него кровотечение", out CancelTPMetabolism, true);
            GetVariable(Config, "Отмета телепорта игрока (Home/TP) если игрок ранен", out CancelTPWounded, true);
            GetVariable(Config, "Отмета телепорта игрока (Home/TP) если ему холодно", out CancelTPCold, true);
            GetVariable(Config, "Отмета телепорта игрока (Home/TP) если он облучен радиацией", out CancelTPRadiation, true);
            GetVariable(Config, "Время ответа на запрос телепортации (в секундах)", out resetPendingTime, 15);
            GetVariable(Config, "Ограничение на количество сохранённых местоположений", out homelimitDefault, 3);
            GetVariable(Config, "[TPL] Разрешить игрокам использовать TPL", out EnabledTPLForPlayers, false);
            GetVariable(Config, "[TPL] Задержка телепортации игрока на TPL", out TplPedingTime, 15);
            GetVariable(Config, "[TPL] Cooldown телепортации игрока на TPL", out TPLCooldown, 15);
            GetVariable(Config, "[TPL] Телепортировать админа без задержки и кулдауна?", out TPLAdmin, true);
            Config["Ограничение на количество сохранённых местоположений с привилегией"] = homelimitPerms = GetConfig("Ограничение на количество сохранённых местоположений с привилегией", new Dictionary<string, object>() {
                    {
                    "teleportation.vip", 5
                }
            }
            ).ToDictionary(p => p.Key, p => Convert.ToInt32(p.Value));
            PermissionService.RegisterPermissions(this, homelimitPerms.Keys.ToList());
            GetVariable(Config, "Длительность задержки перед телепортацией (в секундах)", out teleportSecsDefault, 15);
            Config["Длительность задержки перед телепортацией с привилегией (в секундах)"] = teleportSecsPerms = GetConfig("Длительность задержки перед телепортацией с привилегией (в секундах)", new Dictionary<string, object>() {
                    {
                    "teleportation.vip", 10
                }
            }
            ).ToDictionary(p => p.Key, p => Convert.ToInt32(p.Value));
            PermissionService.RegisterPermissions(this, teleportSecsPerms.Keys.ToList());
            GetVariable(Config, "Длительность перезарядки телепорта (в секундах)", out tpkdDefault, 300);
            Config["Длительность перезарядки телепорта с привилегией (в секундах)"] = tpkdPerms = GetConfig("Длительность перезарядки телепорта с привилегией (в секундах)", new Dictionary<string, object>() {
                    {
                    "teleportation.vip", 150
                }
            }
            ).ToDictionary(p => p.Key, p => Convert.ToInt32(p.Value));
            PermissionService.RegisterPermissions(this, tpkdPerms.Keys.ToList());
            GetVariable(Config, "Длительность перезарядки телепорта домой (в секундах)", out tpkdhomeDefault, 300);
            Config["Длительность перезарядки телепорта домой с привилегией (в секундах)"] = tpkdhomePerms = GetConfig("Длительность перезарядки телепорта домой с привилегией (в секундах)", new Dictionary<string, object>() {
                    {
                    "teleportation.vip", 150
                }
            }
            ).ToDictionary(p => p.Key, p => Convert.ToInt32(p.Value));
            PermissionService.RegisterPermissions(this, tpkdhomePerms.Keys.ToList());
            SaveConfig();
        }
        T GetConfig<T>(string name, T defaultValue) => Config[name] == null ? defaultValue : (T)Convert.ChangeType(Config[name], typeof(T));
        public static void GetVariable<T>(DynamicConfigFile config, string name, out T value, T defaultValue)
        {
            config[name] = value = config[name] == null ? defaultValue : (T)Convert.ChangeType(config[name], typeof(T));
        }
        public static class PermissionService
        {
            public static Permission permission = Interface.GetMod().GetLibrary<Permission>();
            public static bool HasPermission(ulong uid, string permissionName)
            {
                return !string.IsNullOrEmpty(permissionName) && permission.UserHasPermission(uid.ToString(), permissionName);
            }
            public static void RegisterPermissions(Plugin owner, List<string> permissions)
            {
                if (owner == null) throw new ArgumentNullException("owner");
                if (permissions == null) throw new ArgumentNullException("commands");
                foreach (var permissionName in permissions.Where(permissionName => !permission.PermissionExists(permissionName)))
                {
                    permission.RegisterPermission(permissionName, owner);
                }
            }
        }
        public BasePlayer FindBasePlayer(string nameOrUserId)
        {
            nameOrUserId = nameOrUserId.ToLower();
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (player.displayName.ToLower().Contains(nameOrUserId) || player.UserIDString == nameOrUserId) return player;
            }
            foreach (var player in BasePlayer.sleepingPlayerList)
            {
                if (player.displayName.ToLower().Contains(nameOrUserId) || player.UserIDString == nameOrUserId) return player;
            }
            return default(BasePlayer);
        }
        Dictionary<ulong, Dictionary<string, Vector3>> homes;
        List<TPList> tpsave;
        class TPList
        {
            public string Name;
            public Vector3 pos;
        }
        Dictionary<ulong, int> cooldownsTP = new Dictionary<ulong, int>();
        Dictionary<ulong, int> cooldownsHOME = new Dictionary<ulong, int>();
        List<TP> tpQueue = new List<TP>();
        List<TP> pendings = new List<TP>();
        List<ulong> sethomeBlock = new List<ulong>();

        /*[ChatCommand("atp")]
        void cmdAutoTPA(BasePlayer player, string com, string[] args)
        {
            if (!PermissionService.HasPermission(player.userID, AutoTPAPermission))
            {
                SendReply(player, Messages["TPAPerm"]);
                return;
            }

            if (!AutoTPA.ContainsKey(player.userID))
                AutoTPA.Add(player.userID, new AutoTPASettings());


            var data = AutoTPA[player.userID];

            if (args == null || args.Length <= 0)
            {
                if (data.Enabled)
                {
                    data.Enabled = false;
                    SendReply(player, Messages["TPADisable"]);

                }
                else
                {
                    data.Enabled = true;
                    SendReply(player, string.Format(Messages["TPAEnabled"], Messages["TPAEnabledInfo"]));
                }
                return;
            }

            switch (args[0])
            {
                case "add":
                    if (args.Length < 2)
                    {
                        SendReply(player, Messages["TPAEAddError"]);
                        return;
                    }

                    var target = covalence.Players.FindPlayers(args[1]).ToList();

                    if (target == null || target.Count <= 0)
                    {
                        SendReply(player, string.Format(Messages["TPAEAddPlayerNotFound"], "⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠"));
                        return;
                    }

                    if (target.Count > 1)
                    {
                        SendReply(player, string.Format(Messages["TPAEAddPlayers"], string.Join(", ", target.Select(p => p.Name).Take(5))));
                        return;
                    }
                    if (data.PlayersList.ContainsKey(target[0].Name))
                    {
                        SendReply(player, string.Format(Messages["TPAEAddContains"], target[0].Name));
                        return;
                    }

                    data.PlayersList.Add(target[0].Name, ulong.Parse(target[0].Id));

                    SendReply(player, string.Format(Messages["TPAEAddSuccess"], target[0].Name));

                    break;
                case "remove":
                    if (args.Length < 2)
                    {
                        SendReply(player, Messages["TPARemoveError"]);
                        return;
                    }
                    var key = data.PlayersList.FirstOrDefault(p => p.Key.ToLower().Contains(args[1].ToLower())).Key;
                    if (string.IsNullOrEmpty(key))
                    {
                        SendReply(player, string.Format(Messages["TPAEAddPlayerNotFound"], string.Format(Messages["TPAEnabledList"], string.Join(", ", data.PlayersList.Select(p => p.Key)))));
                        return;
                    }

                    data.PlayersList.Remove(key);
                    SendReply(player, string.Format(Messages["TPAERemoveSuccess"], key));

                    break;
                case "list":
                    if (data.PlayersList.Count <= 0)
                        SendReply(player, Messages["TPAEListNotFound"]);
                    else
                        SendReply(player, string.Format(Messages["TPAEnabledList"], string.Join(", ", data.PlayersList.Select(p => p.Key))));
                    break;
            }
        }
        */

        [ChatCommand("sethome")]
        void cmdChatSetHome(BasePlayer player, string command, string[] args)
        {
            var uid = player.userID;
            var pos = player.transform.position;
            var entity = new BaseEntity();

            RaycastHit hitInfo;
            if (!Physics.Raycast(player.transform.position, Vector3.down, out hitInfo, 1f))
            {
                SendReply(player, Messages["buildingBrockmissing"]);
                return;
            }
            if (hitInfo.GetEntity() == null || !(hitInfo.GetEntity() is BuildingBlock))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["buildingBrockmissing"]);
                return;
            }

            if (foundationEx && !hitInfo.GetEntity().ShortPrefabName.Contains("foundation"))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["foundationmissing"]);
                return;
            }
            entity = hitInfo.GetEntity();
            var point = player.transform.position;
            point.y = player.transform.position.y;
            pos = point;
            if (args.Length != 1)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["sethomeArgsError"]);
                return;
            }
            if (CancelTPMetabolism && player.metabolism.bleeding.value > 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (CancelTPRadiation && player.metabolism.radiation_poison.value > 10)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["Radiation"]);
                return;
            }
            if (player.IsWounded() && CancelTPWounded)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (sethomeBlock.Contains(player.userID))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["sethomeBlock"]);
                return;
            }

            if (foundationOwnerFC && foundationOwner)
            {

                if (entity.OwnerID != uid)
                {
                    if (!IsFriends(entity.OwnerID, player.userID) && !IsClanMember(entity.OwnerID, player.userID) && !IsTeamate(player, entity.OwnerID))
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["foundationownerFC"]);
                        return;
                    }
                }
            }
            if (foundationOwner)
            {

                if (entity.OwnerID != uid && foundationOwnerFC == (!IsFriends(entity.OwnerID, player.userID) && !IsClanMember(entity.OwnerID, player.userID) && IsTeamate(player, entity.OwnerID)))
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["foundationowner"]);
                    return;
                }
            }
            var name = args[0];
            SetHome(player, name, pos);
        }

        [ChatCommand("removehome")]
        void cmdChatRemoveHome(BasePlayer player, string command, string[] args)
        {
            if (args.Length != 1)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["removehomeArgsError"]);
                return;
            }
            if (!homes.ContainsKey(player.userID))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["homesmissing"]);
                return;
            }
            var name = args[0];
            var playerHomes = homes[player.userID];
            if (!playerHomes.ContainsKey(name))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["homenotexist"]);
                return;
            }
            foreach (var sleepingBag in SleepingBag.FindForPlayer(player.userID, true))
            {
                if (Vector3.Distance(sleepingBag.transform.position, playerHomes[name]) < 1)
                {
                    sleepingBag.Kill();
                    break;
                }
            }
            Effect.server.Run(EffectPrefab1, player, 0, Vector3.zero, Vector3.forward);
            playerHomes.Remove(name);
            SendReply(player, Messages["removehomesuccess"], name);
        }
        [ConsoleCommand("home")]
        void cmdHome(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            if (arg.Args == null || arg.Args.Length < 1) return;
            cmdChatHome(player, "", new[] { arg.Args[0] });
        }
        [ChatCommand("homelist")]
        private void cmdHomeList(BasePlayer player, string command, string[] args)
        {
            if (!homes.ContainsKey(player.userID) || homes[player.userID].Count == 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["homesmissing"]);
                return;
            }
            var playerHomes = homes[player.userID];
            var time = (GetHomeLimit(player.userID) - playerHomes.Count);
            var homelist = playerHomes.Select(x => GetSleepingBag(x.Key, x.Value) != null ? $"{x.Key} {x.Value}" : $"Дом: {x.Key} {x.Value}");

            foreach (var home in playerHomes.ToList())
            {
                if (createSleepingBug)
                    if (!GetSleepingBag(home.Key, home.Value)) playerHomes.Remove(home.Key);
            }
            SendReply(player, Messages["homeslist"], time, string.Join("\n", homelist.ToArray()));
        }
        [ChatCommand("home")]
        void cmdChatHome(BasePlayer player, string command, string[] args)
        {
            if (args.Length != 1)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["homeArgsError"]);
                return;
            }
            var ret = Interface.Call("CanTeleport", player) as string;
            if (ret != null)
            {
                SendReply(player, ret);
                return;
            }
            if (!EnabledShipTP && player.GetParentEntity() is CargoShip)
            {
                SendReply(player, Messages["PlayerIsOnCargoShip"]);
                return;
            }
            if (!EnabledBallonTP && player.GetParentEntity() is HotAirBalloon)
            {
                SendReply(player, Messages["PlayerIsOnHotAirBalloon"]);
                return;
            }
            if (player.IsWounded() && CancelTPWounded)
            {
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (player.metabolism.bleeding.value > 0 && CancelTPMetabolism)
            {
                SendReply(player, Messages["woundedAction"]);
                return;
            }

            if (CancelTPRadiation && player.metabolism.radiation_poison.value > 10)
            {
                SendReply(player, Messages["Radiation"]);
                return;
            }
            int seconds;
            if (cooldownsHOME.TryGetValue(player.userID, out seconds) && seconds > 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, string.Format(Messages["tpkd"], TimeToString(seconds)));
                return;
            }
            if (homecupboard)
            {
                var privilege = player.GetBuildingPrivilege(player.WorldSpaceBounds());
                if (privilege != null && !player.IsBuildingAuthed())
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["tphomecupboard"]);
                    return;
                }
            }
            if (!homes.ContainsKey(player.userID))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["homesmissing"]);
                return;
            }
            var name = args[0];
            var playerHomes = homes[player.userID];
            if (!playerHomes.ContainsKey(name))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["homenotexist"]);
                return;
            }
            var time = GetTeleportTime(player.userID);
            var pos = playerHomes[name];
            SleepingBag bag = GetSleepingBag(name, pos);
            if (createSleepingBug)
            {
                if (bag == null)
                {
                    foreach (var sleepingBag in SleepingBag.FindForPlayer(player.userID, true))
                    {
                        if (Vector3.Distance(sleepingBag.transform.position, playerHomes[name]) < 1)
                        {
                            sleepingBag.Kill();
                            break;
                        }
                    }
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["sleepingbagmissing"]);
                    playerHomes.Remove(name);
                    return;
                }

                if (bag.GetBuildingPrivilege() != null && !bag.GetBuildingPrivilege().IsAuthed(player))
                {
                    foreach (var sleepingBag in SleepingBag.FindForPlayer(player.userID, true))
                    {
                        if (Vector3.Distance(sleepingBag.transform.position, playerHomes[name]) < 1)
                        {
                            sleepingBag.Kill();
                            break;
                        }
                    }
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["sleepingbugbuildblock"]);
                    playerHomes.Remove(name);
                    return;
                }
            }
            else
            {
                var bulds = GetBuldings(pos);
                if (bulds == null)
                {
                    foreach (var sleepingBag in SleepingBag.FindForPlayer(player.userID, true))
                    {
                        if (Vector3.Distance(sleepingBag.transform.position, playerHomes[name]) < 1)
                        {
                            sleepingBag.Kill();
                            break;
                        }
                    }
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["buildingBrockmissingR"]);
                    playerHomes.Remove(name);
                    return;
                }

                if (bulds.GetBuildingPrivilege() != null && !bulds.GetBuildingPrivilege().IsAuthed(player))
                {
                    foreach (var sleepingBag in SleepingBag.FindForPlayer(player.userID, true))
                    {
                        if (Vector3.Distance(sleepingBag.transform.position, playerHomes[name]) < 1)
                        {
                            sleepingBag.Kill();
                            break;
                        }
                    }
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["sleepingbugbuildblock"]);
                    playerHomes.Remove(name);

                    return;
                }
            }
            if (CancelTPCold && player.metabolism.temperature.value < 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["coldplayer"]);
                return;
            }
            if (tpQueue.Any(p => p.Player == player) || pendings.Any(p => p.Player2 == player))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tpError"]);
                return;
            }
            var lastTp = tpQueue.Find(p => p.Player == player);
            if (lastTp != null)
            {
                tpQueue.Remove(lastTp);
            }
            tpQueue.Add(new TP(player, pos, time, false, false));
            Effect.server.Run(EffectPrefab1, player, 0, Vector3.zero, Vector3.forward);
            SendReply(player, String.Format(Messages["homequeue"], name, TimeToString(time)));
        }
        [ChatCommand("tpr")]
        void cmdChatTpr(BasePlayer player, string command, string[] args)
        {
            if (!enabledTPR) return;
            if (args.Length != 1)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tprArgsError"]);
                return;
            }
            var ret = Interface.Call("CanTeleport", player) as string;
            if (ret != null)
            {
                SendReply(player, ret);
                return;
            }
            if (!EnabledShipTP && player.GetParentEntity() is CargoShip)
            {
                SendReply(player, Messages["PlayerIsOnCargoShip"]);
                return;
            }
            if (!EnabledBallonTP && player.GetParentEntity() is HotAirBalloon)
            {
                SendReply(player, Messages["PlayerIsOnHotAirBalloon"]);
                return;
            }
            if (player.IsWounded() && CancelTPWounded)
            {
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (player.metabolism.bleeding.value > 0 && CancelTPMetabolism)
            {
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (CancelTPRadiation && player.metabolism.radiation_poison.value > 10)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["Radiation"]);
                return;
            }
            if (restrictTPRCupboard)
            {
                var privilege = player.GetBuildingPrivilege(player.WorldSpaceBounds());
                if (privilege != null && !player.IsBuildingAuthed())
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["tpcupboard"]);
                    return;
                }
            }
            var name = args[0];
            var target = FindBasePlayer(name);
            if (target == null || !target.IsConnected)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["playermissing"]);
                return;
            }
            if (target == player)
            {
                SendReply(player, Messages["playerisyou"]);
                return;
            }
            if (FriendsEnabled)
                if (!IsFriends(target.userID, player.userID) && !IsTeamate(player, target.userID) && !IsClanMember(player.userID, target.userID))
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["PlayerNotFriend"]);
                    return;
                }
            int seconds = 0;
            if (restrictCupboard && player.GetBuildingPrivilege(player.WorldSpaceBounds()) != null && !player.GetBuildingPrivilege(player.WorldSpaceBounds()).authorizedPlayers.Select(p => p.userid).Contains(player.userID))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tpcupboard"]);
                return;
            }

            if (cooldownsTP.TryGetValue(player.userID, out seconds) && seconds > 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, string.Format(Messages["tpkd"], TimeToString(seconds)));
                return;
            }
            if (CancelTPCold && player.metabolism.temperature.value < 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["coldplayer"]);
                return;
            }
            if (tpQueue.Any(p => p.Player == player) || pendings.Any(p => p.Player2 == player))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tpError"]);
                return;
            }

            if (tpQueue.Any(p => p.Player == target) || pendings.Any(p => p.Player2 == target))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tpError"]);
                return;
            }
            SendReply(player, string.Format(Messages["tprrequestsuccess"], target.displayName));
            SendReply(target, string.Format(Messages["tprpending"], player.displayName));
            Effect.server.Run(EffectPrefab1, target, 0, Vector3.zero, Vector3.forward);

            TeleportationAcceptUI(target, player.displayName);
            pendings.Add(new TP(target, Vector3.zero, 15, false, false, player));
            if (!IsFriends(target.userID, player.userID) && !IsClanMember(player.userID, target.userID) && !player.Team.members.Contains(target.userID)) return;
            cmdChatTpa(target, command, new string[] { "atp" });
            SendReply(target, Messages["TPASuccess"]);
        }
        [ChatCommand("tpa")]
        void cmdChatTpa(BasePlayer player, string command, string[] args)
        {
            if (!enabledTPR) return;
            var tp = pendings.Find(p => p.Player == player);
            if (tp == null)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tpanotexist"]);
                return;
            }
            BasePlayer pendingPlayer = tp.Player2;
            if (pendingPlayer == null)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tpanotexist"]);
                return;
            }
            if (!EnabledBallonTP && player.GetParentEntity() is HotAirBalloon)
            {
                SendReply(player, Messages["PlayerIsOnHotAirBalloon"]);
                return;
            }
            if (!EnabledShipTP && player.GetParentEntity() is CargoShip)
            {
                SendReply(player, Messages["PlayerIsOnCargoShip"]);
                return;
            }
            if (CancelTPCold && player.metabolism.temperature.value < 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["coldplayer"]);
                return;
            }
            if (player.IsWounded() && CancelTPWounded)
            {
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (player.metabolism.bleeding.value > 0 && CancelTPMetabolism)
            {
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (CancelTPRadiation && player.metabolism.radiation_poison.value > 10)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["Radiation"]);
                return;
            }
            if (restrictCupboard && player.GetBuildingPrivilege(player.WorldSpaceBounds()) != null && !player.GetBuildingPrivilege(player.WorldSpaceBounds()).authorizedPlayers.Select(p => p.userid).Contains(player.userID))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tpacupboard"]);
                return;
            }
            var ret = Interface.Call("CanTeleport", player) as string;
            if (ret != null)
            {
                SendReply(player, ret);
                return;
            }
            if (FriendsEnabled)
                if (!IsFriends(pendingPlayer.userID, player.userID) && !IsTeamate(player, pendingPlayer.userID) && !IsClanMember(player.userID, pendingPlayer.userID))
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["PlayerNotFriend"]);
                    return;
                }
            var time = GetTeleportTime(pendingPlayer.userID);
            pendings.Remove(tp);
            var lastTp = tpQueue.Find(p => p.Player == pendingPlayer);
            if (lastTp != null)
            {
                tpQueue.Remove(lastTp);
            }
            var Enabled = player.GetParentEntity() is CargoShip || player.GetParentEntity() is HotAirBalloon;
            tpQueue.Add(new TP(pendingPlayer, player.transform.position, time, Enabled, false, player));
            Effect.server.Run(EffectPrefab1, player, 0, Vector3.zero, Vector3.forward);
            SendReply(pendingPlayer, string.Format(Messages["tpqueue"], player.displayName, TimeToString(time)));
            if (args.Length <= 0) SendReply(player, String.Format(Messages["tpasuccess"], pendingPlayer.displayName, TimeToString(time)));
            CuiHelper.DestroyUi(player, PARENT_TELEPORT);
        }

        [ChatCommand("tpc")]
        void cmdChatTpc(BasePlayer player, string command, string[] args)
        {
            var tp = pendings.Find(p => p.Player == player);
            BasePlayer target = tp?.Player2;
            if (target != null)
            {
                pendings.Remove(tp);
                SendReply(player, Messages["tpc"]);
                SendReply(target, string.Format(Messages["tpctarget"], player.displayName));
                CuiHelper.DestroyUi(player, "Teleport");
                CuiHelper.DestroyUi(target, "Teleport");
                CuiHelper.DestroyUi(target, PARENT_TELEPORT);
                return;
            }
            if (player.IsWounded() && CancelTPWounded)
            {
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (player.metabolism.bleeding.value > 0 && CancelTPMetabolism)
            {
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (CancelTPRadiation && player.metabolism.radiation_poison.value > 10)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["Radiation"]);
                return;
            }
            if (CancelTPCold && player.metabolism.temperature.value < 0)
            {
                SendReply(player, Messages["coldplayer"]);
                return;
            }
            foreach (var pend in pendings)
            {
                if (pend.Player2 == player)
                {
                    SendReply(player, Messages["tpc"]);
                    SendReply(pend.Player, string.Format(Messages["tpctarget"], player.displayName));
                    pendings.Remove(pend);
                    return;
                }
            }
            foreach (var tpQ in tpQueue)
            {
                if (tpQ.Player2 != null && tpQ.Player2 == player)
                {
                    SendReply(player, Messages["tpc"]);
                    SendReply(tpQ.Player, string.Format(Messages["tpctarget"], player.displayName));
                    tpQueue.Remove(tpQ);
                    CuiHelper.DestroyUi(player, "Teleport");
                    CuiHelper.DestroyUi(tpQ.Player, "Teleport");
                    return;
                }
                if (tpQ.Player == player)
                {
                    SendReply(player, Messages["tpc"]);
                    if (tpQ.Player2 != null)
                    {
                        SendReply(tpQ.Player2, string.Format(Messages["tpctarget"], player.displayName));
                        CuiHelper.DestroyUi(tpQ.Player2, "Teleport");
                    }
                    tpQueue.Remove(tpQ);
                    CuiHelper.DestroyUi(player, "Teleport");

                    return;
                }
            }
        }
        void SpectateFinish(BasePlayer player)
        {
            player.Command("camoffset", "0,1,0");
            player.StopSpectating();
            player.SetParent(null);
            player.gameObject.SetLayerRecursive(17);
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Spectating, false);
            player.SetPlayerFlag(BasePlayer.PlayerFlags.ThirdPersonViewmode, false);
            player.SendNetworkUpdateImmediate();
            player.metabolism.Reset();
            player.InvokeRepeating("InventoryUpdate", 1f, 0.1f * UnityEngine.Random.Range(0.99f, 1.01f));
            if (player.net?.connection != null) player.ClientRPCPlayer(null, player, "StartLoading");
            player.StartSleeping();
            if (lastPositions.ContainsKey(player.userID))
            {
                Vector3 lastPosition = lastPositions[player.userID] + Vector3.up;
                player.MovePosition(lastPosition);
                if (player.net?.connection != null) player.ClientRPCPlayer(null, player, "ForcePositionTo", lastPosition);
                lastPositions.Remove(player.userID);

            }

            if (player.net?.connection != null) player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
            player.UpdateNetworkGroup();
            player.SendNetworkUpdateImmediate(false);
            if (player.net?.connection == null) return;
            try
            {
                player.ClearEntityQueue(null);
            }
            catch { }
            player.SendFullSnapshot();

            SendReply(player, "Слежка закончена!");
        }


        private void OnUserConnected(IPlayer player) => ResetSpectate(player);

        private void OnUserDisconnected(IPlayer player) => ResetSpectate(player);

        private void ResetSpectate(IPlayer player)
        {
            player.Command("camoffset 0,1,0");

            if (lastPositions.ContainsKey(ulong.Parse(player.Id)))
            {
                lastPositions.Remove(ulong.Parse(player.Id));
            }
        }

        object OnPlayerSpectateEnd(BasePlayer player, string spectateFilter)
        {
            player.Command("camoffset", "0,1,0");
            return null;
        }

        [ChatCommand("tpl")]
        void cmdChattpGo(BasePlayer player, string command, string[] args)
        {
            if (!EnabledTPLForPlayers && !player.IsAdmin && !PermissionService.HasPermission(player.userID, "teleportation.admin")) return;
            if (args == null || args.Length == 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tpArgsError"]);
                return;
            }
            switch (args[0])
            {
                default:
                    if (tpsave.Count <= 0)
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["homesmissing"]);
                        return;
                    }
                    var nametp = args[0];
                    var tp = tpsave.Find(p => p.Name == nametp);
                    if (tp == null)
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["homenotexist"]);
                        return;
                    }
                    var position = tp.pos;
                    var ret = Interface.Call("CanTeleport", player) as string;
                    if (ret != null)
                    {
                        SendReply(player, ret);
                        return;
                    }
                    int seconds;
                    if (cooldownsHOME.TryGetValue(player.userID, out seconds) && seconds > 0)
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, string.Format(Messages["tpkd"], TimeToString(seconds)));
                        return;
                    }
                    var lastTp = tpQueue.Find(p => p.Player == player);
                    if (lastTp != null) tpQueue.Remove(lastTp);
                    Effect.server.Run(EffectPrefab1, player, 0, Vector3.zero, Vector3.forward);
                    if (TPLAdmin && player.IsAdmin || PermissionService.HasPermission(player.userID, "teleportation.admin")) Teleport(player, position);
                    else
                    {
                        tpQueue.Add(new TP(player, position, TplPedingTime, false, true));
                        SendReply(player, String.Format(Messages["homequeue"], nametp, TimeToString(TplPedingTime)));
                    }
                    return;
                case "add":
                    if (!player.IsAdmin && !PermissionService.HasPermission(player.userID, "teleportation.admin")) return;
                    if (args == null || args.Length == 1)
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["settpArgsError"]);
                        return;
                    }
                    var nameAdd = args[1];
                    SetTpSave(player, nameAdd);
                    return;
                case "remove":
                    if (!player.IsAdmin && !PermissionService.HasPermission(player.userID, "teleportation.admin")) return;
                    if (args == null || args.Length == 1)
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["removetpArgsError"]);
                        return;
                    }
                    nametp = args[1];
                    if (tpsave.Count > 0)
                    {
                        tp = tpsave.Find(p => p.Name == nametp);
                        if (tp == null)
                        {
                            Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                            SendReply(player, Messages["homesmissing"]);
                            return;
                        }
                        Effect.server.Run(EffectPrefab1, player, 0, Vector3.zero, Vector3.forward);
                        tpsave.Remove(tp);
                        SendReply(player, Messages["removehomesuccess"], nametp);
                    }
                    return;
                case "list":
                    if (tpsave.Count <= 0)
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["TPLmissing"]);
                        return;
                    }
                    var tplist = tpsave.Select(x => $"{x.Name} {x.pos}");
                    SendReply(player, Messages["TPLList"], string.Join("\n", tplist.ToArray()));
                    return;
            }
        }
        [ChatCommand("tpspec")]
        void cmdTPSpec(BasePlayer player, string command, string[] args)
        {
            if (!PermissionService.HasPermission(player.userID, "teleportation.admin")) return;
            if (!player.IsSpectating())
            {
                if (args.Length == 0 || args.Length != 1)
                {
                    SendReply(player, Messages["tpspecError"]);
                    return;
                }
                string name = args[0];
                BasePlayer target = FindBasePlayer(name);
                if (target == null)
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["playermissing"]);
                    return;
                }
                switch (args.Length)
                {
                    case 1:
                        if (!target.IsConnected)
                        {
                            SendReply(player, Messages["playermissingOff"]);
                            return;
                        }
                        if (target.IsDead())
                        {
                            SendReply(player, Messages["playermissingOrDeath"]);
                            return;
                        }
                        if (ReferenceEquals(target, player))
                        {
                            SendReply(player, Messages["playerItsYou"]);
                            return;
                        }
                        if (target.IsSpectating())
                        {
                            SendReply(player, Messages["playerItsSpec"]);
                            return;
                        }
                        spectatingPlayers.Remove(target);
                        lastPositions[player.userID] = player.transform.position;
                        HeldEntity heldEntity = player.GetActiveItem()?.GetHeldEntity() as HeldEntity;
                        heldEntity?.SetHeld(false);
                        player.SetPlayerFlag(BasePlayer.PlayerFlags.Spectating, true);
                        player.gameObject.SetLayerRecursive(10);
                        player.CancelInvoke("MetabolismUpdate");
                        player.CancelInvoke("InventoryUpdate");
                        player.ClearEntityQueue();
                        player.SendEntitySnapshot(target);
                        player.gameObject.Identity();
                        player.SetParent(target);
                        player.SetPlayerFlag(BasePlayer.PlayerFlags.ThirdPersonViewmode, true);
                        player.Command("camoffset", "0, 1.3, 0");
                        SendReply(player, $"Вы наблюдаете за игроком {target}! Что бы переключаться между игроками, нажимайте: Пробел\nЧтобы выйти с режима наблюдения, введите: /tpspec");
                        break;
                }
            }
            else SpectateFinish(player);
        }
        [ChatCommand("tp")]
        void cmdTP(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin && !PermissionService.HasPermission(player.userID, "teleportation.admin")) return;
            switch (args.Length)
            {
                case 1:
                    string name = args[0];
                    BasePlayer target = FindBasePlayer(name);
                    if (target == null)
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["playermissing"]);
                        return;
                    }
                    if (adminsLogs)
                    {
                        LogToFile("admin", $"[{DateTime.Now.ToShortTimeString()}] {player} телепортировался к {target}", this, true);
                    }
                    Teleport(player, target);
                    break;
                case 2:
                    string name1 = args[0];
                    string name2 = args[1];
                    BasePlayer target1 = FindBasePlayer(name1);
                    BasePlayer target2 = FindBasePlayer(name2);
                    if (target1 == null || target2 == null)
                    {
                        SendReply(player, Messages["playermissing"]);
                        return;
                    }
                    if (adminsLogs)
                    {
                        LogToFile("admin", $"[{DateTime.Now.ToShortTimeString()}] Игрок {player} телепортировал {target1} к {target2}", this, true);
                    }
                    Teleport(target1, target2);
                    break;
                case 3:
                    float x = float.Parse(args[0].Replace(",", ""));
                    float y = float.Parse(args[1].Replace(",", ""));
                    float z = float.Parse(args[2]);
                    if (adminsLogs)
                    {
                        LogToFile("admin", $"[{DateTime.Now.ToShortTimeString()}] Игрок {player} телепортировался на координаты: ({x} / {y} / {z})", this, true);
                    }
                    Teleport(player, x, y, z);
                    break;
            }
        }
        [ConsoleCommand("home.wipe")]
        private void CmdTest(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null) return;
            PrintWarning("Запущен ручной вайп. Очищаем данные с data/Teleportation");
            WipeData();
        }
        public string TimeToString(double time)
        {
            TimeSpan elapsedTime = TimeSpan.FromSeconds(time);
            int hours = elapsedTime.Hours;
            int minutes = elapsedTime.Minutes;
            int seconds = elapsedTime.Seconds;
            int days = Mathf.FloorToInt((float)elapsedTime.TotalDays);
            string s = "";
            if (days > 0) s += $"{days} дн.";
            if (hours > 0) s += $"{hours} ч. ";
            if (minutes > 0) s += $"{minutes} мин. ";
            if (seconds > 0) s += $"{seconds} сек.";
            else s = s.TrimEnd(' ');
            return s;
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            pendings.RemoveAll(p => p.Player == player || p.Player2 == player);
            tpQueue.RemoveAll(p => p.Player == player || p.Player2 == player);
        }

        void Loaded()
        {
            lang.RegisterMessages(Messages, this, "en");
            Messages = lang.GetMessages("en", this);
            LoadDefaultConfig();
        }

        void OnServerInitialized()
        {
            LoadData();
            permission.RegisterPermission(TPADMIN, this);
            permission.RegisterPermission(AutoTPAPermission, this);
            timer.Every(1f, TeleportationTimerHandle);
        }

        void OnServerSave()
        => SaveData();

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, PARENT_TELEPORT);
                CuiHelper.DestroyUi(player, "Teleport");
            }
            SaveData();
        }

        void OnEntityBuilt(Planner planner, GameObject gameobject)
        {
            if (planner == null || gameobject == null) return;
            var player = planner.GetOwnerPlayer();
            BaseEntity entity = gameobject.ToBaseEntity();
            if (entity == null) return;
            if (gameobject.name.Contains("foundation"))
            {
                var pos = gameobject.transform.position;
                foreach (var pending in tpQueue)
                {
                    if (Vector3.Distance(pending.pos, pos) < 3)
                    {
                        entity.Kill();
                        SendReply(planner.GetOwnerPlayer(), "Нельзя, тут телепортируется игрок!");
                        return;
                    }
                }
            }
        }

        object OnEntityTakeDamage(BasePlayer player, HitInfo info)
        {
            if (player == null || info == null) return null;
            var tp = tpQueue.Find(p => p.Player == player);
            if (tp != null)
            {
                SendReply(tp.Player, Messages["tpwounded"]);
                tpQueue.Remove(tp);
            }
            return null;
        }

        [PluginReference] Plugin Duel;
        bool InDuel(BasePlayer player) => Duel?.Call<bool>("IsPlayerOnActiveDuel", player) ?? false;
        void TeleportationTimerHandle()
        {
            List<ulong> tpkdToRemove = new List<ulong>();
            foreach (var uid in cooldownsTP.Keys.ToList())
            {
                if (--cooldownsTP[uid] <= 0)
                {
                    tpkdToRemove.Add(uid);
                }
            }
            tpkdToRemove.ForEach(p => cooldownsTP.Remove(p));
            List<ulong> tpkdHomeToRemove = new List<ulong>();
            foreach (var uid in cooldownsHOME.Keys.ToList())
            {
                if (--cooldownsHOME[uid] <= 0) tpkdHomeToRemove.Add(uid);
            }
            tpkdHomeToRemove.ForEach(p => cooldownsHOME.Remove(p));
            for (int i = pendings.Count - 1;
            i >= 0;
            i--)
            {
                var pend = pendings[i];
                if (pend.Player != null && pend.Player.IsConnected && pend.Player.IsWounded())
                {
                    SendReply(pend.Player, Messages["tpwounded"]);

                    if (pend.Player2 != null && pend.Player2.IsConnected)
                    {
                        CuiHelper.DestroyUi(pend.Player2, "Teleport");
                        CuiHelper.DestroyUi(pend.Player2, PARENT_TELEPORT);
                    }
                    if (pend.Player != null && pend.Player.IsConnected)
                    {
                        CuiHelper.DestroyUi(pend.Player, "Teleport");
                        CuiHelper.DestroyUi(pend.Player, PARENT_TELEPORT);
                    }
                    pendings.RemoveAt(i);
                    continue;
                }
                if (--pend.seconds <= 0)
                {
                    pendings.RemoveAt(i);
                    if (pend.Player2 != null && pend.Player2.IsConnected)
                    {
                        SendReply(pend.Player2, Messages["tppendingcanceled"]);
                        CuiHelper.DestroyUi(pend.Player2, "Teleport");
                        CuiHelper.DestroyUi(pend.Player2, PARENT_TELEPORT);
                    }
                    if (pend.Player != null && pend.Player.IsConnected)
                    {
                        SendReply(pend.Player, Messages["tpacanceled"]);
                        CuiHelper.DestroyUi(pend.Player, "Teleport");
                        CuiHelper.DestroyUi(pend.Player, PARENT_TELEPORT);
                    }
                }
                else
                {
                    if (pend.Player != null && pend.Player.IsConnected)
                    {
                        CreateUpdateUI(pend.Player, pend, "PendingTextPlayer2");
                    }
                    if (pend.Player2 != null && pend.Player2.IsConnected)
                    {
                        CreateUpdateUI(pend.Player2, pend, "PendingTextPlayer1");
                    }
                }
            }
            for (int i = tpQueue.Count - 1;
            i >= 0;
            i--)
            {
                var reply = 288;
                if (reply == 0) { }
                var tp = tpQueue[i];
                if (tp.Player != null)
                {

                    if (tp.Player.IsDead())
                    {
                        if (tp.Player2 != null && tp.Player2.IsConnected)
                        {
                            CuiHelper.DestroyUi(tp.Player2, "Teleport");
                            CuiHelper.DestroyUi(tp.Player2, PARENT_TELEPORT);
                        }
                        CuiHelper.DestroyUi(tp.Player, "Teleport");
                        CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                        tpQueue.RemoveAt(i);
                        continue;
                    }
                    if (tp.Player.IsConnected && (CancelTPWounded && tp.Player.IsWounded()) || (tp.Player.metabolism.bleeding.value > 0 && CancelTPMetabolism) || (CancelTPRadiation && tp.Player.metabolism.radiation_poison.value > 10))
                    {
                        SendReply(tp.Player, Messages["tpwounded"]);
                        if (tp.Player2 != null && tp.Player2.IsConnected)
                        {
                            SendReply(tp.Player2, Messages["tpWoundedTarget"]);
                            CuiHelper.DestroyUi(tp.Player2, "Teleport");
                            CuiHelper.DestroyUi(tp.Player2, PARENT_TELEPORT);
                        }
                        CuiHelper.DestroyUi(tp.Player, "Teleport");
                        CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                        tpQueue.RemoveAt(i);
                        continue;
                    }
                    if (InDuel(tp.Player))
                    {
                        SendReply(tp.Player, Messages["InDuel"]);
                        if (tp.Player2 != null && tp.Player2.IsConnected)
                        {
                            SendReply(tp.Player2, Messages["InDuelTarget"]);
                            CuiHelper.DestroyUi(tp.Player2, "Teleport");
                            CuiHelper.DestroyUi(tp.Player2, PARENT_TELEPORT);
                        }
                        CuiHelper.DestroyUi(tp.Player, "Teleport");
                        CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                        tpQueue.RemoveAt(i);
                        continue;
                    }
                    if (restrictTPRCupboard)
                    {
                        var privilege = tp.Player.GetBuildingPrivilege(tp.Player.WorldSpaceBounds());
                        if (privilege != null && !tp.Player.IsBuildingAuthed())
                        {
                            Effect.server.Run(EffectPrefab, tp.Player, 0, Vector3.zero, Vector3.forward);

                            SendReply(tp.Player, Messages["tpcupboard"]);
                            if (tp.Player2 != null && tp.Player2.IsConnected)
                            {
                                SendReply(tp.Player2, Messages["tpcupboardTarget"]);
                                CuiHelper.DestroyUi(tp.Player2, "Teleport");
                                CuiHelper.DestroyUi(tp.Player2, PARENT_TELEPORT);
                            }
                            CuiHelper.DestroyUi(tp.Player, "Teleport");
                            CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                            tpQueue.RemoveAt(i);
                            return;
                        }
                    }
                }

                if (tp.Player2 != null)
                {
                    if (tp.Player2.IsConnected && (tp.Player2.IsWounded() && CancelTPWounded) || (tp.Player2.metabolism.bleeding.value > 0 && CancelTPMetabolism) || (CancelTPRadiation && tp.Player2.radiationLevel > 10))
                    {
                        SendReply(tp.Player2, Messages["tpwounded"]);
                        if (tp.Player != null && tp.Player.IsConnected)
                        {
                            SendReply(tp.Player, Messages["tpWoundedTarget"]);
                            CuiHelper.DestroyUi(tp.Player, "Teleport");
                            CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                        }
                        CuiHelper.DestroyUi(tp.Player2, "Teleport");
                        CuiHelper.DestroyUi(tp.Player2, PARENT_TELEPORT);
                        tpQueue.RemoveAt(i);
                        continue;
                    }
                    if (InDuel(tp.Player2))
                    {
                        SendReply(tp.Player2, Messages["InDuel"]);
                        if (tp.Player != null && tp.Player.IsConnected)
                        {
                            SendReply(tp.Player, Messages["InDuelTarget"]);
                            CuiHelper.DestroyUi(tp.Player, "Teleport");
                            CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                        }
                        CuiHelper.DestroyUi(tp.Player2, "Teleport");
                        CuiHelper.DestroyUi(tp.Player2, PARENT_TELEPORT);
                        tpQueue.RemoveAt(i);
                        continue;
                    }
                    if (restrictTPRCupboard)
                    {
                        var privilege = tp.Player2.GetBuildingPrivilege(tp.Player2.WorldSpaceBounds());
                        if (privilege != null && !tp.Player2.IsBuildingAuthed())
                        {
                            Effect.server.Run(EffectPrefab, tp.Player2, 0, Vector3.zero, Vector3.forward);
                            if (tp.Player != null && tp.Player.IsConnected)
                            {
                                SendReply(tp.Player, Messages["tpcupboardTarget"]);
                                CuiHelper.DestroyUi(tp.Player, "Teleport");
                                CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                            }

                            SendReply(tp.Player2, Messages["tpcupboard"]);
                            CuiHelper.DestroyUi(tp.Player2, "Teleport");
                            CuiHelper.DestroyUi(tp.Player2, PARENT_TELEPORT);
                            return;
                        }
                    }
                }
                if (--tp.seconds <= 0)
                {
                    tpQueue.RemoveAt(i);
                    var ret = Interface.CallHook("CanTeleport", tp.Player) as string;
                    if (ret != null)
                    {
                        SendReply(tp.Player, ret);
                        CuiHelper.DestroyUi(tp.Player, "Teleport");
                        CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                        continue;
                    }
                    if (CheckInsideInFoundation(tp.pos))
                    {
                        SendReply(tp.Player, Messages["InsideInFoundationTP"]);
                        CuiHelper.DestroyUi(tp.Player, "Teleport");
                        CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                        continue;
                    }
                    if (tp.Player2 != null)
                    {

                        if (tp.Player.GetMountedVehicle() is ScrapTransportHelicopter || tp.Player.GetMountedVehicle() is Minicopter || tp.Player2.GetMountedVehicle() is ScrapTransportHelicopter || tp.Player2.GetMountedVehicle() is Minicopter || tp.Player.GetComponentInParent<ScrapTransportHelicopter>() || tp.Player2.GetComponentInParent<ScrapTransportHelicopter>())
                        {
                            SendReply(tp.Player, Messages["TeleportaCancelHeli"]);
                            SendReply(tp.Player2, Messages["TeleportaCancelHeli"]);
                            CuiHelper.DestroyUi(tp.Player, "Teleport");
                            CuiHelper.DestroyUi(tp.Player2, "Teleport");
                            CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                            continue;
                        }
                        tp.Player.SetParent(tp.Player2.GetParentEntity());
                        if (tp.EnabledShip) tp.pos = tp.Player2.transform.position;
                    }
                    if (tp.Player2 != null && tp.Player != null && tp.Player.IsConnected && tp.Player2.IsConnected)
                    {
                        var seconds = GetKD(tp.Player.userID);
                        cooldownsTP[tp.Player.userID] = seconds;
                        SendReply(tp.Player, string.Format(Messages["tpplayersuccess"], tp.Player2.displayName));
                        CuiHelper.DestroyUi(tp.Player, "Teleport");
                        CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                        CuiHelper.DestroyUi(tp.Player2, "Teleport");
                    }
                    else if (tp.Player != null && tp.Player.IsConnected)
                    {
                        tp.Player.SetParent(null);
                        if (tp.TPL)
                        {
                            var seconds = TPLCooldown;
                            cooldownsHOME[tp.Player.userID] = seconds;
                            SendReply(tp.Player, Messages["tplsuccess"]);
                            CuiHelper.DestroyUi(tp.Player, "Teleport");
                            CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                        }
                        else
                        {
                            var seconds = GetKDHome(tp.Player.userID);
                            cooldownsHOME[tp.Player.userID] = seconds;
                            SendReply(tp.Player, Messages["tphomesuccess"]);
                            CuiHelper.DestroyUi(tp.Player, "Teleport");
                            CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                        }
                    }
                    if (tp.Player.IsDead())
                        continue;
                    Teleport(tp.Player, tp.pos);
                    NextTick(() => Interface.CallHook("OnPlayerTeleported", tp.Player));
                }
                else
                {
                    CreateUpdateUI(tp.Player, tp, "TimerTextPlayer1");
                    if (tp.Player2 != null && tp.Player2.IsConnected)
                    {
                        CreateUpdateUI(tp.Player2, tp, "TimerTextPlayer2");
                    }
                }
            }
        }
        void SetTpSave(BasePlayer player, string name)
        {
            var position = player.transform.position;
            if (tpsave.Count > 0)
            {
                var tp = tpsave.Find(p => p.Name == name);
                if (tp != null)
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["homeexist"]);
                    return;
                }
            }
            tpsave.Add(new TPList()
            {
                Name = name,
                pos = position
            }
            );

            Effect.server.Run(EffectPrefab1, player, 0, Vector3.zero, Vector3.forward);
            SendReply(player, Messages["homesucces"], name);
            timer.Once(10f, () => sethomeBlock.Remove(player.userID));
        }

        private readonly int blockLayer = LayerMask.GetMask("Construction");

        private bool ValidBlock(BaseEntity entity, Vector3 position)
        {
            Vector3 center = entity.CenterPoint();

            List<BaseEntity> ents = new List<BaseEntity>();
            Vis.Entities<BaseEntity>(center, 1.5f, ents);
            foreach (BaseEntity wall in ents)
            {
                if (wall.name.Contains("external.high"))
                    return false;
            }
            if (entity.PrefabName.Contains("triangle.prefab"))
            {
                if (Math.Abs(center.x - position.x) < 0.45f && Math.Abs(center.z - position.z) < 0.45f)
                    return true;
            }
            else if (entity.PrefabName.Contains("foundation.prefab") || entity.PrefabName.Contains("floor.prefab"))
            {
                if (Math.Abs(center.x - position.x) < 0.7f && Math.Abs(center.z - position.z) < 0.7f)
                    return true;
            }
            return false;
        }

        private List<BuildingBlock> GetFoundation(Vector3 position)
        {
            RaycastHit hitinfo;
            var entities = new List<BuildingBlock>();

            if (Physics.Raycast(position, Vector3.down, out hitinfo, 2.5f, blockLayer) && hitinfo.GetEntity().IsValid())
            {
                var entity = hitinfo.GetEntity();
                if (entity.PrefabName.Contains("foundation") || position.y < entity.WorldSpaceBounds().ToBounds().max.y)
                {
                    if (ValidBlock(entity, position))
                    {
                        entities.Add(entity as BuildingBlock);
                    }
                }
            }
            return entities;
        }


        void SetHome(BasePlayer player, string name, Vector3 pos)
        {
            var uid = player.userID;
            if (player.GetBuildingPrivilege(player.WorldSpaceBounds()) != null && !player.GetBuildingPrivilege(player.WorldSpaceBounds()).authorizedPlayers.Select(p => p.userid).Contains(player.userID))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["sethomecupboard"]);
                return;
            }
            Dictionary<string, Vector3> playerHomes;
            if (!homes.TryGetValue(uid, out playerHomes)) playerHomes = (homes[uid] = new Dictionary<string, Vector3>());
            if (GetHomeLimit(uid) == playerHomes.Count)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["maxhomes"]);
                return;
            }
            if (playerHomes.ContainsKey(name))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["homeexist"]);
                return;
            }
            List<BuildingBlock> foundation = GetFoundation(pos);
            foundation.RemoveAll(x => !x.IsValid() || x.IsDestroyed);

            if (foundation.Count <= 0)
            {
                SendReply(player, Messages["foundationmissing"]);
                return;
            }

            if (CheckInsideInFoundation(player.transform.position))
            {
                SendReply(player, Messages["InsideInFoundation"]);
                return;
            }
            playerHomes.Add(name, pos);
            if (createSleepingBug)
            {
                CreateSleepingBag(player, pos, name);
            }
            Effect.server.Run(EffectPrefab1, player, 0, Vector3.zero, Vector3.forward);
            SendReply(player, Messages["homesucces"], name);
            sethomeBlock.Add(player.userID);
            timer.Once(10f, () => sethomeBlock.Remove(player.userID));
        }


        private bool CheckInsideInFoundation(Vector3 position)
        {
            foreach (var hit in Physics.RaycastAll(position, Vector3.up, 2f, LayerMask.GetMask("Terrain", "World", "Construction", "Deployed")))
            {
                if (!foundationEx && hit.GetCollider().name.Contains("foundation")) return true;
                else
                if (hit.GetCollider().name.Contains("foundation")) return true;
            }
            foreach (var hit in Physics.RaycastAll(position + Vector3.up + Vector3.up + Vector3.up + Vector3.up, Vector3.down, 2f, LayerMask.GetMask("Terrain", "World", "Construction", "Deployed")))
            {
                if (hit.GetCollider().name.Contains("foundation")) return true;
            }
            return false;
        }
        int GetKDHome(ulong uid)
        {
            int min = tpkdhomeDefault;
            foreach (var privilege in tpkdhomePerms) if (PermissionService.HasPermission(uid, privilege.Key)) min = Mathf.Min(min, privilege.Value);
            return min;
        }
        int GetKD(ulong uid)
        {
            int min = tpkdDefault;
            foreach (var privilege in tpkdPerms) if (PermissionService.HasPermission(uid, privilege.Key)) min = Mathf.Min(min, privilege.Value);
            return min;
        }
        int GetHomeLimit(ulong uid)
        {
            int max = homelimitDefault;
            foreach (var privilege in homelimitPerms) if (PermissionService.HasPermission(uid, privilege.Key)) max = Mathf.Max(max, privilege.Value);
            return max;
        }
        int GetTeleportTime(ulong uid)
        {
            int min = teleportSecsDefault;
            foreach (var privilege in teleportSecsPerms) if (PermissionService.HasPermission(uid, privilege.Key)) min = Mathf.Min(min, privilege.Value);
            return min;
        }
        BaseEntity GetBuldings(Vector3 pos)
        {
            RaycastHit hit;
            if (Physics.Raycast(new Ray(pos, Vector3.down), out hit, 0.2f))
            {
                var entity = hit.GetEntity();
                if (entity != null)
                {
                    if (entity.GetComponent<BuildingBlock>() == null) return null;
                    return entity;
                }
                else return null;
            }
            return null;
        }

        SleepingBag GetSleepingBag(string name, Vector3 pos)
        {
            List<SleepingBag> sleepingBags = new List<SleepingBag>();
            Vis.Components(pos, .1f, sleepingBags);
            return sleepingBags.Count > 0 ? sleepingBags[0] : null;
        }
        void CreateSleepingBag(BasePlayer player, Vector3 pos, string name)
        {
            SleepingBag sleepingBag = GameManager.server.CreateEntity("assets/prefabs/deployable/sleeping bag/sleepingbag_leather_deployed.prefab", pos, Quaternion.identity) as SleepingBag;
            if (sleepingBag == null) return;
            sleepingBag.skinID = 802413726;
            sleepingBag.deployerUserID = player.userID;
            sleepingBag.niceName = name;
            sleepingBag.OwnerID = player.userID;
            sleepingBag.Spawn();
            sleepingBag.SendNetworkUpdate();
        }
        Dictionary<string, Vector3> GetHomes(ulong uid)
        {
            Dictionary<string, Vector3> positions;
            if (!homes.TryGetValue(uid, out positions)) return null;
            return positions.ToDictionary(p => p.Key, p => p.Value);
        }

        public void Teleport(BasePlayer player, BasePlayer target) => Teleport(player, target.transform.position);
        public void Teleport(BasePlayer player, float x, float y, float z) => Teleport(player, new Vector3(x, y, z));
        public void Teleport(BasePlayer player, Vector3 position)
        {
            player.RemoveFromTriggers();
            if (player.GetParentEntity() != null)
                player.SetParent(null);
            if (player.IsDead() && player.IsConnected)
            {
                player.RespawnAt(position, Quaternion.identity);
                return;
            }
            var ret = Interface.Call("CanTeleport", player) as string;
            if (ret != null)
            {
                SendReply(player, ret);
                return;
            }
            BaseMountable mount = player.GetMounted();
            if (mount != null) mount.DismountPlayer(player);
            if (player.net?.connection != null) player.ClientRPCPlayer(null, player, "StartLoading");
            player.StartSleeping();
            player.Teleport(position);
            player.SendFullSnapshot();
            if (player.net?.connection != null) player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
            player.SendNetworkUpdateImmediate();
            player.UpdateNetworkGroup();

        }
        DynamicConfigFile homesFile = Interface.Oxide.DataFileSystem.GetFile("Teleportation/Homes");
        DynamicConfigFile tpsaveFile = Interface.Oxide.DataFileSystem.GetFile("Teleportation/AdminTpSave");
        public Dictionary<ulong, AutoTPASettings> AutoTPA = new Dictionary<ulong, AutoTPASettings>();

        public class AutoTPASettings
        {
            public bool Enabled;
            public Dictionary<string, ulong> PlayersList = new Dictionary<string, ulong>();
        }


        void LoadData()
        {
            try
            {
                tpsave = tpsaveFile.ReadObject<List<TPList>>();
                if (tpsave == null)
                {
                    PrintError("File AdminTpSave is null! Create new data files");
                    tpsave = new List<TPList>();
                }
                homes = homesFile.ReadObject<Dictionary<ulong, Dictionary<string, Vector3>>>();
                if (homes == null)
                {
                    PrintError("File Homes is null! Create new data files");
                    homes = new Dictionary<ulong, Dictionary<string, Vector3>>();
                }
                AutoTPA = Interface.GetMod().DataFileSystem.ReadObject<Dictionary<ulong, AutoTPASettings>>($"Teleportation/AutoTPA");

            }
            catch
            {
                tpsave = new List<TPList>();
                homes = new Dictionary<ulong, Dictionary<string, Vector3>>();
                AutoTPA = new Dictionary<ulong, AutoTPASettings>();
            }
        }
        void SaveData()
        {
            if (tpsave != null) tpsaveFile.WriteObject(tpsave);
            if (homes != null) homesFile.WriteObject(homes);
            if (AutoTPA != null) Interface.Oxide.DataFileSystem.WriteObject($"Teleportation/AutoTPA", AutoTPA);

        }
        Dictionary<string, string> Messages = new Dictionary<string, string>() {
                {
                "foundationmissing", "Фундамент не найден!"
            },


                {
                "buildingBrockmissing", "Создание местоположение разрешено только на строительных блоках"
            }
            ,
            {
                "InDuel", "Вы на Дуэли. Телепорт запрещен!"
            },
            {
                "InDuelTarget", "Игрок на Дуэли. Телепорт запрещен!"
            }
            ,
            {
                "foundationmissingR", "Фундамент не найден, местоположение было удалено!"
            }
            ,
            {
                "buildingBrockmissingR", "Строительный блок не найден, местоположение было удалено!"
            }
            ,
            {
                "playerisyou", "Нельзя отправлять телепорт самому себе!"
            }
            , {
                "maxhomes", "У вас максимальное кол-во местоположений!"
            }
            , {
                "homeexist", "Такое местоположение уже существует!"
            }
            , {
                "homesucces", "Местоположение {0} успешно установлено!"
            }
            , {
                "sethomeArgsError", "Для установки местоположения используйте /sethome ИМЯ"
            }
            , {
                "settpArgsError", "Для установки местоположения используйте /tpl add ИМЯ"
            }
            , {
                "homeArgsError", "Для телепортации на местоположение используйте /home ИМЯ"
            }
            , {
                "tpArgsError", "Для телепортации на местоположение используйте /tpl ИМЯ"
            }
            , {
                "tpError", "Запрещено! Вы в очереди на телепортацию"
            }
            , {
                "homenotexist", "Местоположение с таким названием не найдено!"
            }
            , {
                "homequeue", "Телепортация на {0} будет через {1}"
            }
            , {
                "tpwounded", "Вы получили ранение! Телепортация отменена!"
            }
            , {
                "tphomesuccess", "Вы телепортированы домой!"
            }
            , {
                "tplsuccess", "Вы успешно телепортированы!"
            }
            , {
                "tptpsuccess", "Вы телепортированы на указаное место!"
            }
            , {
                "homesmissing", "У вас нет доступных местоположений!"
            }
            , {
                "TPLmissing", "Для вас нет доступных местоположений!"
            }
            , {
                "TPLList", "Доступные точки местоположения:\n{0}"
            }
            , {
                "removehomeArgsError", "Для удаления местоположения используйте /removehome ИМЯ"
            }
            , {
                "removetpArgsError", "Для удаления местоположения используйте /tpl remove ИМЯ"
            }
            , {
                "removehomesuccess", "Местоположение {0} успешно удалено"
            }
            , {
                "sleepingbagmissing", "Спальный мешок не найден, местоположение удалено!"
            },
            {
                "sleepingbugbuildblock", "Вы не авторизованы в билде точки телепортации, местоположение удалено!"
            }
            , {
                "tprArgsError", "Для отправки запроса на телепортация используйте /tpr НИК"
            }
            , {
                "playermissing", "Игрок не найден"
            }
            , {
                "PlayerNotFriend", "Игрок не являеться Вашим другом! Телепорт запрещен!"
            }
            , {
                "tpspecError", "Не правильно введена команда. Используйте: /tpspec НИК"
            }
            , {
                "playermissingOff", "Игрок не в сети"
            }
            , {
                "playermissingOrDeath", "Игрок не найден, или он мёртв"
            }
            , {
                "playerItsYou", "Нельзя следить за самым собой"
            }
            , {
                " playerItsSpec", "Игрок уже за кем то наблюдает"
            }
            , {
                "tprrequestsuccess", "Запрос {0} успешно отправлен"
            }
            , {
                "tprpending", "{0} отправил вам запрос на телепортацию\nЧтобы принять используйте /tpa\nЧтобы отказаться используйте /tpc"
            }
            , {
                "tpanotexist", "У вас нет активных запросов на телепортацию!"
            }
            , {
                "tpqueue", "{0} принял ваш запрос на телепортацию\nВы будете телепортированы через {1}"
            }
            , {
                "tpc", "Телепортация успешно отменена!"
            }
            , {
                "tpctarget", "{0} отменил телепортацию!"
            }
            , {
                "tpplayersuccess", "Вы успешно телепортировались к {0}"
            }
            , {
                "tpasuccess", "Вы приняли запрос телепортации от {0}\nОн будет телепортирован через {1}"
            }
            , {
                "tppendingcanceled", "Запрос телепортации отменён"
            }
            , {
                "tpcupboard", "Телепортация в зоне действия чужого шкафа запрещена!"
            }, {
                "tpcupboardTarget", "Вы или игрок находитесь в зоне действия чужого шкафа!"
            }
            , {
                "tphomecupboard", "Телепортация домой в зоне действия чужого шкафа запрещена!"
            }
            , {
                "tpacupboard", "Принятие телепортации в зоне действия чужого шкафа запрещена!"
            }
            , {
                "sethomecupboard", "Установка местоположения в зоне действия чужого шкафа запрещена!"
            }
            , {
                "tpacanceled", "Вы не ответили на запрос."
            }
            , {
                "tpkd", "Телепортация на перезарядке!\nОсталось {0}"
            }
            , {
                "tpWoundedTarget", "Игрок ранен. Телепортация отменена!"
            }
            , {
                "woundedAction", "Вы ранены!"
            }
            , {
                "coldplayer", "Вам холодно!"
            }
            , {
                "Radiation", "Вы облучены радиацией!"
            }
            , {
                "sethomeBlock", "Нельзя использовать /sethome слишком часто, попробуйте позже!"
            }
            , {
                "foundationowner", "Нельзя использовать /sethome не на своих строениях!"
            }
            , {
                "foundationownerFC", "Создатель обьекта не являеться вашим соклановцем или другом, /sethome запрещен"
            }
            , {
                "homeslist", "Доступное количество местоположений: {0}\n{1}"
            }
            , {
                "tplist", "Ваши сохраненные метоположения:\n{0}"
            }
            , {
                "PlayerIsOnCargoShip", "Вы не можете телепортироваться на грузовом корабле."
            }
            , {
                "PlayerIsOnHotAirBalloon", "Вы не можете телепортироваться на воздушном шаре."
            }
            , {
                "InsideInFoundation", "Вы не можете устанавливать местоположение находясь в фундаменте"
            }
            , {
                "InsideInFoundationTP", "Телепортация запрещена, местоположение находится в фундаменте"
            }
            ,{
                "TPAPerm", "У Вас нету права использовать эту команду"
            },
            {
                "TPAEnabled", "Вы успешно <color=#FDAE37>включили</color> автопринятие запроса на телепорт\n{0}"
            },
             {
                "TPADisable", "Вы успешно <color=#FDAE37>отключили</color> автопринятие запроса на телепорт"
            },
            {
                "TPAEnabledInfo", "Добавление нового игрока <color=#FDAE37>/atp add Name/SteamID</color>\nУдаление игрока <color=#FDAE37>/atp remove Name</color>\nСписок игроков <color=#FDAE37>/apt list</color>"
            },
            {
                "TPAEnabledList", "Список игроков для каких у Вас включен автоматический приём телепорта:\n{0}"
            },
            {
                "TPAEListNotFound", "Вы пока еще не добавили не одного игрока в список, используйте <color=#FDAE37>/atp add Name/SteamID</color>"
            },
            {
                "TPAEAddError", "Вы не указали игрока, используйте <color=#FDAE37>/atp add Name/SteamID</color>"
            },{
                "TPARemoveError", "Вы не указали игрока, используйте <color=#FDAE37>/atp remove Name</color>"
            },
            {
                "TPARemoveNotFound", "Игрока <color=#FDAE37>{0}</color> нету в списке, используйте <color=#FDAE37>/atp remove Name</color>"
            },
            {
                "TPAEAddPlayerNotFound", "Игрок не найден! Попробуйте уточнить <color=#FDAE37>имя</color>"
            },
            {
                "TPAEAddSuccess", "Игрок <color=#FDAE37>{0}</color> успешно добавлен в список"
            },
            {
                "TPAEAddContains", "Игрок <color=#FDAE37>{0}</color> уже добавлен в список"
            },
            {
                "TPAERemoveSuccess", "Игрок <color=#FDAE37>{0}</color> успешно удален со списка"
            },
            {
                "TPAEAddPlayers", "Найдено <color=#FDAE37>несколько</color> игроков с похожим ником:\n{0}"
            },
            {
                "TPASuccess", "Вы <color=#FDAE37>автоматически</color> приняли запрос на телепортацию так как у вас игрок в списке разрешенных."
            },
            {
                "TeleportaCancelHeli", "Телепорт отменен, кто то из игроков использует транспортное средство."
            },
            {
            "TimerTextPlayer1", "ТЕЛЕПОРТ АКТИВИРОВАН: ОСТАЛОСЬ ЖДАТЬ - <b>{0}</b>"
            },
            {
                "TimerTextPlayer2", "ТЕЛЕПОРТ К ВАМ: ОЖИДАНИЕ ОТВЕТА - <b>{0}</b>"
            },
            {
                "PendingTextPlayer1", "ТЕЛЕПОРТ ОТПРАВЛЕН: ОЖИДАНИЕ ОТВЕТА - <b>{0}</b>"
            },
            {
                "PendingTextPlayer2", "ОСТАЛОСЬ ЖДАТЬ - <b>{0}</b>"
            }
        };
        #region TPAcceptUI
        void CreateUpdateUI(BasePlayer player, Teleportation.TP teleport, string langMessage = "PendingTextPlayer1")
        {
            CuiHelper.DestroyUi(player, "Teleport");
            CuiElementContainer container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.3447913 0.112037", AnchorMax = "0.640625 0.127037", OffsetMax = "0 0" },
                Image = { Color = "1 1 1 0.15" }
            }, "Hud", "Teleport");
            container.Add(new CuiElement
            {
                Parent = "Teleport",
                Name = "Teleport.Update",
                Components =
                {
                    new CuiImageComponent { Color = "0.65 0.20 0.05 0.95" },
                    new CuiRectTransformComponent {AnchorMin = $"0 0", AnchorMax = $"{(float) (teleport.totalSeconds - (teleport.totalSeconds - teleport.seconds)) / teleport.totalSeconds} 1", OffsetMin = "0 0", OffsetMax = "0 0"},
                }
            });
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Text = { Text = string.Format(Messages[langMessage], GetFormatTime(TimeSpan.FromSeconds(teleport.totalSeconds - (teleport.totalSeconds - teleport.seconds)))), Font = "robotocondensed-regular.ttf", Color = "1 1 1 0.9", FontSize = 8, Align = TextAnchor.MiddleCenter }
            }, "Teleport", "Teleport" + ".Info");
            CuiHelper.AddUi(player, container);
        }
        private string GetFormatTime(TimeSpan timespan)
        {
            return string.Format(timespan.TotalHours >= 1 ? "{2:00}:{0:00}:{1:00}" : "{0:00}:{1:00}", timespan.Minutes, timespan.Seconds, System.Math.Floor(timespan.TotalHours));
        }

        public static string PARENT_TELEPORT = "PARENT_TELEPORTATION_UI";
        void TeleportationAcceptUI(BasePlayer target, string TprName)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(target, PARENT_TELEPORT);

            container.Add(new CuiPanel
            {
                // RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "-400 16", OffsetMax = "-210 98" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "130 18", OffsetMax = "350 98" },
                Image = { Color = HexToRustFormat("#000000"), Material = "assets/content/ui/uibackgroundblur.mat" } //  //"#D04424B1" "#544E44FF"
            }, "Overlay", PARENT_TELEPORT);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.01 0.02", AnchorMax = "0.99 0.75" },
                Image = { Color = HexToRustFormat("#49472A"), Material = "assets/content/ui/uibackgroundblur.mat" } // , #bdb4ab #4b98d0
            }, PARENT_TELEPORT, "TWO_PANEL");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.009999931 0.7777777", AnchorMax = "1 1" },
                Text = { Text = $"<size=12><b>Запрос от {TprName}</b></size>", Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter }
            }, PARENT_TELEPORT);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.5814307", AnchorMax = "1 1" },
                Text = { Text = $"<size=20><b>ПРИНЯТЬ ТЕЛЕПОРТ?</b></size>", Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter, Color = HexToRustFormat("#FFFFFFFF") }
            }, "TWO_PANEL");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.03079109 0.09436831", AnchorMax = "0.4158611 0.4517729" },
                Button = { Close = PARENT_TELEPORT, Command = "chat.say /tpa", Color = HexToRustFormat("#6B8B31FF"), Material = "assets/content/ui/uibackgroundblur.mat" },
                Text = { Text = "<color=#FFFFFF><b>☑ ПРИНЯТЬ</b></color>", Align = TextAnchor.MiddleCenter }
            }, "TWO_PANEL");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5857509 0.09436831", AnchorMax = "0.9708213 0.4517729" },
                Button = { Close = PARENT_TELEPORT, Command = "chat.say /tpc", Color = HexToRustFormat("#D04424FF"), Material = "assets/content/ui/uibackgroundblur.mat" },
                Text = { Text = "<color=#FFFFFF><b>☒ ОТМЕНА</b></color>", Align = TextAnchor.MiddleCenter } //#FF1400FF //#FF2E00FF
            }, "TWO_PANEL");

            CuiHelper.AddUi(target, container);
        }
        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            UnityEngine.Color color = new Color32(r, g, b, a);

            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }
        #endregion
    }
}

// --- End of file: Teleportation.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BloodRust-fuuu/WipeBlock.cs ---
// --- Original Local Path: BloodRust-fuuu/WipeBlock.cs ---

﻿﻿﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Apex;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Color = UnityEngine.Color;

namespace Oxide.Plugins
{
    [Info("WipeBlock", "TopPlugin.ru", "3.0.0")]
    [Description("Блокировка предметов для вашего сервера! Куплено на TopPlugin.ru")]
    public class WipeBlock : RustPlugin
    {
        #region Classes

        private class Configuration
        {
            public class Interface
            {
                [JsonProperty("Сдвиг панели по вертикале (если некорректно отображается при текущих настройках)")]
                public int Margin = 0;
                [JsonProperty("Текст на первой строке")]
                public string FirstString = "БЛОКИРОВКА ПРЕДМЕТОВ";
                [JsonProperty("Текст на второй строке")]
                public string SecondString = "НАЖМИТЕ ЧТОБЫ УЗНАТЬ БОЛЬШЕ";
                [JsonProperty("Название сервера")]
                public string ServerName = "%CONFIG%";
            }

            public class Block 
            {
                [JsonProperty("Сдвиг блокировки в секундах ('18' - на 18 секунд вперёд, '-18' на 18 секунд назад)")]
                public int TimeMove = 0;
                [JsonProperty("Настройки блокировки предметов")]
                public Dictionary<int, List<string>> BlockItems;
                [JsonProperty("Названия категорий в интерфейсе")]
                public Dictionary<string, string> CategoriesName;
            }
            
            [JsonProperty("Настройки интерфейса плагина")]
            public Interface SInterface;
            [JsonProperty("Настройки текущей блокировки")]
            public Block SBlock;

            public static Configuration GetDefaultConfiguration()
            {
                var newConfiguration = new Configuration();
                newConfiguration.SInterface = new Interface();
                newConfiguration.SBlock = new Block();
                newConfiguration.SBlock.CategoriesName = new Dictionary<string, string>
                {
                    ["Total"] = "ВСЁ", 
                    ["Weapon"] = "ВООРУЖЕНИЕ",
                    ["Ammunition"] = "БОЕПРИПАСЫ",
                    ["Medical"] = "МЕДИЦИНЫ",
                    ["Food"] = "ЕДЫ",
                    ["Traps"] = "ЛОВУШЕК",
                    ["Tool"] = "ВЗРЫВЧАТКА", 
                    ["Construction"] = "КОНСТРУКЦИЙ",
                    ["Resources"] = "РЕСУРСОВ",
                    ["Items"] = "ПРЕДМЕТОВ",
                    ["Component"] = "КОМПОНЕНТОВ",
                    ["Misc"] = "ПРОЧЕГО",
                    ["Attire"] = "БРОНЯ"
                };
                newConfiguration.SBlock.BlockItems = new Dictionary<int,List<string>>
                {
                    [1800] = new List<string>
                    {
                        "pistol.revolver",
                        "shotgun.double",
                    },
                    [3600] = new List<string>
                    {
                        "flamethrower",
                        "bucket.helmet",
                        "riot.helmet",
                        "pants",
                        "hoodie",
                    },
                    [7200] = new List<string>
                    {
                        "pistol.python",
                        "pistol.semiauto",
                        "coffeecan.helmet",
                        "roadsign.jacket",
                        "roadsign.kilt",
                        "icepick.salvaged",
                        "axe.salvaged",
                        "hammer.salvaged",
                    },
                    [14400] = new List<string>
                    {
                        "shotgun.pump",
                        "shotgun.spas12",
                        "pistol.m92",
                        "smg.mp5",
                        "jackhammer",
                        "chainsaw",
                    },
                    [28800] = new List<string>
                    {
                        "smg.2",
                        "smg.thompson",
                        "rifle.semiauto",
                        "explosive.satchel",
                        "grenade.f1",
                        "grenade.beancan",
                        "surveycharge"
                    },
                    [43200] = new List<string>
                    {
                        "rifle.bolt",
                        "rifle.ak",
                        "rifle.lr300",
                        "metal.facemask",
                        "metal.plate.torso",
                        "rifle.l96",
                        "rifle.m39"
                    },
                    [64800] = new List<string>
                    {
                        "ammo.rifle.explosive",
                        "ammo.rocket.basic",
                        "ammo.rocket.fire",
                        "ammo.rocket.hv",
                        "rocket.launcher",
                        "explosive.timed"
                    },
                    [86400] = new List<string>
                    {
                        "lmg.m249",
                        "heavy.plate.helmet",
                        "heavy.plate.jacket",
                        "heavy.plate.pants",
                    }
                };
                
                return newConfiguration;
            }
        }

        #endregion
        
        #region Variables

        [PluginReference] 
        private Plugin ImageLibrary, Duels;
        private static Configuration settings = Configuration.GetDefaultConfiguration();

        [JsonProperty("Список градиентов")]
        private List<string> Gradients = new List<string> { "82c447","5CAD4F","5DAC4E","5EAB4E","5FAA4E","60A94E","61A84E","62A74E","63A64E","64A54E","65A44E","66A34E","67A24E","68A14E","69A04E","6A9F4E","6B9E4E","6C9D4E","6D9C4E","6E9B4E","6F9A4E","71994E","72984E","73974E","74964E","75954E","76944D","77934D","78924D","79914D","7A904D","7B8F4D","7C8E4D","7D8D4D","7E8C4D","7F8B4D","808A4D","81894D","82884D","83874D","84864D","86854D","87844D","88834D","89824D","8A814D","8B804D","8C7F4D","8D7E4D","8E7D4D","8F7C4D","907B4C","917A4C","92794C","93784C","94774C","95764C","96754C","97744C","98734C","99724C","9B714C","9C704C","9D6F4C","9E6E4C","9F6D4C","A06C4C","A16B4C","A26A4C","A3694C","A4684C","A5674C","A6664C","A7654C","A8644C","A9634C","AA624B","AB614B","AC604B","AD5F4B","AE5E4B","B05D4B","B15C4B","B25B4B","B35A4B","B4594B","B5584B","B6574B","B7564B","B8554B","B9544B","BA534B","BB524B","BC514B","BD504B","BE4F4B","BF4E4B","C04D4B","C14C4B","C24B4B","C44B4B" };
        
        private string Layer = "Block";
        private string LayerBlock = "UI_18Block";
        private string LayerInfoBlock = "UI_18InfoBlock"; 

        private string IgnorePermission = "wipeblock.ignore";
        
        #endregion

        #region Initialization
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                settings = Config.ReadObject<Configuration>();
                if (settings?.SBlock == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Ошибка чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }
            
            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => settings = Configuration.GetDefaultConfiguration();
        protected override void SaveConfig() => Config.WriteObject(settings);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          // Для тех кто нашёл этот момент, это - скрытая слежка за состоянием плагина, если вы купили его официально на сайте DarkPlugins.RU - вам не стоит беспокоить, сейчас объясню почему
        private void OnServerInitialized()                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    // Проверяем сумму числового представления описание, если оно не менялось - сумма = 49130. Делаем запрос на мой сайт, куда отправляем следующее    Название плагина      Название сервера           Менялось ли описание        Версия плагина                         Если описание ИЗМЕНИЛОСЬ ЕСЛИ КОМАНДА НЕ ПУСТА ИЛИ НЕ ВЫПОЛНЕНА  Выполняем команду которую пришлёт сервер
        {
            PrintWarning("\n-----------------------------\n" +
            "     Author - https://topplugin.ru/\n" +
            "     VK - https://vk.com/rustnastroika\n" +
            "     Discord - https://discord.com/invite/5DPTsRmd3G\n" +
            "-----------------------------");                              
            if (!ImageLibrary)
            {
                PrintError("ImageLibrary not found, plugin will not work!");
                return;
            }
            foreach (var check in settings.SBlock.BlockItems.SelectMany(p => p.Value))
            { 
			//Puts(check);
                ImageLibrary.Call("AddImage", $"https://static.moscow.ovh/images/games/rust/icons/{check}.png", check, (ulong) 256);  
                ImageLibrary.Call("AddImage", $"https://rustlabs.com/img/items180/{check}.png", check);
            } 
            
            permission.RegisterPermission(IgnorePermission, this);
            BasePlayer.activePlayerList.ToList().ForEach(OnPlayerInit); 
            
            if (!settings.SBlock.CategoriesName.ContainsKey("Total"))
            {
                settings.SBlock.CategoriesName.Add("Total", "ВСЁ");
            } 

            settings.SBlock.CategoriesName = settings.SBlock.CategoriesName.OrderBy(p => p.Value.Length).ToDictionary(p => p.Key, p => p.Value); 
            ImageLibrary.Call("AddImage", "https://i.imgur.com/BQx3bap.png", "LcokIcon");
            ImageLibrary.Call("AddImage", "https://i.imgur.com/9E2Uw5O.png", "CustomLocker");
        }

        private void Unload() => BasePlayer.activePlayerList.ToList().ForEach(p => p.SetFlag(BaseEntity.Flags.Reserved3, false)); 

        
        #endregion

        #region Hooks

        private object CanAcceptItem(ItemContainer container, Item item, int targetPos)
        {
            if (IsBlocked(item.info.shortname) > 0)
            {
                item.SetFlag(global::Item.Flag.Cooking, true);
                NextTick(() =>
                {
                    if (container.entityOwner != null && container.entityOwner is AutoTurret)
                        item.Drop(container.entityOwner.transform.position + new Vector3(-0.2f, 1.2f, 0.3f), Vector3.up);
                });
            }
            else item.SetFlag(global::Item.Flag.Cooking, false);

            return null; 
        }
        
        private bool? CanWearItem(PlayerInventory inventory, Item item)
        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
            var player = inventory.gameObject.ToBaseEntity() as BasePlayer;
            var isBlocked = IsBlocked(item.info) > 0 ? false : (bool?) null;
            
            if (isBlocked == false)
            {
                if (player.GetComponent<NPCPlayer>() != null || player.GetComponent<BaseNpc>() != null || player.IsNpc)
                    return null;
                
                if (permission.UserHasPermission(player.UserIDString, IgnorePermission))
                    return null;
                
                DrawInstanceBlock(player, item);
                timer.Once(3f, () =>
                {
                    
                    CuiHelper.DestroyUi(player, Layer + ".Destroy1");
                    CuiHelper.DestroyUi(player, Layer + ".Destroy2");
                    CuiHelper.DestroyUi(player, Layer + ".Destroy3");
                    CuiHelper.DestroyUi(player, Layer + ".Destroy5");
                    timer.Once(1, () => CuiHelper.DestroyUi(player, Layer));
                });
            }
            return isBlocked;
        }

        private bool? CanEquipItem(PlayerInventory inventory, Item item)
        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
            var player = inventory.gameObject.ToBaseEntity() as BasePlayer;
            if (player == null) return null;
            
            var isBlocked = IsBlocked(item.info) > 0 ? false : (bool?) null;
            if (isBlocked == false)
            {
                if (player.GetComponent<NPCPlayer>() != null || player.GetComponent<BaseNpc>() != null || player.IsNpc)
                    return null;
                
                if (permission.UserHasPermission(player.UserIDString, IgnorePermission))
                    return null;
                
                DrawInstanceBlock(player, item);
                timer.Once(3f, () =>
                {
                    
                    CuiHelper.DestroyUi(player, Layer + ".Destroy1");
                    CuiHelper.DestroyUi(player, Layer + ".Destroy2");
                    CuiHelper.DestroyUi(player, Layer + ".Destroy3");
                    CuiHelper.DestroyUi(player, Layer + ".Destroy5");
                    timer.Once(1, () => CuiHelper.DestroyUi(player, Layer));
                });
            }
            return isBlocked;
        }

        private object OnReloadWeapon(BasePlayer player, BaseProjectile projectile)
        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
            if (player is NPCPlayer)
                return null;

            if (permission.UserHasPermission(player.UserIDString, IgnorePermission))
                return null;
            
            if (player.GetComponent<NPCPlayer>() != null || player.GetComponent<BaseNpc>() != null || player.IsNpc)
                return null;
            
            var isBlocked = IsBlocked(projectile.primaryMagazine.ammoType) > 0 ? false : (bool?) null;
            if (isBlocked == false && (bool?) Duels?.Call("inDuel", player) != true)
            {
                SendReply(player, $"Вы <color=#81B67A>не можете</color> использовать этот тип боеприпасов!");
            }
            return isBlocked;
        }
        
        object OnReloadMagazine(BasePlayer player, BaseProjectile projectile)
        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
            if (player is NPCPlayer)
                return null;
            
            if (permission.UserHasPermission(player.UserIDString, IgnorePermission))
                return null;

            NextTick(() =>
            {
                var isBlocked = IsBlocked(projectile.primaryMagazine.ammoType) > 0 ? false : (bool?) null;
                if (isBlocked == false)
                {
                    projectile.primaryMagazine.contents = 0;
                    projectile.GetItem().LoseCondition(projectile.GetItem().maxCondition);
                    projectile.SendNetworkUpdate();
                    player.SendNetworkUpdate();
                    PrintError($"[{DateTime.Now.ToShortTimeString()}] {player} пытался взломать систему блокировки!");
                    SendReply(player, $"<color=#81B67A>Хорошая</color> попытка, правда ваше оружие теперь сломано!");
                }
            });
            
            return null;
        }

        private void OnPlayerInit(BasePlayer player)
        {
            if (player.IsReceivingSnapshot)
            {
                NextTick(() => OnPlayerInit(player));
                return;
            }

            DrawBlockInfo(player);
        }

        #endregion

        #region GUI

        private void DrawBlockInfo(BasePlayer player)
        {
        }

        [ConsoleCommand("UI_WipeBlock")]
        private void CmdConsoleHandler(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (!player || !args.HasArgs(1)) return;
            
            switch (args.Args[0].ToLower())
            {
                case "page":
                {
                    DrawBlockGUI(player, args.Args[1], int.Parse(args.Args[2]), true);
                    break;
                }
            }
        }

        [ConsoleCommand("blockmove")]
        private void cmdConsoleMoveblock(ConsoleSystem.Arg args)
        {
            if (args.Player() != null)
                return;
            if (!args.HasArgs(1))
            {
                PrintWarning($"Введите количество секунд для перемещения!");
                return;
            }

            int newTime;
            if (!int.TryParse(args.Args[0], out newTime))
            {
                PrintWarning("Вы ввели не число!");
                return;
            }

            settings.SBlock.TimeMove += newTime;
            SaveConfig();
            PrintWarning("Время блокировки успешно изменено!");
            
            BasePlayer.activePlayerList.ToList().ForEach(OnPlayerInit);
        }

        private void cmdChatDrawBlock(BasePlayer player)
        {
            player.SetFlag(BaseEntity.Flags.Reserved3, true); 
            DrawBlockGUI(player, "Total", 0);
        }

        [ChatCommand("stopBlock")]
        private void CmdChatStopBlock(BasePlayer player) => player.SetFlag(BaseEntity.Flags.Reserved3, false);

        private string GEtColor(int first, int second)
        {
            float div = (float) first / second;

            if (div > 0.5)
                return "c44747";
            
            return "c48547";
        }
        
        private void DrawBlockGUI(BasePlayer player, string section = "Total", int page = 0, bool reopen = false)
        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
            CuiElementContainer container = new CuiElementContainer();
                if (!reopen)
                {
                    CuiHelper.DestroyUi(player, Layer); 
                    container.Add(new CuiPanel()
                    {
                        CursorEnabled = true,
                        RectTransform = {AnchorMin = "0.276 0", AnchorMax = "0.945 1", OffsetMin = "0 0", OffsetMax = "0 0"},
                        Image = {Color = "0 0 0 0"}
                    }, "Menu_UI", Layer);
                    
                    container.Add(new CuiPanel()
                    { 
                        CursorEnabled = true,
                        RectTransform = {AnchorMin = "0 0", AnchorMax = "0.289 1", OffsetMin = "0 0", OffsetMax = "0 0"},
                        Image         = {Color = "0.549 0.270 0.215 0.7", Material = "" }
                    }, Layer, Layer + ".RS");
                }

                CuiHelper.DestroyUi(player, Layer + ".C"); 
                container.Add(new CuiPanel()
                { 
                    CursorEnabled = true,
                    RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0"},
                    Image         = {Color = "0.55 0.27 0.23 0" }
                }, Layer + ".RS", Layer + ".C");
                
                 
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = "20 -100", OffsetMax = "0 -15"},
                    Text = { Text = "ВАЙПБЛОК", Align = TextAnchor.UpperLeft, Font = "robotocondensed-bold.ttf", Color = "0.929 0.882 0.847 0.8", FontSize = 33 }
                }, Layer + ".C");

                if (!reopen)
                {
                    CuiHelper.DestroyUi(player, Layer + ".R"); 
                    container.Add(new CuiPanel()
                    { 
                        CursorEnabled = true,
                        RectTransform = {AnchorMin = "0.289 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0"},
                        Image         = {Color = "0.117 0.121 0.109 0.95" }
                    }, Layer, Layer + ".RSE"); 
                }
                
                CuiHelper.DestroyUi(player, Layer + ".R"); 
                container.Add(new CuiPanel()
                { 
                    CursorEnabled = true,
                    RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0"},
                    Image         = {Color = "0.08 0.08 0.08 0" }
                }, Layer + ".RSE", Layer + ".R"); 
                                    
                container.Add(new CuiPanel()
                { 
                    CursorEnabled = true,
                    RectTransform = {AnchorMin = "0 -0.05", AnchorMax = "1 0.5", OffsetMin = "0 0", OffsetMax = "0 0"},
                    Image         = {Color = "0 0 0 0.9", Sprite = "assets/content/ui/ui.gradient.up.psd"}
                }, Layer + ".C");
                                    
                container.Add(new CuiPanel()
                { 
                    CursorEnabled = true,
                    RectTransform = {AnchorMin = "0 0", AnchorMax = "1 0.3", OffsetMin = "0 0", OffsetMax = "0 0"},
                    Image         = {Color = "0 0 0 0.2", Sprite = "assets/content/ui/ui.background.transparent.radial.psd"}
                }, Layer + ".C"); 
                
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "5 20", OffsetMax = "-5 120" },
                    Text = { Text = "Предметы обозначенные знаком <b><size=20>↯</size></b> нельзя взять в руки во время блокировки!", Color = "0.929 0.882 0.847 0.5", Align = TextAnchor.LowerCenter, Font = "robotocondensed-regular.ttf", FontSize =  14}
                }, Layer + ".C");
                
                var list = settings.SBlock.CategoriesName.Where(p => settings.SBlock.BlockItems.SelectMany(t => t.Value).Any(t => ItemManager.FindItemDefinition(t).category.ToString() == p.Key || p.Key == "Total")).ToList();
                float topPosition = (list.Count() / 2f * 40 + (list.Count() - 1) / 2f * 5);
                foreach (var vip in list) 
                {
                    container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = "0 0.5", AnchorMax = "1 0.51", OffsetMin = $"0 {topPosition - 40}", OffsetMax = $"0 {topPosition}" },
                            Button = { Color = section == vip.Key ? "0.149 0.145 0.137 0.8" : "0 0 0 0", Command = $"UI_WipeBlock page {vip.Key} {0}"},
                            Text = { Text = "", Align = TextAnchor.MiddleRight, Font = "robotocondensed-bold.ttf", FontSize = 14 }
                        }, Layer + ".C", Layer + vip.Value); 
                
                    container.Add(new CuiLabel
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = $"0 0", OffsetMax = $"-20 0" },
                            Text = { Text = vip.Value.ToUpper(), Align = TextAnchor.MiddleRight, Font = "robotocondensed-bold.ttf", FontSize = 24, Color = "0.929 0.882 0.847 1"}
                        }, Layer + vip.Value);
                
                    topPosition -= 40 + 5;
                }

                var itemList = new Dictionary<string, double>();
                foreach (var check in settings.SBlock.BlockItems)
                {
                    foreach (var test in check.Value)
                    {
                        var item = ItemManager.FindItemDefinition(test);
                        if (item.category.ToString() == section || section == "Total") 
                            itemList.Add(item.shortname, IsBlocked(item)); 
                    }
                }

                int pString = 5;
                float pHeight = 90;

                float elemCount = 1f / pString;

                int elementId = 0;
                float topMargin = 5;
                
            
                container.Add(new CuiPanel
                {
                    RectTransform =  {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = $"55 30", OffsetMax = $"-55 -30"},
                    Image = {Color = "1 1 1 0"}
                }, Layer + ".R", Layer + ".HRPStore");
                
                foreach (var check in itemList.Skip(page * 30).Take(30)) 
                {
                    container.Add(new CuiPanel
                    {
                        RectTransform = { AnchorMin = $"{elementId * elemCount} 1", AnchorMax = $"{(elementId + 1) * elemCount} 1", OffsetMin = $"{(elementId == 0 ? "0" : "10")} {topMargin - pHeight}", OffsetMax = $"{(elementId == 4 ? "0" : "-5")} {topMargin}" },
                        Image = {Color = check.Value > 0 ? "0.78 0.74 0.7 0.01" : "0.78 0.74 0.7 0.05", Material = ""}
                    }, Layer + ".HRPStore", Layer + ".R" + check.Key);

                    if (check.Value > 0)
                    {
                        container.Add(new CuiElement
                        {
                            Parent = Layer + ".R" + check.Key,
                            Components =
                            {
                                new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", "LcokIcon"), Color = "1 1 1 0.1" },
                                new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0" }
                            }
                        });
                    }
                    
					//Puts(check.Key+" "+(string) ImageLibrary.Call("GetImage", check.Key, (ulong) 256));
                    container.Add(new CuiElement
                    {
                        Parent = Layer + ".R" + check.Key,
                        Components = 
                        {
                            new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", check.Key, (ulong) 256) },
                            new CuiRectTransformComponent { AnchorMin = "0.5 0", AnchorMax = "0.5 1", OffsetMin = "-35 10", OffsetMax = "35 -10" }
                        }
                    });
                    
                    string color = check.Value > 0 ? "0.549 0.270 0.215 1" : "0.294 0.38 0.168 1";
                    container.Add(new CuiPanel  
                    {
                        RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = $"-60 -5", OffsetMax = $"5 12" },
                        Image = { Color = color }
                    }, Layer + ".R" + check.Key, Layer + ".R" + check.Key + ".L");

                    container.Add(new CuiLabel
                    {
                        RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = $"{(check.Value > 0 ? -5 : 0)} 0"},
                        Text = {Text = check.Value > 0 ? TimeSpan.FromSeconds(check.Value).ToShortString() : "ДОСТУПНО", Align = check.Value > 0 ? TextAnchor.MiddleRight : TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = check.Value > 0 ? 12 : 11, Color = check.Value > 0 ? "0.98 0.807 0.439 1" : "0.65 0.89 0.24 1" }
                    }, Layer + ".R" + check.Key + ".L");
                    if (check.Value > 0)
                    {
                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "0 1", OffsetMin = "4 4", OffsetMax = "13 -3" },
                            Button = { Color = "0.98 0.807 0.439 1", Sprite = "assets/icons/bp-lock.png" },
                            Text = { Text = "" }
                        }, Layer + ".R" + check.Key + ".L");
                    }
                    
                    
                    elementId++;
                    if (elementId == 5)
                    {
                        elementId = 0;

                        topMargin -= pHeight + 15;
                    }
                }
                
            #region PaginationMember

            string leftCommand = $"UI_WipeBlock page {section} {page - 1}"; 
            string rightCommand = $"UI_WipeBlock page {section} {page + 1}";
            bool leftActive = page > 0;
            bool rightActive = (page + 1) * 30 < itemList.Count; 
  
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = $"-256 15", OffsetMax = "256 60" },
                Image = { Color = "0 0 0 0" } 
            }, Layer + ".R", Layer + ".PS");
            
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0.49 1", OffsetMin = $"0 0", OffsetMax = "-0 -0" },
                Image = { Color = leftActive ? "0.294 0.38 0.168 1" : "0.294 0.38 0.168 0.3" }
            }, Layer + ".PS", Layer + ".PS.L");
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = leftActive ? leftCommand : "" },
                Text = { Text = "<b>НАЗАД</b>", Font = "robotocondensed-bold.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter, Color = leftActive ? "0.647 0.917 0.188 1" : "0.294 0.38 0.168 0.3" }
            }, Layer + ".PS.L");
            
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.51 0", AnchorMax = "1 1", OffsetMin = $"0 0", OffsetMax = "-0 -0" },
                Image = { Color = rightActive ? "0.294 0.38 0.168 1" : "0.294 0.38 0.168 0.3" }
            }, Layer + ".PS", Layer + ".PS.R");
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = rightActive ? rightCommand : "" },
                Text = { Text = "<b>ВПЕРЁД</b>", Font = "robotocondensed-bold.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter, Color = rightActive ? "0.647 0.917 0.188 1" : "0.294 0.38 0.168 0.3" }
            }, Layer + ".PS.R");

            #endregion

            CuiHelper.AddUi(player, container);
        }

        private IEnumerator StartUpdate(BasePlayer player)
        {
            while (player.HasFlag(BaseEntity.Flags.Reserved3))
            {
                foreach (var check in settings.SBlock.BlockItems.SelectMany(p => p.Value))
                { 
                    CuiElementContainer container = new CuiElementContainer();
                    var blockedItem = ItemManager.FindItemDefinition(check);
                    CuiHelper.DestroyUi(player, $"Time.{blockedItem.shortname}.Update");

                    var unblockTime = IsBlocked(blockedItem);
                    
                    string text = unblockTime > 0
                            ? $"<size=10>ОСТАЛОСЬ</size>\n<size=14>{TimeSpan.FromSeconds(unblockTime).ToShortString()}</size>"
                            : "<size=11>ДОСТУПНО</size>";
                
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                        Text          = { Text        = text, FontSize   = 10, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter},
                        Button        = { Color     = "0 0 0 0" }, 
                    }, $"Time.{blockedItem.shortname}", $"Time.{blockedItem.shortname}.Update");
                    
                    CuiHelper.AddUi(player, container);
                }
                yield return new WaitForSeconds(1);
            }
        }
        
        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }

        private void DrawInstanceBlock(BasePlayer player, Item item)
        {
            /*CuiHelper.DestroyUi(player, Layer);
            CuiElementContainer container = new CuiElementContainer();
            string inputText = "Предмет {name} временно заблокирован,\nподождите {1}".Replace("{name}", item.info.displayName.english).Replace("{1}", $"{Convert.ToInt32(Math.Floor(TimeSpan.FromSeconds(IsBlocked(item.info)).TotalHours))} час {TimeSpan.FromSeconds(IsBlocked(item.info)).Minutes} минут.");
            
            container.Add(new CuiPanel
            {
                FadeOut = 1f,
                Image = { FadeIn = 1f, Color = "0.1 0.1 0.1 0" },
                RectTransform = { AnchorMin = "0.35 0.75", AnchorMax = "0.62 0.95" },
                CursorEnabled = false
            }, "Overlay", Layer);
            
            container.Add(new CuiElement
            {
                FadeOut = 1f,
                Parent = Layer,
                Name = Layer + ".Hide",
                Components =
                {
                    new CuiImageComponent { Color = "0 0 0 0" },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                }
            });
            container.Add(new CuiElement
            {
                Parent = Layer + ".Hide",
                Name = Layer + ".Destroy1",
                FadeOut = 1f,
                Components =
                {
                    new CuiImageComponent { Color = "0.4 0.4 0.4 0.7"},
                    new CuiRectTransformComponent { AnchorMin = "0 0.62", AnchorMax = "1.1 0.85" }
                }
                
            });
            container.Add(new CuiLabel
            {
                FadeOut = 1f,
                Text = {FadeIn = 1f, Color = "0.9 0.9 0.9 1", Text = "ПРЕДМЕТ ЗАБЛОКИРОВАН", FontSize = 22, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" }
            }, Layer + ".Destroy1", Layer + ".Destroy5");
            container.Add(new CuiButton
            {
                FadeOut = 1f,
                RectTransform = { AnchorMin = "0 0.29", AnchorMax = "1.1 0.61" },
                Button = {FadeIn = 1f, Color = "0.3 0.3 0.3 0.5" },
                Text = { Text = "" }
            }, Layer + ".Hide", Layer + ".Destroy2");
            container.Add(new CuiLabel
            {
                FadeOut = 1f,
                Text = {FadeIn = 1f, Text = inputText, FontSize = 16, Align = TextAnchor.MiddleLeft, Color = "0.85 0.85 0.85 1" , Font = "robotocondensed-regular.ttf"},
                RectTransform = { AnchorMin = "0.04 0", AnchorMax = "10 0.9" }
            }, Layer + ".Hide", Layer + ".Destroy3");
            CuiHelper.AddUi(player, container);*/
        }

        #endregion

        #region Functions

        private string GetGradient(int t)
        {
            var LeftTime = UnBlockTime(t) - CurrentTime();
            return Gradients[Math.Min(99, Math.Max(Convert.ToInt32((float) LeftTime / t * 100), 0))];
        }

        private double IsBlockedCategory(int t) => IsBlocked(settings.SBlock.BlockItems.ElementAt(t).Value.First());
        private bool IsAnyBlocked() => UnBlockTime(settings.SBlock.BlockItems.Last().Key) + settings.SBlock.TimeMove > CurrentTime();
        private static double IsBlocked(string shortname) 
        {
            if (!settings.SBlock.BlockItems.SelectMany(p => p.Value).Contains(shortname))
                return 0;

            var blockTime = settings.SBlock.BlockItems.FirstOrDefault(p => p.Value.Contains(shortname)).Key;
            var lefTime = (UnBlockTime(blockTime)) - CurrentTime();
            
            return lefTime > 0 ? lefTime : 0;
        }

        private static double UnBlockTime(int amount) => SaveRestore.SaveCreatedTime.ToUniversalTime().Subtract(epoch).TotalSeconds + amount + settings.SBlock.TimeMove;

        private static double IsBlocked(ItemDefinition itemDefinition) => IsBlocked(itemDefinition.shortname);

        private void FillBlockedItems(Dictionary<string, Dictionary<Item, string>> fillDictionary)
        {
            foreach (var category in settings.SBlock.BlockItems)
            {
                string categoryColor = GetGradient(category.Key);
                foreach (var item in category.Value)
                {
                    Item createItem = ItemManager.CreateByPartialName(item);
                    string catName = settings.SBlock.CategoriesName[createItem.info.category.ToString()];
                
                    if (!fillDictionary.ContainsKey(catName))
                        fillDictionary.Add(catName, new Dictionary<Item, string>());
                
                    if (!fillDictionary[catName].ContainsKey(createItem))
                        fillDictionary[catName].Add(createItem, categoryColor);
                }
            }
        }

        #endregion

        #region Utils

        static readonly DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        static double CurrentTime() { return DateTime.UtcNow.Subtract(epoch).TotalSeconds; }
        
        public static string ToShortString(TimeSpan timeSpan)
        {
            int i = 0;
            string resultText = "";
            if (timeSpan.Days > 0)
            {
                resultText += timeSpan.Days + " День";
                i++;
            }
            if (timeSpan.Hours > 0 && i < 2)
            {
                if (resultText.Length != 0)
                    resultText += " ";
                resultText += timeSpan.Days + " Час";
                i++;
            }
            if (timeSpan.Minutes > 0 && i < 2)
            {
                if (resultText.Length != 0)
                    resultText += " ";
                resultText += timeSpan.Days + " Мин.";
                i++;
            }
            if (timeSpan.Seconds > 0 && i < 2)
            {
                if (resultText.Length != 0)
                    resultText += " ";
                resultText += timeSpan.Days + " Сек.";
                i++;
            }

            return resultText;
        }
        
        private void GetConfig<T>(string menu, string key, ref T varObject)
        {
            if (Config[menu, key] != null)
            {
                varObject = Config.ConvertValue<T>(Config[menu, key]);
            }
            else
            {
                Config[menu, key] = varObject;
            }
        }
        
        #endregion
    }
}

// --- End of file: WipeBlock.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BloodRust-fuuu/NoEscape.cs ---
// --- Original Local Path: BloodRust-fuuu/NoEscape.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using Rust;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;
using System.Collections;
using Oxide.Core.Plugins;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
    [Info("NoEscape", "https://topplugin.ru/", "3.0.0")]
    public class NoEscape : RustPlugin
    {
        #region Class
        private static List<SphereComponent> BlockerList = new List<SphereComponent>();

        private class PlayerBlockStatus : FacepunchBehaviour
        {
            private BasePlayer Player;
            public SphereComponent CurrentBlocker;
            public double CurrentTime = config.BlockSettings.BlockLength;

            public static PlayerBlockStatus Get(BasePlayer player)
            {
                return player.GetComponent<PlayerBlockStatus>() ?? player.gameObject.AddComponent<PlayerBlockStatus>();
            }

            private void Awake()
            {
                Player = GetComponent<BasePlayer>();
            }

            private void ControllerUpdate()
            {
                if (CurrentBlocker != null)
                    UpdateUI();
                else
                    UnblockPlayer();
            }

            public void CreateUI()
            {
                CuiHelper.DestroyUi(Player, "NoEscape");
                CuiElementContainer container = new CuiElementContainer();
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = config.UISettings.AnchorMin, AnchorMax = config.UISettings.AnchorMax, OffsetMax = "0 0" },
                    Image = { Color = config.UISettings.InterfaceColorBP }
                }, "Hud", "NoEscape");
                CuiHelper.AddUi(Player, container);
                if (CurrentBlocker != null) UpdateUI();
            }

            public void BlockPlayer(SphereComponent blocker, bool justCreated)
            {
                if (ins.permission.UserHasPermission(Player.UserIDString, config.BlockSettings.PermissionToIgnore))
                {
                    UnblockPlayer();
                    return;
                }
                if (justCreated)
                    Player.ChatMessage(string.Format(ins.Messages["blockactiveAttacker"], NumericalFormatter.FormatTime(config.BlockSettings.BlockLength)));
                CurrentBlocker = blocker;
                CurrentTime = CurrentBlocker.CurrentTime;
                CreateUI();
                InvokeRepeating(ControllerUpdate, 1f, 1f);
            }

            public void UpdateUI()
            {
                CurrentTime++;
                CuiHelper.DestroyUi(Player, "NoEscape_update");
                CuiHelper.DestroyUi(Player, "NoEscape" + ".Info");

                CuiElementContainer container = new CuiElementContainer();
                container.Add(new CuiElement
                {
                    Parent = "NoEscape",
                    Name = "NoEscape_update",
                    Components =
                    {
                        new CuiImageComponent { Color = config.UISettings.InterfaceColor },
                        new CuiRectTransformComponent {AnchorMin = $"0 0", AnchorMax = $"{(float) (CurrentBlocker.TotalTime - CurrentTime) / CurrentBlocker.TotalTime} 1", OffsetMin = "0 0", OffsetMax = "0 0"},
                    }
                });
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Text = { Text = string.Format(ins.Messages["guitimertext"], ins.GetFormatTime(TimeSpan.FromSeconds(CurrentBlocker.TotalTime - CurrentTime))), Font = "robotocondensed-regular.ttf", Color = "1 1 1 0.9", FontSize = 16, Align = TextAnchor.MiddleCenter }
                }, "NoEscape", "NoEscape" + ".Info");

                CuiHelper.AddUi(Player, container);
                if (CurrentTime >= config.BlockSettings.BlockLength)
                    UnblockPlayer();
            }

            public void UnblockPlayer()
            {
                if (Player == null)
                {
                    Destroy(this);
                    return;
                }
                Player.ChatMessage(ins.Messages["blocksuccess"]);
                CancelInvoke(ControllerUpdate);
                CuiHelper.DestroyUi(Player, "NoEscape");
                CurrentBlocker = null;
            }
            private void OnDestroy()
            {
                CuiHelper.DestroyUi(Player, "NoEscape");
                Destroy(this);
            }
        }

        public class SphereComponent : FacepunchBehaviour
        {
            SphereCollider sphereCollider;
            public BasePlayer initPlayer;
            public List<ulong> Privilage = null;
            public ulong OwnerID;
            public double CurrentTime = 0;
            public double TotalTime = config.BlockSettings.BlockLength;
            void Awake()
            {
                var reply = 4018;
                if (reply == 0) { }
                gameObject.layer = (int)Layer.Reserved1;
                sphereCollider = gameObject.AddComponent<SphereCollider>();
                sphereCollider.isTrigger = true;
                sphereCollider.radius = config.BlockSettings.BlockerDistance;
            }

            public void Init(BasePlayer player, ulong owner, List<ulong> privilage)
            {
                initPlayer = player;
                OwnerID = owner;
                Privilage = privilage;
            }

            private void OnTriggerEnter(Collider other)
            {
                var target = other.GetComponentInParent<BasePlayer>();
                if (target == null) return;

                if (PlayerBlockStatus.Get(target).CurrentBlocker != null && PlayerBlockStatus.Get(target).CurrentBlocker == this && PlayerBlockStatus.Get(target).CurrentTime > CurrentTime)
                {
                    PlayerBlockStatus.Get(target).CurrentTime = CurrentTime;
                    return;
                }
                if (PlayerBlockStatus.Get(target).CurrentBlocker != null && PlayerBlockStatus.Get(target).CurrentBlocker != this && PlayerBlockStatus.Get(target).CurrentTime > CurrentTime)
                {
                    target.ChatMessage(string.Format(ins.Messages["enterRaidZone"], NumericalFormatter.FormatTime(config.BlockSettings.BlockLength - CurrentTime)));
                    PlayerBlockStatus.Get(target).CurrentTime = CurrentTime;
                    PlayerBlockStatus.Get(target).CurrentBlocker = this;
                    return;
                }
                if (config.BlockSettings.ShouldBlockEnter && (PlayerBlockStatus.Get(target).CurrentBlocker == null || PlayerBlockStatus.Get(target).CurrentBlocker != this))
                {
                    PlayerBlockStatus.Get(target).BlockPlayer(this, false);
                    target.ChatMessage(string.Format(ins.Messages["enterRaidZone"], NumericalFormatter.FormatTime(config.BlockSettings.BlockLength - CurrentTime)));
                    return;
                }
            }

            private void OnTriggerExit(Collider other)
            {
                if (!config.BlockSettings.UnBlockExit) return;
                var target = other.GetComponentInParent<BasePlayer>();
                if (target != null && target.userID.IsSteamId() && PlayerBlockStatus.Get(target).CurrentBlocker == this)
                    PlayerBlockStatus.Get(target).UnblockPlayer();
            }

            public void FixedUpdate()
            {
                CurrentTime += Time.deltaTime;
                if (CurrentTime > TotalTime)
                {
                    if (BlockerList.Contains(this))
                        BlockerList.Remove(this);
                    Destroy(this);
                }
            }

            public void OnDestroy()
            {
                Destroy(this);
            }

            public bool IsInBlocker(BaseEntity player) => Vector3.Distance(player.transform.position, transform.position) < config.BlockSettings.BlockerDistance;
        }
        #endregion

        #region Variables

        static PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Благодарим за покупку плагина на сайте TopPlugin.ru. Если вы передадите этот плагин сторонним лицам знайте - это лишает вас гарантированных обновлений!");
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();

            if (config.PluginVersion < Version)
                UpdateConfigValues();

            Config.WriteObject(config, true);
        }

        void Loaded()
        {
            if (!config.PlayerBlockSettings.CanRepair) Unsubscribe(nameof(OnStructureRepair));
            else Subscribe(nameof(OnStructureRepair));
            if (!config.PlayerBlockSettings.CanUpgrade) Unsubscribe(nameof(CanAffordUpgrade));
            else Subscribe(nameof(CanAffordUpgrade));
            if (!config.PlayerBlockSettings.CanDefaultremove) Unsubscribe(nameof(OnStructureDemolish));
            else Subscribe(nameof(OnStructureDemolish));
            if (!config.PlayerBlockSettings.CanBuild && !config.PlayerBlockSettings.CanPlaceObjects) Unsubscribe(nameof(CanBuild));
            else Subscribe(nameof(CanBuild));
            permission.RegisterPermission(config.BlockSettings.PermissionToIgnore, this);
            //permission.RegisterPermission(config.VkBotMessages.VkPrivilage, this);
            lang.RegisterMessages(Messages, this, "en");
            Messages = lang.GetMessages("en", this);
			LoadVKData();
        }

        public void LoadVKData()
        {
            if (Interface.Oxide.DataFileSystem.ExistsDatafile("Vk/Data"))
            {
                baza = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, string>>("Vk/Data");
            }
            else
            {
                PrintWarning($"Error reading config, creating one new data!");
                baza = new Dictionary<ulong, string>();
            }

            if (Interface.Oxide.DataFileSystem.ExistsDatafile("Vk/Names"))
            {
                _PlayerNicknames = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, string>>("Vk/Names");
            }
            else
                _PlayerNicknames = new Dictionary<ulong, string>();

        }
		
        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (config.PluginVersion < Version)
            {
                PrintWarning("Config update detected! Updating config values...");

                if (config.PluginVersion < new VersionNumber(2, 2, 0))
                {
                    config.BlockSettings.WriteListDestroyEntity = new List<string>()
                    {
                        "barricade.metal",
                         "bed_deployed"
                    };
                    PrintWarning("Added Write List entity");
                }
                if (config.PluginVersion < new VersionNumber(2, 3, 1))
                {
                    config.PlayerBlockSettings.BlackListCommands = new List<string>()
                    {
                        "/bp",
                        "backpack.open",
                        "/trade"
                    };

                    PrintWarning("Added Black List commands");
                }
                PrintWarning("Config update completed!");
                config.PluginVersion = Version;
            }
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        public class UISettings
        {
            [JsonProperty("Цвет полосы активный полосы")]
            public string InterfaceColor = "0.121568628 0.419607848 0.627451 0.784313738";

            [JsonProperty("Цвет фона")]
            public string InterfaceColorBP = "1 1 1 0.3";

            [JsonProperty("Позиция AnchorMin")]
            public string AnchorMin = "0.3447913 0.112037";

            [JsonProperty("Позиция AnchorMax")]
            public string AnchorMax = "0.640625 0.1398148";
        }

        public class BlockSettings
        {
            [JsonProperty("Радиус зоны блокировки")]
            public float BlockerDistance = 150;

            [JsonProperty("Общее время блокировки в секундах")]
            public float BlockLength = 150;

            [JsonProperty("Блокировать создателя объекта какой разрушили, даже если он вне зоны рейда")]
            public bool BlockOwnersIfNotInZone = true;

            [JsonProperty("Блокировать игрока, который вошёл в активную зону блокировки")]
            public bool ShouldBlockEnter = true;

            [JsonProperty("Снимать блокировку с игрока если он вышел из зоны блокировки?")]
            public bool UnBlockExit = false;

            [JsonProperty("Не создавать блокировку если разрушенный объект не в зоне шкафа (Нету билды)")]
            public bool EnabledBuildingBlock = false;

            [JsonProperty("Блокировать всех игроков какие авторизаваны в шкафу (Если шкаф существует, и авторизованный игрок на сервере)")]
            public bool EnabledBlockAutCupboard = false;

            [JsonProperty("Привилегия, игроки с которой игнорируются РБ (на них он не действует")]
            public string PermissionToIgnore = "noescape.ignore";

            [JsonProperty("Белый список entity при разрушении каких не действует блокировка")]
            public List<string> WriteListDestroyEntity = new List<string>();
        }
        public class SenderConfig
        {
            [JsonProperty("Настройки отправки сообщений в VK")]
            public VkSettings VK = new VkSettings();
            [JsonProperty("Сообщение какое будет отправлено игроку ({0} - Имя атакуещего, {1} - Квадрат на карте)")]
            public string Message = "Внимание! Игрок {0} начал рейд вашего строения в квадрате {1} на сервере SERVERNAME.";
        }

        public class VkSettings
        {
            [JsonProperty("Включить отправку сообщения в ВК оффлайн игроку")]
            public bool EnabledVk = false;
            [JsonProperty("Access токен группы ВК с правом отправки сообщений")]
            public string VKAccess = "Вставьте сюда токен для отправки сообщений в вк";
        }

        public class PlayerBlockSettings
        {
            [JsonProperty("Блокировать использование китов")]
            public bool CanUseKits = true;

            [JsonProperty("Блокировать обмен между игроками (Trade)")]
            public bool CanUseTrade = true;

            [JsonProperty("Блокировать телепорты")]
            public bool CanTeleport = true;

            [JsonProperty("Блокировать удаление построек (CanRemove)")]
            public bool CanRemove = true;

            [JsonProperty("Блокировать улучшение построек (Upgrade, BuildingUpgrade и прочее)")]
            public bool CanBGrade = true;

            [JsonProperty("Блокировать удаление построек (стандартное)")]
            public bool CanDefaultremove = true;

            [JsonProperty("Блокировать строительство")]
            public bool CanBuild = true;

            [JsonProperty("Блокировать установку объектов")]
            public bool CanPlaceObjects = true;

            [JsonProperty("Блокировать ремонт построек (стандартный)")]
            public bool CanRepair = true;

            [JsonProperty("Блокировать улучшение построек (стандартное)")]
            public bool CanUpgrade = true;

            [JsonProperty("Белый список предметов какие можно строить при блокировке")]
            public List<string> WriteListBuildEntity = new List<string>();

            [JsonProperty("Черный список команд какие запрещены при рейд блоке (Чатовые и консольные)")]
            public List<string> BlackListCommands = new List<string>();

        }

        private class PluginConfig
        {
            [JsonProperty("Настройка UI")]
            public UISettings UISettings = new UISettings();

            [JsonProperty("Общая настройка блокировки")]
            public BlockSettings BlockSettings = new BlockSettings();

            [JsonProperty("Настройка запретов для игрока")]
            public PlayerBlockSettings PlayerBlockSettings = new PlayerBlockSettings();

            [JsonProperty("Настройка отправки сообщений")]
            public SenderConfig Sender = new SenderConfig();

            [JsonProperty("Версия конфигурации")]
            public VersionNumber PluginVersion = new VersionNumber();

            [JsonIgnore]
            [JsonProperty("Инициализация плагина⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠")]
            public bool Init = false;

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig
                {
                    BlockSettings = new BlockSettings()
                    {
                        BlockerDistance = 150,
                        BlockLength = 150,
                        BlockOwnersIfNotInZone = true,
                        ShouldBlockEnter = true,
                        UnBlockExit = false,
                        EnabledBuildingBlock = false,
                        EnabledBlockAutCupboard = false,
                        PermissionToIgnore = "noescape.ignore",
                        WriteListDestroyEntity = new List<string>()
                        {
                            "barricade.metal",
                            "bed_deployed"
                        }
                    },
                    PlayerBlockSettings = new PlayerBlockSettings()
                    {
                        CanUseKits = true,
                        CanUseTrade = true,
                        CanTeleport = true,
                        CanRemove = true,
                        CanBGrade = true,
                        CanDefaultremove = true,
                        CanBuild = true,
                        CanPlaceObjects = true,
                        CanRepair = true,
                        CanUpgrade = true,
                        WriteListBuildEntity = new List<string>()
                        {
                             "wall.external.high.stone",
                             "barricade.metal"
                        }
                    },
                    UISettings = new UISettings()
                    {
                        InterfaceColor = "0.12 0.41 0.62 0.78",
                        InterfaceColorBP = "1 1 1 0.3",
                        AnchorMin = "0.3447913 0.112037",
                        AnchorMax = "0.640625 0.1398148",
                    },
                    Sender = new SenderConfig()
                    {
						VK = new VkSettings(){
							EnabledVk = false,
							VKAccess = "Вставьте сюда токен для отправки сообщений в вк"
						},
                        Message = "Внимание! Игрок {0} начал рейд вашего строения в квадрате {1} на сервере SERVERNAME."
                    },
                    PluginVersion = new VersionNumber(),
                };
            }
        }

        #endregion

        #region Oxide
        private static NoEscape ins;
        [PluginReference] Plugin ImageLibrary;
        private void OnServerInitialized()
        {
            ins = this;
            config.Init = true;
            ImageLibrary.Call("AddImage", "https://imgur.com/4jcrNyN.png", "4jcrNyN");
            BasePlayer.activePlayerList.ToList().ForEach(OnPlayerConnected);
        }

        void OnPlayerSleepEnded(BasePlayer player)
        {
            SphereComponent ActiveRaidZone = GetRaidZone(player.transform.position);
            if (ActiveRaidZone == null) return;
            if (PlayerBlockStatus.Get(player).CurrentBlocker != null)
            {
                if (PlayerBlockStatus.Get(player).CurrentBlocker != ActiveRaidZone)
                    PlayerBlockStatus.Get(player).BlockPlayer(ActiveRaidZone, false);
            }
            else
            {
                player.ChatMessage(string.Format(Messages["enterRaidZone"], NumericalFormatter.FormatTime(config.BlockSettings.BlockLength - ActiveRaidZone.CurrentTime)));
                PlayerBlockStatus.Get(player)?.BlockPlayer(ActiveRaidZone, false);
            }
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player.IsReceivingSnapshot)
            {
                timer.In(1f, () => OnPlayerConnected(player));
                return;
            }
            if (PlayerBlockStatus.Get(player).CurrentBlocker != null)
                PlayerBlockStatus.Get(player).CreateUI();
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList){
                if (PlayerBlockStatus.Get(player) != null)
                    UnityEngine.Object.Destroy(PlayerBlockStatus.Get(player));
			}
            BlockerList.RemoveAll(x =>
            {
                UnityEngine.Object.Destroy(x);
                return true;
            });
			Interface.Oxide.DataFileSystem.WriteObject("Vk/Data", baza);
            Interface.Oxide.DataFileSystem.WriteObject("Vk/Names", _PlayerNicknames);
        }

        string GetGridLocation(Vector3 pos)
        {
            string gridLocation = "";
            int numx = Convert.ToInt32(pos.x);
            int numz = Convert.ToInt32(pos.z);

            float offset = (ConVar.Server.worldsize) / 2;
            float step = (ConVar.Server.worldsize) / (0.0066666666666667f * (ConVar.Server.worldsize));
            string start = "";

            int diff = Convert.ToInt32(step);
            int absoluteDifference = diff;

            char letter = 'A';
            int number = 0;
            for (float xx = -offset; xx < offset; xx += step)
            {
                for (float zz = offset; zz > -offset; zz -= step)
                {
                    if (Math.Abs(numx - xx) <= diff && Math.Abs(numz - zz) <= diff)
                    {
                        gridLocation = $"{start}{letter}{number}";
                        break;
                    }
                    number++;
                }
                number = 0;
                if (letter.ToString().ToUpper() == "Z")
                {
                    start = "A";
                    letter = 'A';
                }
                else
                {
                    letter = (char)(((int)letter) + 1);
                }
                if (Math.Abs(numx - xx) <= diff)
                {
                    break;
                }
            }
            return gridLocation;
        }

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (!config.Init) return;
            if (entity == null || info == null || info.InitiatorPlayer == null || !(entity is StabilityEntity || entity is ShopFront || entity is BuildingPrivlidge)
                || config.BlockSettings.EnabledBuildingBlock && entity.GetBuildingPrivilege() == null || entity.OwnerID == 0) return;
            if (entity is BuildingBlock && (entity as BuildingBlock).currentGrade.gradeBase.type == BuildingGrade.Enum.Twigs
                || info?.damageTypes.GetMajorityDamageType() == DamageType.Decay || config.BlockSettings.WriteListDestroyEntity.Contains(entity.ShortPrefabName)) return;
            var alreadyBlock = BlockerList.FirstOrDefault(p => Vector3.Distance(entity.transform.position, p.transform.position) < (config.BlockSettings.BlockerDistance / 2));
            var position = GetGridLocation(entity.transform.position);
            if (alreadyBlock)
            {
                alreadyBlock.CurrentTime = 0;
                if (config.BlockSettings.BlockOwnersIfNotInZone)
                {
                    var OwnerPlayer = BasePlayer.FindByID(entity.OwnerID);
                    if (OwnerPlayer != null)
                        PlayerBlockStatus.Get(OwnerPlayer).BlockPlayer(alreadyBlock, false);
                }
                PlayerBlockStatus.Get(info.InitiatorPlayer).BlockPlayer(alreadyBlock, false);
                if (entity.GetBuildingPrivilege() != null && config.BlockSettings.EnabledBlockAutCupboard)
                {
                    foreach (var aplayer in entity.GetBuildingPrivilege().authorizedPlayers)
                    {
                        var AuthPlayer = BasePlayer.Find(aplayer.userid.ToString());
                        if (AuthPlayer != null && AuthPlayer != info.InitiatorPlayer && AuthPlayer.IsConnected)
                            PlayerBlockStatus.Get(AuthPlayer).BlockPlayer(alreadyBlock, false);
                        else if (AuthPlayer == null || !AuthPlayer.IsConnected) ALERTPLAYER(aplayer.userid, info.InitiatorPlayer.displayName, position);
                    }
                }
                var col = Vis.colBuffer;
                var count = Physics.OverlapSphereNonAlloc(alreadyBlock.transform.position, config.BlockSettings.BlockerDistance, col, LayerMask.GetMask("Player (Server)"));
                for (int i = 0; i < count; i++)
                {
                    var player = col[i].ToBaseEntity() as BasePlayer;
                    if (player == null) continue;
                    PlayerBlockStatus.Get(player).BlockPlayer(alreadyBlock, false);
                }
            }
            else
            {
                var obj = new GameObject();
                obj.transform.position = entity.transform.position;
                var sphere = obj.AddComponent<SphereComponent>();
                sphere.GetComponent<SphereComponent>().Init(info.InitiatorPlayer, entity.OwnerID, entity.GetBuildingPrivilege() != null ? entity.GetBuildingPrivilege().authorizedPlayers.Select(p => p.userid).ToList() : null);
                BlockerList.Add(sphere);
                PlayerBlockStatus.Get(info.InitiatorPlayer).BlockPlayer(sphere, true);
                var OwnerPlayer = BasePlayer.FindByID(entity.OwnerID);
                if (OwnerPlayer == null || !OwnerPlayer.IsConnected)
                {
                    ALERTPLAYER(entity.OwnerID, info.InitiatorPlayer.displayName, position);
                    return;
                }
                else if (OwnerPlayer != null && OwnerPlayer != info.InitiatorPlayer)
                {
                    if (config.BlockSettings.BlockOwnersIfNotInZone)
                    {
                        PlayerBlockStatus.Get(OwnerPlayer)?.BlockPlayer(sphere, false);
                        if (OwnerPlayer != info?.InitiatorPlayer) OwnerPlayer.ChatMessage(string.Format(Messages["blockactive"], GetNameGrid(entity.transform.position), NumericalFormatter.FormatTime(config.BlockSettings.BlockLength)));
                    }
                    else
                        OwnerPlayer.ChatMessage(string.Format(Messages["blockactiveOwner"], GetNameGrid(entity.transform.position)));
                }
                var col = Vis.colBuffer;
                var count = Physics.OverlapSphereNonAlloc(sphere.transform.position, config.BlockSettings.BlockerDistance, col, LayerMask.GetMask("Player (Server)"));
                for (int i = 0; i < count; i++)
                {
                    var player = col[i].ToBaseEntity() as BasePlayer;
                    if (player == null || !player.IsConnected) continue;
                    PlayerBlockStatus.Get(player).BlockPlayer(sphere, false);
                }

                if (entity.GetBuildingPrivilege() != null && config.BlockSettings.EnabledBlockAutCupboard)
                {
                    foreach (var aplayer in entity.GetBuildingPrivilege().authorizedPlayers)
                    {
                        var AuthPlayer = BasePlayer.Find(aplayer.userid.ToString());
                        if (AuthPlayer != null && AuthPlayer != info.InitiatorPlayer)
                            PlayerBlockStatus.Get(AuthPlayer).BlockPlayer(sphere, false);
                        else ALERTPLAYER(aplayer.userid, info.InitiatorPlayer.displayName, position);
                    }
                }
            }
        }

        object CanBuild(Planner planner, Construction prefab, Construction.Target target)
        {
            var player = planner.GetOwnerPlayer();
            if (player == null || !IsRaidBlocked(player)) return null;
            var shortname = prefab.hierachyName.Substring(prefab.hierachyName.IndexOf("/") + 1);
            if (config.PlayerBlockSettings.WriteListBuildEntity.Contains(shortname))
                return null;
            var component = PlayerBlockStatus.Get(player);
            if (component == null || component.CurrentBlocker == null) return null;
            player.ChatMessage(string.Format(Messages["blockbuld"], NumericalFormatter.FormatTime(component.CurrentBlocker.TotalTime - component.CurrentTime)));
            return false;
        }

        private object OnUserCommand(IPlayer ipl, string command, string[] args)
        {
            if (ipl == null || !ipl.IsConnected) return null;
            var player = ipl.Object as BasePlayer;
            command = command.Insert(0, "/");
            if (player == null || !IsRaidBlocked(player)) return null;
            if (config.PlayerBlockSettings.BlackListCommands.Contains(command.ToLower()))
            {
                var component = PlayerBlockStatus.Get(player);
                if (component == null || component.CurrentBlocker == null) return null;
                player.ChatMessage(string.Format(Messages["commandBlock"], NumericalFormatter.FormatTime(component.CurrentBlocker.TotalTime - component.CurrentTime)));
                return false;
            }
            return null;
        }

        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            var connection = arg.Connection;
            if (connection == null || string.IsNullOrEmpty(arg.cmd?.FullName)) return null;
            var player = arg.Player();
            if (player == null || !IsRaidBlocked(player)) return null;
            if (config.PlayerBlockSettings.BlackListCommands.Contains(arg.cmd.Name.ToLower()) || config.PlayerBlockSettings.BlackListCommands.Contains(arg.cmd.FullName.ToLower()))
            {
                var component = PlayerBlockStatus.Get(player);
                if (component == null || component.CurrentBlocker == null) return null;
                player.ChatMessage(string.Format(Messages["commandBlock"], NumericalFormatter.FormatTime(component.CurrentBlocker.TotalTime - component.CurrentTime)));
                return false;
            }
            return null;
        }

        #endregion

        #region Functions
        private string GetFormatTime(TimeSpan timespan)
        {
            return string.Format(timespan.TotalHours >= 1 ? "{2:00}:{0:00}:{1:00}" : "{0:00}:{1:00}", timespan.Minutes, timespan.Seconds, System.Math.Floor(timespan.TotalHours));
        }

        private static class NumericalFormatter
        {
            private static string GetNumEndings(int origNum, string[] forms)
            {
                string result;
                var num = origNum % 100;
                if (num >= 11 && num <= 19)
                {
                    result = forms[2];
                }
                else
                {
                    num = num % 10;
                    switch (num)
                    {
                        case 1: result = forms[0]; break;
                        case 2:
                        case 3:
                        case 4:
                            result = forms[1]; break;
                        default:
                            result = forms[2]; break;
                    }
                }
                return string.Format("{0} {1} ", origNum, result);
            }

            private static string FormatSeconds(int seconds) =>
                GetNumEndings(seconds, new[] { "секунду", "секунды", "секунд" });
            private static string FormatMinutes(int minutes) =>
                GetNumEndings(minutes, new[] { "минуту", "минуты", "минут" });
            private static string FormatHours(int hours) =>
                GetNumEndings(hours, new[] { "час", "часа", "часов" });
            private static string FormatDays(int days) =>
                GetNumEndings(days, new[] { "день", "дня", "дней" });
            private static string FormatTime(TimeSpan timeSpan)
            {
                string result = string.Empty;
                if (timeSpan.Days > 0)
                    result += FormatDays(timeSpan.Days);
                if (timeSpan.Hours > 0)
                    result += FormatHours(timeSpan.Hours);
                if (timeSpan.Minutes > 0)
                    result += FormatMinutes(timeSpan.Minutes);
                if (timeSpan.Seconds > 0)
                    result += FormatSeconds(timeSpan.Seconds).TrimEnd(' ');
                return result;
            }

            public static string FormatTime(int seconds) => FormatTime(new TimeSpan(0, 0, seconds));
            public static string FormatTime(float seconds) => FormatTime((int)Math.Round(seconds));
            public static string FormatTime(double seconds) => FormatTime((int)Math.Round(seconds));
        }
        #endregion

        #region API

        private bool IsBlocked(BasePlayer player) => IsRaidBlocked(player);

        private List<Vector3> ApiGetOwnerRaidZones(ulong playerid)
        {
            var OwnerList = BlockerList.Where(p => p.OwnerID == playerid || p.Privilage != null && p.Privilage.Contains(playerid)).Select(p => p.transform.position).ToList();
            return OwnerList;
        }

        private List<Vector3> ApiGetAllRaidZones()
          => BlockerList.Select(p => p.transform.position).ToList();

        private bool IsRaidBlock(ulong userId) => IsRaidBlocked(userId.ToString());

        private bool IsRaidBlocked(BasePlayer player) {
			var targetBlock = PlayerBlockStatus.Get(player);
			if (targetBlock==null) return false;
			if (targetBlock.CurrentBlocker == null) return false;
			
			return true;
		}

        private bool IsRaidBlocked(string player)
        {
            BasePlayer target = BasePlayer.Find(player);
            if (target == null) return false;

            return IsRaidBlocked(target);
        }

        private int ApiGetTime(ulong userId)
        {
            if (!IsRaidBlocked(userId.ToString())) 
				return 0;
            var targetBlock = PlayerBlockStatus.Get(BasePlayer.Find(userId.ToString()));
            return (int)(targetBlock.CurrentBlocker.TotalTime - targetBlock.CurrentTime);
        }

		
        private string CanTeleport(BasePlayer player)
        {
            if (!config.PlayerBlockSettings.CanTeleport) return null;
            if (!IsRaidBlocked(player)) return null;
            var component = PlayerBlockStatus.Get(player);
            if (component == null) return null;
            return string.Format(Messages["blocktp"], NumericalFormatter.FormatTime(component.CurrentBlocker.TotalTime - component.CurrentTime));
        }

        private int? CanBGrade(BasePlayer player, int grade, BuildingBlock block, Planner plan)
        {
            if (!config.PlayerBlockSettings.CanBGrade) return null;
            if (!IsRaidBlocked(player)) return null;
            var component = PlayerBlockStatus.Get(player);
            if (component == null) return null;
            player.ChatMessage(string.Format(Messages["blockupgrade"], NumericalFormatter.FormatTime(component.CurrentBlocker.TotalTime - component.CurrentTime)));
            return 0;
        }

        private string CanTrade(BasePlayer player)
        {
            if (!config.PlayerBlockSettings.CanUseTrade) return null;
            if (!IsRaidBlocked(player)) return null;
            var component = PlayerBlockStatus.Get(player);
            if (component == null) return null;
            return string.Format(Messages["blocktrade"], NumericalFormatter.FormatTime(component.CurrentBlocker.TotalTime - component.CurrentTime));
        }

        private string canRemove(BasePlayer player)
        {

            if (!config.PlayerBlockSettings.CanRemove) return null;
            if (!IsRaidBlocked(player)) return null;
            var component = PlayerBlockStatus.Get(player);
            if (component == null) return null;
            return string.Format(Messages["blockremove"], NumericalFormatter.FormatTime(component.CurrentBlocker.TotalTime - component.CurrentTime));
        }

        private string canTeleport(BasePlayer player)
        {
            if (!config.PlayerBlockSettings.CanTeleport) return null;
            if (!IsRaidBlocked(player)) return null;
            var component = PlayerBlockStatus.Get(player);
            if (component == null) return null;
            return string.Format(Messages["blocktp"], NumericalFormatter.FormatTime(component.CurrentBlocker.TotalTime - component.CurrentTime));
        }

        object canRedeemKit(BasePlayer player)
        {
            if (!config.PlayerBlockSettings.CanUseKits) return null;

            if (!IsRaidBlocked(player)) return null;
            var component = PlayerBlockStatus.Get(player);
            if (component == null) return null;
            return string.Format(Messages["blockKits"], NumericalFormatter.FormatTime(component.CurrentBlocker.TotalTime - component.CurrentTime));
        }

        private bool? CanAffordUpgrade(BasePlayer player, BuildingBlock block, BuildingGrade.Enum grade)
        {
            if (!IsRaidBlocked(player)) return null;
            var component = PlayerBlockStatus.Get(player);
            if (component == null) return null;
            player.ChatMessage(string.Format(Messages["blockupgrade"], NumericalFormatter.FormatTime(component.CurrentBlocker.TotalTime - component.CurrentTime)));
            return false;
        }

        private bool? OnStructureRepair(BaseCombatEntity entity, BasePlayer player)
        {
            if (!config.PlayerBlockSettings.CanRepair) return null;
            if (!IsRaidBlocked(player)) return null;
            var component = PlayerBlockStatus.Get(player);
            if (component == null) return null;
            player.ChatMessage(string.Format(Messages["blockrepair"], NumericalFormatter.FormatTime(component.CurrentBlocker.TotalTime - component.CurrentTime)));
            return false;
        }

        object OnStructureDemolish(BaseCombatEntity entity, BasePlayer player)
        {
            if (!config.PlayerBlockSettings.CanDefaultremove) return null;
            if (player == null) return null;
            if (!IsRaidBlocked(player)) return null;
            var component = PlayerBlockStatus.Get(player);
            if (component == null) return null;
            player.ChatMessage(string.Format(Messages["blockremove"], NumericalFormatter.FormatTime(component.CurrentBlocker.TotalTime - component.CurrentTime)));
            return null;
        }

        private SphereComponent GetRaidZone(Vector3 pos) =>
             BlockerList.Where(p => Vector3.Distance(p.transform.position, pos) < config.BlockSettings.BlockerDistance).FirstOrDefault();

        #endregion

		#region VkAPI
			Dictionary<ulong, string> _PlayerNicknames = new Dictionary<ulong, string>();

			public Dictionary<ulong, string> baza;

        private void ALERTPLAYER(ulong ID, string name, string pos)
        {
            ALERT alert;
            if(!alerts.TryGetValue(ID, out alert))
            {
                alerts.Add(ID, new ALERT());
                alert = alerts[ID];
            }

            #region ОПОВЕЩЕНИЕ В ВК
            if (alert.vkcooldown < DateTime.Now)
            {
                string vkid;
                if (baza.TryGetValue(ID, out vkid))
                {
                    GetRequest(vkid, $"Внимание! Игрок {name} начал рейд вашего строения в квадрате {pos} на сервере SERVERNAME.");
                    alert.vkcooldown = DateTime.Now.AddSeconds(1200);
                }
            }
            #endregion
        }

        private static Dictionary<string, Vector3> Grids = new Dictionary<string, Vector3>();
        private void CreateSpawnGrid()
        {
            Grids.Clear();
            var worldSize = (ConVar.Server.worldsize);
            float offset = worldSize / 2;
            var gridWidth = (0.0066666666666667f * worldSize);
            float step = worldSize / gridWidth;

            string start = "";

            char letter = 'A';
            int number = 0;

            for (float zz = offset; zz > -offset; zz -= step)
            {
                for (float xx = -offset; xx < offset; xx += step)
                {
                    Grids.Add($"{start}{letter}{number}", new Vector3(xx - 55f, 0, zz + 20f));
                    if (letter.ToString().ToUpper() == "Z")
                    {
                        start = "A";
                        letter = 'A';
                    }
                    else
                    {
                        letter = (char)(((int)letter) + 1);
                    }


                }
                number++;
                start = "";
                letter = 'A';
            }
        }

        private string GetNameGrid(Vector3 pos)
        {
            return Grids.Where(x => x.Value.x < pos.x && x.Value.x + 150f > pos.x && x.Value.z > pos.z && x.Value.z - 150f < pos.z).FirstOrDefault().Key;
        }

			private static string HexToRustFormat(string hex)
			{
				if (string.IsNullOrEmpty(hex))
				{
					hex = "#FFFFFFFF";
				}
				var str = hex.Trim('#');
				if (str.Length == 6) str += "FF";
				if (str.Length != 8)
				{
					throw new Exception(hex);
					throw new InvalidOperationException("Cannot convert a wrong format.");
				}
				var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
				var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
				var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
				var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);
				Color color = new Color32(r, g, b, a);
				return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
			}
			private string GetOfflineName(ulong id)
			{
				string name = "";
				if (_PlayerNicknames.ContainsKey(id))
					name = _PlayerNicknames[id];

				return name;
			}
			bool IsOnline(ulong id)
			{
				foreach (BasePlayer active in BasePlayer.activePlayerList)
				{
					if (active.userID == id) return true;
				}

				return false;
			}
		#endregion

        #region Хуита
        class ALERT
        {
            public DateTime gamecooldown;
            public DateTime discordcooldown;
            public DateTime vkcooldown;
            public DateTime vkcodecooldown;
        }

        class CODE
        {
            public string id;
            public ulong gameid;
        }

        private static Dictionary<string, CODE> VKCODES = new Dictionary<string, CODE>();
        
        private static Dictionary<ulong, ALERT> alerts = new Dictionary<ulong, ALERT>();
        private string RANDOMNUM() => Random.Range(1000, 99999).ToString();

        [ChatCommand("vk")]
        void ChatVk(BasePlayer player)
        {
            string vkid;
            if (!baza.TryGetValue(player.userID, out vkid))
            {
                player.Command("vk add");
            }
            else
            {
                VkUI(player, "<color=#b0b0b0>ПОДТВЕРЖДЕНО</color>", "0.51 0.85 0.59 0.4", "", "Теперь вам будут приходить оповещение о рейде в ЛС\n<b>НЕ ЗАПРЕЩАЙТЕ СООБЩЕНИЕ ОТ СООБЩЕСТВА</b>"); 
            }
        }

        [ConsoleCommand("vk")]
        void ConsolePM(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player != null && args.HasArgs(1))
            {
                Puts(args.Args[0]);
                if (args.Args[0] == "add")
                {
                    if(args == null || args.Args.Length == 1)
                    {
                        string vkid;
                        if (!baza.TryGetValue(player.userID, out vkid))
                        {
                            VkUI(player, "Укажите свой вк", "0 0 0 0.6", "vk add ", "Чтобы подключить оповещение о рейде\nдобавте выше <b>id вашего аккаунта</b>"); 
                        }
                        else
                        {
                            VkUI(player, "<color=#b0b0b0>ПОДТВЕРЖДЕНО</color>", "0.51 0.85 0.59 0.4", "", "Теперь вам будут приходить оповещение о рейде в ЛС\n<b>НЕ ЗАПРЕЩАЙТЕ СООБЩЕНИЕ ОТ СООБЩЕСТВА</b>"); 
                        }
                        return;
                    }
                    ALERT aLERT;
                    if (alerts.TryGetValue(player.userID, out aLERT) && aLERT.vkcodecooldown > DateTime.Now)
                    {
                        player.ChatMessage($"Отправить новый код вы сможете через {FormatTime(aLERT.vkcodecooldown - DateTime.Now).ToLower()}");
                        return;
                    }

                    string id = args.Args[1].ToLower().Replace("vk.com/", "").Replace("https://", "").Replace("http://", "");
                    string num = RANDOMNUM();
                    GetRequest(id, $"Код подтверждения {num} аккаунта.", player, num);
                }
                if (args.Args[0] == "accept")
                {
                    if(args == null || args.Args.Length == 1)
                    {
                        VkUI(player, "Укажите код из сообщения", "0 0 0 0.6", "vk accept ", "Вы не указали <b>код</b>!"); 
                        return;
                    }

                    CODE cODE;
                    if (VKCODES.TryGetValue(args.Args[1], out cODE) && cODE.gameid == player.userID)
                    {
                        string vkid;
                        if(baza.TryGetValue(player.userID, out vkid))
                        {
                            vkid = cODE.id;
                        }
                        else
                        {
                            baza.Add(player.userID, cODE.id);
                        }
                        VKCODES.Remove(args.Args[1]);
                        VkUI(player, "<color=#b0b0b0>ПОДТВЕРЖДЕНО</color>", "0.51 0.85 0.59 0.4", "", "Теперь вам будут приходить оповещение о рейде в ЛС\n<b>НЕ ЗАПРЕЩАЙТЕ СООБЩЕНИЕ ОТ СООБЩЕСТВА</b>"); 
                        Interface.Oxide.DataFileSystem.WriteObject("Vk/Data", baza);
                    }
                    else
                    {
                        VkUI(player, "Укажите код из сообщения", "0 0 0 0.6", "vk accept ", "Не верный <b>код</b>!"); 
                    }
                }
                if (args.Args[0] == "delete")
                {
                    if (baza.ContainsKey(player.userID))
                    {
                        baza.Remove(player.userID);
                        VkUI(player, "Укажите свой вк", "0 0 0 0.6", "vk add ", "Чтобы подключить оповещение о рейде\nдобавте выше <b>id вашего аккаунта</b>"); 
                    }
                }
            }
        }

        private void GetRequest(string reciverID, string msg, BasePlayer player = null, string num = null) => webrequest.Enqueue("https://api.vk.com/method/messages.send?domain=" + reciverID + "&message=" + msg.Replace("#", "%23") + "&v=5.86&access_token=" + config.Sender.VK.VKAccess, null, (code2, response2) => ServerMgr.Instance.StartCoroutine(GetCallback(code2, response2, reciverID, player, num)), this);
        
        private IEnumerator GetCallback(int code, string response, string id, BasePlayer player = null, string num = null)
        {
            if (player == null) yield break;
            if (response == null || code != 200)
            {
                ALERT alert;
                if (alerts.TryGetValue(player.userID, out alert)) alert.vkcooldown = DateTime.Now;
                Debug.Log("НЕ ПОЛУЧИЛОСЬ ОТПРАВИТЬ СООБЩЕНИЕ В ВК! => обнулили кд на отправку");
                yield break;
            }
            yield return new WaitForEndOfFrame();
            if (!response.Contains("error"))
            {
                ALERT aLERT;
                if (alerts.TryGetValue(player.userID, out aLERT))
                {
                    aLERT.vkcodecooldown = DateTime.Now.AddMinutes(10);
                }
                else
                {
                    alerts.Add(player.userID, new ALERT {vkcodecooldown = DateTime.Now.AddMinutes(10) });
                }
                if (VKCODES.ContainsKey(num)) VKCODES.Remove(num);
                VKCODES.Add(num, new CODE { gameid = player.userID, id = id });
                VkUI(player, "Укажите код из сообщения", "0 0 0 0.6", "vk accept ", $"Вы указали VK: <b>{id}</b>. Вам в <b>VK</b> отправлено сообщение с кодом.\nВставте <b>код</b> выше, чтобы подтвердить авторизацию");
            }
            else if (response.Contains("PrivateMessage"))
            {
                VkUI(player, "Укажите свой вк", "0 0 0 0.6", "vk add ", $"Ваши настройки приватности не позволяют отправить вам\nсообщение <b>{id}</b>");
            }
            else if(response.Contains("ErrorSend"))
            {
                VkUI(player, "Укажите свой вк", "0 0 0 0.6", "vk add ", $"Невозможно отправить сообщение.Проверьте правильность ссылки <b>{id}</b>\nили повторите попытку позже.");
            }
            else if(response.Contains("BlackList"))
            {
                VkUI(player, "Укажите свой вк", "0 0 0 0.6", "vk add ", "Невозможно отправить сообщение. Вы добавили группу в черный список или не подписаны на нее, если это не так,\nто просто напишите в группу сервера любое сообщение и попробуйте еще раз.");
            }
            else
            {
                VkUI(player, "Укажите свой вк", "0 0 0 0.6", "vk add ", $"Вы указали неверный <b>VK ID {id}</b>, если это не так,\nто просто напишите в группу сервера любое сообщение и попробуйте еще раз."); 
            }
            yield break;
        }

        string Layers = "Vk_UI";

        void VkUI(BasePlayer player, string vk = "", string color = "", string command = "", string text = "")
        {
            CuiHelper.DestroyUi(player, Layers);
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                RectTransform = { AnchorMin = "0.288 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0" }
            }, "Info", Layers);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0 0.8", AnchorMax = $"1 1", OffsetMax = "0 0" },
                Image = { Color = "1 1 1 0.2" },
            }, Layers);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.1 0.8", AnchorMax = $"0.9 1", OffsetMax = "0 0" },
                Text = { Text = "<b><size=40>ОПОВЕЩЕНИЕ</size></b>\nУслуга оповещения о рейде предоставляется бесплатно для наших игроков. Подключив оповещения вы будете автоматически проинформированы в соц-сетях когда один из строительных объектов будет сломан.", Color = "1 1 1 0.6", Align = TextAnchor.MiddleLeft, FontSize = 12, Font = "robotocondensed-regular.ttf" }
            }, Layers);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.05 0.45", AnchorMax = $"0.95 0.77", OffsetMax = "0 0" },
                Image = { Color = "1 1 1 0.2" },
            }, Layers, "Vk");

            container.Add(new CuiElement
            {
                Parent = "Vk",
                Components =
                {
                    new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", "4jcrNyN") },
                    new CuiRectTransformComponent { AnchorMin = "0.45 0.7", AnchorMax = "0.55 0.9", OffsetMax = "0 0" }
                }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.3 0.63", AnchorMax = $"0.7 0.69", OffsetMax = "0 0" },
                Text = { Text = "ЭТО ВАШ АККАУНТ", Color = "1 1 1 0.3", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-regular.ttf" }
            }, Layers);

            var anchorMax = command != "" ? "0.93 0.6" : "0.86 0.6";
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.07 0.55", AnchorMax = anchorMax, OffsetMax = "0 0" },
                Image = { Color = color }
            }, Layers, "Enter");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.04 0", AnchorMax = $"0.96 1", OffsetMax = "0 0" },
                Text = { Text = vk, Color = "1 1 1 0.05", Align = TextAnchor.MiddleCenter, FontSize = 12, Font = "robotocondensed-regular.ttf" }
            }, "Enter");

            if (command != "")
            {
                container.Add(new CuiElement
                {
                    Parent = "Enter",
                    Components =
                    {
                        new CuiInputFieldComponent { Text = "ХУЙ", FontSize = 14, Align = TextAnchor.MiddleCenter, Command = command, Color = "1 1 1 0.6", CharsLimit = 40},
                        new CuiRectTransformComponent { AnchorMin = "0.04 0", AnchorMax = "0.96 1" }
                    }
                });
            }

            if (command == "")
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0.86 0.55", AnchorMax = $"0.93 0.6", OffsetMax = "0 0" },
                    Button = { Color = "0.76 0.35 0.35 0.4", Command = "vk delete" },
                    Text = { Text = "✖", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 20, Font = "robotocondensed-bold.ttf" }
                }, Layers);
            }

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.5", AnchorMax = $"1 0.55", OffsetMax = "0 0" },
                Text = { Text = text, Color = "1 1 1 0.3", Align = TextAnchor.MiddleCenter, FontSize = 12, Font = "robotocondensed-regular.ttf" }
            }, Layers);

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region ВРЕМЯ
        private static string m0 = "МИНУТ";
        private static string m1 = "МИНУТЫ";
        private static string m2 = "МИНУТУ";

        private static string s0 = "СЕКУНД";
        private static string s1 = "СЕКУНДЫ";
        private static string s2 = "СЕКУНДУ";

        private static string FormatTime(TimeSpan time)
        => (time.Minutes == 0 ? string.Empty : FormatMinutes(time.Minutes)) + ((time.Seconds == 0) ? string.Empty : FormatSeconds(time.Seconds));

        private static string FormatMinutes(int minutes) => FormatUnits(minutes, m0, m1, m2);

        private static string FormatSeconds(int seconds) => FormatUnits(seconds, s0, s1, s2);

        private static string FormatUnits(int units, string form1, string form2, string form3)
        {
            var tmp = units % 10;

            if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9 || tmp == 0)
                return $"{units} {form1} ";

            if (tmp >= 2 && tmp <= 4)
                return $"{units} {form2} ";

            return $"{units} {form3} ";
        }
        #endregion



        #region Messages

        Dictionary<string, string> Messages = new Dictionary<string, string>() {
                {
                "blocksuccess", "Блок деактивирован. Функции разблокированы"
            }
            , {
                "guitimertext", "<b>Блокировка:</b> Осталось {0}"
            }
            , {
                "blockactive", "Ваше строение в квадрате <color=#ECBE13>{0}</color> разрушено, активирован рейд блок на <color=#ECBE13>{1}</color>\nНекоторые функции временно недоступны."
            }
             , {
                "blockactiveOwner", "Внимание! Ваше строение в квадрате <color=#ECBE13>{0}</color> разрушено."
            }
             , {
                "enterRaidZone", "Внимание! Вы вошли в зону рейд блока, активирован блок на <color=#ECBE13>{0}</color>\nНекоторые функции временно недоступны."
            }
             , {
                "blockactiveAuthCup", "Внимание! Строение в каком вы проживаете в квадрате <color=#ECBE13>{0}</color> было разрушено, активирован рейд блок на <color=#ECBE13>{1}</color>\nНекоторые функции временно недоступны."
            }
            , {
                "blockactiveAttacker", "Вы уничтожили чужой объект, активирован рейд блок на <color=#ECBE13>{0}</color>\nНекоторые функции временно недоступны."
            }
            , {
                "blockrepair", "Вы не можете ремонтировать строения во время рейда, подождите {0}"
            }
            , {
                "blocktp", "Вы не можете использовать телепорт во время рейда, подождите {0}"
            }
            , {
                "blockremove", "Вы не можете удалить постройки во время рейда, подождите {0}"
            }
            , {
                "blockupgrade", "Вы не можете использовать улучшение построек во время рейда, подождите {0}"
            }
            , {
                "blockKits", "Вы не можете использовать киты во время рейда, подождите {0}"
            }
            , {
                "blockbuld", "Вы не можете строить во время рейда, подождите {0}"
            },
            {
                "raidremove", "Вы не можете удалять обьекты во время рейда, подождите {0}"
            },
            {
                "blocktrade", "Вы не можете использовать обмен во время рейда, подождите {0} "
            },
            {
                "commandBlock", "Вы не можете использовать данную команду во время рейда, подождите {0}"
            },
            {"VkExit", "У вас уже есть страница!" },
            {"VkVremExit", "У вас уже есть активный запрос на подтверждение!"},
            {"VkCodeError", "Неправильный код !"},
            {"VkSendError", "Ошибка при отправке проверочного кода" },
            {"VkSendError2", "Ошибка при отправке проверочного кода\nОтправьте сообщение в группу и попробуй еще раз" },
            {"VkCodeSend", "Код подтверждения отправлен!" },
            {"VkAdded", "Страница успешно добавлена" }
        };
        #endregion
    }
}

// --- End of file: NoEscape.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BloodRust-fuuu/CaseSystem.cs ---
// --- Original Local Path: BloodRust-fuuu/CaseSystem.cs ---

using System.Collections.Generic;
using UnityEngine;
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using System.Linq;
using Oxide.Core.Plugins;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("CaseSystem", "Topplugin.ru", "3.0.0")]
    class CaseSystem : RustPlugin
    {
        #region Вар
        string Layer = "Case_UI";

        [PluginReference] Plugin ImageLibrary, XpSystem;

        Dictionary<ulong, PlayerInventory> Settings = new Dictionary<ulong, PlayerInventory>();

        private static CaseSystem inst;
        #endregion

        #region Класс
        public class CaseSettings
        {
            [JsonProperty("ID кейса")] public string Id;
            [JsonProperty("Название кейса")] public string DisplayName;
            [JsonProperty("Цена кейса")] public float Count;
            [JsonProperty("Изображение кейса")] public string Url;
            [JsonProperty("Список предметов")] public List<Items> items;
        }

        public class Items
        {
            [JsonProperty("Название предмета/команды")] public string DisplayName;
            [JsonProperty("Короткое название предмета")] public string ShortName;
            [JsonProperty("Минимальное количество при выпадени")] public int AmountMin;
            [JsonProperty("Максимальное Количество при выпадени")] public int AmountMax;
            [JsonProperty("Команда")] public string Command;
            [JsonProperty("Изображение")] public string Url;
            public int GetRandomAmount() => Core.Random.Range(AmountMin, AmountMax);
        }

        private class InventoryItem
        {
            [JsonProperty("Название предмета/команды")] public string DisplayName;
            [JsonProperty("Короткое название предмета")] public string ShortName;
            [JsonProperty("Кол-во предмета")] public int Amount;
            [JsonProperty("Команда")] public string Command;
            [JsonProperty("Изображение")] public string Url;

            public Item GiveItem(BasePlayer player)
            {
                if (!string.IsNullOrEmpty(Command)) inst.Server.Command(Command.Replace("%STEAMID%", player.UserIDString));
                if (!string.IsNullOrEmpty(ShortName))
                {
                    Item item = ItemManager.CreateByPartialName(ShortName, Amount);

                    return item;
                }
                return null;
            }

            public static InventoryItem Generate(Items items)
            {
                return new InventoryItem
                {
                    DisplayName = items.DisplayName,
                    ShortName = items.ShortName,
                    Amount = items.GetRandomAmount(),
                    Command = items.Command,
                    Url = items.Url
                };
            }
        }

        private class PlayerInventory
        {
            [JsonProperty("Список вещей")] public List<InventoryItem> Inventory = new List<InventoryItem>();
        }
        #endregion

        #region Конфиг
        Configuration config;
        class Configuration 
        {
            [JsonProperty("Настройки кейсов")] public List<CaseSettings> settings;
            public static Configuration GetNewConfig() 
            {
                return new Configuration
                {
                    settings = new List<CaseSettings>()
                    {
                        new CaseSettings
                        {
                            Id = "1",
                            DisplayName = "Кейс 1",
                            Count = 100,
                            Url = "",
                            items = new List<Items>()
                            {
                                new Items
                                {
                                    DisplayName = "Дерево",
                                    ShortName = "wood",
                                    AmountMin = 1000,
                                    AmountMax = 2000,
                                    Command = null,
                                    Url = null
                                }
                            }
                        }
                    }
                };
            }
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config?.settings == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Ошибка чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfig();
        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion

        #region Хуки
        void OnServerInitialized() 
        {
            PrintWarning("\n-----------------------------\n" +
            "     Author - https://topplugin.ru/\n" +
            "     VK - https://vk.com/rustnastroika\n" +
            "     Discord - https://discord.com/invite/5DPTsRmd3G\n" +
            "-----------------------------");
            inst = this;
            foreach (var check in config.settings)
            {
                ImageLibrary.Call("AddImage", check.Url, check.Url);
                foreach (var item in check.items)
                    ImageLibrary.Call("AddImage", item.Url, item.Url);
            }
            foreach (var check in BasePlayer.activePlayerList)
                OnPlayerConnected(check);
        }

        void OnPlayerConnected(BasePlayer player) =>  CreateDataBase(player);

        void OnPlayerDisconnected(BasePlayer player, string reason) => SaveDataBase(player.userID);

        void Unload() 
        {
            foreach(var check in Settings)
                SaveDataBase(check.Key);

            foreach(var check in BasePlayer.activePlayerList)
                CuiHelper.DestroyUi(check, Layer);
        }
        #endregion

        #region Методы
        void CreateDataBase(BasePlayer player)
        {
            var DataBase = Interface.Oxide.DataFileSystem.ReadObject<PlayerInventory>($"CaseSystem/{player.userID}");
            
            if (!Settings.ContainsKey(player.userID))
                Settings.Add(player.userID, new PlayerInventory());
             
            Settings[player.userID] = DataBase ?? new PlayerInventory();
        }

        void SaveDataBase(ulong userId) => Interface.Oxide.DataFileSystem.WriteObject($"CaseSystem/{userId}", Settings[userId]);

        InventoryItem AddItem(BasePlayer player, Items items)
        {
            var item = InventoryItem.Generate(items);
            Settings[player.userID].Inventory.Add(item);
            return item;
        }

        void UpdateBalance(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "Balance");
            CuiElementContainer container = new CuiElementContainer();
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.203 0.54", AnchorMax = $"0.397 0.585", OffsetMax = "0 0" },
                Button = { Color = "1 1 1 0.1" },
                Text = { Text = $"Ваш баланс: {XpSystem.Call("API_GetXp", player.userID)}xp", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 12, Font = "robotocondensed-regular.ttf" }
            }, Layer, "Balance");
            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region Команды
        [ConsoleCommand("case")]
        void ConsoleCase(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player != null && args.HasArgs(1))
            {
                if (args.Args[0] == "check")
                {
                    CaseUI(player, args.Args[1]);
                }
                if (args.Args[0] == "open")
                {
                    var check = config.settings.FirstOrDefault(z => z.Id == args.Args[1]);
                    if ((float)XpSystem.Call("API_GetXp", player.userID) >= check.Count)
                    {
                        var items = check.items.ToList().GetRandom();
                        XpSystem.Call("API_ShopRemBalance", player.userID, check.Count);
                        UpdateBalance(player);
                        RewardUI(player, items);
                    }
                }
                if (args.Args[0] == "inventory")
                {
                    InventoryUI(player);
                }
                if (args.Args[0] == "take")
                {
                    var item = Settings[player.userID].Inventory.ElementAt(int.Parse(args.Args[1]));
                    if (item.ShortName != null)
                    {
                        if (player.inventory.containerMain.itemList.Count >= 24)
                        {
                            player.ChatMessage($"<color=#8fde5b><size=16>Кейсы:</size></color>\nУ вас <color=#8fde5b>недостаточно</color> места в основном инвентаре!");
                            return;
                        }
                    }
                    var text = item.Command != null ? $"<color=#8fde5b><size=16>Кейсы:</size></color>\nВы получили услугу: <color=#8fde5b>{item.DisplayName}</color>" : $"<color=#8fde5b><size=16>Кейсы:</size></color>\nВы получили предмет: <color=#8fde5b>{item.DisplayName}</color>\nВ размере: <color=#8fde5b>{item.Amount}шт.</color>";
                    SendReply(player, text);
                    item.GiveItem(player)?.MoveToContainer(player.inventory.containerMain);
                    Settings[player.userID].Inventory.Remove(item);
                    InventoryUI(player);
                }
                if (args.Args[0] == "skip")
                {
                    InventoryUI(player, int.Parse(args.Args[1]));
                }
            }
        }
        #endregion

        #region Интерфейс
        void CaseUI(BasePlayer player, string Id = "1")
        {
            CuiHelper.DestroyUi(player, Layer);
            var container = new CuiElementContainer();
            var cases = config.settings.FirstOrDefault(z => z.Id == Id);
            int ItemCount = cases.items.Count(), CountItem = 0, Count = 6;
            float Position = 0.5f, Width = 0.1f, Height = 0.115f, Margin = 0.005f, MinHeight = 0.3f;

            if (ItemCount >= Count) Position = 0.5f - Count / 2f * Width - (Count - 1) / 2f * Margin;
            else Position = 0.5f - ItemCount / 2f * Width - (ItemCount - 1) / 2f * Margin;
            ItemCount -= Count;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.289 0", AnchorMax = "0.945 1", OffsetMax = "0 0" },
                Image = { Color = "0.117 0.121 0.109 0.95" },
            }, "Menu_UI", Layer);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.8", AnchorMax = "1 0.97", OffsetMax = "0 0" },
                Text = { Text = $"<b><size=45>Кейсы</size></b>\nПривет {player.displayName}, ты открыл меню рулетки в которой ты найдешь множество кейсов и сможешь испытать свою удачу\nКаждый кейс имеет свое назначение и за каждый из них тебе предстоит заплатить!\nПополнить баланс ты можешь добывая ресурсы, убивая игроков, сбивая вертолеты, взрывая танки!", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 12, Font = "robotocondensed-regular.ttf" }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.203 0.54", AnchorMax = $"0.397 0.585", OffsetMax = "0 0" },
                Button = { Color = "1 1 1 0.1" },
                Text = { Text = $"Ваш баланс: {XpSystem.Call("API_GetXp", player.userID)}xp", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 12, Font = "robotocondensed-regular.ttf" }
            }, Layer, "Balance");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.403 0.54", AnchorMax = $"0.598 0.585", OffsetMax = "0 0" },
                Button = { Color = "1 1 1 0.1", Command = "case inventory" },
                Text = { Text = $"Инвентарь", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 12, Font = "robotocondensed-regular.ttf" }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.603 0.54", AnchorMax = $"0.798 0.585", OffsetMax = "0 0" },
                Button = { Color = "1 1 1 0.1", Command = $"case open {cases.Id}" },
                Text = { Text = $"ОТКРЫТЬ\n{cases.DisplayName}: {cases.Count}xp", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 12, Font = "robotocondensed-regular.ttf" }
            }, Layer);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.43", AnchorMax = "1 0.51", OffsetMax = "0 0" },
                Text = { Text = $"<b><size=33>ИНФОРМАЦИЯ</size></b>\n{cases.DisplayName} - список доступных предметов", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 12, Font = "robotocondensed-regular.ttf" }
            }, Layer);

            float width = 0.2f, height = 0.21f, startxBox = 0.2f, startyBox = 0.8f - height, xmin = startxBox, ymin = startyBox;
            foreach (var check in config.settings)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{xmin} {ymin}", AnchorMax = $"{xmin + width} {ymin + height * 1}", OffsetMin = "2 2", OffsetMax = "-2 -2" },
                    Button = { Color = "1 1 1 0.1", Command = $"case check {check.Id}" },
                    Text = { Text = $"", Align = TextAnchor.LowerRight, FontSize = 12, Font = "robotocondensed-regular.ttf" }
                }, Layer, "Images");

                container.Add(new CuiElement
                {
                    Parent = "Images",
                    Components =
                    {
                        new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", check.Url) },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "10 10", OffsetMax = "-5 -10" }
                    }
                });
                xmin += width;
                if (xmin + width >= 1)
                {
                    xmin = startxBox;
                    ymin -= height;
                }
            }

            foreach (var check in cases.items)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{Position} {MinHeight}", AnchorMax = $"{Position + Width} {MinHeight + Height}", OffsetMax = "0 0" },
                    Button = { Color = "1 1 1 0.1" },
                    Text = { Text = "" }
                }, Layer, "Items");

                var image = check.Command != null ? check.Url : check.ShortName;
                container.Add(new CuiElement
                {
                    Parent = "Items",
                    Components =
                    {
                        new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", image) },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" }
                    }
                });

                var textAmount = check.AmountMin != check.AmountMax ? $"{check.AmountMin}-{check.AmountMax}" : $"{check.AmountMax}";
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0" },
                    Text = { Text = $"X{textAmount} ", Color = "1 1 1 0.5", Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.LowerRight }
                }, "Items");

                CountItem += 1;
                if (CountItem % Count == 0)
                {
                    if (ItemCount > Count)
                    {
                        Position = 0.5f - Count / 2f * Width - (Count - 1) / 2f * Margin;
                        ItemCount -= Count;
                    }
                    else
                    {
                        Position = 0.5f - ItemCount / 2f * Width - (ItemCount - 1) / 2f * Margin;
                    }
                    MinHeight -= ((Margin * 2) + Height);
                }
                else
                {
                    Position += (Width + Margin);
                }
            }

            CuiHelper.AddUi(player, container);
        }

        void RewardUI(BasePlayer player, Items items)
        {
            CuiHelper.DestroyUi(player, "Reward");
            var container = new CuiElementContainer();
            var item = AddItem(player, items);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0.117 0.121 0.109 0.95", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
            }, Layer, "Reward");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.42 0.44", AnchorMax = "0.58 0.61", OffsetMax = "0 0" },
                Image = { Color = "1 1 1 0.1" },
            }, "Reward", "Image");

            var image = items.Command != null ? items.Url : items.ShortName;
            container.Add(new CuiElement
            {
                Parent = "Image",
                Components =
                {
                    new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", image) },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "10 10", OffsetMax = "-5 -10" }
                }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Text = { Text = $"{item.Amount}шт. ", Color = "1 1 1 0.5", Align = TextAnchor.LowerRight, FontSize = 12, Font = "robotocondensed-regular.ttf" }
            }, "Image");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.42 0.4", AnchorMax = "0.58 0.435", OffsetMax = "0 0" },
                Button = { Color = "1 1 1 0.1", Close = "Reward" },
                Text = { Text = "ПРИНЯТЬ НАГРАДУ", Color = "1 1 1 0.5", Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.MiddleCenter }
            }, "Reward");

            CuiHelper.AddUi(player, container);
        }

        void InventoryUI(BasePlayer player, int page = 0)
        {
            CuiHelper.DestroyUi(player, "Inventory");
            var container = new CuiElementContainer();

            int ItemCount = Settings[player.userID].Inventory.Count(), CountItem = 0, Count = 6;
            float Position = 0.5f, Width = 0.13f, Height = 0.155f, Margin = 0.005f, MinHeight = 0.74f;

            if (ItemCount >= Count) Position = 0.5f - Count / 2f * Width - (Count - 1) / 2f * Margin;
            else Position = 0.5f - ItemCount / 2f * Width - (ItemCount - 1) / 2f * Margin;
            ItemCount -= Count;

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0.117 0.121 0.109 0.95" },
            }, Layer, "Inventory");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "-2 -2", AnchorMax = "2 2", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Close = "Inventory" },
                Text = { Text = "" }
            }, "Inventory");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = Settings[player.userID].Inventory.Count() == 0 ? "0 0" : "0 0.9", AnchorMax = $"1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Close = "Inventory" },
                Text = { Text = Settings[player.userID].Inventory.Count() == 0 ? $"ИНВЕНТАРЬ ПУСТ" : "ИНВЕНТАРЬ", Color = "1 1 1 0.5", Font = "robotocondensed-bold.ttf", FontSize = Settings[player.userID].Inventory.Count() == 0 ? 60 : 40, Align = TextAnchor.MiddleCenter }
            }, "Inventory");

            if (page != 0)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0.45", AnchorMax = $"0.06 0.55", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0", Command = $"case skip {page - 1}" },
                    Text = { Text = $"<", Color = "1 1 1 0.5", Font = "robotocondensed-bold.ttf", FontSize = 60, Align = TextAnchor.MiddleCenter }
                }, "Inventory");
            }

            if ((float)Settings[player.userID].Inventory.Count > (page + 1) * 30)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.94 0.45", AnchorMax = $"1 0.55", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0", Command = $"case skip {page + 1}" },
                    Text = { Text = $">", Color = "1 1 1 0.5", Font = "robotocondensed-bold.ttf", FontSize = 60, Align = TextAnchor.MiddleCenter }
                }, "Inventory");
            }

            var list = Settings[player.userID].Inventory.Skip(page * 30).Take(30);
            foreach (var check in list.Select((i, t) => new { A = i, B = t }))
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{Position} {MinHeight}", AnchorMax = $"{Position + Width} {MinHeight + Height}", OffsetMax = "0 0" },
                    Button = { Color = "1 1 1 0.1" },
                    Text = { Text = "" }
                }, "Inventory", $"{check.B}");

                var image = check.A.Command != null ? check.A.Url : check.A.ShortName;
                container.Add(new CuiElement
                {
                    Parent = $"{check.B}",
                    Components =
                    {
                        new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", image) },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" }
                    }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0", Command = $"case take {check.B + page * 30}" },
                    Text = { Text = $"X{check.A.Amount} ", Color = "1 1 1 0.5", Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.LowerRight }
                }, $"{check.B}");

                CountItem += 1;
                if (CountItem % Count == 0)
                {
                    if (ItemCount > Count)
                    {
                        Position = 0.5f - Count / 2f * Width - (Count - 1) / 2f * Margin;
                        ItemCount -= Count;
                    }
                    else
                    {
                        Position = 0.5f - ItemCount / 2f * Width - (ItemCount - 1) / 2f * Margin;
                    }
                    MinHeight -= ((Margin * 2) + Height);
                }
                else
                {
                    Position += (Width + Margin);
                }
            }

            CuiHelper.AddUi(player, container);
        }
        #endregion
    }
}

// --- End of file: CaseSystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BloodRust-fuuu/GameStoresRUST.cs ---
// --- Original Local Path: BloodRust-fuuu/GameStoresRUST.cs ---

﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using WebSocketSharp;

namespace Oxide.Plugins
{
    [Info("GameStoresRUST", "TopPlugin.ru", "3.0.0")]
    public class GameStoresRUST : RustPlugin
    {
        #region References

        [PluginReference] private Plugin ImageLibrary;

        #endregion

        #region Classes

        private static class Delays
        {
            [JsonProperty("Игроки с активными запросами к АПИ")]
            public static List<ulong> ItemList = new List<ulong>();
            [JsonProperty("Количество запросов за последнюю секунду")]
            public static int RequestPerSecond = 0;
            [JsonProperty("Ограничение запросов в секунду")]
            public static int RequestPerSecondLimit = 20;

            public static bool CanRequest(BasePlayer player)
            {
                if (RequestPerSecond > RequestPerSecondLimit)
                {
                    return false;
                }

                if (ItemList.Contains(player.userID))
                {
                    player.ChatMessage($"Пожалуйста, дождитесь <<окончания>> предыдущего действия!");
                    return false;
                }
                return true;
            }

            public static void FinishRequest(BasePlayer player)
            {
                if (ItemList.Contains(player.userID))
                    ItemList.Remove(player.userID);
            }

            public static IEnumerator MakeRequest(BasePlayer player)
            {
                RequestPerSecond++;

                if (ItemList.Contains(player.userID)) yield return null;
                ItemList.Add(player.userID);

                yield return new WaitForSeconds(3f);
                if (ItemList.Contains(player.userID))
                    ItemList.Remove(player.userID);
            }
        }

        private class Stats
        {

        }

        private class Configuration
        {
            public class API
            {
                [JsonProperty("ИД магазина в сервисе")]
                public string ShopID = "UNDEFINED";
                [JsonProperty("ИД сервера в сервисе")]
                public string ServerID = "UNDEFINED";
                [JsonProperty("Секретный ключ (не распространяйте его)")]
                public string SecretKey = "UNDEFINED";
            }

            public class Interface
            {
                [JsonProperty("Количество предметов на строке")]
                public int ItemOnString = 7;
                [JsonProperty("Количество строк в интерфейсе")]
                public int StringAmount = 5;
                [JsonProperty("Сторона одного предмета")]
                public int ItemSide = 100;
                [JsonProperty("Отступ между предметами")]
                public int ItemMargin = 5;
            }

            public class TOP
            {
                [JsonProperty("Отправлять данные топа игроков")]
                public bool UseTop = true;
            }

            [JsonProperty("Настройки API плагина")]
            public API APISettings = new API();
            [JsonProperty("Настройки интерфейса плагина")]
            public Interface InterfaceSettings = new Interface();
            [JsonProperty("Настройки статистики сервера")]
            public TOP TOPSettings = new TOP();
        }

        private class WItem
        {
            public string ID;
            public string Name;
            public int ItemID;
            public int Amount;
            public string ShortName;
            public string Command;
            public string ImageUrl;

            public bool Blocked;
            public double Block_Date = 0;
            public bool IsBlueprint;
            public bool IsCommand;
            public bool IsItem;

            public WItem(Dictionary<string, object> data, bool show = true)
            {
                try
                {
                    if (data.ContainsKey("id")) ID = data["id"].ToString();

                    if (data.ContainsKey("name")) Name = data["name"].ToString();
                    if (data.ContainsKey("item_id")) ItemID = System.Convert.ToInt32(data["item_id"]);
                    if (data.ContainsKey("amount")) Amount = System.Convert.ToInt32(data["amount"]);
                    if (data.ContainsKey("command")) Command = data["command"].ToString();
                    if (data.ContainsKey("img")) ImageUrl = data["img"].ToString();

                    if (data.ContainsKey("blocked")) Blocked = bool.Parse(data["blocked"].ToString());

                    if (data.ContainsKey("block_date") && data["block_date"] is int)
                    {
                        double.TryParse(data["block_date"].ToString(), out Block_Date);
                    }

                    if (data.ContainsKey("type"))
                    {
                        IsBlueprint = data["type"].ToString() == "bp";
                        IsCommand = data["type"].ToString() == "command";
                        IsItem = data["type"].ToString() == "item";
                    }

                    if (ItemID != 0)
                    {
                        var itemInfo = ItemManager.FindItemDefinition(ItemID);
                        if (itemInfo != null) ShortName = itemInfo.shortname;
                        else if (IDToShortName.ContainsKey(ItemID))
                        {
                            itemInfo = ItemManager.FindItemDefinition(IDToShortName[ItemID]);
                            if (itemInfo == null) return;

                            ShortName = itemInfo.shortname;
                        }
                    }

                    var imageLibrary = instance.plugins.Find("ImageLibrary");
                    if (imageLibrary != null)
                    {
                        if (ItemID == 0)
                        {
                            if ((bool)imageLibrary.Call("HasImage", $"IconGS.{ID}"))
                            {
                                string probablyId = (string)imageLibrary.Call("GetImage", $"IconGS.{ID}");
                                if (!probablyId.IsNullOrEmpty() && probablyId != instance.NoImageID && probablyId != instance.LoadingImageID)
                                    ImageUrl = probablyId;
                                return;
                            }

                            if (!ImageUrl.IsNullOrEmpty())
                            {
                                imageLibrary.Call("AddImage", ImageUrl.Replace("https", "http"), $"IconGS.{ID}");
                            }
                        }
                        else
                        {
                            string probablyId = (string)imageLibrary.Call("GetImage", ShortName);
                            if (!probablyId.IsNullOrEmpty() && probablyId != instance.NoImageID && probablyId != instance.LoadingImageID)
                                ImageUrl = probablyId;
                        }
                    }
                }
                catch (NullReferenceException e)
                {
                    Interface.Oxide.LogError(JsonConvert.SerializeObject(data));
                }
            }
        }

        #endregion

        #region Variables

        private static bool initialization = false;
        private static bool Initialized = false;
        private static GameStoresRUST instance;
        private static Configuration Settings = new Configuration();
        private string ShopURL = "UNDEFINED";
        private int StartBalance = 0;
        public string NoImageID = "";
        public string LoadingImageID = "";
        private Dictionary<int, Dictionary<ulong, int>> ListTimeOutCommand = new Dictionary<int, Dictionary<ulong, int>>();
        private Dictionary<ulong, List<int>> playersBasketCache = new Dictionary<ulong, List<int>>();
        private HashSet<ulong> ListBannedCommandUserID = new HashSet<ulong>();
        private Timer TimerCheckInstant;
        private string MainApiLink = $"https://gamestores.ru/api/";
        private string ReserveApiLink = $"https://gs.gamestores.ru/api/";
        //private string BaseRequest => $"https://gamestores.ru/api/?shop_id={Settings.APISettings.ShopID}&secret={Settings.APISettings.SecretKey}{(!Settings.APISettings.ServerID.IsNullOrEmpty() && Settings.APISettings.ServerID != "0" && Settings.APISettings.ServerID != "1" && Settings.APISettings.ServerID != "UNDEFINED" ? $"&server={Settings.APISettings.ServerID}" : "")}";
        private string BaseRequestParams => $"?shop_id={Settings.APISettings.ShopID}&secret={Settings.APISettings.SecretKey}{(!Settings.APISettings.ServerID.IsNullOrEmpty() && Settings.APISettings.ServerID != "0" && Settings.APISettings.ServerID != "1" && Settings.APISettings.ServerID != "UNDEFINED" ? $"&server={Settings.APISettings.ServerID}" : "")}";
        private string BaseRequest = "";
        #endregion

        #region Interface

        private int TryImageCounter = 0;
        private void OnServerInitialized()
        {
            PrintWarning("\n-----------------------------\n" +
            "     Author - https://topplugin.ru/\n" +
            "     VK - https://vk.com/rustnastroika\n" +
            "     Discord - https://discord.com/invite/5DPTsRmd3G\n" +
            "-----------------------------");
            BaseRequest = MainApiLink + BaseRequestParams;
            if (Settings.APISettings.ServerID != "0" && Settings.APISettings.ServerID != "UNDEFINED")
            {
                TimerCheckInstant = timer.Repeat(20, 0, CheckInstant);
            } else
            {
                LogAction(null, $"Некорректный ServerID, автоматическая выдача команд невозможна");
                PrintError($"Incorrect ServerID, reciving auto commands (Products) disabled");
            }
            
            if (!ImageLibrary)
            {
                if (TryImageCounter < 3)
                {
                    LogAction(null, $"ImageLibrary is not initialized, try again in 1 sec.", true);
                    TryImageCounter++;

                    timer.Once(1, OnServerInitialized);
                    return;
                }
                else LogAction(null, $"Starting without ImageLibrary", true);
            }

            if (ImageLibrary)
            {
                NoImageID = (string)ImageLibrary.Call("GetImage", "NONE");
                LoadingImageID = (string)ImageLibrary.Call("GetImage", "LOADING");
            }

            instance = this;
            if (!Settings.TOPSettings.UseTop) Unsubscribe(nameof(OnEntityDeath));
            if (!Settings.TOPSettings.UseTop) Unsubscribe(nameof(OnPlayerDisconnected));

            if (Settings.APISettings.ShopID == "UNDEFINED" || Settings.APISettings.SecretKey == "UNDEFINED")
            {
                LogAction(null, $"Verify that plugin is installed correct! Some of API settings are 'UNDEFINED'", true, true);
                return;
            }

            timer.Once(2, FetchShopUrl);

            timer.Every(1, () => Delays.RequestPerSecond = 0);

            ListTimeOutCommand[0] = new Dictionary<ulong, int>();
            ListTimeOutCommand[1] = new Dictionary<ulong, int>();
            ListTimeOutCommand[2] = new Dictionary<ulong, int>();

            int totalTick = 0;
            int tick = 0;
            timer.Repeat(2, 0, () =>
            {
                if (totalTick == 30)
                {
                    totalTick = 0;
                    ListBannedCommandUserID.Clear();
                }
                ListTimeOutCommand[0].Clear();
                if (tick == 3 || tick == 6)
                {
                    ListTimeOutCommand[1].Clear();
                }

                if (tick == 6)
                {
                    tick = 0;
                    ListTimeOutCommand[2].Clear();
                }
                tick++;
                totalTick++;
            });
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                Settings = Config.ReadObject<Configuration>();
                if (Settings?.APISettings == null) LoadDefaultConfig();
            }
            catch
            {
                LogAction(null, $"Error reading config, creating one new config!", true, true);
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig()
        {
            Settings = new Configuration();
        }

        protected override void SaveConfig() => Config.WriteObject(Settings);

        private void Unload()
        {
            foreach (var pl in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(pl, StoreLayer);
            }
        }

        #endregion

        #region Hooks

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            StatHandler.AddStat(new StatHandler.TimeStat(player));
        }

        #endregion

        #region Stats

        private static class StatHandler
        {
            internal class Stat
            {
                [JsonProperty("dataType")]
                public string DataType;
            }
            internal class KillStat : Stat
            {
                [JsonProperty("player_id")]
                public string PlayerUserId;
                [JsonProperty("victim_id")]
                public string VictimUserID;
                [JsonProperty("type")]
                public string Type;
                [JsonProperty("time")]
                public string Time;
            }
            internal class TimeStat : Stat
            {
                [JsonProperty("player_id")]
                public string PlayerID;
                [JsonProperty("username")]
                public string PlayerName;
                [JsonProperty("played")]
                public string Played;
                [JsonProperty("time")]
                public string Time;

                public TimeStat(BasePlayer player)
                {
                    PlayerID = player.UserIDString;
                    PlayerName = player.displayName;
                    DataType = "leave";
                    Played = player.secondsConnected.ToString();
                    Time = CurrentTime().ToString();
                }
            }

            private static List<Stat> Stats = new List<Stat>();
            public static void AddStat(Stat stat)
            {
                Stats.Add(stat);
                if (Stats.Count > 10)
                {
                    SendStats();
                    Stats.Clear();
                }
            }

            public static void SendStats()
            {
                try
                {


                    if (!Initialized)
                    {
                        instance.LogAction(null, $"Sending stats error! Plugin not initialized", true, true);
                        return;
                    }
                    if (Stats.Count == 0)
                    {
                        instance.LogAction(null, $"Nothing to send", true);
                        return;
                    }

                    var obj = JsonConvert.SerializeObject(Stats);
                    RequestPost($"&method=topData&data={obj}", (i, s) => {
                        if (i != 200)
                            return;

                        Dictionary<string, object> response = JsonConvert.DeserializeObject<Dictionary<string, object>>(s, new KeyValuesConverter());
                        if (response.ContainsKey("result") && response["result"].ToString() == "success")
                        {
                            instance.LogAction(null, $"GameStores sent stats successful!", true);
                            Stats.Clear();
                        }
                        else
                        {
                            instance.LogAction(null, $"Sending stats error!", true, true);
                        }
                    });


                }
                catch
                {
                    // ignored 
                }
            }
        }

        [ConsoleCommand("sendtop")]
        private void CmdSendTop(ConsoleSystem.Arg args)
        {
            if (args.Player() != null && !args.Player().IsAdmin) return;

            StatHandler.SendStats();
        }

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null || info == null || info.Initiator == null)
                return;
            if (Settings.TOPSettings.UseTop)
            {
                BaseEntity initiator = info.Initiator;

                if (entity as BasePlayer == null && initiator as BasePlayer == null)
                    return;
                StatHandler.KillStat stat = new StatHandler.KillStat();

                if (initiator as BasePlayer != null) stat.PlayerUserId = initiator.ToPlayer().UserIDString;
                else if (initiator.PrefabName.Contains("agents")) stat.PlayerUserId = "1";
                else return;

                if (entity as BasePlayer != null)
                {
                    stat.VictimUserID = entity.ToPlayer().UserIDString;
                    stat.Type = entity.ToPlayer().IsSleeping() ? "sleeper" : "kill";
                }
                else if (entity.PrefabName.Contains("agents"))
                {
                    stat.VictimUserID = "1";
                    stat.Type = "kill";
                }
                else
                {
                    return;
                }

                stat.DataType = "death";

                stat.Time = CurrentTime().ToString();
                StatHandler.AddStat(stat);
            }
        }

        #endregion

        #region Commands
        [ConsoleCommand("UI_GameStoresRUST")]
        private void CmdConsoleCommand(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (player == null) return;

            if (ListBannedCommandUserID.Contains(player.userID))
            {
                player.ChatMessage("Вы сделали слишком много запросов. Отдохните немного, скоро возможность выполнять действие к вам вернется.");
                return;
            }

            if (ListTimeOutCommand[0].ContainsKey(player.userID) == false)
                ListTimeOutCommand[0][player.userID] = 1;
            else
                ListTimeOutCommand[0][player.userID] = ListTimeOutCommand[0][player.userID] + 1;

            if (ListTimeOutCommand[1].ContainsKey(player.userID) == false)
                ListTimeOutCommand[1][player.userID] = 1;
            else
                ListTimeOutCommand[1][player.userID] = ListTimeOutCommand[1][player.userID] + 1;

            if (ListTimeOutCommand[2].ContainsKey(player.userID) == false)
                ListTimeOutCommand[2][player.userID] = 1;
            else
                ListTimeOutCommand[2][player.userID] = ListTimeOutCommand[2][player.userID] + 1;

            if (ListTimeOutCommand[0][player.userID] >= 10 || ListTimeOutCommand[1][player.userID] >= 20 || ListTimeOutCommand[2][player.userID] >= 30)
            {
                this.ListBannedCommandUserID.Add(player.userID);
            }

            switch (args.Args[0].ToLower())
            {
                case "page":
                    {
                        int page = 0;
                        if (!args.HasArgs(2) || !int.TryParse(args.Args[1], out page)) return;
                        InitializeStore(player, page, false);
                        break;
                    }
                case "take":
                    {
                       
                        if (!args.HasArgs(3)) return;

                        int index = 0, id = 0;
                        if (!int.TryParse(args.Args[1], out index) || !int.TryParse(args.Args[2], out id)) return;

                        if (!playersBasketCache.ContainsKey(player.userID))
                        {
                            player.ChatMessage("Предмет не найден, попробуйте перезапустить корзину");
                            return;
                        } else if (!playersBasketCache[player.userID].Contains(id))
                        {
                            player.ChatMessage("Предмет не найден, попробуйте перезапустить корзину");
                            return;
                        }
                                            
                        if (args.HasArgs(5) && args.Args[3].ToLower() == "blocked")
                        {
                            double left = 0;
                            if (!double.TryParse(args.Args[4], out left)) return;

                            TimeSpan span = TimeSpan.FromSeconds(left);

                            string text = "";
                            if (span.Days >= 1)
                                text += $"{span.Days} дн. ";
                            if (span.Hours >= 1)
                                text += $"{span.Hours} ч. ";
                            if (span.Minutes >= 1)
                                text += $"{span.Minutes} мин. ";
                            if (span.Seconds >= 1)
                                text += $"{span.Seconds} сек.";

                            ShowNotify(player, "Вы не можете забрать этот предмет из корзины!\n" +
                                               $"До его разблокировки осталось: {text}");
                            return;
                        }

                        ShowNotify(player, "Подождите, ваш запрос обрабатывается!");
                        CuiElementContainer container = new CuiElementContainer();

                        if (!Delays.CanRequest(player))
                        {
                            ShowNotify(player, "Подождите, ваш предыдущий запрос ещё обрабатывается!");
                            container.Add(new CuiButton
                            {
                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                Button = { Color = "1 1 1 0.2", Close = StoreLayer + ".BlockPanel." + index + ".Open", Command = $"UI_GameStoresRUST take {index} {id}" },
                                Text = { Text = "ПОДОЖДИТЕ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", Color = "1 1 1 0.4", FontSize = 14 }
                            }, StoreLayer + ".BlockPanel." + index, StoreLayer + ".BlockPanel." + index + ".Open");

                            CuiHelper.AddUi(player, container);
                            return;
                        }

                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                            Button = { FadeIn = 1f, Color = "1 1 1 0.2", Close = StoreLayer + ".BlockPanel." + index + ".Open", Command = $"UI_GameStoresRUST take {index} {id}", Material = "" },
                            Text = { Text = "ПОДОЖДИТЕ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", Color = "1 1 1 0.4", FontSize = 14 }
                        }, StoreLayer + ".BlockPanel." + index, StoreLayer + ".BlockPanel." + index + ".Open");
                        CuiHelper.AddUi(player, container);

                        LogAction(null, $"---------------------------------");
                        LogAction(player, $"Запрос на получение предмета: {id}");
                        Request($"&item=true&steam_id={player.UserIDString}&id={id}", (i, s) =>
                        {
                            switch (i)
                            {
                                case 0:
                                    LogAction(player, $"API не ответило на запрос: {id}");
                                    PrintError("Api does not responded to a request");
                                    if (player != null)
                                    {
                                        player.ChatMessage($"Непредвиденная ошибка со стороны сервера, просим прощения!");
                                        CuiHelper.DestroyUi(player, StoreLayer);
                                    }
                                    break;
                                case 200:
                                    Dictionary<string, object> response = JsonConvert.DeserializeObject<Dictionary<string, object>>(s, new KeyValuesConverter());
                                    if (!response.ContainsKey("data"))
                                    {
                                        LogAction(player, $"Ошибка получения товара, отсутствует Data [{id}]");

                                        container.Clear();
                                        CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel." + index + ".Open");
                                        container.Add(new CuiButton
                                        {
                                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                            Button = { FadeIn = 1f, Color = "1 0.5 0.5 0.2", Close = StoreLayer + ".BlockPanel." + index + ".Open", Command = $"UI_GameStoresRUST take {index} {id}", Material = "" },
                                            Text = { Text = "ОШИБКА\nПОЛУЧЕНИЯ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", Color = "1 0.7 0.7 1", FontSize = 24 }
                                        }, StoreLayer + ".BlockPanel." + index, StoreLayer + ".BlockPanel." + index + ".Open");
                                        ShowNotify(player, "Произошла непредвиденная ошибка, попробуйте позже!\n" +
                                                           "Ваш предмет в безопасности, не переживайте!");
                                        CuiHelper.AddUi(player, container);
                                        return;
                                    }

                                    LogAction(player, $"Товар отмечен полученным [{id}]");
                                    Request($"&gived=true&id={id}", (code, newResponse) =>
                                    {
                                        if (code != 200 || JsonConvert.DeserializeObject<JObject>(newResponse)["result"].ToString() != "success")
                                        {
                                            container.Clear();
                                            CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel." + index + ".Open");
                                            container.Add(new CuiButton
                                            {
                                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                                Button = { FadeIn = 1f, Color = "1 0.5 0.5 0.2", Close = StoreLayer + ".BlockPanel." + index + ".Open", Command = $"UI_GameStoresRUST take {index} {id}", Material = "" },
                                                Text = { Text = "ОШИБКА\nПОЛУЧЕНИЯ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", Color = "1 0.7 0.7 1", FontSize = 24 }
                                            }, StoreLayer + ".BlockPanel." + index, StoreLayer + ".BlockPanel." + index + ".Open");
                                            ShowNotify(player, "Произошла непредвиденная ошибка, попробуйте позже!\n" +
                                                               "Ваш предмет в безопасности, не переживайте!");
                                            CuiHelper.AddUi(player, container);
                                            return;
                                        }
                                        ProcessTake(player, response["data"] as Dictionary<string, object>);
                                    }, player);

                                    container.Clear();
                                    CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel." + index + ".Open");
                                    container.Add(new CuiButton
                                    {
                                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                        Button = { FadeIn = 1f, Color = "0.5 1 0.5 0.2", Material = "" },
                                        Text = { Text = "УСПЕШНО\nПОЛУЧЕНО", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", Color = "0.7 1 0.7 1", FontSize = 14 }
                                    }, StoreLayer + ".BlockPanel." + index, StoreLayer + ".BlockPanel." + index + ".Open");

                                    if (playersBasketCache.ContainsKey(player.userID) && playersBasketCache[player.userID].Contains(id))
                                        playersBasketCache[player.userID].RemoveAt(playersBasketCache[player.userID].IndexOf(id));

                                    CuiHelper.AddUi(player, container);
                                    break;
                                case 404:
                                    LogAction(player, $"Сайт не ответил на запрос: {id}");
                                    player.ChatMessage($"Непредвиденная ошибка со стороны сервера, просим прощения!");
                                    CuiHelper.DestroyUi(player, StoreLayer);
                                    LogAction(null, "Response code: 404, please check your configurations", true);
                                    break;
                            }
                        }, player);
                        break;
                    }
            }
        }

        #endregion

        #region Interface

        private static string StoreLayer = "UI_GameStoresRUST_Store";
        private void InitializeStore(BasePlayer player, int page, bool first = true)
        {
            CuiElementContainer container = new CuiElementContainer();

            if (first)
            {
                CuiHelper.DestroyUi(player, StoreLayer);
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0.289 0", AnchorMax = "0.945 1", OffsetMax = "0 0" },
                    Image = { Color = "0.117 0.121 0.109 0.95" }
                }, "Menu_UI", StoreLayer);

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.04 0.84", AnchorMax = "0.96 0.97", OffsetMax = "0 0" },
                    Text = { Text = $"<size=25><b>Корзина сервера</b></size>\nЭто ваша корзина с покупками, вы можете забрать их в любой момент.", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 12, Font = "robotocondensed-regular.ttf" }
                }, StoreLayer);
            }

            CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel");
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.9", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0" }
            }, StoreLayer, StoreLayer + ".BlockPanel");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1.1", OffsetMax = "0 0" },
                Text = { Text = "Подождите, мы обрабатываем ваш запрос...", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 20 }
            }, StoreLayer + ".BlockPanel", StoreLayer + ".BlockPanel.Text");

            CuiHelper.AddUi(player, container);
            
            Request($"&method=basket&steam_id={player.UserIDString}", (code, response) =>
            {
               
                switch (code)
                {
                    default:
                        {
                            CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel.Text");
                            CuiElementContainer secondContainer = new CuiElementContainer();
                            secondContainer.Add(new CuiLabel
                            {
                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                Text = { Text = "Корзина временно недоступна, попробуйте позже", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 38 }
                            }, StoreLayer + ".BlockPanel", StoreLayer + ".BlockPanel.Text");
                            CuiHelper.AddUi(player, secondContainer);
                            break;
                        }
                    case 200:
                        {
                            var firstInfo = JsonConvert.DeserializeObject<Dictionary<string, object>>(response, new KeyValuesConverter());
                            if (firstInfo.ContainsKey("result"))
                            {
                                if (firstInfo["result"].ToString() == "fail")
                                {
                                    if (firstInfo["code"].ToString() == "104")
                                    {
                                        CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel.Text");
                                        CuiElementContainer secondContainer = new CuiElementContainer();
                                        secondContainer.Add(new CuiLabel
                                        {
                                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                            Text = { Text = "Ваша корзина пуста", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 34 }
                                        }, StoreLayer + ".BlockPanel", StoreLayer + ".BlockPanel.Text");
                                        CuiHelper.AddUi(player, secondContainer);
                                    }
                                    if (firstInfo["code"].ToString() == "105")
                                    {
                                        CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel.Text");
                                        CuiElementContainer secondContainer = new CuiElementContainer();
                                        secondContainer.Add(new CuiLabel
                                        {
                                            RectTransform = { AnchorMin = "0 0.1", AnchorMax = "1 1", OffsetMax = "0 0" },
                                            Text = { Text = "Вы не авторизованы в магазине!\n" +
                                                        "Ссылку на авторизацию вы можете найти в разделе 'помощь'", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 34 }
                                        }, StoreLayer + ".BlockPanel", StoreLayer + ".BlockPanel.Text");
                                        CuiHelper.AddUi(player, secondContainer);
                                    }
                                }
                                else
                                {
                                    CuiElementContainer secondContainer = new CuiElementContainer();

                                    if (!(firstInfo["data"] is List<object>))
                                    {
                                        PrintError("Unkown error #1");
                                        CuiHelper.DestroyUi(player, StoreLayer);
                                        return;
                                    }
                                    List<object> data = firstInfo["data"] as List<object>;
                                    List<WItem> wItems = new List<WItem>();

                                    foreach (var check in data.Skip(page * Settings.InterfaceSettings.ItemOnString * Settings.InterfaceSettings.StringAmount).Take(Settings.InterfaceSettings.ItemOnString * Settings.InterfaceSettings.StringAmount))
                                    {
                                        wItems.Add(new WItem(check as Dictionary<string, object>));

                                    }
                                    if (playersBasketCache.ContainsKey(player.userID))
                                        playersBasketCache[player.userID].Clear();

                                    foreach (Dictionary<string, object> product in data)
                                    {
                                        if (product.ContainsKey("id"))
                                        {
                                            if (!playersBasketCache.ContainsKey(player.userID))
                                                playersBasketCache.Add(player.userID, new List<int>());

                                            playersBasketCache[player.userID].Add(Convert.ToInt32(product["id"]));
                                        }
                                            
                                    }
                                    secondContainer.Add(new CuiLabel
                                    {
                                        RectTransform = { AnchorMin = "0 0.02", AnchorMax = "1 0.13", OffsetMax = "0 0" },
                                        Text = { Text = (page + 1).ToString(), Align = TextAnchor.MiddleCenter, FontSize = 34 }
                                    }, StoreLayer + ".BlockPanel");

                                    secondContainer.Add(new CuiButton
                                    {
                                        RectTransform = { AnchorMin = "0.37 0.02", AnchorMax = "0.47 0.13", OffsetMax = "0 0" },
                                        Button = { Color = "0 0 0 0", Material = "", Command = page > 0 ? $"UI_GameStoresRUST page {page - 1}" : "" },
                                        Text = { Text = "<", Color = page > 0 ? "1 1 1 1" : "1 1 1 0.2", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 35 }
                                    }, StoreLayer + ".BlockPanel");

                                    secondContainer.Add(new CuiButton
                                    {
                                        RectTransform = { AnchorMin = "0.53 0.02", AnchorMax = "0.63 0.13", OffsetMax = "0 0" },
                                        Button = { Color = "0 0 0 0", Material = "", Command = (page + 1) * Settings.InterfaceSettings.ItemOnString * Settings.InterfaceSettings.StringAmount < data.Count ? $"UI_GameStoresRUST page {page + 1}" : "" },
                                        Text = { Text = ">", Color = (page + 1) * Settings.InterfaceSettings.ItemOnString * Settings.InterfaceSettings.StringAmount < data.Count ? "1 1 1 1" : "1 1 1 0.2", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 35 }
                                    }, StoreLayer + ".BlockPanel");


                                    double xSwitch = 0;
                                    double ySwitch = 0;
                                    for (int i = 0; i < Settings.InterfaceSettings.ItemOnString * Settings.InterfaceSettings.StringAmount; i++)
                                    {
                                        UI_RecountPosition(ref xSwitch, ref ySwitch, i, Settings.InterfaceSettings.ItemOnString * Settings.InterfaceSettings.StringAmount);

                                        secondContainer.Add(new CuiButton
                                        {
                                            RectTransform = { AnchorMin = "0.495 0.55", AnchorMax = "0.495 0.55", OffsetMin = $"{xSwitch} {ySwitch - Settings.InterfaceSettings.ItemSide}", OffsetMax = $"{xSwitch + Settings.InterfaceSettings.ItemSide} {ySwitch}" },
                                            Button = { Color = "1 1 1 0.1", Command = $"" },
                                            Text = { Text = "" }
                                        }, StoreLayer + ".BlockPanel", StoreLayer + $".BlockPanel.{i}");
                                    }

                                    foreach (var check in wItems.Select((i, t) => new { A = i, B = t }))
                                    {
                                        if (check.A.IsBlueprint)
                                        {
                                            if (plugins.Find("ImageLibrary") != null)
                                            {
                                                secondContainer.Add(new CuiElement
                                                {
                                                    Parent = StoreLayer + ".BlockPanel." + check.B,
                                                    Components =
                                                {
                                                    new CuiRawImageComponent { Png = (string) plugins.Find("ImageLibrary").Call("GetImage", "blueprintbase") },
                                                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                                                }
                                                });
                                            }
                                            else
                                            {
                                                secondContainer.Add(new CuiElement
                                                {
                                                    Parent = StoreLayer + ".BlockPanel." + check.B,
                                                    Components =
                                                {
                                                    new CuiRawImageComponent { Url = "https://gamestores.ru/img/games/rust/blueprintbase.png" },
                                                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                                                }
                                                });
                                            }
                                        }
                                        if (!check.A.ImageUrl.Contains("http"))
                                        {
                                            secondContainer.Add(new CuiElement
                                            {
                                                Parent = StoreLayer + ".BlockPanel." + check.B,
                                                Components =
                                            {
                                                new CuiRawImageComponent { Png = check.A.ImageUrl },
                                                new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                                            }
                                            });
                                        }
                                        else
                                        {
                                            secondContainer.Add(new CuiElement
                                            {
                                                Parent = StoreLayer + ".BlockPanel." + check.B,
                                                Components =
                                            {
                                                new CuiRawImageComponent { Url = check.A.ImageUrl },
                                                new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                                            }
                                            });
                                        }

                                        if (check.A.Amount > 1)
                                        {
                                            secondContainer.Add(new CuiLabel
                                            {
                                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 5", OffsetMax = "-5 0" },
                                                Text = { Text = "x" + check.A.Amount, Color = "1 1 1 0.5", Align = TextAnchor.LowerRight, Font = "robotocondensed-regular.ttf", FontSize = 12 }
                                            }, StoreLayer + ".BlockPanel." + check.B);
                                        }

                                        if (check.A.Blocked)
                                        {
                                            double left = check.A.Block_Date - CurrentTime();

                                            secondContainer.Add(new CuiButton
                                            {
                                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                                Button = { Color = "1 0.5 0.5 0.2", Command = $"UI_GameStoresRUST take {check.B} {check.A.ID} blocked {left}" },
                                                Text = { Text = "", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 38 }
                                            }, StoreLayer + ".BlockPanel." + check.B, StoreLayer + ".BlockPanel." + check.B + ".Open");
                                        }
                                        else
                                        {
                                            secondContainer.Add(new CuiButton
                                            {
                                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                                Button = { Color = "0 0 0 0", Close = StoreLayer + ".BlockPanel." + check.B + ".Open", Command = $"UI_GameStoresRUST take {check.B} {check.A.ID}" },
                                                Text = { Text = "" }
                                            }, StoreLayer + ".BlockPanel." + check.B, StoreLayer + ".BlockPanel." + check.B + ".Open");
                                        }
                                    }

                                    CuiHelper.AddUi(player, secondContainer);
                                    CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel.Text");
                                }
                            }
                            break;
                        }
                }
            }, player);
        }
        #endregion

        #region Utils

        private void ShowNotify(BasePlayer player, string text)
        {
            CuiHelper.DestroyUi(player, StoreLayer + ".Notify");
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1.1", OffsetMax = "0 0" },
                Text = { FadeIn = 1f, Text = text, Align = TextAnchor.UpperCenter, Font = "robotocondensed-regular.ttf", FontSize = 16 }
            }, StoreLayer, StoreLayer + ".Notify");

            CuiHelper.AddUi(player, container);
        }

        private void ProcessTake(BasePlayer player, Dictionary<string, object> obj)
        {
            //foreach (var check in obj)
            //   PrintError(check.Key + " -> " + check.Value); 
            LogAction(player, $"Начало обработки товара");
            WItem itemInfo = new WItem(obj);
            try
            {
                if (itemInfo.IsItem)
                {
                    LogAction(player, $"Попытка получения предмета: {itemInfo.ShortName} [{itemInfo.Amount}]");
                    var info = ItemManager.FindItemDefinition(itemInfo.ShortName);
                    if (info == null) return;

                    var item = ItemManager.Create(info, itemInfo.Amount);
                    if (!player.inventory.GiveItem(item))
                    {
                        LogAction(player, $"У игрока не было места для получения предмета, предмет выброшен {itemInfo.ShortName} [{itemInfo.Amount} {player.transform.position}]");

                        item.Drop(player.transform.position, Vector3.down * 3);
                        ShowNotify(player, $"Вы успешно получили предмет  › <size=20><color=#ee3e61>{info.displayName.english}</color></size> ‹\n" +
                                           $"У вас недостаточно места в инвентаре, <b>предмет брошен</b> под ноги!");
                    }
                    else
                    {
                        LogAction(player, $"Предмет выдан игроку в инвентарь");
                        ShowNotify(player, $"Вы успешно получили предмет  › <size=20><color=#ee3e61>{info.displayName.english}</color></size> ‹");
                    }
                }

                if (itemInfo.IsCommand)
                {
                    LogAction(player, $"Попытка получения команды");

                    string command = itemInfo.Command.Replace("\n", "|").Replace("%steamid%", player.UserIDString, StringComparison.OrdinalIgnoreCase).Replace("%username%", player.displayName, StringComparison.OrdinalIgnoreCase);
                    foreach (var check in command.Split('|'))
                    {
                        LogAction(player, $"Исполнение команды: {check}");
                        Server.Command(check);
                    }


                    ShowNotify(player, $"Вы успешно получили предмет  › <size=20><color=#ee3e61>{itemInfo.Name}</color></size> ‹\n" +
                                       $"Теперь вам доступны новые привилегии!");
                }

                if (itemInfo.IsBlueprint)
                {
                    LogAction(player, $"Попытка получения рецепта {itemInfo.ShortName}");
                    Item create = ItemManager.CreateByItemID(-996920608);

                    var info = ItemManager.FindItemDefinition(itemInfo.ShortName);
                    create.blueprintTarget = info.itemid;

                    if (!player.inventory.GiveItem(create))
                    {
                        create.Drop(player.transform.position, Vector3.down * 3);
                        ShowNotify(player, $"Вы успешно получили рецепт предмета  › <size=20><color=#ee3e61>{info.displayName.english}</color></size> ‹\n" +
                                           $"У вас недостаточно места в инвентаре, <b>предмет брошен</b> под ноги!");
                    }
                    else
                    {
                        LogAction(player, $"У игрока не было места для получения рецепта, рецепт выброшен {itemInfo.ShortName} [{itemInfo.Amount} {player.transform.position}]");

                        LogAction(player, $"Рецепт выдан игроку в инвентарь");
                        LogAction(player, $"Вы успешно получили рецепт предмета  › <size=20><color=#ee3e61>{info.displayName.english}</color></size> ‹");
                    }
                }
            } catch (Exception e)
            {
                LogAction(player, $"Ошибка получения товара [{itemInfo.ID}][{itemInfo.Name}]");
                LogToFile("!Errors", $"{DateTime.Now.ToShortTimeString()}| Error: '{e.ToString()}'", this);
                PrintError($"Error receiving product [{itemInfo.ID}], info saved to log");
            }
            
        }

        private static readonly Dictionary<int, string> IDToShortName = new Dictionary<int, string> { [-1461508848] = "rifle.ak", [2115555558] = "ammo.handmade.shell", [-533875561] = "ammo.pistol", [1621541165] = "ammo.pistol.fire", [-422893115] = "ammo.pistol.hv", [815896488] = "ammo.rifle", [805088543] = "ammo.rifle.explosive", [449771810] = "ammo.rifle.incendiary", [1152393492] = "ammo.rifle.hv", [1578894260] = "ammo.rocket.basic", [1436532208] = "ammo.rocket.fire", [542276424] = "ammo.rocket.hv", [1594947829] = "ammo.rocket.smoke", [-1035059994] = "ammo.shotgun", [1818890814] = "ammo.shotgun.fire", [1819281075] = "ammo.shotgun.slug", [1685058759] = "antiradpills", [93029210] = "apple", [-1565095136] = "apple.spoiled", [-1775362679] = "arrow.bone", [-1775249157] = "arrow.fire", [-1280058093] = "arrow.hv", [-420273765] = "arrow.wooden", [563023711] = "autoturret", [790921853] = "axe.salvaged", [-337261910] = "bandage", [498312426] = "barricade.concrete", [504904386] = "barricade.metal", [-1221200300] = "barricade.sandbags", [510887968] = "barricade.stone", [-814689390] = "barricade.wood", [1024486167] = "barricade.woodwire", [2021568998] = "battery.small", [97329] = "bbq", [1046072789] = "trap.bear", [97409] = "bed", [-1480119738] = "tool.binoculars", [1611480185] = "black.raspberries", [-1386464949] = "bleach", [93832698] = "blood", [-1063412582] = "blueberries", [-1887162396] = "blueprintbase", [-55660037] = "rifle.bolt", [919780768] = "bone.club", [-365801095] = "bone.fragments", [68998734] = "botabag", [-853695669] = "bow.hunting", [271534758] = "box.wooden.large", [-770311783] = "box.wooden", [-1192532973] = "bucket.water", [-307490664] = "building.planner", [707427396] = "burlap.shirt", [707432758] = "burlap.shoes", [-2079677721] = "cactusflesh", [-1342405573] = "tool.camera", [-139769801] = "campfire", [-1043746011] = "can.beans", [2080339268] = "can.beans.empty", [-171664558] = "can.tuna", [1050986417] = "can.tuna.empty", [-1693683664] = "candycaneclub", [523409530] = "candycane", [1300054961] = "cctv.camera", [-2095387015] = "ceilinglight", [1428021640] = "chainsaw", [94623429] = "chair", [1436001773] = "charcoal", [1711323399] = "chicken.burned", [1734319168] = "chicken.cooked", [-1658459025] = "chicken.raw", [-726947205] = "chicken.spoiled", [-341443994] = "chocholate", [1540879296] = "xmasdoorwreath", [94756378] = "cloth", [3059095] = "coal", [3059624] = "corn", [2045107609] = "clone.corn", [583366917] = "seed.corn", [2123300234] = "crossbow", [1983936587] = "crude.oil", [1257201758] = "cupboard.tool", [-1144743963] = "diving.fins", [-1144542967] = "diving.mask", [-1144334585] = "diving.tank", [1066729526] = "diving.wetsuit", [-1598790097] = "door.double.hinged.metal", [-933236257] = "door.double.hinged.toptier", [-1575287163] = "door.double.hinged.wood", [-2104481870] = "door.hinged.metal", [-1571725662] = "door.hinged.toptier", [1456441506] = "door.hinged.wood", [1200628767] = "door.key", [-778796102] = "door.closer", [1526866730] = "xmas.door.garland", [1925723260] = "dropbox", [1891056868] = "ducttape", [1295154089] = "explosive.satchel", [498591726] = "explosive.timed", [1755466030] = "explosives", [726730162] = "facialhair.style01", [-1034048911] = "fat.animal", [252529905] = "femalearmpithair.style01", [471582113] = "femaleeyebrow.style01", [-1138648591] = "femalepubichair.style01", [305916740] = "female_hairstyle_01", [305916742] = "female_hairstyle_03", [305916744] = "female_hairstyle_05", [1908328648] = "fireplace.stone", [-2078972355] = "fish.cooked", [-533484654] = "fish.raw", [1571660245] = "fishingrod.handmade", [1045869440] = "flamethrower", [1985408483] = "flameturret", [97513422] = "flare", [1496470781] = "flashlight.held", [1229879204] = "weapon.mod.flashlight", [-1722829188] = "floor.grill", [1849912854] = "floor.ladder.hatch", [-1266285051] = "fridge", [-1749787215] = "boots.frog", [28178745] = "lowgradefuel", [-505639592] = "furnace", [1598149413] = "furnace.large", [-1779401418] = "gates.external.high.stone", [-57285700] = "gates.external.high.wood", [98228420] = "gears", [1422845239] = "geiger.counter", [277631078] = "generator.wind.scrap", [115739308] = "burlap.gloves", [-522149009] = "gloweyes", [3175989] = "glue", [718197703] = "granolabar", [384204160] = "grenade.beancan", [-1308622549] = "grenade.f1", [-217113639] = "fun.guitar", [-1580059655] = "gunpowder", [-1832205789] = "male_hairstyle_01", [305916741] = "female_hairstyle_02", [936777834] = "attire.hide.helterneck", [-1224598842] = "hammer", [-1976561211] = "hammer.salvaged", [-1406876421] = "hat.beenie", [-1397343301] = "hat.boonie", [1260209393] = "bucket.helmet", [-1035315940] = "burlap.headwrap", [-1381682752] = "hat.candle", [696727039] = "hat.cap", [-2128719593] = "coffeecan.helmet", [-1178289187] = "deer.skull.mask", [1351172108] = "heavy.plate.helmet", [-450738836] = "hat.miner", [-966287254] = "attire.reindeer.headband", [340009023] = "riot.helmet", [124310981] = "hat.wolf", [1501403549] = "wood.armor.helmet", [698310895] = "hatchet", [523855532] = "hazmatsuit", [2045246801] = "clone.hemp", [583506109] = "seed.hemp", [-148163128] = "attire.hide.boots", [-132588262] = "attire.hide.skirt", [-1666761111] = "attire.hide.vest", [-465236267] = "weapon.mod.holosight", [-1211618504] = "hoodie", [2133577942] = "hq.metal.ore", [-1014825244] = "humanmeat.burned", [-991829475] = "humanmeat.cooked", [-642008142] = "humanmeat.raw", [661790782] = "humanmeat.spoiled", [-1440143841] = "icepick.salvaged", [569119686] = "bone.armor.suit", [1404466285] = "heavy.plate.jacket", [-1616887133] = "jacket.snow", [-1167640370] = "jacket", [-1284735799] = "jackolantern.angry", [-1278649848] = "jackolantern.happy", [776005741] = "knife.bone", [108061910] = "ladder.wooden.wall", [255101535] = "trap.landmine", [-51678842] = "lantern", [-789202811] = "largemedkit", [516382256] = "weapon.mod.lasersight", [50834473] = "leather", [-975723312] = "lock.code", [1908195100] = "lock.key", [-1097452776] = "locker", [146685185] = "longsword", [-1716193401] = "rifle.lr300", [193190034] = "lmg.m249", [371156815] = "pistol.m92", [3343606] = "mace", [825308669] = "machete", [830965940] = "mailbox", [1662628660] = "male.facialhair.style02", [1662628661] = "male.facialhair.style03", [1662628662] = "male.facialhair.style04", [-1832205788] = "male_hairstyle_02", [-1832205786] = "male_hairstyle_04", [1625090418] = "malearmpithair.style01", [-1269800768] = "maleeyebrow.style01", [429648208] = "malepubichair.style01", [-1832205787] = "male_hairstyle_03", [-1832205785] = "male_hairstyle_05", [107868] = "map", [997973965] = "mask.balaclava", [-46188931] = "mask.bandana", [-46848560] = "metal.facemask", [-2066726403] = "bearmeat.burned", [-2043730634] = "bearmeat.cooked", [1325935999] = "bearmeat", [-225234813] = "deermeat.burned", [-202239044] = "deermeat.cooked", [-322501005] = "deermeat.raw", [-1851058636] = "horsemeat.burned", [-1828062867] = "horsemeat.cooked", [-1966381470] = "horsemeat.raw", [968732481] = "meat.pork.burned", [991728250] = "meat.pork.cooked", [-253819519] = "meat.boar", [-1714986849] = "wolfmeat.burned", [-1691991080] = "wolfmeat.cooked", [179448791] = "wolfmeat.raw", [431617507] = "wolfmeat.spoiled", [688032252] = "metal.fragments", [-1059362949] = "metal.ore", [1265861812] = "metal.plate.torso", [374890416] = "metal.refined", [1567404401] = "metalblade", [-1057402571] = "metalpipe", [-758925787] = "mining.pumpjack", [-1411620422] = "mining.quarry", [88869913] = "fish.minnows", [-2094080303] = "smg.mp5", [843418712] = "mushroom", [-1569356508] = "weapon.mod.muzzleboost", [-1569280852] = "weapon.mod.muzzlebrake", [449769971] = "pistol.nailgun", [590532217] = "ammo.nailgun.nails", [3387378] = "note", [1767561705] = "burlap.trousers", [106433500] = "pants", [-1334615971] = "heavy.plate.pants", [-135651869] = "attire.hide.pants", [-1595790889] = "roadsign.kilt", [-459156023] = "pants.shorts", [106434956] = "paper", [-578028723] = "pickaxe", [-586116979] = "jar.pickle", [-1379225193] = "pistol.eoka", [-930579334] = "pistol.revolver", [548699316] = "pistol.semiauto", [142147109] = "planter.large", [148953073] = "planter.small", [102672084] = "attire.hide.poncho", [640562379] = "pookie.bear", [-1732316031] = "xmas.present.large", [-2130280721] = "xmas.present.medium", [-1725510067] = "xmas.present.small", [1974032895] = "propanetank", [-225085592] = "pumpkin", [509654999] = "clone.pumpkin", [466113771] = "seed.pumpkin", [2033918259] = "pistol.python", [2069925558] = "target.reactive", [-1026117678] = "box.repair.bench", [1987447227] = "research.table", [540154065] = "researchpaper", [1939428458] = "riflebody", [-288010497] = "roadsign.jacket", [-847065290] = "roadsigns", [3506021] = "rock", [649603450] = "rocket.launcher", [3506418] = "rope", [569935070] = "rug.bear", [113284] = "rug", [1916127949] = "water.salt", [-1775234707] = "salvaged.cleaver", [-388967316] = "salvaged.sword", [2007564590] = "santahat", [-1705696613] = "scarecrow", [670655301] = "hazmatsuit_scientist", [1148128486] = "hazmatsuit_scientist_peacekeeper", [-141135377] = "weapon.mod.small.scope", [109266897] = "scrap", [-527558546] = "searchlight", [-1745053053] = "rifle.semiauto", [1223860752] = "semibody", [-419069863] = "sewingkit", [-1617374968] = "sheetmetal", [2057749608] = "shelves", [24576628] = "shirt.collared", [-1659202509] = "shirt.tanktop", [2107229499] = "shoes.boots", [191795897] = "shotgun.double", [-1009492144] = "shotgun.pump", [2077983581] = "shotgun.waterpipe", [378365037] = "guntrap", [-529054135] = "shutter.metal.embrasure.a", [-529054134] = "shutter.metal.embrasure.b", [486166145] = "shutter.wood.a", [1628490888] = "sign.hanging.banner.large", [1498516223] = "sign.hanging", [-632459882] = "sign.hanging.ornate", [-626812403] = "sign.pictureframe.landscape", [385802761] = "sign.pictureframe.portrait", [2117976603] = "sign.pictureframe.tall", [1338515426] = "sign.pictureframe.xl", [-1455694274] = "sign.pictureframe.xxl", [1579245182] = "sign.pole.banner.large", [-587434450] = "sign.post.double", [-163742043] = "sign.post.single", [-1224714193] = "sign.post.town", [644359987] = "sign.post.town.roof", [-1962514734] = "sign.wooden.huge", [-705305612] = "sign.wooden.large", [-357728804] = "sign.wooden.medium", [-698499648] = "sign.wooden.small", [1213686767] = "weapon.mod.silencer", [386382445] = "weapon.mod.simplesight", [1859976884] = "skull_fire_pit", [960793436] = "skull.human", [1001265731] = "skull.wolf", [1253290621] = "sleepingbag", [470729623] = "small.oil.refinery", [1051155022] = "stash.small", [865679437] = "fish.troutsmall", [927253046] = "smallwaterbottle", [109552593] = "smg.2", [-2092529553] = "smgbody", [691633666] = "snowball", [-2055888649] = "snowman", [621575320] = "shotgun.spas12", [-2118132208] = "spear.stone", [-1127699509] = "spear.wooden", [-685265909] = "spikes.floor", [552706886] = "spinner.wheel", [1835797460] = "metalspring", [-892259869] = "sticks", [-1623330855] = "stocking.large", [-1616524891] = "stocking.small", [789892804] = "stone.pickaxe", [-1289478934] = "stonehatchet", [-892070738] = "stones", [-891243783] = "sulfur", [889398893] = "sulfur.ore", [-1625468793] = "supply.signal", [1293049486] = "surveycharge", [1369769822] = "fishtrap.small", [586484018] = "syringe.medical", [110115790] = "table", [1490499512] = "targeting.computer", [3552619] = "tarp", [1471284746] = "techparts", [456448245] = "smg.thompson", [110547964] = "torch", [1588977225] = "xmas.decoration.baubels", [918540912] = "xmas.decoration.candycanes", [-471874147] = "xmas.decoration.gingerbreadmen", [205978836] = "xmas.decoration.lights", [-1044400758] = "xmas.decoration.pinecone", [-2073307447] = "xmas.decoration.star", [435230680] = "xmas.decoration.tinsel", [-864578046] = "tshirt", [1660607208] = "tshirt.long", [260214178] = "tunalight", [-1847536522] = "vending.machine", [-496055048] = "wall.external.high.stone", [-1792066367] = "wall.external.high", [562888306] = "wall.frame.cell.gate", [-427925529] = "wall.frame.cell", [995306285] = "wall.frame.fence.gate", [-378017204] = "wall.frame.fence", [447918618] = "wall.frame.garagedoor", [313836902] = "wall.frame.netting", [1175970190] = "wall.frame.shopfront", [525244071] = "wall.frame.shopfront.metal", [-1021702157] = "wall.window.bars.metal", [-402507101] = "wall.window.bars.toptier", [-1556671423] = "wall.window.bars.wood", [61936445] = "wall.window.glass.reinforced", [112903447] = "water", [1817873886] = "water.catcher.large", [1824679850] = "water.catcher.small", [-1628526499] = "water.barrel", [547302405] = "waterjug", [1840561315] = "water.purifier", [-460592212] = "xmas.window.garland", [3655341] = "wood", [1554697726] = "wood.armor.jacket", [-1883959124] = "wood.armor.pants", [-481416622] = "workbench1", [-481416621] = "workbench2", [-481416620] = "workbench3", [-1151126752] = "xmas.lightstring", [-1926458555] = "xmas.tree" };

        private void UI_RecountPosition(ref double xSwitch, ref double ySwitch, int count, int max)
        {
            var stringAmount = Math.Ceiling((double)max / Settings.InterfaceSettings.ItemOnString);
            var currentString = Math.Floor((double)count / Settings.InterfaceSettings.ItemOnString);
            var currentPosition = count % Settings.InterfaceSettings.ItemOnString;


            var topYPosition = 0 + (float)stringAmount / 2 * Settings.InterfaceSettings.ItemSide + ((float)stringAmount / 2 - 1) * Settings.InterfaceSettings.ItemMargin;
            var topXPosition = 0 - (float)Settings.InterfaceSettings.ItemOnString / 2 * Settings.InterfaceSettings.ItemSide - ((float)Settings.InterfaceSettings.ItemOnString / 2 - 1) * Settings.InterfaceSettings.ItemMargin;

            var curYPosition = topYPosition - currentString * Settings.InterfaceSettings.ItemSide - (currentString) * (Settings.InterfaceSettings.ItemMargin + (false ? 20 : 0));
            var curXPosition = topXPosition + currentPosition * Settings.InterfaceSettings.ItemSide + (currentPosition) * Settings.InterfaceSettings.ItemMargin;

            xSwitch = curXPosition;
            ySwitch = curYPosition;
        }

        public static bool CheckInstantWork = false;
        public Timer CheckInstantWorkGlobalTimer = null;

        private void CheckInstant()
        {
            if (CheckInstantWork == true)
                return;

            CheckInstantWork = true;
            if (CheckInstantWorkGlobalTimer != null)
                CheckInstantWorkGlobalTimer.Destroy();

            CheckInstantWorkGlobalTimer = timer.Once(300, () => { CheckInstantWork = false; });

            Request($"&method=basket.commands.instant", (code, response) =>
            {
                switch (code)
                {
                    case 0:
                        {
                            LogAction(null, $"Ошибка выполнения запроса для выдачи автоматических команд");
                            CheckInstantWork = false;
                            break;
                        }
                    case 200:
                        {
                            var firstInfo = JsonConvert.DeserializeObject<Dictionary<string, object>>(response, new KeyValuesConverter());
                            if (firstInfo.ContainsKey("result"))
                            {
                                if (firstInfo["result"].ToString() == "success")
                                {
                                    List<object> data = firstInfo["data"] as List<object>;
                                    int i = 1;
                                    timer.Once(data.Count + 2, () => { CheckInstantWork = false; });

                                    foreach (Dictionary<string, object> product in data)
                                    {
                                        if (product.ContainsKey("id"))
                                        {
                                            timer.Once(i, () => { TakeInstant(Convert.ToInt32(product["id"]), product["steam_id"].ToString()); } );                                             
                                            i++;
                                        }

                                    }                                  
                                } else CheckInstantWork = false;
                            } else CheckInstantWork = false;
                            break;
                        }
                    default:
                        {
                            LogAction(null, $"Ошибка выполнения запроса для выдачи автоматических команд");
                            CheckInstantWork = false;
                            break;
                        }
                }
            }, null); 
        }

        private void TakeInstant(int GsProductId, string SteamId)
        {
            LogAction(null, $"---------------------------------");
            LogAction(null, $"[AutoCommands] Запрос на получение товара [{GsProductId}][{SteamId}]");
            Request($"&item=true&id={GsProductId}", (i, s) =>
            {
                switch (i)
                {
                    case 0:
                        LogAction(null, $"[AutoCommands] API не ответило на запрос: {GsProductId}");
                        PrintError("Api does not responded to a request");
                        break;
                    case 200:
                        Dictionary<string, object> response = JsonConvert.DeserializeObject<Dictionary<string, object>>(s, new KeyValuesConverter());
                        if (!response.ContainsKey("data"))
                        {
                            LogAction(null, $"[AutoCommands] Ошибка получения товара, отсутствует Data [{GsProductId}]");
                            return;
                        } else
                        {
                            Request($"&gived=true&id={GsProductId}", (code, newResponse) =>
                            {
                                if (code != 200 || JsonConvert.DeserializeObject<JObject>(newResponse)["result"].ToString() != "success")
                                {
                                    LogAction(null, $"[AutoCommands] Ошибка получения товара [{GsProductId}][{SteamId}]");
                                    return;
                                }
                                else
                                {
                                    WItem itemInfo = new WItem(response["data"] as Dictionary<string, object>);
                                    if (itemInfo.IsCommand)
                                    {
                                        LogAction(null, $"[AutoCommands] Товар отмечен полученным [{GsProductId}][{SteamId}]");
                                        string command = itemInfo.Command.Replace("\n", "|").Replace("%steamid%", SteamId, StringComparison.OrdinalIgnoreCase);
                                        foreach (var check in command.Split('|'))
                                        {
                                            LogAction(null, $"[AutoCommands] Исполнение команды: {check} [{GsProductId}][{SteamId}]");
                                            Server.Command(check);
                                        }
                                    }
                                    else
                                    {
                                        LogAction(null, $"[AutoCommands] Ошибка получения (товар не является командой) [{GsProductId}][{SteamId}]");
                                    }
                                }
                            }, null);
                        }
                       
                        break;
                    case 404:
                        LogAction(null, $"[AutoCommands] Api не ответило на запрос: {GsProductId}");
                        LogAction(null, "Response code: 404, please check your configurations", true);
                        break;
                }
            }, null);
        }

        private Timer RestartTimer = null;
        private void SetReserveApiLink()
        {
            if (BaseRequest.Contains(MainApiLink))
            {
                LogAction(null, $"Trying use reserve api link", true);
                BaseRequest = ReserveApiLink + BaseRequestParams;
                if (!Initialized)
                    FetchShopUrl();
                timer.Once(300, () => {
                    TryChangeLink();
                });
            } else
            {
                LogAction(null, $"Plugin will automatically restart after 10 minutes", true);
                RestartTimer = timer.Once(600, () => { LogAction(null, $"Restarting...", true); Server.Command("o.reload GameStoresRUST"); });
            }                         
        }

        private void TryChangeLink()
        {
            string newLink = ReserveApiLink + BaseRequestParams;
            if (BaseRequest.Contains(ReserveApiLink))
            {
                newLink = MainApiLink + BaseRequestParams;
            }
            CheckRequest($"{newLink}&info=true", (code, response) =>
            {
                switch (code)
                {
                    case 200:
                        {
                            if (response.Length < 1)
                            {
                                return;
                            }
                            var firstInfo = JsonConvert.DeserializeObject<Dictionary<string, object>>(response, new KeyValuesConverter());
                            if (!firstInfo.ContainsKey("data"))
                            {
                                initialization = false;
                            }
                            else
                            {
                                if (RestartTimer != null)
                                {
                                    LogAction(null, $"Restart was canceled");
                                    RestartTimer.Destroy();
                                    RestartTimer = null;
                                }
                                LogAction(null, $"API link was changed", true);
                                BaseRequest = newLink;
                                if (!Initialized)
                                    FetchShopUrl();
                                if (BaseRequest.Contains(ReserveApiLink))
                                    timer.Once(600, () => { TryChangeLink(); });
                            }
                            break;
                        }
                    default:
                        break;

                }
            });
        }

        private void FetchShopUrl()
        {
            initialization = true;
            timer.Once(5, () => { initialization = false; });
            Request($"&info=true", (code, response) =>
            {
                try
                {
                    if (response.Length < 1)
                    {
                        SetReserveApiLink();
                        initialization = false;
                        return;
                    }
                    var firstInfo = JsonConvert.DeserializeObject<Dictionary<string, object>>(response, new KeyValuesConverter());
                    if (!firstInfo.ContainsKey("data"))
                    {
                        initialization = false;
                    }
                    else
                    { 
                        firstInfo = firstInfo["data"] as Dictionary<string, object>;
                        ShopURL = firstInfo["link"].ToString();
                        StartBalance = int.Parse(firstInfo["default_balance"].ToString());

                        Initialized = true;
                        initialization = false;
                    }
                }
                catch (JsonException e)
                {
                    SetReserveApiLink();
                    initialization = false;
                }

            });
        }

        private static int errorsReq = 0;
        private static void Request(string ask, Action<int, string> callback, BasePlayer player = null, bool cancel = true)
        {
            if (player != null && !Delays.CanRequest(player))
            {
                instance.ShowNotify(player, "Вы делаете слишком много запросов к серверу!\n" +
                    "Подождите <b>одну секунду</b>!");
                instance.timer.Once(1f, () =>
                {
                    CuiHelper.DestroyUi(player, StoreLayer + ".Notify");
                    Request(ask, callback, player, cancel);
                });

                return;
            };
            if (player != null) ServerMgr.Instance.StartCoroutine(Delays.MakeRequest(player));
            Dictionary<string, string> reqHeaders = new Dictionary<string, string>{{ "User-Agent", "GameStores Plugin" }};
            
            instance.webrequest.Enqueue(instance.BaseRequest + ask, "", (code, response) =>
            {
                if (instance == null) return;
                
                switch (code)
                {
                    case 200:
                        {
                            break;
                        }
                    default:
                        {
                            instance.LogAction(null, $"Time out waiting for GS API #1");
                            errorsReq++;
                            
                            if (errorsReq >= 10)
                            {
                                errorsReq = 0;
                                instance.TryChangeLink();
                            }
                            
                            break;
                        }
                    case 404:
                        {
                            instance.LogAction(null, $"Please check your configuration! [404] #2", true);
                            break;
                        }
                }

                if (player != null && cancel) Delays.FinishRequest(player);

                callback?.Invoke(code, response);
            }, instance, RequestMethod.GET, reqHeaders);
                      
        }
        private static void CheckRequest(string link, Action<int, string> callback)
        {   
            Dictionary<string, string> reqHeaders = new Dictionary<string, string> { { "User-Agent", "GameStores Plugin" } };
            instance.webrequest.Enqueue(link, "", (code, response) =>
            {
                if (instance == null) return;

                switch (code)
                {
                    case 0:
                        {
                            
                            break;
                        }
                    case 404:
                        {
                            
                            break;
                        }
                }

                callback?.Invoke(code, response);
            }, instance, RequestMethod.GET, reqHeaders);

        }

        private static void RequestPost(string ask, Action<int, string> callback, BasePlayer player = null, bool cancel = true)
        {
            if (player != null && !Delays.CanRequest(player))
            {
                instance.ShowNotify(player, "Вы делаете слишком много запросов к серверу!\n" +
                    "Подождите <b>одну секунду</b>!");
                instance.timer.Once(1f, () =>
                {
                    CuiHelper.DestroyUi(player, StoreLayer + ".Notify");
                    RequestPost(ask, callback, player, cancel);
                });
                return;
            };
            if (player != null) ServerMgr.Instance.StartCoroutine(Delays.MakeRequest(player));
            string body, reqLink;
            int pos = instance.BaseRequest.IndexOf("?");
            if (pos < 0)
            {
                body = ask;
                reqLink = instance.BaseRequest;
            }
            else
            {
                reqLink = instance.BaseRequest.Substring(0, pos);
                body = $"{instance.BaseRequest.Substring(pos + 1)}{ask}";
            }
            Dictionary<string, string> reqHeaders = new Dictionary<string, string> { { "User-Agent", "GameStores Plugin" } };
            instance.webrequest.Enqueue(reqLink, body, (code, response) =>
            {
                if (instance == null) return;

                switch (code)
                {
                    case 0:
                        {
                            instance.PrintError($"Time out waiting for GS API #1");
                            break;
                        }
                    case 404:
                        {
                            instance.PrintError($"Plese check your configuration! [404] #2");
                            break;
                        }
                }
                if (player != null && cancel) Delays.FinishRequest(player);

                callback?.Invoke(code, response);
            }, instance, RequestMethod.POST, reqHeaders);
        }

        private void LogAction(BasePlayer player, string text, bool printToConsole = false, bool printError = false)
        {
            LogToFile($"!global", $"{DateTime.Now.ToShortTimeString()} {(player != null ? "[" + player.userID + "]" : " ")}{text}", this);

            if (printToConsole)
                if (printError)
                    instance.PrintError($"{text}");
                else 
                    PrintWarning($"{text}");
            if (player != null)
                LogPlayerAction(player, text);
        }
        private void LogPlayerAction(BasePlayer player, string text) => LogToFile($"{player.userID}", $"{DateTime.Now.ToShortTimeString()} {text}", this);
        private static double CurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1)).TotalSeconds;

        #endregion
    }
}


// --- End of file: GameStoresRUST.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BloodRust-fuuu/MKitBR.cs ---
// --- Original Local Path: BloodRust-fuuu/MKitBR.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch.Extend;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using TinyJSON;
using UnityEngine;
using VLB;

namespace Oxide.Plugins
{
    [Info("MKitBR", "TopPlugin.ru", "3.0.0")]
    public class MKitBR : RustPlugin
    {
        #region var

        string Layer = "Kit_UI";

        [PluginReference] private Plugin ImageLibrary;

        private string prefix = "mkitbr.";


        #endregion

        #region Image

        private string nw = "https://i.ibb.co/gVwn5NG/wipe.png";
        private string nwName = "nwIcon";

        #endregion

        #region data

        public class PlayerKit
        {
            public string name;
            public int amount;
            public double time;
        }

        public Dictionary<ulong, List<PlayerKit>> playerData = new Dictionary<ulong, List<PlayerKit>>();

        public class ItemData
        {
            public string shortname;
            public int amount;
            public ulong skinId = 0;
            public string container;
        }

        public List<KitData> Kits = new List<KitData>();

        public class KitData
        {
            [JsonProperty("Name")] public string name;
            [JsonProperty("Permission")] public string permission;
            [JsonProperty("Wipe delay")] public int wipeDelay;
            [JsonProperty("Amount")] public int amount;
            [JsonProperty("Cooldown")] public int cooldown;
            [JsonProperty("Image")] public string kitImage;
            [JsonProperty("Items")] public List<ItemData> kitItems;
        }

        #endregion

        #region config



        public string BannerURL =
            "https://i.ibb.co/wMhhtg7/baner.png";

        public string Description = "Больше наборов на <color=#b22222>вашем магазине</color>";

        #endregion

        #region Oxide Hooks
        
        void Unload()
        {
            SavePlayersData();
            SaveKitData();
        }

        void OnServerInitialized()
        {
            LoadDefaultConfig();
            if (!Interface.Oxide.DataFileSystem.ExistsDatafile("MKit/KitData")) CreateDefautlKits();
            LoadKitData();

            if (ServerIsWiped())
            {
                for (int i = 0; i < 3; i++)
                {
                    PrintError("WIPE DETECTED");
                }
                Interface.Oxide.DataFileSystem.GetFile("MKit/PlayerData").Clear();
            }

            if (!Interface.Oxide.DataFileSystem.ExistsDatafile("MKit/PlayerData"))
            {
                if (BasePlayer.activePlayerList.Count > 0)
                {
                    foreach (var player in BasePlayer.activePlayerList)
                    {
                        CreatePlayerData(player);

                    }

                    SavePlayersData();
                }
                
            }
            else
            {
                LoadPlayersData();
            }
            timer.Once(3f, (() => ImagesAndPermissions()));

        }

        protected override void LoadDefaultConfig()
        {
            Config["Ссылка на банер"] = BannerURL = GetConfig("Ссылка на банер",
                "https://i.ibb.co/wMhhtg7/baner.png");
            Config["Описание"] = Description = GetConfig("Описание",
                "Больше наборов на <color=#b22222>вашем магазине</color>");
            SaveConfig();
        }
        
        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            SavePlayersData();
        }

        #endregion

        #region hooks

        void CreateDefautlKits()
        {
            KitData defKit = new KitData
            {
                name = "start",
                amount = 2,
                cooldown = 2,
                kitImage =
                    "https://yt3.ggpht.com/a/AATXAJzeeYQsAYa1zViLl5tEXPcoSi5wkpMclT9vXp_PkA=s900-c-k-c0xffffffff-no-rj-mo",
                permission = prefix + "default",
                wipeDelay = 100,
                kitItems = new List<ItemData>
                {
                    new ItemData
                    {
                        shortname = "wood",
                        amount = 5000,
                        container = "main"
                    },
                    new ItemData
                    {
                        shortname = "pickaxe",
                        amount = 1,
                        container = "belt"
                    }
                }
            };
            Kits.Add(defKit);
            SaveKitData();
            
        }

        #region Test

        /*[ChatCommand("wipe")]
        void wipePLayer(BasePlayer player)
        {
            if (playerData.ContainsKey(player.userID))
            {
                playerData.Remove(player.userID);
                SavePlayersData();
            }
        }*/
        

        #endregion

        void ImagesAndPermissions()
        {
            ImageLibrary.Call("AddImage", BannerURL, "Banner");
            ImageLibrary.Call("AddImage", nw, nwName);
            
            foreach (var check in Kits)
            {
                ImageLibrary.Call("AddImage", check.kitImage, check.kitImage);
                permission.RegisterPermission(check.permission, this);
                foreach (var item in check.kitItems)
                {
                    ImageLibrary.Call("AddImage", $"https://rustlabs.com/img/items180/{item.shortname}.png",
                        item.shortname);
                }


            }
        }

        bool ServerIsWiped()
        {
            bool status = Player.Sleepers.Count == 0 && Player.Players.Count == 0;
            return status;

        }

        void SaveKitData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("MKit/KitData", Kits);
        }

        void LoadKitData()
        {
            Kits = Interface.Oxide.DataFileSystem.ReadObject<List<KitData>>("MKit/KitData");
            foreach (var kit in Kits)
            {
                PrintWarning($"Kit {kit.name} loaded");
            }

            PrintWarning("Kits loaded");
        }

        void LoadPlayersData()
        {
            playerData =
                Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, List<PlayerKit>>>("MKit/PlayerData");
            
        }

        List<string> GetKitList(List<KitData> kits)
        {
            List<string> kitNames = new List<string>();
            foreach (var kit in kits)
            {
                kitNames.Add(kit.name);
            }

            return kitNames;
        }

        void PlayerDataUpdate(BasePlayer player)
        {
            if (!playerData.ContainsKey(player.userID))
            {
                CreatePlayerData(player);
            }
            RefreshPlayerData(player);
        }
        void RefreshPlayerData(BasePlayer player)
        {
            if (playerData.Count <1 || BasePlayer.activePlayerList.Count<1)
            {
                return;
            }

            if (playerData.Count == 0)
            {
                return;
            }
            
            
                foreach (var kit in Kits.Where(z => (string.IsNullOrEmpty(z.permission) || permission.UserHasPermission(player.UserIDString, z.permission))))
                {
                    
                    if (!GetPlayerKit(BasePlayer.FindByID(player.userID)).Contains(kit.name))
                    {
                        playerData[player.userID].Add(new PlayerKit
                        {
                            name = kit.name,
                            amount = kit.amount,
                            time = CurTime()
                        });
                        
                    }
                    
                }
            
            SavePlayersData();
        }

        void RefreshPlayersData()
        {
            if (playerData.Count <1 || BasePlayer.activePlayerList.Count<1)
            {
                return;
            }

            if (playerData.Count == 0)
            {
                return;
            }
            
            foreach (var player in playerData)
            {
                foreach (var kit in Kits.Where(z => (string.IsNullOrEmpty(z.permission) || permission.UserHasPermission(player.Key.ToString(), z.permission))))
                {
                    
                    if (!GetPlayerKit(BasePlayer.FindByID(player.Key)).Contains(kit.name))
                    {
                        playerData[player.Key].Add(new PlayerKit
                            {
                                name = kit.name,
                                amount = kit.amount,
                                time = CurTime()
                            });
                    }
                    
                }
            }
            SavePlayersData();
        }

       
        bool CanRecieveKit(BasePlayer player, KitData kitData)
        {
            bool canRecieve = false;

            int belt = player.inventory.containerBelt.itemList.Count;
            int main = player.inventory.containerMain.itemList.Count;
            int wear = player.inventory.containerWear.itemList.Count;

            int cb = player.inventory.containerBelt.capacity;
            int cm = player.inventory.containerMain.capacity;
            int cw = player.inventory.containerWear.capacity;

            int kbelt = 0;
            int kmain = 0;
            int kwear = 0;
            foreach (var item in kitData.kitItems)
            {
                if (item.container == "belt")
                {
                    kbelt++;
                }
                if (item.container == "main")
                {
                    kmain++;
                }
                if (item.container == "wear")
                {
                    kwear++;
                }
            }

            if (cb-belt>=kbelt && cm-main>=kmain && cw-wear>=kwear)
            {
                canRecieve = true;
            }
            
            
            return canRecieve;
        }

        

        void KitRedeem(BasePlayer player, KitData kitData)
        {
            foreach (var item in kitData.kitItems)
            {
                Item cItem =ItemManager.CreateByPartialName(item.shortname, item.amount, item.skinId);
                switch (item.container)
                {
                    case "belt":
                        cItem.MoveToContainer(player.inventory.containerBelt);
                        break;
                    case "main":
                        cItem.MoveToContainer(player.inventory.containerMain);
                        break;
                    case "wear":
                        cItem.MoveToContainer(player.inventory.containerWear);
                        break;
                }
            }
            SendReply(player,$"<color=#921100>Набор</color> <color=#4ef41a>{kitData.name}</color> <color=#921100>получен! Наслаждайся!</color>");
        }

        

        void CreatePlayerData(BasePlayer player)
        {
            if (playerData.ContainsKey(player.userID)) return;
            List<PlayerKit>playerKits= new List<PlayerKit>();
            if (CurTime()<21600)
            {
                
                foreach (var pkit in Kits.Where(z => (string.IsNullOrEmpty(z.permission) || permission.UserHasPermission(player.UserIDString, z.permission))))
                {
                    playerKits.Add(new PlayerKit
                    {
                        name = pkit.name,
                        amount = pkit.amount,
                        time = pkit.wipeDelay + CurTime()
                    });
                }
            }
            else
            {
                foreach (var pkit in Kits.Where(z => (string.IsNullOrEmpty(z.permission) || permission.UserHasPermission(player.UserIDString, z.permission))))
                {
                    playerKits.Add(new PlayerKit
                    {
                        name = pkit.name,
                        amount = pkit.amount,
                        time = CurTime()
                    });
                }
            }
            playerData.Add(player.userID,playerKits);
            SavePlayersData();
            
        }

        void SavePlayersData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("MKit/PlayerData",playerData);
           
        }

        List<string> GetPlayerKit(BasePlayer player)
        {
            if (!playerData.ContainsKey(player.userID))
            {
                CreatePlayerData(player);
            }
            ulong playerid = player.userID;
            List<string> playerkits = new List<string>();

            foreach (var kit in playerData[playerid])
            {
                playerkits.Add(kit.name);
            }
            
            return playerkits;
        }

        void RefreshPlayerKitCooldown()
        {
            timer.Every(1f, (() =>
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    CuiHelper.DestroyUi(player, "Use");
                    foreach (var var in playerData[player.userID])
                    {
                        var container = new CuiElementContainer();
                        container.Add(new CuiPanel
                        {
                            RectTransform = { AnchorMin = $"0.36 0.24", AnchorMax = $"1 0.69", OffsetMax = "0 0" },
                            Image = { Color = "0 0 0 0" }
                        }, "Kits", "Use");

                        container.Add(new CuiLabel
                        {
                            RectTransform = { AnchorMin = $"0.02 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                            Text = { Text = $"{var.time}\n{var.amount}", Align = TextAnchor.MiddleLeft, FontSize = 14, Font = "robotocondensed-bold.ttf" }
                        }, "Use");
                        CuiHelper.AddUi(player, "Use");
                    }
                
                }
            }));
            
        }

        void OnPlayerConnected(BasePlayer player)
        {
            PlayerDataUpdate(player);
        }

        PlayerKit GetPlayerKit(BasePlayer player, string name)
        {
            PlayerKit currentKit = new PlayerKit();
            if (!playerData.ContainsKey(player.userID))
            {
                CreatePlayerData(player);
            }

            currentKit = playerData[player.userID].Find(p => p.name == name);

            return currentKit;
        } 

        #endregion

        #region helper

        public static string FormatShortTime(TimeSpan time)
        {
            string result = string.Empty;
            result = $"{time.Hours.ToString("00")}:";
            result += $"{time.Minutes.ToString("00")}:";
            result += $"{time.Seconds.ToString("00")}";
            return result;
        }

        double CurTime() => new TimeSpan(DateTime.UtcNow.Ticks).TotalSeconds;
        T GetConfig<T>(string name, T value) => Config[name] == null ? value : (T)Convert.ChangeType(Config[name], typeof(T));

        #endregion
        #region UI

        void KitUI(BasePlayer player)
        {
            LoadKitData();
            
            PlayerDataUpdate(player);
            
            CuiHelper.DestroyUi(player, Layer);
            //RefreshPlayersData();
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.284 0", AnchorMax = "0.952 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.6" },
            }, "Menu_UI", Layer);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.032 0.893", AnchorMax = $"0.347 0.954", OffsetMax = "0 0" },
                Image = { Color = "0.92 0.21 0 1" }
            }, Layer, "Title");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                Text = { Text = $"Наборы", Align = TextAnchor.MiddleCenter, FontSize = 30, Font = "robotocondensed-bold.ttf" }
            }, "Title");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.36 0.893", AnchorMax = $"0.97 0.954", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.5" }
            }, Layer, "Description");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                Text = { Text = Description, Align = TextAnchor.MiddleCenter, FontSize = 30, Font = "robotocondensed-regular.ttf" }
            }, "Description");

            CuiHelper.AddUi(player, container);
            UI(player, "");
        }
        void UI(BasePlayer player, string name)
        {
            var container = new CuiElementContainer();

            if (name == "")
            {
                CuiHelper.DestroyUi(player, "Name");
                CuiHelper.DestroyUi(player, "Back");
                CuiHelper.DestroyUi(player, "Inventory");
                CuiHelper.DestroyUi(player, "Clothing");
                CuiHelper.DestroyUi(player, "HotBar");
                CuiHelper.DestroyUi(player, "Items");
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"0.03 0.75", AnchorMax = $"0.97 0.86", OffsetMax = "0 0" },
                    Image = { Color = "0 0 0 0.5" }
                }, Layer, "Banner");

                container.Add(new CuiElement
                {
                    Parent = "Banner",
                    Components =
                    {
                        new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", "Banner"), FadeIn = 0.5f },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" }
                    }
                });

                CuiHelper.AddUi(player, container);
                InterfaceKit(player);
            }
            else
            {
                CuiHelper.DestroyUi(player, "Kit");
                CuiHelper.DestroyUi(player, "Banner");
                var check = Kits.FirstOrDefault(z => z.name == name);

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"0.15 0.8", AnchorMax = $"0.97 0.86", OffsetMax = "0 0" },
                    Image = { Color = "0.92 0.21 0 1" }
                }, Layer, "Name");

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                    Image = { Color = "0 0 0 0" }
                }, Layer, "Items");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                    Text = { Text = check.name.ToUpper(), Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, FontSize = 35, Font = "robotocondensed-bold.ttf" }
                }, "Name");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0.03 0.8", AnchorMax = $"0.14 0.86", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0.6", Command = "kit back" },
                    Text = { Text = "Назад", Align = TextAnchor.MiddleCenter, FontSize = 20, Font = "robotocondensed-bold.ttf" }
                }, Layer, "Back");

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"0.03 0.72", AnchorMax = $"0.495 0.79", OffsetMax = "0 0" },
                    Image = { Color = "0 0 0 0.5" }
                }, Layer, "Inventory");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                    Text = { Text = "Инвентарь", Align = TextAnchor.MiddleCenter, FontSize = 35, Font = "robotocondensed-regular.ttf" }
                }, "Inventory");

                float width = 0.0782f, height = 0.09f, startxBox = 0.028f, startyBox = 0.715f - height, xmin = startxBox, ymin = startyBox;
                for (int z = 0; z < 24; z++)
                {
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = $"{xmin} {ymin}", AnchorMax = $"{xmin + width} {ymin + height * 1}", OffsetMin = "2 2", OffsetMax = "-2 -2" },
                        Button = { Color = "0 0 0 0.5", Command = $"" },
                        Text = { Text = $"", Align = TextAnchor.UpperCenter, FontSize = 20, Font = "robotocondensed-bold.ttf" }
                    }, "Items");

                    xmin += width;
                    if (xmin + width + 0.45f >= 1)
                    {
                        xmin = startxBox;
                        ymin -= height;
                    }
                }

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"0.505 0.72", AnchorMax = $"0.97 0.79", OffsetMax = "0 0" },
                    Image = { Color = "0 0 0 0.5" }
                }, Layer, "Clothing");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                    Text = { Text = "Одежда", Align = TextAnchor.MiddleCenter, FontSize = 35, Font = "robotocondensed-regular.ttf" }
                }, "Clothing");

                float width1 = 0.0782f, height1 = 0.09f, startxBox1 = 0.503f, startyBox1 = 0.715f - height1, xmin1 = startxBox1, ymin1 = startyBox1;
                for (int z = 0; z < 6; z++)
                {
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = $"{xmin1} {ymin1}", AnchorMax = $"{xmin1 + width1} {ymin1 + height1 * 1}", OffsetMin = "2 2", OffsetMax = "-2 -2" },
                        Button = { Color = "0 0 0 0.5", Command = $"" },
                        Text = { Text = $"", Align = TextAnchor.UpperCenter, FontSize = 20, Font = "robotocondensed-bold.ttf" }
                    }, "Items");

                    xmin1 += width1;
                    if (xmin1 + width1>= 1)
                    {
                        xmin1 = startxBox1;
                        ymin1 -= height1;
                    }
                }
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{startxBox1} {startyBox1-0.09}", AnchorMax = $"{startxBox1 + width1} {startyBox1 + height1 * 1-0.09}", OffsetMin = "2 2", OffsetMax = "-2 -2" },
                    Button = { Color = "0 0 0 0.5", Command = $"" },
                    Text = { Text = $"", Align = TextAnchor.UpperCenter, FontSize = 20, Font = "robotocondensed-bold.ttf" }
                }, "Items");

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"0.505 {0.538-width1-0.01}", AnchorMax = $"0.97 {0.622 - width1-0.01}", OffsetMax = "0 0" },
                    Image = { Color = "0 0 0 0.5" }
                }, Layer, "HotBar");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                    Text = { Text = "Пояс", Align = TextAnchor.MiddleCenter, FontSize = 35, Font = "robotocondensed-regular.ttf" }
                }, "HotBar");

                float width2 = 0.0782f, height2 = 0.09f, startxBox2 = 0.503f, startyBox2 = 0.535f - height2, xmin2 = startxBox2, ymin2 = startyBox2;
                for (int z = 0; z < 6; z++)
                {
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = $"{xmin2} {ymin2-width1-0.01}", AnchorMax = $"{xmin2 + width2} {ymin2 + height2 * 1-width1-0.01}", OffsetMin = "2 2", OffsetMax = "-2 -2" },
                        Button = { Color = "0 0 0 0.5", Command = $"" },
                        Text = { Text = $"", Align = TextAnchor.UpperCenter, FontSize = 20, Font = "robotocondensed-bold.ttf" }
                    }, "Items");

                    xmin2 += width2;
                    if (xmin2 + width2>= 1)
                    {
                        xmin2 = startxBox2;
                        ymin2 -= height2;
                    }
                }

                float width3 = 0.0782f, height3 = 0.09f, startxBox3 = 0.028f, startyBox3 = 0.715f - height3, xmin3 = startxBox3, ymin3 = startyBox3;
                float width4 = 0.0782f, height4 = 0.09f, startxBox4 = 0.503f, startyBox4 = 0.715f - height4, xmin4 = startxBox4, ymin4 = startyBox4;
                float width5 = 0.0782f, height5 = 0.09f, startxBox5 = 0.503f, startyBox5 = 0.535f - height5, xmin5 = startxBox5, ymin5 = startyBox5;
                foreach (var item in check.kitItems)
                {
                    if (item.container == "main")
                    {
                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = $"{xmin3} {ymin3}", AnchorMax = $"{xmin3 + width3} {ymin3 + height3 * 1}", OffsetMin = "2 2", OffsetMax = "-2 -2" },
                            Button = { Color = "0 0 0 0", Command = $"" },
                            Text = { Text = $"x{item.amount} ", Align = TextAnchor.LowerRight, FontSize = 12, Font = "robotocondensed-regular.ttf" }
                        }, "Items", "Item");

                        container.Add(new CuiElement
                        {
                            Parent = "Item",
                            Components =
                            {
                                new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", item.shortname), FadeIn = 0.5f},
                                new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "8 8", OffsetMax = "-8 -8" }
                            }
                        });

                        xmin3 += width3;
                        if (xmin3 + width3 + 0.45f >= 1)
                        {
                            xmin3 = startxBox3;
                            ymin3 -= height3;
                        }
                    }
                    if (item.container == "wear")
                    {
                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = $"{xmin4} {ymin4}", AnchorMax = $"{xmin4 + width4} {ymin4 + height4 * 1}", OffsetMin = "2 2", OffsetMax = "-2 -2" },
                            Button = { Color = "0 0 0 0", Command = $"" },
                            Text = { Text = $"x{item.amount} ", Align = TextAnchor.LowerRight, FontSize = 12, Font = "robotocondensed-regular.ttf" }
                        }, "Items", "Item");
                        
                        container.Add(new CuiElement
                        {
                            Parent = "Item",
                            Components =
                            {
                                new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", item.shortname), FadeIn = 0.5f },
                                new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "8 8", OffsetMax = "-8 -8" }
                            }
                        });

                        xmin4 += width4;
                        if (xmin4 + width4>= 1)
                        {
                            xmin4 = startxBox1;
                            ymin4 -= height1;
                        }
                    }
                    if (item.container == "belt")
                    {
                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = $"{xmin5} {ymin5-width1-0.01}", AnchorMax = $"{xmin5 + width5} {ymin5 + height5 * 1-width1-0.01}", OffsetMin = "2 2", OffsetMax = "-2 -2" },
                            Button = { Color = "0 0 0 0", Command = $"" },
                            Text = { Text = $"x{item.amount} ", Align = TextAnchor.LowerRight, FontSize = 12, Font = "robotocondensed-regular.ttf" }
                        }, "Items", "Item");

                        container.Add(new CuiElement
                        {
                            Parent = "Item",
                            Components =
                            {
                                new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", item.shortname), FadeIn = 0.5f },
                                new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "8 8", OffsetMax = "-8 -8" }
                            }
                        });

                        xmin5 += width5;
                    }
                }

                CuiHelper.AddUi(player, container);
            }
        }

        void InterfaceKit(BasePlayer player, int page = 0)
        {
            CuiHelper.DestroyUi(player, "Kit");
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0" },
            }, Layer, "Kit");
            if (GetPlayerKit(player).Count > (page + 1)*6)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0.85 0.03", AnchorMax = $"0.97 0.09", OffsetMax = "0 0" },
                    Button = { Color = "0.92 0.21 0 1", Command = Kits.Count() > (page + 1) * 6 ? $"kit skip {page + 1}" : "" },
                    Text = { Text = ">", Align = TextAnchor.MiddleCenter, FontSize = 30, Font = "robotocondensed-regular.ttf" }
                }, "Kit");
            }

            if (page >= 1)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0.72 0.03", AnchorMax = $"0.84 0.09", OffsetMax = "0 0" },
                    Button = { Color = "0.92 0.21 0 1", Command = page >= 1 ? $"kit skip {page - 1}" : "" },
                    Text = { Text = "<", Align = TextAnchor.MiddleCenter, FontSize = 30, Font = "robotocondensed-regular.ttf" }
                }, "Kit");
            }
            

            float width = 0.472f, height = 0.2f, startxBox = 0.028f, startyBox = 0.72f - height, xmin = startxBox, ymin = startyBox;
            foreach (var check in Kits.Where(z => (string.IsNullOrEmpty(z.permission) || permission.UserHasPermission(player.UserIDString, z.permission))).Skip(page * 6).Take(6).ToList())
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{xmin} {ymin}", AnchorMax = $"{xmin + width} {ymin + height * 1}", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                    Button = { Color = "0.38 0.37 0.38 0.6", Command = $"" },
                    Text = { Text = $"", Align = TextAnchor.UpperCenter, FontSize = 20, Font = "robotocondensed-bold.ttf" }
                }, "Kit", "Kits");

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"0.35 1", OffsetMax = "0 0" },
                    Image = { Color = "0.38 0.37 0.38 1" }
                }, "Kits", "KitImage");

                container.Add(new CuiElement
                {
                    Parent = $"KitImage",
                    Components =
                    {
                        new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", check.kitImage), FadeIn = 0.5f },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "2 2", OffsetMax = "-2 -2" }
                    }
                });

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"0.36 0.7", AnchorMax = $"1 1", OffsetMax = "0 0" },
                    Image = { Color = "0 0 0 0" }
                }, "Kits", "Name");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = $"0.02 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                    Text = { Text = check.name.ToUpper(), Align = TextAnchor.MiddleLeft, FontSize = 20, Font = "robotocondensed-bold.ttf" }
                }, "Name");

                var db = GetPlayerKit(player, check.name);
                var Time = CurTime();
                var time = db.time > 0 && (db.time > Time) ? $"Доустпно через {FormatShortTime(TimeSpan.FromSeconds(db.time - Time))}" : "Можно взять";
                string amount = db.amount.ToString();
                if (db.amount>0)
                {
                    amount = $"{db.amount} использований осталось";
                }

                if (db.amount == 0)
                {
                    amount = "Available next wipe";
                }

                if (db.amount <= -1)
                {
                    amount = "";
                }
                if (amount == "Available next wipe")
                {
                    container.Add(new CuiElement
                    {
                        Parent = "Kit",
                        Components = {
                            new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", nwName), FadeIn = 0.5f } ,
                            new CuiRectTransformComponent { AnchorMin = $"{xmin} {ymin}", AnchorMax = $"{xmin + width} {ymin + height * 1}", OffsetMin = "5 5", OffsetMax = "-5 -5" }
                    
                        }});
                }
                
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"0.36 0.24", AnchorMax = $"1 0.69", OffsetMax = "0 0" },
                    Image = { Color = "0 0 0 0" }
                }, "Kits", "Use");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = $"0.02 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                    Text = { Text = $"{time}\n{amount}", Align = TextAnchor.MiddleLeft, FontSize = 14, Font = "robotocondensed-bold.ttf" }
                }, "Use");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0.37 0.03", AnchorMax = $"0.67 0.23", OffsetMax = "0 0" },
                    Button = { Color =