 "0 0 0 1", Command = $"kit previev {check.name}" },
                    Text = { Text = "Посмотреть", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf" }
                }, "Kits");

                if (amount != "Available next wipe" && db.time<Time)
                {
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = $"0.68 0.03", AnchorMax = $"0.98 0.23", OffsetMax = "0 0" },
                        Button = { Color = "0 0 0 1", Command = $"kit take {check.name}" },
                        Text = { Text = "Взять", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf" }
                    }, "Kits");
                }
                

                xmin += width;
                if (xmin + width >= 1)
                {
                    xmin = startxBox;
                    ymin -= height;
                }
            }

            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region chat

        [ConsoleCommand("kit")]
        void ConsoleKit(ConsoleSystem.Arg args)
        {
            
            var Time = CurTime();
            var player = args.Player();
            if (player != null && args.HasArgs(1))
            {
                if (args.Args[0] == "take")
                {
                    var check = Kits.FirstOrDefault(z => z.name == args.Args[1]);
                    /*if (player.inventory.containerMain.itemList.Count >= 24 || player.inventory.containerWear.itemList.Count >= 7 || player.inventory.containerBelt.itemList.Count >= 6)
                    {
                        SendReply(player, "Not enough space");
                        return;
                    }*/
                    var db = GetPlayerKit(player, check.name);
                    
                    if (!CanRecieveKit(player,Kits.Find(p => p.name == db.name)))
                    {
                        SendReply(player, "Не хватает места");
                        return;
                    }
                    KitRedeem(player,check);
                    
                    if (db.time > Time)
                    {
                        SendReply(player, "Подождите");
                        return;
                    }
                    if (check.cooldown > 0)
                    {
                        //db.time = Time + check.cooldown;
                        playerData[player.userID].Find(p => p.name == db.name).time = Time+check.cooldown;
                        SavePlayersData();
                    };
                    if (check.amount == 0)
                    {
                        SendReply(player, "Вы не можете получить этот набор");
                        return;
                    }

                    playerData[player.userID].Find(p => p.name == db.name).amount -= 1;
                    //db.amount -= 1;
                    SavePlayersData();
                    InterfaceKit(player);
                    Effect x = new Effect("assets/bundled/prefabs/fx/notice/stack.world.fx.prefab", player, 0, new Vector3(), new Vector3());
                    EffectNetwork.Send(x, player.Connection);
                }
                if (args.Args[0] == "back")
                {
                    UI(player, "");
                }
                if (args.Args[0] == "previev")
                {
                    UI(player, args.Args[1]);
                }
                if (args.Args[0] == "skip")
                {
                    InterfaceKit(player, int.Parse(args.Args[1]));
                }
            }
        }

        #endregion
        #region admin

        List<ItemData> SimpleGetItemsToKit(BasePlayer player)
        {
            List<ItemData> itemList = new List<ItemData>();
            foreach (var items in player.inventory.containerBelt.itemList)
            {
                itemList.Add(new ItemData
                {
                    shortname = items.info.shortname,
                    amount = items.amount,
                    container = "belt",
                    skinId = items.skin
                });
            }
            foreach (var items in player.inventory.containerMain.itemList)
            {
                itemList.Add(new ItemData
                {
                    shortname = items.info.shortname,
                    amount = items.amount,
                    container = "main",
                    skinId = items.skin
                });
            }
            foreach (var items in player.inventory.containerWear.itemList)
            {
                itemList.Add(new ItemData
                {
                    shortname = items.info.shortname,
                    amount = items.amount,
                    container = "wear",
                    skinId = items.skin
                });
            }

            return itemList;
        }

        KitData GetNewKit(string name, int cd, int amount, string perm, List<ItemData> items,
            string url = "https://files.facepunch.com/s/84f338d00e7e.png")
        {
            KitData newKit = new KitData();
            newKit.name = name;
            newKit.amount = amount;
            newKit.cooldown = cd;
            newKit.permission = "mkitbr." + perm;
            newKit.kitItems = items;
            newKit.kitImage = url;
            return newKit;
        }

        [ChatCommand("addkit")]
        void AdminCreateKit(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin) return;
            if (args.Length<4)
            {
                SendReply(player,$"Используйте /addkit Название КД количество пермишен\n например /kit start 600 -1 use http:/image.com/ima.png");
                return;
            }

            string url = "https://files.facepunch.com/s/84f338d00e7e.png";

            string name = args[0];
            int cd = args[1].ToInt();
            int amount = args[2].ToInt();
            string perm = args[3];
            if (args.Length>4)
            {
                url = args[4];
            }
            KitData newKit = GetNewKit(name, cd, amount, perm, SimpleGetItemsToKit(player),url);
            Kits.Add(newKit);
            permission.RegisterPermission(newKit.permission,this);
            ImageLibrary.Call("AddImage", url, url);
            SaveKitData();

        }

        [ChatCommand("seturl")]
        void SetKitImage(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin)return;
            if (args.Length<2)
            {
                SendReply(player,"Напишите название набора и url");
            }

            KitData kit =Kits.Find(p => p.name == args[0]);
            if (kit == null)
            {
                SendReply(player,$"Набор с именеи {args[0]} не существует");
                return;
            }

            kit.kitImage = args[1];
            ImageLibrary.Call("AddImage", args[1], args[1]);
            

        }

        [ConsoleCommand("add.kit")]
        void AddKitByAdmin(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null)
                return;
            if (!player.IsAdmin) return;
            
            
        }

        #endregion
    }
}

// --- End of file: MKitBR.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BloodRust-fuuu/Farmer.cs ---
// --- Original Local Path: BloodRust-fuuu/Farmer.cs ---

using System;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;
using UnityEngine;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Farmer", "TopPlugin.ru", "3.0.0")]
    class Farmer : RustPlugin
    {																			
		
		#region Variables
		
		private static System.Random Rnd = new System.Random();
		
		private static List<ulong> NeedInitPlayers = new List<ulong>();
		
		private const string EarnedScoreText = "<color=white>ОЧКИ ФЕРМЕРА</color>";
		
		private static Dictionary<string, string> Images = new Dictionary<string, string>();
		
		private const string MainPanelSizeMin = "-291 -180";
		private const string MainPanelSizeMax = "291 220";
		
		private const int MaxImages = 15; // изменять тут
		
		private const string FarmMainFon = /*"https://i.imgur.com/Zkj8Mq0.png";*/"https://i.imgur.com/yAgKJps.png";
		private const string FarmGreyFon = /*"https://i.imgur.com/YHOIQIy.png";*/"https://i.imgur.com/DT4j3D5.png";
		
		private const string FarmExit = "https://i.imgur.com/mxD6pkk.png";
		private const string FarmBack = "https://i.imgur.com/eKEwvCQ.png";
		private const string FarmExchange = "https://i.imgur.com/r2OI5aq.png";
		
		private readonly Dictionary<int, string> FarmArts = new Dictionary<int, string>()
		{
			{ 1, "https://i.imgur.com/xkvRBMp.png" },
			{ 2, "https://i.imgur.com/4U8Uyur.png" },
			{ 3, "https://i.imgur.com/srwzAIt.png" },
			{ 4, "https://i.imgur.com/uF6l4Ao.png" },
			{ 5, "https://i.imgur.com/Nzx528V.png" },
			{ 6, "https://i.imgur.com/Qnn2kpA.png" },
			{ 7, "https://i.imgur.com/EB7V0bD.png" },
			{ 8, "https://i.imgur.com/1xDvHZn.png" },
			{ 9, "https://i.imgur.com/BS6bnOI.png" },
			{ 10, "https://i.imgur.com/yH3afVL.png" }
		};				
		
		#endregion
		
		#region Hooks
		
		private void Init() 
		{
                        PrintWarning("\n-----------------------------\n" +
                        "     Author - https://topplugin.ru/\n" +
                        "     VK - https://vk.com/rustnastroika\n" +
                        "     Discord - https://discord.com/invite/5DPTsRmd3G\n" +
                        "-----------------------------");
			LoadVariables();
			LoadData();
		}				
		
		private void OnServerInitialized() => DownloadImages();
		
		private void OnServerSave() => SaveData();
		
		private void OnNewSave()
		{
			PlayerData.Clear();
			SaveData();
		}
		
		private void Unload()
		{
			foreach (var player in BasePlayer.activePlayerList)
			{
				if (player == null) continue;
				CuiHelper.DestroyUi(player, MainPanel);
				CuiHelper.DestroyUi(player, InitPanel);
			}
			
			SaveData();			
		}
		
		private void OnPlayerConnected(BasePlayer player)
		{
			if (player == null) return;						
				
			if (!NeedInitPlayers.Contains(player.userID))
				NeedInitPlayers.Add(player.userID);
		}
		
		private void OnGrowableGathered(GrowableEntity plant, Item item, BasePlayer player)
		{
			if (plant == null || item == null || player == null) return;
			
			if (plant.OwnerID == player.userID)
			{
				if ( (item.info.shortname == "cloth" && (plant.State.ToString() == "Ripe" || plant.State.ToString() == "Fruiting")) || 
				     ((item.info.shortname == "pumpkin" || item.info.shortname == "corn" || item.info.shortname == "potato") && (plant.State.ToString() == "Ripe" || plant.State.ToString() == "Fruiting")) )
				{
					int scores = 0;
					if (/*item.info.shortname == "cloth" &&*/ plant.GetPlanter() != null)
						scores+=2;
					
					scores++;
					var type = item.info.shortname == "cloth" ? "hemp" : item.info.shortname;
					API_AddPlayerScores(player.userID, type, scores);										
				}								
			}
		}
		
		private void DoAction(Item item, BasePlayer player, bool giveSeed)
		{
			ItemModConsume mod = null;
			
			var itemModArray = item.info.itemMods;
			for (int i = 0; i < (int)itemModArray.Length; i++)
			{
				if (itemModArray[i] is ItemModMenuOption)
				{
					mod = (itemModArray[i] as ItemModMenuOption).actionTarget as ItemModConsume;
					break;
				}
			}
			
			if (mod != null)
			{
				if (item.amount < 1)				
					return;
				
				GameObjectRef consumeEffect = mod.GetConsumeEffect();
				if (consumeEffect.isValid)
				{
					Vector3 vector3 = (player.IsDucked() ? new Vector3(0f, 1f, 0f) : new Vector3(0f, 2f, 0f));
					Effect.server.Run(consumeEffect.resourcePath, player, 0, vector3, Vector3.zero, null, false);
				}
				player.metabolism.MarkConsumption();
				ItemModConsumable consumable = mod.GetConsumable();
				
				float single = (float)Mathf.Max(consumable.amountToConsume, 1);
				float single1 = (float)Mathf.Min((float)item.amount, single);
				float single2 = single1 / single;
				float single3 = item.conditionNormalized;
				if (consumable.conditionFractionToLose > 0f)
				{
					single3 = consumable.conditionFractionToLose;
				}
				foreach (ItemModConsumable.ConsumableEffect effect in consumable.effects)
				{
					if (Mathf.Clamp01(player.healthFraction + player.metabolism.pending_health.Fraction()) > effect.onlyIfHealthLessThan)
					{
						continue;
					}
					if (effect.type != MetabolismAttribute.Type.Health)
					{
						player.metabolism.ApplyChange(effect.type, effect.amount * single2 * single3, effect.time * single2 * single3);
					}
					else if (effect.amount >= 0f)
					{
						BasePlayer basePlayer = player;
						basePlayer.health = basePlayer.health + effect.amount * single2 * single3;
					}
					else
					{
						player.OnAttacked(new HitInfo(player, player, Rust.DamageType.Generic, -effect.amount * single2 * single3, player.transform.position + (player.transform.forward * 1f)));
					}
				}
				if (mod.product != null && giveSeed)
				{
					ItemAmountRandom[] itemAmountRandomArray = mod.product;
					for (int i = 0; i < (int)itemAmountRandomArray.Length; i++)
					{
						ItemAmountRandom itemAmountRandom = itemAmountRandomArray[i];
						int num = Mathf.RoundToInt((float)itemAmountRandom.RandomAmount() * single3);
						if (num > 0)
						{
							Item item1 = ItemManager.Create(itemAmountRandom.itemDef, num, (ulong)0);
							player.GiveItem(item1, BaseEntity.GiveItemReason.Generic);
						}
					}
				}
				if (string.IsNullOrEmpty(mod.eatGesture))
				{
					player.SignalBroadcast(BaseEntity.Signal.Gesture, mod.eatGesture, null);
				}
				if (consumable.conditionFractionToLose <= 0f)
				{
					item.UseItem((int)single1);
					return;
				}
				item.LoseCondition(consumable.conditionFractionToLose * item.maxCondition);
			}
			
		}
		
		private bool? OnItemAction(Item item, string action, BasePlayer player)
        {			
            if (item == null || player == null || !(item.info.shortname == "pumpkin" || item.info.shortname == "corn" || item.info.shortname == "potato") || !(action == "consume")) return null;
				
			if (player.metabolism.CanConsume())
				DoAction(item, player, Rnd.Next(1,3)==1);
						
			return false;
		}
		
		#endregion
		
		#region Images
		
		private static bool AreImagesLoaded() => Images.Count >= MaxImages;		
		
		private void DownloadImages() 
		{						
			ServerMgr.Instance.StartCoroutine(DownloadImage(FarmMainFon));
			ServerMgr.Instance.StartCoroutine(DownloadImage(FarmGreyFon));
			ServerMgr.Instance.StartCoroutine(DownloadImage(FarmExit));
			ServerMgr.Instance.StartCoroutine(DownloadImage(FarmBack));
			ServerMgr.Instance.StartCoroutine(DownloadImage(FarmExchange));
			
			foreach (var pair in FarmArts)
				ServerMgr.Instance.StartCoroutine(DownloadImage(pair.Value));
		}
		
		private IEnumerator DownloadImage(string url)
        {
            using (var www = new WWW(url))
            {
                yield return www;                
                if (www.error != null)                
                    PrintWarning($"Ошибка добавления изображения. Неверная ссылка на изображение:\n {url}");
                else
                {
                    var tex = www.texture;
                    byte[] bytes = tex.EncodeToPNG();															
                    var image = FileStorage.server.Store(bytes, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID).ToString();
					
					if (!Images.ContainsKey(url))
						Images.Add(url, image);
					else
						Images[url] = image;
					
                    UnityEngine.Object.DestroyImmediate(tex);
                    yield break;
                }
            }
        }
		
		#endregion
		
		#region Commands
		
		[ChatCommand("farmer_add_scores")]
        private void CommandFarmScores(BasePlayer player, string command, string[] args)
        {
            if (player == null || !player.IsAdmin) return;
			API_AddPlayerScores(player.userID, "pumpkin", 500);
		}
		
		[ChatCommand("fermer")]
        private void CommandFarm1(BasePlayer player, string command, string[] args) => CommandFarm(player, command, args);
		
		[ChatCommand("farmer")]
        private void CommandFarm(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;			
			
			if (!AreImagesLoaded())
			{
				SendReply(player, "Плагин еще инициализируется, подождите пару секунд.\nЕсли это сообщение не проходит, сообщите администратору.");
				return;
			}
			
			//API_AddPlayerScores(76561198241364488, "pumpkin", 66);
			
			if (NeedInitPlayers.Contains(player.userID))
			{
				DoInitImages(player);
				timer.Once(0.1f, ()=> DrawUI(player));
			}						
			else
				DrawUI(player);
        }
		
		[ChatCommand("fermer_top")]
        private void CommandFarmTop1(BasePlayer player, string command, string[] args) => CommandFarmTop2(player, command, args);
		
		[ChatCommand("farmer_top")]
        private void CommandFarmTop2(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;			
			
			int num = 0;
			var result = "ТОП Фермеров за текущий вайп:\n";
			foreach (var pair in PlayerData.OrderByDescending(x=> x.Value.PotatoScores+x.Value.PumpkinScores+x.Value.CornScores+x.Value.HempScores+x.Value.EggScores+x.Value.OysterScores))			
			{
				var total = pair.Value.PotatoScores + pair.Value.PumpkinScores + pair.Value.CornScores + pair.Value.HempScores + pair.Value.EggScores + pair.Value.OysterScores;
				result += $"{++num}. "+"<color=#8ABB50>" + GetPlayerName(pair.Key) + "</color>" + $": {total} всего, {pair.Value.PumpkinScores} ткв, {pair.Value.CornScores} ккз, {pair.Value.PotatoScores} крш, {pair.Value.HempScores} кон, {pair.Value.EggScores} яйц, {pair.Value.OysterScores} уст\n";
				if (num >= 10) break;
			}
						
			SendReply(player, "<size=15>"+result+"</size>");
        }
		
		#endregion
		
		#region Init Images
		
		private void DoInitImages(BasePlayer player, bool isFull = false)
		{
			if (player == null) return;						
			
			var container = new CuiElementContainer();
			UI_MainPanel(ref container, "0 0 0 0", "1.1 1.1", "1.2 1.2", "Overlay", false, false, InitPanel);
			
			if (!isFull)
			{				
				UI_Image(ref container, Images[FarmExit], "0 0", "1 1", 0f, 0f, InitPanel);
				UI_Image(ref container, Images[FarmBack], "0 0", "1 1", 0f, 0f, InitPanel);
				UI_Image(ref container, Images[FarmExchange], "0 0", "1 1", 0f, 0f, InitPanel);
				
				UI_Image(ref container, Images[FarmMainFon], "0 0", "1 1", 0f, 0f, InitPanel);
				UI_Image(ref container, Images[FarmGreyFon], "0 0", "1 1", 0f, 0f, InitPanel);
			}
			else
			{
				foreach (var img in FarmArts.Values)
					UI_Image(ref container, Images[img], "0 0", "1 1", 0f, 0f, InitPanel);
			}
			
			CuiHelper.DestroyUi(player, InitPanel);
			CuiHelper.AddUi(player, container);	
		}
		
		#endregion
		
		#region GUI
		
		private static void SendЕarnedScores(BasePlayer player, int score)
		{
			if (player == null) return;			
			player.Command("note.inv", new object[] { -1002156085, score, EarnedScoreText });
		}
		
		private static void SendЕarnedScores(ulong userID, int score)
		{
			var player = BasePlayer.FindByID(userID);
			if (player == null) return;
			player.Command("note.inv", new object[] { -1002156085, score, EarnedScoreText });
		}
		
		private void DrawUI(BasePlayer player)
		{
			if (player == null) return;
			
			CuiHelper.DestroyUi(player, MainPanel);
			CuiHelper.DestroyUi(player, InitPanel);
			
			var container = new CuiElementContainer();
			UI_MainPanel(ref container, "0 0 0 0", "0 0", "1 1", "Menu_UI2", true, false);
			
			UI_Button(ref container, "0 0 0 0", "", 14, "0 0", "1 1", "farmer_9182743.exit", "robotocondensed-regular.ttf", TextAnchor.MiddleCenter, MainPanel, "farmer.globalexit.button");
			
			UI_Panel(ref container, "0 0 0 0", "0.5 0.5", "0.5 0.5", MainPanel, "farmer.mainfon.panel", MainPanelSizeMin, MainPanelSizeMax);
			
			UI_Image(ref container, Images[FarmMainFon], "0 0", "1 1", 0.5f, 0.5f, "farmer.mainfon.panel", "farmer.mainfon.image");
			
			// кнопки
			UI_Button(ref container, "0 0 0 0", "", 14, "0.1417222 0.4110795", "0.243 0.6348011", "farmer_9182743.art 1", "robotocondensed-regular.ttf", TextAnchor.MiddleCenter, "farmer.mainfon.panel", "farmer.art1.button");
			UI_Button(ref container, "0 0 0 0", "", 14, "0.2537222 0.4110795", "0.407 0.6348011", "farmer_9182743.art 2", "robotocondensed-regular.ttf", TextAnchor.MiddleCenter, "farmer.mainfon.panel", "farmer.art2.button");
			UI_Button(ref container, "0 0 0 0", "", 14, "0.4167221 0.4110798", "0.5690001 0.6348007", "farmer_9182743.art 3", "robotocondensed-regular.ttf", TextAnchor.MiddleCenter, "farmer.mainfon.panel", "farmer.art3.button");
			UI_Button(ref container, "0 0 0 0", "", 14, "0.5767221 0.41108", "0.7200001 0.6348003", "farmer_9182743.art 4", "robotocondensed-regular.ttf", TextAnchor.MiddleCenter, "farmer.mainfon.panel", "farmer.art4.button");
			UI_Button(ref container, "0 0 0 0", "", 14, "0.728722 0.4110799", "0.8639999 0.6348006", "farmer_9182743.art 5", "robotocondensed-regular.ttf", TextAnchor.MiddleCenter, "farmer.mainfon.panel", "farmer.art5.button");
			UI_Button(ref container, "0 0 0 0", "", 14, "0.1367223 0.1541199", "0.278 0.3778401", "farmer_9182743.art 6", "robotocondensed-regular.ttf", TextAnchor.MiddleCenter, "farmer.mainfon.panel", "farmer.art6.button");
			UI_Button(ref container, "0 0 0 0", "", 14, "0.2867224 0.1553983", "0.428 0.3791185", "farmer_9182743.art 7", "robotocondensed-regular.ttf", TextAnchor.MiddleCenter, "farmer.mainfon.panel", "farmer.art7.button");
			UI_Button(ref container, "0 0 0 0", "", 14, "0.4387224 0.1566766", "0.564 0.380397", "farmer_9182743.art 8", "robotocondensed-regular.ttf", TextAnchor.MiddleCenter, "farmer.mainfon.panel", "farmer.art8.button");
			UI_Button(ref container, "0 0 0 0", "", 14, "0.5717223 0.1579551", "0.7129999 0.3816754", "farmer_9182743.art 9", "robotocondensed-regular.ttf", TextAnchor.MiddleCenter, "farmer.mainfon.panel", "farmer.art9.button");
			UI_Button(ref container, "0 0 0 0", "", 14, "0.7217223 0.1592336", "0.8629999 0.3829538", "farmer_9182743.art 10", "robotocondensed-regular.ttf", TextAnchor.MiddleCenter, "farmer.mainfon.panel", "farmer.art10.button");
			
			// очки
			PreparePlayerScores(player, ref container, false);
			
			// выход			
			//UI_Panel(ref container, "0.5 0.5 0.5 0.9", "0.7207223 0.051", "0.874 0.12", "farmer.mainfon.panel");
			UI_Image(ref container, Images[FarmExit], "0.7207223 0.051", "0.874 0.12", 0.5f, 0.5f, "farmer.mainfon.panel", "farmer.exit.image");
			UI_Button(ref container, "0 0 0 0", "", 14, "0 0", "1 1", "farmer_9182743.exit", "robotocondensed-regular.ttf", TextAnchor.MiddleCenter, "farmer.exit.image", null, 0.5f, 0.5f);
			
			CuiHelper.AddUi(player, container);
			
			if (NeedInitPlayers.Contains(player.userID))
			{
				DoInitImages(player, true);
				NeedInitPlayers.Remove(player.userID);				
			}
		}
		
		private void PreparePlayerScores(BasePlayer player, ref CuiElementContainer container, bool isSecond)
		{
			if (!isSecond)
			{
				CuiHelper.DestroyUi(player, "farmer.scores.label");
				var scores = GetPlayerScores(player.userID, "total.real");			
				UI_FLabel(ref container, scores.ToString(), "0 0 0 0", 28, "0.1307223 0.042", "0.228 0.13", 0f, 0f, TextAnchor.MiddleCenter, "robotocondensed-bold.ttf", "farmer.mainfon.panel", "farmer.scores.label");
			}
			else
			{
				CuiHelper.DestroyUi(player, "farmer.scores.label2");
				var scores = GetPlayerScores(player.userID, "total.real");			
				UI_FLabel(ref container, scores.ToString(), "0 0 0 0", 28, "0.1307223 0.042", "0.228 0.13", 0f, 0f, TextAnchor.MiddleCenter, "robotocondensed-bold.ttf", "farmer.greyfon.panel", "farmer.scores.label2");
			}
		}
		
		private void DrawArt(BasePlayer player, int num)
		{
			if (player == null) return;
			
			var container = new CuiElementContainer();
			
			UI_Panel(ref container, "0 0 0 0", "0.5 0.5", "0.5 0.5", MainPanel, "farmer.greyfon.panel", MainPanelSizeMin, MainPanelSizeMax);
			
			UI_Image(ref container, Images[FarmGreyFon], "0 0", "1 1", 0f, 0f, "farmer.greyfon.panel", "farmer.greyfon.image");
			
			UI_Image(ref container, Images[FarmArts[num]], "0.215 0.2717329", "0.788 0.6757102", 0.2f, 0.2f, "farmer.greyfon.panel", "farmer.art.image");
			
			// обменять			
			var colorExchange = GetCaseCost(num) <= GetPlayerScores(player.userID, "total.real") ? "0.5 0.7 0.2 0.5" : "0.9 0.9 0.9 0.5";
			
			UI_Image(ref container, Images[FarmExchange], "0.39 0.2180398", "0.61 0.2845171", 0f, 0f, "farmer.greyfon.panel", "farmer.exchange.image");
			UI_Button(ref container, colorExchange, "", 14, "0 0", "1 1", $"farmer_9182743.exchange {num}", "robotocondensed-regular.ttf", TextAnchor.MiddleCenter, "farmer.exchange.image", null);
			
			// очки
			PreparePlayerScores(player, ref container, true);
			
			// назад
			//UI_Panel(ref container, "0.5 0.5 0.5 0.9", "0.7207223 0.051", "0.874 0.12", "farmer.greyfon.panel");
			UI_Image(ref container, Images[FarmBack], "0.7207223 0.051", "0.874 0.12", 0f, 0f, "farmer.greyfon.panel", "farmer.back.image");
			UI_Button(ref container, "0 0 0 0", "", 14, "0 0", "1 1", "farmer_9182743.back", "robotocondensed-regular.ttf", TextAnchor.MiddleCenter, "farmer.back.image", null, 0f, 0f);
			
			CuiHelper.AddUi(player, container);
		}
		
		#endregion
		
		#region GUI Commands
		
		[ConsoleCommand("farmer_9182743.exit")]
        private void cmdGUIClose(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;						
									
			CuiHelper.DestroyUi(player, MainPanel);
		}
		
		[ConsoleCommand("farmer_9182743.art")]
        private void cmdGUIArt(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;
			
			var num = Convert.ToInt32(arg.Args[0]);
			DrawArt(player, num);
		}
		
		[ConsoleCommand("farmer_9182743.back")]
        private void cmdGUIBack(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;
			
			CuiHelper.DestroyUi(player, "farmer.greyfon.panel");
		}
		
		[ConsoleCommand("farmer_9182743.exchange")]
        private void cmdGUIExchange(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;
			
			var num = Convert.ToInt32(arg.Args[0]);
			var cost = GetCaseCost(num);
			if (cost <= GetPlayerScores(player.userID, "total.real"))
			{
				if (GivePlayerLoot(player, num))
				{
					UsePlayerScores(player.userID, cost);
				
					var container = new CuiElementContainer();				
					PreparePlayerScores(player, ref container, false);
					CuiHelper.AddUi(player, container);
					
					CuiHelper.DestroyUi(player, "farmer.greyfon.panel");
					
					ShowMessage(player, "Вы открыли ящик и достали оттуда случайный предмет.\nПроверьте свой инвентарь.");
				}
			}
		}
		
		#endregion
		
		#region GUI Helpers
		
		private const string MainPanel = "FarmerMainPanel";		
		private const string InitPanel = "FarmerInitPanel";
		
		private static void UI_MainPanel(ref CuiElementContainer container, string color, string aMin, string aMax, string Parent = "Menu_UI2", bool isNeedCursor = true, bool isBlur = false, string panel = MainPanel)
		{					
			container.Add(new CuiPanel
			{
				Image = { Color = color, Material = isBlur ? "assets/content/ui/uibackgroundblur.mat" : "Assets/Icons/IconMaterial.mat" },
				RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
				CursorEnabled = isNeedCursor
			}, Parent, panel);
		}
		
		private static void UI_Panel(ref CuiElementContainer container, string color, string aMin, string aMax, string panel = MainPanel, string name = null, string oMin = "0.0 0.0", string oMax = "0.0 0.0", float fadeIn = 0f, float fadeOut = 0f)
		{			
			container.Add(new CuiPanel
			{
				FadeOut = fadeOut,
				Image = { Color = color, FadeIn = fadeIn },
				RectTransform = { AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax }
			}, panel, name);
		}
		
		private static void UI_Label(ref CuiElementContainer container, string text, int size, string aMin, string aMax, float fadeIn = 0f, float fadeOut = 0f, TextAnchor align = TextAnchor.MiddleCenter, string font = "robotocondensed-regular.ttf", string panel = MainPanel, string name = null)
		{						
			container.Add(new CuiElement
			{
				Name = !string.IsNullOrEmpty(name) ? name : CuiHelper.GetGuid(),
				Parent = panel,
				FadeOut = fadeOut,
				Components =
				{
					new CuiTextComponent { FontSize = size, Align = align, Text = text, Font = font, FadeIn = fadeIn },
					new CuiRectTransformComponent { AnchorMin = aMin, AnchorMax = aMax }					
				}
			});
		}
		
		private static void UI_FLabel(ref CuiElementContainer container, string text, string fcolor, int size, string aMin, string aMax, float fadeIn = 0f, float fadeOut = 0f, TextAnchor align = TextAnchor.MiddleCenter, string font = "robotocondensed-regular.ttf", string panel = MainPanel, string name = null)
		{						
			if (string.IsNullOrEmpty(fcolor))
				fcolor = "0.0 0.0 0.0 1.0";
			
			container.Add(new CuiElement
			{
				Name = !string.IsNullOrEmpty(name) ? name : CuiHelper.GetGuid(),
				Parent = panel,
				FadeOut = fadeOut,
				Components =
				{
					new CuiTextComponent { FontSize = size, Align = align, Text = text, Font = font, FadeIn = fadeIn },
					new CuiRectTransformComponent { AnchorMin = aMin, AnchorMax = aMax },
					new CuiOutlineComponent { Distance = "1 1", Color = fcolor }
				}
			});
		}
				
		private static void UI_Button(ref CuiElementContainer container, string color, string text, int size, string aMin, string aMax, string command, string font = "robotocondensed-regular.ttf", TextAnchor align = TextAnchor.MiddleCenter, string panel = MainPanel, string name = null, float fadeIn = 0f, float fadeOut = 0f)
		{
			if (string.IsNullOrEmpty(color)) color = "0 0 0 0";
			
			container.Add(new CuiButton
			{
				FadeOut = fadeOut,
				Button = { Color = color, Command = command, FadeIn = fadeIn },
				RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
				Text = { Text = text, FontSize = size, Align = align, Font = font }
			}, panel, name);
		}
		
		private static void UI_Image(ref CuiElementContainer container, string png, string aMin, string aMax, float fadeIn = 0f, float fadeOut = 0f, string panel = MainPanel, string name = null, string oMin = null, string oMax = null)
		{
			container.Add(new CuiElement
			{
				Name = !string.IsNullOrEmpty(name) ? name : CuiHelper.GetGuid(),
				Parent = panel,
				FadeOut = fadeOut,
				Components =
				{
					(png.Contains("https://") || png.Contains("http://")) ? new CuiRawImageComponent { Url = png, FadeIn = fadeIn } : new CuiRawImageComponent { Png = png, FadeIn = fadeIn },
					string.IsNullOrEmpty(oMin) ? new CuiRectTransformComponent { AnchorMin = aMin, AnchorMax = aMax } : new CuiRectTransformComponent { AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax }
				}
			});
		}
		
		#endregion
		
		#region SendMessage
		
		private static Dictionary<ulong, Timer> SMPlayerTimer = new Dictionary<ulong, Timer>();
		
		private void ShowMessage(BasePlayer player, string message)
		{						
			if (player == null || string.IsNullOrEmpty(message)) return;						
		
			ClearMessages(player);			
			var container = new CuiElementContainer();
						
			UI_Panel(ref container, "0.9 0.9 0.9 0.9", "0.213 0.7792612", "0.7909999 0.8649148", "farmer.mainfon.panel", "farmer.sm.panel", "0.0 0.0", "0.0 0.0", 0.5f, 0.5f);
			UI_Label(ref container, $"<color=black>{message}</color>", 18, "0 0", "1 1", 0.5f, 0.5f, TextAnchor.MiddleCenter, "robotocondensed-bold.ttf", "farmer.sm.panel", "farmer.sm.label");
			
			CuiHelper.AddUi(player, container);	
			
			if (!SMPlayerTimer.ContainsKey(player.userID))
				SMPlayerTimer.Add(player.userID, null);
			
			SMPlayerTimer[player.userID] = timer.Once(4f, ()=> 
			{
				CuiHelper.DestroyUi(player, "farmer.sm.label");
				CuiHelper.DestroyUi(player, "farmer.sm.panel");
			});
		}
		
		private static void ClearMessages(BasePlayer player)
		{
			if (player == null) return;
			
			if (SMPlayerTimer.ContainsKey(player.userID) && SMPlayerTimer[player.userID] != null)
			{	
				SMPlayerTimer[player.userID].Destroy();
				SMPlayerTimer[player.userID] = null;
			}
			
			CuiHelper.DestroyUi(player, "farmer.sm.panel");
		}
		
		#endregion
		
		#region Helpers
		
		private string GetPlayerName(ulong userID)
		{
			var data = permission.GetUserData(userID.ToString());															
			return data.LastSeenNickname;
		}
		
		private static int GetPlayerScores(ulong userID, string type)
		{
			if (!PlayerData.ContainsKey(userID))
				return 0;
			
			switch (type)
			{
				case "total.real" : return PlayerData[userID].PotatoScores + PlayerData[userID].PumpkinScores + PlayerData[userID].CornScores + PlayerData[userID].HempScores + PlayerData[userID].EggScores + PlayerData[userID].OysterScores - PlayerData[userID].UsedScores;
				case "total.all" : return PlayerData[userID].PotatoScores + PlayerData[userID].PumpkinScores + PlayerData[userID].CornScores + PlayerData[userID].HempScores + PlayerData[userID].EggScores + PlayerData[userID].OysterScores;
				case "used" : return PlayerData[userID].UsedScores;
				case "pumpkin" : return PlayerData[userID].PumpkinScores;
				case "corn" : return PlayerData[userID].CornScores;
				case "hemp" : return PlayerData[userID].HempScores;
				case "egg" : return PlayerData[userID].EggScores;
				case "oyster" : return PlayerData[userID].OysterScores;
				case "potato" : return PlayerData[userID].PotatoScores;
			}
			
			return 0;
		}
		
		private static void UsePlayerScores(ulong userID, int amount)
		{
			if (!PlayerData.ContainsKey(userID))
				PlayerData.Add(userID, new PData());
				
			PlayerData[userID].UsedScores += amount;
		}
		
		private void API_AddPlayerScores(ulong userID, string type, int amount)
		{
			if (!PlayerData.ContainsKey(userID))
				PlayerData.Add(userID, new PData());
			
			switch (type)
			{
				case "pumpkin" : PlayerData[userID].PumpkinScores += amount; break;
				case "corn" : PlayerData[userID].CornScores += amount; break;
				case "hemp" : PlayerData[userID].HempScores += amount; break;
				case "egg" : PlayerData[userID].EggScores += amount; break;
				case "oyster" : PlayerData[userID].OysterScores += amount; break;
				case "potato" : PlayerData[userID].PotatoScores += amount; break;
			}
			
			SendЕarnedScores(userID, amount);
		}
		
		private static int GetCaseCost(int num)
		{
			if (!configData.Costs.ContainsKey(num)) 
				return int.MaxValue;
			
			return configData.Costs[num];
		}
		
		#endregion
		
		#region Give
		
		private bool GivePlayerLoot(BasePlayer player, int num)
		{
			if (player == null || !configData.Items.ContainsKey(num))
				return false;
			
			var listItems = configData.Items[num].Where(x=> x.Enabled).ToList();
			
			if (listItems.Count == 0)
				return false;
			
			int rndNum = 0;
			FarmItem item = null;
			try
			{
				var max = Rnd.Next(1,21);
				for (int ii = 0; ii <= max; ii++)
					rndNum = (int)Math.Truncate(Rnd.Next(1, listItems.Count*10)/10f);
				
				item = listItems[rndNum];
				
				var newItem = ItemManager.CreateByName(item.ItemName, Rnd.Next(item.MinAmount, item.MaxAmount + 1));
				player.GiveItem(newItem, BaseEntity.GiveItemReason.ResourceHarvested);
			}
			catch
			{
				PrintWarning($"Ошибка создания предмета, имя {item.ItemName}, позиция в списке {rndNum}");
				return false;
			}
			
			return true;
		}
		
		#endregion
		
		#region Config
		
        private static ConfigData configData;
		
        private class ConfigData
        {            
			[JsonProperty(PropertyName = "Список кейсов и их стоимость")]
			public Dictionary<int, int> Costs;			
			[JsonProperty(PropertyName = "Список кейсов и их лут")]
			public Dictionary<int, List<FarmItem>> Items;
        }
		
		private class FarmItem
		{
			[JsonProperty(PropertyName = "Номер предмета (для ссылок)")]
			public int Num;
			[JsonProperty(PropertyName = "Включен")]
			public bool Enabled;
			[JsonProperty(PropertyName = "Игровое название предмета")]
			public string ItemName;
			[JsonProperty(PropertyName = "Количество (минимум)")]
			public int MinAmount;
			[JsonProperty(PropertyName = "Количество (максимум)")]
			public int MaxAmount;
			[JsonProperty(PropertyName = "Список предметов, которые будут падать совместно с этим")]
			public List<int> AddItems;
			
			public FarmItem(int Num, bool Enabled, string ItemName, int MinAmount, int MaxAmount, List<int> AddItems)
			{
				this.Num = Num;
				this.Enabled = Enabled;
				this.ItemName = ItemName;
				this.MinAmount = MinAmount;
				this.MaxAmount = MaxAmount;
				this.AddItems = AddItems;
			}
		}
		
        private void LoadVariables() => configData = Config.ReadObject<ConfigData>();        
		
        protected override void LoadDefaultConfig()
        {
            configData = new ConfigData
            {
                Costs = new Dictionary<int, int>()
				{
					{ 1, 25 },
					{ 2, 50 },
					{ 3, 75 },
					{ 4, 80 },
					{ 5, 100 },
					{ 6, 200 },
					{ 7, 250 },
					{ 8, 300 },
					{ 9, 325 },
					{ 10, 350 }
				},
				Items = new Dictionary<int, List<FarmItem>>()
				{
					{ 1, new List<FarmItem>() 
						{ 
							new FarmItem(1, true, "pants", 1, 1, null),
							new FarmItem(2, true, "hoodie", 1, 1, null),
							new FarmItem(3, true, "tactical.gloves", 1, 1, null),
							new FarmItem(4, true, "shoes.boots", 1, 1, null),
							new FarmItem(5, true, "jacket.snow", 1, 1, null),
							new FarmItem(6, true, "hazmatsuit", 1, 1, null)
						} 
					},
					{ 2, new List<FarmItem>() 
						{ 
							new FarmItem(7, true, "hatchet", 1, 1, null),
							new FarmItem(8, true, "pickaxe", 1, 1, null),
							new FarmItem(9, true, "icepick.salvaged", 1, 1, null),
							new FarmItem(10, true, "axe.salvaged", 1, 1, null),
							new FarmItem(11, true, "jackhammer", 1, 1, null),
							new FarmItem(12, true, "chainsaw", 1, 1, null)
						} 
					},
					{ 3, new List<FarmItem>() 
						{ 
							new FarmItem(13, true, "bed", 1, 1, null),
							new FarmItem(14, true, "furnace.large", 1, 1, null),
							new FarmItem(15, true, "small.oil.refinery", 1, 1, null),
							new FarmItem(16, true, "vending.machine", 1, 1, null),
							new FarmItem(17, true, "shelves", 1, 1, null),
							new FarmItem(18, true, "locker", 1, 1, null)
						} 
					},
					{ 4, new List<FarmItem>() 
						{ 
							new FarmItem(19, true, "coffeecan.helmet", 1, 1, null),
							new FarmItem(20, true, "roadsign.jacket", 1, 1, null),
							new FarmItem(21, true, "roadsign.kilt", 1, 1, null),
							new FarmItem(22, true, "roadsign.gloves", 1, 1, null)							
						} 
					},
					{ 5, new List<FarmItem>() 
						{ 
							new FarmItem(23, true, "wall.frame.garagedoor", 1, 1, null),
							new FarmItem(24, true, "floor.ladder.hatch", 1, 1, null),
							new FarmItem(25, true, "ladder.wooden.wall", 1, 1, null),
							new FarmItem(26, true, "wall.external.high.stone", 1, 1, null),
							new FarmItem(27, true, "gates.external.high.stone", 1, 1, null),
							new FarmItem(28, true, "gates.external.high.wood", 1, 1, null),
							new FarmItem(29, true, "wall.external.high", 1, 1, null),
							new FarmItem(30, true, "wall.window.glass.reinforced", 1, 1, null),
							new FarmItem(31, true, "barricade.metal", 1, 1, null),
							new FarmItem(32, true, "wall.frame.shopfront.metal", 1, 1, null)							
						} 
					},
					{ 6, new List<FarmItem>() 
						{ 
							new FarmItem(33, true, "stones", 7000, 10000, null),
							new FarmItem(34, true, "wood", 9000, 12000, null),
							new FarmItem(35, true, "cloth", 500, 800, null),
							new FarmItem(36, true, "leather", 400, 700, null),
							new FarmItem(37, true, "lowgradefuel", 400, 700, null),
							new FarmItem(38, true, "metal.fragments", 3000, 5000, null),
							new FarmItem(39, true, "metal.refined", 80, 120, null),
							new FarmItem(40, true, "crude.oil", 200, 300, null),
							new FarmItem(41, true, "sulfur", 2000, 3000, null),
							new FarmItem(42, true, "gunpowder", 1500, 2000, null),
							new FarmItem(43, true, "charcoal", 9000, 12000, null)
						}
					},
					{ 7, new List<FarmItem>() 
						{ 
							new FarmItem(44, true, "techparts", 7, 10, null),
							new FarmItem(45, true, "smgbody", 5, 7, null),
							new FarmItem(46, true, "riflebody", 5, 7, null),
							new FarmItem(47, true, "semibody", 7, 10, null),
							new FarmItem(48, true, "rope", 40, 50, null),
							new FarmItem(49, true, "sewingkit", 20, 30, null),
							new FarmItem(50, true, "sheetmetal", 15, 20, null),
							new FarmItem(51, true, "roadsigns", 15, 25, null),
							new FarmItem(52, true, "metalspring", 10, 15, null),
							new FarmItem(53, true, "metalpipe", 15, 25, null),
							new FarmItem(54, true, "gears", 15, 20, null)
						}
					},
					{ 8, new List<FarmItem>() 
						{ 
							new FarmItem(55, true, "grenade.beancan", 1, 1, null),
							new FarmItem(56, true, "explosive.satchel", 1, 1, null),
							new FarmItem(57, true, "explosives", 1, 1, null),
							new FarmItem(58, true, "flamethrower", 1, 1, null),
							new FarmItem(59, true, "ammo.rifle.explosive", 1, 1, null)
						}
					},
					{ 9, new List<FarmItem>() 
						{ 
							new FarmItem(60, true, "pistol.semiauto", 1, 1, null),
							new FarmItem(61, true, "shotgun.pump", 1, 1, null),
							new FarmItem(62, true, "smg.thompson", 1, 1, null),
							new FarmItem(63, true, "smg.2", 1, 1, null),							
							new FarmItem(65, true, "rifle.semiauto", 1, 1, null)
						}
					},
					{ 10, new List<FarmItem>() 
						{ 
							new FarmItem(66, true, "pistol.m92", 1, 1, null),
							new FarmItem(67, true, "rifle.lr300", 1, 1, null),
							new FarmItem(68, true, "rifle.l96", 1, 1, null),
							new FarmItem(69, true, "smg.mp5", 1, 1, null),
							new FarmItem(70, true, "shotgun.spas12", 1, 1, null),
							new FarmItem(71, true, "rifle.m39", 1, 1, null)
						}
					}					
				}
            };
            SaveConfig(configData);
			timer.Once(0.1f, ()=> SaveConfig(configData));
        }        
		
        private void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
		
        #endregion
		
		#region Data
		
		private static Dictionary<ulong, PData> PlayerData = new Dictionary<ulong, PData>();
		
		private class PData
		{
			public int PumpkinScores;	// pumpkin
			public int CornScores;		// corn
			public int HempScores;		// hemp
			public int PotatoScores;	// potato
			public int EggScores;		// egg
			public int OysterScores;	// oyster
			public int UsedScores;	
		}
		
		private void LoadData() => PlayerData = Interface.GetMod().DataFileSystem.ReadObject<Dictionary<ulong, PData>>("FarmerData");					
		
		private static void SaveData() => Interface.GetMod().DataFileSystem.WriteObject("FarmerData", PlayerData);		
		
		#endregion
		
	}
	
}	

// --- End of file: Farmer.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BloodRust-fuuu/XpSystem.cs ---
// --- Original Local Path: BloodRust-fuuu/XpSystem.cs ---

﻿using System.Collections.Generic;
using Oxide.Core;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("XpSystem", "TopPlugin.ru", "3.0.0")]
    public class XpSystem : RustPlugin
    {
        #region Класс
        private Dictionary<ulong, PlayerSetting> playerSettings;
        public class PlayerSetting
        {
            [JsonProperty("Ник игрока")] public string DisplayName;
            [JsonProperty("XP игрока")] public float Xp;
        }

        public class Settings
        {
            [JsonProperty("Xp за убийство игрока")] public float KillPlayer;
            [JsonProperty("Xp за сбитие вертолета")] public float KillHeli;
            [JsonProperty("Xp за уничтожение танка")] public float KillBradley;
            [JsonProperty("Xp за добычу ресурсов")] public float Gather;
            [JsonProperty("Стартовый баланс игрока")] public float StartBalance;
        }
        #endregion

        #region Конфиг
        public Configuration config;
        public class Configuration
        {
            [JsonProperty("Настройки")] public Settings settings = new Settings();
            public static Configuration GetNewCong()
            {
                return new Configuration
                {
                    settings = new Settings
                    {
                        KillPlayer = 20f,
                        KillHeli = 20f,
                        KillBradley = 25f,
                        Gather = 1f,
                        StartBalance = 0f
                    }
                };
            }
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config?.settings == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Ошибка чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewCong();
        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion

        #region Хуки
        void OnServerInitialized()
        {
            PrintWarning("\n-----------------------------\n" +
            "     Author - https://topplugin.ru/\n" +
            "     VK - https://vk.com/rustnastroika\n" +
            "     Discord - https://discord.com/invite/5DPTsRmd3G\n" +
            "-----------------------------");
            if (Interface.Oxide.DataFileSystem.ExistsDatafile("XpSystem/Player"))
                playerSettings = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, PlayerSetting>>("XpSystem/Player");
            else
                playerSettings = new Dictionary<ulong, PlayerSetting>();

            foreach (var check in BasePlayer.activePlayerList)
                OnPlayerConnected(check);
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (!playerSettings.ContainsKey(player.userID))
                playerSettings.Add(player.userID, new PlayerSetting { DisplayName = player.displayName.ToUpper(), Xp = config.settings.StartBalance });
        }

        void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("XpSystem/Player", playerSettings);
        }

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            SaveData();
        }

        void Unload()
        {
            SaveData();
        }

        #region Добыча xp
        void OnPlayerDie(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null || info == null) return;
            BasePlayer player = null;

            if (info.InitiatorPlayer != null)
            {
                player = info.InitiatorPlayer;
                playerSettings[player.userID].Xp += config.settings.KillPlayer;
            }
        }

        public ulong lastDamageName;
        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity is BaseHelicopter && info.Initiator is BasePlayer)
                lastDamageName = info.Initiator.ToPlayer().userID;
            if (entity is BradleyAPC && info.Initiator is BasePlayer)
                lastDamageName = info.Initiator.ToPlayer().userID;
        }

        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null || info == null) return;
            BasePlayer player = null;

            if (entity is BradleyAPC)
            {
                player = BasePlayer.FindByID(lastDamageName);
                playerSettings[player.userID].Xp += config.settings.KillBradley;
                return;
            }

            if (entity is BaseHelicopter)
            {
                player = BasePlayer.FindByID(lastDamageName);
                playerSettings[player.userID].Xp += config.settings.KillHeli;
                return;
            }
        }

        void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            if (item.info.shortname == "hq.metal.ore")
            {
                return;
            }
            playerSettings[player.userID].Xp += config.settings.Gather;
        }
        #endregion
        #endregion

        #region Команды
        [ConsoleCommand("balance")]
        void ConsoleCommand(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (!player.IsAdmin)
            {
                SendReply(player, "Отказано в доступе!");
                return;
            }
            if (args.Args == null || args.Args.Length < 1)
            {
                player.ConsoleMessage("Команда для выдачи баланса: balance steamid кол-во");
                return;
            }
            BasePlayer targetPlayer = BasePlayer.Find(args.Args[0]);
            if (targetPlayer == null)
            {
                player.ConsoleMessage("Игрок не найден");
                return;
            }
            int change;
            if (!int.TryParse(args.Args[1], out change))
            {
                Puts("В сумме необходимо ввести число");
                return;
            }
            player.ConsoleMessage($"Игроку {targetPlayer} был выдан баланс, в размере {change}$.");
            playerSettings[player.userID].Xp += change;
            SaveData();

        }

        [ConsoleCommand("balances")]
        void ServerCommand(ConsoleSystem.Arg args)
        {
            if (args.Player() != null && !args.Player().IsAdmin) return;
            if (args.Args == null || args.Args.Length < 1)
            {
                Puts("Команда для выдачи баланса: balances steamid кол-во");
                return;
            }
            var targetPlayer = BasePlayer.Find(args.Args[0]);
            if (targetPlayer == null)
            {
                Puts("Игрок не найден");
                return;
            }
            int change;
            if (!int.TryParse(args.Args[1], out change))
            {
                Puts("В сумме необходимо ввести число");
                return;
            }
            Puts($"Игроку {targetPlayer} был выдан баланс, в размере {change}$");
            playerSettings[targetPlayer.userID].Xp += change;
            SaveData();
        }

        [ConsoleCommand("clear.data")]
        void ConsoleClear(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (!player.IsAdmin)
            {
                SendReply(player, "Отказано в доступе!");
                return;
            }
            playerSettings.Clear();
            player.ConsoleMessage($"Вы успешно очистили дату {Name}");
            player.SendConsoleCommand("o.reload XpSystem");
        }
        #endregion

        #region Апи
        float API_GetXp(ulong userid)
        {
            return playerSettings[userid].Xp;
        }

        void API_AddBalance(ulong userid, float balance)
        {
            playerSettings[userid].Xp += balance;
            return;
        }

        void API_ShopRemBalance(ulong userid, float balance)
        {
            if (playerSettings[userid].Xp >= balance)
            {
                playerSettings[userid].Xp -= balance;
            }
            else
            {
                playerSettings[userid].Xp = 0f;
            }
            return;
        }
        #endregion
    }
}


// --- End of file: XpSystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BloodRust-fuuu/Mush.cs ---
// --- Original Local Path: BloodRust-fuuu/Mush.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.SceneManagement;
using Facepunch;

namespace Oxide.Plugins
{
    [Info("Mush", "TopPlugin.ru", "3.0.0")]
    public class Mush : RustPlugin
    {
        #region Classess

        private class Case
        {
            [JsonProperty("Количество грибов")]
            public int MushAmount;
            [JsonProperty("Ссылка на изображение")]
            public string ImageURL;
            [JsonProperty("СкинИД предмета")]
            public ulong SkinID;
            [JsonProperty("Предметы выпадающие (shortname:кол-во)")]
            public List<List<string>> Items = new List<List<string>>();
        }

        private class Configuration
        {
            [JsonProperty("Скин ИД гриба")]
            public ulong SkinID;
            [JsonProperty("Количество грибов на карте")]
            public int MushAmount = 1000;
            [JsonProperty("Доступные кейсы для получения")]
            public List<Case> Cases = new List<Case>();

            public static Configuration Generate()
            {
                return new Configuration
                {
                    Cases = new List<Case>
                    {
                        new Case
                        {
                            MushAmount = 10,
                            ImageURL = "https://i.ibb.co/Vg8drxC/rxQI7bS.png",
                            SkinID = 1838629777,
                            Items = new List<List<string>>
                            {
                                new List<string> { "stonehatchet:1","stone.pickaxe:1" },
                                new List<string> { "bow.hunting:1","arrow.wooden:16" },
                                new List<string> { "wood.armor.helmet:1","wood.armor.jacket:1","wood.armor.pants:1" },
                                new List<string> { "workbench1:1" },
                                new List<string> { "knife.combat:1" },
                            }
                        },
                        new Case
                        {
                            MushAmount = 30,
                            ImageURL   = "https://i.ibb.co/jMpzknj/ILxvRqK.png",
                            SkinID = 1838630959,
                            Items = new List<List<string>>
                            {
                                new List<string> { "crossbow:1","arrow.wooden:16" },
                                new List<string> { "bow.compound:1","arrow.wooden:30" },
                                new List<string> { "shotgun.waterpipe:1","ammo.handmade.shell:5" },
                                new List<string> { "pickaxe:1" },
                                new List<string> { "hatchet:1" }
                            }
                        },
                        new Case
                        {
                            MushAmount = 70,
                            ImageURL   = "https://i.ibb.co/rQyyYH1/bAB1hin.png",
                            SkinID = 1838632386,
                            Items = new List<List<string>>
                            {
                                new List<string> { "jackhammer:1" },
                                new List<string> { "chainsaw:1","lowgradefuel:50" },
                                new List<string> { "ammo.shotgun:10","shotgun.double:1" },
                                new List<string> { "pistol.revolver:1", "ammo.pistol:45"},
                                new List<string> { "syringe.medical:2", "largemedkit:1" }
                            }
                        },
                        new Case
                        {
                            MushAmount = 150,
                            ImageURL   = "https://i.ibb.co/Xj54LZ8/Z5i1Lng.png",
                            SkinID = 1838632681,
                            Items = new List<List<string>>
                            {
                                new List<string> { "pistol.semiauto:1", "ammo.pistol:60" },
                                new List<string> { "shotgun.pump:1", "ammo.shotgun:28" },
                                new List<string> { "pistol.python:1", "ammo.pistol:60"},
                                new List<string> {"keycard_green:1","keycard_red:1", "keycard_blue:1", "hazmatsuit:1", "fuse:1"},
                                new List<string> { "flamethrower:1", "lowgradefuel:200"},
                            }
                        },
                        new Case
                        {
                            MushAmount = 250,
                            ImageURL   = "https://i.ibb.co/5rCKmrS/6E16pOU.png",
                            SkinID = 1838649876,
                            Items = new List<List<string>>
                            {
                                new List<string> { "coffeecan.helmet:1","roadsign.kilt:1", "roadsign.gloves:1", "roadsign.jacket:1" },
                                new List<string> { "smg.2:1", "ammo.pistol:90"},
                                new List<string> { "rifle.semiauto:1","ammo.rifle:80"},
                                new List<string> { "grenade.beancan:5"},
                                new List<string> { "floor.ladder.hatch:1","wall.frame.garagedoor:1"}
                            }
                        },
                        new Case
                        {
                            MushAmount = 350,
                            ImageURL   = "https://i.ibb.co/NW5CwWR/41Cf838.png",
                            SkinID = 1838649325,
                            Items = new List<List<string>>
                            {
                                new List<string> { "explosive.satchel:3" },
                                new List<string> { "weapon.mod.8x.scope:1", "rifle.bolt:1", "ammo.rifle:35"},
                                new List<string> { "smg.thompson:1", "ammo.pistol:90"},
                                new List<string> { "grant.group %STEAMID% lite 7d"},
                                new List<string> { "workbench2:1"}
                            }
                        },
                        new Case
                        {
                            MushAmount = 400,
                            ImageURL   = "https://i.ibb.co/sjC9X4d/sGm4767.png",
                            SkinID = 1838649325,
                            Items = new List<List<string>>
                            {
                                new List<string> { "rifle.semiauto:1","weapon.mod.silencer:1","ammo.rifle.explosive:64"},
                                new List<string> { "smg.mp5:1","ammo.pistol:90"},
                                new List<string> { "pistol.m92:1", "ammo.pistol:60"},
                                new List<string> { "wall.external.high.stone:1","gates.external.high.stone:1"},
                                new List<string> { "supply.signal:1"}
                            }
                        },
                        new Case
                        {
                            MushAmount = 450,
                            ImageURL   = "https://i.ibb.co/drLfbHV/pIIumZB.png",
                            SkinID = 1838643433,
                            Items = new List<List<string>>
                            {
                                new List<string> { "rifle.m39:1","weapon.mod.holosight:1","ammo.rifle:128"},
                                new List<string> { "rifle.lr300:1","weapon.mod.holosight:1","ammo.rifle:128"},
                                new List<string> { "rocket.launcher:1","ammo.rocket.basic:1"},
                                new List<string> { "door.hinged.toptier:1", "door.double.hinged.toptier:1"},
                                new List<string> { "workbench3:1"}
                            }
                        },
                        new Case
                        {
                            MushAmount = 500,
                            ImageURL   = "https://i.ibb.co/C23NG3Y/7zUn22E.png",
                            SkinID = 1838642505,
                            Items = new List<List<string>>
                            {
                                new List<string> { "grant.group %STEAMID% nitro 7d"},
                                new List<string> { "metal.facemask:1", "metal.plate.torso:1"},
                                new List<string> { "rifle.bolt:1", "rifle.ak:1", "ammo.rifle:128"},
                                new List<string> { "lmg.m249:1","weapon.mod.holosight:1","ammo.rifle:128"},
                                new List<string> { "explosive.timed:1"}
                            }
                        },
                    }
                };
            }
        }

        private class DataBase
        {
            public Dictionary<ulong, PlayerDataBase> Players = new Dictionary<ulong, PlayerDataBase>();
        }

        private class PlayerDataBase
        {
            public int FullCount;
            public int Count;
        }

        #endregion

        #region Variables

        [PluginReference] 
		private Plugin ImageLibrary;
		
		private static System.Random Rnd = new System.Random();
		private static List<ulong> NeedInitPlayers = new List<ulong>();
		
        private static DataBase Base = new DataBase();
        private static Configuration Settings;
		private static List<BaseEntity> MushList = new List<BaseEntity>();
		private bool init = false;
		
		public List<string> CaseItems = new List<string>()
        {
            "https://i.imgur.com/7Mi4uQj.png",
            "https://i.imgur.com/J7WAiqy.png",
            "https://i.imgur.com/CCl6cR0.png",
            "https://i.imgur.com/khDM9Tf.png",
            "https://i.imgur.com/Qn9BGET.png",
            "https://i.imgur.com/fANuZsi.png",
            "https://i.imgur.com/WpDKf0n.png",
            "https://i.imgur.com/IYHgljB.png",
            "https://i.imgur.com/RAHGm4t.png"
        };

        #endregion

        #region Initialization 

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                Settings = Config.ReadObject<Configuration>();
            }
            catch
            {
                PrintWarning($"Error reading config, creating one new config!");
                LoadDefaultConfig();
            }

            SaveConfig();
        }
		
		private void LoadData()
        {
            try
            {
                Base = Interface.Oxide.DataFileSystem.ReadObject<DataBase>(Name);
                if (Base == null)
                    Base = new DataBase();
            }
            catch
            {
                Base = new DataBase();
            }
            init = true;
        }
		
		private void SaveData()
        {
            if (Base != null)
            Interface.Oxide.DataFileSystem.WriteObject(Name, Base);
        }

        protected override void LoadDefaultConfig() => Settings = Configuration.Generate();
        protected override void SaveConfig() => Config.WriteObject(Settings);
		
		#endregion             

		#region Hooks
		
        private void OnNewSave()
        {
            if (!init)
            {
                timer.Once(1f, () => OnNewSave());
                return;
            }
            Base.Players.Clear();
            SaveData();

            PrintWarning("Wiped detected! Clear data players");
        }                
        
		private void OnPlayerConnected(BasePlayer player)
        {
            if (!Base.Players.ContainsKey(player.userID))
            {
                Base.Players.Add(player.userID, new PlayerDataBase() { Count = 0, FullCount = 0 });
            }
			
			if (!NeedInitPlayers.Contains(player.userID))
				NeedInitPlayers.Add(player.userID);
        }  
		
        private void OnServerInitialized()
        {
            PrintWarning("\n-----------------------------\n" +
            "     Author - https://topplugin.ru/\n" +
            "     VK - https://vk.com/rustnastroika\n" +
            "     Discord - https://discord.com/invite/5DPTsRmd3G\n" +
            "-----------------------------");
			MushList.Clear();
            LoadData();
			DisableDefaultMushes();
            
            CaseItems.ForEach(image => ImageLibrary.Call("AddImage", image, image));
            ImageLibrary.Call("AddImage", "https://i.imgur.com/r3Zp9Dq.png", "Mush_BG");                        
            ImageLibrary.Call("AddImage", "https://i.imgur.com/x9MrQGP.png", "Mush_IC");
            ImageLibrary.Call("AddImage", "https://i.imgur.com/8uu3MSz.png", "Mush_Close");
            ImageLibrary.Call("AddImage", "https://i.imgur.com/597k7Xs.png", "Mush_Left"); 
            ImageLibrary.Call("AddImage", "https://i.imgur.com/twY7dLp.png", "Mush_Right");

            foreach (var check in Settings.Cases)            
                ImageLibrary.Call("AddImage", check.ImageURL, $"Mush.{Settings.Cases.IndexOf(check)}");            

            BasePlayer.activePlayerList.ToList().ForEach(OnPlayerConnected);						            		
			CommunityEntity.ServerInstance.StartCoroutine(SpawnToads());			            
        }
		
		private void Unload()
        {
            MushList.ForEach(p => { if (p != null && !p.IsDestroyed) p.Kill(); });
            SaveData();
			
			foreach (var player in BasePlayer.activePlayerList)
			{
				CuiHelper.DestroyUi(player, LayerMain);
				CuiHelper.DestroyUi(player, InitPanel);
			}
        }

        object CanCombineDroppedItem(DroppedItem drItem, DroppedItem anotherDrItem)
        {
            if (drItem.item.info.itemid == -1002156085 && drItem.item.info.itemid == anotherDrItem.item.info.itemid && drItem.item.skin != anotherDrItem.item.skin) return false;
            if (drItem.item.info.itemid == 844440409 && drItem.item.info.itemid == anotherDrItem.item.info.itemid && drItem.item.skin != anotherDrItem.item.skin) return false;
            if (drItem.item.skin != anotherDrItem.item.skin) return false;

            return null;
        }

        object CanStackItem(Item item, Item anotherItem)
        {
            if (item.info.itemid == -1002156085 && item.skin != anotherItem.skin) return false;
            if (item.info.itemid == 844440409 && item.skin != anotherItem.skin) return false;
            if (item.skin != anotherItem.skin) return false;
            return null;
        }
		
		object OnItemAction(Item item, string action, BasePlayer player)
        {
            if (item.info.shortname != "easter.goldegg") return null;

            var enter = Settings.Cases.FirstOrDefault(p => (ulong)p.SkinID == item.skin);
            if (enter == null) return null;

            var result = enter.Items.GetRandom();
            if (result.Any(p => !p.Contains(":")))
            {
                if (Oxide.Core.Random.Range(0, 100) > 50)
                {
                    OnItemAction(item, action, player);
                    return false;
                }
            }

            foreach (var check in result)
            {
                if (check.Contains(":"))
                {
                    var items = ItemManager.CreateByPartialName(check.Split(':')[0], int.Parse(check.Split(':')[1]));
                    if (!items.MoveToContainer(player.inventory.containerMain))
                    {
                        items.Drop(player.transform.position, Vector3.zero);
                        player.ChatMessage($"У вас не хватило места, предметы выбрашены на пол!");
                    }
                }
                else
                {
                    player.ChatMessage($"Вы получили <color=orange>редкую</color> привилегию!");
                    Server.Command(check.Replace("%STEAMID%", player.UserIDString));
                }
            }

            if (item.amount > 1)
                item.amount--;
            else item.DoRemove();

            return false;
        }

        private object OnItemSplit(Item item, int amount)
        {
            if (Settings.Cases.Any(p => p.SkinID == item.skin))
            {
                Item x = ItemManager.CreateByPartialName(item.info.shortname, amount);
                x.name = item.name;
                x.skin = item.skin;
                item.amount -= amount;
                item.MarkDirty();
                x.MarkDirty();
                return x;
            }

            if (item.info.shortname == "mushroom" && item.skin == Settings.SkinID)
            {
                Item byItemId = ItemManager.CreateByItemID(item.info.itemid, 1, item.skin);
                item.amount -= amount;
                byItemId.amount = amount;
                byItemId.name = item.name;
                item.MarkDirty();
                return byItemId;
            }

            return null;
        }
     
        private void OnCollectiblePickup(Item item, BasePlayer player)
        {
            if (item.info.shortname != "mushroom") return;
            if (!Base.Players.ContainsKey(player.userID))
            {
                Base.Players.Add(player.userID, new PlayerDataBase() { Count = 0, FullCount = 0 });
            }								
            item.skin = Settings.SkinID;
            Base.Players[player.userID].Count+=item.amount;
            Base.Players[player.userID].FullCount+=item.amount;

			timer.Once(1.5f, ()=>
			{
				if (player != null)
				{
					string position = player.transform.position.ToString();
					var ent = CreateMush();
					var randomPos = GetRandomPosition();
					ent.transform.position = (Vector3)randomPos;
					ent.Spawn();
					MushList.Add(ent);
				}
			});
        }
		
		#endregion
		
		#region Fill
		
		private void DisableDefaultMushes()
		{
			var allSpawnPopulations = SpawnHandler.Instance.AllSpawnPopulations;
            SpawnHandler.Instance.StopCoroutine("SpawnTick");
                        			
			SpawnDistribution[] spawndists = SpawnHandler.Instance.SpawnDistributions;
			for (int i = 0; i < allSpawnPopulations.Length; i++)
			{				
				if (!(allSpawnPopulations[i] == null) && allSpawnPopulations[i].name.Contains("mushroom"))
				{										
					allSpawnPopulations[i]._targetDensity = 0;			
					SpawnHandler.Instance.SpawnInitial(allSpawnPopulations[i], spawndists[i]);					
				}
			}			
            
            SpawnHandler.Instance.StartCoroutine("SpawnTick");
						
			foreach (var mush in BaseNetworkable.serverEntities.Where(p => p != null && p.PrefabName.Contains("mushroom-cluster-")).ToList())
				if (mush != null && !mush.IsDestroyed)				
					mush.Kill();
		}
		
		private BaseEntity InstantiateEntity(string type, Vector3 position, Quaternion rotation)
        {
            var gameObject = Instantiate.GameObject(GameManager.server.FindPrefab(type), position, rotation);
            gameObject.name = type;

            SceneManager.MoveGameObjectToScene(gameObject, Rust.Server.EntityScene);

            UnityEngine.Object.Destroy(gameObject.GetComponent<Spawnable>());

            if (!gameObject.activeSelf)
                gameObject.SetActive(true);

            BaseEntity component = gameObject.GetComponent<BaseEntity>();
            return component;
        }
		
        private BaseEntity CreateMush()
        {
            BaseEntity entity = InstantiateEntity($@"assets/bundled/prefabs/autospawn/collectable/mushrooms/mushroom-cluster-{Rnd.Next(1,3)==1?"5":"6"}.prefab", new Vector3(), new Quaternion());
			return entity;
        }
		
		private static Vector3 GetRandomPosition()
        {
            var pos = Vector3.zero + new Vector3(Oxide.Core.Random.Range(-World.Size / 2.2f, World.Size / 2.2f), 0, Oxide.Core.Random.Range(-World.Size / 2.2f, World.Size / 2.2f));
            pos.y = TerrainMeta.HeightMap.GetHeight(pos);

            if (pos.y < 0.2f)
                return GetRandomPosition();
			
            List<BaseEntity> entities = Facepunch.Pool.GetList<BaseEntity>();
            Vis.Entities(pos, 1.5f, entities);
            int count = entities.Count;
            if (count > 0)						
                return GetRandomPosition();

            return pos;
        }  
		
		private IEnumerator SpawnToads()
		{
			for (int i = 0; i < Settings.MushAmount; i++)
            {
                var ent = CreateMush();
                var randomPos = GetRandomPosition();
                if (randomPos == null) continue;
                ent.transform.position = randomPos;
                ent.Spawn();
                MushList.Add(ent);
				
				if (i % 3 == 0)
					yield return null;
            }
			
			PrintWarning($"The plugin Mush was loaded successfully, mushrooms on the server added: {Settings.MushAmount}, current {BaseNetworkable.serverEntities.Where(p => p.PrefabName.Contains("mushroom-cluster-")).ToList().Count}");
			timer.Every(310, SaveData);
		}        
        
        #endregion

        #region Player Commands

		[ConsoleCommand("mush.top")]
        private void cmdMushTop10(ConsoleSystem.Arg args)
        {
            if (args.Args == null) return;
            int amount;
            if (!int.TryParse(args.Args[0], out amount)) return;
            var top = Base.Players.ToList().OrderByDescending(p=> p.Value.FullCount).Select(p=> $"{covalence.Players.FindPlayerById(p.Key.ToString()).Name}: {p.Value.FullCount}").Take(amount);
            args.ReplyWith(string.Join("\n", top));
        }
				
		[ChatCommand("grib")]
        private void CmdChatMush(BasePlayer player, string command, string[] args)
        {
            if (args == null || args.Length <= 0)
            {
				if (NeedInitPlayers.Contains(player.userID))
				{
					DoInitImages(player);
					NeedInitPlayers.Remove(player.userID);
					timer.Once(0.1f, ()=> InitializeExperimentalInterface(player, -1, 0, true));
				}						
				else
					InitializeExperimentalInterface(player, -1, 0, true);
			                
                return;
            }
            if (args != null && args[0] == "top")
            {
                int i = 1;
                var top = Base.Players.ToList().OrderByDescending(p => p.Value.FullCount).Select(p => $"{i++} <color=#8ABB50>{covalence.Players.FindPlayerById(p.Key.ToString()).Name}</color>: {p.Value.FullCount}").Take(10);
                SendReply(player, $"ТОП 10 грибников за текущий вайп:\n{string.Join("\n", top)}" );
            }
        }
		
		#endregion
		
		#region Commands

        [ConsoleCommand("UI_Mush")]
        private void CmdConsoleHandler(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (!player || !args.HasArgs(1)) return;

            switch (args.Args[0].ToLower())
            {
                case "open":
                    {
                        int index;
                        if (!args.HasArgs(2) || !int.TryParse(args.Args[1], out index)) return;

                        var enter = Settings.Cases.FirstOrDefault(p => p.MushAmount == index);
                        if (enter == null || enter.MushAmount > Base.Players[player.userID].Count) return;

                        if (player.inventory.containerMain.capacity <= player.inventory.containerMain.itemList.Count)
                        {
                            player.ChatMessage($"У вас недостаточно места в инвентаре!");
                            return;
                        }

                        Base.Players[player.userID].Count -= enter.MushAmount;
                        player.ChatMessage($"Вы получили подарок в инвентарь!");

                        var item = ItemManager.CreateByName("easter.goldegg", 1, (ulong)enter.SkinID);
                        item.name = "Ящик с подарком";
                        item.MoveToContainer(player.inventory.containerMain);

                        InitializeExperimentalInterface(player,-1, Settings.Cases.IndexOf(enter) / 4);
                        break;
                    }
                case "page":
                    {
						var pg = int.Parse(args.Args[1]);
						
                        if (pg < 0 || pg > (int)Math.Ceiling(Settings.Cases.Count/4f)-1)
							return;						                        

                        InitializeExperimentalInterface(player, -1, pg);
                        break;
                    }
            }
        }

		[ConsoleCommand("grib_selectcase")]
        private void cmdSelectGriCase(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            int casse = int.Parse(args.Args[0]);
            int page = int.Parse(args.Args[1]);
            InitializeExperimentalInterface(player, casse, page, false, true);
        }   		        

        #endregion

        #region GUI
		
		private static string LayerMain = "UI_Main123";
		private static string Layer = "UI_MushLayer";
		private static string LayerCase = "UI_CaseLayer";
		private const string InitPanel = "MushInitPanel";
		
		private void InitImage(ref CuiElementContainer container, string png, string ipanel)
		{
			container.Add(new CuiElement
			{
				Name = CuiHelper.GetGuid(),
				Parent = ipanel,				
				Components =
				{
					new CuiRawImageComponent { Png = png },
					new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
				}
			});
		}
		
		private void DoInitImages(BasePlayer player)
		{
			if (player == null) return;									
			var container = new CuiElementContainer();			
			
			container.Add(new CuiPanel
			{				
				RectTransform = { AnchorMin = "1.1 1.1", AnchorMax = "1.2 1.2" },
				CursorEnabled = false
			}, "Overlay", InitPanel);
			
			InitImage(ref container, (string)ImageLibrary.Call("GetImage", "Mush_BG"), InitPanel);
			InitImage(ref container, (string)ImageLibrary.Call("GetImage", "Mush_IC"), InitPanel);
			InitImage(ref container, (string)ImageLibrary.Call("GetImage", "Mush_Close"), InitPanel);
			InitImage(ref container, (string)ImageLibrary.Call("GetImage", "Mush_Left"), InitPanel);
			InitImage(ref container, (string)ImageLibrary.Call("GetImage", "Mush_Right"), InitPanel);
			
			foreach (var check in Settings.Cases)
				InitImage(ref container, (string)ImageLibrary.Call("GetImage", $"Mush.{Settings.Cases.IndexOf(check)}"), InitPanel);
				
			CaseItems.ForEach(image => InitImage(ref container, (string)ImageLibrary.Call("GetImage", image), InitPanel));
			
			CuiHelper.DestroyUi(player, InitPanel);
			CuiHelper.AddUi(player, container);	
		}
 
        public void InitializeExperimentalInterface(BasePlayer player,int type = -1, int page = 0, bool isStart = false, bool isCase = false)
        {
			Puts($"InitializeExperimentalInterface {player} {type} {page} {isStart}");
			CuiElementContainer container = new CuiElementContainer();			
			var fadeIn = 0f;
			if (isStart)
			{
				fadeIn = 0.3f;
				timer.Once(2f, ()=> { if (player != null) CuiHelper.DestroyUi(player, InitPanel); });;
				CuiHelper.DestroyUi(player, LayerMain);												
				
				container.Add(new CuiPanel
				{
					CursorEnabled = true,
					RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
					Image = { Color = "0 0 0 0" }
				}, "Menu_UI2", LayerMain);											
				//Общий фон
				container.Add(new CuiElement
				{
					Parent = LayerMain,
					Components =
					{
						new CuiImageComponent {Color = "0.4 0.4 0.4 0.4", Material = "", FadeIn = fadeIn},
						new CuiRectTransformComponent {AnchorMin = "0.5 0.6", AnchorMax = "0.5 0.6", OffsetMin = $"-265 -160", OffsetMax = $"265 200"}
					}
				});
				//Подложка под 4 ящика
				container.Add(new CuiElement
				{
					Parent = LayerMain,
					Components =
					{
						new CuiImageComponent {Color             = "0.23 0.23 0.23 0.8", Material = "", FadeIn = fadeIn},
						new CuiRectTransformComponent {AnchorMin = "0.5 0.6", AnchorMax = "0.5 0.6", OffsetMin = $"-255 -60", OffsetMax = $"255 140"}
					}
				});												
				//Верхняя плашка Лавка грибника
				container.Add(new CuiElement
				{
					Parent = LayerMain,
					Components =
					{
						new CuiRawImageComponent {Png             = (string) ImageLibrary.Call("GetImage", "Mush_BG"), FadeIn = fadeIn},
						new CuiRectTransformComponent { AnchorMin = "0.5 0.6", AnchorMax = "0.5 0.6", OffsetMin = $"-260 140", OffsetMax = $"260 235" }
					}
				});	
				//Подложка под текст
				container.Add(new CuiElement
				{
					Name = LayerMain + "FFF",
					Parent = LayerMain,
					Components =
					{
						new CuiImageComponent {Color  = "0.2 0.2 0.2 0.5", Material = "", FadeIn = fadeIn},
						new CuiRectTransformComponent {AnchorMin = "0.5 0.6", AnchorMax  = "0.5 0.6", OffsetMin = $"-255 -155", OffsetMax = $"170 -65"}
					}
				});	
				//Панелька с грибами
				container.Add(new CuiElement
				{
					Parent = LayerMain,
					Components =
					{
						new CuiImageComponent {Color = "0.2 0.2 0.2 0.5", Material = "", FadeIn = fadeIn},
						new CuiRectTransformComponent {AnchorMin = "0.5 0.6", AnchorMax        = "0.5 0.6", OffsetMin = $"175 -140", OffsetMax = $"260 -105"}
					}
				});
				//Грибы
				container.Add(new CuiElement
				{
					Parent = LayerMain,
					Name = LayerMain + ".D",
					Components =
					{
						new CuiRawImageComponent {Png            = (string) ImageLibrary.Call("GetImage", $"Mush_IC"), FadeIn = fadeIn},
						new CuiRectTransformComponent {AnchorMin = "0.5 0.6", AnchorMax = "0.5 0.6", OffsetMin = $"180 -138", OffsetMax = $"220 -108"}
					}
				});
				//Лево
				container.Add(new CuiElement
				{
					Name = LayerMain + ".L",
					Parent = LayerMain,
					Components =
					{
						new CuiRawImageComponent {Png             = (string) ImageLibrary.Call("GetImage", "Mush_Left"), FadeIn = fadeIn},
						new CuiRectTransformComponent { AnchorMin = "0.5 0.6", AnchorMax = "0.5 0.6", OffsetMin = $"-275 30", OffsetMax = $"-250 60" }
					}
				});
				//Право
				container.Add(new CuiElement
				{
					Name = LayerMain + ".R",
					Parent = LayerMain,
					Components =
					{
						new CuiRawImageComponent {Png             = (string) ImageLibrary.Call("GetImage", "Mush_Right"), FadeIn = fadeIn},
						new CuiRectTransformComponent { AnchorMin = "0.5 0.6", AnchorMax = "0.5 0.6", OffsetMin = $"250 30", OffsetMax = $"275 60" }
					}
				});/*
				container.Add(new CuiElement
				{
					Name = LayerMain + ".C",
					Parent = LayerMain,
					Components =
					{
						new CuiRawImageComponent {Png             = (string) ImageLibrary.Call("GetImage", "Mush_Close"), FadeIn = fadeIn},
						new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"285 155", OffsetMax = $"320 190" }
					}
				});*/
				
				//CuiHelper.AddUi(player, container);
				//return;
			}
			
			if (!isCase)
			{
				CuiHelper.DestroyUi(player, LayerCase);
				
				container.Add(new CuiPanel
				{                				
					RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
					Image = { Color = "0 0 0 0" }
				}, LayerMain, LayerCase);
			}
			
            CuiHelper.DestroyUi(player, Layer);
			//Общий
            container.Add(new CuiPanel
            {                				
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0" }
            }, LayerMain, Layer);
			/*
			container.Add(new CuiButton
			{
				RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
				Button = { Color = "0 0 0 0", Material = "", Close = LayerMain },
				Text = { Text = "" }
			}, Layer);
			*/
			container.Add(new CuiElement
			{
				Parent = Layer,
				Components =
				{
					new CuiImageComponent {Color = "0 0 0 0", Material = ""},
					new CuiRectTransformComponent {AnchorMin = "0.5 0.6", AnchorMax = "0.5 0.6", OffsetMin = $"-265 -160", OffsetMax = $"265 200"}
				}
			});
			//Текст
			container.Add(new CuiElement
			{
				Name = LayerMain + ".T",
				Parent = Layer,
				Components =
				{
					new CuiImageComponent {Color  = "0 0 0 0", Material = ""},
					new CuiRectTransformComponent {AnchorMin = "0.5 0.6", AnchorMax  = "0.5 0.6", OffsetMin = $"-255 -155", OffsetMax = $"170 -65"}
				}
			});			

            if (type < 0)
            {
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 0", OffsetMax = "0 0" },
                    Text = { Text = "Собирайте грибы и покупайте за них ящики с предметами.\nЧем выше уровень, тем лучше предметы.", Align = TextAnchor.MiddleLeft, Font = "robotocondensed-bold.ttf", FontSize = 17, FadeIn = fadeIn }
                }, LayerMain + ".T");
            }
            else
            {
                container.Add(new CuiElement
                {
                    Parent = LayerMain + ".T",
                    Components =
                {
                    new CuiRawImageComponent {Color = "1 1 1 1", Png = (string)ImageLibrary.Call("GetImage", CaseItems[type]), FadeIn = fadeIn},
                    new CuiRectTransformComponent {AnchorMin = "0 0.0.9", AnchorMax = "1 0.91"}
                }
                });
            }            						            
			//Кнопка вево
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5 0.6", AnchorMax = "0.5 0.6", OffsetMin = $"-275 30", OffsetMax = $"-250 60" },
                Button = { Color = "0 0 0 0", Command = $"UI_Mush page {page - 1}" },
                Text = { Text = "" }
            }, Layer);
			//Кнопка вправо
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5 0.6", AnchorMax = "0.5 0.6", OffsetMin = $"250 30", OffsetMax = $"275 60" },
                Button = { Color = "0 0 0 0", Command = $"UI_Mush page {page + 1}" },
                Text = { Text = "" }
            }, Layer);

            var list = Settings.Cases.Skip(page * 4).Take(4);
            if (!list.Any())
            {
                InitializeExperimentalInterface(player, type, page - 1);
                return;
            }
									
			foreach (var check in list.Select((i, t) => new { A = i, B = t - 2 }))
			{
				if (!isCase)
				{
					container.Add(new CuiElement
					{
						Name = LayerMain + check.B,
						Parent = LayerCase,
						Components =
						{
							new CuiRawImageComponent {Png = (string) ImageLibrary.Call("GetImage", $"Mush.{Settings.Cases.IndexOf(check.A)}"), FadeIn = fadeIn},
							new CuiRectTransformComponent { AnchorMin = "0.5 0.6", AnchorMax = "0.5 0.6", OffsetMin = $"{5+check.B * 115} -10", OffsetMax = $"{110 + check.B * 115} 120" }
						}
					});
				}

				string text = "ПОКАЗАТЬ";
				string color = "0.33 0.52 0.71 1.00";

				if (type >= 0 && type == Settings.Cases.IndexOf(check.A))
				{
					text = Base.Players[player.userID].Count < check.A.MushAmount ? "ЗАКРЫТО" : "КУПИТЬ";
					color = Base.Players[player.userID].Count < check.A.MushAmount ? "0.74 0.51 0.38 1.00" : "0.54 0.73 0.31 1.00";
				}
				
				container.Add(new CuiButton
				{
					RectTransform = { AnchorMin = "0.5 0.6", AnchorMax = "0.5 0.6", OffsetMin = $"{5+check.B * 115} -50", OffsetMax = $"{110 + check.B * 115} -25" },
					Button = { Color = color, FadeIn = fadeIn, Command = type > -1 && type == Settings.Cases.IndexOf(check.A) ? $"UI_Mush open {check.A.MushAmount}": $"grib_selectcase {Settings.Cases.IndexOf(check.A)} {page}" },
					Text = { Text = text, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 20, FadeIn = fadeIn }
				}, Layer);
			}		
            var info = Base.Players[player.userID];
            container.Add(new CuiLabel()
            {
                RectTransform = { AnchorMin = "0.5 0.6", AnchorMax = "0.5 0.6", OffsetMin = $"215 -140", OffsetMax = $"253 -105" },
                Text = { Text = info.Count.ToString(), Align = TextAnchor.MiddleRight, Font = "robotocondensed-bold.ttf", FontSize = 20, FadeIn = fadeIn }
            }, Layer);
			//ТОП 10 игроков	

			container.Add(new CuiLabel
			{
				RectTransform = { AnchorMin = "0.09 0.32", AnchorMax = "1 0.36"},
				Text = { Text = "ТОП 10 ГРИБНИКОВ ЗА ТЕКУЩИЙ ВАЙП:", Align = TextAnchor.MiddleLeft, Font = "robotocondensed-bold.ttf", FontSize = 20, FadeIn = fadeIn }
			}, Layer );
			int cc=1;
            var top = Base.Players.ToList().OrderByDescending(p => p.Value.FullCount).Select(p => $"{cc++}) <color=#8ABB50>{covalence.Players.FindPlayerById(p.Key.ToString()).Name}</color>: {p.Value.FullCount}").Take(10);
            
			container.Add(new CuiLabel
			{
				RectTransform = { AnchorMin = "0.09 0.03", AnchorMax = "1 0.317"},
				Text = { Text = string.Join("\n", top), Align = TextAnchor.UpperLeft, Font = "robotocondensed-bold.ttf", FontSize = 16, FadeIn = fadeIn }
			}, Layer );
			//SendReply(player, $"ТОП 10 грибников за текущий вайп:\n{string.Join("\n", top)}" );
				
            CuiHelper.AddUi(player, container);
        }            
       
		private void DrawUI(BasePlayer player)
		{	
			if (NeedInitPlayers.Contains(player.userID))
			{
				DoInitImages(player);
				NeedInitPlayers.Remove(player.userID);
				timer.Once(0.1f, ()=> InitializeExperimentalInterface(player, -1, 0, true));
			}						
			else
				InitializeExperimentalInterface(player, -1, 0, true);
		}
        #endregion
        
    }
}

// --- End of file: Mush.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BloodRust-fuuu/Menu.cs ---
// --- Original Local Path: BloodRust-fuuu/Menu.cs ---

using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using UnityEngine.XR;
using WebSocketSharp;

namespace Oxide.Plugins
{
    [Info("Menu", "TopPlugin.ru", "3.0.0")]
    public class Menu : RustPlugin
    {
        #region eNums

        private enum State
        {
            None,
            Closed,
            Opened
        }

        #endregion
        
        #region Classess
 
        private class Configuration
        {
            public string ServerID = "1";
            public string ServerName = "БАТЯ ✘ MAX 5";
            
            public Dictionary<float, string> Images = new Dictionary<float, string>();

            public static Configuration Generate()
            {
                return new Configuration
                {
                    Images = new Dictionary<float, string>
                    {
                        [0f] = "https://ic.wampi.ru/2021/04/20/star_5cd1b24dedbd4bc70.png",
                        [0.05f] = "https://ic.wampi.ru/2021/04/20/star_6297f4499a942cea9.png",
                        [0.1f] = "https://ic.wampi.ru/2021/04/20/star_7e3d1a733037c24ca.png",
                        [0.15f] = "https://ic.wampi.ru/2021/04/20/star_831f42d0849450fe3.png",
                        [0.2f] = "https://ic.wampi.ru/2021/04/20/star_963105e3116ff4d96.png",
                        [0.25f] = "https://ic.wampi.ru/2021/04/20/star_100c39452d1dbeedb9.png",
                        [0.3f] = "https://ic.wampi.ru/2021/04/20/star_11ddc299d3f047b859.png",
                        [0.35f] = "https://ic.wampi.ru/2021/04/20/star_12bab753dbda836ef3.png",
                        [0.4f] = "https://ic.wampi.ru/2021/04/20/star_1352b0a4c991f9545c.png",
                        [0.45f] = "https://ic.wampi.ru/2021/04/20/star_14977af47947206953.png",
                        [0.5f] = "https://ic.wampi.ru/2021/04/20/star_15b6f76f0047938ed9.png",
                        [0.55f] = "https://ic.wampi.ru/2021/04/20/star_16d0860a3bbad25c34.png",
                        [0.6f] = "https://ic.wampi.ru/2021/04/20/star_17b635f2e49f797a22.png",
                        [0.65f] = "https://ic.wampi.ru/2021/04/20/star_1832b34b7dc5ca166c.png",
                        [0.7f] = "https://ic.wampi.ru/2021/04/20/star_1832b34b7dc5ca166c.png",
                        [0.75f] = "https://ic.wampi.ru/2021/04/20/star_19ffda2cd71c78190a.png",
                        [0.8f] = "https://ic.wampi.ru/2021/04/20/star_19ffda2cd71c78190a.png",
                        [0.85f] = "https://ic.wampi.ru/2021/04/20/star_19ffda2cd71c78190a.png",
                        [0.9f] = "https://ic.wampi.ru/2021/04/20/star_19ffda2cd71c78190a.png",
                        [0.95f] = "https://ic.wampi.ru/2021/04/20/star_19ffda2cd71c78190a.png",
                        [1.0f] = "https://ic.wampi.ru/2021/04/20/star_19ffda2cd71c78190a.png"
                    }
                };
            }
        }

        private class MenuPoint
        {
            public string ImageURL;
            public string ImageID;

            public string Command;
            public bool Active;
        }

        private class Notification
        {
            public string Title;
            public string Information;
            public string Color;

            public int Duration; 
            public string SoundEffect;
            public string ImageID;
            public string Command;
        }

        private class MenuPlayer : MonoBehaviour
        {
            private BasePlayer Player;
            private State      State;
			private int LastOnline = 0;
            private string Layer = "UI_MenuInitial2";
            public List<MenuPoint> Points = new List<MenuPoint>();

            public List<Notification> Notifications = new List<Notification>
            {
                new Notification
                {
                    Title = "ДОБРО ПОЖАЛОВАТЬ",
                    Information = Settings.ServerName,
                    
                    Color = "1 1 1 0.6",
                    Duration = 15,
                    SoundEffect = "",
                    ImageID = ""
                }
            };

            public void Awake()
            {
                Player = GetComponent<BasePlayer>();
                Points = Handler.Points.ToList();
                Notifications.AddRange(Handler.Defaults);
                
                Initialize();
            }

            public void Initialize()
            { 
                if (Player.IsReceivingSnapshot || Player.IsSleeping()) 
                {
                    Invoke(nameof(Initialize), 1f);
                    return;
                }

                State = State.Closed;
                InitializeLayers();
                InitializeMenu();
                
                DoNotification(false);
            }

            public void CloseNotification()
            {
                DoNotification(false); 
            }

            public void DoNotification(bool @new)
            {
                if (@new && IsInvoking(nameof(CloseNotification)))
                {
                    return;
                }
                
                var notify = Notifications.FirstOrDefault();
                if (notify == null)
                {
                    for (int i = 0; i < 5; i++)
                        CuiHelper.DestroyUi(Player, Layer + $".Notify{i}");
                    
                    if (IsInvoking(nameof(CloseNotification)))
                        CancelInvoke(nameof(CloseNotification));
                    
                    StopAllCoroutines();
                    return;
                }
                
                DestroyNotification(notify);
                
                if (IsInvoking(nameof(CloseNotification)))
                    CancelInvoke(nameof(CloseNotification));
                
                Invoke(nameof(CloseNotification), notify.Duration);
                
                Notifications.Remove(notify);
            }

            public void DestroyNotification(Notification notification)
            {
                for (int i = 0; i < 5; i++)
                    CuiHelper.DestroyUi(Player, Layer + $".Notify{i}");

                StopAllCoroutines();
                StartCoroutine(DrawNotification(notification));
            }

            public void InitializeMenu(bool fromMenu = false) 
            {
                InitializeLayers();
                if (fromMenu && Notifications.All(p => !p.Title.ToLower().Contains("добро")))
                {
                    Notifications.Clear();
                    DoNotification(false);  
                    
                    Notifications.Add(new Notification
                    {
                        Title = Settings.ServerName, 
                        Information = $"Игроков онлайн: {BasePlayer.activePlayerList.ToList().Count + ServerMgr.Instance.connectionQueue.joining.Count} {(ServerMgr.Instance.connectionQueue.queue.Count > 0 ? ("(" + ServerMgr.Instance.connectionQueue.queue.Count +  " в очереди" + ")") : (ServerMgr.Instance.connectionQueue.joining.Count > 0 ? ("(" + ServerMgr.Instance.connectionQueue.joining.Count +  " присоединяется" + ")") : ""))}",
                        Color = "1 1 1 0.5",
                        Duration = 360,
                        SoundEffect = "",
                        ImageID = ""
                    });
                    DoNotification(true);
                }
                CuiElementContainer container = new CuiElementContainer();
                
                container.Add(new CuiPanel
                {
                    RectTransform = {AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "0 0", OffsetMax = "0 0"},
                    Image         = {Color     = "0 0 0 0"}
                }, "Overlay4", Layer); 

                CuiHelper.AddUi(Player, container);

                CancelInvoke(nameof(UpdateOnline));
                
                UpdateOnline(true);
                InvokeRepeating(nameof(UpdateOnline), 5f, 5f);
            }

            public void UpdateOnline(bool update=false)
            {
				int online = BasePlayer.activePlayerList.ToList().Count;
				if (!update) if (LastOnline==online) return;
				LastOnline = online;
                CuiHelper.DestroyUi(Player, Layer + ".Online");
                CuiElementContainer container = new CuiElementContainer();

                float imageId = 0f;
                //Выстраиваем прогресс от онлайна
				imageId = (float)online/(float)ConVar.Server.maxplayers;
                
                if (imageId % 0.05f != 0)
                    imageId += 0.05f - imageId % 0.05f; 
                
                container.Add(new CuiElement
                {
                    Parent = Layer,
                    Name   = Layer + ".Online", 
                    Components =
                    {
                        new CuiRawImageComponent { Png = Handler.PrepareImages[imageId.ToString()], Color = "1 1 1 0.9",FadeIn=update==true?3f:0f },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 -64", OffsetMax = "54 -10" }
                    }
                });

                container.Add(new CuiButton
                {
                    RectTransform = {AnchorMin = "0 0", AnchorMax   = "1 1", OffsetMin = "0 0", OffsetMax = "0 0"},
                    Button        = {Color     = "0 0 0 0", Command = "chat.say /menu"},
                    Text          = {Text      = ""}
                }, Layer + ".Online");

                if (State == State.Opened)
                {
                    container.Add(new CuiLabel
                    {
                        RectTransform = {AnchorMin = "0 0", AnchorMax                                   = "1 0", OffsetMin                        = "-2 -15", OffsetMax = "0 5"},
                        Text          = { Text      = online.ToString(), Font = "robotocondensed-regular.ttf", FontSize = 15, Align = TextAnchor.MiddleCenter, Color = "0.9 0.1 0.2 1" }
                    }, Layer + ".Online", Layer + ".VisualUpdate");
                }

                CuiHelper.AddUi(Player, container);
            }

            public IEnumerator DrawNotification(Notification notification)
            {
                yield return new WaitForSeconds(1f);
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    FadeOut = 1f,
                    Name = Layer + ".Notify4",
                    Parent = Layer + ".Notify",
                    Components =
                    {
                        new CuiRawImageComponent {FadeIn         = 1f, Png          = Handler.NotificationImage, Color = notification.Color, Material = ""},
                        new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin                 = "0 0", OffsetMax = "0 1" } 
                    } 
                });

                if (!notification.ImageID.IsNullOrEmpty())
                {
                    container.Add(new CuiElement
                    {
                        FadeOut = 1f,
                        Name = Layer + ".Notify3",
                        Parent = Layer + ".Notify",
                        Components =
                        {
                            new CuiRawImageComponent {FadeIn         = 1f, Png          = notification.ImageID, Color = "1 1 1 0.5" },
                            new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin            = "0 0", OffsetMax = "0 0" } 
                        }
                    }); 
                }
                 
                container.Add(new CuiLabel
                {
                    FadeOut = 1f,
                    RectTransform = {AnchorMin = "0.13 0.46", AnchorMax        = "4 1", OffsetMax              = "0 0"},
                    Text          = {FadeIn = 1f,Text      = notification.Title, Align = TextAnchor.LowerLeft, Font = "robotocondensed-bold.ttf", FontSize = 16}
                }, Layer + ".Notify", Layer + ".Notify1");
                
                container.Add(new CuiLabel 
                {
                    FadeOut = 1f,
                    RectTransform = {AnchorMin = "0.13 0", AnchorMax        = "4 0.46", OffsetMax              = "0 0"},
                    Text          = {FadeIn = 1f,Text      = notification.Information, Align = TextAnchor.UpperLeft, Font = "robotocondensed-regular.ttf", FontSize = 10}
                }, Layer + ".Notify", Layer + ".Notify2");

                container.Add(new CuiButton
                {
                    RectTransform = {AnchorMin = "0.08 0", AnchorMax = "0.8 1", OffsetMax = "0 0"},
                    Button        = {Color     = "0 0 0 0", Command = $"UI_MenuHandler skip " + notification.Command },
                    Text          = {Text      = ""}
                }, Layer + ".Notify");
                
				CuiHelper.AddUi(Player, container);

                if (!notification.SoundEffect.IsNullOrEmpty())
                {
                    while (true)
                    {
                        Effect effect = new Effect(notification.SoundEffect, Player.transform.position, Vector3.zero);
                        EffectNetwork.Send(effect, Player.net.connection);

                        yield return new WaitForSeconds(5);
                    }
                }
                yield return 0;
            }

            public void OpenMenu()
            {
                CuiHelper.DestroyUi(Player, Layer + ".Menu");
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name   = Layer + ".Menu",
                    Parent = Layer,
                    Components =
                    {
                        new CuiRawImageComponent { FadeIn = 1f, Png           = Handler.MenuHeaderImage, Color = "1 1 1 0.9"},
                        new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax               = "1 0", OffsetMin = "-1.5 -86", OffsetMax = "52.5 -40" }
                    }
                });

                float topPosition = 0f;

                float counter = 0;
                
                /*CuiHelper.AddUi(Player, container);
                foreach (var check in Handler.Points)
                {
                    InitializePoint(check, false, true); 
                }  
                 
                if (IsInvoking(nameof(UpdateOnline)))
                    CancelInvoke(nameof(UpdateOnline));*/
                
                //UpdateOnline();
                //InvokeRepeating(nameof(UpdateOnline), 5f, 5f);
            }

            public void InitializePoint(MenuPoint point, bool active, bool initial)
            {  
                point.Active = active;
                
                int index = Handler.Points.IndexOf(point); 
                string layerName = Layer + $"MP.{index}";
                CuiHelper.DestroyUi(Player, layerName);

                CuiElementContainer container = new CuiElementContainer();
                
                float topPosition = -38f * index;
                float counter = 0.5f * index;
                
                /*container.Add(new CuiPanel
                {
                    RectTransform = {AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = $"9 {topPosition - 36 + 4}", OffsetMax = $"-9 {topPosition + 4}"},
                    Image         = {FadeIn = 1f + counter,Color     = "0 0 0 0"}
                }, Layer + ".Menu", layerName);
                
                container.Add(new CuiPanel
                {
                    RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0"},
                    Image         = {Color     = "0 0 0 0"}
                }, layerName, layerName + ".Inactive");
                
                container.Add(new CuiPanel
                { 
                    RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0"},
                    Image         = {Color     = "0 0 0 0"}
                }, layerName, layerName + ".Active");

                if (active)
                {
                    container.Add(new CuiElement
                    {
                        Parent = layerName + ".Inactive",
                        Components =
                        {
                            new CuiRawImageComponent() { Png            = Handler.ActiveImage },
                            new CuiRectTransformComponent() {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0"}
                        }
                    });
                }
                
                container.Add(new CuiElement
                {
                    Parent = layerName + ".Active",
                    Components =
                    {
                        new CuiRawImageComponent() {FadeIn = initial ? 1f + counter : 0f, Png            = point.ImageID, Color = active ? "1 1 1 1" : "1 1 1 0.5" },
                        new CuiRectTransformComponent() {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0"}
                    }
                });

                container.Add(new CuiButton
                {
                    RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0"},
                    Button        = {Color     = "0 0 0 0", Command = $"UI_MenuHandler rebuild {index} {(active ? "" : "123")}"},
                    Text          = {Text      = ""}
                }, layerName + ".Active");*/

                CuiHelper.AddUi(Player, container);
            }

            public void CloseMenu()
            {
                CuiHelper.DestroyUi(Player, Layer + ".VisualUpdate");
                for (int i = 10; i >= 0; i--)
                    CuiHelper.DestroyUi(Player, Layer + i);
                
                CuiHelper.DestroyUi(Player, Layer + ".Menu");
            }

            public void SwitchState()
            {
                State = State == State.Opened ? State.Closed : State.Opened;

                if (State == State.Opened)
                {
                    OpenMenu();
                    //UpdateOnline();
                }
                else
                {
                    CloseMenu();
                }
            }

            public void InitializeLayers()
            {
                CuiElementContainer container = new CuiElementContainer();

                CuiHelper.DestroyUi(Player, Layer);
                CuiHelper.DestroyUi(Player, "Overlay1");
                CuiHelper.DestroyUi(Player, "Overlay2");
                CuiHelper.DestroyUi(Player, "Overlay3");
                CuiHelper.DestroyUi(Player, "Overlay4");
                

                container.Add(new CuiPanel
                {
                    RectTransform = {AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMax = "0 0"},
                    Image         = {Color     = "0 0 0 0"}
                }, "Overlay", "Overlay1");
                
                container.Add(new CuiPanel 
                {
                    RectTransform = {AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMax = "0 0"},
                    Image         = {Color     = "0 0 0 0"}
                }, "Overlay", "Overlay2");
                
                container.Add(new CuiPanel
                {
                    RectTransform = {AnchorMin = "0 1", AnchorMax = "0 1", OffsetMax = "0 0"},
                    Image         = {Color     = "0 0 0 0"}
                }, "Overlay", "Overlay3");
                 
                container.Add(new CuiElement
                {
                    Name   = Layer + ".Notify",
                    Parent = "Overlay3",
                    Components =  
                    {
                        new CuiRawImageComponent {FadeIn         = 1f, Color = "1 1 1 0" },
                        new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin                 = "24 -65", OffsetMax = "290 -9" } 
                    }
                });
                
                container.Add(new CuiPanel
                {
                    RectTransform = {AnchorMin = "0 1", AnchorMax = "0 1", OffsetMax = "0 0"},
                    Image         = {Color     = "0 0 0 0"}
                }, "Overlay", "Overlay4");

                CuiHelper.AddUi(Player, container);
            }

            public void DestroyLayers()
            {
                CuiHelper.DestroyUi(Player, "Overlay1");
                CuiHelper.DestroyUi(Player, "Overlay2");
                CuiHelper.DestroyUi(Player, "Overlay3");
                CuiHelper.DestroyUi(Player, "Overlay4");
            }

            public void OnDestroy()
            {
                DestroyLayers();
            }
        }  
        
        private class MenuHandler : MonoBehaviour
        {
            public Dictionary<float, string> RawImages = new Dictionary<float, string>();

            public List<Notification> Defaults = new List<Notification>
            {
            };
            public List<MenuPoint> Points = new List<MenuPoint>
            {
                new MenuPoint
                { 
                    ImageURL = "https://i.imgur.com/Nou392v.png",
                    ImageID  = "",
                    Command  = "chat.say /store"
                },
                new MenuPoint
                {
                    ImageURL = "https://i.imgur.com/CXBatkm.png",
                    ImageID  = "",
                    Command  = "chat.say /report"
                },
                new MenuPoint
                {
                    ImageURL = "https://i.imgur.com/eFakSsx.png",
                    ImageID  = "",
                    Command  = "chat.say /help"
                },  
                new MenuPoint  
                {  
                    ImageURL = "https://i.imgur.com/JDsmlwV.png",
                    ImageID  = "",
                    Command  = "chat.say /wipe"
                }, 
                new MenuPoint
                {
                    ImageURL = "https://i.imgur.com/vhQCtI2.png",
                    ImageID  = "",
                    Command  = "chat.say /block"
                },
                new MenuPoint
                {
                    ImageURL = "https://i.imgur.com/DSiRg5v.png",
                    ImageID = "",
                    Command = "chat.say /vip"
                }, 
            };
            public Dictionary<string, string> PrepareImages = new Dictionary<string, string>();
            public string ActiveImage = "";
            public string MenuHeaderImage = "";
            public string NotificationImage = "";
            public string RaidNotification = "";
            public string BoarNotification = "";

            public void Awake()
            {
                RawImages = Settings.Images;
                Interface.Oxide.LogWarning($"Initializing menu components [Loading images]");

                _.ImageLibrary.Call("AddImage", "https://i.imgur.com/OQQbkzE.png", "ActiveImage");
                _.ImageLibrary.Call("AddImage", "https://ic.wampi.ru/2021/04/21/menu_2_2.png", "NotificationImage");
                _.ImageLibrary.Call("AddImage", "https://i.imgur.com/HiEEg07.png", "MenuHeaderImage");
                _.ImageLibrary.Call("AddImage", "https://ic.wampi.ru/2021/04/20/menu_1_7.png", "RaidNotification");
                _.ImageLibrary.Call("AddImage", "", "BoarNotification");

                foreach (var check in Defaults.Where(p => !p.ImageID.IsNullOrEmpty())) 
                {
                    _.ImageLibrary.Call("AddImage", check.ImageID, check.Title.Replace(" ", ""));
                }
                foreach (var check in RawImages)
                {  
                    _.ImageLibrary.Call("AddImage", check.Value, $"I.{check.Key}");
                    if (RawImages.ToList().IndexOf(check) % 5 == 0)
                    {
                        Interface.Oxide.LogDebug($"Loading: {(((float) RawImages.ToList().IndexOf(check) / RawImages.Count) * 100):F0}%");
                    }
                }

                foreach (var check in Points)
                {
                    _.ImageLibrary.Call("AddImage", check.ImageURL, $"M.{Points.IndexOf(check)}");
                }
                
                Interface.Oxide.LogWarning($"Parsing image components [Parsing images in 15 sec]");
                Invoke(nameof(ParseImages), 1f);
            }

            public void ParseImages()
            {
                foreach (var check in RawImages)
                {
                    var result = _.ImageLibrary.Call("GetImage", $"I.{check.Key}");
                    PrepareImages.Add(check.Key.ToString(), result.ToString());
                }
                foreach (var check in Points)
                { 
                    check.ImageID = (string) _.ImageLibrary.Call("GetImage", $"M.{Points.IndexOf(check)}");
                }
                foreach (var check in Defaults.Where(p => !p.ImageID.IsNullOrEmpty())) 
                {
                    check.ImageID = (string) _.ImageLibrary.Call("GetImage", check.Title.Replace(" ", ""));
                }
                ActiveImage = (string) _.ImageLibrary.Call("GetImage", $"ActiveImage");
                MenuHeaderImage = (string) _.ImageLibrary.Call("GetImage", $"MenuHeaderImage");
                NotificationImage = (string) _.ImageLibrary.Call("GetImage", $"NotificationImage");
                RaidNotification = (string) _.ImageLibrary.Call("GetImage", $"RaidNotification");
                BoarNotification = (string) _.ImageLibrary.Call("GetImage", $"BoarNotification");
                
                Interface.Oxide.LogError($"Saving images complete, giving components...");
                GiveComponents();
            }

            public void GiveComponents()
            {
                _.Subscribe(nameof(_.OnPlayerConnected));
                BasePlayer.activePlayerList.ToList().ForEach(p =>
                {
                    p.gameObject.AddComponent<MenuPlayer>();
                });   
            }
        }

        #endregion

        #region Variables

        private static Menu _;
        private static MenuHandler Handler;
        
        [PluginReference] private Plugin ImageLibrary;
        
        
        private static Configuration Settings = null;
        
        #endregion

        #region Initialization

        private void CloseMenu(BasePlayer player)
        {
            var obj = player.GetComponent<MenuPlayer>();
            
            
            obj.Notifications.Clear();
            obj.DoNotification(false);  
        }
        
        private void ShowMenu(BasePlayer player)
        {
            player.GetComponent<MenuPlayer>().InitializeMenu(true);
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                Settings = Config.ReadObject<Configuration>();
            }
            catch
            {
                PrintWarning($"Error reading config, creating one new config!");
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig() => Settings = Configuration.Generate();
        protected override void SaveConfig()        => Config.WriteObject(Settings);

        private void OnServerInitialized()
        {
            _ = this;

            Unsubscribe(nameof(_.OnPlayerConnected));
            Handler = ServerMgr.Instance.gameObject.AddComponent<MenuHandler>(); 
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            var obj = player.GetComponent<MenuPlayer>();
            if (obj != null) return;

            player.gameObject.AddComponent<MenuPlayer>();
        }
        
        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            var obj = player.GetComponent<MenuPlayer>();
            if (obj != null) UnityEngine.Object.Destroy(obj); 
        }
        
        private void Unload()
        {
            DestroyAll<MenuHandler>();
            DestroyAll<MenuPlayer>();
        }

        #endregion

        #region Commands

        [ConsoleCommand("UI_MenuHandler")]
        private void CmdConsoleHandler(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player == null) return;

            var obj = player.GetComponent<MenuPlayer>();
            if (obj == null) return;
            
            switch (args.Args[0].ToLower())
            {
                case "switch":
                {
                    obj.SwitchState();
                    break;
                }
                case "rebuild":
                {
                    CmdConsoleClose(args);
                    
                    int index = int.Parse(args.Args[1]);
                    var elem = Handler.Points.ElementAt(index);
                    
                    obj.InitializePoint(elem, args.HasArgs(3), false); 
                    
                    if (args.HasArgs(3))
                        player.SendConsoleCommand(elem.Command);
                    break;
                }
                case "skip":
                {
                    string result = "";
                    if (args.HasArgs(2))
                    {
                        for (int i = 1; i < args.Args.Length; i++)
                            result += args.Args[i] + " ";
                    }
                    
                    if (!result.IsNullOrEmpty())
                        player.SendConsoleCommand(result); 
                        
                    obj.DoNotification(false);
                    break;
                }
            }
        }

        [ConsoleCommand("closemenu")]
        private void CmdConsoleClose(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player == null) return;

            args.Player().SendConsoleCommand("UI_BReport closec");
            CuiHelper.DestroyUi(player, "Overlay2");
            CuiHelper.AddUi(player, new CuiElementContainer
            {
                {
                    new CuiPanel
                    {
                        RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0"},
                        Image         = {Color     = "0 0 0 0"}
                    },
                    "Overlay1", "Overlay2"
                }
            });

            var obj = player.GetComponent<MenuPlayer>();
            if (obj == null) return;
            
            foreach (var check in obj.Points)
                obj.InitializePoint(check, false, false); 
        }

        #endregion

        #region API

        [HookMethod("AddNotificationFromMenu")] 
        private void AddNotificationFromMenu(BasePlayer player, string title, string desc, string color, int duration, string sound, string imageId, string command = "")
        {
            var obj = player.GetComponent<MenuPlayer>();
            if (obj == null) return; 
            
            obj.Notifications.Clear();
            obj.Notifications.Add(new Notification
            {
                Title = title,
                Information = desc,
                Color = color,
                Duration = duration,
                SoundEffect = sound,
                ImageID = imageId,
                Command = command 
            });
            
            obj.DoNotification(false);   
        }

        [HookMethod("AddNotification")] 
        private void AddNotification(BasePlayer player, string title, string desc, string color, int duration, string sound, string imageId, string command = "")
        {
            if (player == null)
            {
                return;
            }
            
            var obj = player.GetComponent<MenuPlayer>();
            if (obj == null) return;
            
            obj.Notifications.Add(new Notification
            {
                Title = title,
                Information = desc,
                Color = color,
                Duration = duration,
                SoundEffect = sound,
                ImageID = imageId,
                Command = command 
            });
            
            obj.DoNotification(true);  
        }

        #endregion

        #region Utils

        private void DestroyAll<T>()
        {
            var objects = UnityEngine.Object.FindObjectsOfType(typeof(T));
            objects?.ToList().ForEach(UnityEngine.Object.Destroy); 
        }

        #endregion
    }
}

// --- End of file: Menu.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BloodRust-fuuu/SoReport.cs ---
// --- Original Local Path: BloodRust-fuuu/SoReport.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Facepunch.Extend;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("SoReport", "TopPlugin.ru", "3.0.0")]
    public class SoReport : RustPlugin
    {
        #region Data

        private ConfigData cfg { get; set; }

        private class ConfigData
        {
            [JsonProperty("Название сервера")] public string Lable;
            [JsonProperty("Включить дискорд?")] public bool discord;

            [JsonProperty("Dircord Report WebHook")]
            public string discordhook;

            [JsonProperty("Dircord PlayerSayDiscord WebHook")]
            public string discordhook2;
            [JsonProperty("Отправлять ли уведомления в телеграмм ?")]
            public bool TelegramUse = false; 
            [JsonProperty("Название чата(Пригласить своего бота в чат)")]
            public string chatid = "НАЗВАНИЕ ЧАТА";
            [JsonProperty("Создать своего бота через BotFather и скопировать сюда токен")]
            public string botToken = "ТОКЕН";
            [JsonProperty("Отправлять ли уведомления в вконтакте ?")]
            public bool Vkontakte = false;
            [JsonProperty("Вк админа")] public string vkadmin = "";
            [JsonProperty("VK Token группы")]
            public string vkAcces = "";

            [JsonProperty("Cooldown")] public int cooldown;
            [JsonProperty("Причина 1")] public string res1 = "МАКРОСЫ";
            [JsonProperty("Причина 2")] public string res2 = "ЧЭТЫ";
            [JsonProperty("Причина 3")] public string res3 = "БАГОЮЗ";
            [JsonProperty("Причина 4")] public string res4 = "+3";

 
            [JsonProperty("Кол-во репортов для появление в панели модератора")]
            public int kolreport = 2;

            [JsonProperty("Кол-во репортов для подсветки красный в панели модератора")]
            public int redcolor = 10;

            [JsonProperty("Кол-во проверки для подсветки зеленым в панели модератора")]
            public int greencolor = 3;

            public static ConfigData GetNewConf()
            {
                var newConfig = new ConfigData();
                newConfig.Lable = "SoReport";
                newConfig.discord = false;
                newConfig.cooldown = 30; 
                newConfig.discordhook = "";
                newConfig.discordhook2 = "";
                return newConfig;
            }
        }

        protected override void LoadDefaultConfig()
        {
            cfg = ConfigData.GetNewConf();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(cfg);
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                cfg = Config.ReadObject<ConfigData>();
            }
            catch
            {
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        Dictionary<ulong, PlayerData> _playerData = new Dictionary<ulong, PlayerData>();

        class PlayerData
        {
            public string UserName;
            public int ReportCount;
            public int AlertCount;
            public double ReportCD = CurrentTime();
            public double IsCooldown => Math.Max(ReportCD - CurrentTime(), 0);
        }

        #endregion
        #region UI

        private static string Layer = "Report";
        private string Hud = "Hud";
        private string Overlay = "Overlay";
        private string regular = "robotocondensed-regular.ttf";
        private static string Sharp = "assets/content/ui/ui.background.tile.psd";
        private static string Blur = "assets/content/ui/uibackgroundblur.mat";
        private string radial = "assets/content/ui/ui.background.transparent.radial.psd";

        private CuiPanel _fon = new CuiPanel()
        {
            RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
            Image = {Color = "0 0 0 0.87", Material = "assets/content/ui/uibackgroundblur.mat"}
        };

        private CuiPanel _mainFon = new CuiPanel()
        {
            RectTransform =
                {AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-1920 -1080", OffsetMax = "1920 1080"},
            CursorEnabled = true,
            Image = {Color = "0.211200 0.2312312 0.312312312 0"}
        };

        private CuiPanel _redPanel = new CuiPanel()
        {
            RectTransform = {AnchorMin = "0 0", AnchorMax = "0.289 1"},
            Image = {Color = "0.549 0.270 0.215 0.7", Material = ""}
        };

        private CuiPanel _modPanel = new CuiPanel()
        {
            RectTransform = {AnchorMin = "0.01 0.25", AnchorMax = "0.28 0.666358"},
            Image = {Color = HexToRustFormat("#222222CC")}
        };
        private CuiPanel _mod2Panel = new CuiPanel()
        {
            RectTransform = {AnchorMin = "0.01 0.25", AnchorMax = "0.28 0.666358"},
            Image = {Color = HexToRustFormat("#222222CC"), Material = Blur }
        };
        private CuiPanel _playersPanel = new CuiPanel()
        {
            RectTransform = {AnchorMin = "0.289 0", AnchorMax = "1 1"},
            Image = {Color = "0.117 0.121 0.109 0.95"}
        };

        private CuiButton _close = new CuiButton()
        {
            RectTransform = {AnchorMin = "0.6567709 0.6496913", AnchorMax = "0.6659723 0.6645062"},
            Button = {Close = Layer, Sprite = "assets/icons/vote_down.png", Color = "0.64 0.64 0.64 0.86",},
            Text = {Text = ""}
        };

        private void StartUi(BasePlayer player)
        {
            var cont = new CuiElementContainer();
            cont.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.276 0", AnchorMax = "0.945 1", OffsetMax = "0 0" },
                Image = { Color = "0.117 0.121 0.109 0.5" }
            }, "Menu_UI", Layer + "Main");
            if (permission.UserHasPermission(player.UserIDString, "soreport.admin"))
                cont.Add(new CuiButton()
                {
                    Text = {Text = "МОДЕРАТОР ПАНЕЛЬ", Align = TextAnchor.MiddleCenter},
                    Button = {Color = "0.64 0.64 0.64 0.35", Command = "uisoreport modmenu open"},
                    RectTransform = {AnchorMin = "0.29 0.25", AnchorMax = "0.455 0.32"}
                }, "Menu_UI", Layer + "BMod");
            CuiHelper.AddUi(player, cont);
            PlayerListLoad(player, 1);
            ReportFon(player);
        }

        private void Alert(ulong targetId)
        {
            var targetPlayer = BasePlayer.FindByID(targetId);
            if (targetPlayer == null) return;
            var cont = new CuiElementContainer();
            cont.Add(new CuiPanel()
            {
                RectTransform =
                    {AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-300 250", OffsetMax = "300 300"},
                Image = {Color = "0 0 0 0.64", Material = Blur}
            }, Overlay, "AlerUISo");
            cont.Add(new CuiElement()
            {
                Parent = "AlerUISo",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Align = TextAnchor.MiddleCenter,
                        Text =
                            "Вас вызвали на проверку напиши ваш дискорд /discord <color=purple>{ВАШ ДИСКОРД}</color>.Если вы покините сервер вы будете наказаны,за отказ вы тоже будете наказаны!"
                    },
                    new CuiRectTransformComponent() {AnchorMin = "0.09 0", AnchorMax = "0.9 1"}
                }
            });
            CuiHelper.AddUi(targetPlayer, cont);
        }

        private void ModeratorInterface(BasePlayer player, int page)
        {
            var cont = new CuiElementContainer();
            List<ulong> f;
            CuiHelper.DestroyUi(player, Layer + "Mod");
            cont.Add(_modPanel, Layer + "Main", Layer + "Mod");
            //Лейбл
            PlayerData playerData;
            if (!_playerData.TryGetValue(player.userID, out playerData)) return;
            if (page > 1)
            {
                cont.Add(new CuiButton()
                {
                    Button =
                        {Command = $"uisoreport nextpage mod {page - 1}", Color = HexToRustFormat("#4b602aCC")},
                    Text = {Text = "<", Color = HexToRustFormat("#a1e432"), Align = TextAnchor.MiddleCenter},
                    RectTransform = {AnchorMin = "0.42 0.01297505", AnchorMax = "0.4722021 0.06"}
                }, Layer + "Mod");
            }
            else
            {
                cont.Add(new CuiButton()
                {
                    Button = {Command = $"", Color = HexToRustFormat($"#24291dCC")},
                    Text = {Text = "<", Color = HexToRustFormat("#a1e432"), Align = TextAnchor.MiddleCenter},
                    RectTransform = {AnchorMin = "0.42 0.01297505", AnchorMax = "0.4722021 0.06"}
                }, Layer + "Mod");
            }

            cont.Add(new CuiButton()
            {
                Button = {Color = "0 0 0 0.64"},
                Text =
                    {Text = page.ToString(), Color = HexToRustFormat("#a1e432"), Align = TextAnchor.MiddleCenter},
                RectTransform = {AnchorMin = "0.4786112 0.01297505", AnchorMax = "0.53 0.06"}
            }, Layer + "Mod");
            cont.Add(new CuiButton()
            {
                Button = {Command = $"uisoreport nextpage mod {page + 1}", Color = HexToRustFormat("#4b602aCC")},
                Text = {Text = ">", Color = HexToRustFormat("#a1e432"), Align = TextAnchor.MiddleCenter},
                RectTransform = {AnchorMin = "0.53 0.01297505", AnchorMax = "0.59 0.06"}
            }, Layer + "Mod");
            cont.Add(new CuiElement()
            {
                Parent = Layer + "Mod",
                Components =
                {
                    new CuiTextComponent() {Text = "МОДЕРАТОР", Color = "0.64 0.64 0.64 0.86", FontSize = 20},
                    new CuiRectTransformComponent()
                        {AnchorMin = "0.03044713 0.9", AnchorMax = "0.9742392 1"}
                }
            });
            foreach (var players in _playerData.Where(p => p.Value.ReportCount >= cfg.kolreport)
                .Where(p => BasePlayer.FindByID(p.Key) != null)
                .Select((i, t) => new {A = i, B = t - (page - 1) * 8}).Skip((page - 1) * 8).Take(8))
            {
                var target = BasePlayer.FindByID(players.A.Key);
                if (players.A.Value.AlertCount >= cfg.greencolor)
                {
                    cont.Add(new CuiElement()
                    {
                        Parent = Layer + "Mod",
                        Name = Layer + "Mod" + players.B,
                        Components =
                        {
                            new CuiImageComponent()
                            {
                                Color = "0.00 0.78 0.00 0.25",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin =
                                    $"{0.03278887} {0.8 - Math.Floor((double) players.B / 1) * 0.1}",
                                AnchorMax = $"{0.976581} {0.8923218 - Math.Floor((double) players.B / 1) * 0.1}"
                            }
                        }
                    });
                }
                else if (players.A.Value.ReportCount >= cfg.redcolor)
                {
                    cont.Add(new CuiElement()
                    {
                        Parent = Layer + "Mod",
                        Name = Layer + "Mod" + players.B,
                        Components =
                        {
                            new CuiImageComponent()
                            {
                                Color = "0.50 0.00 0.00 0.35",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin =
                                    $"{0.03278887} {0.8 - Math.Floor((double) players.B / 1) * 0.1}",
                                AnchorMax = $"{0.976581} {0.8923218 - Math.Floor((double) players.B / 1) * 0.1}"
                            }
                        }
                    });
                }
                else
                {

                    cont.Add(new CuiElement()
                    {
                        Parent = Layer + "Mod",
                        Name = Layer + "Mod" + players.B,
                        Components =
                        {
                            new CuiImageComponent()
                            {
                                Color = "0.35 0.35 0.35 0.45",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin =
                                    $"{0.03278887} {0.8 - Math.Floor((double) players.B / 1) * 0.1}",
                                AnchorMax = $"{0.976581} {0.8923218 - Math.Floor((double) players.B / 1) * 0.1}"
                            }
                        }
                    });
                }

                cont.Add(new CuiElement()
                {
                    Parent = Layer + "Mod" + players.B,
                    Components =
                    {
                        new CuiRawImageComponent() {Png = GetImage(target.UserIDString)},
                        new CuiRectTransformComponent() {AnchorMin = "0 0", AnchorMax = "0.1464023 0.9851253"}
                    }
                });
                cont.Add(new CuiElement()
                {
                    Parent = Layer + "Mod" + players.B,
                    Components =
                    {
                        new CuiTextComponent()
                        {
                            Text = $" {target.displayName.ToUpper()}", Align = TextAnchor.MiddleLeft,
                            FontSize = 16
                        },
                        new CuiRectTransformComponent()
                            {AnchorMin = "0.1994236 0.2736453", AnchorMax = "1.003585 0.9851253"}
                    }
                });
                cont.Add(new CuiElement()
                {
                    Parent = Layer + "Mod" + players.B,
                    Components =
                    {
                        new CuiTextComponent()
                        {
                            Text = $"  {target.userID}", Color = "0.64 0.64 0.64 0.64",
                            Align = TextAnchor.UpperLeft, FontSize = 10, Font = regular
                        },
                        new CuiRectTransformComponent()
                            {AnchorMin = "0.1994236 0.01242494", AnchorMax = "1.003585 0.4013513"}
                    }
                });
                cont.Add(new CuiButton()
                {
                    Button =
                    {
                        Color = "0.64 0.64 0.64 0.86", Command = $"UISoReport profile {target.userID}",
                        Sprite = "assets/icons/tools.png"
                    },
                    RectTransform = {AnchorMin = "0.8615944 0", AnchorMax = "0.9975222 1"},
                    Text = {Text = ""}
                }, Layer + "Mod" + players.B);
            }

            CuiHelper.AddUi(player, cont);
        }

        private void LoadProfile(BasePlayer player, ulong targetId)
        {
            PlayerData f;
            if (!_playerData.TryGetValue(targetId, out f)) return;
            var cont = new CuiElementContainer();
            CuiHelper.DestroyUi(player, Layer + "Profile");
            cont.Add(_mod2Panel, "Menu_UI", Layer + "Profile");
            cont.Add(new CuiElement()
            {
                Parent = Layer + "Profile",
                Components =
                {
                    new CuiTextComponent()
                        {Align = TextAnchor.MiddleCenter, Text = f.UserName.ToUpper(), FontSize = 25},
                    new CuiRectTransformComponent()
                        {AnchorMin = "0.03270523 0.9434662", AnchorMax = "0.927317 0.9870253"}
                }
            });
            cont.Add(new CuiElement()
            {
                Parent = Layer + "Profile",
                Components =
                {
                    new CuiRawImageComponent() {Png = GetImage(targetId.ToString())},
                    new CuiRectTransformComponent()
                        {AnchorMin = "0.3160769 0.65", AnchorMax = "0.6369192 0.9416128"}
                }
            });
            cont.Add(new CuiElement()
            {
                Parent = Layer + "Profile",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Align = TextAnchor.MiddleCenter, Text = "Кол-во репортов: " + f.ReportCount,
                        Color = "0.64 0.64 0.64 0.64", FontSize = 10
                    },
                    new CuiRectTransformComponent()
                        {AnchorMin = "0.316077 0.6", AnchorMax = "0.6369191 0.64"}
                }
            });
            cont.Add(new CuiElement()
            {
                Parent = Layer + "Profile",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Align = TextAnchor.MiddleCenter, Text = "Кол-во проверок: " + f.AlertCount,
                        Color = "0.64 0.64 0.64 0.64", FontSize = 10
                    },
                    new CuiRectTransformComponent()
                        {AnchorMin = "0.316077 0.55", AnchorMax = "0.6369191 0.59"}
                }
            });
            cont.Add(new CuiButton()
            {
                Button = {Color = "0.65 0.65 0.65 0.45", Command = $"uisoreport alert {targetId}"},
                Text =
                {
                    Text = "ВЫЗВАТЬ НА ПРОВЕРКУ", Color = "0.64 0.64 0.64 0.87", Align = TextAnchor.MiddleCenter
                },
                RectTransform = {AnchorMin = "0.09125336 0.47", AnchorMax = "0.8570592 0.54"}
            }, Layer + "Profile");
            cont.Add(new CuiButton()
            {
                Button = {Color = "1 1 1 1", Sprite = "assets/icons/circle_open.png", Close = Layer + "Profile"},
                Text = {Text = ""},
                RectTransform = {AnchorMin = "0.4120954 0.36", AnchorMax = "0.5151403 0.46"}
            }, Layer + "Profile");
            cont.Add(new CuiButton()
            {
                Button = {Color = "1 1 1 1", Sprite = "assets/icons/vote_down.png", Close = Layer + "Profile"},
                Text = {Text = ""},
                RectTransform = {AnchorMin = "0.4120954 0.36", AnchorMax = "0.5151403 0.46"}
            }, Layer + "Profile");
            CuiHelper.AddUi(player, cont);
        }

        private void ReportFon(BasePlayer player)
        {
            var cont = new CuiElementContainer();
            List<ulong> f;
            CuiHelper.DestroyUi(player, Layer + "Red");
            cont.Add(_redPanel, Layer + "Main", Layer + "Red");
            //Лейбл
            PlayerData playerData;
            if (!_playerData.TryGetValue(player.userID, out playerData)) return;
            cont.Add(new CuiElement()
            {
                Parent = Layer + "Red",
                Components =
                {
                    new CuiTextComponent() {Text = "РЕПОРТ", Align = TextAnchor.MiddleLeft, Color = "0.929 0.882 0.847 0.8", FontSize = 33},
                    new CuiRectTransformComponent()
                        {AnchorMin = "0.09 0.91", AnchorMax = "1 1"}
                }
            });
            if (playerData.IsCooldown > 0)
            {
                cont.Add(new CuiElement()
                {
                    Parent = Layer + "Red",
                    Components =
                    {
                        new CuiTextComponent()
                        {
                            Text = "Подождите: " + FormatTime(TimeSpan.FromSeconds(playerData.IsCooldown), "ru"),
                            Color = "0.929 0.882 0.847 0.8", FontSize = 15, Align = TextAnchor.MiddleRight, Font = regular
                        },
                        new CuiRectTransformComponent()
                            {AnchorMin = "0.03044713 0.9258574", AnchorMax = "0.9742392 0.9766592"}
                    }
                });
            }

            //Инфо
            cont.Add(new CuiElement()
            {
                Parent = Layer + "Red",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Text = "Не забывайте что жалобу можно отравить не только на <b>одного человека</b>, а сразу на <b>шестерых</b>.", Color = "0.64 0.64 0.64 0.86", FontSize = 12,
                        Font = regular
                    },
                    new CuiRectTransformComponent() {AnchorMin = "0.03513062 0.146427", AnchorMax = "0.976581 0.214087"}
                }
            });
            //Первая причина
            cont.Add(new CuiButton()
            {
                Text = {Text = cfg.res1, Color = "0.64 0.64 0.64 0.86", Align = TextAnchor.MiddleCenter},
                Button = {Color = "0 0 0 0.64", Command = $"UiSoReport reportsend {cfg.res1}"},
                RectTransform = {AnchorMin = "0.03747275 0.07877186", AnchorMax = "0.4941462 0.1390175"}
            }, Layer + "Red");
            //Вторая причина
            cont.Add(new CuiButton()
            {
                Text = {Text = cfg.res2, Color = "0.64 0.64 0.64 0.86", Align = TextAnchor.MiddleCenter},
                Button = {Color = "0 0 0 0.64", Command = $"UiSoReport reportsend {cfg.res2}"},
                RectTransform = {AnchorMin = "0.5128826 0.07877186", AnchorMax = "0.9695571 0.1390175"}
            }, Layer + "Red");
            //3 причина
            cont.Add(new CuiButton()
            {
                Text = {Text = cfg.res3, Color = "0.64 0.64 0.64 0.86", Align = TextAnchor.MiddleCenter},
                Button = {Color = "0 0 0 0.64", Command = $"UiSoReport reportsend {cfg.res3}"},
                RectTransform = {AnchorMin = "0.5128826 0.01204333", AnchorMax = "0.9695571 0.07228888"}
            }, Layer + "Red");
            //4 причина
            cont.Add(new CuiButton()
            {
                Text = {Text = cfg.res4, Color = "0.64 0.64 0.64 0.86", Align = TextAnchor.MiddleCenter},
                Button = {Color = "0 0 0 0.64", Command = $"UiSoReport reportsend {cfg.res4}"},
                RectTransform = {AnchorMin = "0.03981462 0.01204333", AnchorMax = "0.4964881 0.07228888"}
            }, Layer + "Red");
            if (_reportList.TryGetValue(player.userID, out f))
            {
                foreach (var players in f.Select((i, t) => new {A = i, B = t}))
                {
                    var target = BasePlayer.FindByID(players.A);
                    if (target == null) continue;
                    cont.Add(new CuiElement()
                    {
                        Parent = Layer + "Red",
                        Name = Layer + "Red" + players.B,
                        Components =
                        {
                            new CuiImageComponent()
                            {
                                Color = "0.64 0.64 0.64 0.45",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin =
                                    $"{0.03278887} {0.8387395 - Math.Floor((double) players.B / 1) * 0.058}",
                                AnchorMax = $"{0.976581} {0.8923218 - Math.Floor((double) players.B / 1) * 0.058}"
                            }
                        }
                    });
                    cont.Add(new CuiElement()
                    {
                        Parent = Layer + "Red" + players.B,
                        Components =
                        {
                            new CuiRawImageComponent() {Png = GetImage(target.UserIDString)},
                            new CuiRectTransformComponent() {AnchorMin = "0 0", AnchorMax = "0.1464023 0.9851253"}
                        }
                    });
                    cont.Add(new CuiElement()
                    {
                        Parent = Layer + "Red" + players.B,
                        Components =
                        {
                            new CuiTextComponent()
                            {
                                Text = $" {target.displayName.ToUpper()}", Align = TextAnchor.MiddleLeft,
                                FontSize = 16
                            },
                            new CuiRectTransformComponent()
                                {AnchorMin = "0.1994236 0.2736453", AnchorMax = "1.003585 0.9851253"}
                        }
                    });
                    cont.Add(new CuiElement()
                    {
                        Parent = Layer + "Red" + players.B,
                        Components =
                        {
                            new CuiTextComponent()
                            {
                                Text = $"  {target.userID}", Color = "0.64 0.64 0.64 0.64",
                                Align = TextAnchor.UpperLeft, FontSize = 10, Font = regular
                            },
                            new CuiRectTransformComponent()
                                {AnchorMin = "0.1994236 0.01242494", AnchorMax = "1.003585 0.4013513"}
                        }
                    });
                    cont.Add(new CuiButton()
                    {
                        Button =
                        {
                            Color = "0.64 0.64 0.64 0.86", Command = $"UISoReport remove {target.userID}",
                            Sprite = "assets/icons/vote_down.png"
                        },
                        RectTransform = {AnchorMin = "0.8515944 0", AnchorMax = "0.9975222 1"},
                        Text = {Text = ""}
                    }, Layer + "Red" + players.B);
                }
            }

            CuiHelper.AddUi(player, cont);
        }

        private void PlayerListLoad(BasePlayer player, int page, string find = "")
        {
            var cont = new CuiElementContainer();
            CuiHelper.DestroyUi(player, Layer + "Players");
            cont.Add(_playersPanel, Layer + "Main", Layer + "Players");
            ;
            if (page > 1)
            {
                cont.Add(new CuiButton()
                {
                    Button =
                    {
                        Command = $"uisoreport nextpage players {page - 1}", Color = HexToRustFormat("#4b602aCC")
                    },
                    Text = {Text = "<", Color = HexToRustFormat("#a1e432"), Align = TextAnchor.MiddleCenter},
                    RectTransform = {AnchorMin = "0.4305381 0.01297505", AnchorMax = "0.4722021 0.05097298"}
                }, Layer + "Players");
            }
            else
            {
                cont.Add(new CuiButton()
                {
                    Button = {Command = $"", Color = HexToRustFormat($"#24291dCC")},
                    Text = {Text = "<", Color = HexToRustFormat("#a1e432"), Align = TextAnchor.MiddleCenter},
                    RectTransform = {AnchorMin = "0.4305381 0.01297505", AnchorMax = "0.4722021 0.05097298"}
                }, Layer + "Players");
            }

            cont.Add(new CuiButton()
            {
                Button = {Color = "0 0 0 0.64"},
                Text =
                    {Text = page.ToString(), Color = HexToRustFormat("#a1e432"), Align = TextAnchor.MiddleCenter},
                RectTransform = {AnchorMin = "0.4786112 0.01297505", AnchorMax = "0.5202752 0.05097298"}
            }, Layer + "Players");
            cont.Add(new CuiButton()
            {
                Button =
                    {Command = $"uisoreport nextpage players {page + 1}", Color = HexToRustFormat("#4b602aCC")},
                Text = {Text = ">", Color = HexToRustFormat("#a1e432"), Align = TextAnchor.MiddleCenter},
                RectTransform = {AnchorMin = "0.5256162 0.01297505", AnchorMax = "0.5672802 0.05097298"}
            }, Layer + "Players");
            cont.Add(new CuiElement()
            {
                Parent = Layer + "Players",
                Components =
                {
                    new CuiTextComponent() {Text = "НАЙДИ ИГРОКА(-ОВ)", Color = "0.64 0.64 0.64 0.86", FontSize = 15},
                    new CuiRectTransformComponent()
                        {AnchorMin = "0.02672157 0.9277115", AnchorMax = "0.3984902 0.9785135"}
                }
            });
            cont.Add(new CuiElement()
            {
                Parent = Layer + "Players",
                Components =
                {
                    new CuiTextComponent()
                        {Text = "НА КОТОРОГО ХОЧЕШЬ ПОЖАЛОВАТЬСЯ", Color = "0.64 0.64 0.64 0.34", FontSize = 9},
                    new CuiRectTransformComponent()
                        {AnchorMin = "0.02776662 0.9341984", AnchorMax = "0.3963884 0.9564412"}
                }
            });
            //Инфо
            cont.Add(new CuiElement()
            {
                Parent = Layer + "Players",
                Components =
                {
                    new CuiImageComponent() {Color = "0.64 0.64 0.64 0.35"},
                    new CuiRectTransformComponent()
                        {AnchorMin = "0.5256127 0.936052", AnchorMax = "0.9710997 0.9785135"}
                }
            });
            cont.Add(new CuiElement()
            {
                Parent = Layer + "Players",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Text = "   НАЙТИ ИГРОКА ПО НИКУ/STEAMID", Align = TextAnchor.MiddleLeft,
                        Color = "0.64 0.64 0.64 0.10"
                    },
                    new CuiRectTransformComponent()
                        {AnchorMin = "0.5256127 0.936052", AnchorMax = "0.9710997 0.9785135"}
                }
            });

            cont.Add(new CuiElement()
            {
                Parent = Layer + "Players",
                Components =
                {
                    new CuiInputFieldComponent()
                    {
                        Text = "", Color = "0.64 0.64 0.64 0.64", Align = TextAnchor.MiddleLeft,
                        Command = $"UISoReport find {page} "
                    },
                    new CuiRectTransformComponent()
                        {AnchorMin = "0.5256127 0.936052", AnchorMax = "0.9710997 0.9785135"}
                }
            });
            cont.Add(new CuiElement()
            {
                Parent = Layer + "Players",
                Components =
                {
                    new CuiImageComponent()
                    {
                        Sprite = "assets/icons/examine.png",
                        Color = "0.64 0.64 0.64 0.64"
                    },
                    new CuiRectTransformComponent()
                        {AnchorMin = "0.9207384 0.936052", AnchorMax = "0.9710997 0.9785135"}
                }
            });
            if (find != "" && BasePlayer.Find(find) != null)
            {
                var targetPlayer = BasePlayer.Find(find);
                cont.Add(new CuiElement()
                {
                    Parent = Layer + "Players",
                    Name = Layer + "Players" + "0",
                    Components =
                    { 
                        new CuiImageComponent() {Color = "0.64 0.64 0.64 0.25"},
                        new CuiRectTransformComponent
                        {
                            AnchorMin =
                                "0.02964282 0.8609824",
                            AnchorMax =
                                "0.3365291 0.9117843"
                        }
                    }
                });

                cont.Add(new CuiElement()
                {
                    Parent = Layer + "Players" + "0",
                    Components =
                    {
                        new CuiRawImageComponent() {Png = GetImage(targetPlayer.UserIDString)},
                        new CuiRectTransformComponent() {AnchorMin = "0 0", AnchorMax = "0.199423 0.9851253"}
                    }
                });
                cont.Add(new CuiElement()
                {
                    Parent = Layer + "Players" + "0",
                    Components =
                    {
                        new CuiTextComponent()
                        {
                            Text = $" {targetPlayer.displayName.ToUpper()}", Align = TextAnchor.MiddleLeft,
                            FontSize = 16
                        },
                        new CuiRectTransformComponent()
                            {AnchorMin = "0.1994236 0.2736453", AnchorMax = "1.003585 0.9851253"}
                    }
                });
                cont.Add(new CuiElement()
                {
                    Parent = Layer + "Players" + "0",
                    Components =
                    {
                        new CuiTextComponent()
                        {
                            Text = $"  {targetPlayer.userID}", Color = "0.64 0.64 0.64 0.64",
                            Align = TextAnchor.UpperLeft, FontSize = 10, Font = regular
                        },
                        new CuiRectTransformComponent()
                            {AnchorMin = "0.1994236 0.01242494", AnchorMax = "1.003585 0.4013513"}
                    }
                });

                cont.Add(new CuiButton()
                {
                    Button = {Color = "0 0 0 0", Command = $"UISoReport add {page} {targetPlayer.userID}"},
                    RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
                    Text = {Text = ""}
                }, Layer + "Players" + "0");
            }
            else
            {
                foreach (var players in BasePlayer.activePlayerList
                    .Select((i, t) => new {A = i, B = t - (page - 1) * 45}).Skip((page - 1) * 45).Take(45))
                {
                    List<ulong> f;
                    if (_reportList.TryGetValue(player.userID, out f) && f.Contains(players.A.userID))
                    {
                        cont.Add(new CuiElement()
                        {
                            Parent = Layer + "Players",
                            Name = Layer + "Players" + players.B,
                            Components =
                            {
                                new CuiImageComponent()
                                {
                                    Color = HexToRustFormat("#93c9415a")
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin =
                                        $"{0.02964282 + players.B * 0.315 - Math.Floor((double) players.B / 3) * 3 * 0.315} {0.8609824 - Math.Floor((double) players.B / 3) * 0.058}",
                                    AnchorMax =
                                        $"{0.3365291 + players.B * 0.315 - Math.Floor((double) players.B / 3) * 3 * 0.315} {0.9117843 - Math.Floor((double) players.B / 3) * 0.058}"
                                }
                            }
                        });
                    }
                    else
                    {
                        cont.Add(new CuiElement()
                        {
                            Parent = Layer + "Players",
                            Name = Layer + "Players" + players.B,
                            Components =
                            {
                                new CuiImageComponent()
                                    {Color = "0.64 0.64 0.64 0.25"},
                                new CuiRectTransformComponent
                                {
                                    AnchorMin =
                                        $"{0.02964282 + players.B * 0.315 - Math.Floor((double) players.B / 3) * 3 * 0.315} {0.8609824 - Math.Floor((double) players.B / 3) * 0.058}",
                                    AnchorMax =
                                        $"{0.3365291 + players.B * 0.315 - Math.Floor((double) players.B / 3) * 3 * 0.315} {0.9117843 - Math.Floor((double) players.B / 3) * 0.058}"
                                }
                            }
                        });
                    }

                    cont.Add(new CuiElement()
                    {
                        Parent = Layer + "Players" + players.B,
                        Components =
                        {
                            new CuiRawImageComponent() {Png = GetImage(players.A.UserIDString)},
                            new CuiRectTransformComponent() {AnchorMin = "0 0", AnchorMax = "0.199423 0.9851253"}
                        }
                    });
                    cont.Add(new CuiElement()
                    {
                        Parent = Layer + "Players" + players.B,
                        Components =
                        {
                            new CuiTextComponent()
                            {
                                Text = $" {players.A.displayName.ToUpper()}", Align = TextAnchor.MiddleLeft,
                                FontSize = 16
                            },
                            new CuiRectTransformComponent()
                                {AnchorMin = "0.1994236 0.2736453", AnchorMax = "1.003585 0.9851253"}
                        }
                    });
                    cont.Add(new CuiElement()
                    {
                        Parent = Layer + "Players" + players.B,
                        Components =
                        {
                            new CuiTextComponent()
                            {
                                Text = $"  {players.A.userID}", Color = "0.64 0.64 0.64 0.64",
                                Align = TextAnchor.UpperLeft, FontSize = 10, Font = regular
                            },
                            new CuiRectTransformComponent()
                                {AnchorMin = "0.1994236 0.01242494", AnchorMax = "1.003585 0.4013513"}
                        }
                    });
                    cont.Add(new CuiButton()
                    {
                        Button = {Color = "0 0 0 0", Command = $"UISoReport add {page} {players.A.userID}"},
                        RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
                        Text = {Text = ""}
                    }, Layer + "Players" + players.B);
                }
            }

            CuiHelper.AddUi(player, cont);
        }

        #endregion

        #region Commands

        [ChatCommand("discord")]
        private void SayDiscord(BasePlayer player, string c, string[] a)
        {
            if (!_alertList.ContainsValue(player.userID))
            {
                ReplySend(player, "Вы не на проверке!");
                return;
            }
            if (a.Length < 1)
            {
                ReplySend(player, "/discord {ВАШ ДИСКОРД}");
                return;
            }
            var arg = string.Join(" ", a.ToArray());
            var admin = BasePlayer.FindByID(_alertList.First(p => p.Value == player.userID).Key);
            ReplySend(player, "Дискорд успешно отправлен!");
            if (admin != null)
                ReplySend(admin, $"Игрок {player.displayName}[{player.userID}] отправил свой дискорд: {arg}");
            if (cfg.Vkontakte) 
                webrequest.Enqueue( 
                    "https://api.vk.com/method/messages.send?user_ids=" + cfg.vkadmin + "&message=" + $"Игрок {player.displayName}[{player.userID}] отправил свой дискорд: {arg}" +
                    "&v=5.92" + "&random_id=" + UnityEngine.Random.Range(Int32.MinValue, Int32.MaxValue) +
                    "&access_token=" + cfg.vkAcces, null, (code, response) => { }, this);
            if(cfg.TelegramUse) webrequest.Enqueue($"https://api.telegram.org/bot{cfg.botToken}/sendMessage?chat_id=@{cfg.chatid}&text=Игрок {player.displayName}[{player.userID}] отправил свой дискорд: {arg}", null, (code, response) => { if(code == 400) Puts("Chat not found");},this, RequestMethod.POST);
            if (cfg.discord) SendDiscord("SendPlayerDiscord", $"Игрок {player.displayName}[{player.userID}] отправил свой дискорд: {arg}", cfg.discordhook2);
        }

        [ConsoleCommand("UISoReport")]
        private void SoCommands(ConsoleSystem.Arg arg)
        {
            var targetPlayer = arg.Player();
            switch (arg.Args[0])
            {
                case "nextpage":
                    if (arg.Args[1] == "players")
                        PlayerListLoad(targetPlayer, arg.Args[2].ToInt());
                    if (arg.Args[1] == "mod")
                        ModeratorInterface(targetPlayer, arg.Args[2].ToInt());
                    break;
                case "alert":
                    ulong ss;
                    if (_alertList.TryGetValue(targetPlayer.userID, out ss))
                    {
                        var target = BasePlayer.FindByID(ss);
                        ReplySend(target, $"Проверка окончена!");
                        ReplySend(targetPlayer, $"Вы закончили проверку игрока {target.displayName}");
                        CuiHelper.DestroyUi(target, "AlerUISo");
                        _alertList.Remove(targetPlayer.userID);
                    }
                    else if (!_alertList.ContainsValue(ulong.Parse(arg.Args[1])))
                    {
                        PlayerData data;
                        if (!_playerData.TryGetValue(ulong.Parse(arg.Args[1]), out data)) return;
                        data.AlertCount += 1;
                        _alertList.Add(targetPlayer.userID, ulong.Parse(arg.Args[1]));
                        Alert(ulong.Parse(arg.Args[1]));
                    }

                    break;
                case "find":
                    if(arg.Args.Length < 3) return;
                    PlayerListLoad(targetPlayer, arg.Args[1].ToInt(), arg.Args[2]);
                    break;
                case "add":
                    List<ulong> f;

                    if (_reportList.TryGetValue(targetPlayer.userID, out f))
                    {
                        if (!f.Contains(ulong.Parse(arg.Args[2])))
                            if (f.Count < 6)
                                f.Add(ulong.Parse(arg.Args[2]));
                    }
                    else
                        _reportList.Add(targetPlayer.userID, new List<ulong>()
                        {
                            ulong.Parse(arg.Args[2]),
                        });

                    PlayerListLoad(targetPlayer, arg.Args[1].ToInt());
                    ReportFon(targetPlayer);
                    break;
                case "remove":
                    if (_reportList.TryGetValue(targetPlayer.userID, out f))
                        f.Remove(ulong.Parse(arg.Args[1]));

                    PlayerListLoad(targetPlayer, 1);
                    ReportFon(targetPlayer);
                    break;
                case "reportsend":
                    PlayerData playerDat;
                    if (!_playerData.TryGetValue(targetPlayer.userID, out playerDat)) return;
                    if (playerDat.IsCooldown > 0) return;
                    if (_reportList.TryGetValue(targetPlayer.userID, out f))
                    {
                        string text =
                            $"Игрок {targetPlayer.displayName}[{targetPlayer.userID}] пожаловался по причине {arg.Args[1]} на игрока(-ов):";
                        if (f.Count < 1) return;
                        foreach (var reportSend in f)
                        {
                            var target = BasePlayer.FindByID(reportSend);
                            if (target == null) continue;
                            PlayerData dataPlayer;
                            if (_playerData.TryGetValue(target.userID, out dataPlayer))
                            {
                                dataPlayer.ReportCount += 1;
                                text +=
                                    $"\n{target.displayName} [{target.userID}] \nКол-во репортов: {dataPlayer.ReportCount}\nSteam: [КЛИК](https://steamcommunity.com/profiles/{target.userID})";
                            }
                        }

                        f.Clear();
                        if (cfg.discord) SendDiscord("REPORT", text, cfg.discordhook);
                        if (cfg.Vkontakte) webrequest.Enqueue("https://api.vk.com/method/messages.send?user_ids=" + cfg.vkadmin + "&message=" + text + "&v=5.92" + "&random_id=" + UnityEngine.Random.Range(Int32.MinValue, Int32.MaxValue) + "&access_token=" + cfg.vkAcces, null, (code, response) => { }, this);
                        if(cfg.TelegramUse) webrequest.Enqueue($"https://api.telegram.org/bot{cfg.botToken}/sendMessage?chat_id=@{cfg.chatid}&text={text}", null, (code, response) => { if(code == 400) Puts("Chat not found");},this, RequestMethod.POST);
                        Puts(text);
                        playerDat.ReportCD = cfg.cooldown + CurrentTime();
                    }

                    PlayerListLoad(targetPlayer, 1);
                    ReportFon(targetPlayer);
                    break;
                case "modmenu":
                    if (arg.Args[1] == "open")
                    {
                        CuiHelper.DestroyUi(targetPlayer, Layer + "BMod");
                        ModeratorInterface(targetPlayer, 1);
                    }

                    break;
                case "profile":
                    LoadProfile(targetPlayer, ulong.Parse(arg.Args[1]));
                    break;
            }
        }
        [ChatCommand("alert")]
        private void AlertCommand(BasePlayer player, string c, string[] a)
        {
            if (permission.UserHasPermission(player.UserIDString, "soreport.admin"))
            {
                if (a.Length < 1)
                {
                    ReplySend(player, "/alert {НИК/STEAMID}");
                    return;
                }

                var arg = String.Join(" ", a.ToArray());
                var target = BasePlayer.Find(arg);
                if (target == null)
                {
                    ReplySend(player, "Игрок не найден");
                    return;
                }

                ulong ss;
                if (_alertList.TryGetValue(player.userID, out ss))
                {
                    _alertList.Remove(player.userID);
                    var targes = BasePlayer.FindByID(ss);
                    CuiHelper.DestroyUi(targes, "AlerUISo");
                    
                    ReplySend(targes, $"Проверка окончена!");
                    ReplySend(player, $"Вы закончили проверку игрока {targes.displayName}");
                    return;
                }
                PlayerData data;
                if(!_playerData.TryGetValue(target.userID, out data)) return;
                data.AlertCount += 1;
                _alertList.Add(player.userID, target.userID);
                Alert(target.userID);
                ReplySend(player, $"Вы вызвали игрока {target.displayName} на проверку");
            }
        }

        #endregion
        
        #region DS

        #region discord

        private readonly JsonSerializerSettings _jsonSettings = new JsonSerializerSettings();
        private static SoReport _instance;

        private readonly Dictionary<string, string> _headers = new Dictionary<string, string>
        {
            ["Content-Type"] = "application/json"
        };

        private class FancyMessage
        {
            [JsonProperty("content")] private string Content { get; set; }
            [JsonProperty("tts")] private bool TextToSpeech { get; set; }
            [JsonProperty("embeds")] private EmbedBuilder[] Embeds { get; set; }

            public FancyMessage WithContent(string value)
            {
                Content = value;
                return this;
            }

            public FancyMessage SetEmbed(EmbedBuilder value)
            {
                Embeds = new[] {value};
                return this;
            }

            public string ToJson()
            {
                return JsonConvert.SerializeObject(this, _instance._jsonSettings);
            }
        }

        public class EmbedBuilder
        {
            public EmbedBuilder()
            {
                Fields = new List<Field>();
            }

            [JsonProperty("title")] private string Title { get; set; }
            [JsonProperty("color")] private int Color { get; set; }
            [JsonProperty("fields")] private List<Field> Fields { get; }

            public EmbedBuilder WithTitle(string title)
            {
                Title = title;
                return this;
            }

            public EmbedBuilder SetColor(int color)
            {
                Color = color;
                return this;
            }

            public EmbedBuilder AddField(Field field)
            {
                Fields.Add(field);
                return this;
            }

            public class Field
            {
                public Field(string name, object value)
                {
                    Name = name;
                    Value = value;
                }

                [JsonProperty("name")] public string Name { get; set; }
                [JsonProperty("value")] public object Value { get; set; }
            }
        }

        private class Request
        {
            private readonly string _payload;
            private readonly Plugin _plugin;
            private readonly string _url;

            public void Send()
            {
                _instance.webrequest.Enqueue(_url, _payload, (code, rawResponse) => { }, _instance, RequestMethod.POST,
                    _instance._headers);
            }

            public static void Send(string url, FancyMessage message, Plugin plugin = null)
            {
                new Request(url, message, plugin).Send();
            }

            private Request(string url, FancyMessage message, Plugin plugin = null)
            {
                _url = url;
                _payload = message.ToJson();
                _plugin = plugin;
            }
        }

        #endregion

        private void SendDiscord(string type, string reason, string hook)
        {
            var fields = new List<EmbedBuilder.Field>();
            fields.Add(new EmbedBuilder.Field(type, reason));
            var serializedObject = JsonConvert.SerializeObject(fields);
            var builder = new EmbedBuilder().SetColor(104403);
            foreach (var field in JsonConvert.DeserializeObject<EmbedBuilder.Field[]>(serializedObject))
                builder.AddField(field);
            var payload = new FancyMessage().WithContent(cfg.Lable).SetEmbed(builder);
            Request.Send(hook, payload, this);
        }

        #endregion

        #region L

        private Dictionary<ulong, ulong> _alertList = new Dictionary<ulong, ulong>();
        private Dictionary<ulong, List<ulong>> _reportList = new Dictionary<ulong, List<ulong>>();

        #endregion

        #region Hooks

        private void OnPlayerConnected(BasePlayer player)
        {
            if (!_playerData.ContainsKey(player.userID))
                _playerData.Add(player.userID, new PlayerData() {UserName = player.displayName, ReportCount = 1});
        }

        private void OnServerInitialized()
        {
            PrintWarning("\n-----------------------------\n" +
            "     Author - https://topplugin.ru/\n" +
            "     VK - https://vk.com/rustnastroika\n" +
            "     Discord - https://discord.com/invite/5DPTsRmd3G\n" +
            "-----------------------------");
            permission.RegisterPermission("soreport.admin", this);
            _instance = this;

            if (Interface.Oxide.DataFileSystem.ExistsDatafile("TryReport/Report"))
                _playerData =
                    Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, PlayerData>>("SoReport/Players");
            foreach (var basePlayer in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(basePlayer);
            }
        }

        private void Unload()
        {
            Interface.Oxide.DataFileSystem.WriteObject("SoReport/Players", _playerData);
            foreach (var basePlayer in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(basePlayer, "ReportMain");
                CuiHelper.DestroyUi(basePlayer, "AlerUISo");
            }
        }

        #endregion

        #region Help

        private static string Format(int units, string form1, string form2, string form3)
        {
            var tmp = units % 10;
            if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9) return $"{units} {form1}";
            if (tmp >= 2 && tmp <= 4) return $"{units} {form2}";
            return $"{units} {form3}";
        }

        public static string FormatTime(TimeSpan time, string language, int maxSubstr = 5)
        {
            var result = string.Empty;
            switch (language)
            {
                case "ru":
                    var i = 0;
                    if (time.Days != 0 && i < maxSubstr)
                    {
                        if (!string.IsNullOrEmpty(result)) result += " ";
                        result += $"{Format(time.Days, "дней", "дня", "день")}";
                        i++;
                    }

                    if (time.Hours != 0 && i < maxSubstr)
                    {
                        if (!string.IsNullOrEmpty(result)) result += " ";
                        result += $"{Format(time.Hours, "часов", "часа", "час")}";
                        i++;
                    }

                    if (time.Minutes != 0 && i < maxSubstr)
                    {
                        if (!string.IsNullOrEmpty(result)) result += " ";
                        result += $"{Format(time.Minutes, "минут", "минуты", "минута")}";
                        i++;
                    }

                    if (time.Seconds != 0 && i < maxSubstr)
                    {
                        if (!string.IsNullOrEmpty(result)) result += " ";
                        result += $"{Format(time.Seconds, "сек", "сек", "сек")}";
                        i++;
                    }

                    break;
                case "en":
                {
                    var i2 = 0;
                    if (time.Days != 0 && i2 < maxSubstr)
                    {
                        if (!string.IsNullOrEmpty(result)) result += " ";
                        result += $"{Format(time.Days, "days'", "day's", "day")}";
                        i2++;
                    }

                    if (time.Hours != 0 && i2 < maxSubstr)
                    {
                        if (!string.IsNullOrEmpty(result)) result += " ";
                        result += $"{Format(time.Hours, "hours'", "hour's", "hour")}";
                        i2++;
                    }

                    if (time.Minutes != 0 && i2 < maxSubstr)
                    {
                        if (!string.IsNullOrEmpty(result)) result += " ";
                        result += $"{Format(time.Minutes, "minutes", "minutes", "minute")}";
                        i2++;
                    }

                    if (time.Seconds != 0 && i2 < maxSubstr)
                    {
                        if (!string.IsNullOrEmpty(result)) result += " ";
                        result += $"{Format(time.Seconds, "second", "seconds", "second")}";
                        i2++;
                    }

                    break;
                }
            }

            return result;
        }

        [PluginReference] private Plugin ImageLibrary;

        public string GetImage(string shortname, ulong skin = 0) =>
            (string) ImageLibrary.Call("GetImage", shortname, skin);

        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex)) hex = "#FFFFFFFF";
            var str = hex.Trim('#');
            if (str.Length == 6) str += "FF";
            if (str.Length != 8)
            {
                throw new Exception(hex);
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);
            Color color = new Color32(r, g, b, a);
            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }

        private void ReplySend(BasePlayer player, string message) => player.SendConsoleCommand("chat.add 0",
            new object[2]
                {76561199015371818, $"<size=18><color=purple>SoReport</color></size>\n{message}"});

        private static DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        private static double CurrentTime() => DateTime.UtcNow.Subtract(epoch).TotalSeconds;

        #endregion
    }
}

// --- End of file: SoReport.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BloodRust-fuuu/PassSystem.cs ---
// --- Original Local Path: BloodRust-fuuu/PassSystem.cs ---

﻿using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("PassSystem", "TopPlugin.ru", "3.0.0")]
    class PassSystem : RustPlugin
    {
        #region Вар
        private string Layer = "Pass_UI";

        [PluginReference] Plugin ImageLibrary;
        #endregion

        #region Класс
        public class Settings
        {
            [JsonProperty("Основное название")] public string DisplayName;
            [JsonProperty("Название сервера")] public string ServerName;
            [JsonProperty("Последний уровень")] public int Level;
        }

        public class PassSettings
        {
            [JsonProperty("Уровень")] public int Level;
            [JsonProperty("Сколько максимум игрок может получить вещей из списка?")] public int Count;
            [JsonProperty("Список заданий")] public List<MainSettings> mains;
            [JsonProperty("Список наград")] public List<ItemsList> items;
        }

        public class MainSettings
        {
            [JsonProperty("Название задания")] public string DisplayName;
            [JsonProperty("Короткое название задачи")] public string ShortName;
            [JsonProperty("Количество предмета")] public int Amount;
        }

        public class ItemsList
        {
            [JsonProperty("Короткое название предмета")] public string ShortName;
            [JsonProperty("Шанс выпадения предмета")] public int DropChance;
            [JsonProperty("Минимальное количество при выпадени")] public int AmountMin;
            [JsonProperty("Максимальное Количество при выпадени")] public int AmountMax;
        }

        private Dictionary<ulong, PlayerTasks> ProgressPass;
        private class PlayerTasks
        {
            [JsonProperty("Уровень игрока")] public int Level;
            [JsonProperty("Список выполняемых заданий")] public Dictionary<string, PlayerProgress> Progress = new Dictionary<string, PlayerProgress>();
        }

        private class PlayerProgress
        {
            [JsonProperty("Количество")] public int Amount;
        }
        #endregion

        #region Конфиг
        public Configuration config;
        public class Configuration
        {
            [JsonProperty("Основные настройки")] public Settings settings = new Settings();
            [JsonProperty("Список")] public List<PassSettings> passSettings;
            public static Configuration GetNewConfig()
            {
                return new Configuration
                {
                    settings = new Settings
                    {
                        DisplayName = "SERVERNAME PASS",
                        ServerName = "SERVERNAME",
                        Level = 3
                    },
                    passSettings = new List<PassSettings>
                    {
                        new PassSettings
                        {
                            Level = 1,
                            Count = 3,
                            mains = new List<MainSettings>
                            {
                                new MainSettings
                                {
                                    DisplayName = "Собери ткань",
                                    ShortName = "cloth",
                                    Amount = 500,
                                },       
                                new MainSettings
                                {
                                    DisplayName = "Убить игроков",
                                    ShortName = "player",
                                    Amount = 5,
                                },   
                                new MainSettings
                                {
                                    DisplayName = "Добыть дерево",
                                    ShortName = "wood",
                                    Amount = 6000,
                                },  
                                new MainSettings
                                {
                                    DisplayName = "Добыть камень",
                                    ShortName = "stones",
                                    Amount = 6000,
                                },
                            },
                            items = new List<ItemsList>
                            {
                                new ItemsList
                                {
                                    ShortName = "wood",
                                    AmountMin = 1000,
                                    AmountMax = 5000,
                                    DropChance = 100
                                },       
                                new ItemsList
                                {
                                    ShortName = "stones",
                                    AmountMin = 1000,
                                    AmountMax = 5000,
                                    DropChance = 100
                                },
                            }
                        },
                        new PassSettings
                        {
                            Level = 2,
                            Count = 3,
                            mains = new List<MainSettings>
                            {
                                new MainSettings
                                {
                                    DisplayName = "Уничтожить танк",
                                    ShortName = "bradleyapc",
                                    Amount = 1,
                                },
                                new MainSettings
                                {
                                    DisplayName = "Сера",
                                    ShortName = "sulfur.ore",
                                    Amount = 500,
                                }
                            },
                            items = new List<ItemsList>
                            {
                                new ItemsList
                                {
                                    ShortName = "stones",
                                    AmountMin = 1000,
                                    AmountMax = 5000,
                                    DropChance = 70
                                }, 
                                new ItemsList
                                {
                                    ShortName = "rifle.ak",
                                    AmountMin = 1,
                                    AmountMax = 1,
                                    DropChance = 70
                                },
                            }
                        }
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config?.passSettings == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Ошибка чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfig();
        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion

        #region Хуки
        private void OnServerInitialized()
        {
            PrintWarning("\n-----------------------------\n" +
            "     Author - https://topplugin.ru/\n" +
            "     VK - https://vk.com/rustnastroika\n" +
            "     Discord - https://discord.com/invite/5DPTsRmd3G\n" +
            "-----------------------------");
            if (Interface.Oxide.DataFileSystem.ExistsDatafile("PassSystem/PlayerList"))
            {
                ProgressPass = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, PlayerTasks>>("PassSystem/PlayerList");
            }
            else
            {
                ProgressPass = new Dictionary<ulong, PlayerTasks>();
            }
            BasePlayer.activePlayerList.ToList().ForEach(OnPlayerConnected);
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (!ProgressPass.ContainsKey(player.userID))
            {
                ProgressPass.Add(player.userID, new PlayerTasks());
            }
            SaveData();
        }

        private PlayerProgress AddPlayersData(ulong userID, string name)
        {
            if (!ProgressPass.ContainsKey(userID))
                ProgressPass[userID].Progress = new Dictionary<string, PlayerProgress>();

            if (!ProgressPass[userID].Progress.ContainsKey(name))
                ProgressPass[userID].Progress[name] = new PlayerProgress();

            return ProgressPass[userID].Progress[name];
        }

        private void Progress(BasePlayer player, string ShortName, int Count)
        {
            foreach (var check in config.passSettings)
            {
                var name = check.mains.FirstOrDefault(x => x.ShortName == ShortName);
                if (name != null)
                {
                    var data = AddPlayersData(player.userID, name.ShortName);
                    if (ProgressPass[player.userID].Level == check.Level)
                    {
                        if (data.Amount <= name.Amount)
                        {
                            if (data.Amount < name.Amount)
                            {
                                data.Amount += Count;
                                SaveData();
                            }
                            else return;
                            if (name.Amount <= data.Amount)
                            {
                                SendReply(player, $"Вы успешно выполнили задание: <color=#ee3e61>{name.DisplayName}</color>!");
                                data.Amount = name.Amount;
                            }
                            else return;
                        }
                        else return;
                    }
                    else return;
                }
            }
        }

        private void OnDispenserBonus(ResourceDispenser dispenser, BaseEntity entity, Item item) => OnDispenserGather(dispenser, entity, item);
        private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            BasePlayer player = entity.ToPlayer();
            NextTick(() => Progress(player, item.info.shortname, item.amount));
        }

        private void OnCollectiblePickup(Item item, BasePlayer player)
        {
            NextTick(() => Progress(player, item.info.shortname, item.amount));
        }

        private void OnItemCraftFinished(ItemCraftTask task, Item item)
        {
            Progress(task.owner, item.info.shortname, item.amount);
        }

        public ulong lastDamageName;
        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity is BradleyAPC && info.Initiator is BasePlayer)
                lastDamageName = info.Initiator.ToPlayer().userID;
            if (entity is BaseHelicopter && info.Initiator is BasePlayer)
                lastDamageName = info.Initiator.ToPlayer().userID;
        }

        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null || info == null) return;
            BasePlayer player = null;

            if (info.InitiatorPlayer != null) player = info.InitiatorPlayer;
            else if (entity is BradleyAPC || entity is BaseHelicopter) player = BasePlayer.FindByID(lastDamageName);

            if (player == null) return;
            if (entity.ToPlayer() != null && entity as BasePlayer == player) return;
            Progress(player, entity?.ShortPrefabName, 1);
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("PassSystem/PlayerList", ProgressPass);
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            SaveData();
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, Layer);
            }
        }
        #endregion

        #region Команды
        private void ChatPass(BasePlayer player)
        {
            if (ProgressPass[player.userID].Level == config.settings.Level)
            {
                SendReply(player, "Вы уже <color=#ee3e61>выполнили</color> все задания!");
            }
            else PassUI(player);
        }

        [ConsoleCommand("pass")]
        private void CmdCase(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player != null && args.HasArgs(1))
            {
                if (args.Args[0] == "take")
                {
                    bool enable = true;
                    foreach (var check in config.passSettings)
                    {
                        foreach (var pass in check.mains)
                        {
                            if (ProgressPass[player.userID].Level == check.Level)
                            {
                                var data = AddPlayersData(player.userID, pass.ShortName);
                                if (data.Amount >= pass.Amount) continue;
                                enable = false;
                            }
                        }
                    }
                    if (!enable)
                    {
                        SendReply(player, "Вы еще не <color=#ee3e61>выполнили</color> все задания");
                    }
                    else
                    {
                        foreach (var check in config.passSettings)
                        {
                            int count = 0;
                            foreach (var item in check.items)
                            {
                                if (UnityEngine.Random.Range(0, 100) > item.DropChance) continue;
                                int Amount = Core.Random.Range(item.AmountMin, item.AmountMax);
                                if (ProgressPass[player.userID].Level == check.Level)
                                {
                                    if (count >= check.Count) break;
                                    player.inventory.GiveItem(ItemManager.CreateByName(item.ShortName, Amount));
                                    SendReply(player, $"Вы получили: <color=#ee3e61>{item.ShortName}</color>\nВ размере: <color=#ee3e61>{Amount}</color>");
                                    count++;
                                }
                                ProgressPass[player.userID].Progress.Clear();
                                
                            }
                        }
                        ProgressPass[player.userID].Level += 1;
                        CuiHelper.DestroyUi(player, Layer);
                        SaveData();
                    }
                }
                if (args.Args[0] == "start")
                {
                    ProgressPass[player.userID].Level += 1;
                    PassUI(player);
                }
            }
        }
        #endregion

        #region Интерфейс
        private void PassUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "Pass");
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.276 0", AnchorMax = "0.945 1", OffsetMax = "0 0" },
                Image = { Color = "0.117 0.121 0.109 0.95" }
            }, "Menu_UI", "Pass");

            if (ProgressPass[player.userID].Level == 0)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0.15", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Button = { Color = "1 1 1 0" },
                    Text = { Text = $"<b><size=40>{config.settings.ServerName}</size></b>\n\nПривет, <color=#1E88E5><b>{player.displayName.ToUpper()}</b></color>\n\nТы зашел на проект <b></b>, а значит, ты готов тащить и развиваться, в соло или с <b>кривыми</b> тимейтами, но это не важно. Важно лишь то, что мы готовы <b>облегчить</b> твои страдания, но платой за это будет выполнение <b>наших</b> заданий!\n\n<b><color=#1E88E5>Правила</color></b>\n<b><color=#1E88E5>1</color></b>. Выполняешь <b><color=#1E88E5>задания</color></b>\n<b><color=#1E88E5>2</color></b>. Забираешь <b><color=#1E88E5>награду</color></b>\n<b><color=#1E88E5>3</color></b>. Выполняешь <b><color=#1E88E5>новое</color></b> задание\n\nКак видишь, <b>правила просты</b>, скорее приступай!\nА мы желаем <b>тебе</b> удачи и прекрасного вайпа!", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-regular.ttf", FadeIn = 0.5f }
                }, "Pass");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.4 0.31", AnchorMax = "0.6 0.37", OffsetMax = "0 0" },
                    Button = { Color = "1 1 1 0.1", Command = "pass start" },
                    Text = { Text = $"<color=#1E88E5>ПРИСТУПИТЬ</color>", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 18, Font = "robotocondensed-bold.ttf", FadeIn = 0.5f }
                }, "Pass");
            }
            else
            {
                foreach (var check in config.passSettings)
                {
                    if (ProgressPass[player.userID].Level == check.Level)
                    {
                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = "0 0.643", AnchorMax = "1 0.75", OffsetMax = "0 0" },
                            Button = { Color = "1 1 1 0" },
                            Text = { Text = $"<b><size=35>{config.settings.DisplayName}</size></b>\nУровень: {ProgressPass[player.userID].Level}", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-regular.ttf", FadeIn = 0.5f }
                        }, "Pass");

                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = "0.35 0.17", AnchorMax = "0.65 0.22", OffsetMax = "0 0" },
                            Button = { Color = "1 1 1 0.1", Command = $"pass take" },
                            Text = { Text = $"ЗАБРАТЬ НАГРАДУ", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 18, Font = "robotocondensed-bold.ttf", FadeIn = 0.5f }
                        }, "Pass");

                        float gap1 = 0f, width1 = 0.13f, height1 = 0.15f, xmin1 = 0.1f, ymin1 = 0.63f - height1;
                        for (int i = 0; i < 6; i++)
                        {
                            container.Add(new CuiPanel
                            {
                                RectTransform = { AnchorMin = xmin1 + " " + ymin1, AnchorMax = (xmin1 + width1) + " " + (ymin1 + height1 * 1), OffsetMin = "2 0", OffsetMax = "-2 0" },
                                Image = { Color = "1 1 1 0.1" }
                            }, "Pass");
                            xmin1 += width1;
                        }

                        float width2 = 0.13f, height2 = 0.15f, xmin2 = 0.1f, ymin2 = 0.63f - height2;
                        foreach (var item in check.items)
                        {
                            container.Add(new CuiPanel
                            {
                                RectTransform = { AnchorMin = xmin2 + " " + ymin2, AnchorMax = (xmin2 + width2) + " " + (ymin2 + height2 * 1), OffsetMin = "2 0", OffsetMax = "-2 0" },
                                Image = { Color = "1 1 1 0" }
                            }, "Pass", "Set");

                            container.Add(new CuiElement
                            {
                                Parent = "Set",
                                Components =
                                {
                                    new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", item.ShortName) },
                                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" }
                                }
                            });

                            var textAmount = item.AmountMin != item.AmountMax ? $"{item.AmountMin}-{item.AmountMax}" : $"{item.AmountMax}";
                            container.Add(new CuiButton
                            {
                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                Button = { Color = "0 0 0 0" },
                                Text = { Text = $"{textAmount}x ", Color = "1 1 1 0.5", Align = TextAnchor.LowerRight, FontSize = 14, Font = "robotocondensed-bold.ttf", FadeIn = 0.5f }
                            }, "Set");
                            xmin2 += width2;
                        }

                        float width = 0.7f, height = 0.05f, startxBox = 0.145f, startyBox = 0.45f - height, xmin = startxBox, ymin = startyBox;
                        foreach (var pass in check.mains)
                        {
                            var data = AddPlayersData(player.userID, pass.ShortName);
                            container.Add(new CuiButton
                            {
                                RectTransform = { AnchorMin = xmin + " " + ymin, AnchorMax = (xmin + width) + " " + (ymin + height * 1), OffsetMin = "2 2", OffsetMax = "-2 -2" },
                                Button = { Color = "1 1 1 0" },
                                Text = { Text = $"" }
                            }, "Pass", "Task");
                            xmin += width;
                            if (xmin + width >= 1)
                            {
                                xmin = startxBox;
                                ymin -= height;
                            }

                            container.Add(new CuiButton
                            {
                                RectTransform = { AnchorMin = "0 0.35", AnchorMax = "0.5 0.9", OffsetMax = "0 0" },
                                Button = { Color = "1 1 1 0" },
                                Text = { Text = $" {pass.DisplayName}", Color = "1 1 1 0.5", Align = TextAnchor.MiddleLeft, FontSize = 14, Font = "robotocondensed-regular.ttf", FadeIn = 0.5f }
                            }, "Task");

                            var text = data.Amount >= pass.Amount ? "выполнено" : $"{data.Amount}/{pass.Amount}";
                            container.Add(new CuiButton
                            {
                                RectTransform = { AnchorMin = "0.5 0.35", AnchorMax = "1 0.9", OffsetMax = "0 0" },
                                Button = { Color = "1 1 1 0" },
                                Text = { Text = $"{text} ", Color = "1 1 1 0.5", Align = TextAnchor.MiddleRight, FontSize = 14, Font = "robotocondensed-regular.ttf", FadeIn = 0.5f }
                            }, "Task");

                            container.Add(new CuiButton
                            {
                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.3", OffsetMax = "0 0" },
                                Button = { Color = "1 1 1 0.12" },
                                Text = { Text = "", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf", FadeIn = 0.5f }
                            }, "Task", "Progress");

                            container.Add(new CuiButton
                            {
                                RectTransform = { AnchorMin = "0 0", AnchorMax = $"{(float)data.Amount / pass.Amount} 1", OffsetMax = "0 0" },
                                Button = { Color = "0.46 0.73 0.43 0.5" },
                                Text = { Text = "", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf", FadeIn = 0.5f }
                            }, "Progress");
                        }
                    }
                }
            }
            CuiHelper.AddUi(player, container);
        }
        #endregion
    }
}

// --- End of file: PassSystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BloodRust-fuuu/InfoMenu.cs ---
// --- Original Local Path: BloodRust-fuuu/InfoMenu.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("InfoMenu", "TopPlugin.ru", "3.0.0")]
    public class InfoMenu : RustPlugin
    {
		
		#region Variables
		
		[PluginReference] 
		private Plugin ImageLibrary;

		#endregion
        		
		#region Config 
		
		//Управляет высотой пункта меню
		readonly int HEIGHT_MENU_ELEMENT = 35;
		
        private PluginConfig config;
		
		private class PluginConfig
        {
            [JsonProperty("Вкладки")]
            public Dictionary<string, List<Tabs>> tabs = new Dictionary<string, List<Tabs>>();
            public static PluginConfig DefaultConfig()
            {
				PluginConfig conf = new PluginConfig();
                conf.tabs = new  Dictionary<string, List<Tabs>>();
				List<Tabs> Tab1 = new List<Tabs>();
				Tab1.Add(new Tabs(){Title = "О СЕРВЕРЕ", Pages = new List<Page>()});
				Tab1[0].Pages.Add(new Page(){Images = new List<Images>(),Buttons = new List<Buttons>(), blocks = new List<TextBlocks>()});
				//Тексты
				List<TextBlocks> blocks1 = Tab1[0].Pages[0].blocks;
				blocks1.Add(new TextBlocks(){colums = new List<TextColumns>()});
				blocks1[0].colums.Add(new TextColumns{Anchor=TextAnchor.UpperCenter, TextSize=24,OutlineColor ="0 0 0 0", TextList = new List<string>(){"<b><color=#DADADADA>ДОБРО ПОЖАЛОВАТЬ НА СЕРВЕР!</color></b>"}, PositionType = "MiddleCenter",Center = "0.5 0.95", Height = 30.0, Width=550.0});
				blocks1[0].colums.Add(new TextColumns{Anchor=TextAnchor.MiddleCenter, TextSize=16,OutlineColor ="0 0 0 0", TextList = new List<string>(){
					"Мы рады приветствовать вас на сервере <color=yellow>БЛА БЛА СЕРВ</color>!",
                    "Наш сервер - отличный выбор для любителей спокойного развития и реалистичных сражений, с множеством приятных плагинов, не мешающих классическому геймплею и развитию.",
                    "Мы постарались сделать внешний вид сервера более удобным для восприятия.",
                    "Наши сервера мы делаем учитывая все ваши пожелания!",
                    "Играйте на наших серверах, советуйте другим, помогайте нам своими предложениями сделать сервер лучше!",
                    "У нас самая лояльная администрация!"
				}, PositionType = "MiddleCenter",Center = "0.5 0.5", Height = 200.0, Width=550.0});
		
				Tab1.Add(new Tabs(){Title = "ПРИМЕР С КНОПКАМИ", Pages = new List<Page>()});
				Tab1[1].Pages.Add(new Page(){Images = new List<Images>(),Buttons = new List<Buttons>(), blocks = new List<TextBlocks>()});
				//Изображения
				List<Images> Images2 = Tab1[1].Pages[0].Images;
				Images2.Add(new Images(){URL="https://i.ibb.co/7bmLn7P/xdcobalt.jpg", PositionType="UpperLeft",Center= "0.0 0.805", Height = 150.0, Width=150.0});
				//Тексты
				List<TextBlocks> blocks2 = Tab1[1].Pages[0].blocks;
				blocks2.Add(new TextBlocks(){colums = new List<TextColumns>()});
				blocks2[0].colums.Add(new TextColumns{Anchor=TextAnchor.UpperCenter, TextSize=24,OutlineColor ="0 0 0 0", TextList = new List<string>(){"<b><color=#DADADADA>ЛАБОРАТОРИЯ КОБАЛЬТ</color></b>"}, PositionType = "MiddleCenter",Center = "0.5 0.95", Height = 30.0, Width=550.0});
				blocks2[0].colums.Add(new TextColumns{Anchor=TextAnchor.UpperLeft, TextSize=16,OutlineColor ="0 0 0 0", TextList = new List<string>(){"<color=#DADADADA>Никто не знает что происходит на этом острове!\nПериодически ученые разворачивают на нем иследовательские центры под засекреченным названием <<КОБАЛЬТ>></color>"}, PositionType = "UpperLeft",Center = "0.0 0.9", Height = 100.0, Width=550.0});
				blocks2[0].colums.Add(new TextColumns{Anchor=TextAnchor.UpperLeft, TextSize=16,OutlineColor ="0 0 0 0", TextList = new List<string>(){"<color=#DADADADA>Данные базы очень хорошо охраняются, а раз они хорошо охраняются, значит там есть чем поживиться.</color>"}, PositionType = "UpperLeft",Center = "0.315 0.807", Height = 70.0, Width=350.0});
				blocks2[0].colums.Add(new TextColumns{Anchor=TextAnchor.UpperLeft, TextSize=16,OutlineColor ="0 0 0 0", TextList = new List<string>(){"<color=#e84c3d>Будьте внимательны!</color> <color=#DADADADA>После того как вы доберетесь до ценного груза, сработает сигнализация. На звук сирены приходит подмога! Ученые серьезно вооружены и откроют огонь на поражение по любому кто приблизится к базе!</color>"}, PositionType = "UpperLeft",Center = "0.315 0.723", Height = 100.0, Width=350.0});
				
				//Кнопки
				List<Buttons> Buttons = Tab1[1].Pages[0].Buttons;
				Buttons.Add(new Buttons(){isClient=true,CommandText="chat.say TEST",CloseMenu=true,Color="#d035266D",Caption="Первая кнопка для текста в чат",TextSize=16, PositionType = "MiddleCenter",Center = "0.5 0.5", Height = 30.0, Width=550.0});
				Buttons.Add(new Buttons(){isClient=false,CommandText="inventory.giveto %STEAMID% rifle.ak 1",CloseMenu=true,Color="#df35266D",Caption="Выдать АК47 используя %STEAMID%",TextSize=16, PositionType = "MiddleCenter",Center = "0.5 0.42", Height = 30.0, Width=550.0});

				conf.tabs.Add("main",Tab1);
                return conf;
            }
        }

        public class Tabs
        {
            [JsonProperty("Заголовок вкладки")]
            public string Title;
            [JsonProperty("Страницы")]
            public List<Page> Pages = new List<Page>();
        }

        public class Page
        {
            [JsonProperty("Изображения")]
            public List<Images> Images = new List<Images>();
            [JsonProperty("Кнопки")]
            public List<Buttons> Buttons = new List<Buttons>();
            [JsonProperty("Блоки текста")]
            public List<TextBlocks> blocks = new List<TextBlocks>();
        }

        public class Images
        {
            [JsonProperty("Ссылка")]
            public string URL;
            [JsonProperty("Алгоритм позиционирования (LeftTop,MiddleCenter,RightBottom и т.д")]
            public string PositionType = "MiddleCenter";
            [JsonProperty("Позиция изображения ((0.0 - 1.0),(0.0 - 1.0))")]
            public string Center = "0.5 0.5";
            [JsonProperty("Ширина (в пикселях)")]
            public double Width;
            [JsonProperty("Высота (в пикселях)")]
            public double Height;
        }
        public class Buttons
        {
            [JsonProperty("Это команда клиентская?")]
            public bool isClient = true;
            [JsonProperty("Команда (Допускаются шаблоны %STEAMID%)")]
            public string CommandText="";
            [JsonProperty("Нужно ли закрыть меню?")]
            public bool CloseMenu = true;
            [JsonProperty("Цвет кнопки (RGBA)")]
            public string Color;
            [JsonProperty("Заголовок кнопки")]
            public string Caption="";
            [JsonProperty("Размер шрифта")]
            public int TextSize;
            [JsonProperty("Алгоритм позиционирования (LeftTop,MiddleCenter,RightBottom и т.д")]
            public string PositionType = "MiddleCenter";
            [JsonProperty("Позиция размещения ((0.0 - 1.0),(0.0 - 1.0))")]
            public string Center = "0.5 0.5";
            [JsonProperty("Ширина (в пикселях)")]
            public double Width;
            [JsonProperty("Высота (в пикселях)")]
            public double Height;
        }


        public class TextBlocks
        {
            [JsonProperty("Колонки текста")]
            public List<TextColumns> colums = new List<TextColumns>();
        }

        public class TextColumns
        {
            [JsonProperty("Выравнивание (Left/Center/Right))")]
            public TextAnchor Anchor;

            [JsonProperty("Размер шрифта")]
            public int TextSize;
            [JsonProperty("Цвет тени текста (RGBA)")]
            public string OutlineColor;
            [JsonProperty("Строки текста")]
            public List<string> TextList = new List<string>();
            [JsonProperty("Алгоритм позиционирования (LeftTop,MiddleCenter,RightBottom и т.д")]
            public string PositionType = "MiddleCenter";
            [JsonProperty("Позиция размещения блока текста ((0.0 - 1.0),(0.0 - 1.0))")]
            public string Center = "0.5 0.5";
            [JsonProperty("Ширина (в пикселях)")]
            public double Width;
            [JsonProperty("Высота (в пикселях)")]
            public double Height;
        }    
		
		
		
		protected override void LoadConfig()
		{
			base.LoadConfig();
			try
			{
				config = Config.ReadObject<PluginConfig>();
				if (config?.tabs == null || config.tabs.Count<1){
					//if (config.tabs[0].Pages==null || config.tabs[0].Pages.Count<1){
						PrintWarning("Errorn in config file. Created default config.");
						LoadDefaultConfig();
					//}
				}
			}
			catch
			{
				LoadDefaultConfig();
			}
			NextTick(SaveConfig);
		}
		
		protected override void SaveConfig() => Config.WriteObject(config);
		//////////////////////
		
        protected override void LoadDefaultConfig()
        {            
            config = PluginConfig.DefaultConfig();
        }
		
		#endregion

		#region Hooks	            
        private void OnServerInitialized()
        {
            PrintWarning("\n-----------------------------\n" +
            "     Author - https://topplugin.ru/\n" +
            "     VK - https://vk.com/rustnastroika\n" +
            "     Discord - https://discord.com/invite/5DPTsRmd3G\n" +
            "-----------------------------");
            if (!ImageLibrary)
            {
                PrintError("Imagelibrary not found!"); 
                return;
            }
            IEnumerable<Images> images = from messages in config.tabs.Values from message in messages from pages in message.Pages from image in pages.Images select image;
            foreach (var image in images.ToList())            
                ImageLibrary?.Call("AddImage", image.URL, image.URL);     
			
        }                      
 
        private void Unload()
        {
            BasePlayer.activePlayerList.ToList().ForEach(player => 
				{ 
					CuiHelper.DestroyUi(player, BaseLayer);					
					CuiHelper.DestroyUi(player, LeftLayer);
				});
        }
		#endregion
		
		#region GUI
		private static string BaseLayer = "InfoMenu_base";
		private static string LeftLayer = "InfoMenu_left";
		private static string ContentLayer = "InfoMenu_content";
		
        [ConsoleCommand("infomenu_selectpage")]
        private void cmdSelectPage(ConsoleSystem.Arg args)
        {
            var player = args.Player();
			string group = args.Args[0];
            var tabIndex = args.GetInt(1);
            var page = args.GetInt(2);			
            CreateMenu(player, group, tabIndex, page, false);
        } 
		
        [ConsoleCommand("im_exec_cmd")]
        void ConsoleMenu(ConsoleSystem.Arg args)
        {
            var player = args.Player();     
			if (player==null) return;
            if (!player || !args.HasArgs(5)) return;
			string group = args.Args[0];
            bool isClient = bool.Parse(args.Args[1]);
            bool CloseMenu = bool.Parse(args.Args[2]);
            int tabIndex = args.GetInt(3);
            int page = args.GetInt(4);
            int but = args.GetInt(5);
			var Group = config.tabs[group];
			if (Group==null) return;
			if (Group.Count<tabIndex || Group[tabIndex]==null) return; 
			if (Group[tabIndex].Pages.Count<page || Group[tabIndex].Pages[page]==null) return;
			if (Group[tabIndex].Pages[page].Buttons.Count<but || Group[tabIndex].Pages[page].Buttons[but]==null) return;
			string command = Group[tabIndex].Pages[page].Buttons[but].CommandText;
			if (string.IsNullOrEmpty(command)) return;
			string commanda =command.Replace("'", "").Replace("%STEAMID%", player.UserIDString);
			if (isClient){
				player.Command(commanda);
			}else{
				rust.RunServerCommand(commanda);
			}
			if (CloseMenu) player.Command("closemenusystem");
        }
		
        private void CreateMenu(BasePlayer player, string group, int tabIndex = 0, int page = 0, bool isStart = true)
        {        
			Puts($"player={player} group={group}");
            CuiElementContainer container = new CuiElementContainer();
			
			if (isStart)
			{
				container.Add(new CuiPanel
				{
					CursorEnabled = true,
					Image =	{Color = "0 0 0 0"},
					RectTransform = {AnchorMin = "0.276 0", AnchorMax = "0.945 1", OffsetMin = "0 0", OffsetMax = "0 0"}
				}, "Menu_UI", BaseLayer);
				
				container.Add(new CuiPanel()
				{ 
					CursorEnabled = true,
					RectTransform = {AnchorMin = "0 0", AnchorMax = "0.289 1", OffsetMin = "0 0", OffsetMax = "0 0"},
					Image         = {Color = "0.549 0.270 0.215 0.7", Material = "" }
				}, BaseLayer, BaseLayer + ".RedPanel");				
				
				
				container.Add(new CuiPanel()
				{ 
					CursorEnabled = true,
					RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0"},
					Image         = {Color = "0 0 0 0" }
				}, BaseLayer + ".RedPanel", BaseLayer + ".Left");			
				
				container.Add(new CuiPanel()
				{ 
					CursorEnabled = true,
					RectTransform = {AnchorMin = "0.289 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0"},
					Image         = {Color = "0.117 0.121 0.109 0.95" }
				}, BaseLayer, BaseLayer + ".CONTENT_MAIN");		
				container.Add(new CuiLabel
				{
					RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = "20 -100", OffsetMax = "0 -15"},
					Text = { Text = "ИНФОРМАЦИЯ", Align = TextAnchor.UpperLeft, Font = "robotocondensed-bold.ttf", Color = "0.929 0.882 0.847 0.8", FontSize = 33 }
				}, BaseLayer + ".Left");
							
			}
			
			CuiHelper.DestroyUi(player, LeftLayer);
						
			// левая панель меню под кнопки 
			container.Add(new CuiPanel
			{
				Image =
				{
					Color = "0 0 0 0"
				},
				RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0"},
			}, BaseLayer + ".Left", LeftLayer);
			 
			
			CuiHelper.DestroyUi(player, ContentLayer); 
			container.Add(new CuiPanel()
			{ 
				CursorEnabled = true,
				RectTransform = {AnchorMin = "0.05 0", AnchorMax = "0.95 1", OffsetMin = "0 0", OffsetMax = "0 0"},
				Image         = {Color = "0 0 0 0" }
			}, BaseLayer + ".CONTENT_MAIN", ContentLayer); 
		
		
			var Group = config.tabs[group];
			
			//ССЫЛКИ 
			float topPosition = (Group.Count() / 2f * HEIGHT_MENU_ELEMENT + (Group.Count() - 1) / 2f * 5);
			int i=0;
			foreach (var res in Group){
				container.Add(new CuiButton 
				{
					RectTransform = { AnchorMin = "0 0.5", AnchorMax = "1 0.51", OffsetMin = $"0 {topPosition - HEIGHT_MENU_ELEMENT}", OffsetMax = $"0 {topPosition}" },
					Button = { Color = tabIndex == i ? "0.149 0.145 0.137 0.8" : "0 0 0 0", Command = $"infomenu_selectpage {group} {i} {0}"},
					Text = { Text = "", Align = TextAnchor.MiddleRight, Font = "robotocondensed-bold.ttf", FontSize = 14 }
				}, LeftLayer, LeftLayer + i); 
		
				container.Add(new CuiLabel
				{
					RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = $"0 0", OffsetMax = $"-20 0" },
					Text = { Text = res.Title.ToUpper(), Align = TextAnchor.MiddleRight, Font = "robotocondensed-bold.ttf", FontSize = 18, Color = "0.929 0.882 0.847 1"}
				}, LeftLayer + i);
				i++;
				topPosition -= HEIGHT_MENU_ELEMENT + 5;
			}
			var PageTab = Group[tabIndex];
            var PageSelect = PageTab.Pages[page];

			string omin="";
			string omax="";
			// расставляем изображения на выбранной странице
            if (PageSelect.Images.Count > 0)
            {
                foreach (var image in PageSelect.Images)
                {
					//Смотрим алгоритм позиционирования
					GetOffsetPos(image.PositionType.ToUpper(),image.Height, image.Width, ref omin, ref omax);
                    container.Add(new CuiElement()
                    {
                        Parent = ContentLayer,
                        Components = {
                            new CuiRawImageComponent {
                                Png = (string)ImageLibrary?.Call("GetImage", image.URL), Color = "1 1 1 0.9"
                            }
                            , new CuiRectTransformComponent {
                                AnchorMin=$"{image.Center}", AnchorMax= $"{image.Center}", OffsetMin = omin, OffsetMax = omax
                            },
                        }
                    }
                    );
                }
            }	
			// расставляем текст на выбранной странице
            foreach (var block in PageSelect.blocks)
            {
                foreach (var select in block.colums)
                {
					var text = string.Join("\n", select.TextList);
					
					GetOffsetPos(select.PositionType.ToUpper(),select.Height, select.Width, ref omin, ref omax);
					
                    container.Add(new CuiElement
                    {
                        Name = CuiHelper.GetGuid(),
                        Parent = ContentLayer, 
                        Components =
                            {
                                new CuiTextComponent { Text = text, FontSize = select.TextSize, Align = select.Anchor, Color = "1 1 1 1",Font="robotocondensed-regular.ttf" , FadeIn = isStart ? 0.5f : 0.2f},
                                new CuiRectTransformComponent{ AnchorMin = select.Center, AnchorMax = select.Center, OffsetMin = omin, OffsetMax = omax},
                                new CuiOutlineComponent {Color = ParseColorFromRGBA(select.OutlineColor), Distance = "0.5 -0.5" }
                            }
                    });
                }
            }
			// расставляем кнопки на выбранной странице
            if (PageSelect.Buttons.Count > 0)
            {
				int l=0;
                foreach (var button in PageSelect.Buttons)
                {
					//Смотрим алгоритм позиционирования
					GetOffsetPos(button.PositionType.ToUpper(),button.Height, button.Width, ref omin, ref omax);
					string cmd = $"im_exec_cmd {group} {button.isClient} {button.CloseMenu} {tabIndex} {page} {l}";
					
					container.Add(new CuiButton 
					{
						RectTransform = {AnchorMin=$"{button.Center}", AnchorMax= $"{button.Center}", OffsetMin = omin, OffsetMax = omax},
						Button = { Color = HexToCuiColor(button.Color), Command = cmd},
						Text = { Text = button.Caption, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = button.TextSize}
					}, ContentLayer, ContentLayer + "btn"+l); 
					l++;
                }
            }	
            #region Скип страниц
			if (PageTab.Pages.Count>1){
				if (page>0){
					container.Add(new CuiButton
					{
						RectTransform = { AnchorMin = "0.34 0.0", AnchorMax = $"0.407 0.11", OffsetMax = "0 0" },
						Button = { Color = "0 0 0 0", Command = $"infomenu_selectpage {group} {tabIndex} {page-1}"},
						Text = { Text = $"<", Font = "robotocondensed-bold.ttf", FontSize = 30, Align = TextAnchor.MiddleCenter }
					}, ContentLayer);
				}
				container.Add(new CuiButton
				{
					RectTransform = { AnchorMin = "0.41 0.0", AnchorMax = $"0.59 0.106", OffsetMax = "0 0" },
					Button = { Color = "0 0 0 0" },
					Text = { Text = $"СТРАНИЦА: {page+1}", Font = "robotocondensed-regular.ttf", FontSize = 16, Align = TextAnchor.MiddleCenter }
				}, ContentLayer);
				if (PageTab.Pages.Count > (page+1)){
					container.Add(new CuiButton
					{
						RectTransform = { AnchorMin = "0.593 0.0", AnchorMax = $"0.66 0.11", OffsetMax = "0 0" },
						Button = { Color = "0 0 0 0", Command = $"infomenu_selectpage {group} {tabIndex} {page+1}"} ,
						Text = { Text = $">", Font = "robotocondensed-bold.ttf", FontSize = 30, Align = TextAnchor.MiddleCenter }
					}, ContentLayer);
				}
			}
            #endregion

            CuiHelper.AddUi(player, container);
        }
		 
		
        private void CreateTab(BasePlayer player, string group, int tabIndex = 0, int page = 0)
        {        		
			var Group = config.tabs[group];		
			var PageTab = Group[tabIndex];
            var PageSelect = PageTab.Pages[page];

			string omin="";
			string omax="";
			
			CuiElementContainer container = new CuiElementContainer();
		
			CuiHelper.DestroyUi(player, ContentLayer);
			container.Add(new CuiPanel
			{
				CursorEnabled = true,
				Image =	{Color = "0 0 0 0"},
				RectTransform = { AnchorMin = "0.485 0", AnchorMax = "0.945 1" }
			}, "Menu_UI", ContentLayer);
			
			// расставляем изображения на выбранной странице
            if (PageSelect.Images.Count > 0)
            {
                foreach (var image in PageSelect.Images)
                {
					//Смотрим алгоритм позиционирования
					GetOffsetPos(image.PositionType.ToUpper(),image.Height, image.Width, ref omin, ref omax);
                    container.Add(new CuiElement()
                    {
                        Parent = ContentLayer,
                        Components = {
                            new CuiRawImageComponent {
                                Png = (string)ImageLibrary?.Call("GetImage", image.URL), Color = "1 1 1 0.9"
                            }
                            , new CuiRectTransformComponent {
                                AnchorMin=$"{image.Center}", AnchorMax= $"{image.Center}", OffsetMin = omin, OffsetMax = omax
                            },
                        }
                    });
                }
            }	
			// расставляем текст на выбранной странице
            foreach (var block in PageSelect.blocks)
            {
                foreach (var select in block.colums)
                {
					var text = string.Join("\n", select.TextList);
					
					GetOffsetPos(select.PositionType.ToUpper(),select.Height, select.Width, ref omin, ref omax);
					
                    container.Add(new CuiElement
                    {
                        Name = CuiHelper.GetGuid(),
                        Parent = ContentLayer, 
                        Components =
                            {
                                new CuiTextComponent { Text = text, FontSize = select.TextSize, Align = select.Anchor, Color = "1 1 1 1",Font="robotocondensed-regular.ttf" , FadeIn = 0.2f},
                                new CuiRectTransformComponent{ AnchorMin = select.Center, AnchorMax = select.Center, OffsetMin = omin, OffsetMax = omax},
                                new CuiOutlineComponent {Color = ParseColorFromRGBA(select.OutlineColor), Distance = "0.5 -0.5" }
                            }
                    });
                }
            }
			// расставляем кнопки на выбранной странице
            if (PageSelect.Buttons.Count > 0)
            {
				int l=0;
                foreach (var button in PageSelect.Buttons)
                {
					//Смотрим алгоритм позиционирования
					GetOffsetPos(button.PositionType.ToUpper(),button.Height, button.Width, ref omin, ref omax);
					string cmd = $"im_exec_cmd {group} {button.isClient} {button.CloseMenu} {tabIndex} {page} {l}";
					
					container.Add(new CuiButton 
					{
						RectTransform = {AnchorMin=$"{button.Center}", AnchorMax= $"{button.Center}", OffsetMin = omin, OffsetMax = omax},
						Button = { Color = HexToCuiColor(button.Color), Command = cmd},
						Text = { Text = button.Caption, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = button.TextSize}
					}, ContentLayer, ContentLayer + "btn"+l); 
					l++;
                }
            }
            #region Скип страниц
			if (PageTab.Pages.Count>1){
				if (page>0){
					container.Add(new CuiButton
					{
						RectTransform = { AnchorMin = "0.34 0.0", AnchorMax = $"0.407 0.11", OffsetMax = "0 0" },
						Button = { Color = "0 0 0 0", Command = $"infomenu_selectpage {group} {tabIndex} {page-1}"},
						Text = { Text = $"<", Font = "robotocondensed-bold.ttf", FontSize = 30, Align = TextAnchor.MiddleCenter }
					}, ContentLayer);
				}
				container.Add(new CuiButton
				{
					RectTransform = { AnchorMin = "0.41 0.0", AnchorMax = $"0.59 0.106", OffsetMax = "0 0" },
					Button = { Color = "0 0 0 0" },
					Text = { Text = $"СТРАНИЦА: {page+1}", Font = "robotocondensed-regular.ttf", FontSize = 16, Align = TextAnchor.MiddleCenter }
				}, ContentLayer);
				if (PageTab.Pages.Count > (page+1)){
					container.Add(new CuiButton
					{
						RectTransform = { AnchorMin = "0.593 0.0", AnchorMax = $"0.66 0.11", OffsetMax = "0 0" },
						Button = { Color = "0 0 0 0", Command = $"infomenu_selectpage {group} {tabIndex} {page+1}"} ,
						Text = { Text = $">", Font = "robotocondensed-bold.ttf", FontSize = 30, Align = TextAnchor.MiddleCenter }
					}, ContentLayer);
				}
			}
            #endregion

            CuiHelper.AddUi(player, container);
        }
		
		public void GetOffsetPos(string pos,double Height, double Width, ref string omin, ref string omax){
			switch(pos){
				case "UPPERLEFT":
					omin = $"0 -{Height}";
					omax = $"{Width} 0";
				break;
				case "UPPERCENTER": 
					omin = $"-{(float)Width/2} -{Height}";
					omax = $"{(float)Width/2} 0";
				break;
				case "UPPERRIGHT":
					omin = $"-{Width} -{Height}";
					omax = $"0 0";
				break; 
				case "MIDDLELEFT":
					omin = $"0 -{(float)Height/2}";
					omax = $"{Width} {(float)Height/2}";
				break;
				case "MIDDLECENTER":
					omin = $"-{(float)Width/2} -{(float)Height/2}";
					omax = $"{(float)Width/2} {(float)Height/2}";
				break;
				case "MIDDLERIGHT":
					omin = $"-{Width} -{(float)Height/2}";
					omax = $"0 {(float)Height/2}";
				break;
				case "BOTTOMLEFT":
					omin = $"0 0";
					omax = $"{Width} {Height}";
				break;
				case "BOTTOMCENTER":
					omin = $"-{(float)Width/2} 0";
					omax = $"{(float)Width/2} {Height}";
				break;
				case "BOTTOMRIGHT":
					omin = $"-{Width} 0";
					omax = $"0 {Height}";
				break;
			}
		}
		
		
		private void InitImage(ref CuiElementContainer container, string png, string ipanel)
		{
			container.Add(new CuiElement
			{
				Name = CuiHelper.GetGuid(),
				Parent = ipanel,				
				Components =
				{
					new CuiRawImageComponent { Png = png },
					new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
				}
			});
		}
		#endregion

        #region Helper
		
		private static string HexToCuiColor(string hex)
		{
			if (string.IsNullOrEmpty(hex))
			{
				hex = "#FFFFFFFF";
			}
			var str = hex.Trim('#');
			if (str.Length == 6)
				str += "FF";
			if (str.Length != 8)
			{
				throw new Exception(hex);
				throw new InvalidOperationException("Cannot convert a wrong format.");
			}
			var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
			var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
			var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
			var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);
			Color color = new Color32(r, g, b, a);
			return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
		}
        public static string ParseColorFromRGBA(string cssColor)
        {
            cssColor = cssColor.Trim();
            string[] parts = cssColor.Split(' ');
            int r = int.Parse(parts[0], CultureInfo.InvariantCulture);
            int g = int.Parse(parts[1], CultureInfo.InvariantCulture);
            int b = int.Parse(parts[2], CultureInfo.InvariantCulture);
            float a = float.Parse(parts[3], CultureInfo.InvariantCulture);
            var finish = System.Drawing.Color.FromArgb((int)(a * 255), r, g, b);
            cssColor = "#" + finish.R.ToString("X2") + finish.G.ToString("X2") + finish.B.ToString("X2") + finish.A.ToString("X2");
            var str = cssColor.Trim('#');
            if (str.Length == 6)
                str += "FF";
            if (str.Length != 8)
            {
                throw new Exception(cssColor);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }
            var r1 = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g1 = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b1 = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a1 = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);
            Color color = new Color32(r1, g1, b1, a1);
            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }

        #endregion
		
    }
}


// --- End of file: InfoMenu.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BloodRust-fuuu/MenuSystem.cs ---
// --- Original Local Path: BloodRust-fuuu/MenuSystem.cs ---

using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Rust;
using System;
using System.Linq;
using Random = UnityEngine.Random;
using ru = Oxide.Game.Rust;

namespace Oxide.Plugins
{
    [Info("MenuSystem", "TopPlugin.ru", "3.0.0")]
    class MenuSystem : RustPlugin
    {
        #region Вар
        private string Layer = "Menu_UI";

        [PluginReference] Plugin ImageLibrary;

        string Url = "";
        #endregion

        #region Класс
		public class MenuItem:SubMenuItem{
            [JsonProperty("Пункты подменю", Order = 1)]
			public List<SubMenuItem> items;
		}
		public class SubMenuItem{
            [JsonProperty("Заголовок пункта меню", Order = 1)]
			public string title;
            [JsonProperty("Чат команда для доступа к пункту меню", Order = 2)]
			public string chatCommand;
            [JsonProperty("Имя плагина, api которого необходимо вызвать", Order = 3)]
			public string pluginName;
            [JsonProperty("Имя функции из плагина для показа GUI", Order = 4)]
			public string functionName;
            [JsonProperty("Передаваемые аргументы (player - передавать не нужно он передается первым параметром)", Order = 5)]
			public List<object> args = new List<object>();
            [JsonProperty("Названия слоев для дестроя GUI", Order = 6)]
			public List<string> UILayers = new List<string>();
            [JsonProperty("Имя функции из плагина для дополнительной отработки закрытия", Order = 7)]
			public string closeFunctionName;
		}
		
		
        public class Settings
        {
            [JsonProperty("Название кнопки")] public string DisplayName;
            [JsonProperty("Описание")] public string Info;
            [JsonProperty("Команда")] public string Command;
        }
        #endregion

		public Dictionary<ulong,SubMenuItem> lastMenuElement = new Dictionary<ulong,SubMenuItem>();

        #region Кофниг
        Configuration config;
        class Configuration 
        {
            [JsonProperty("Расстояние между пунктами меню",Order=0)] public float punktOffset = 0.138f;
            [JsonProperty("Пункты меню",Order=1)] public Dictionary<string,MenuItem> menuItems;
            [JsonProperty("Настройки", Order=2)] public List<Settings> settings;
            public static Configuration GetNewConfig() 
            {
                return new Configuration
                {
					punktOffset = 0.138f,
                    settings = new List<Settings>() 
                    {
                        new Settings
                        {
                            DisplayName = "О СЕРВЕРЕ",
                            Info = "<b><size=20>О СЕРВЕРЕ</size></b>\n\nХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуитаnХуита",
                            Command = "i"
                        },
                        new Settings
                        {
                            DisplayName = "ПРАВИЛА",
                            Info = "<b><size=20>ПРАВИЛА</size></b>\n\nХуита",
                            Command = "p"
                        },
                        new Settings
                        {
                            DisplayName = "КОМАНДЫ И БИНДЫ",
                            Info = "<b><size=20>КОМАНДЫ И БИНДЫ</size></b>\n\nХуита",
                            Command = "b"
                        },
                    },
					menuItems = new Dictionary<string,MenuItem>(){
						["info"]  = new MenuItem(){
							title = "ГЛАВНАЯ",
							chatCommand="info",
							pluginName="",
							functionName="",
							args = new List<object>(){
								43,
								"ASD"
							},
							UILayers = new List<string>(){
								"UI_Layer1"
							},
							items = new List<SubMenuItem>(){
									new SubMenuItem(){
									title = "ПУНКТ1",
									chatCommand="info1",
									pluginName="",
									functionName="",
									args = new List<object>(){
										43,
										"ASD"
									},
									UILayers = new List<string>(){
										"UI_Layer1"
									},
								}
							}
						},
						["store"]  = new MenuItem(){
							title = "КОРЗИНА",
							chatCommand="store",
							pluginName="GameStoresRUST",
							functionName="InitializeStore",
							args = new List<object>(){
								"player"
							},
							UILayers = new List<string>(){
								"UI_GameStoresRUST_Store"
							}
						},
						["case"]  = new MenuItem(){
							title = "КЕЙСЫ",
							chatCommand="case",
							pluginName="CaseSystem",
							functionName="CaseUI",
							args = new List<object>(){
								"player"
							},
							UILayers = new List<string>(){
								"Case_UI"
							}
						},
						["cal"]  = new MenuItem(){
							title = "КАЛЕНДАРЬ",
							chatCommand="wipe",
							pluginName="WipeCalendar",
							functionName="CreateGui",
							args = new List<object>(){
								"player"
							},
							UILayers = new List<string>(){}
						},
						["wipe"]  = new MenuItem(){
							title = "ВАЙПБЛОК",
							chatCommand="wipe",
							pluginName="WipeCalendar",
							functionName="CreateGui",
							args = new List<object>(){
								"player"
							},
							UILayers = new List<string>(){}
						},
						["report"]  = new MenuItem(){
							title = "РЕПОРТ",
							chatCommand="wipe",
							pluginName="SoReport",
							functionName="StartUi",
							args = new List<object>(){
								"player"
							},
							UILayers = new List<string>(){"ReportMain","ReportBMod"}
						},
						["settings"]  = new MenuItem(){
							title = "НАСТРОЙКИ",
							chatCommand="settings",
							pluginName="",
							functionName="SettingsUI",
							args = new List<object>(){
								"player"
							},
							UILayers = new List<string>(){"settings","Settingsmain","UI_SettingsLayer.WINDOW_FRAME"}
						},
						["pass"]  = new MenuItem(){
							title = "БАТЛПАСС",
							chatCommand="pass",
							pluginName="PassSystem",
							functionName="PassUI",
							args = new List<object>(){
								"player"
							},
							UILayers = new List<string>(){"Pass"}
						}
					}
                };
            }
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config?.settings == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Ошибка чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfig();
        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion

        #region Хуки
        void OnServerInitialized()
        {
            PrintWarning("\n-----------------------------\n" +
            "     Author - https://topplugin.ru/\n" +
            "     VK - https://vk.com/rustnastroika\n" +
            "     Discord - https://discord.com/invite/5DPTsRmd3G\n" +
            "-----------------------------");
            ImageLibrary.Call("AddImage", "https://imgur.com/C2g6QoA.png", "Background");
            ImageLibrary.Call("AddImage", Url, "LogoImage");
			RegisterChatCommand();
        }
        #endregion

        #region Команды
		void RegisterChatCommand(){
			foreach (MenuItem item in config.menuItems.Values){
				if (!string.IsNullOrEmpty(item.chatCommand)) Interface.Oxide.GetLibrary<ru.Libraries.Command>(null).AddChatCommand(item.chatCommand, this, "MenuChatCommands");
				if (item.items==null) continue;
				foreach (SubMenuItem item2 in item.items.Where(x => !string.IsNullOrEmpty(x.chatCommand))){
					Interface.Oxide.GetLibrary<ru.Libraries.Command>(null).AddChatCommand(item2.chatCommand, this, "SubMenuChatCommands");					
				}
			}
		}
		private void MenuChatCommands(BasePlayer player, string command, string[] args)=>MenuUI(player, command);
		private void SubMenuChatCommands(BasePlayer player, string command, string[] args)=>MenuUI(player, command, true);

        [ConsoleCommand("closemenusystem")]
        void ConsoleCloseMenu(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            DestroyUI(player);
            CuiHelper.DestroyUi(player, Layer);
			CheckAdditionalClose(player);
        }
		public void CloseMenu(BasePlayer player){			
            DestroyUI(player);
            CuiHelper.DestroyUi(player, Layer);
			CheckAdditionalClose(player);
		}
        [ConsoleCommand("menu")]
        void ConsoleMenu(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            //ActiveButton[player.userID] = args.Args[0];
            DestroyUI(player);
            ButtonUI(player, args.Args[0]);
        }
        #endregion
        
        #region Интерфейс
        void MenuUI(BasePlayer player, string name = "menu", bool sub=false)
        {
			int pos = 0;
			if (sub){
				DestroySubUI(player,name);
				//Ищем меню первого уровня и позицию подпункта
				foreach(KeyValuePair<string, MenuItem> item1 in config.menuItems.Where(x=>x.Value.items!=null && x.Value.items.Count>0)){
					for(int i=0;i<item1.Value.items.Count;i++){
						if (item1.Value.items[i].chatCommand==name){
							pos = i;
							name = item1.Key;
						}						
					}				
				}			
			}
			
			
			
            CuiHelper.DestroyUi(player, Layer);
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.9" },
            }, "Overlay", Layer);

            container.Add(new CuiElement
            {
                Parent = Layer,
                Components =
                {
                    new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", "Background") },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" }
                }
            });

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.05 0.8", AnchorMax = "0.24 0.88", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0" }
            }, Layer, "Logo");

            container.Add(new CuiElement
            {
                Parent = "Logo",
                Components =
                {
                    new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", "LogoImage") },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" }
                }
            });

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.068 0.17", AnchorMax = "0.2 0.73", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0" }
            }, Layer, "Button");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.945 0.91", AnchorMax = $"1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = "closemenusystem" },
                Text = { Text = $"✖", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 50, Font = "robotocondensed-bold.ttf" }
            }, Layer);

            CuiHelper.AddUi(player, container);
            DestroyUI(player);
            ButtonUI(player, name);
			SubUI(player, name, pos);
        }

		void CheckAdditionalClose(BasePlayer player){			
			//Смотрим щелкали ли мы куда то ранее и нужно ли вызывать доп функцию закрытия
			if (!lastMenuElement.ContainsKey(player.userID)) lastMenuElement.Add(player.userID, null);
			SubMenuItem last = lastMenuElement[player.userID];
			if (last!=null){
				Puts($"LAST ELEMENT IS {last.pluginName}");
				if (!string.IsNullOrEmpty(last.closeFunctionName)){
					if (!string.IsNullOrEmpty(last.pluginName) && plugins.Find(last.pluginName)){ 
						Puts("CALL CLOSE FUNCTION");
						plugins.Find(last.pluginName).Call(last.closeFunctionName, player);
					}							
				}
			}
		}
		bool ExecExternalCMD(SubMenuItem item, BasePlayer player){
			string pluginName="";
			CheckAdditionalClose(player);
			
			if (item==null || player == null || string.IsNullOrEmpty(item.functionName)) return false;
			if (item.functionName == "close") {CloseMenu(player);return false;}
			pluginName = "MenuSystem";
			if (!string.IsNullOrEmpty(item.pluginName)) pluginName = item.pluginName;
			if (!plugins.Find(pluginName)) {PrintWarning($"Plugin not found: {pluginName}");return false;}
			var Plugin = plugins.Find(pluginName);
			if (Plugin==null) return false;
			if (item.args==null || item.args.Count==0){
				Plugin.Call(item.functionName, player);				
				Puts($"{pluginName}.Call({item.functionName}, {player});");
			}
			switch(item.args.Count){
				case 1: 
					Plugin.Call(item.functionName, player, item.args[0]);
					break;
				case 2: 
					Plugin.Call(item.functionName, player,item.args[0],item.args[1]);
					break;
				case 3: 
					Plugin.Call(item.functionName, player,item.args[0],item.args[1],item.args[2]);
					//Puts($"Plugin.Call({item.functionName}, {player},{item.args[0]},{item.args[1]},{item.args[2]});");
					break;
				case 4: 
					Plugin.Call(item.functionName, player,item.args[0],item.args[1],item.args[2],item.args[3]);
					break;
			}	
			//Сохраняем указатель что открыли
			lastMenuElement[player.userID] = item;
			return true;
		}

        void ButtonUI(BasePlayer player, string name="")
        {			
            //DestroyUI(player);
            CuiHelper.DestroyUi(player, "Command");
            CuiHelper.DestroyUi(player, "Info");
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.13", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0"  }
            }, "Button", "Command");
			
			string cmd = "";
            float width = 1f, height = config.punktOffset, startxBox = 0f, startyBox = 0.995f - height, xmin = startxBox, ymin = startyBox;
            foreach (KeyValuePair<string, MenuItem> item in config.menuItems)
            {
                //var color = ActiveButton[player.userID] == item.Key ? "1 1 1 1" : "1 1 1 0.3";
				var color ="1 1 1 0.3";
				if (name == item.Key){
					ExecExternalCMD(item.Value, player);
					color = "1 1 1 1";
				}
				cmd = $"menu {item.Key}";
				if (item.Value.items!=null && item.Value.items.Count>0) cmd = $"subMenu {item.Key}";
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{xmin} {ymin}", AnchorMax = $"{xmin + width} {ymin + height * 1}", OffsetMin = "0 1", OffsetMax = "0 -1" },
                    Button = { Color = "0 0 0 0", Command = cmd },
                    Text = { Text = item.Value.title, Color = color, Align = TextAnchor.MiddleLeft, FontSize = 25, Font = "robotocondensed-bold.ttf" }
                }, "Command");

                xmin += width;
                if (xmin + width >= 1)
                {
                    xmin = startxBox;
                    ymin -= height;
                }
            }

            CuiHelper.AddUi(player, container);
        }
		
        [ConsoleCommand("subMenu")]
        void ConsoleSubMenuCmd(ConsoleSystem.Arg args)
        {
			var player = args.Player();
			if (args.Args.Length==0) return;
			int pos = 0;
			if (args.Args.Length==2) 
				if (!int.TryParse(args.Args[1], out pos)) pos =0;
            //ActiveButton[player.userID] = args.Args[0];
            DestroyUI(player);
            ButtonUI(player, args.Args[0]);
			SubUI(player, args.Args[0],pos);
        }
        void SubUI(BasePlayer player, string keyItem, int pos = 0)
        {
			if (!config.menuItems.ContainsKey(keyItem)) return;
			MenuItem item = config.menuItems[keyItem];
			if (item==null || item.items==null || item.items.Count<1) {
				//PrintWarning($"MenuItem {keyItem} not contains submenu");
				return;
			}
            //ActiveButton2[player.userID] = "i";
            var container = new CuiElementContainer();
			
            CuiHelper.DestroyUi(player, "Info");
			
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.276 0", AnchorMax = "0.945 1", OffsetMax = "0 0" },
                Image = { Color = "0.117 0.121 0.109 0" }
            }, Layer, "Info");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0.289 1", OffsetMax = "0 0" },
                Image = { Color = "0.549 0.270 0.215 0.7", Material = "" }
            }, "Info", "Left");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.09 0.91", AnchorMax = $"1 1", OffsetMax = "0 0" },
                Text = { Text = item.title, Color = "0.929 0.882 0.847 0.8", Align = TextAnchor.MiddleLeft, FontSize = 33, Font = "robotocondensed-bold.ttf" }
            }, "Left");

            CuiHelper.AddUi(player, container);
            SubButton(player,keyItem,pos);
        }


        void SubButton(BasePlayer player, string keyItem,int index=0)
        {
			if (!config.menuItems.ContainsKey(keyItem)) return;
			MenuItem item = config.menuItems[keyItem];
			if (item==null || item.items==null || item.items.Count<1) {
				PrintWarning($"MenuItem {keyItem} not contains submenu");
				return;
			}
            CuiHelper.DestroyUi(player, "InfoButton");
            CuiHelper.DestroyUi(player, "Menu_UI2");
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0"  }
            }, "Left", "InfoButton");

            float width = 1f, height = 0.06f, startxBox = 0f, startyBox = 0.6f - height, xmin = startxBox, ymin = startyBox;
			int i=0;
			SubMenuItem SelectedItem = null;
            foreach (SubMenuItem check in item.items)
            {
                var color =  "0 0 0 0";
				if (index == i){
					SelectedItem = check;
					color = "0.149 0.145 0.137 0.8";
				}
				
				container.Add(new CuiPanel
				{
					RectTransform = { AnchorMin = "0.289 0", AnchorMax = "1 1", OffsetMax = "0 0" },
					Image = { Color = "0.117 0.121 0.109 0.8" }
				}, "Info", "Menu_UI2");
				
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{xmin} {ymin}", AnchorMax = $"{xmin + width} {ymin + height * 1}", OffsetMin = "0 1", OffsetMax = "0 -1" },
                    Button = { Color = color, Command = $"subMenu {keyItem} {i}" },
                    Text = { Text = $"{check.title}      ", Color = "1 1 1 0.8", Align = TextAnchor.MiddleRight, FontSize = 18, Font = "robotocondensed-bold.ttf" }
                }, "InfoButton");
				
                

                xmin += width;
                if (xmin + width >= 1)
                {
                    xmin = startxBox;
                    ymin -= height;
                }
				i++;
            }

            CuiHelper.AddUi(player, container);
			if (SelectedItem!=null)	ExecExternalCMD(SelectedItem, player);
			
        }
		

        /*
        void MapUI(BasePlayer player) {
            player.Command("map.open");
            player.Command("map_settings");
        }*/
        #endregion

        #region Хелпер
        void DestroyUI(BasePlayer player)
        {
			foreach (MenuItem menuItem in config.menuItems.Values.Where(x => x.UILayers!=null && x.UILayers.Count>0))
            {				
				foreach (string layer in menuItem.UILayers)
					CuiHelper.DestroyUi(player, layer);
			}
			CuiHelper.DestroyUi(player, "Info");
        }
        void DestroySubUI(BasePlayer player, string key)
        {
			if (!config.menuItems.ContainsKey(key)) return;
			if (key!="map") player.Command("close_map");
			MenuItem menuItem = config.menuItems[key];			
			if (menuItem.items==null || menuItem.items.Count<1) return;
			foreach (SubMenuItem subMenu in menuItem.items.Where(x=>x.UILayers!=null && x.UILayers.Count>0))
				foreach (string layer in subMenu.UILayers) CuiHelper.DestroyUi(player, layer);
        }
        #endregion
    }
}

// --- End of file: MenuSystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BloodRust-fuuu/XWipeCalendar.cs ---
// --- Original Local Path: BloodRust-fuuu/XWipeCalendar.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("XWipeCalendar", "TopPlugin.ru", "3.0.0")]
    class XWipeCalendar : RustPlugin
    {
		#region Configuration

        private CalendarConfig config;

        private class CalendarConfig
        {		          
			internal class GUISetting
			{
				[JsonProperty("Цвет фона_1")]
				public string ColorBackgroundO;					
				[JsonProperty("Цвет фона_2")]
				public string ColorBackgroundT;				
				[JsonProperty("Цвет чисел текучего месяца")]
				public string ColorNumericM;					
				[JsonProperty("Цвет чисел следующего месяца")]
				public string ColorNumericNM;				
				[JsonProperty("Цвет блоков")]
				public string ColorBlock;				
				[JsonProperty("Закрытие календаря нажатием в любой точке экрана")]
				public bool ButtonClose;				
			}
			
			internal class EventsSetting
		    {
				[JsonProperty("Цвет")]
				public string Color;			
				[JsonProperty("Список дней события")]
				public List<int> Day; 
				
				public EventsSetting(string color, List<int> day)
				{
					Color = color; Day = day;
				}
			}
				
			[JsonProperty("Настройка GUI")]
			public GUISetting GUI;			
			[JsonProperty("Список событий. Описание событий - oxide/lang")]
			public List<EventsSetting> Events;
			[JsonProperty("Время по МСК")]			
			public DateTime MSCTime;
			
			public static CalendarConfig GetNewConfiguration()
            {
                return new CalendarConfig
                {
					GUI = new GUISetting
					{
						ColorBackgroundO = "0.517 0.521 0.509 0.95",
						ColorBackgroundT = "0.217 0.221 0.209 0.95",
						ColorNumericM = "1 1 1 0.75",
						ColorNumericNM = "1 1 1 0.1",
						ColorBlock = "0.417 0.421 0.409 0.95",
						ButtonClose = false
					},
					Events = new List<EventsSetting>
					{
						new EventsSetting("0.61 0.18 0.18 1", new List<int> { 3, 16 } ),
						new EventsSetting("0.5 0.18 0.61 1", new List<int> { 5, 38 } ),
						new EventsSetting("0.18 0.21 0.61 1", new List<int> { 8, 14 } ),
						new EventsSetting("0.18 0.49 0.61 1", new List<int> { 21, 34 } ),
						new EventsSetting("0.21 0.61 0.18 1", new List<int> { 11 } ),
						new EventsSetting("0.61 0.55 0.18 1", new List<int> { 29 } ),
						new EventsSetting("0.61 0.31 0.18 1", new List<int> { 25 } )
					}
				};
			}
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
			
			try
			{
				config = Config.ReadObject<CalendarConfig>();
			}
			catch
			{
				PrintWarning("Ошибка чтения конфигурации! Создание дефолтной конфигурации!");
				LoadDefaultConfig();
			}
			
			SaveConfig();
        }
		protected override void LoadDefaultConfig() => config = CalendarConfig.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion
		
		#region Gommands
		
		[ChatCommand("wipe")]
		private void cmdOpenGUI(BasePlayer player)
		{
			if (permission.UserHasPermission(player.UserIDString, "xwipecalendar.use"))
			    GUI(player);
			else
				SendReply(player, lang.GetMessage("CHATNP", this, player.UserIDString));
		}		
		
		[ChatCommand("calendar")]
		private void cmdOpenGUII(BasePlayer player)
		{
			if (permission.UserHasPermission(player.UserIDString, "xwipecalendar.use"))
			    GUI(player);
			else
				SendReply(player, lang.GetMessage("CHATNP", this, player.UserIDString));
		}
		
		#endregion
		
		#region Hooks
		
		private void OnServerInitialized()
		{		
                        PrintWarning("\n-----------------------------\n" +
                        "     Author - https://topplugin.ru/\n" +
                        "     VK - https://vk.com/rustnastroika\n" +
                        "     Discord - https://discord.com/invite/5DPTsRmd3G\n" +
                        "-----------------------------");
			
			permission.RegisterPermission("xwipecalendar.use", this);
			
			InitializeLang();
			MSC();
		}
		
		private void OnServerSave() => MSC();
		
		private void MSC()
		{
			webrequest.Enqueue("https://time100.ru/api.php", null, (code, response) =>
            {
                if (code != 200 || response == null) return;
				
			    config.MSCTime = new DateTime(1970, 1, 1, 0, 0, 0, 0).ToLocalTime().AddSeconds(double.Parse(response));
			    Config.WriteObject(config);
            }, this);
		}
		
		#endregion
		
		#region GUI
		
		void GUI(BasePlayer player)
		{
			CuiHelper.DestroyUi(player, ".OverlayB");
            CuiElementContainer container = new CuiElementContainer();
				
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.276 0", AnchorMax = "0.945 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0" }
            }, "Menu_UI", ".OverlayB");			
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-357.5 -267.5", OffsetMax = "357.5 267.5" },
                Image = { Color = config.GUI.ColorBackgroundO, Material = "assets/icons/greyout.mat" }
            }, ".OverlayB", ".Overlay");
			
			if (config.GUI.ButtonClose)
			    container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "-350 -125", OffsetMax = "350 125" },
                    Button = { Color = "0 0 0 0", Close = ".OverlayB" },
                    Text = { Text = "" }
                }, ".Overlay");
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                Image = { Color = config.GUI.ColorBackgroundT }
            }, ".Overlay", ".OverlayGUI");
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-357.5 220", OffsetMax = "357.5 225" },
                Image = { Color = config.GUI.ColorBackgroundO, Material = "assets/content/ui/uibackgroundblur.mat" }
            }, ".Overlay");
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "319 220", OffsetMax = "314 267.5" },
                Image = { Color = config.GUI.ColorBackgroundO, Material = "assets/content/ui/uibackgroundblur.mat" }
            }, ".Overlay");	
			
			container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-310 220", OffsetMax = "350 267.5" },
                Text = { Text = string.Format(lang.GetMessage("TITLE", this, player.UserIDString), lang.GetMessage(config.MSCTime.ToString("MMMM"), this, player.UserIDString), config.MSCTime.Year), Align = TextAnchor.MiddleCenter, FontSize = 18, Color = "1 1 1 0.75" }
            }, ".Overlay");
			
			int x = 0, y = 0, z = 1, h = 0, g = 0, j = 0;
			int daynow = config.MSCTime.Day;
			
			for (int i = 1; i <= 42; i++)
			{
				container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"{-347.5 + (x * 100)} {132.5 - (y * 65)}", OffsetMax = $"{-252.5 + (x * 100)} {192.5 - (y * 65)}" },
                    Image = { Color = config.GUI.ColorBlock, Material = "assets/content/ui/uibackgroundblur.mat" }
                }, ".OverlayGUI", ".GUII" + i);	
				
				x++;
					
			    if (x == 7)
				{
				    x = 0;
					y++;
					
					if (y == 6)
						break;
				}
			}
			
			int eventscount = config.Events.Count;
			DateTime date = new DateTime(config.MSCTime.Year, config.MSCTime.Month, 1);
			int dayscount = DateTime.DaysInMonth(config.MSCTime.Year, config.MSCTime.Month);
			int dayofweek = (int)date.DayOfWeek == 0 ? 7 : (int)date.DayOfWeek;
			
		    container.Add(new CuiElement
            {
                Parent = ".GUII" + (config.MSCTime.Day + dayofweek - 1),
                Components =
                {
					new CuiImageComponent { Color = "0.417 0.421 0.409 0.95", Material = "assets/content/ui/uibackgroundblur.mat" },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
					new CuiOutlineComponent { Color = "0.75 0.75 0.75 1", Distance = "1.5 1.5" }
                }
            });
			
			foreach(var events in config.Events)
			{
				foreach(var eventscolor in events.Day)
				{
					if (eventscolor + dayofweek - 1 > 42) continue;  
					
				    container.Add(new CuiPanel
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                        Image = { Color = events.Color, Material = "assets/content/ui/uibackgroundblur.mat" }
                    }, ".GUII" + (eventscolor + dayofweek - 1));
				}
				
				container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"{-47.5 - (47.5 * (eventscount + (eventscount * 0.0525 - 0.0525) - 1)) + (g * 100)} -257.5", OffsetMax = $"{47.5 - (47.5 * (eventscount + (eventscount * 0.0525 - 0.0525) - 1)) + (g * 100)} -197.5" },
                    Image = { Color = events.Color, Material = "assets/content/ui/uibackgroundblur.mat" }
                }, ".OverlayGUI", ".EventText");
				
				container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Text = { Text = lang.GetMessage("EVENT" + (1 + g), this, player.UserIDString), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 14, Color = "1 1 1 0.75" }
                }, ".EventText");
				
				g++;
				
				if (g == 7)
					break;
			}
			
			for (int i = 0; i <= 6; i++)
			{
				container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"{-347.5 + (h * 100)} 196", OffsetMax = $"{-252.5 + (h * 100)} 216" },
                    Text = { Text = lang.GetMessage("DAY" + (1 + i), this, player.UserIDString), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 14, Color = "1 1 1 0.75" }
                }, ".OverlayGUI");
				
				h++;
			}
			
			int count = ++dayscount;

			for (int i = 0; i <= 41; i++)
			{
				container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Text = { Text = $"{z}", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 30, Color = j != 0 ? config.GUI.ColorNumericNM : config.GUI.ColorNumericM }
                }, ".GUII" + (i + dayofweek));
				
				z++;
				if (z == count)
				{
					j++;
					z = 1;
				}
			}
			
			CuiHelper.AddUi(player, container);
		}
		
		#endregion
		
		#region Lang

        void InitializeLang()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["TITLE"] = "CALENDAR COOL SERVER | {0} - {1}",					
                ["CHATNP"] = "No permission!",					
			    ["January"] = "JANUARY",
			    ["February"] = "FEBRUARY",
			    ["March"] = "MARCH",
			    ["April"] = "APRIL",
			    ["May"] = "MAY",
			    ["June"] = "JUNE",
			    ["July"] = "JULY",
			    ["August"] = "AUGUST",
			    ["September"] = "SEPTEMBER",
			    ["October"] = "OCTOBER",
			    ["November"] = "NOVEMBER",
			    ["December"] = "DECEMBER",					
			    ["DAY1"] = "MONDAY",
			    ["DAY2"] = "TUESDAY",
			    ["DAY3"] = "WEDNESDAY",
			    ["DAY4"] = "THURSDAY",
			    ["DAY5"] = "FRIDAY",
			    ["DAY6"] = "SATURDAY",
			    ["DAY7"] = "SUNDAY",
                ["EVENT1"] = "EVENT 1",				
                ["EVENT2"] = "EVENT 2",				
                ["EVENT3"] = "EVENT 3",				
                ["EVENT4"] = "EVENT 4",				
                ["EVENT5"] = "EVENT 5",				
                ["EVENT6"] = "EVENT 6",				
                ["EVENT7"] = "EVENT 7",				
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["TITLE"] = "КАЛЕНДАРЬ КРУТОГО СЕРВЕРА | {0} - {1}",					
                ["CHATNP"] = "Недостаточно прав!",					
			    ["January"] = "ЯНВАРЬ",
			    ["February"] = "ФЕВРАЛЬ",
			    ["March"] = "МАРТ",
			    ["April"] = "АПРЕЛЬ",
			    ["May"] = "МАЙ",
			    ["June"] = "ИЮНЬ",
			    ["July"] = "ИЮЛЬ",
			    ["August"] = "АВГУСТ",
			    ["September"] = "СЕНТЯБРЬ",
			    ["October"] = "ОКТЯБРЬ",
			    ["November"] = "НОЯБРЬ",
			    ["December"] = "ДЕКАБРЬ",					
			    ["DAY1"] = "ПОНЕДЕЛЬНИК",
			    ["DAY2"] = "ВТОРНИК",
			    ["DAY3"] = "СРЕДА",
			    ["DAY4"] = "ЧЕТВЕРГ",
			    ["DAY5"] = "ПЯТНИЦА",
			    ["DAY6"] = "СУББОТА",
			    ["DAY7"] = "ВОСКРЕСЕНЬЕ",
                ["EVENT1"] = "СОБЫТИЕ 1",				
                ["EVENT2"] = "СОБЫТИЕ 2",				
                ["EVENT3"] = "СОБЫТИЕ 3",				
                ["EVENT4"] = "СОБЫТИЕ 4",				
                ["EVENT5"] = "СОБЫТИЕ 5",				
                ["EVENT6"] = "СОБЫТИЕ 6",				
                ["EVENT7"] = "СОБЫТИЕ 7"				
            }, this, "ru");            
			
			lang.RegisterMessages(new Dictionary<string, string>
            {
                ["TITLE"] = "SERVIDOR DE CALENDARIO COOL | {0} - {1}",					
                ["CHATNP"] = "¡No hay suficientes derechos!",					
			    ["January"] = "ENERO",
			    ["February"] = "FEBRERO",
			    ["March"] = "MARZO",
			    ["April"] = "ABRIL",
			    ["May"] = "MAYO",
			    ["June"] = "JUNIO",
			    ["July"] = "JULIO",
			    ["August"] = "AGOSTO",
			    ["September"] = "SEPTIMBRE",
			    ["October"] = "OCTUBRE",
			    ["November"] = "NOVIEMBRE",
			    ["December"] = "DECIEMBRE",					
			    ["DAY1"] = "LUNES",
			    ["DAY2"] = "MARTES",
			    ["DAY3"] = "MIERCOLES",
			    ["DAY4"] = "JUEVES",
			    ["DAY5"] = "VIERNES",
			    ["DAY6"] = "SABADO",
			    ["DAY7"] = "DOMINGO",
                ["EVENT1"] = "EVENTO 1",				
                ["EVENT2"] = "EVENTO 2",				
                ["EVENT3"] = "EVENTO 3",				
                ["EVENT4"] = "EVENTO 4",				
                ["EVENT5"] = "EVENTO 5",				
                ["EVENT6"] = "EVENTO 6",				
                ["EVENT7"] = "EVENTO 7",					
            }, this, "es-ES");
        }

        #endregion
	}
}

// --- End of file: XWipeCalendar.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BloodRust-fuuu/ImageLibrary.cs ---
// --- Original Local Path: BloodRust-fuuu/ImageLibrary.cs ---

//Reference: Facepunch.Sqlite
//Reference: UnityEngine.UnityWebRequestModule
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Steamworks;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Networking;

namespace Oxide.Plugins
{
    [Info("Image Library", "Absolut & K1lly0u", "3.0.0")]
    [Description("Plugin API for downloading and managing images")]
    class ImageLibrary : RustPlugin
    {
        #region Fields

        private ImageIdentifiers imageIdentifiers;
        private ImageURLs imageUrls;
        private SkinInformation skinInformation;
        private DynamicConfigFile identifiers;
        private DynamicConfigFile urls;
        private DynamicConfigFile skininfo;

        private static ImageLibrary il;
        private ImageAssets assets;

        private Queue<LoadOrder> loadOrders = new Queue<LoadOrder>();
        private bool orderPending;
        private bool isInitialized;

        private JsonSerializerSettings errorHandling = new JsonSerializerSettings { Error = (se, ev) => { ev.ErrorContext.Handled = true; } };

        private const string STEAM_API_URL = "https://api.steampowered.com/ISteamRemoteStorage/GetPublishedFileDetails/v1/";
        private const string STEAM_AVATAR_URL = "https://api.steampowered.com/ISteamUser/GetPlayerSummaries/v0002/?key={0}&steamids={1}";

        private string[] itemShortNames;

        #endregion Fields

        #region Oxide Hooks

        private void Loaded()
        {
            identifiers = Interface.Oxide.DataFileSystem.GetFile("ImageLibrary/image_data");
            urls = Interface.Oxide.DataFileSystem.GetFile("ImageLibrary/image_urls");
            skininfo = Interface.Oxide.DataFileSystem.GetFile("ImageLibrary/skin_data");

            il = this;
            LoadData();
        }

        private void OnServerInitialized()
        {
            itemShortNames = ItemManager.itemList.Select(x => x.shortname).ToArray();

            foreach (ItemDefinition item in ItemManager.itemList)
            {
                string workshopName = item.displayName.english.ToLower().Replace("skin", "").Replace(" ", "").Replace("-", "");
                if (!workshopNameToShortname.ContainsKey(workshopName))
                    workshopNameToShortname.Add(workshopName, item.shortname);
            }

            AddDefaultUrls();

            CheckForRefresh();

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);
        }

        private void OnPlayerConnected(BasePlayer player) => GetPlayerAvatar(player?.UserIDString);

        private void Unload()
        {
            SaveData();
            UnityEngine.Object.Destroy(assets);
            il = null;
        }

        #endregion Oxide Hooks

        #region Functions

        private IEnumerator ProcessLoadOrders()
        {
            yield return new WaitWhile(() => !isInitialized);

            if (loadOrders.Count > 0)
            {
                if (orderPending)
                    yield break;

                LoadOrder nextLoad = loadOrders.Dequeue();
                if (!nextLoad.loadSilent)
                    Puts("Starting order " + nextLoad.loadName);

                if (nextLoad.imageList != null && nextLoad.imageList.Count > 0)
                {
                    foreach (KeyValuePair<string, string> item in nextLoad.imageList)
                        assets.Add(item.Key, item.Value);
                }
                if (nextLoad.imageData != null && nextLoad.imageData.Count > 0)
                {
                    foreach (KeyValuePair<string, byte[]> item in nextLoad.imageData)
                        assets.Add(item.Key, null, item.Value);
                }

                orderPending = true;

                assets.RegisterCallback(nextLoad.callback);

                assets.BeginLoad(nextLoad.loadSilent ? string.Empty : nextLoad.loadName);
            }
        }

        private void GetPlayerAvatar(string userId)
        {
            if (!configData.StoreAvatars || string.IsNullOrEmpty(userId) || string.IsNullOrEmpty(configData.SteamAPIKey) || HasImage(userId, 0))
                return;

            webrequest.Enqueue(string.Format(STEAM_AVATAR_URL, configData.SteamAPIKey, userId), null, (code, response) =>
            {
                if (response != null && code == 200)
                {
                    try
                    {
                        AvatarRoot rootObject = JsonConvert.DeserializeObject<AvatarRoot>(response, errorHandling);
                        if (rootObject?.response?.players?.Length > 0)
                        {
                            string avatarUrl = rootObject.response.players[0].avatarmedium;
                            if (!string.IsNullOrEmpty(avatarUrl))                            
                                AddImage(avatarUrl, userId, 0);                               
                        }                        
                    }
                    catch { }
                }
            }, this);
        }

        private void RefreshImagery()
        {
            imageIdentifiers.imageIds.Clear();
            imageIdentifiers.lastCEID = CommunityEntity.ServerInstance.net.ID;

            AddImage("http://i.imgur.com/sZepiWv.png", "NONE", 0);
            AddImage("http://i.imgur.com/lydxb0u.png", "LOADING", 0);
            foreach (var image in configData.UserImages)
            {
                if (!string.IsNullOrEmpty(image.Value))
                    AddImage(image.Value, image.Key, 0);
            }

            if ((Steamworks.SteamInventory.Definitions?.Length ?? 0) == 0)
            {
                PrintWarning("Waiting for Steamworks to update item definitions....");
                Steamworks.SteamInventory.OnDefinitionsUpdated += GetItemSkins;
            }
            else GetItemSkins();
        }

        private void CheckForRefresh()
        {
            if (assets == null)
                assets = new GameObject("WebObject").AddComponent<ImageAssets>();

            isInitialized = true;

            if (imageIdentifiers.lastCEID != CommunityEntity.ServerInstance.net.ID)
            {
                if (imageIdentifiers.imageIds.Count < 2)
                {
                    RefreshImagery();
                }
                else
                {
                    PrintWarning("The CommunityEntity instance ID has changed! Due to the way CUI works in Rust all previously stored images must be removed and re-stored using the new ID as reference so clients can find the images. These images will be added to a new load order. Interupting this process will result in being required to re-download these images from the web");
                    RestoreLoadedImages();
                }
            }
        }

        private void RestoreLoadedImages()
        {
            orderPending = true;
            int failed = 0;

            Dictionary<string, byte[]> oldFiles = new Dictionary<string, byte[]>();

            for (int i = imageIdentifiers.imageIds.Count - 1; i >= 0; i--)
            {
                var image = imageIdentifiers.imageIds.ElementAt(i);

                uint imageId;
                if (!uint.TryParse(image.Value, out imageId))
                    continue;

                byte[] bytes = FileStorage.server.Get(imageId, FileStorage.Type.png, imageIdentifiers.lastCEID);
                if (bytes != null)
                    oldFiles.Add(image.Key, bytes);
                else
                {
                    failed++;
                    imageIdentifiers.imageIds.Remove(image.Key);
                }
            }

            Facepunch.Sqlite.Database db = new Facepunch.Sqlite.Database();
            try
            {
                db.Open($"{ConVar.Server.rootFolder}/sv.files.0.db");
                db.Execute("DELETE FROM data WHERE entid = ?", imageIdentifiers.lastCEID);
                db.Close();
            }
            catch { }

            loadOrders.Enqueue(new LoadOrder("Image restoration from previous database", oldFiles));
            PrintWarning($"{imageIdentifiers.imageIds.Count - failed} images queued for restoration, {failed} images failed");
            imageIdentifiers.lastCEID = CommunityEntity.ServerInstance.net.ID;
            SaveData();

            orderPending = false;
            ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
        }

        #endregion Functions

        #region Workshop Names and Image URLs

        private void AddDefaultUrls()
        {
            foreach (ItemDefinition itemDefinition in ItemManager.itemList)
            {
                string identifier = $"{itemDefinition.shortname}_0";
                if (!imageUrls.URLs.ContainsKey(identifier))
                    imageUrls.URLs.Add(identifier, $"https://www.rustedit.io/images/imagelibrary/{itemDefinition.shortname}.png");
            }
            SaveUrls();
        }

        private readonly Dictionary<string, string> workshopNameToShortname = new Dictionary<string, string>
        {
            {"longtshirt", "tshirt.long" },
            {"cap", "hat.cap" },
            {"beenie", "hat.beenie" },
            {"boonie", "hat.boonie" },
            {"balaclava", "mask.balaclava" },
            {"pipeshotgun", "shotgun.waterpipe" },
            {"woodstorage", "box.wooden" },
            {"ak47", "rifle.ak" },
            {"bearrug", "rug.bear" },
            {"boltrifle", "rifle.bolt" },
            {"bandana", "mask.bandana" },
            {"hideshirt", "attire.hide.vest" },
            {"snowjacket", "jacket.snow" },
            {"buckethat", "bucket.helmet" },
            {"semiautopistol", "pistol.semiauto" },
            {"burlapgloves", "burlap.gloves" },
            {"roadsignvest", "roadsign.jacket" },
            {"roadsignpants", "roadsign.kilt" },
            {"burlappants", "burlap.trousers" },
            {"collaredshirt", "shirt.collared" },
            {"mp5", "smg.mp5" },
            {"sword", "salvaged.sword" },
            {"workboots", "shoes.boots" },
            {"vagabondjacket", "jacket" },
            {"hideshoes", "attire.hide.boots" },
            {"deerskullmask", "deer.skull.mask" },
            {"minerhat", "hat.miner" },
            {"lr300", "rifle.lr300" },
            {"lr300.item", "rifle.lr300" },
            {"burlap.gloves", "burlap.gloves.new"},
            {"leather.gloves", "burlap.gloves"},
            {"python", "pistol.python" },
            {"m39", "rifle.m39"},
            {"woodendoubledoor", "door.double.hinged.wood"}
        };

        #endregion Workshop Names and Image URLs

        #region API

        [HookMethod("AddImage")]
        public bool AddImage(string url, string imageName, ulong imageId, Action callback = null)
        {
            loadOrders.Enqueue(new LoadOrder(imageName, new Dictionary<string, string> { { $"{imageName}_{imageId}", url } }, true, callback));
            if (!orderPending)
                ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
            return true;
        }

        [HookMethod("AddImageData")]
        public bool AddImageData(string imageName, byte[] array, ulong imageId, Action callback = null)
        {
            loadOrders.Enqueue(new LoadOrder(imageName, new Dictionary<string, byte[]> { { $"{imageName}_{imageId}", array } }, true, callback));
            if (!orderPending)
                ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
            return true;
        }

        [HookMethod("GetImageURL")]
        public string GetImageURL(string imageName, ulong imageId = 0)
        {
            string identifier = $"{imageName}_{imageId}";
            string value;
            if (imageUrls.URLs.TryGetValue(identifier, out value))
                return value;
            return string.Empty;
        }

        [HookMethod("GetImage")]
        public string GetImage(string imageName, ulong imageId = 0, bool returnUrl = false)
        {
            string identifier = $"{imageName}_{imageId}";
            string value;
            if (imageIdentifiers.imageIds.TryGetValue(identifier, out value))
                return value;
            else
            {                
                if (imageUrls.URLs.TryGetValue(identifier, out value))
                {
                    AddImage(value, imageName, imageId);
                    return imageIdentifiers.imageIds["LOADING_0"];
                }
            }

            if (returnUrl && !string.IsNullOrEmpty(value))
                return value;

            return imageIdentifiers.imageIds["NONE_0"];
        }

        [HookMethod("GetImageList")]
        public List<ulong> GetImageList(string name)
        {
            List<ulong> skinIds = new List<ulong>();
            var matches = imageUrls.URLs.Keys.Where(x => x.StartsWith(name)).ToArray();
            for (int i = 0; i < matches.Length; i++)
            {
                var index = matches[i].IndexOf("_");
                if (matches[i].Substring(0, index) == name)
                {
                    ulong skinID;
                    if (ulong.TryParse(matches[i].Substring(index + 1), out skinID))
                        skinIds.Add(ulong.Parse(matches[i].Substring(index + 1)));
                }
            }
            return skinIds;
        }

        [HookMethod("GetSkinInfo")]
        public Dictionary<string, object> GetSkinInfo(string name, ulong id)
        {
            Dictionary<string, object> skinInfo;
            if (skinInformation.skinData.TryGetValue($"{name}_{id}", out skinInfo))
                return skinInfo;
            return null;
        }

        [HookMethod("HasImage")]
        public bool HasImage(string imageName, ulong imageId)
        {
            if (imageIdentifiers.imageIds.ContainsKey($"{imageName}_{imageId}") && IsInStorage(uint.Parse(imageIdentifiers.imageIds[$"{imageName}_{imageId}"])))
                return true;

            return false;
        }

        public bool IsInStorage(uint crc) => FileStorage.server.Get(crc, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID) != null;

        [HookMethod("IsReady")]
        public bool IsReady() => loadOrders.Count == 0 && !orderPending;

        [HookMethod("ImportImageList")]
        public void ImportImageList(string title, Dictionary<string, string> imageList, ulong imageId = 0, bool replace = false, Action callback = null)
        {
            Dictionary<string, string> newLoadOrder = new Dictionary<string, string>();
            foreach (var image in imageList)
            {
                if (!replace && HasImage(image.Key, imageId))
                    continue;
                newLoadOrder[$"{image.Key}_{imageId}"] = image.Value;
            }
            if (newLoadOrder.Count > 0)
            {
                loadOrders.Enqueue(new LoadOrder(title, newLoadOrder, false, callback));
                if (!orderPending)
                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
            }
            else
            {
                if (callback != null)
                    callback.Invoke();
            }
        }

        [HookMethod("ImportItemList")]
        public void ImportItemList(string title, Dictionary<string, Dictionary<ulong, string>> itemList, bool replace = false, Action callback = null)
        {
            Dictionary<string, string> newLoadOrder = new Dictionary<string, string>();
            foreach (var image in itemList)
            {
                foreach (var skin in image.Value)
                {
                    if (!replace && HasImage(image.Key, skin.Key))
                        continue;
                    newLoadOrder[$"{image.Key}_{skin.Key}"] = skin.Value;
                }
            }
            if (newLoadOrder.Count > 0)
            {
                loadOrders.Enqueue(new LoadOrder(title, newLoadOrder, false, callback));
                if (!orderPending)
                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
            }
            else
            {
                if (callback != null)
                    callback.Invoke();
            }
        }

        [HookMethod("ImportImageData")]
        public void ImportImageData(string title, Dictionary<string, byte[]> imageList, ulong imageId = 0, bool replace = false, Action callback = null)
        {
            Dictionary<string, byte[]> newLoadOrder = new Dictionary<string, byte[]>();
            foreach (var image in imageList)
            {
                if (!replace && HasImage(image.Key, imageId))
                    continue;
                newLoadOrder[$"{image.Key}_{imageId}"] = image.Value;
            }
            if (newLoadOrder.Count > 0)
            {
                loadOrders.Enqueue(new LoadOrder(title, newLoadOrder, false, callback));
                if (!orderPending)
                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
            }
            else
            {
                if (callback != null)
                    callback.Invoke();
            }
        }

        [HookMethod("LoadImageList")]
        public void LoadImageList(string title, List<KeyValuePair<string, ulong>> imageList, Action callback = null)
        {
            Dictionary<string, string> newLoadOrderURL = new Dictionary<string, string>();
            List<KeyValuePair<string, ulong>> workshopDownloads = new List<KeyValuePair<string, ulong>>();

            foreach (KeyValuePair<string, ulong> image in imageList)
            {
                if (HasImage(image.Key, image.Value))
                    continue;

                string identifier = $"{image.Key}_{image.Value}";

                if (imageUrls.URLs.ContainsKey(identifier) && !newLoadOrderURL.ContainsKey(identifier))
                {
                    newLoadOrderURL.Add(identifier, imageUrls.URLs[identifier]);
                }
                else
                {
                    workshopDownloads.Add(new KeyValuePair<string, ulong>(image.Key, image.Value));
                }
            }

            if (workshopDownloads.Count > 0)
            {
                QueueWorkshopDownload(title, newLoadOrderURL, workshopDownloads, 0, callback);
                return;
            }

            if (newLoadOrderURL.Count > 0)
            {
                loadOrders.Enqueue(new LoadOrder(title, newLoadOrderURL, null, false, callback));
                if (!orderPending)
                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
            }
            else
            {
                if (callback != null)
                    callback.Invoke();
            }
        }

        [HookMethod("RemoveImage")]
        public void RemoveImage(string imageName, ulong imageId)
        {
            if (!HasImage(imageName, imageId))
                return;

            uint crc = uint.Parse(GetImage(imageName, imageId));
            FileStorage.server.Remove(crc, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID);
        }

        [HookMethod("SendImage")]
        public void SendImage(BasePlayer player, string imageName, ulong imageId = 0)
        {
            if (!HasImage(imageName, imageId) || player?.net?.connection == null)
                return;

            uint crc = uint.Parse(GetImage(imageName, imageId));
            byte[] array = FileStorage.server.Get(crc, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID);

            if (array == null)
                return;

            CommunityEntity.ServerInstance.ClientRPCEx<uint, uint, byte[]>(new Network.SendInfo(player.net.connection)
            {
                channel = 2,
                method = Network.SendMethod.Reliable
            }, null, "CL_ReceiveFilePng", crc, (uint)array.Length, array);
        }
        #endregion API

        #region Steam API
        private List<ulong> BuildApprovedItemList()
        {
            List<ulong> list = new List<ulong>();

            foreach (InventoryDef item in Steamworks.SteamInventory.Definitions)
            {
                string shortname = item.GetProperty("itemshortname");
                ulong workshopid;

                if (item == null || string.IsNullOrEmpty(shortname))
                    continue;

                if (workshopNameToShortname.ContainsKey(shortname))
                    shortname = workshopNameToShortname[shortname];

                if (item.Id < 100)
                    continue;

                if (!ulong.TryParse(item.GetProperty("workshopid"), out workshopid))
                    continue;

                if (HasImage(shortname, workshopid))
                    continue;

                list.Add(workshopid);
            }

            return list;
        }

        private string BuildDetailsString(List<ulong> list, int page)
        {
            int start = page * 100;
            int end = start + 100 > list.Count ? list.Count : start + 100;

            string details = string.Format("?key={0}&itemcount={1}", configData.SteamAPIKey, end - start);

            for (int i = start; i < end; i++)
                details += string.Format("&publishedfileids[{0}]={1}", i - start, list[i]);

            return details;
        }

        private string BuildDetailsString(List<ulong> list)
        {
            string details = string.Format("?key={0}&itemcount={1}", configData.SteamAPIKey, list.Count);

            for (int i = 0; i < list.Count; i++)
                details += string.Format("&publishedfileids[{0}]={1}", i, list[i]);

            return details;
        }

        private bool IsValid(PublishedFileQueryDetail item)
        {
            if (string.IsNullOrEmpty(item.preview_url))
                return false;

            if (item.tags == null)
                return false;

            return true;
        }

        private void GetItemSkins()
        {
            Steamworks.SteamInventory.OnDefinitionsUpdated -= GetItemSkins;

            PrintWarning("Retrieving item skin lists...");

            GetApprovedItemSkins(BuildApprovedItemList(), 0);
        }

        private void QueueFileQueryRequest(string details, Action<PublishedFileQueryDetail[]> callback)
        {
            webrequest.Enqueue(STEAM_API_URL, details, (code, response) =>
            {
                try
                {
                    PublishedFileQueryResponse query = JsonConvert.DeserializeObject<PublishedFileQueryResponse>(response, errorHandling);
                    if (query == null || query.response == null || query.response.publishedfiledetails.Length == 0)
                    {
                        if (code != 200)
                            PrintError($"There was a error querying Steam for workshop item data : Code ({code})");
                        return;
                    }
                    else
                    {
                        if (query?.response?.publishedfiledetails?.Length > 0)
                            callback.Invoke(query.response.publishedfiledetails);
                    }
                }
                catch { }
            }, this, Core.Libraries.RequestMethod.POST);
        }

        private void GetApprovedItemSkins(List<ulong> itemsToDownload, int page)
        {
            if (itemsToDownload.Count < 1)
            {
                Puts("Approved skins loaded");

                SaveUrls();
                SaveSkinInfo();

                if (!orderPending)
                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
                return;
            }

            int totalPages = Mathf.CeilToInt((float)itemsToDownload.Count / 100f) - 1;

            string details = BuildDetailsString(itemsToDownload, page);

            QueueFileQueryRequest(details, (PublishedFileQueryDetail[] items) =>
            {
                ServerMgr.Instance.StartCoroutine(ProcessApprovedBlock(itemsToDownload, items, page, totalPages));
            });
        }

        private IEnumerator ProcessApprovedBlock(List<ulong> itemsToDownload, PublishedFileQueryDetail[] items, int page, int totalPages)
        {
            PrintWarning($"Processing approved skins; Page {page + 1}/{totalPages + 1}");

            Dictionary<string, Dictionary<ulong, string>> loadOrder = new Dictionary<string, Dictionary<ulong, string>>();

            foreach (PublishedFileQueryDetail item in items)
            {
                if (!IsValid(item))
                    continue;

                foreach (PublishedFileQueryDetail.Tag tag in item.tags)
                {
                    if (string.IsNullOrEmpty(tag.tag))
                        continue;

                    ulong workshopid = Convert.ToUInt64(item.publishedfileid);

                    string adjTag = tag.tag.ToLower().Replace("skin", "").Replace(" ", "").Replace("-", "").Replace(".item", "");
                    if (workshopNameToShortname.ContainsKey(adjTag))
                    {
                        string shortname = workshopNameToShortname[adjTag];

                        string identifier = $"{shortname}_{workshopid}";

                        if (!imageUrls.URLs.ContainsKey(identifier))
                            imageUrls.URLs.Add(identifier, item.preview_url.Replace("https", "http"));

                        skinInformation.skinData[identifier] = new Dictionary<string, object>
                                {
                                    {"title", item.title },
                                    {"votesup", 0 },
                                    {"votesdown", 0 },
                                    {"description", item.description },
                                    {"score", 0 },
                                    {"views", 0 },
                                    {"created", new DateTime() },
                                };
                    }
                }
            }

            yield return CoroutineEx.waitForEndOfFrame;
            yield return CoroutineEx.waitForEndOfFrame;

            if (page < totalPages)
                GetApprovedItemSkins(itemsToDownload, page + 1);
            else
            {
                itemsToDownload.Clear();

                Puts("Approved skins loaded");

                SaveUrls();
                SaveSkinInfo();

                if (!orderPending)
                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
            }
        }

        private void QueueWorkshopDownload(string title, Dictionary<string, string> newLoadOrderURL, List<KeyValuePair<string, ulong>> workshopDownloads, int page = 0, Action callback = null)
        {
            int rangeMin = page * 100;
            int rangeMax = (page + 1) * 100;

            if (rangeMax > workshopDownloads.Count)
                rangeMax = workshopDownloads.Count;

            List<ulong> requestedSkins = workshopDownloads.GetRange(rangeMin, rangeMax - rangeMin).Select(x => x.Value).ToList();

            int totalPages = Mathf.CeilToInt((float)workshopDownloads.Count / 100f) - 1;

            string details = BuildDetailsString(requestedSkins);

            try
            {
                webrequest.Enqueue(STEAM_API_URL, details, (code, response) =>
                {
                    PublishedFileQueryResponse query = JsonConvert.DeserializeObject<PublishedFileQueryResponse>(response, errorHandling);
                    if (query == null || query.response == null || query.response.publishedfiledetails.Length == 0)
                    {
                        if (code != 200)
                            PrintError($"There was a error querying Steam for workshop item data : Code ({code})");

                        if (page < totalPages)
                            QueueWorkshopDownload(title, newLoadOrderURL, workshopDownloads, page + 1, callback);
                        else
                        {
                            if (newLoadOrderURL.Count > 0)
                            {
                                loadOrders.Enqueue(new LoadOrder(title, newLoadOrderURL, null, false, page < totalPages ? null : callback));
                                if (!orderPending)
                                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
                            }
                            else
                            {
                                if (callback != null)
                                    callback.Invoke();
                            }
                        }
                        return;
                    }
                    else
                    {
                        if (query.response.publishedfiledetails.Length > 0)
                        {
                            Dictionary<string, Dictionary<ulong, string>> loadOrder = new Dictionary<string, Dictionary<ulong, string>>();

                            foreach (PublishedFileQueryDetail item in query.response.publishedfiledetails)
                            {
                                if (!string.IsNullOrEmpty(item.preview_url))
                                {
                                    ulong skinId = Convert.ToUInt64(item.publishedfileid);

                                    KeyValuePair<string, ulong>? kvp = workshopDownloads.Find(x => x.Value == skinId);

                                    if (kvp.HasValue)
                                    {
                                        string identifier = $"{kvp.Value.Key}_{kvp.Value.Value}";

                                        if (!newLoadOrderURL.ContainsKey(identifier))
                                            newLoadOrderURL.Add(identifier, item.preview_url);

                                        if (!imageUrls.URLs.ContainsKey(identifier))
                                            imageUrls.URLs.Add(identifier, item.preview_url);

                                        skinInformation.skinData[identifier] = new Dictionary<string, object>
                                        {
                                            {"title", item.title },
                                            {"votesup",  0 },
                                            {"votesdown", 0 },
                                            {"description", item.description },
                                            {"score", 0 },
                                            {"views", item.views },
                                            {"created", new DateTime(item.time_created) },
                                        };

                                        requestedSkins.Remove(skinId);
                                    }
                                }
                            }

                            SaveUrls();
                            SaveSkinInfo();

                            if (requestedSkins.Count != 0)
                            {
                                Puts($"{requestedSkins.Count} workshop skin ID's for image batch ({title}) are invalid! They may have been removed from the workshop\nIDs: {requestedSkins.ToSentence()}");
                            }
                        }

                        if (page < totalPages)
                            QueueWorkshopDownload(title, newLoadOrderURL, workshopDownloads, page + 1, callback);
                        else
                        {
                            if (newLoadOrderURL.Count > 0)
                            {
                                loadOrders.Enqueue(new LoadOrder(title, newLoadOrderURL, null, false, page < totalPages ? null : callback));
                                if (!orderPending)
                                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
                            }
                            else
                            {
                                if (callback != null)
                                    callback.Invoke();
                            }
                        }
                    }
                },
                this,
                Core.Libraries.RequestMethod.POST);
            }
            catch { }
        }

        #region JSON Response Classes
        public class PublishedFileQueryResponse
        {
            public FileResponse response { get; set; }
        }

        public class FileResponse
        {
            public int result { get; set; }
            public int resultcount { get; set; }
            public PublishedFileQueryDetail[] publishedfiledetails { get; set; }
        }

        public class PublishedFileQueryDetail
        {
            public string publishedfileid { get; set; }
            public int result { get; set; }
            public string creator { get; set; }
            public int creator_app_id { get; set; }
            public int consumer_app_id { get; set; }
            public string filename { get; set; }
            public int file_size { get; set; }
            public string preview_url { get; set; }
            public string hcontent_preview { get; set; }
            public string title { get; set; }
            public string description { get; set; }
            public int time_created { get; set; }
            public int time_updated { get; set; }
            public int visibility { get; set; }
            public int banned { get; set; }
            public string ban_reason { get; set; }
            public int subscriptions { get; set; }
            public int favorited { get; set; }
            public int lifetime_subscriptions { get; set; }
            public int lifetime_favorited { get; set; }
            public int views { get; set; }
            public Tag[] tags { get; set; }

            public class Tag
            {
                public string tag { get; set; }
            }
        }
        #endregion
        #endregion

        #region Commands

        [ConsoleCommand("cancelstorage")]
        private void cmdCancelStorage(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null || arg.Connection.authLevel > 0)
            {
                if (!orderPending)
                    PrintWarning("No images are currently being downloaded");
                else
                {
                    assets.ClearList();
                    loadOrders.Clear();
                    PrintWarning("Pending image downloads have been cancelled!");
                }
            }
        }

        private List<ulong> pendingAnswers = new List<ulong>();

        [ConsoleCommand("refreshallimages")]
        private void cmdRefreshAllImages(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null || arg.Connection.authLevel > 0)
            {
                SendReply(arg, "Running this command will wipe all of your ImageLibrary data, meaning every registered image will need to be re-downloaded. Are you sure you wish to continue? (type yes or no)");

                ulong userId = arg.Connection == null || arg.IsRcon ? 0U : arg.Connection.userid;
                if (!pendingAnswers.Contains(userId))
                {
                    pendingAnswers.Add(userId);
                    timer.In(5, () =>
                    {
                        if (pendingAnswers.Contains(userId))
                            pendingAnswers.Remove(userId);
                    });
                }
            }
        }

        [ConsoleCommand("yes")]
        private void cmdRefreshAllImagesYes(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null || arg.Connection.authLevel > 0)
            {
                ulong userId = arg.Connection == null || arg.IsRcon ? 0U : arg.Connection.userid;
                if (pendingAnswers.Contains(userId))
                {
                    PrintWarning("Wiping ImageLibrary data and redownloading ImageLibrary specific images. All plugins that have registered images via ImageLibrary will need to be re-loaded!");
                    RefreshImagery();

                    pendingAnswers.Remove(userId);
                }
            }
        }

        [ConsoleCommand("no")]
        private void cmdRefreshAllImagesNo(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null || arg.Connection.authLevel > 0)
            {
                ulong userId = arg.Connection == null || arg.IsRcon ? 0U : arg.Connection.userid;

                if (pendingAnswers.Contains(userId))
                {
                    SendReply(arg, "ImageLibrary data wipe aborted!");
                    pendingAnswers.Remove(userId);
                }
            }
        }

        #endregion Commands

        #region Image Storage

        private struct LoadOrder
        {
            public string loadName;
            public bool loadSilent;

            public Dictionary<string, string> imageList;
            public Dictionary<string, byte[]> imageData;

            public Action callback;

            public LoadOrder(string loadName, Dictionary<string, string> imageList, bool loadSilent = false, Action callback = null)
            {
                this.loadName = loadName;
                this.imageList = imageList;
                this.imageData = null;
                this.loadSilent = loadSilent;
                this.callback = callback;
            }
            public LoadOrder(string loadName, Dictionary<string, byte[]> imageData, bool loadSilent = false, Action callback = null)
            {
                this.loadName = loadName;
                this.imageList = null;
                this.imageData = imageData;
                this.loadSilent = loadSilent;
                this.callback = callback;
            }
            public LoadOrder(string loadName, Dictionary<string, string> imageList, Dictionary<string, byte[]> imageData, bool loadSilent = false, Action callback = null)
            {
                this.loadName = loadName;
                this.imageList = imageList;
                this.imageData = imageData;
                this.loadSilent = loadSilent;
                this.callback = callback;
            }
        }

        private class ImageAssets : MonoBehaviour
        {
            private Queue<QueueItem> queueList = new Queue<QueueItem>();
            private bool isLoading;
            private double nextUpdate;
            private int listCount;
            private string request;

            private Action callback;

            private void OnDestroy()
            {
                queueList.Clear();
            }

            public void Add(string name, string url = null, byte[] bytes = null)
            {
                queueList.Enqueue(new QueueItem(name, url, bytes));
            }

            public void RegisterCallback(Action callback) => this.callback = callback;

            public void BeginLoad(string request)
            {
                this.request = request;
                nextUpdate = UnityEngine.Time.time + il.configData.UpdateInterval;
                listCount = queueList.Count;
                Next();
            }

            public void ClearList()
            {
                queueList.Clear();
                il.orderPending = false;
            }

            private void Next()
            {
                if (queueList.Count == 0)
                {
                    il.orderPending = false;
                    il.SaveData();
                    if (!string.IsNullOrEmpty(request))
                        print($"Image batch ({request}) has been stored successfully");

                    request = string.Empty;
                    listCount = 0;

                    if (callback != null)
                        callback.Invoke();

                    StartCoroutine(il.ProcessLoadOrders());
                    return;
                }
                if (il.configData.ShowProgress && listCount > 1)
                {
                    var time = UnityEngine.Time.time;
                    if (time > nextUpdate)
                    {
                        var amountDone = listCount - queueList.Count;
                        print($"{request} storage process at {Math.Round((amountDone / (float)listCount) * 100, 0)}% ({amountDone}/{listCount})");
                        nextUpdate = time + il.configData.UpdateInterval;
                    }
                }
                isLoading = true;

                QueueItem queueItem = queueList.Dequeue();
                if (!string.IsNullOrEmpty(queueItem.url))
                    StartCoroutine(DownloadImage(queueItem));
                else StoreByteArray(queueItem.bytes, queueItem.name);
            }

            private IEnumerator DownloadImage(QueueItem info)
            {
                UnityWebRequest www = UnityWebRequest.Get(info.url);

                yield return www.SendWebRequest();
                if (il == null) yield break;
                if (www.isNetworkError || www.isHttpError)
                {
                    print(string.Format("Image failed to download! Error: {0} - Image Name: {1} - Image URL: {2}", www.error, info.name, info.url));
                    www.Dispose();
                    isLoading = false;
                    Next();
                    yield break;
                }

                Texture2D texture = new Texture2D(2, 2);
                texture.LoadImage(www.downloadHandler.data);
                if (texture != null)
                {
                    byte[] bytes = texture.EncodeToPNG();
                    DestroyImmediate(texture);
                    StoreByteArray(bytes, info.name);
                }
                www.Dispose();
            }

            private void StoreByteArray(byte[] bytes, string name)
            {
                if (bytes != null)
                    il.imageIdentifiers.imageIds[name] = FileStorage.server.Store(bytes, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID).ToString();
                isLoading = false;
                Next();
            }

            private class QueueItem
            {
                public byte[] bytes;
                public string url;
                public string name;
                public QueueItem(string name, string url = null, byte[] bytes = null)
                {
                    this.bytes = bytes;
                    this.url = url;
                    this.name = name;
                }
            }
        }

        #endregion Image Storage

        #region Config

        private ConfigData configData;

        class ConfigData
        {
            [JsonProperty(PropertyName = "Avatars - Store player avatars")]
            public bool StoreAvatars { get; set; }

            [JsonProperty(PropertyName = "Steam API key (get one here https://steamcommunity.com/dev/apikey)")]
            public string SteamAPIKey { get; set; }

            //[JsonProperty(PropertyName = "Workshop - Download workshop image information")]
            //public bool WorkshopImages { get; set; }

            [JsonProperty(PropertyName = "Progress - Show download progress in console")]
            public bool ShowProgress { get; set; }

            [JsonProperty(PropertyName = "Progress - Time between update notifications")]
            public int UpdateInterval { get; set; }

            [JsonProperty(PropertyName = "User Images - Manually define images to be loaded")]
            public Dictionary<string, string> UserImages { get; set; }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                ShowProgress = true,
                SteamAPIKey = string.Empty,
                StoreAvatars = false,
                UpdateInterval = 20,
                UserImages = new Dictionary<string, string>(),
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (configData.Version < new VersionNumber(2, 0, 47))
                configData = baseConfig;

            if (configData.Version < new VersionNumber(2, 0, 53))
                configData.StoreAvatars = false;

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion Config

        #region Data Management

        private void SaveData() => identifiers.WriteObject(imageIdentifiers);
        private void SaveSkinInfo() => skininfo.WriteObject(skinInformation);
        private void SaveUrls() => urls.WriteObject(imageUrls);

        private void LoadData()
        {
            try
            {
                imageIdentifiers = identifiers.ReadObject<ImageIdentifiers>();
            }
            catch
            {
                imageIdentifiers = new ImageIdentifiers();
            }
            try
            {
                skinInformation = skininfo.ReadObject<SkinInformation>();
            }
            catch
            {
                skinInformation = new SkinInformation();
            }
            try
            {
                imageUrls = urls.ReadObject<ImageURLs>();
            }
            catch
            {
                imageUrls = new ImageURLs();
            }
            if (skinInformation == null)
                skinInformation = new SkinInformation();
            if (imageIdentifiers == null)
                imageIdentifiers = new ImageIdentifiers();
            if (imageUrls == null)
                imageUrls = new ImageURLs();
        }

        private class ImageIdentifiers
        {
            public uint lastCEID;
            public Hash<string, string> imageIds = new Hash<string, string>();
        }

        private class SkinInformation
        {
            public Hash<string, Dictionary<string, object>> skinData = new Hash<string, Dictionary<string, object>>();
        }

        private class ImageURLs
        {
            public Hash<string, string> URLs = new Hash<string, string>();
        }


        public class AvatarRoot
        {
            public Response response { get; set; }

            public class Response
            {
                public Player[] players { get; set; }

                public class Player
                {
                    public string steamid { get; set; }
                    public int communityvisibilitystate { get; set; }
                    public int profilestate { get; set; }
                    public string personaname { get; set; }
                    public int lastlogoff { get; set; }
                    public string profileurl { get; set; }
                    public string avatar { get; set; }
                    public string avatarmedium { get; set; }
                    public string avatarfull { get; set; }
                    public int personastate { get; set; }
                    public string realname { get; set; }
                    public string primaryclanid { get; set; }
                    public int timecreated { get; set; }
                    public int personastateflags { get; set; }
                }
            }
        }
        #endregion Data Management
    }
}


// --- End of file: ImageLibrary.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BloodRust-fuuu/TopChat.cs ---
// --- Original Local Path: BloodRust-fuuu/TopChat.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Game.Rust.Cui;
using UnityEngine; 

namespace Oxide.Plugins
{
    [Info("TopChat", "TopPlugin.ru", "3.0.0")]
    public class TopChat : RustPlugin
    {
        #region Classes

        private class Prefix
        {
            [JsonProperty("Наименование префикса")]
            public string Name;
            [JsonProperty("Цвет префикса")]
            public string Color;
            [JsonProperty("Размер префикса")]
            public string Size;

            [JsonProperty("Скобки префикса")]
            public string Hooks;
        }

        private class Chatter
        {
            [JsonProperty("Подсказки")]
            public bool Tips;
            [JsonProperty("Звуки личных сообщений")]
            public bool Sound;
            [JsonProperty("Звук сообщений в чате")]
            public bool Censor;
            [JsonProperty("Сообщения в чат")] 
            public bool Chat = true;
            [JsonProperty("Сообщения в ПМ")] 
            public bool PM = true;
        }

        private class Name
        {
            public string Color;
        }
        
        private class Settings
        {
            [JsonProperty("Настройки текущего префикса")]
            public Prefix Prefixes;
            [JsonProperty("Настройки чата")]
            public Chatter Chatters;
            [JsonProperty("Настройки имени")]
            public Name Names;

            [JsonProperty("Список игнорируемых игроков")] 
            public Dictionary<ulong, string> IgnoreList = new Dictionary<ulong, string>();
            [JsonProperty("Последнее личное сообщение для"), JsonIgnore] 
            public BasePlayer ReplyTarget = null;

            public double UMT; 
            
            public Settings() {}
            public static Settings Generate()
            {
                return new Settings
                {
                    Prefixes = new Prefix
                    {
                        Name = "-",
                        Hooks = "-", 
                        Size = "<size=14>",
                        Color = "<color=#eb7d6a>"
                    },
                    Chatters = new Chatter
                    {
                        Censor = false,
                        Sound = true, 
                        Tips = true
                    },
                    Names = new Name
                    {
                        Color = "<color=#eb7d6a>"
                    }
                }; 
            } 
        }

        private class DataBase
        {
            public Dictionary<ulong, Settings> Settingses = new Dictionary<ulong, Settings>();

            public static DataBase LoadData() => Interface.Oxide.DataFileSystem.ExistsDatafile("TopChat") ? Interface.Oxide.DataFileSystem.ReadObject<DataBase>("TopChat") : new DataBase();

            public void SaveData()
            {
                Interface.Oxide.DataFileSystem.WriteObject("TopChat", this);
                Interface.Oxide.DataFileSystem.WriteObject($"Logs", MessagesLogs);
            } 
        }

        private class Configuration
        {
            [JsonProperty("Список доступных префиксов")]
            public Dictionary<string, string> Prefixes = new Dictionary<string, string>();
            [JsonProperty("Список доступных цветов")]
            public Dictionary<string, string> Colors = new Dictionary<string, string>();
            [JsonProperty("Список доступных размеров")]
            public Dictionary<string, string> Sizes = new Dictionary<string, string>();
            [JsonProperty("Список доступных типов префикса")]
            public Dictionary<string, string> Types = new Dictionary<string, string>();
            [JsonProperty("Список цензуры и исключений")]
            public Dictionary<string, List<string>> Censures = new Dictionary<string, List<string>>(); 
            [JsonProperty("Список доступных сообщений")]
            public List<string> Broadcaster = new List<string>();
            [JsonProperty("Интервал отправки сообщений")]
            public int BroadcastInterval = 300;
            [JsonProperty("Оповещать о подключении с префиксом")]
            public bool WelcomePrefix = true;

            [JsonProperty("SteamID отправителя в чат")] 
            public ulong ImageID = 76561199039326412;
            
            public static Configuration LoadDefaultConfiguration()
            {
                return new Configuration
                {
                    WelcomePrefix = true,
                    BroadcastInterval = 600,
                    Broadcaster = new List<string>
                    {
      "Заметили нечестного игрока? \nОтправьте репорт <color=#fff27a>/report</color>",
      "Воспользуйтесь уникальным меню крафта <color=#fff27a>/craft</color>",
      "Классовая система прокачки <color=#fff27a>/xp</color>\nСпособности <color=#fff27a>/perk</color>\nНавыки <color=#fff27a>/skill</color>",
      "Меню транспортной системы <color=#fff27a>/vm</color>",
      "Чтобы создать улучшенную аптечку, перенесите пакетик с кровью на обычную аптечку.",
      "Вы можете чинить предметы изолентой. Просто перенесите изоленту на поломанный предмет.",
      "Защитите свой дом, усилив его ударив киянокй по шкафу или введите команду <color=#fff27a>/bp</color> у шкафа",
      "Приглашайте друзей на сервер и получите награду! Подробнее <color=#fff27a>/ref</color>!",
      "Проверяйте актуальные товары на базаре <color=#fff27a>/bazar</color>",
      "Настройте свой никнейм, префикс командой <color=#fff27a>/chat</color>",
      "Наш премиум рынок: <color=#fff27a>mythrust.ru</color>",
      "Испытайте удачу в капсулах! \nТак же попробуйте уникальную лоттерею!",
      "Настройте свой хитмаркер с помощью команды <color=#fff27a>/hit</color>",
      "Команды для удаления простроек <color=#fff27a>/remove</color>\nАпгрейду построек /up</color>\nПолному апгрейду здания <color=#fff27a>/gr</color>",
      "В городе, у главных ворот есть торговец Сидорович, который имеет целый ряд задач, за выполнение которых готов не плохо заплатить!",
      "Наша группа ВКонтакте: <color=#fff27a>vk.com/mythrust</color>",
      "Хотите улучшить свой аккаунт? Приобретите альфа или омега статус! Подробнее: <color=#fff27a>mythrust.ru</color>"
                    },
                    Prefixes = new Dictionary<string, string>
                    {
						["Chat.Default"] = "НЕТ:-",
						["kits.secret2"] = "o:o",
						["Chat.Kaban1"] = "シ:シ",
						["Chat.Kaban2"] = "₪:₪",
						["Chat.Kaban4"] = "ВЕПРЬ:ВЕПРЬ",
						["Chat.Joker1"] = "¥:¥",
						["Chat.Joker2"] = "®:®",
						["Chat.Joker3"] = "〄:〄",
						["Chat.Joker4"] = "JOKER:JOKER",
						["Chat.Masnik1"] = "ס:ס",
						["Chat.Masnik2"] = "√:√",
						["Chat.Masnik3"] = "〤:〤",
						["Chat.Masnik4"] = "マ:マ",
						["Chat.admin"] = "Администратор:Администратор",						
						["Chat.Smert1"] = "ה:ה",
						["Chat.Smert2"] = "©:©",
						["Chat.Smert3"] = "〰:〰",
						["Chat.Smert4"] = "†:†",
						["Chat.Smert5"] = "€:€",
						["Chat.Smert6"] = "DEATH:DEATH",
						["Chat.Store1"] = "ש:ש",
						["Chat.Store2"] = "‡:‡",
						["Chat.Store3"] = "◊:◊",
						["Chat.Store4"] = "Ѫ:Ѫ",
						["Chat.Store5"] = "〶:〶"
                    },
                    Colors = new Dictionary<string, string>
                    {
						["Chat.Default"]= "СТАНДАРТНЫЙ:<color=#eb7d6a>",
						["Chat.Default"]= "СТАНДАРТНЫЙ:<color=#c692de>",
						["Chat.White"]= "БЕЛЫЙ:<color=#d4d8de>",
						["Chat.Korange"]= "ОРАНЖЕВЕНЬКИЙ:<color=#ec9a49>",
						["Chat.Kcal"]= "КОРИЧНЕВЫЙ:<color=#b18755>",
						["Chat.Jgreen"]= "ЗЕЛЁНЫЙ:<color=#ADFF2F>",
						["Chat.Jpink"]= "СВ.РОЗОВЫЙ:<color=#e999c4>",
						["Chat.Jpaleturquoise"]= "БИРЮЗОВЫЙ:<color=#52d398>",
						["Chat.Mred"]= "КРАСНЫЙ:<color=#e25252>",
						["Chat.Mrosybrowm"]= "SALMON:<color=#FA8072>",
						["Chat.Mmistyrose"]= "KHAKI:<color=#f0e68c>",
						["Chat.Mdarkred"]= "ТЁМНО-КРАСНЫЙ:<color=#a86464>",
						["Chat.Sgray"]= "СЕРЫЙ:<color=#696969>",
						["Chat.Sskyblue"]= "НЕБЕСН.СИНИЙ:<color=#B1D6F1>",
						["Chat.Sdarkslategrey"]= "ТЁМНО-СЕР.ШИФЕР:<color=#FDD9B5>",
						["Chat.Sasdsd"]= "РОЗОВО-КОРИЧ.:<color=#bc8f8f>",
						["Chat.Sdarkgreen"]= "ТЁМНО-ЗЕЛЁНЫЙ:<color=#57a078>",
						["Chat.StoreColor1"]= "ЛИЛОВЫЙ:<color=#DB7093>",
						["Chat.StoreColor2"]= "СВЕТЛО-ГОЛУБОЙ:<color=#E0FFFF>",
						["Chat.StoreColor3"]= "ТЁМНО-ОЛИВКОВЫЙ:<color=#6B8E23>",
						["Chat.StoreColor4"]= "ЗОЛОТОЙ:<color=#FFD700>",
						["Chat.StoreColor5"]= "ТЁМНАЯ-ОРХИДЕЯ:<color=#9932CC>"
                    },
                    Sizes = new Dictionary<string, string>
                    {
                        ["Chat.Default"] = "СТАНДАРТНЫЙ:<size=14>",
                        ["Chat.Big"] = "БОЛЬШОЙ:<size=16>"
                    },
                    Types = new Dictionary<string, string>
                    {
                        ["Chat.Default"] = "НЕТ:-",
                        ["Chat.Hooks"] = "СКОБКИ:[]",
                        ["Chat.Limitter"] = "ПОЛОСА:|"
                    },
					Censures = new Dictionary<string,List<string>>{
						["бля"] = new List<string>{},
						["аху"] = new List<string>{},
						["впиз"] = new List<string>{},
						["въеб"] = new List<string>{},
						["выбля"] = new List<string>{},
						["выеб"] = new List<string>{},
						["выёб"] = new List<string>{},
						["гнид"] = new List<string>{},
						["гонд"] = new List<string>{},
						["доеб"] = new List<string>{},
						["долбо"] = new List<string>{},
						["дроч"] = new List<string>{},
						["ёб"] = new List<string>{},
						["елд"] = new List<string>{},
						["заеб"] = new List<string>{},
						["заёб"] = new List<string>{},
						["залуп"] = new List<string>{},
						["захуя"] = new List<string>{},
						["заяб"] = new List<string>{},
						["злоеб"] = new List<string>{},
						["ипа"] = new List<string>{},
						["лох"] = new List<string>{},
						["лошар"] = new List<string>{},
						["манд"] = new List<string>{"мандар"},
						["мля"] = new List<string>{},
						["мраз"] = new List<string>{},
						["муд"] = new List<string>{"мудр"},
						["наеб"] = new List<string>{},
						["наёб"] = new List<string>{},
						["напизд"] = new List<string>{},
						["нах"] = new List<string>{"наха","нахо","нахл"},
						["нех"] = new List<string>{"нехо","нехв", "неха"},
						["нии"] = new List<string>{},
						["обоср"] = new List<string>{}
					}
                };
            }
        }
        
        #endregion

        #region Variables

        private static TopChat _;
        private static DataBase Handler;
        private static Configuration Settingses;
        
        private static List<ulong> AntiSpamFilter = new List<ulong>();

        #endregion

        #region Initialization

        private void Unload(){
			Handler.SaveData();
			BasePlayer.activePlayerList.ToList().ForEach((player) =>
            {
				CuiHelper.DestroyUi(player, SettingsLayer);
				//CuiHelper.DestroyUi(player, SettingsLayer + ".WINDOW");
				CuiHelper.DestroyUi(player, SettingsLayer + ".INNER");
			});
		}
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                Settingses = Config.ReadObject<Configuration>();
            }
            catch
            {
                PrintWarning($"Error reading config, creating one new config!");
                LoadDefaultConfig();
            }

            SaveConfig();
        } 

        protected override void LoadDefaultConfig() => Settingses = Configuration.LoadDefaultConfiguration();
        protected override void SaveConfig()        => Config.WriteObject(Settingses); 
        
        private void OnServerInitialized()
        {
            _ = this;
            Handler = DataBase.LoadData();
             
            BasePlayer.activePlayerList.ToList().ForEach((player) =>
            {
                if (!Handler.Settingses.ContainsKey(player.userID))
                    Handler.Settingses.Add(player.userID, Settings.Generate());
            });  
            
            if (Interface.Oxide.DataFileSystem.ExistsDatafile("Logs"))
                MessagesLogs = Interface.Oxide.DataFileSystem.ReadObject<HashSet<Message>>($"Logs");
            if (MessagesLogs.Count > 1000)
            {
                MessagesLogs.Clear();
                PrintError("Data messages was cleared!"); 
            } 

            permission.RegisterPermission("topchat.mute", this);	
              
            Settingses.Colors.ToList().ForEach(p => { if (!permission.PermissionExists(p.Key) && p.Key.ToLower().StartsWith("chat")) permission.RegisterPermission(p.Key, this);});
            Settingses.Types.ToList().ForEach(p => { if (!permission.PermissionExists(p.Key) && p.Key.ToLower().StartsWith("chat")) permission.RegisterPermission(p.Key, this);});
            Settingses.Sizes.ToList().ForEach(p => { if (!permission.PermissionExists(p.Key) && p.Key.ToLower().StartsWith("chat")) permission.RegisterPermission(p.Key, this);});
            Settingses.Prefixes.ToList().ForEach(p => { if (!permission.PermissionExists(p.Key) && p.Key.ToLower().StartsWith("chat")) permission.RegisterPermission(p.Key, this);});

            timer.Every(Settingses.BroadcastInterval, () =>
            {
                var message = Settingses.Broadcaster.GetRandom();
                foreach (var check in BasePlayer.activePlayerList.ToList())
                {
                    var settings = Handler.Settingses[check.userID];
                    if (!settings.Chatters.Tips)
                        continue;

                    check.SendConsoleCommand("chat.add", 0, Settingses.ImageID, message);
                    check.SendConsoleCommand($"echo [<color=white>ЧАТ</color>] {message}");
                }
            }).Callback();
            timer.Every(10, AntiSpamFilter.Clear);
            timer.Every(60, Handler.SaveData);
            timer.Every(300, () => BasePlayer.activePlayerList.ToList().ForEach(p => FetchStatus(p)));    
        }
 
        #endregion

        #region Commands

        [ConsoleCommand("UI_Chat")]
        private void CmdConsoleHandler(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (!player || !arg.HasArgs(1)) return;

            switch (arg.Args[0].ToLower())
            {
                case "chatpm":
                {
                    Handler.Settingses[player.userID].Chatters.PM = Convert.ToBoolean(arg.Args[1]);
                    InitializeInterface(player,true); 
                    break;
                }
                case "chatglobal":
                {
                    Handler.Settingses[player.userID].Chatters.Chat = Convert.ToBoolean(arg.Args[1]);
                    InitializeInterface(player,true); 
                    break;
                }
                case "censor":
                {
                    Handler.Settingses[player.userID].Chatters.Censor = Convert.ToBoolean(arg.Args[1]);
                    InitializeInterface(player,true); 
                    break;
                }
                case "sound":
                {
                    Handler.Settingses[player.userID].Chatters.Sound = Convert.ToBoolean(arg.Args[1]);
                    InitializeInterface(player,true); 
                    break;
                }
                case "tips":
                {
                    Handler.Settingses[player.userID].Chatters.Tips = Convert.ToBoolean(arg.Args[1]);
                    InitializeInterface(player,true); 
                    break;
                }
                case "name_color": 
                {
                    var nameColor = Settingses.Colors.FirstOrDefault(p => p.Value == arg.Args[1]);
                    if (!permission.UserHasPermission(player.UserIDString, nameColor.Key)) return;

                    Handler.Settingses[player.userID].Names.Color = nameColor.Value.Split(':')[1];
                    InitializeInterface(player,true); 
                    break;
                }
                case "prefix_color":
                {
                    var nameColor = Settingses.Colors.FirstOrDefault(p => p.Value == arg.Args[1]);
                    if (!permission.UserHasPermission(player.UserIDString, nameColor.Key)) return;

                    Handler.Settingses[player.userID].Prefixes.Color = nameColor.Value.Split(':')[1];
                    InitializeInterface(player,true); 
                    break;
                }
                case "prefix_size":
                {
                    var nameColor = Settingses.Sizes.FirstOrDefault(p => p.Value == arg.Args[1]);
                    if (!permission.UserHasPermission(player.UserIDString, nameColor.Key)) return;

                    Handler.Settingses[player.userID].Prefixes.Size = nameColor.Value.Split(':')[1];
                    InitializeInterface(player,true); 
                    break;
                }
                case "hook_type":
                {
                    var nameColor = Settingses.Types.FirstOrDefault(p => p.Value == arg.Args[1]);
                    if (!permission.UserHasPermission(player.UserIDString, nameColor.Key)) return;

                    Handler.Settingses[player.userID].Prefixes.Hooks = nameColor.Value.Split(':')[1];
                    InitializeInterface(player,true); 
                    break;
                }
                case "prefix":
                {
                    var nameColor = Settingses.Prefixes.FirstOrDefault(p => p.Value == arg.Args[1]);
                    if (!permission.UserHasPermission(player.UserIDString, nameColor.Key)) return;

                    Handler.Settingses[player.userID].Prefixes.Name = nameColor.Value.Split(':')[1];
                    InitializeInterface(player,true); 
                    break;
                }
            }
        }

        #endregion

        #region Hooks
  
        private class Response
        {
            [JsonProperty("country")]
            public string Country { get; set; }
        }
        
        void OnCorpse(BasePlayer player, BaseCorpse corpse)
        {
            if (!Handler.Settingses.ContainsKey(player.userID)) return;

            var obj = corpse.GetComponent<PlayerCorpse>();
            if (obj == null) return;
            obj._playerName = PrepareNick(player);
        }

        private void FetchStatus(BasePlayer player)
        {
            if (!Handler.Settingses.ContainsKey(player.userID))
            {
                OnPlayerConnected(player);
                FetchStatus(player);
                return;
            }
            
            var settings = Handler.Settingses[player.userID];            
            if (Settingses.Prefixes.All(p => !p.Value.Contains(settings.Prefixes.Name)) || !permission.UserHasPermission(player.UserIDString, Settingses.Prefixes.FirstOrDefault(p => p.Value.Contains(settings.Prefixes.Name)).Key))
            {
                settings.Prefixes.Name = Settingses.Prefixes.FirstOrDefault(p => permission.UserHasPermission(player.UserIDString, p.Key)).Value.Split(':')[1]; 				
            }
            if (Settingses.Colors.All(p => !p.Value.Contains(settings.Prefixes.Color)) || !permission.UserHasPermission(player.UserIDString, Settingses.Colors.FirstOrDefault(p => p.Value.Contains(settings.Prefixes.Color)).Key))
            {
                settings.Prefixes.Color = Settingses.Colors.FirstOrDefault(p => permission.UserHasPermission(player.UserIDString, p.Key)).Value.Split(':')[1]; 
            }
            if (Settingses.Types.All(p => !p.Value.Contains(settings.Prefixes.Hooks)) || !permission.UserHasPermission(player.UserIDString, Settingses.Types.FirstOrDefault(p => p.Value.Contains(settings.Prefixes.Hooks)).Key))
            {
                 settings.Prefixes.Hooks = Settingses.Types.FirstOrDefault(p => permission.UserHasPermission(player.UserIDString, p.Key)).Value.Split(':')[1]; 
            } 
            if (Settingses.Sizes.All(p => !p.Value.Contains(settings.Prefixes.Size)) || !permission.UserHasPermission(player.UserIDString, Settingses.Sizes.FirstOrDefault(p => p.Value.Contains(settings.Prefixes.Size)).Key))
            {
                settings.Prefixes.Size = Settingses.Sizes.FirstOrDefault(p => permission.UserHasPermission(player.UserIDString, p.Key)).Value.Split(':')[1]; 
            }
            if (Settingses.Colors.All(p => !p.Value.Contains(settings.Names.Color)) || !permission.UserHasPermission(player.UserIDString, Settingses.Colors.FirstOrDefault(p => p.Value.Contains(settings.Names.Color)).Key))
            { 
                settings.Names.Color = Settingses.Colors.FirstOrDefault(p => permission.UserHasPermission(player.UserIDString, p.Key)).Value.Split(':')[1]; 
            } 
        }
        
        private void OnPlayerConnected(BasePlayer player)
        {
            if (!Handler.Settingses.ContainsKey(player.userID))
                Handler.Settingses.Add(player.userID, Settings.Generate());
            
            FetchStatus(player); 

			foreach (var check in BasePlayer.activePlayerList.ToList())
			{ 
				check.SendConsoleCommand("chat.add", 0, player.userID, $"<size=12>Игрок {_.PrepareNickForConnect(player)} присоединился!</size>");
			}
        }

        private static HashSet<Message> MessagesLogs = new HashSet<Message>();
        
        #region Helpers

        private void Broadcast(string text)
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (!Handler.Settingses.ContainsKey(player.userID))
                    continue;
                    
                var targetSettings = Handler.Settingses[player.userID];
                if (!targetSettings.Chatters.Tips) continue;
                
                SafeMessage(player, text, Settingses.ImageID);
            }
        }
        [ChatCommand("mute")]		
	void ChatMute(BasePlayer player, string command, string[] args)		
	{		
	if (!permission.UserHasPermission(player.UserIDString, "topchat.mute"))		
	{		
	SendReply(player, "<size=12>У вас нет доступа к команде /mute</size>");		
	return;		
	}		
			
	if (args.Length < 3)		
	{		
	SendReply(player, "<size=12>Пример использования:\n/mute <color=#ee3e61>[имя или steamid]</color> <color=#ee3e61>[время мута (в секундах)]</color> <color=#ee3e61>[причина мута]</color></size>");		
	return;		
	}		
			
	var target = FindBasePlayer(args[0]);		
	if (target == null)		
	{		
	SendReply(player, $"<size=12>Игрок не найден!</size>");		
	return;		
	}		
			
	MutePlayer(target, player.displayName, int.Parse(args[1]), args[2]);		
	}		
			
	[ChatCommand("unmute")]		
	void ChatUnMute(BasePlayer player, string command, string[] args)		
	{		
	if (!permission.UserHasPermission(player.UserIDString, "topchat.mute"))		
	{		
	SendReply(player, "<size=12>У вас нет доступа к команде /unmute</size>");		
	return;		
	}		
			
	if (args.Length < 1)		
	{		
	SendReply(player, "<size=12>Пример использования:\n/unmute <color=#ee3e61>[имя или steamid]</color></size>");		
	return;		
	}		
			
	var target = FindBasePlayer(args[0]);		
	if (target == null)		
	{		
	SendReply(player, $"<size=12>Игрок не найден!</size>");		
	return;		
	}		
			
	MutePlayer(target, player.displayName, 0, "");		
	}

        private void MutePlayer(BasePlayer player, string initiatorName, int time, string reason)
        {

            if (time == 0)
            {
                Broadcast($"<color=#90e095>{initiatorName}</color> разблокировал чат игроку <color=#e68585>{player.displayName}</color>");
                Handler.Settingses[player.userID].UMT = 0;
            }
            else 
            {
                Broadcast($"<color=#90e095>{initiatorName}</color> выдал мут игроку <color=#e68585>{player.displayName}</color>\n" +
                          $"  <size=12><color=#e3e3e3>Причина: {reason} [{TimeSpan.FromSeconds(time).ToShortString()}]</color></size>");
                Handler.Settingses[player.userID].UMT = Time() + time;
            }
        }

        BasePlayer FindBasePlayer(string nameOrUserId)		
	{		
	nameOrUserId = nameOrUserId.ToLower();		
	foreach (var player in BasePlayer.activePlayerList)		
	{		
	if (player.displayName.ToLower().Contains(nameOrUserId) || player.UserIDString == nameOrUserId) return player;		
	}		
	foreach (var player in BasePlayer.sleepingPlayerList)		
	{		
	if (player.displayName.ToLower().Contains(nameOrUserId) || player.UserIDString == nameOrUserId) return player;		
	}		
	return default(BasePlayer);		
	}		


        private void SendPrivateMessage(BasePlayer initiator, BasePlayer target, string message)
            => SendPrivateMessage(initiator.userID, target.userID, message);

        private void SendPrivateMessage(ulong initiatorReadyId, ulong targetReadyId, string message)
        {
            BasePlayer initiator = BasePlayer.FindByID(initiatorReadyId);
            BasePlayer target    = BasePlayer.FindByID(targetReadyId);

            string targetReadyName                        = BasePlayer.FindByID(targetReadyId)?.displayName ?? "UNKNOWN";
            string initiatorReadyName                     = BasePlayer.FindByID(initiatorReadyId)?.displayName ?? "UNKNOWN";
            if (initiatorReadyId == 76561199039326412) initiatorReadyName = "ADMIN";

            if (target == null || !target.IsConnected)
            {
                SafeMessage(initiator, "Игрок не находится на сервере!");
                return;
            }

            var targetSettings = Handler.Settingses[targetReadyId];
            if (!targetSettings.IgnoreList.ContainsKey(initiatorReadyId))
            {
                if (!targetSettings.Chatters.PM)
                {
                    initiator.ChatMessage("У игрока отключены приватные сообщения");
                    return;
                }
                if (targetSettings.Chatters.Sound)
                {
                    Effect effect = new Effect("assets/bundled/prefabs/fx/notice/item.select.fx.prefab", target, 0, new Vector3(), new Vector3());
                    EffectNetwork.Send(effect, target.Connection);
                }

                if (initiator != null && initiator.IsConnected)
                {
                    targetSettings.ReplyTarget = initiator;
                }

                string prepareName = PrepareNick(new BasePlayer {userID = initiatorReadyId, displayName = initiatorReadyName});
                SafeMessage(target, $"<size=14>Личное сообщение от {prepareName}</size>\n<size=12>{message}</size>", initiatorReadyId);
            }
 
            string prepareTargetName = PrepareNick(new BasePlayer {userID = targetReadyId, displayName = targetReadyName});
            SafeMessage(initiator, $"<size=14>Личное сообщение для {prepareTargetName}</size>\n<size=12>{message}</size>", targetReadyId);
            AddMessage(initiatorReadyName, initiatorReadyId, message, targetReadyName, targetReadyId);
            
            DebugEx.Log((object) "[CHAT] " + initiatorReadyName + $" [{initiatorReadyId}] : > {target.displayName} [{target.userID}] :" + message); 
        }
		
        public class Message
        {
            [JsonProperty("id")] public string Id = CuiHelper.GetGuid();
            
            [JsonProperty("displayName")] public string DisplayName;
            [JsonProperty("userId")]      public string UserID;

            [JsonProperty("targetDisplayName")] public string TargetDisplayName;
            [JsonProperty("targetUserId")]      public string TargetUserId;

            [JsonProperty("text")]   public string Text;
            [JsonProperty("isTeam")] public bool   IsTeam;
            [JsonProperty("time")]   public string Time;
        }
		
        private void AddMessage(BasePlayer player, string message, bool team = false) => AddMessage(player.displayName, player.userID, message, team: team);

        private void AddMessage(string displayName, ulong userId, string message, string targetName = "", ulong targetId = 0UL, bool team = false)
        {
            var time       = DateTime.Now;
            var resultTime = $"{time.Hour}:{time.Minute}:{time.Second}";

            var chat = new Message
            {
                DisplayName       = displayName,
                Text              = message,
                TargetDisplayName = targetName,
                TargetUserId      = targetId.ToString(),
                Time              = resultTime,
                UserID            = userId.ToString(),
                IsTeam            = team
            };

            MessagesLogs.Add(chat);

            string logFormat = $"{displayName} [{targetId}]: {message}";
            if (team)
            {
                logFormat = "TEAM: " + logFormat;
            }
            else if (targetId != 0)
            {
                logFormat = $"{displayName} [{userId}] -> {targetName}[{targetId}]: {message}";
            }

            LogToFile($"{(!team ? targetId == 0 ? "Chat" : "PM" : "Team")}", logFormat, this);
        }

        #endregion

        #region Utils

        private static void LogInfo(string text)
        {
            //if (Settings) 
            //{
               // _.PrintWarning(text);
            //}
        }
        private static void UnloadPlugin() => _.NextTick(() => Interface.Oxide.UnloadPlugin("TopChat"));
      

        private static double Time() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;

        private static void SafeMessage(BasePlayer player, string text, ulong avatarId = 0)
        {
            if (player == null || !player.IsConnected) return;

            player.SendConsoleCommand("chat.add", 0, avatarId, text);
            player.SendConsoleCommand($"echo <color=white>[ЧАТ]</color> {text}");
        }

        #endregion
 
        private object OnPlayerChat(BasePlayer player, string message, ConVar.Chat.ChatChannel channel)
        {
            // TODO: HotFix
            while (message.Contains("size"))
                message = message.Replace("size", "");

            if (channel == ConVar.Chat.ChatChannel.Global)
            {
                if (AntiSpamFilter.Contains(player.userID) && !player.IsAdmin)
                {
                    player.ChatMessage("Вы не можете писать чаще, чем раз в <color=#fd7d6b>10</color> секунд!\n<size=12>Старайтесь писать всё в одном сообщении.</size>");
                    return false;
                }

                if (Handler.Settingses[player.userID].UMT > Time())
                {
                    player.ChatMessage("Ссори, у вас мут!");
                    return false;
                }

                string realMessage = PrepareMessage(player, message);
                string censureMessage = PrepareMessage(player, Censure(message));
                
                AntiSpamFilter.Add(player.userID); 
                foreach (var check in BasePlayer.activePlayerList.ToList())
                {
                    var settings = Handler.Settingses[check.userID];
                    if (settings.IgnoreList.ContainsKey(player.userID) || !settings.Chatters.Chat)
                        continue;
                    
                    string prepareMessagge = settings.Chatters.Censor ? censureMessage : realMessage; 
                    check.SendConsoleCommand("chat.add", 0, player.userID, prepareMessagge);
                    check.SendConsoleCommand($"echo [<color=white>ЧАТ</color>] {prepareMessagge}");
                }
            
                DebugEx.Log((object) ("[CHAT] " + player.displayName + $" [{player.UserIDString}] : " + message));
                LogChat(player.displayName + $" [{player.UserIDString}]: " + message);
                AddMessage(player, message);
                return false;
            }
            else
            {
                foreach (var check in player.Team.members)
                {
                    var settings = Handler.Settingses[player.userID]; 
                    if (settings.IgnoreList.ContainsKey(player.userID))
                        continue; 

                    var target = BasePlayer.FindByID(check);
                    if (target == null || !target.IsConnected) continue;
                    
                    string prepareMessagge = PrepareMessage(player, message, true);
                    target.SendConsoleCommand("chat.add", 0, player.userID, prepareMessagge);
                    target.SendConsoleCommand($"echo [<color=white>TEAM</color>] {prepareMessagge}");
                }
            
                DebugEx.Log((object) ("[CHAT] " + player.displayName + $" [{player.UserIDString}] : " + "TEAM> " + message));
                LogChat(player.displayName + $" [{player.UserIDString}]: " + message);
                AddMessage(player, message, true); 
                return false;
            }
            return null;
        }

        #endregion

        #region Commands

        private void CmdChatCommandSecret(BasePlayer player, string command, string[] args) => InitializeInterface(player);
        
        [ChatCommand("ignore")]
        private void CmdChatPersonalIgnore(BasePlayer player, string command, string[] args)
        {
            if (args.Length != 1)
            {
                player.ChatMessage($"Вы <color=orange>неправильно</color> используете команду!\n<size=12>/ignore <игрок> - отправить сообщение");
                return;
            }

            var targetSearch = args[0].ToLower();
            
            var target = BasePlayer.activePlayerList.ToList().FirstOrDefault(p => p.displayName.ToLower().Contains(targetSearch) || p.UserIDString == targetSearch);
            if (target == null || !target.IsConnected)
            {
                player.ChatMessage($"Игрок не найден!");
                return;
            }

            var settings = Handler.Settingses[player.userID];
            if (settings.IgnoreList.ContainsKey(target.userID))
            {
                player.ChatMessage($"Вы больше <color=orange>не игнорируете</color> этого игрока!");
                settings.IgnoreList.Remove(target.userID);
                return;
            }
            else
            {
                player.ChatMessage($"Теперь вы <color=orange>игнорируете</color> этого игрока!");
                settings.IgnoreList.Add(target.userID, target.displayName);
                return;
            }
        }

        [ChatCommand("r")]
        private void CmdChatPersonalReply(BasePlayer player, string command, string[] args)
        {
            if (args.Length < 1)
            {
                player.ChatMessage($"Вы <color=orange>неправильно</color> используете команду!\n<size=12>/r <сообщение> - отправить сообщение</size>");
                return;
            }

            var message = "";

            for (var i = 0; i < args.Length; i++)
                message += $"{args[i]} ";

            var target = Handler.Settingses[player.userID].ReplyTarget;
            if (target == null || !target.IsConnected)
            {
                player.ChatMessage($"Игрок не найден!");
                return;
            }

            SendPrivateMessage(player, target, message); 
        }
        
        [ChatCommand("pm")]
        private void CmdChatPersonalMessage(BasePlayer player, string command, string[] args)
        {
            if (args.Length <= 1)
            {
                player.ChatMessage($"Вы <color=orange>неправильно</color> используете команду!\n<size=12>/pm <имя> <сообщение> - отправить сообщение</size>");
                return;
            }

            var targetSearch = args[0].ToLower();
            var message      = "";

            for (var i = 1; i < args.Length; i++)
                message += $"{args[i]} ";

            var target = BasePlayer.activePlayerList.ToList().FirstOrDefault(p => p.displayName.ToLower().Contains(targetSearch));
            if (target == null || !target.IsConnected)
            {
                player.ChatMessage($"Игрок не найден!");
                return;
            }
            
            SendPrivateMessage(player, target, message);
        }
 
        #endregion

        #region Interface 
		[ConsoleCommand("UI_RM_Handler")]
        private void CmdConsoleRustMenu(ConsoleSystem.Arg args)
        {
			var player = args.Player();
            if (player == null || !args.HasArgs(1)) return;

            switch (args.Args[0].ToLower())
            {
                case "close":
                { 
					CuiHelper.DestroyUi(player, SettingsLayer);
					//CuiHelper.DestroyUi(player, SettingsLayer + ".WINDOW");
					CuiHelper.DestroyUi(player, SettingsLayer + ".INNER");

                    break;
				}
			}
		
		}
        private string SettingsLayer = "UI_SettingsLayer"; 
        private void InitializeInterface(BasePlayer player, bool reopen = false)
        {
            FetchStatus(player); 
			
            var settings = Handler.Settingses[player.userID];			 
			 
            CuiElementContainer container = new CuiElementContainer();
            if (!reopen)
            {
                CuiHelper.DestroyUi(player, SettingsLayer);

				container.Add(new CuiElement
				{
					Name = SettingsLayer + ".WINDOW_FRAME",
					Parent = "Menu_UI",
					Components =
					{
						new CuiImageComponent { Color = "0.117 0.121 0.109 0.95" },	
						new CuiRectTransformComponent { AnchorMin = "0.468 0", AnchorMax = "0.957 1" }					
					}
				});

				container.Add(new CuiElement
				{
					Name = SettingsLayer + ".WINDOW",
					Parent = SettingsLayer + ".WINDOW_FRAME",
					Components =
					{
						new CuiImageComponent { Color = "0 0 0 0" },	
						new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0"}					
					}
				});
			}
			CuiHelper.DestroyUi(player, SettingsLayer + ".INNER");
            
			container.Add(new CuiPanel()
			{ 
				CursorEnabled = false,
				RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0"},  
				Image         = {Color = "0 0 0 0.0" }
			}, SettingsLayer + ".WINDOW", SettingsLayer + ".INNER");
            
            container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = $"28 -90", OffsetMax = $"500 -20"} ,
                    Text = { Text = "НАСТРОЙКИ НИКА", Align = TextAnchor.UpperLeft, Font = "robotocondensed-bold.ttf", FontSize = 40, Color = "0.93 0.89 0.85 1"}
                }, SettingsLayer + ".INNER");  
            
            container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = $"30 -130", OffsetMax = $"500 -80"} , 
                    Text = { Text = $"ТВОЙ НИК СЕЙЧАС: {PrepareNick(player)}", Align = TextAnchor.UpperLeft, Font = "robotocondensed-bold.ttf", FontSize = 18, Color = "0.81 0.77 0.74 0.6"}
                }, SettingsLayer + ".INNER");
            
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "0 0", OffsetMax = "0 125" },
                Image = { Color = "0.29411 0.27450 0.254901 1" }
            },  SettingsLayer + ".WINDOW", SettingsLayer + ".Info");//
			
			container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = $"28 -100", OffsetMax = $"-30 -5"},
                Text = { Text = "ИНФОРМАЦИЯ", Align = TextAnchor.UpperLeft, Font = "robotocondensed-bold.ttf", FontSize = 40, Color = "0.93 0.89 0.85 1"}
            }, SettingsLayer + ".Info");

            string helpText = "<b>Подсказки</b> - сообщения сервера с подсказками (которые отправляются в чат каждые ~3 минуты)\n<b>Глобальный чат</b> - отключает общий чат, но информационные сообщения от плагинов и раста остаются\n<b>Личные сообщения</b> - отключает/включает возможность писать вам в личные сообщения";
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "30 0", OffsetMax = "0 -60" },
                Text = { Text = helpText, Align = TextAnchor.UpperLeft, Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "0.67 0.63 0.596"}
            }, SettingsLayer + ".Info");

            #region Switch layer Цвет
            
            var currentStatus = Settingses.Colors.FirstOrDefault(p => p.Value.Split(':')[1] == settings.Names.Color);
            List<KeyValuePair<string, string>> possibleStatuses = Settingses.Colors.ToList().FindAll(p => permission.UserHasPermission(player.UserIDString, p.Key));
 
            var colorIndex = possibleStatuses.IndexOf(currentStatus);
            string leftCommand = $"UI_Chat name_color {possibleStatuses.ElementAtOrDefault(colorIndex - 1).Value}"; 
            string rightCommand = $"UI_Chat name_color {possibleStatuses.ElementAtOrDefault(colorIndex + 1).Value}"; 
            bool leftActive = colorIndex > 0;
            bool rightActive = colorIndex < possibleStatuses.Count - 1;
            
            string guid = CuiHelper.GetGuid(); 
            container.Add(new CuiLabel 
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = $"30 -200", OffsetMax = $"-10 -130" },
                Text = { Text = $"ЦВЕТ НИКА<size=12>({possibleStatuses.Count})</size>", Align = TextAnchor.UpperLeft, Font = "robotocondensed-bold.ttf", FontSize = 28, Color = "0.81 0.77 0.74 0.6"}
            }, SettingsLayer + ".INNER", guid);
            
            container.Add(new CuiPanel
            {
                RectTransform = {AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = $"-250 -30", OffsetMax = $"-30 0"},
                Image = {Color = "0.27 0.247 0.184 1"}
            }, guid, guid + ".P");
            
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 1", OffsetMax = "30 0" },
                Image = { Color = leftActive ? "0.81 0.77 0.74 0.2" : "0.81 0.77 0.74 0.15" }
            }, guid + ".P", guid + ".L"); 
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = leftActive ? leftCommand : "" },
                Text = { Text = "<b><</b>", Font = "robotocondensed-bold.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter, Color = leftActive ? "0.8 0.8 0.8 1" : "0.8 0.8 0.8 0.2" }
            }, guid + ".L");
            
            container.Add(new CuiPanel 
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 1", OffsetMin = "-30 0", OffsetMax = "0 0" },
                Image = { Color = rightActive ? "0.81 0.77 0.74 0.2" : "0.81 0.77 0.74 0.1"}
            }, guid + ".P", guid + ".WINDOW");
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = rightActive ? rightCommand : "" },
                Text = { Text = "<b>></b>", Font = "robotocondensed-bold.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter, Color = rightActive ? "0.8 0.8 0.8 1" : "0.8 0.8 0.8 0.2"}
            }, guid + ".WINDOW");
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = $"30 0", OffsetMax = $"-30 0" },  
                Text = { Text = currentStatus.Value.Split(':')[0], Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 18, Color = "0.81 0.77 0.74 0.6"}
            }, guid + ".P");

            #endregion 

            #region Switch layer Префикс
            
            currentStatus = Settingses.Prefixes.FirstOrDefault(p => p.Value.Split(':')[1] == settings.Prefixes.Name);
            possibleStatuses = Settingses.Prefixes.ToList().FindAll(p => permission.UserHasPermission(player.UserIDString, p.Key));
            bool canChange = currentStatus.Value != "НЕТ:-";
            
            colorIndex = possibleStatuses.IndexOf(currentStatus);
            leftCommand = $"UI_Chat prefix {possibleStatuses.ElementAtOrDefault(colorIndex - 1).Value}"; 
            rightCommand = $"UI_Chat prefix {possibleStatuses.ElementAtOrDefault(colorIndex + 1).Value}"; 
            leftActive = colorIndex > 0;
            rightActive = colorIndex < possibleStatuses.Count - 1;
            
            guid = CuiHelper.GetGuid(); 
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = $"30 -220", OffsetMax = $"-10 -165" },
                Text = { Text = $"ПРЕФИКС<size=12>({possibleStatuses.Count})</size>", Align = TextAnchor.UpperLeft, Font = "robotocondensed-bold.ttf", FontSize = 28, Color = "0.81 0.77 0.74 0.6"}
            }, SettingsLayer + ".INNER", guid);

            container.Add(new CuiPanel
            {
                RectTransform = {AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = $"-250 -30", OffsetMax = $"-30 0"},
                Image = {Color = "0.27 0.247 0.184 1"} 
            }, guid, guid + ".P");
            
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 1", OffsetMax = "30 0" },
                Image = { Color = leftActive ? "0.81 0.77 0.74 0.2" : "0.81 0.77 0.74 0.15" }
            }, guid + ".P", guid + ".L"); 
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = leftActive ? leftCommand : "" },
                Text = { Text = "<b><</b>", Font = "robotocondensed-bold.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter, Color = leftActive ? "0.8 0.8 0.8 1" : "0.8 0.8 0.8 0.2" }
            }, guid + ".L");
            
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 1", OffsetMin = "-30 0", OffsetMax = "0 0" },
                Image = { Color = rightActive ? "0.81 0.77 0.74 0.2" : "0.81 0.77 0.74 0.1"}
            }, guid + ".P", guid + ".WINDOW");
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = rightActive ? rightCommand : "" },
                Text = { Text = "<b>></b>", Font = "robotocondensed-bold.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter, Color = rightActive ? "0.8 0.8 0.8 1" : "0.8 0.8 0.8 0.2"}
            }, guid + ".WINDOW");
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = $"30 0", OffsetMax = $"-30 0" },  
                Text = { Text = currentStatus.Value.Split(':')[0], Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 18, Color = "0.81 0.77 0.74 0.6"}
            }, guid + ".P");

            #endregion 

            #region Switch layer ЦветПрефикс
            
            
            currentStatus = Settingses.Colors.FirstOrDefault(p => p.Value.Split(':')[1] == settings.Prefixes.Color);
            possibleStatuses = Settingses.Colors.ToList().FindAll(p => permission.UserHasPermission(player.UserIDString, p.Key));
 
            colorIndex = possibleStatuses.IndexOf(currentStatus);
            leftCommand = $"UI_Chat prefix_color {possibleStatuses.ElementAtOrDefault(colorIndex - 1).Value}"; 
            rightCommand = $"UI_Chat prefix_color {possibleStatuses.ElementAtOrDefault(colorIndex + 1).Value}"; 
            leftActive = colorIndex > 0 && canChange;
            rightActive = colorIndex < possibleStatuses.Count - 1 && canChange;
            
            guid = CuiHelper.GetGuid(); 
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = $"30 -250", OffsetMax = $"-10 -200" },
                Text = { Text = $"ЦВЕТ ПРЕФИКСА<size=12>({possibleStatuses.Count})</size>", Align = TextAnchor.UpperLeft, Font = "robotocondensed-bold.ttf", FontSize = 28, Color = "0.81 0.77 0.74 0.6"}
            }, SettingsLayer + ".INNER", guid);

            container.Add(new CuiPanel
            {
                RectTransform = {AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = $"-250 -30", OffsetMax = $"-30 0"},
                Image = {Color = "0.27 0.247 0.184 1"}
            }, guid, guid + ".P");
            
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 1", OffsetMax = "30 0" },
                Image = { Color = leftActive ? "0.81 0.77 0.74 0.2" : "0.81 0.77 0.74 0.15" }
            }, guid + ".P", guid + ".L"); 
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = leftActive ? leftCommand : "" },
                Text = { Text = "<b><</b>", Font = "robotocondensed-bold.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter, Color = leftActive ? "0.8 0.8 0.8 1" : "0.8 0.8 0.8 0.2" }
            }, guid + ".L");
            
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 1", OffsetMin = "-30 0", OffsetMax = "0 0" },
                Image = { Color = rightActive ? "0.81 0.77 0.74 0.2" : "0.81 0.77 0.74 0.1"}
            }, guid + ".P", guid + ".WINDOW");
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = rightActive ? rightCommand : "" },
                Text = { Text = "<b>></b>", Font = "robotocondensed-bold.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter, Color = rightActive ? "0.8 0.8 0.8 1" : "0.8 0.8 0.8 0.2"}
            }, guid + ".WINDOW");
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = $"30 0", OffsetMax = $"-30 0" },  
                Text = { Text = currentStatus.Value.Split(':')[0], Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 18, Color = "0.81 0.77 0.74 0.6"}
            }, guid + ".P");

            #endregion 

            #region Switch layer Размер префикса
            
            
            currentStatus = Settingses.Sizes.FirstOrDefault(p => p.Value.Split(':')[1] == settings.Prefixes.Size);
            possibleStatuses = Settingses.Sizes.ToList().FindAll(p => permission.UserHasPermission(player.UserIDString, p.Key));
 
            colorIndex = possibleStatuses.IndexOf(currentStatus);
            leftCommand = $"UI_Chat prefix_size {possibleStatuses.ElementAtOrDefault(colorIndex - 1).Value}"; 
            rightCommand = $"UI_Chat prefix_size {possibleStatuses.ElementAtOrDefault(colorIndex + 1).Value}"; 
            leftActive = colorIndex > 0 && canChange;
            rightActive = colorIndex < possibleStatuses.Count - 1 && canChange;
            
            guid = CuiHelper.GetGuid(); 
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = $"30 -290", OffsetMax = $"-10 -235" },
                Text = { Text = $"РАЗМЕР ПРЕФИКСА<size=12>({possibleStatuses.Count})</size>", Align = TextAnchor.UpperLeft, Font = "robotocondensed-bold.ttf", FontSize = 28, Color = "0.81 0.77 0.74 0.6"}
            }, SettingsLayer + ".INNER", guid);

            container.Add(new CuiPanel
            {
                RectTransform = {AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = $"-250 -30", OffsetMax = $"-30 0"},
                Image = {Color = "0.27 0.247 0.184 1"}
            }, guid, guid + ".P");
            
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 1", OffsetMax = "30 0" },
                Image = { Color = leftActive ? "0.81 0.77 0.74 0.2" : "0.81 0.77 0.74 0.15" }
            }, guid + ".P", guid + ".L"); 
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = leftActive ? leftCommand : "" },
                Text = { Text = "<b><</b>", Font = "robotocondensed-bold.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter, Color = leftActive ? "0.8 0.8 0.8 1" : "0.8 0.8 0.8 0.2" }
            }, guid + ".L");
            
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 1", OffsetMin = "-30 0", OffsetMax = "0 0" },
                Image = { Color = rightActive ? "0.81 0.77 0.74 0.2" : "0.81 0.77 0.74 0.1"}
            }, guid + ".P", guid + ".WINDOW");
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = rightActive ? rightCommand : "" },
                Text = { Text = "<b>></b>", Font = "robotocondensed-bold.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter, Color = rightActive ? "0.8 0.8 0.8 1" : "0.8 0.8 0.8 0.2"}
            }, guid + ".WINDOW");
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = $"30 0", OffsetMax = $"-30 0" },  
                Text = { Text = currentStatus.Value.Split(':')[0], Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 18, Color = "0.81 0.77 0.74 0.6"}
            }, guid + ".P");

            #endregion 

            #region Switch layer Вид префикса
            
            
            currentStatus = Settingses.Types.FirstOrDefault(p => p.Value.Split(':')[1] == settings.Prefixes.Hooks);
            possibleStatuses = Settingses.Types.ToList().FindAll(p => permission.UserHasPermission(player.UserIDString, p.Key));
 
            colorIndex = possibleStatuses.IndexOf(currentStatus);
            leftCommand = $"UI_Chat hook_type {possibleStatuses.ElementAtOrDefault(colorIndex - 1).Value}"; 
            rightCommand = $"UI_Chat hook_type {possibleStatuses.ElementAtOrDefault(colorIndex + 1).Value}"; 
            leftActive = colorIndex > 0 && canChange;
            rightActive = colorIndex < possibleStatuses.Count - 1 && canChange;
            
            guid = CuiHelper.GetGuid(); 
             
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = $"30 -390", OffsetMax = $"-10 -270" },
                Text = { Text = $"ВИД ПРЕФИКСА<size=12>({possibleStatuses.Count})</size>", Align = TextAnchor.UpperLeft, Font = "robotocondensed-bold.ttf", FontSize = 28, Color = "0.81 0.77 0.74 0.6"}
            }, SettingsLayer + ".INNER", guid);

            container.Add(new CuiPanel
            {
                RectTransform = {AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = $"-250 -30", OffsetMax = $"-30 0"},
                Image = {Color = "0.27 0.247 0.184 1"}
            }, guid, guid + ".P");
            
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 1", OffsetMax = "30 0" },
                Image = { Color = leftActive ? "0.81 0.77 0.74 0.2" : "0.81 0.77 0.74 0.15" }
            }, guid + ".P", guid + ".L"); 
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = leftActive ? leftCommand : "" },
                Text = { Text = "<b><</b>", Font = "robotocondensed-bold.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter, Color = leftActive ? "0.8 0.8 0.8 1" : "0.8 0.8 0.8 0.2" }
            }, guid + ".L");
            
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 1", OffsetMin = "-30 0", OffsetMax = "0 0" },
                Image = { Color = rightActive ? "0.81 0.77 0.74 0.2" : "0.81 0.77 0.74 0.1"}
            }, guid + ".P", guid + ".WINDOW");
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = rightActive ? rightCommand : "" },
                Text = { Text = "<b>></b>", Font = "robotocondensed-bold.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter, Color = rightActive ? "0.8 0.8 0.8 1" : "0.8 0.8 0.8 0.2"}
            }, guid + ".WINDOW");
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = $"30 0", OffsetMax = $"-30 0" },  
                Text = { Text = currentStatus.Value.Split(':')[0], Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 18, Color = "0.81 0.77 0.74 0.6"}
            }, guid + ".P");

            #endregion 
            
            
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = $"28 -500", OffsetMax = $"500 -320"} ,
                Text = { Text = "НАСТРОЙКИ ЧАТА", Align = TextAnchor.UpperLeft, Font = "robotocondensed-bold.ttf", FontSize = 40, Color = "0.93 0.89 0.85 1"}
            }, SettingsLayer + ".INNER");  
            

            #region Bool layer Подсказки
            
             
            var switchStatus = settings.Chatters.Tips;

            var mainCommand = $"UI_Chat tips {!switchStatus}"; 
            
            guid = CuiHelper.GetGuid(); 
             
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = $"30 -500", OffsetMax = $"-10 -390" },
                Text = { Text = "ПОДСКАЗКИ", Align = TextAnchor.UpperLeft, Font = "robotocondensed-bold.ttf", FontSize = 28, Color = "0.81 0.77 0.74 0.6"}
            }, SettingsLayer + ".INNER", guid);

            container.Add(new CuiPanel
            {
                RectTransform = {AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = $"-250 -30", OffsetMax = $"-30 0"},
                Image = {Color = switchStatus ? "0.27 0.247 0.184 1" : "0.23 0.22 0.17 0.5"}
            }, guid, guid + ".P");
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = $"30 0", OffsetMax = $"-30 0" },  
                Text = { Text = switchStatus ? "ВКЛ" : "ВЫКЛ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 18, Color = "0.81 0.77 0.74 0.6"}
            }, guid + ".P");
            
            container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0", Command = mainCommand },
                    Text = { Text = "", Font = "robotocondensed-bold.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter, Color = rightActive ? "0.8 0.8 0.8 1" : "0.8 0.8 0.8 0.2"}
                }, guid + ".P"); 

            #endregion 
            
            #region Bool layer Звуки
            
             
            switchStatus = settings.Chatters.Sound;

            mainCommand = $"UI_Chat sound {!switchStatus}";  
            
            guid = CuiHelper.GetGuid(); 
             
            container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = $"30 -700", OffsetMax = $"-10 -425" },
                    Text = { Text = "ЗВУК ЛИЧНЫХ СООБЩ.", Align = TextAnchor.UpperLeft, Font = "robotocondensed-bold.ttf", FontSize = 28, Color = "0.81 0.77 0.74 0.6"}
                }, SettingsLayer + ".INNER", guid);

            container.Add(new CuiPanel
                {
                    RectTransform = {AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = $"-250 -30", OffsetMax = $"-30 0"},
                    Image = {Color = switchStatus ? "0.27 0.247 0.184 1" : "0.23 0.22 0.17 0.5"}
                }, guid, guid + ".P");
            
            container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = $"30 0", OffsetMax = $"-30 0" },  
                    Text = { Text = switchStatus ? "ВКЛ" : "ВЫКЛ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 18, Color = "0.81 0.77 0.74 0.6"}
                }, guid + ".P");
            
            container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0", Command = mainCommand },
                    Text = { Text = "", Font = "robotocondensed-bold.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter, Color = rightActive ? "0.8 0.8 0.8 1" : "0.8 0.8 0.8 0.2"}
                }, guid + ".P"); 

            #endregion 
            
            
            #region Bool layer Вид префикса
            
             
            switchStatus = settings.Chatters.Censor;

            mainCommand = $"UI_Chat censor {!switchStatus}";  
            
            guid = CuiHelper.GetGuid(); 
             
            container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = $"30 -700", OffsetMax = $"-10 -460" },
                    Text = { Text = "ЦЕНЗУРА", Align = TextAnchor.UpperLeft, Font = "robotocondensed-bold.ttf", FontSize = 28, Color = "0.81 0.77 0.74 0.6"}
                }, SettingsLayer + ".INNER", guid);

            container.Add(new CuiPanel
                {
                    RectTransform = {AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = $"-250 -30", OffsetMax = $"-30 0"},
                    Image = {Color = switchStatus ? "0.27 0.247 0.184 1" : "0.23 0.22 0.17 0.5"}
                }, guid, guid + ".P");
            
            container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = $"30 0", OffsetMax = $"-30 0" },  
                    Text = { Text = switchStatus ? "ВКЛ" : "ВЫКЛ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 18, Color = "0.81 0.77 0.74 0.6"}
                }, guid + ".P");
            
            container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0", Command = mainCommand },
                    Text = { Text = "", Font = "robotocondensed-bold.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter, Color = rightActive ? "0.8 0.8 0.8 1" : "0.8 0.8 0.8 0.2"}
                }, guid + ".P"); 

            #endregion 
            
            #region Bool layer Вид префикса
            
             
            switchStatus = settings.Chatters.Chat;

            mainCommand = $"UI_Chat chatglobal {!switchStatus}";  
            
            guid = CuiHelper.GetGuid(); 
             
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = $"30 -700", OffsetMax = $"-10 -495" },
                Text = { Text = "ГЛОБАЛЬНЫЙ ЧАТ", Align = TextAnchor.UpperLeft, Font = "robotocondensed-bold.ttf", FontSize = 28, Color = "0.81 0.77 0.74 0.6"}
            }, SettingsLayer + ".INNER", guid);

            container.Add(new CuiPanel
            {
                RectTransform = {AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = $"-250 -30", OffsetMax = $"-30 0"},
                Image = {Color = switchStatus ? "0.27 0.247 0.184 1" : "0.23 0.22 0.17 0.5"}
            }, guid, guid + ".P");
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = $"30 0", OffsetMax = $"-30 0" },  
                Text = { Text = switchStatus ? "ВКЛ" : "ВЫКЛ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 18, Color = "0.81 0.77 0.74 0.6"}
            }, guid + ".P");
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = mainCommand },
                Text = { Text = "", Font = "robotocondensed-bold.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter, Color = rightActive ? "0.8 0.8 0.8 1" : "0.8 0.8 0.8 0.2"}
            }, guid + ".P"); 

            #endregion 
            
            #region Bool layer Вид префикса
            
             
            switchStatus = settings.Chatters.PM;

            mainCommand = $"UI_Chat chatpm {!switchStatus}";  
            
            guid = CuiHelper.GetGuid(); 
             
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = $"30 -700", OffsetMax = $"-10 -530" },
                Text = { Text = "ЛИЧНЫЕ СООБЩЕНИЯ", Align = TextAnchor.UpperLeft, Font = "robotocondensed-bold.ttf", FontSize = 28, Color = "0.81 0.77 0.74 0.6"}
            }, SettingsLayer + ".INNER", guid);

            container.Add(new CuiPanel
            {
                RectTransform = {AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = $"-250 -30", OffsetMax = $"-30 0"},
                Image = {Color = switchStatus ? "0.27 0.247 0.184 1" : "0.23 0.22 0.17 0.5"}
            }, guid, guid + ".P");
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = $"30 0", OffsetMax = $"-30 0" },  
                Text = { Text = switchStatus ? "ВКЛ" : "ВЫКЛ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 18, Color = "0.81 0.77 0.74 0.6"}
            }, guid + ".P");
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = mainCommand },
                Text = { Text = "", Font = "robotocondensed-bold.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter, Color = rightActive ? "0.8 0.8 0.8 1" : "0.8 0.8 0.8 0.2"}
            }, guid + ".P"); 

            #endregion 
			
            CuiHelper.AddUi(player, container);	
        }
 
        #endregion

        #region Utils

        private void LogChat(string message) => LogToFile("Chat", "[" + DateTime.Now.ToShortTimeString() + "]" + message, this);
        private void LogPM(string message) => LogToFile("PM", "[" + DateTime.Now.ToShortTimeString() + "]" + message, this);

        
        
        private string PrepareNickForConnect(BasePlayer player)
        {
            var settings = Handler.Settingses[player.userID];

            string prefixPrepare = "continue";
            switch (settings.Prefixes.Hooks) 
            {
                case "[]": prefixPrepare = $"[{settings.Prefixes.Color}{settings.Prefixes.Name}</color>]";
                    break;
                case "-": prefixPrepare = $"{settings.Prefixes.Color}{settings.Prefixes.Name}</color>";
                    break;
                case "|": prefixPrepare = $"{settings.Prefixes.Color}{settings.Prefixes.Name}</color> |";
                    break;
            }

            if (settings.Prefixes.Name == "-")
                prefixPrepare = "";
            
            string format = "continue";
            switch (settings.Prefixes.Hooks)
            {
                case "[]": format = $"{(Settingses.WelcomePrefix ? prefixPrepare : "")} {settings.Names.Color}{player.displayName}</color>";
                    break;
                case "-": format = $"{(Settingses.WelcomePrefix ? prefixPrepare : "")} {settings.Names.Color}{player.displayName}</color>";
                    break;
                case "|": format = $"{(Settingses.WelcomePrefix ? prefixPrepare : "")} {settings.Names.Color}{player.displayName}</color>";
                    break;
            }
            
            return format; 
        }
        private string PrepareNick(BasePlayer player)
        {
            var settings = Handler.Settingses[player.userID];

            string prefixPrepare = "continue";
            switch (settings.Prefixes.Hooks) 
            {
                case "[]": prefixPrepare = $"[{settings.Prefixes.Color}{settings.Prefixes.Name}</color>]";
                    break;
                case "-": prefixPrepare = $"{settings.Prefixes.Color}{settings.Prefixes.Name}</color>";
                    break;
                case "|": prefixPrepare = $"{settings.Prefixes.Color}{settings.Prefixes.Name}</color> |";
                    break;
            }

            if (settings.Prefixes.Name == "-")
                prefixPrepare = "";

            string name = player.displayName.Length > 26 ? player.displayName.Substring(0, 26) : player.displayName;

            string format = "continue";
            switch (settings.Prefixes.Hooks)
            {
                case "[]": format = $"{prefixPrepare} {settings.Names.Color}{name}</color>";
                    break;
                case "-": format = $"{prefixPrepare} {settings.Names.Color}{name}</color>";
                    break;
                case "|": format = $"{prefixPrepare} {settings.Names.Color}{name}</color>";
                    break;
            }
            
            return format; 
        }

        private string Censure(string message)
        {
            foreach (var mat in Settingses.Censures)
            {
                if (message.ToLower().Contains(mat.Key))
                {
                    bool shouldReplace = true;
                    foreach (var ist in mat.Value)
                    {
                        if (message.Contains(ist))
                        {
                            shouldReplace = false;
                            break;
                        }
                    }

                    if (shouldReplace) message = message.Replace(mat.Key, "***", StringComparison.CurrentCultureIgnoreCase);
                }
            }

            return message; 
        }
        
        private string PrepareMessage(BasePlayer player, string message, bool team = false) 
        {
            var settings = Handler.Settingses[player.userID];

            string prefixPrepare = "continue";
            switch (settings.Prefixes.Hooks)
            {
                case "[]": prefixPrepare = $"{settings.Prefixes.Size}[{settings.Prefixes.Color}{settings.Prefixes.Name}</color>]</size>";
                    break;
                case "-": prefixPrepare = $"{settings.Prefixes.Size}{settings.Prefixes.Color}{settings.Prefixes.Name}</color></size>";
                    break;
                case "|": prefixPrepare = $"{settings.Prefixes.Size}{settings.Prefixes.Color}{settings.Prefixes.Name}</color></size> |";
                    break;
            }

            if (settings.Prefixes.Name == "-")
                prefixPrepare = "";
            
            string format = "continue";
            switch (settings.Prefixes.Hooks)
            {
                case "[]": format = $"{prefixPrepare} {settings.Names.Color}{player.displayName}</color>: {message}";
                    break;
                case "-": format = $"{prefixPrepare} {settings.Names.Color}{player.displayName}</color>: {message}";
                    break;
                case "|": format = $"{prefixPrepare} {settings.Names.Color}{player.displayName}</color>: {message}";
                    break;
            }

            if (team) format = "<color=#ADFF2F>[TEAM]</color> " + format;
            
            return format;
        }

        #endregion
    }
}

// --- End of file: TopChat.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BloodRust-fuuu/SkillSystem.cs ---
// --- Original Local Path: BloodRust-fuuu/SkillSystem.cs ---

﻿using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("SkillSystem", "TopPlugin.ru", "3.0.0")]
    class SkillSystem : RustPlugin
    {
        #region Вар
        private string Layer = "Skill_UI";
        private string LayersAlert = "Alerts_UI";

        [PluginReference] private Plugin ImageLibrary;
        #endregion

        #region Класс
        public class SkillSettings
        {
            [JsonProperty("Название панельки")] public string Name;
            [JsonProperty("Информация")] public string Info;
            [JsonProperty("Название предмета")] public string DisplayName;
            [JsonProperty("Используемый предмет Glue")] public string ShortName;
            [JsonProperty("SkinId предмета")] public ulong SkinID;
            [JsonProperty("Шанс выпадения листка в %")] public float DropChance;
        }
        
        public class Settings
        {
            [JsonProperty("Название навыка")] public string DisplayName;
            [JsonProperty("Рейтинг увеличения навыка за уровень")] public float Rate;
            [JsonProperty("Сколько нужно листов с информацией, чтобы прокачать навык")] public int Price;
            [JsonProperty("Максимальный уровень прокачки навыка")] public int LevelMax;
            [JsonProperty("Изображение навыка")] public string Url;
            [JsonProperty("Короткое название предмета, на который будет действовать увеличенный рейтинг навыка")] public Dictionary<string, string> ShortName;
        }
        
        private Dictionary<ulong, Dictionary<string, SettingsData>> settingsData;
        public class SettingsData
        {
            [JsonProperty("Навык")] public int Level;
            [JsonProperty("Рейт")] public float Rate = 1;
        }
        #endregion

        #region Конфиг
        public Configuration config;
        public class Configuration
        {
            [JsonProperty("Настройки")] public SkillSettings skill = new SkillSettings();
            [JsonProperty("Список")] public List<Settings> settings;
            [JsonProperty("Список ящиков")] public List<string> container = new List<string>();
            public static Configuration GetNewCong()
            {
                return new Configuration
                {
                    skill = new SkillSettings()
                    {
                        DisplayName = "Листок с информацией",
                        ShortName = "glue",
                        SkinID = 1835496050,
                        DropChance = 100f
                    },
                    settings = new List<Settings>
                    {
                        new Settings()
                        {
                            DisplayName = "Гайд для лесоруба",
                            Rate = 0.1f,
                            Price = 100,
                            LevelMax = 10,
                            Url = "https://imgur.com/4q8snx9.png",
                            ShortName = new Dictionary<string, string>()
                                                         {
                                ["wood"] = "Дерево"
                            }
                        },                
                        new Settings()
                        {
                            DisplayName = "Дневник шахтера",
                            Rate = 0.1f,
                            Price = 100,
                            LevelMax = 10,
                            Url = "https://imgur.com/Lhyflw5.png",
                            ShortName = new Dictionary<string, string>()
                            {
                                ["stones"] = "Камень"
                            }
                        },        
                        new Settings()
                        {
                            DisplayName = "Добыча металла",
                            Rate = 0.1f,
                            Price = 100,
                            LevelMax = 10,
                            Url = "https://imgur.com/xAepxrq.png",
                            ShortName = new Dictionary<string, string>()
                            {
                                ["metal.ore"] = "Металл"
                            }
                        },   
                        new Settings()
                        {
                            DisplayName = "Серные камни",
                            Rate = 0.1f,
                            Price = 100,
                            LevelMax = 10,
                            Url = "https://imgur.com/6xqLfrQ.png",
                            ShortName = new Dictionary<string, string>()
                            {
                                ["sulfur.ore"] = "Сера"
                            }
                        },  
                        new Settings()
                        {
                            DisplayName = "Снятие шкур",
                            Rate = 0.1f,
                            Price = 100,
                            LevelMax = 10,
                            Url = "https://imgur.com/Nla51R6.png",
                            ShortName = new Dictionary<string, string>()
                            {
                                ["cloth"] = "Ткань"
                            }
                        },  
                        new Settings()
                        {
                            DisplayName = "Поиск предметов",
                            Rate = 0.1f,
                            Price = 100,
                            LevelMax = 10,
                            Url = "https://imgur.com/E46dylP.png",
                            ShortName = new Dictionary<string, string>()
                            {
                                ["Поиск"] = "Не трогать"
                            }
                        },
                    },
                    container = new List<string>()
                    {
                        { "crate_elite" },
                        { "supply_drop" },
                        { "crate_normal_2" }
                    }
                };
            }
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config?.container == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Ошибка чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewCong();
        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion

        #region Команды
        [ConsoleCommand("skill")]
        private void Command(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player != null && args.HasArgs(1))
            {
                if (args.Args[0] == "buy")
                {
                    var check = config.settings.ElementAt(int.Parse(args.Args[1]));
                    var count = player.inventory.GetAmount(ItemManager.FindItemDefinition(config.skill.ShortName).itemid);
                    if (count >= check.Price) { } else { return; }
                    foreach (var item in check.ShortName)
                    {
                        var data = AddPlayersData(player.userID, item.Key);
                        if (data.Level != check.LevelMax)
                        {
                            data.Rate += check.Rate;
                            data.Level += 1;
                            player.inventory.Take(null, ItemManager.FindItemDefinition(config.skill.ShortName).itemid, check.Price);
                            SkillUI(player);
                            AlertUI(player, check.DisplayName);
                        }
                        else
                        {
                            SendReply(player, "Вы полностью изучили навык!");
                        }
                    }
                }
                if (args.Args[0] == "give")
                {
                    if (player != null && !player.IsAdmin) return;
                    if (args.Args == null || args.Args.Length < 2)
                    {
                        player.ConsoleMessage("Команда: skill give SteamID количество листков");
                        return;
                    }
                    BasePlayer target = BasePlayer.Find(args.Args[1]);
                    if (target == null)
                    {
                        player.ConsoleMessage($"Игрок {target} не найден");
                        return;
                    }
                    int change;
                    if (!int.TryParse(args.Args[2], out change))
                    {
                        player.ConsoleMessage("Вы не указали кол-во");
                        return;
                    }

                    player.ConsoleMessage($"Игроку {target}, были успешно выданы листки с информацией.\nВ размере: {change}");
                    Item item = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(config.skill.ShortName).itemid, change, config.skill.SkinID);
                    item.name = config.skill.DisplayName;
                    player.inventory.GiveItem(item);
                }
            }
        }
        #endregion

        #region Хуки
        private void Loaded()
        {
            settingsData = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, Dictionary<string, SettingsData>>>("SkillSystem/Player");
        }
        
        private SettingsData AddPlayersData(ulong userID, string name)
        {
            if (!settingsData.ContainsKey(userID)) settingsData[userID] = new Dictionary<string, SettingsData>();

            if (!settingsData[userID].ContainsKey(name)) settingsData[userID][name] = new SettingsData();

            return settingsData[userID][name];
        }
        
        private void OnServerInitialized()
        {
            PrintWarning("\n-----------------------------\n" +
            "     Author - https://topplugin.ru/\n" +
            "     VK - https://vk.com/rustnastroika\n" +
            "     Discord - https://discord.com/invite/5DPTsRmd3G\n" +
            "-----------------------------");
            foreach (var check in config.settings)
            {
                ImageLibrary.Call("AddImage", check.Url, check.Url);
            }
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, Layer);
            }
            SaveData();
        }
        
        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            SaveData();
        }
        
        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("SkillSystem/Player", settingsData);
        }
        
        private void OnDispenserGather(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            var playerData = AddPlayersData(player.userID, item.info.shortname);
            item.amount = (int) (item.amount * playerData.Rate);
        }
        
        private void OnDispenserBonus(ResourceDispenser disp, BasePlayer player, Item item)
        {
            var playerData = AddPlayersData(player.userID, item.info.shortname);
            item.amount = (int) (item.amount * playerData.Rate);
        }

        private void OnLootEntity(BasePlayer player, BaseEntity entity, Item item)
        {
            if (!(entity is LootContainer) || entity.OwnerID != 0)
                return;
            foreach (var check in ((LootContainer) entity).inventory.itemList.Where(p => p.MaxStackable() > 1 && !p.IsBlueprint()))
            {
                var playerData = AddPlayersData(player.userID, "Поиск");
                check.amount = (int) (check.amount * playerData.Rate);
            }
            entity.OwnerID = player.userID;
        }

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (!(info?.Initiator is BasePlayer) || !(entity is LootContainer)) return;
            var inventory = entity.GetComponent<LootContainer>().inventory;
            foreach (var check in inventory.itemList.Where(p => p.MaxStackable() > 1 && !p.IsBlueprint()))
            {
                var playerData = AddPlayersData(info.InitiatorPlayer.userID, "Поиск");
                check.amount = (int) (check.amount * playerData.Rate);
            }
        }
        
        int GetList(BasePlayer player, string type)
        {
            int amount = 0;
            foreach (var item in player.inventory.FindItemIDs(ItemManager.FindItemDefinition(config.skill.ShortName).itemid))
            {
                if (type == "skill")
                {
                    if (item.info.itemid == ItemManager.FindItemDefinition(config.skill.ShortName).itemid)
                    {
                        amount += item.amount;
                    }
                }
            }
            return amount;
        }

        #region Спавн листочков
        private void OnLootSpawn(LootContainer lootContainer)
        {
            if (lootContainer == null) return;
            if (lootContainer.inventory == null) return;
            if (config.container.Contains(lootContainer.ShortPrefabName))
            {
                if (UnityEngine.Random.Range(0, 100) <= config.skill.DropChance)
                {
                    Item add = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(config.skill.ShortName).itemid, 1, config.skill.SkinID);
                    add.name = config.skill.DisplayName;
                    add.MoveToContainer(lootContainer.inventory);
                }
            }
        }

        object OnItemSplit(Item thisI, int split_Amount)
        {
            Item item = null;
            if (thisI.skin == 0uL) return null;
            if (thisI.skin == config.skill.SkinID)
            {
                thisI.amount -= split_Amount; item = ItemManager.CreateByItemID(thisI.info.itemid, split_Amount, thisI.skin);
                if (item != null)
                {
                    item.amount = split_Amount;
                    item.name = thisI.name;
                    item.OnVirginSpawn();
                    if (thisI.IsBlueprint()) item.blueprintTarget = thisI.blueprintTarget;
                    if (thisI.hasCondition) item.condition = thisI.condition;
                    item.MarkDirty();
                    return item;
                }
            }
            return null;
        }

        object CanStackItem(Item item, Item targetItem)
        {
            if (item.info.itemid == ItemManager.FindItemDefinition(config.skill.ShortName).itemid && targetItem.info.itemid == ItemManager.FindItemDefinition(config.skill.ShortName).itemid) if (item.skin == config.skill.SkinID || targetItem.skin == config.skill.SkinID) if (targetItem.skin != item.skin) return false;
            return null;
        }
        #endregion

        #endregion

        #region Интерфейс
        private void SkillUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, Layer);
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.276 0", AnchorMax = "0.945 1", OffsetMax = "0 0" },
                Image = { Color = "0.117 0.121 0.109 0.95" },
            }, "Menu_UI", Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0.76", AnchorMax = "1 0.855", OffsetMax = "0 0" },
                Button = { Color = "1 1 1 0" },
                Text = { Text = $"<b><size=30>ПРОКАЧКА НАВЫКОВ</size></b>\nЛистков с информацией - {GetList(player, "skill").ToString()}", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "robotocondensed-regular.ttf" }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0.05", AnchorMax = "1 0.25", OffsetMax = "0 0" },
                Button = { Color = "1 1 1 0" },
                Text = { Text = $"<b><size=30>ИНФОРМАЦИЯ</size></b>\nКаждый навык прибавляет рейт к добычи ресурса, ресурс который изображен на картинке!\nЗа одно изучение вы получаеье x0.1\nМаксимально можно увеличить добычу на x1.", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 12, Font = "robotocondensed-regular.ttf" }
            }, Layer);

            float gap = 0.01f, width = 0.165f, height = 0.23f, startxBox = 0.15f, startyBox = 0.73f - height, xmin = startxBox, ymin = startyBox;
            for (int z = 0; z < config.settings.Count(); z++)
            {
                container.Add(new CuiButton()
                {
                    RectTransform = { AnchorMin = xmin + " " + ymin, AnchorMax = (xmin + width) + " " + (ymin + height * 1), OffsetMax = "0 0" },
                    Button = { Color = "1 1 1 0" },
                    Text = { Text = "" }
                }, Layer, $"{z}");
                xmin += width + gap;
                if (xmin + width >= 1)
                {
                    xmin = startxBox + 0.175f;
                    ymin -= height + gap;
                }

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.1 0.49", AnchorMax = "0.9 1", OffsetMax = "0 0" },
                    Button = { Color = "1 1 1 0" },
                    Text = { Text = "" }
                }, $"{z}", "Images");

                container.Add(new CuiElement
                {
                    Parent = "Images",
                    Components =
                        {
                            new CuiRawImageComponent {Png = (string) ImageLibrary.Call("GetImage", config.settings.ElementAt(z).Url), Color = "1 1 1 0.5"},
                            new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "15 0", OffsetMax = "-15 0"}
                        }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0.365", AnchorMax = "1 0.475", OffsetMax = "0 0" },
                    Button = { Color = "1 1 1 0" },
                    Text = { Text = $"{config.settings.ElementAt(z).DisplayName.ToUpper()}", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf" }
                }, $"{z}");
                foreach (var check in config.settings.ElementAt(z).ShortName)
                {
                    var data = AddPlayersData(player.userID, check.Key);
                    var text = config.settings.ElementAt(z).LevelMax <= data.Level ? "ИЗУЧЕНО" : $"ИЗУЧИТЬ";

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0.025 0.3", AnchorMax = "0.975 0.34", OffsetMax = "0 0" },
                        Button = { Color = "1 1 1 0.1" },
                        Text = { Text = "", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 12, Font = "robotocondensed-bold.ttf" }
                    }, $"{z}", "Progress");

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = $"{(float)data.Level / config.settings.ElementAt(z).LevelMax} 1", OffsetMax = "0 0" },
                        Button = { Color = "0.43 0.81 0.53 0.6" },
                        Text = { Text = "" }
                    }, "Progress");

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0.025 0.175", AnchorMax = "0.975 0.275", OffsetMax = "0 0" },
                        Button = { Color = "1 1 1 0" },
                        Text = { Text = $"Цена: {config.settings.ElementAt(z).Price}", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 12, Font = "robotocondensed-regular.ttf" }
                    }, $"{z}");

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0.025 0.02", AnchorMax = "0.975 0.155", OffsetMax = "0 0" },
                        Button = { Color = "1 1 1 0.1", Command = $"skill buy {z}" },
                        Text = { Text = text, Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 12, Font = "robotocondensed-bold.ttf" }
                    }, $"{z}");
                }
            }

            CuiHelper.AddUi(player, container);
        }

        private void AlertUI(BasePlayer player, string DisplayName)
        {
            CuiHelper.DestroyUi(player, LayersAlert);
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-400 180", OffsetMax = "400 280" },
                Image = { Color = "0 0 0 0" },
            }, "Hud", LayersAlert);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0" },
                Text = { Text = $"<color=#FFFFFF9A><size=20><b>НАВЫКИ</b></size>\nВы изучили навык: <b>{DisplayName.ToUpper()}</b></color>\nОткрыть меню <b>скилов</b> можно прописав команду <b>/skill</b>", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-regular.ttf" }
            }, LayersAlert);

            CuiHelper.AddUi(player, container);
            timer.Once(10, () => { CuiHelper.DestroyUi(player, LayersAlert); });
        }
        #endregion
    }
}

// --- End of file: SkillSystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/Trade.cs ---
// --- Original Local Path: KualaRust/Trade.cs ---

using Network;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using System;
using System.Linq;
using System.Collections.Generic;
using UnityEngine;
namespace Oxide.Plugins
{
    [Info("Trade", "OxideBro", "2.1.1")]
    public class Trade : RustPlugin
    {
        private static Trade ins;
        private PluginConfig config;
        public List<TradeBox> tradeBoxes = new List<TradeBox>();
        private List<TradePendings> pendings = new List<TradePendings>();
        private Dictionary<BasePlayer, DateTime> Cooldowns = new Dictionary<BasePlayer, DateTime>();

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Благодарим за покупку плагина на сайте RustPlugin.ru. Если вы передадите этот плагин сторонним лицам знайте - это лишает вас гарантированных обновлений!");
            config = PluginConfig.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
            if (config.PluginVersion < Version)
                UpdateConfigValues();
            Config.WriteObject(config, true);
        }

        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (config.PluginVersion < new VersionNumber(2, 2, 1))
            {
                PrintWarning("Config update detected! Updating config values...");
                config.mainSettings.permsNum = new Dictionary<string, int>()
                {
                    ["trade.slost1"] = 5,
                    ["trade.slost2"] = 6,
                    ["trade.slost3"] = 7,
                };
                PrintWarning("Config update completed!");
            }
            config.PluginVersion = Version;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        public class MainSettings
        {
            [JsonProperty("Запретить принимать запрос в BuildingBlock")]
            public bool getCupAuth = true;

            [JsonProperty("Запретить отправлять запрос в BuildingBlock")]
            public bool getCupSend = true;

            [JsonProperty("Запретить использовать трейд в полёте")]
            public bool getFly = true;

            [JsonProperty("Запретить использовать трейд в воде")]
            public bool getSwim = true;

            [JsonProperty("Запретить обмениватся игрокам если игроки не в тиме (Стандартная система друзей)")]
            public bool enabledTeamate = false;

            [JsonProperty("Запретить использовать трейд в предсмертном состоянии")]
            public bool getWound = true;

            [JsonProperty("Время ответа на предложения обмена (секунд)")]
            public int getTime = 15;

            [JsonProperty("Задержка использования трейда (Cooldown - секунд)")]
            public double CooldownTrade = 60.0;

            [JsonProperty("Разрешить трейд если между игроками если их дистанция больше указанной (-1 - отключение)")]
            public double TradeDistance = 50;

            [JsonProperty("Количество активных слотов при обмене")]
            public int getInt = 8;

            [JsonProperty("Список привилегий и размера слотов при обмене")]
            public Dictionary<string, int> permsNum = new Dictionary<string, int>();

            [JsonProperty("Привилегия на использование команды trade")]
            public string Permission = "trade.use";

            [JsonProperty("Разрешить использование трейда только если игрок имеет привилегию указаную в конфиге")]
            public bool UsePermission = false;
        }

        class PluginConfig
        {
            [JsonProperty("Основные")]
            public MainSettings mainSettings;

            [JsonProperty("Версия конфигурации")]
            public VersionNumber PluginVersion = new VersionNumber();


            [JsonIgnore]
            [JsonProperty("Инициализация плагина⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠")]
            public bool Init;

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    mainSettings = new MainSettings()
                    {
                        permsNum = new Dictionary<string, int>()
                        {
                            ["trade.slost1"] = 5,
                            ["trade.slost2"] = 6,
                            ["trade.slost3"] = 7,
                        }
                    },
                    PluginVersion = new VersionNumber(),

                };
            }
        }

        [PluginReference] Plugin Duel;
        private bool IsDuelPlayer(BasePlayer player)
        {
            if (!Duel) return false;
            var dueler = Duel?.Call("IsPlayerOnActiveDuel", player);
            if (dueler is bool) return (bool)dueler;
            return false;
        }

        private bool IsTeamate(BasePlayer player, BasePlayer target)
        {
            if (!config.mainSettings.enabledTeamate) return true;
            if (player.currentTeam == 0 || target.currentTeam == 0) return false;
            return player.currentTeam == target.currentTeam;
        }

        int GetTradeSize(string UserID)
        {
            int size = config.mainSettings.getInt;
            foreach (var num in config.mainSettings.permsNum)
            {
                if (permission.UserHasPermission(UserID, num.Key))
                    if (num.Value > size) size = num.Value;
            }
            return size;
        }

        void Reply(BasePlayer player, string langKey, params object[] args) => SendReply(player, Messages[langKey], args);

        bool CanPlayerTrade(BasePlayer player)
        {
            var reply = 521;
            if (reply == 0) { }
            if (!config.Init) return false;
            if (config.mainSettings.getSwim)
            {
                if (player.IsSwimming())
                {
                    Reply(player, "DENIED.SWIMMING");
                    return false;
                }
            }
            if (config.mainSettings.getCupSend || config.mainSettings.getCupAuth)
            {
                if (!player.CanBuild())
                {
                    Reply(player, "DENIED.PRIVILEGE");
                    return false;
                }
            }
            if (config.mainSettings.getFly)
            {
                if (!player.IsOnGround() || player.IsFlying)
                {
                    Reply(player, "DENIED.FALLING");
                    return false;
                }
            }
            if (config.mainSettings.getWound)
            {
                if (player.IsWounded())
                {
                    Reply(player, "DENIED.WOUNDED");
                    return false;
                }
            }
            if (Cooldowns.ContainsKey(player))
            {
                double seconds = Cooldowns[player].Subtract(DateTime.Now).TotalSeconds;
                if (seconds >= 0)
                {
                    Reply(player, "COOLDOWN", seconds);
                    return false;
                }
            }
            if (IsDuelPlayer(player))
            {
                Reply(player, "DENIED.DUEL");
                return false;
            }
            var canTrade = Interface.Call("CanTrade", player);
            if (canTrade != null)
            {
                if (canTrade is string)
                {
                    SendReply(player, Convert.ToString(canTrade));
                    return false;
                }
                Reply(player, "DENIED.GENERIC");
                return false;
            }
            return true;
        }

        Dictionary<string, string> Messages = new Dictionary<string, string>() {
                {
                "DENIED.SWIMMING", "Недоступно, вы плаваете!"
            }
            , {
                "DENIED.DUEL", "Недоступно, один из игроков на Duel!"
            }
            , {
                "DENIED.PERMISSIONON", "Недоступно, у Вас нету прав на использование трейда!"
            }
            , {
                "DENIED.PERMISSIOONTARGETN", "Недоступно, у {0} прав на использование трейда!"
            }
            , {
                "DENIED.FALLING", "Недоступно, вы левитируете!"
            }
            , {
                "DENIED.WOUNDED", "Недоступно, вы в предсмертном состоянии!"
            }
            , {
                "DENIED.GENERIC", "Недоступно, заблокировано другим плагином!"
            }
            , {
                "DENIED.PRIVILEGE", "Недоступно, вы в зоне Building Blocked!"
            }
            , {
                "DENIED.PERMISSION", "Недоступно, вы в зоне Building Blocked!"
            }
            , {
                "TRADE.HELP", "Trade by RustPlugin.ru\nИспользуйте комманду <color=orange>/trade \"НИК\"</color> для обмена\nЧто бы принять обмен, введите: <color=orange>/trade yes</color> (или /trade accept)\nЧто бы отказаться от обмена введите: <color=orange>/trade no </color> (или /trade cancel)"
            }
            , {
                "PLAYER.NOT.FOUND", "Игрок '{0}' не найден!"
            }
             , {
                "TRADE.ALREADY.PENDING", "Невозможно! Вы либо вам уже отправлено предложение обмена!"
            }
            , {
                "TRADE.TARGET.ALREADY.PENDING", "Невозможно! У игрока есть активное предложение обмена!"
            }

            , {
                "TRADE.ACCEPT.PENDING.EMPTY", "У вас нет входящих предложний обмена!"
            }
            , {
                "TRADE.CANCELED", "Trade отменен!"
            }
            , {
                "TRADE.TOYOU", "Нельзя отправлять запрос самому себе!"
            }
            , {
                "TRADE.SUCCESS", "Trade успешно завершён!"
            }
            , {
                "PENDING.RECIEVER.FORMAT", "Игрок '{0}' отправил вам предложние обмена\nДля принятия обмена используйте команду <color=orange>/trade yes</color>\nЧто бы отказаться введите <color=orange>/trade no</color>"
            }
            , {
                "PENDING.SENDER.FORMAT", "Предложение обмена игроку '{0}' успешно отправлено, ожидайте..."
            }
            , {
                "PENDING.TIMEOUT.SENDER", "Trade отменён! Причина: время истекло."
            }
            , {
                "PENDING.TIMEOUT.RECIEVER", "Trade отменён! Причина: вы вовремя не приняли запрос."
            }
            , {
                "PENDING.CANCEL.SENDER", "Trade отменён! Причина: игрок '{0}' отказался"
            },
            {
                "COOLDOWN", "Вы только недавно обменивались, подождите - {0:0} сек."
            },
            {
                "GET.FRIENDS", "Вы не состоите в одной тиме с игроком {0}, трейд запрещен"
            },
            {
                "GET.DISTANCE", "Трейд запрещен на малых дистанциях между вами игроком"
            },
        };


        private void Loaded()
        {
            ins = this;
            lang.RegisterMessages(Messages, this);
            Messages = lang.GetMessages("en", this);
            permission.RegisterPermission(config.mainSettings.Permission, this);
            var perms = config.mainSettings.permsNum.Where(p => p.Key.StartsWith("trade."));
            foreach (var perm in perms)
            {
                if (!permission.PermissionExists(perm.Key))
                    permission.RegisterPermission(perm.Key, this);

            }
            if (!permission.PermissionExists(config.mainSettings.Permission))
                permission.RegisterPermission(config.mainSettings.Permission, this);
            config.Init = true;
        }

        void OnServerInitialized()
        {
            timer.Every(1f, TradeTimerHandle);
        }

        class TradePendings
        {
            public BasePlayer target;
            public BasePlayer player;
            public int seconds;

            public TradePendings(BasePlayer player, int Seconds, BasePlayer target)
            {
                this.target = target;
                this.player = player;
                seconds = Seconds;

            }
        }

        void TradeTimerHandle()
        {
            for (int i = pendings.Count - 1;
           i >= 0;
           i--)
            {
                var pend = pendings[i];
                if (pend.target != null && !pend.target.IsConnected || pend.target.IsWounded())
                {
                    pendings.RemoveAt(i);
                    continue;
                }
                if (pend.player != null && !pend.player.IsConnected || pend.player.IsWounded())
                {
                    pendings.RemoveAt(i);
                    continue;
                }
                if (--pend.seconds <= 0)
                {
                    pendings.RemoveAt(i);
                    if (pend.player.IsConnected) Reply(pend.player, "PENDING.TIMEOUT.SENDER");
                    if (pend.target.IsConnected) Reply(pend.target, "PENDING.TIMEOUT.RECIEVER");
                }
            }
        }

        void Unload()
        {
            foreach (var trade in tradeBoxes)
            {
                UnityEngine.Object.Destroy(trade);
            }
        }

        private void OnItemSplit(Item item, int amount)
        {
            if (!config.Init) return;
            if (item == null) return;
            if (item.GetRootContainer() == null || item.GetRootContainer()?.entityOwner == null || item.GetRootContainer()?.entityOwner?.GetComponent<ShopFront>() == null) return;
            var container = item.GetRootContainer().entityOwner?.GetComponent<ShopFront>();
            if (container != null)
                if (container.GetComponent<TradeBox>() != null)
                {
                    if (container.vendorInventory != null && container.customerInventory != null)
                        if (container.vendorInventory.IsLocked() || container.customerInventory.IsLocked())
                            container.ResetTrade();
                }
        }

        object CanMoveItem(Item item, PlayerInventory playerLoot, uint targetContainer)
        {
            if (!config.Init) return null;
            if (playerLoot == null) return null;
            var container = playerLoot.FindContainer(targetContainer);
            if (container == null) return null;
            var player = playerLoot.containerMain.playerOwner;
            if (player == null) return null;
            if (container.entityOwner != null && container.entityOwner is ShopFront)
            {
                var shopfront = container.entityOwner.GetComponent<ShopFront>();
                if (shopfront != null)
                {
                    if (item.contents != null)
                    {
                        item.contents.SetLocked(true);
                        item.MarkDirty();
                    }
                    if (shopfront.IsPlayerCustomer(player) && shopfront.customerInventory.uid != targetContainer)
                        return false;
                    else if (shopfront.IsPlayerVendor(player) && shopfront.vendorInventory.uid != targetContainer) return false;
                }
            }
            else
            {
                if (item.contents != null && item.contents.IsLocked())
                {
                    item.contents.SetLocked(false);
                    item.MarkDirty();
                }
            }
            return null;
        }

        void OnEntityKill(ShopFront shop)
        {
            if (shop == null) return;
            if (shop.GetComponent<TradeBox>() != null)
            {
                if (shop.GetComponent<TradeBox>().player1 != null)
                    shop.GetComponent<TradeBox>().player1.EndLooting();
                if (shop.GetComponent<TradeBox>().player2 != null)
                    shop.GetComponent<TradeBox>().player2.EndLooting();
            }
        }

        object OnEntityVisibilityCheck(ShopFront shop, BasePlayer player, uint rpcId, string debugName, float maximumDistance)
        {
            if (!config.Init) return null;
            if (shop == null || shop?.net.ID == null || player == null) return null;
            if (shop.GetComponent<TradeBox>() != null)
            {
                if (shop.IsPlayerVendor(player))
                {
                    shop.SetFlag(global::BaseEntity.Flags.Reserved1, true, false, true);
                    shop.vendorInventory.SetLocked(true);
                }
                else if (shop.IsPlayerCustomer(player))
                {
                    shop.SetFlag(global::BaseEntity.Flags.Reserved2, true, false, true);
                    shop.customerInventory.SetLocked(true);
                }
                if (shop.HasFlag(global::BaseEntity.Flags.Reserved1) && shop.HasFlag(global::BaseEntity.Flags.Reserved2))
                {
                    shop.SetFlag(global::BaseEntity.Flags.Reserved3, true, false, true);
                    shop.Invoke(new Action(shop.GetComponent<TradeBox>().CustomCompleteTrade), 2f);
                    return false;
                }
                return true;
            }
            return null;
        }

        public BasePlayer FindOnline(string nameOrUserId, ulong playerid = 533504)
        {
            nameOrUserId = nameOrUserId.ToLower();
            foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
            {
                if (activePlayer.displayName.ToLower().Contains(nameOrUserId) || activePlayer.UserIDString == nameOrUserId) return activePlayer;
            }
            return null;
        }

        [ConsoleCommand("trade")]
        void cmdTrade(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null || arg.Args.Length == 0) return;
            var name = arg.Args[0];
            CmdChatTrade(player, string.Empty, new string[] {
                name
            }
            );
        }

        [ChatCommand("trade")]
        void CmdChatTrade(BasePlayer player, string command, string[] args)
        {
            if (!config.Init) return;
            if (player == null) return;
            if (args.Length == 0 || args == null)
            {
                Reply(player, "TRADE.HELP");
                return;
            }
            if (config.mainSettings.UsePermission && !permission.UserHasPermission(player.UserIDString, config.mainSettings.Permission))
            {
                Reply(player, "DENIED.PERMISSIONON");
                return;
            }
            if (Cooldowns.ContainsKey(player))
            {
                double seconds = Cooldowns[player].Subtract(DateTime.Now).TotalSeconds;
                if (seconds >= 0)
                {
                    Reply(player, "COOLDOWN", seconds);
                    return;
                }
            }
            switch (args[0])
            {
                default:
                    if (!CanPlayerTrade(player))
                        return;
                    var name = args[0];
                    var target = FindOnline(name);
                    if (target == null)
                    {
                        Reply(player, "PLAYER.NOT.FOUND", name);
                        return;
                    }
                    if (target == player)
                    {
                        Reply(player, "TRADE.TOYOU");
                        return;
                    }
                    if (!IsTeamate(player, target))
                    {
                        Reply(player, "GET.FRIENDS", target.displayName);
                        return;
                    }
                    if (Vector3.Distance(player.transform.position, target.transform.position) < config.mainSettings.TradeDistance)
                    {
                        Reply(player, "GET.DISTANCE", target.displayName);
                        return;
                    }


                    var tradeTargetpend = pendings.Find(p => p.player == target || p.target == target);
                    if (tradeTargetpend != null)
                    {
                        Reply(player, "TRADE.TARGET.ALREADY.PENDING");
                        return;
                    }
                    if (config.mainSettings.UsePermission && !permission.UserHasPermission(target.UserIDString, config.mainSettings.Permission))
                    {
                        Reply(player, "DENIED.PERMISSIOONTARGETN", target.displayName);
                        return;
                    }
                    if (config.mainSettings.getCupSend)
                    {
                        if (!player.CanBuild())
                        {
                            Reply(player, "DENIED.PRIVILEGE");
                            return;
                        }
                    }

                    var tradepend = pendings.Find(p => p.player == player || p.target == player);
                    if (tradepend != null)
                    {
                        Reply(player, "TRADE.ALREADY.PENDING");
                        return;
                    }
                    pendings.Add(new TradePendings(player, config.mainSettings.getTime, target));
                    Reply(player, "PENDING.SENDER.FORMAT", target.displayName);
                    Reply(target, "PENDING.RECIEVER.FORMAT", player.displayName);
                    break;
                case "accept":
                case "yes":
                    if (!CanPlayerTrade(player)) return;
                    var tp = pendings.Find(p => p.player == player || p.target == player);
                    if (tp == null)
                    {
                        Reply(player, "TRADE.ACCEPT.PENDING.EMPTY");
                        return;
                    }
                    if (IsDuelPlayer(tp.target) || IsDuelPlayer(tp.player))
                    {
                        pendings.Remove(tp);
                        Reply(tp.player, "DENIED.DUEL");
                        Reply(tp.target, "DENIED.DUEL");
                        return;
                    }
                    pendings.Remove(tp);
                    TradeBox trade = TradeBox.Spawn();
                    if (trade == null) return;

                    tradeBoxes.Add(trade);
                    timer.Once(0.5f, () =>
                    {
                        if (tp.player == null || !tp.player.IsConnected) return;
                        if (tp.target == null || !tp.target.IsConnected) return;
                        trade.StartLoot(tp.player, tp.target);
                    });
                    break;
                case "cancel":
                case "no":
                    var pend = pendings.Find(p => p.player == player || p.target == player);
                    if (pend == null)
                    {
                        Reply(player, "TRADE.ACCEPT.PENDING.EMPTY");
                        return;
                    }
                    pendings.Remove(pend);

                    if (pend.player.IsConnected) Reply(pend.player, "PENDING.CANCEL.SENDER", player.displayName);
                    Reply(pend.target, "TRADE.CANCELED");
                    break;
            }
        }

        public class TradeBox : MonoBehaviour
        {
            public ShopFront shopFront;
            public BasePlayer player1, player2;

            void Awake()
            {
                shopFront = gameObject.GetComponent<ShopFront>();
                enabled = false;
            }

            public static TradeBox Spawn()
            {
                var storage = SpawnContainer(new Vector3());
                var box = storage.gameObject.AddComponent<TradeBox>();
                return box;
            }

            private static ShopFront SpawnContainer(Vector3 position)
            {
                ShopFront shopFront = GameManager.server.CreateEntity("assets/prefabs/building/wall.frame.shopfront/wall.frame.shopfront.metal.prefab", position, new Quaternion(), true) as ShopFront;
                if (shopFront == null) return null;
                shopFront.Spawn();
                shopFront.vendorInventory.capacity = 1;
                shopFront.customerInventory.capacity = 1;
                UnityEngine.Object.Destroy(shopFront.GetComponent<DestroyOnGroundMissing>());
                UnityEngine.Object.Destroy(shopFront.GetComponent<GroundWatch>());
                return shopFront;
            }

            public void StartLoot(BasePlayer player, BasePlayer target)
            {
                if (player == null || target == null)
                {
                    Destroy(this);
                    return;
                }
                player1 = player;
                player2 = target;
                shopFront.vendorInventory.capacity = ins.GetTradeSize(player.UserIDString);
                shopFront.customerInventory.capacity = ins.GetTradeSize(target.UserIDString);
                player.EndLooting();
                target.EndLooting();
                shopFront.vendorPlayer = player1;
                shopFront.customerPlayer = player2;
                if (!player1.net.subscriber.IsSubscribed(shopFront.net.group))
                    player1.net.subscriber.Subscribe(shopFront.net.group);
                if (!player2.net.subscriber.IsSubscribed(shopFront.net.group))
                    player2.net.subscriber.Subscribe(shopFront.net.group);
                SendEntity(player1, (BaseEntity)shopFront);
                SendEntity(player2, (BaseEntity)shopFront);
                SendEntity(player1, (BaseEntity)player2);
                SendEntity(player2, (BaseEntity)player1);
                StartLooting(player1);
                StartLooting(player2);
                shopFront.ResetTrade();
                shopFront.UpdatePlayers();
                enabled = true;

            }

            public void SendEntity(BasePlayer a, BaseEntity b, string reason = "⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠")
            {
                if (Net.sv.write.Start())
                {
                    a.net.connection.validate.entityUpdates++;
                    BaseNetworkable.SaveInfo c = new BaseNetworkable.SaveInfo
                    {
                        forConnection = a.net.connection,
                        forDisk = false
                    }
                    ;
                    Net.sv.write.PacketID(Message.Type.Entities);
                    Net.sv.write.UInt32(a.net.connection.validate.entityUpdates);
                    b.ToStreamForNetwork(Net.sv.write, c);
                    Net.sv.write.Send(new SendInfo(a.net.connection));
                }
            }

            public void StartLooting(BasePlayer player)
            {
                player.inventory.loot.StartLootingEntity(shopFront, false);
                player.inventory.loot.AddContainer(shopFront.vendorInventory);
                player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", shopFront.panelName);
                shopFront.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                player.inventory.loot.AddContainer(shopFront.customerInventory);
                player.inventory.loot.SendImmediate();
            }

            public void PlayerStoppedLooting(BasePlayer player) => Destroy(this);

            public void OnDestroy()
            {
                if (player1 != null)
                    player1.EndLooting();
                if (player2 != null)
                    player2.EndLooting();
                if (shopFront != null && !shopFront.IsDestroyed)
                    shopFront.Kill();
            }

            void FixedUpdate()
            {
                if (!player1.net.subscriber.IsSubscribed(shopFront.net.group))
                {
                    SendEntity(player1, shopFront);
                    SendEntity(player1, player2);
                    player1.net.subscriber.Subscribe(shopFront.net.group);
                    shopFront.UpdatePlayers();
                }
                if (!player2.net.subscriber.IsSubscribed(shopFront.net.group))
                {
                    SendEntity(player2, shopFront);
                    SendEntity(player2, player1);
                    player2.net.subscriber.Subscribe(shopFront.net.group);
                    shopFront.UpdatePlayers();
                }
            }


            public void CustomCompleteTrade()
            {
                if (shopFront.vendorPlayer != null && shopFront.customerPlayer != null && shopFront.HasFlag(global::BaseEntity.Flags.Reserved1) && shopFront.HasFlag(global::BaseEntity.Flags.Reserved2))
                {
                    for (int i = shopFront.vendorInventory.capacity - 1; i >= 0; i--)
                    {
                        Item slot = shopFront.vendorInventory.GetSlot(i);
                        Item slot2 = shopFront.customerInventory.GetSlot(i);
                        if (shopFront.customerPlayer && slot != null)
                        {
                            player2.GiveItem(slot, global::BaseEntity.GiveItemReason.Generic);
                        }
                        if (shopFront.vendorPlayer && slot2 != null)
                        {
                            player1.GiveItem(slot2, global::BaseEntity.GiveItemReason.Generic);
                        }
                    }
                    global::Effect.server.Run(shopFront.transactionCompleteEffect.resourcePath, player1, 0u, new Vector3(0f, 1f, 0f), Vector3.zero, null, false);
                    global::Effect.server.Run(shopFront.transactionCompleteEffect.resourcePath, player2, 0u, new Vector3(0f, 1f, 0f), Vector3.zero, null, false);
                    ins.Reply(player1, "TRADE.SUCCESS");
                    ins.Reply(player2, "TRADE.SUCCESS");
                    ins.Cooldowns[player1] = DateTime.Now.AddSeconds(ins.config.mainSettings.CooldownTrade);
                    ins.Cooldowns[player2] = DateTime.Now.AddSeconds(ins.config.mainSettings.CooldownTrade);
                    ins.tradeBoxes.Remove(this);
                    Destroy(this);
                }
            }
        }

        bool PlayerGetActiveTrade(BasePlayer player)
        {
            var contains = pendings.Find(p => p.target == player);
            return contains != null;
        }
    }
}

// --- End of file: Trade.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/BlueprintManager.cs ---
// --- Original Local Path: KualaRust/BlueprintManager.cs ---

using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Blueprint Manager", "Orange", "1.1.4")]
    [Description("Manage blueprints on your server easily")]
    public class BlueprintManager : RustPlugin
    {
        #region Vars
        
        private Blueprints data = new Blueprints();
        private const string permLVL1 = "blueprintmanager.lvl1";
        private const string permLVL2 = "blueprintmanager.lvl2";
        private const string permLVL3 = "blueprintmanager.lvl3";
        private const string permAll = "blueprintmanager.all";
        private const string permDefault = "blueprintmanager.default";
        private const string permAdmin = "blueprintmanager.admin";
        
        private class Blueprints
        {
            public List<int> workbench1 = new List<int>();
            public List<int> workbench2 = new List<int>();
            public List<int> workbench3 = new List<int>();
            public List<int> allBlueprints = new List<int>();
            public List<int> defaultBlueprints = new List<int>();
        }
        
        #endregion

        #region Oxide Hooks

        private void Init()
        {
            permission.RegisterPermission(permAll, this);
            permission.RegisterPermission(permLVL1, this);
            permission.RegisterPermission(permLVL2, this);
            permission.RegisterPermission(permLVL3, this);
            permission.RegisterPermission(permAdmin, this);
            permission.RegisterPermission(permDefault, this);
            cmd.AddConsoleCommand("blueprintmanager", this, nameof(cmdBlueprintsConsole));
        }

        private void OnServerInitialized()
        {
            CheckBlueprints();
            CheckPlayers();
        }
        
        private void OnPlayerConnected(BasePlayer player)
        {
            CheckPlayer(player);
        }

        #endregion

        #region Core
        
        private void CheckBlueprints()
        {
            foreach (var bp in ItemManager.bpList)
            {
                if (bp.userCraftable && bp.defaultBlueprint == false)
                {
                    var itemID = bp.targetItem.itemid;
                    var shortname = bp.targetItem.shortname;
                    if (config.blacklist?.Contains(shortname) ?? false)
                    {
                        continue;
                    }

                    switch (bp.workbenchLevelRequired)
                    {
                        case 1:
                            data.workbench1.Add(itemID);
                            break;
                        
                        case 2:
                            data.workbench2.Add(itemID);
                            break;
                        
                        case 3:
                            data.workbench3.Add(itemID);
                            break;
                    }

                    if (config.defaultBlueprints?.Contains(shortname) ?? false)
                    {
                        data.defaultBlueprints.Add(itemID);
                    }
                    
                    data.allBlueprints.Add(itemID);
                }
            }
        }

        private void CheckPlayers()
        {
            timer.Once(5f, () =>
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    OnPlayerConnected(player);
                }
            });
        }

        private void CheckPlayer(BasePlayer player)
        {
            var blueprints = GetBlueprints(player);
            UnlockBlueprints(player, blueprints);
        }

        private List<int> GetBlueprints(BasePlayer player)
        {
            var list = new List<int>();

            if (permission.UserHasPermission(player.UserIDString, permDefault))
            {
                list.AddRange(data.defaultBlueprints);
            }

            if (permission.UserHasPermission(player.UserIDString, permAll))
            {
                list.AddRange(data.allBlueprints);
                return list;
            }
            
            if (permission.UserHasPermission(player.UserIDString, permLVL3))
            {
                list.AddRange(data.workbench3);
            }
            
            if (permission.UserHasPermission(player.UserIDString, permLVL2))
            {
                list.AddRange(data.workbench2);
            }
            
            if (permission.UserHasPermission(player.UserIDString, permLVL1))
            {
                list.AddRange(data.workbench1);
            }

            return list;
        }

        private void UnlockBlueprints(BasePlayer player, List<int> blueprints)
        {
            var playerInfo = SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerInfo(player.userID);
            
            foreach (var blueprint in blueprints)
            {
                if (playerInfo.unlockedItems.Contains(blueprint) == false)
                {
                    playerInfo.unlockedItems.Add(blueprint);
                }
            }
            
            SingletonComponent<ServerMgr>.Instance.persistance.SetPlayerInfo(player.userID, playerInfo);
            player.SendNetworkUpdateImmediate();
            player.ClientRPCPlayer(null, player, "UnlockedBlueprint", 0);
        }

        private void ResetBlueprints(BasePlayer player)
        {
            var playerInfo = SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerInfo(player.userID);
            playerInfo.unlockedItems = new List<int>();
            SingletonComponent<ServerMgr>.Instance.persistance.SetPlayerInfo(player.userID, playerInfo);
            player.SendNetworkUpdateImmediate();
            player.ClientRPCPlayer(null, player, "UnlockedBlueprint", 0);
        }
        
        private BasePlayer FindPlayer(string nameOrID)
        {
            var targets = BasePlayer.activePlayerList.Where(x => x.UserIDString == nameOrID || x.displayName.ToLower().Contains(nameOrID.ToLower())).ToArray();
            
            if (targets.Length == 0)
            {
                PrintWarning(GetMessage("No Players", nameOrID));
                return null;
            }

            if (targets.Length > 1)
            {
                PrintWarning(GetMessage("Multiple Players", targets.Select(x => x.displayName).ToSentence()));
                return null;
            }

            return targets[0];
        }

        #endregion

        #region Commands

        private void cmdBlueprintsConsole(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player != null && permission.UserHasPermission(player.UserIDString, permAdmin) == false)
            {
                Message(arg, "Permission");
                return;
            }

            var args = arg.Args;
            if (args == null || args.Length < 2)
            {
                Message(arg, "Usage");
                return;
            }

            var action = args[0].ToLower();

            var target = FindPlayer(args[1]);
            if (target == null)
            {
                return;
            }

            switch (action)
            {
                case "reset":
                    ResetBlueprints(target);
                    break;
                
                case "unlock":
                    if (args.Length < 3)
                    {
                        Message(arg, "Usage");
                        return;
                    }

                    var itemID = ItemManager.FindItemDefinition(args[2])?.itemid ?? 0;
                    UnlockBlueprints(target, new List<int>{itemID});
                    break;
                
                case "unlockall":
                    UnlockBlueprints(target, data.allBlueprints);
                    break;
                
                default:
                    Message(arg, "Usage");
                    return;
            }
            
            Message(arg, "Success", target.displayName);
        }

        #endregion
        
        #region Configuration 1.1.2

        private static ConfigData config;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Blacklist")]
            public List<string> blacklist = new List<string>();
            
            [JsonProperty(PropertyName = "Default blueprints")]
            public List<string> defaultBlueprints = new List<string>();
        }

        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                blacklist = new List<string>
                {
                    "explosive.timed",
                    "rocket.launcher",
                    "ammo.rocket.basic",
                    "ammo.rocket.fire",
                    "ammo.rocket.hv",
                    "ammo.rifle.explosive"
                },
                defaultBlueprints = new List<string>
                {
                    "pistol.revolver",
                    "pistol.semiauto",
                    "pickaxe",
                    "hatchet"
                }
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();

                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                PrintError("Configuration file is corrupt! Check your config file at https://jsonlint.com/");
                
                timer.Every(10f, () =>
                {
                    PrintError("Configuration file is corrupt! Check your config file at https://jsonlint.com/");
                });
                LoadDefaultConfig();
                return;
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
        
        #region Localization 1.1.1
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Usage", "Usage:\n" +
                          " * blueprintmanager reset 'player name or id' - resets blueprints for player\n" +
                          " * blueprintmanager unlock 'player name or id' 'item shortname' - unlock specified blueprint for player\n" +
                          " * blueprintmanager unlockall 'player name or id'- unlocks all blueprints for player"},
                {"Permission", "You don't have permission to use that!"},
                
                {"No Players", "There are no players with that Name or steamID! ({0})"},
                {"Multiple Players", "There are many players with that Name:\n{0}"},
                {"Success", "Your action was done successfully for '{0}'!"}
            }, this);
        }
        
        private string GetMessage(string messageKey, string playerID, params object[] args)
        {
            return string.Format(lang.GetMessage(messageKey, this, playerID), args);
        }

        private void Message(ConsoleSystem.Arg arg, string messageKey, params object[] args)
        {
            var message = GetMessage(messageKey, null, args);
            var player = arg.Player();
            if (player != null)
            {
                player.ChatMessage(message);
            }
            else
            {
                SendReply(arg, message);
            }
        }

        #endregion
    }
}

// --- End of file: BlueprintManager.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/AIQEventSystem.cs ---
// --- Original Local Path: KualaRust/AIQEventSystem.cs ---

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using ConVar;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("AIQEventSystem", "Mercury", "0.0.2")]
    [Description("Не услышанный пионер Mercury")]
    class AIQEventSystem : RustPlugin
    {
        #region Reference
        [PluginReference] Plugin IQChat;
        #endregion

        #region Vars
        public bool EventStatus = false;
        public EventType EventLocal;
        public int LocalIndexEvent = 0;
        public enum EventType
        {
            Gather,
            PickUp,
            Search,
            Kills
        }
        public Dictionary<BasePlayer, int> EventPlayerList = new Dictionary<BasePlayer, int>();
        #endregion

        #region Configuration
        private static Configuration config = new Configuration();
        private class Configuration
        {
            [JsonProperty("Настройка ивентов")]
            public List<Events> EventList = new List<Events>();
            [JsonProperty("Настройка интерфейса")]
            public InterfaceSetting InterfaceSettings = new InterfaceSetting();
            [JsonProperty("Через сколько запуск случайный ивент(в секундах)")]
            public float TimeToStartEvent;
            [JsonProperty("Время ожидания регистрации игроков на ивент")]
            public float TimerVotesWait;
            [JsonProperty("Префикс в чате(IQChat)")]
            public string PrefixForChat;
            [JsonProperty("Минимум игроков для запуска ивента")]
            public int MinimumOnline;

            internal class Events
            {
                [JsonProperty("Тип ивента : 0 - Добыча, 1 - Поднять с пола, 2 - Найти в ящике, 3 - Убийство")]
                public EventType EventTypes;
                [JsonProperty("Время ивента ( в секундах )")]
                public float TimerEvent;
                [JsonProperty("Отображаемое имя")]
                public string DisplayName;
                [JsonProperty("Описание ивента")]
                public string Description;
                [JsonProperty("Цель ивента : Shortname")]
                public string Shortname;
                [JsonProperty("Цель ивента : SkinID (если не требуется,оставляйте 0)")]
                public ulong SkinID;
                [JsonProperty("Награда за победу в ивенте")]
                public List<Reward> Rewards = new List<Reward>();

                internal class Reward
                {
                    [JsonProperty("Shortname")]
                    public string Shortname;
                    [JsonProperty("Команда")]
                    public string Command;
                    [JsonProperty("SkinID")]
                    public ulong SkinID;
                    [JsonProperty("Минимальное количество")]
                    public int MinAmount;
                    [JsonProperty("Максимальное количество")]
                    public int MaxAmount;
                }
            }

            internal class InterfaceSetting
            {
                [JsonProperty("AnchorMin всей панели")]
                public string AnchorMin;
                [JsonProperty("AnchorMax всей панели")]
                public string AnchorMax;
                [JsonProperty("AnchorMin кнопки для участия")]
                public string AnchorMinVote;
                [JsonProperty("AnchorMax кнопки для участия")]
                public string AnchorMaxVote;
                [JsonProperty("Основной цвет")]
                public string MainColor;
                [JsonProperty("Дополнительный цвет")]
                public string TwoMainColor;
            }

            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    TimeToStartEvent = 1600,
                    TimerVotesWait = 20,
                    MinimumOnline = 5,
                    PrefixForChat = "<color=#007FFF><b>[МЕРОПРИЯТИЕ]</b></color>",
                    InterfaceSettings = new InterfaceSetting
                    {
                        AnchorMin = "0.003645837 0.6509259",
                        AnchorMax = "0.1661458 0.9916667",
                        AnchorMinVote = "0.3078125 0.112963",
                        AnchorMaxVote = "0.6765625 0.162963",
                        MainColor = "#6B803EFF",
                        TwoMainColor = "#566B2BFF",
                    },
                    EventList = new List<Events>
                    {
                       new Events
                       {
                           EventTypes = EventType.Gather,
                           DisplayName = "<b>Каменьщик</b>",
                           Description = "<b><size=12>Добудьте КАМНЯ больше всех и получите приз</size></b>",
                           TimerEvent = 600,
                           Shortname = "stones",
                           SkinID = 0,
                           Rewards = new List<Events.Reward>
                           {
                               new Events.Reward
                               {
                                   Shortname = "wrappingpaper",
                                   Command = "",
                                   SkinID = 0,
                                   MinAmount = 1,
                                   MaxAmount = 5
                               }
                           }
                       },
                       new Events
                       {
                           EventTypes = EventType.Kills,
                           DisplayName = "<b>Убийца животных</b>",
                           Description = "<b><size=12>Убейте КАБАНОВ больше всех и получите приз</size></b>",
                           TimerEvent = 600,
                           Shortname = "boar",
                           SkinID = 0,
                           Rewards = new List<Events.Reward>
                           {
                               new Events.Reward
                               {
                                   Shortname = "wrappingpaper",
                                   Command = "",
                                   SkinID = 0,
                                   MinAmount = 1,
                                   MaxAmount = 5
                               },
                               new Events.Reward
                               {
                                   Shortname = "piano",
                                   Command = "say %STEAMID%",
                                   SkinID = 0,
                                   MinAmount = 1,
                                   MaxAmount = 5
                               },
                           }
                       },
                       new Events
                       {
                           EventTypes = EventType.PickUp,
                           DisplayName = "<b>Грибник</b>",
                           Description = "<b><size=12>Найдите грибов больше всех и получите приз</size></b>",
                           TimerEvent = 600,
                           Shortname = "mushroom",
                           SkinID = 0,
                           Rewards = new List<Events.Reward>
                           {
                               new Events.Reward
                               {
                                   Shortname = "wrappingpaper",
                                   Command = "",
                                   SkinID = 0,
                                   MinAmount = 1,
                                   MaxAmount = 5
                               },
                               new Events.Reward
                               {
                                   Shortname = "piano",
                                   Command = "say %STEAMID%",
                                   SkinID = 0,
                                   MinAmount = 1,
                                   MaxAmount = 5
                               },
                           }
                       },
                       new Events
                       {
                           EventTypes = EventType.Search,
                           DisplayName = "<b>Искатель</b>",
                           Description = "<b><size=12>Найдите скрапа больше всех и получите приз</size></b>",
                           TimerEvent = 100,
                           Shortname = "scrap",
                           SkinID = 0,
                           Rewards = new List<Events.Reward>
                           {
                               new Events.Reward
                               {
                                   Shortname = "wrappingpaper",
                                   Command = "",
                                   SkinID = 0,
                                   MinAmount = 1,
                                   MaxAmount = 5
                               },
                               new Events.Reward
                               {
                                   Shortname = "piano",
                                   Command = "say %STEAMID%",
                                   SkinID = 0,
                                   MinAmount = 1,
                                   MaxAmount = 5
                               },
                           }
                       },
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning("Ошибка #132167" + $"чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }
            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion

        #region UI

        public static string QIEVENT_PARENT = "IQEVENT_PARENTS";
        public static string QIEVENT_VOTE_PARENT = "IQEVENTVOTE_PARENTS";

        public void UIEventVotes(int IndexEvent)
        {
            if (EventStatus) return;
            EventPlayerList.Clear();

            for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
            {
                var player = BasePlayer.activePlayerList[i];

                CuiElementContainer container = new CuiElementContainer();
                CuiHelper.DestroyUi(player, QIEVENT_VOTE_PARENT);

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = config.InterfaceSettings.AnchorMinVote, AnchorMax = config.InterfaceSettings.AnchorMaxVote },
                    Button = { Close = QIEVENT_VOTE_PARENT, Command = "iqe vote", Color = HexToRustFormat(config.InterfaceSettings.MainColor), Material = "assets/content/ui/uibackgroundblur.mat" },
                    Text = { FadeIn = 0.8f, Text = lang.GetMessage("EVENT_VOTES_BTN", this, player.UserIDString), Align = TextAnchor.MiddleCenter }
                }, "Overlay", QIEVENT_VOTE_PARENT);

                CuiHelper.AddUi(player, container);
            };

            timer.Once(config.TimerVotesWait, () =>
            {
                foreach (var MembersEvent in EventPlayerList)
                    UIEvent(MembersEvent.Key, IndexEvent);

                for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
                {
                    var player = BasePlayer.activePlayerList[i];
                    CuiHelper.DestroyUi(player, QIEVENT_VOTE_PARENT);
                }
            });
        }

        public void UIEvent(BasePlayer player, int IndexEvent)
        {
            var Event = config.EventList[IndexEvent];
            var Interface = config.InterfaceSettings;
            EventLocal = Event.EventTypes; 
            EventStatus = true;

            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, QIEVENT_PARENT);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = Interface.AnchorMin, AnchorMax = Interface.AnchorMax },
                Image = { FadeIn = 0.15f, Color = "0 0 0 0" }
            }, "Overlay", QIEVENT_PARENT);

            #region TitlePanel

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.8940217", AnchorMax = "1 1" },
                Image = { FadeIn = 0.15f, Color = HexToRustFormat(Interface.MainColor), Material = "assets/content/ui/uibackgroundblur.mat" }
            },  QIEVENT_PARENT, "TITLE_PANEL");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.03205127 0", AnchorMax = "0.7211539 1" },
                Text = { Text = Event.DisplayName, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft, FadeIn = 0.3f }
            }, "TITLE_PANEL");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.775641 0", AnchorMax = "1 0.9074167" },
                Text = { Text = $"<b>{FormatTime(TimeSpan.FromSeconds(Event.TimerEvent))}</b>", Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
            }, "TITLE_PANEL", "TIMER");

            #endregion

            #region MainPanel

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.8858696" },
                Image = { FadeIn = 0.15f, Color = HexToRustFormat(Interface.MainColor), Material = "assets/content/ui/uibackgroundblur.mat" }
            }, QIEVENT_PARENT, "MAIN_PANEL");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.9049079", AnchorMax = "1 1" },
                Text = { Text = lang.GetMessage("LIST_MEMBERS",this,player.UserIDString), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
            }, "MAIN_PANEL");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.8527607", AnchorMax = "1 0.9233128" },
                Text = { Text = lang.GetMessage("ONE_DESCTIPTION", this,player.UserIDString), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
            }, "MAIN_PANEL");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.1441717" },
                Text = { Text = Event.Description, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
            }, "MAIN_PANEL");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.02 0.1503068", AnchorMax = "0.98 0.8036808" },
                Image = { FadeIn = 0.15f, Color = HexToRustFormat(config.InterfaceSettings.TwoMainColor), Material = "assets/content/ui/uibackgroundblur.mat" }
            }, "MAIN_PANEL", "PLAYERS_PANEL");

            #endregion

            CuiHelper.AddUi(player, container);

            timer.Once(1, () => { RefreshTimer(player, (float)Event.TimerEvent, IndexEvent); });
        }

        public void RefreshTimer(BasePlayer player, float Timer,int IndexEvent)
        {
            CuiHelper.DestroyUi(player, "TIMER");
            if (!EventStatus) return;
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.775641 0", AnchorMax = "1 0.9074075" },
                Text = { Text = $"<b>{FormatTime(TimeSpan.FromSeconds(Timer))}</b>", Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
            }, "TITLE_PANEL", "TIMER");

            var TopEvent = EventPlayerList.OrderByDescending(x => x.Value).Take(8).ToDictionary(x => x.Key, x => x.Value);

            for(int i = 0; i < TopEvent.Count; i++)
            {
                CuiHelper.DestroyUi(player, $"PLAYER_COUNT_{i}");
                var ElementTop = TopEvent.ElementAt(i);

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = $"0 {0.8779345 - (i * 0.13)}", AnchorMax = $"1 {1 - (i * 0.13)}" },
                    Text = { Text = $"{ElementTop.Key.displayName} : {ElementTop.Value}шт", Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
                }, "PLAYERS_PANEL", $"PLAYER_COUNT_{i}");
            }

            CuiHelper.AddUi(player, container);

            if(Timer <= 0)
            {
                EventStatus = false;
                GiveReward(IndexEvent);
                foreach (var Eventers in EventPlayerList)
                    CuiHelper.DestroyUi(Eventers.Key, QIEVENT_PARENT);
                return;
            }
            Timer--;
            timer.Once(1, () => { RefreshTimer(player, (float)Timer, IndexEvent); });
        }

        #endregion

        #region Lang
        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["LIST_MEMBERS"] = "<size=14><b>Entry</b></size>",
                ["ONE_DESCTIPTION"] = "<size=10><b>Outrun everyone and hold first place</b></size>",
                ["NON_ADMIN_CHAT_COMMAND"] = "You are not an Administrator",
                ["NON_CORRECT_CHAT_COMMAND"] = "You are using the command incorrectly",
                ["EVENT_VOTES_BTN"] = "<size=14><b>The event is about to begin!\n To take part, click on this button</b></size>",
                ["EVENT_VOTES_BTN_ACCESS"] = "You have successfully registered for participation",
                ["EVENT_WINNER_ALERT"] = "You received a reward for winning the event, congratulations!",

            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["LIST_MEMBERS"] = "<size=14><b>Список участников</b></size>",
                ["ONE_DESCTIPTION"] = "<size=10><b>Обгони всех и удержи первое место</b></size>",
                ["NON_ADMIN_CHAT_COMMAND"] = "Вы не являетесь Администратором",
                ["NON_CORRECT_CHAT_COMMAND"] = "Вы некорректно используете команду",
                ["EVENT_VOTES_BTN"] = "<size=14><b>Achtung!!! Сейчас начнется Kuala Ивент!\nЧтобы принять участие,нажмите на эту кнопку</b></size>",
                ["EVENT_VOTES_BTN_ACCESS"] = "Вы успешно зарегистрировались на участие",
                ["EVENT_WINNER_ALERT"] = "Вы получили награду за победу в ивенте,поздравляем!",

            }, this, "ru");
            PrintWarning("Языковой файл загружен успешно");
        }
        #endregion

        #region Hooks
        private void OnServerInitialized()
        {
            EventAutoStart();
        }

        void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            if (!EventStatus) return;
            if (dispenser == null || entity == null || item == null) return;
            if (EventLocal != EventType.Gather) return;
            if (item.info.shortname != config.EventList[LocalIndexEvent].Shortname) return;
            BasePlayer player = (BasePlayer)entity;
            WriteResult(player, item.amount);
        }

        void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            if (!EventStatus) return;
            if (dispenser == null || player == null || item == null) return;
            if (EventLocal != EventType.Gather) return;
            if (item.info.shortname != config.EventList[LocalIndexEvent].Shortname) return;
            WriteResult(player, item.amount);
        }

        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (!EventStatus) return;
            if (info?.InitiatorPlayer == null || info == null || entity == null) return;
            if (EventLocal != EventType.Kills) return;
            if (entity.ShortPrefabName != config.EventList[LocalIndexEvent].Shortname) return;
            var player = info?.InitiatorPlayer;
            WriteResult(player, 1);
        }

        void OnCollectiblePickup(Item item, BasePlayer player)
        {
            if (!EventStatus) return;
            if (item == null || player == null) return;
            if (EventLocal != EventType.PickUp) return;
            if (item.info.shortname != config.EventList[LocalIndexEvent].Shortname) return;
            WriteResult(player, item.amount);
        }
        void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            if (!EventStatus) return;
            if (entity == null || player == null) return;
            if (entity.GetComponent<StorageContainer>() == null) return;
            if (entity.OwnerID >= 7656000000) return;
            if (EventLocal != EventType.Search) return;

            foreach (var content in entity.GetComponent<StorageContainer>().inventory.itemList)
            {
                if (content.info.shortname == config.EventList[LocalIndexEvent].Shortname)
                    WriteResult(player, content.amount);
            }
        }
        #endregion

        #region Metods

        void EventAutoStart()
        {
            timer.Every(config.TimeToStartEvent, () =>
             {
                 if (EventStatus)
                 {
                     PrintError("Слишком маленькое время для автоматического старта! Прошлый ивент не успел закончится!\nНовый ивент перенесен!");
                     return;
                 }
                 if(BasePlayer.activePlayerList.Count < config.MinimumOnline)
                 {
                     PrintWarning("Автоматический запуск ивента отменен! Недостаточно игроков на сервере!\nНовый ивент перенесен!");
                     return;
                 }
                 LocalIndexEvent = GetRandomEvent();
                 UIEventVotes(LocalIndexEvent);
             });
        }

        public int GetRandomEvent()
        {
            int IndexEvent = UnityEngine.Random.Range(0, config.EventList.Count());
            return IndexEvent;
        }

        public void WriteResult(BasePlayer player,int Amount)
        {
            if (!EventPlayerList.ContainsKey(player)) return;
            EventPlayerList[player] += Amount;
        }

        public void GiveReward(int IndexEvent)
        {
            var Winner = EventPlayerList.OrderByDescending(x => x.Value).Take(1).ToDictionary(x => x.Key, x => x.Value);
            var Rewards = config.EventList[IndexEvent].Rewards;
            foreach (var player in Winner)
            {
                for (int i = 0; i < Rewards.Count; i++)
                {
                    if (String.IsNullOrEmpty(Rewards[i].Command))
                    {
                        var RandomAmount = UnityEngine.Random.Range(Rewards[i].MinAmount, Rewards[i].MaxAmount);
                        Item item = ItemManager.CreateByName(Rewards[i].Shortname, RandomAmount, Rewards[i].SkinID);
                        player.Key.GiveItem(item);
                    }
                    else Server.Command(Rewards[i].Command.Replace("%STEAMID%", player.Key.UserIDString));
                }
                SendChat(lang.GetMessage("EVENT_WINNER_ALERT", this, player.Key.UserIDString), player.Key);
            }
        }
        #endregion

        #region Command

        [ChatCommand("iqe")]
        void IQEventCommand(BasePlayer player, string cmd, string[] arg)
        {
            if (!player.IsAdmin)
            {
                SendChat(lang.GetMessage("NON_ADMIN_CHAT_COMMAND", this, player.UserIDString), player);
                return;
            }
            if (arg == null || arg.Length < 1 || arg[0].Length < 0)
            {
                SendChat(lang.GetMessage("NON_CORRECT_CHAT_COMMAND", this, player.UserIDString), player);
                return;
            }
            switch(arg[0].ToLower())
            {
                case "start":
                    {
                        LocalIndexEvent = GetRandomEvent();
                        UIEventVotes(LocalIndexEvent);
                        SendChat("Вы успешно запустили ивент вручную", player);
                        break;
                    }
                case "stop":
                    {
                        for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
                        {
                            var p = BasePlayer.activePlayerList[i];
                            CuiHelper.DestroyUi(p, QIEVENT_PARENT);
                            CuiHelper.DestroyUi(p, QIEVENT_VOTE_PARENT);
                        }

                        EventStatus = false;
                        SendChat("Вы успешно остановили ивент вручную", player);
                        break;
                    }
            }
        }

        [ConsoleCommand("iqe")]
        void IQECommandConsole(ConsoleSystem.Arg arg)
        {
            switch(arg.Args[0])
            {
                case "vote":
                    {
                        BasePlayer player = arg.Player();
                        EventPlayerList.Add(player, 0);
                        SendChat(lang.GetMessage("EVENT_VOTES_BTN_ACCESS", this, player.UserIDString), player);
                        break;
                    }
            }
        }

        #endregion

        #region Helps
        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }

        static DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        static double CurrentTime() => DateTime.UtcNow.Subtract(epoch).TotalSeconds;

        public static string FormatTime(TimeSpan time)
        {
            string result = string.Empty;
            if (time.Days != 0)
                result += $"{Format(time.Days, "д", "д", "д")} ";

            if (time.Hours != 0)
                result += $"{Format(time.Hours, "ч", "ч", "ч")} ";

            if (time.Minutes != 0)
                result += $"{Format(time.Minutes, "м", "м", "м")} ";

            if (time.Seconds != 0)
                result += $"{Format(time.Seconds, "с", "с", "с")} ";

            return result;
        }

        private static string Format(int units, string form1, string form2, string form3)
        {
            var tmp = units % 10;

            if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                return $"{units} {form1}";

            if (tmp >= 2 && tmp <= 4)
                return $"{units} {form2}";

            return $"{units} {form3}";
        }

        public void SendChat(string Message, BasePlayer player, Chat.ChatChannel channel = Chat.ChatChannel.Global)
        {
            if (IQChat)
                IQChat?.Call("API_ALERT_PLAYER", player, Message, config.PrefixForChat);
            else player.SendConsoleCommand("chat.add", channel, 0, Message);
        }
        #endregion
    }
}


// --- End of file: AIQEventSystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/DoorManager.cs ---
// --- Original Local Path: KualaRust/DoorManager.cs ---

﻿using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;
using Random = Oxide.Core.Random;
using ru = Oxide.Game.Rust;

namespace Oxide.Plugins
{
    [Info("DoorManager", "fermens", "0.0.41")]
    [Description("^^")]
    public class DoorManager : RustPlugin
    {
        #region КЕШ
        static Dictionary<BasePlayer, CodeLock> codelocks = new Dictionary<BasePlayer, CodeLock>();
        static Dictionary<ulong, set> settings = new Dictionary<ulong, set>();
        const int codelockid = 1159991980;
        const string lockprefab = "assets/prefabs/locks/keypad/lock.code.prefab";

        class set
        {
            public string code;
            public bool autolock;
            public bool closer;
            public float delay;
        }

        Dictionary<string, string> MessagesRU = new Dictionary<string, string>
        {
            {"notallow", "<color=#ff8000>У ВАС НЕТ ДОСТУПА К ЭТОЙ КОМАНДЕ!</color>"},
            {"codeinit", "Кодовый замок установлен с кодом <color=#ff8000>{0}</color>."},
            {"autlockoff", "Автолок выключен."},
            {"autlockon", "Автолок включен."},
            {"codeupdate", "Ваш новый код - <color=#ff8000>{0}</color>."},
            {"closeroff", "Установка автодоводчика выключена."},
            {"closeron", "Установка автодоводчика включена."},
            {"closertime", "<color=#ff8000>МОЖНО УКАЗАТЬ НЕ МЕНЬШЕ 2 И НЕ БОЛЬШЕ 10!</color>"},
            {"closerdelay", "<color=#ff8000>Вы успешно указали новое время - {0} сек!</color>"},
            {"main", "<color=#ff8000>KualaCodeLock™</color> \n\n<color=#ff8000>/{0} c</color> - установить новый код\n<color=#ff8000>/{0} t</color> - включить/выключить автолок\n<color=#ff8000>/{0} cl</color> - включить/выключить установку автодоводчика\n<color=#ff8000>/{0} cl </color><color=#FF0077>2-10</color> - установить время закрытия дверей <color=#FF1400>(новых!)</color> <color=#ff8000>(сейчас:</color> <color=#D0007F>{delay}</color><color=#ff8000>)</color>"}
        };

        Dictionary<string, string> MessagesEN = new Dictionary<string, string>
        {
            {"notallow", "<color=#ff8000>YOU DO NOT HAVE ACCESS!</color>"},
            {"codeinit", "Combination lock installed with code <color=#ff8000>{0}</color>."},
            {"autlockoff", "Autolock off."},
            {"autlockon", "Autolock on."},
            {"codeupdate", "Your new code - <color=#ff8000>{0}</color>."},
            {"closeroff", "Automatic closer installation disabled."},
            {"closeron", "Automatic closer installation enabled."},
            {"closertime", "<color=#ff8000>IT IS POSSIBLE TO SPECIFY AT LEAST 2 AND NO MORE THAN 10!</color>"},
            {"closerdelay", "<color=#ff8000>You have successfully entered a new time - {0} сек!</color>"},
            {"main", "<color=#ff8000>/{0} code</color> - install new code\n<color=#ff8000>/{0} toggle</color> - enable/disabled autolock\n<color=#ff8000>/{0} closer</color> - enable/disabled installation of an automatic closer\n<color=#ff8000>/{0} closer 2-10</color> - set door closing time <color=#ff8000>[new!][current: {delay}]</color>"}
        };

        Dictionary<string, string> MessagesES = new Dictionary<string, string>
        {
            {"notallow", "<color=#ff8000>¡NO TIENES ACCESO!</color>"},
            {"codeinit", "Cerradura de combinación instalada con código <color=#ff8000>{0}</color>."},
            {"autlockoff", "Bloqueo automático desactivado."},
            {"autlockon", "Bloqueo automático incluido."},
            {"codeupdate", "Tu nuevo código - <color=#ff8000>{0}</color>."},
            {"closeroff", "Instalación automática más cercana desactivada."},
            {"closeron", "Instalación automática más cercana activada."},
            {"closertime", "<color=#ff8000>¡ES POSIBLE ESPECIFICAR AL MENOS 2 Y NO MÁS DE 10!</color>"},
            {"closerdelay", "<color=#ff8000>Ha ingresado exitosamente una nueva hora - {0} сек!</color>"},
            {"main", "<color=#ff8000>/{0} code</color> - instalar nuevo código\n<color=#ff8000>/{0} toggle</color> - activada/desactivada bloqueo automático\n<color=#ff8000>/{0} closer</color> - activada/desactivada instalación de un cerrador automático\n<color=#ff8000>/{0} closer 2-10</color> - establecer la hora de cierre de la puerta <color=#ff8000>[nuevo!][ahora: {delay}]</color>"}
        };
        #endregion

        #region ОКСИДХУКИ
        private void OnServerInitialized()
        {
            lang.RegisterMessages(MessagesEN, this, "en");
            lang.RegisterMessages(MessagesRU, this, "ru");
            lang.RegisterMessages(MessagesRU, this, "uk");
            lang.RegisterMessages(MessagesES, this, "es");

            permission.RegisterPermission("doormanager.noitem", this);
            permission.RegisterPermission("doormanager.auto", this);

            settings = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, set>>("doormanager");

            var command = Interface.Oxide.GetLibrary<ru.Libraries.Command>(null);
            command.AddChatCommand("autolock", this, "cmdcommand");
            command.AddChatCommand("al", this, "cmdcommand");
        }

        private void OnEntityBuilt(Planner plan, GameObject go)
        {
            BasePlayer player = plan.GetOwnerPlayer();
            if (player == null) return;

            if (!(go.ToBaseEntity() is DecayEntity)) return;

            DecayEntity decayEntity = go.ToBaseEntity().GetComponent<DecayEntity>();
            if (decayEntity == null) return;

            set set;
            if (!settings.TryGetValue(player.userID, out set))
            {
                ADD(player.userID);
                set = settings[player.userID];
            }

            if (!set.autolock || decayEntity.IsLocked()) return;

            if (decayEntity is StorageContainer)
            {
                StorageContainer storageContainer = decayEntity as StorageContainer;
                if (!storageContainer.isLockable) return;
            }
            else if (decayEntity is AnimatedBuildingBlock)
            {
                if (HasCloserPermission(player.UserIDString))
                {
                    Door door = decayEntity.GetComponent<Door>();
                    if (door != null /*&& door.canTakeCloser*/ && (decayEntity.HasSlot(BaseEntity.Slot.UpperModifier) || decayEntity.HasSlot(BaseEntity.Slot.LowerCenterDecoration)))
                    {
                        CREATECLOSER(decayEntity, set.delay, player);
                    }
                }
            }
            else return;

            if (!HASLOCKER(player)) return;

            CodeLock codeLock = GameManager.server.CreateEntity(lockprefab) as CodeLock;
            if (codeLock == null) return;

            codeLock.OwnerID = player.userID;
            codeLock.Spawn();
            codeLock.code = set.code;
            codeLock.SetParent(decayEntity, decayEntity.GetSlotAnchorName(BaseEntity.Slot.Lock));
            decayEntity.SetSlot(BaseEntity.Slot.Lock, codeLock);
            codeLock.SetFlag(BaseEntity.Flags.Locked, true);
            Effect.server.Run(codeLock.effectLocked.resourcePath, codeLock.transform.position);
            codeLock.whitelistPlayers.Add(player.userID);

            player.ChatMessage(GetMessageLanguage("codeinit", player.UserIDString).Replace("{0}", player.net.connection.info.GetBool("global.streamermode") ? "****" : set.code));
        }
        private void Unload()
        {
            Save();
            foreach (var z in codelocks) z.Value?.Kill();
        }
        #endregion
        
        #region ПОМОШНИКИ
        private string GetRandomCode() => Random.Range(1, 9999).ToString().PadLeft(4, '0');
        private bool HasCloserPermission(string id) => permission.UserHasPermission(id, "doormanager.auto");
        private void Save()
        {
            if (settings != null && settings.Count > 0) Interface.Oxide.DataFileSystem.WriteObject("doormanager", settings);
        }

        private string GetMessageLanguage(string key, string userId)
        {
            return lang.GetMessage(key, this, userId);
        }

        private void ADD(ulong id) => settings.Add(id, new set { code = GetRandomCode(), closer = true, autolock = true, delay = 3f });

        private void CREATECLOSER(BaseEntity entity, float delay, BasePlayer player)
        {
            DoorCloser doorcloser = GameManager.server.CreateEntity(StringPool.Get(1831641807), new Vector3(), new Quaternion(), true) as DoorCloser;
            if (doorcloser == null) return;
            doorcloser.gameObject.Identity();
            doorcloser.delay = delay;

            if (entity.ShortPrefabName.StartsWith("door.double.hinged") || entity.ShortPrefabName == "wall.frame.garagedoor")
            {
                doorcloser.SetParent(entity, entity.GetSlotAnchorName(BaseEntity.Slot.LowerCenterDecoration));
            }
            else
            {
                doorcloser.SetParent(entity, entity.GetSlotAnchorName(BaseEntity.Slot.UpperModifier));
            }

            doorcloser.OnDeployed(entity, player);
            if (entity.ShortPrefabName == "floor.ladder.hatch") doorcloser.transform.localPosition = new Vector3(0.7f, 0f, 0f);
            doorcloser.Spawn();
            entity.SetSlot(BaseEntity.Slot.UpperModifier, doorcloser);
        }

        private bool HASLOCKER(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, "doormanager.noitem")) return true;
            Item item = player.inventory.FindItemID(codelockid);
            if (item == null) return false;
            player.inventory.Take(null, codelockid, 1);
            return true;
        }

        private void OpenCodeLockUI(BasePlayer player)
        {
            CodeLock codeLock = GameManager.server.CreateEntity(lockprefab, player.eyes.position + new Vector3(0, -3, 0)) as CodeLock;
            if (codeLock != null)
            {
                codeLock.Spawn();
                codeLock.SetFlag(BaseEntity.Flags.Locked, true);
                codeLock.ClientRPCPlayer(null, player, "EnterUnlockCode");
                codelocks[player] = codeLock;
                Subscribe("OnCodeEntered");

                timer.Once(20f, () => codeLock?.Kill());
            }
        }

        private void OnCodeEntered(CodeLock codeLock, BasePlayer player, string code)
        {
            if (player == null) return;

            CodeLock cl;
            if (!codelocks.TryGetValue(player, out cl)) return;

            if (cl != codeLock)
            {
                cl?.Kill();
                codelocks.Remove(player);
                return;
            }

            set set;
            if (!settings.TryGetValue(player.userID, out set)) return;

            set.code = code;
            player.ChatMessage(string.Format(GetMessageLanguage("codeupdate", player.UserIDString), player.net.connection.info.GetBool("global.streamermode") ? "****" : code));
            Effect.server.Run(cl.effectCodeChanged.resourcePath, player.transform.position);
            cl?.Kill();
            codelocks.Remove(player);
            if (codelocks.Count == 0) Unsubscribe("OnCodeEntered");
        }
        #endregion

        #region ЧАТ_КОМАНДА
        private void cmdcommand(BasePlayer player, string command, string[] args)
        {
            set set;
            if (!settings.TryGetValue(player.userID, out set))
            {
                ADD(player.userID);
                set = settings[player.userID];
            }

            if (args == null || args.Length < 1)
            {
                player.ChatMessage(GetMessageLanguage("main", player.UserIDString).Replace("{0}", command).Replace("{delay}", set.delay.ToString()));
                return;
            }

            if(args[0] == "c")
            {
                OpenCodeLockUI(player);
            }
            else if (args[0] == "t")
            {
                set.autolock = !set.autolock;
                player.ChatMessage(GetMessageLanguage(set.autolock ? "autlockon" : "autlockoff", player.UserIDString));
            }
            else if (args[0] == "cl")
            {
                if (!HasCloserPermission(player.UserIDString))
                {
                    player.ChatMessage(GetMessageLanguage("notallow", player.UserIDString));
                    return;
                }
                float time;
                if (args.Length == 1 || !float.TryParse(args[1], out time))
                {
                    set.closer = !set.closer;
                    player.ChatMessage(GetMessageLanguage(set.closer ? "closeron" : "closeroff", player.UserIDString));
                }
                else
                {
                    if(time < 2 || time > 10)
                    {
                        player.ChatMessage(GetMessageLanguage("closertime", player.UserIDString));
                        return;
                    }
                    set.delay = time;
                    player.ChatMessage(GetMessageLanguage("closerdelay", player.UserIDString).Replace("{0}", time.ToString()));
                }
            }
        }
        #endregion

    }
}


// --- End of file: DoorManager.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/RemoveUpgradeV2.cs ---
// --- Original Local Path: KualaRust/RemoveUpgradeV2.cs ---

﻿using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("RemoveUpgradeV2", "fermens", "0.2.62")]
    [Description("ОПТИМИЗИРОВАН! Лучший плагин для ремува и апгрейда построек")]
    class RemoveUpgradeV2 : RustPlugin
    {
        #region Config
        private PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }
        private class PluginConfig
        {
            [JsonProperty("Разрешить ремувать постройки друзьям")]
            public bool friends;

            [JsonProperty("Разрешить ломать постройки авторизованым в шкафу")]
            public bool cupboard;

            [JsonProperty("Выключить GUI?")]
            public bool disablegui;

            [JsonProperty("Время действия ремува/апгрейда")]
            public int time;

            [JsonProperty("Процент возвращаемых ресурсов с построек")]
            public float procent;

            [JsonProperty("Расположение GUI - AnchorMin")]
            public string AnchorMin;

            [JsonProperty("Расположение GUI - AnchorMax")]
            public string AnchorMax;

            [JsonProperty("Блокировка ремува объекта через определённое время (секунд) [-1 - выключить]")]
            public int blocktime;

            [JsonProperty("Версия рейдблока [0 - Хугана, 1 - С юмода]")]
            public int whatblock;

            [JsonProperty("GUI - Цвет фона")]
            public string color;

            [JsonProperty("Сообщения")]
            public List<string> messages;

            [JsonProperty("Сообщения - Названия")]
            public List<string> messages2;
            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    friends = true,
                    cupboard = false,
                    time = 60,
                    procent = 100f,
                    AnchorMin = "0.3447913 0.1135",
                    AnchorMax = "0.640625 0.1435",
                    color = "0.97 0.92 0.88 0.18",
                    blocktime = 7200,
                    whatblock = 0,
                    messages = new List<string>
                    {
                        "РЕЖИМ УДАЛЕНИЯ ВЫКЛЮЧИТСЯ ЧЕРЕЗ <color=#ffd479>{count} СЕКУНД</color>",
                        "<size=15>Режим удаления выключен</size>.",
                        "<color=red>Не найден объект для удаления.</color>",
                        "<color=#ffd479>BIND X REMOVE.USE</color> БИНД ДЛЯ <color=#ffd479>РЕМУВА</color>\n<color=#ffd479>BIND C UPGRADE.USE</color> БИНД ДЛЯ <color=#ffd479>УЛУЧШЕНИЯ</color>",
                        "<color=#ffd479>BIND C UPGRADE.USE</color> БИНД ДЛЯ <color=#ffd479>УЛУЧШЕНИЯ</color>",
                        "<size=15>В контейнере есть предметы!</size>", //5
                        "<size=15>Ремув этого объекта стоит <color=#ffd479>{amount} дерева</color>!</size>",
                        "Объект уже уничтожен.",
                        "Системный объект.",//8
                        "<size=15>Прошло много времени после постройки данного объекта!</size>",
                        "<size=15>Нельзя использовать <color=#ffd479>remove</color> во время рейд-блока</size>",
                        "<size=15><color=yellow>Вы не имеете права удалять чужие постройки!</color></size>",
                        "<size=15><color=yellow>Что бы удалять постройки, вы должны быть авторизированы в шкафу!</color></size>",
                        "У тебя нету прав на использование этой команды",
                        "<size=15>Используйте <color=#ffd479>киянку</color> для удаления объектов.\nКоманда <color=#ffd479>/remove</color> - выключить режим удаления</size>",
                        "<size=15>Используйте <color=#ffd479>план постройки</color> и <color=#ffd479>киянку</color> для улучшения объектов.\nКоманда <color=#ffd479>/up</color> - сменить ресурс улучшения\nКоманда <color=#ffd479>/remove</color> - выключить режим улучшения</size>",
                        "<size=15>Вы изменили режим улучшения до <color=#ffd479>{grade}</color></size>", //16
                        "АВТОУЛУЧШЕНИЕ ДО <color=#ffd479>{grade}</color> ВЫКЛЮЧИТСЯ ЧЕРЕЗ <color=#ffd479>{count} СЕК</color>",
                        "<size=15>Режим улучшения выключен</size>.",
                        "<size=15>Этот объект не нуждается в улучшении до <color=#ffd479>{grade}</color>!</size>",
                        "<size=15>Вы не можете авто-улучшать постройки <color=#ffd479>во время рейда</color>!</size>", //20
                        "<size=15>Вы находитесь на чужой территории!</size>",
                        "Этот объект можно будет улучшить через <color=#ffd479>{count} секунд</color>",
                        "У вас не хватает ресурсов для улучшения до <color=#ffd479>{grade}</color>!" //23
                    },
                    messages2 = new List<string>()
                    {
                        { "None" }, { "ДЕРЕВА" }, { "КАМНЯ" }, { "МЕТАЛА" }, { "МВК" }
                    },
                    disablegui = false
                };
            }
        }
        #endregion

        Dictionary<uint, DateTime> canremove = new Dictionary<uint, DateTime>();
        private void OnEntitySpawned(BaseCombatEntity ent)
        {
            if (ent == null) return;
            if (ent is DecayEntity)
            {
                if (!ent.IsDestroyed) canremove[ent.net.ID] = DateTime.Now.AddSeconds(config.blocktime);
            }
        }

        static string GUIjson = "";
        static RemoveUpgradeV2 _ins;
        string helpstring;

        void Init()
        {
            Unsubscribe(nameof(OnEntitySpawned));
        }

        private static bool wipe = false;
        private void OnNewSave(string filename) => wipe = true;

        void OnServerInitialized()
        {
            if (wipe) wipe = false;
            else
            {
                Dictionary<uint, string> saved = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<uint, string>>("entspawned");

                foreach (var z in saved)
                {
                    DateTime dateTime = Convert.ToDateTime(z.Value);
                    if (dateTime < DateTime.Now) continue;
                    canremove[z.Key] = dateTime;
                }
            }

            SaveConfig();
            if (config.disablegui) Unsubscribe(nameof(OnActiveItemChanged));
            if (config.blocktime >= 1) Subscribe(nameof(OnEntitySpawned));
            GUIjson = "[{\"name\":\"RemoverGUIBackground\", \"parent\":\"Hud\", \"components\":[{\"type\":\"UnityEngine.UI.Image\", \"color\":\"{color}\"},{\"type\":\"RectTransform\",\"anchormin\":\"{min}\",\"anchormax\":\"{max}\"}]},{\"name\":\"RemoverGUIText\",\"parent\":\"RemoverGUIBackground\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{text}\",\"font\":\"robotocondensed-regular.ttf\",\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.5\",\"distance\":\"0.5 -0.5\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\"}]}]".Replace("{min}", config.AnchorMin).Replace("{color}", config.color);

            float number;
            string[] ar = config.AnchorMax.Split(' ');
            if (float.TryParse(ar[1], out number))
            {
                helpstring = ar[0] + " " + (number + 0.03f).ToString();
            }
            else Debug.LogError("Конфиг поврежден!");

            config.procent /= 100f;
            _ins = this;

            permission.RegisterPermission("removeupgrade.admin", this);
            permission.RegisterPermission("removeupgrade.use", this);
            permission.RegisterPermission("removeupgrade.refund", this);
            permission.RegisterPermission("removeupgradev2.remove", this);
            permission.RegisterPermission("removeupgradev2.up", this);
            permission.RegisterPermission("removeupgradev2.vip", this);

            foreach (ItemDefinition def in ItemManager.GetItemDefinitions())
            {
                if (!def.Blueprint) continue;
                ItemModDeployable deployable = def.GetComponent<ItemModDeployable>();
                if (deployable != null) deployedToItem[deployable.entityPrefab.resourceID] = def.itemid;
            }
        }

        void unloadbehavior(BasePlayer player)
        {
            player.GetComponent<ToolRemover>()?.DoDestroy();
            player.GetComponent<UpgradeConstruction>()?.DoDestroy();
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            unloadbehavior(player);
        }

        private void Unload()
        {
            if (canremove.Count > 0) Interface.Oxide.DataFileSystem.WriteObject("entspawned", canremove);
            foreach (BasePlayer player in BasePlayer.activePlayerList) unloadbehavior(player);
        }

        private Dictionary<uint, int> deployedToItem = new Dictionary<uint, int>();

        enum RemoveType
        {
            Normal,
            Refund,
            Admin,
            All
        }

        static void PrintToChat(BasePlayer player, string message) => player.ChatMessage(message);


        class ToolRemover : MonoBehaviour
        {
            public BasePlayer player;
            int count;
            int maxcount;
            public RemoveType removeType;

            void Awake()
            {
                player = GetComponent<BasePlayer>();
                if (player == null) Destroy(this);
                SetCount(_ins.config.time);
                InvokeRepeating("UpdateGUI", 0, 1);
            }

            public void SetCount(int number)
            {
                count = number;
                maxcount = number;
            }

            public void ResetDestroy()
            {
                count = maxcount;
            }

            void UpdateGUI()
            {
                if (count.Equals(0)) DoDestroy();
                if (!_ins.config.disablegui)
                {
                    CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "RemoverGUIBackground");
                    CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", GUIjson.Replace("{text}", _ins.config.messages[0].Replace("{count}", count.ToString())).Replace("{max}", _ins.config.AnchorMax));
                }
                count--;
            }

            public void DoDestroy()
            {
                Destroy(this);
            }

            void OnDestroy()
            {
                if (!_ins.config.disablegui) CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "RemoverGUIBackground");
                PrintToChat(player, _ins.config.messages[1]);
            }
        }


        object OnHammerHit(BasePlayer player, HitInfo info)
        {
            ToolRemover RemoverClass = player.GetComponent<ToolRemover>();
            if (RemoverClass != null)
            {
                RemoverClass.ResetDestroy();
                ServerMgr.Instance.StartCoroutine(TryRemove(player, info.HitEntity, RemoverClass.removeType));
                return false;
            }
            else if (info.HitEntity is BuildingBlock)
            {
                UpgradeConstruction gr = player.GetComponent<UpgradeConstruction>();
                if (gr == null) return null;
                ServerMgr.Instance.StartCoroutine(TryUpgrade(player, info.HitEntity.GetComponent<BuildingBlock>(), gr));
                return true;
            }
            return null;
        }

        private static bool IsUpgradeBlocked(BuildingBlock block)
        {
            var deployVolumeArray = PrefabAttribute.server.FindAll<DeployVolume>(block.prefabID);
            return DeployVolume.Check(block.transform.position, block.transform.rotation, deployVolumeArray, ~(1 << (block.gameObject.layer & 31)));
        }

        IEnumerator TryUpgrade(BasePlayer player, BuildingBlock block, UpgradeConstruction gr)
        {
            yield return new WaitForSeconds(0.2f);
            if (block.IsDestroyed) yield break;
            if ((int)block.grade >= gr.currentgrade)
            {
                PrintToChat(player, config.messages[19].Replace("{grade}", config.messages2[gr.currentgrade]));
                yield break;
            }
            if (NoEscape != null && (config.whatblock == 3 && (double)NoEscape?.Call("IsRaid", player) > 0 || config.whatblock == 0 && (double)NoEscape?.Call("ApiGetTime", player.userID) > 0 || config.whatblock == 1 && (bool)NoEscape?.Call("IsRaidBlocked", player)) || config.whatblock == 2 && (int)NoEscape?.Call("ApiGetTime", player.userID) > 0 || RaidBlock != null && RaidBlock.Call<bool>("IsRaidBlocked", player) || RaidZone != null && RaidZone.Call<bool>("HasBlock", player.userID))
            {
                gr.DoDestroy();
                PrintToChat(player, config.messages[20]);
                yield break;
            }
            yield return new WaitForEndOfFrame();
            if (block.prefabID == 72949757 || block.prefabID == 3234260181)
            {
                if (IsUpgradeBlocked(block))
                {
                    PrintToChat(player, "<color=yellow>В фундаменте что-то находиться!</color>");
                    yield break;
                }
            }
            yield return new WaitForEndOfFrame();
            if (!player.CanBuild())
            {
                gr.DoDestroy();
                PrintToChat(player, config.messages[21]);
                yield break;
            }
            yield return new WaitForEndOfFrame();
            if (block.SecondsSinceAttacked < 30)
            {
                PrintToChat(player, config.messages[22].Replace("{count}", (30 - block.SecondsSinceAttacked).ToString()));
                yield break;
            }
            List<ItemAmount> items = block.blockDefinition.grades[gr.currentgrade].costToBuild;
            if (items.Where(check => player.inventory.GetAmount(check.itemid) < check.amount).Count() > 0)
            {
                PrintToChat(player, config.messages[23].Replace("{grade}", config.messages2[gr.currentgrade]));
                yield break;
            }
            yield return new WaitForEndOfFrame();
            foreach (var check in items)
            {
                player.inventory.Take(null, check.itemid, (int)check.amount);
                player.Command("note.inv", check.itemid, check.amount * -1f);
            }
            yield return new WaitForEndOfFrame();
            BuildingGrade.Enum @enum = (BuildingGrade.Enum)gr.currentgrade;
            if (block.IsDestroyed) yield break;
            block.SetGrade(@enum);
            block.SetHealthToMax();
            block.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            block.UpdateSkin(false);
            block.ResetUpkeepTime();
            BuildingManager.server.GetBuilding(block.buildingID)?.Dirty();
            //  Effect.server.Run("assets/bundled/prefabs/fx/build/promote_" + @enum.ToString().ToLower() + ".prefab", (BaseEntity)block, 0U, Vector3.zero, Vector3.zero, (Network.Connection)null, false);
            gr.count = _ins.config.time;
            yield break;
        }

        IEnumerator TryRemove(BasePlayer player, BaseEntity removeObject, RemoveType removeType)
        {
            if (removeObject == null)
            {
                PrintToChat(player, config.messages[2]);
                yield break;
            }
            yield return new WaitForSeconds(0.2f);
            bool can = CanRemoveEntity(player, removeObject, removeType);
            if (!can) yield break;
            yield return new WaitForEndOfFrame();
            if (removeType.Equals(RemoveType.All)) Removeall(removeObject);
            else if (removeType.Equals(RemoveType.Refund)) Refund(player, removeObject);
            else DoRemove(removeObject, player);
            yield break;
        }

        Dictionary<ulong, Timer> activegui = new Dictionary<ulong, Timer>();
        List<ulong> activeusers = new List<ulong>();
        private void OnActiveItemChanged(BasePlayer player, Item oldItem, Item newItem)
        {
            if (newItem != null)
            {
                if (newItem.info.itemid.Equals(200773292) || newItem.info.itemid.Equals(1803831286))
                {
                    if (player.GetComponent<ToolRemover>() || player.GetComponent<UpgradeConstruction>()) return;
                    destroynotif(player);
                    CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", GUIjson.Replace("{text}", config.messages[3]).Replace("{max}", helpstring));
                    activegui.Add(player.userID, timer.Once(7f, () =>
                    {
                        destroynotif(player);
                    }));
                }
                else if (newItem.info.itemid.Equals(1525520776))
                {
                    if (player.GetComponent<ToolRemover>() || player.GetComponent<UpgradeConstruction>()) return;
                    destroynotif(player);
                    CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", GUIjson.Replace("{text}", config.messages[4]).Replace("{max}", config.AnchorMax));
                    activegui.Add(player.userID, timer.Once(7f, () =>
                    {
                        destroynotif(player);
                    }));
                }
                else if (activegui.ContainsKey(player.userID))
                {
                    destroynotif(player);
                }
            }
            else if (activegui.ContainsKey(player.userID))
            {
                destroynotif(player);
            }
        }

        void destroynotif(BasePlayer player)
        {
            if (activegui.ContainsKey(player.userID))
            {
                activegui[player.userID]?.Destroy();
                activegui.Remove(player.userID);
            }
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "RemoverGUIBackground");
        }

        static int constructionColl = LayerMask.GetMask(new string[] { "Construction", "Deployable", "Prevent Building", "Deployed" });

        void Removeall(BaseEntity removeObject)
        {
            ServerMgr.Instance.StartCoroutine(Loop(removeObject.transform.position));
        }

        private static IEnumerator Loop(Vector3 pos)
        {
            List<BaseEntity> list = Pool.GetList<BaseEntity>();
            yield return new WaitForEndOfFrame();
            Vis.Entities<BaseEntity>(pos, 10f, list, constructionColl);
            yield return new WaitForEndOfFrame();
            foreach (var z in list)
            {
                z.KillMessage();
                yield return new WaitForSeconds(0.05f);
            }
        }

        void DoRemove(BaseEntity removeObject, BasePlayer player)
        {
            if (removeObject is StorageContainer && removeObject.GetComponent<StorageContainer>().inventory.itemList.Count > 0)
            {
                PrintToChat(player, config.messages[5]);
                return;
            }
            EffectNetwork.Send(new Effect("assets/bundled/prefabs/fx/item_break.prefab", removeObject, 0, Vector3.up, Vector3.zero) { scale = UnityEngine.Random.Range(0f, 1f) });

            removeObject.KillMessage();
        }

        void Refund(BasePlayer player, BaseEntity entity)
        {
            if (entity == null) return;
            if (entity is BuildingBlock)
            {
                BuildingBlock buildingblock = entity as BuildingBlock;
                ConstructionGrade grade = buildingblock?.blockDefinition.grades[(int)buildingblock.grade];
                if (grade != null)
                {

                    float refundRate = buildingblock.healthFraction * (permission.UserHasPermission(player.UserIDString, "removeupgradev2.vip") ? 1f : config.procent);
                    foreach (ItemAmount ia in grade.costToBuild)
                    {
                        int amount = (int)(ia.amount * refundRate);
                        player.inventory.GiveItem(ItemManager.CreateByItemID(ia.itemid, amount));
                        player.Command("note.inv", ia.itemid, amount);
                    }
                }
                EffectNetwork.Send(new Effect("assets/bundled/prefabs/fx/item_break.prefab", entity, 0, Vector3.up, Vector3.zero) { scale = UnityEngine.Random.Range(0f, 1f) });
                entity.Kill();
            }
            else if (deployedToItem.ContainsKey(entity.prefabID))
            {
                if (entity.GetComponent<StorageContainer>()?.inventory.itemList.Count > 0)
                {
                    PrintToChat(player, config.messages[5]);
                    return;
                }
                if (entity is BaseOven)
                {
                    ItemAmount item = entity.GetComponent<BaseOven>().startupContents.FirstOrDefault();
                    if (item != null)
                    {
                        if (player.inventory.GetAmount(item.itemid) < item.amount)
                        {
                            PrintToChat(player, config.messages[6].Replace("{amount}", item.amount.ToString()));
                            return;
                        }

                        player.inventory.Take(null, item.itemid, (int)item.amount);
                        player.Command("note.inv", item.itemid, item.amount * -1f);
                    }
                }
                giveitem(player, deployedToItem[entity.prefabID], (BaseCombatEntity)entity, entity.skinID);
            }
        }

        void giveitem(BasePlayer player, int id, BaseCombatEntity pick, ulong skin)
        {
            Item createdItem = ItemManager.CreateByItemID(id, 1, skin);
            if (createdItem == null) return;
            if (pick.pickup.setConditionFromHealth && createdItem.hasCondition) createdItem.conditionNormalized = Mathf.Clamp01(pick.healthFraction - pick.pickup.subtractCondition);
            player.GiveItem(createdItem, BaseEntity.GiveItemReason.PickedUp);
            pick.OnPickedUp(createdItem, player);
            pick.Kill();
        }

        [PluginReference] Plugin NoEscape, RaidBlock, RaidZone;

        bool CanRemoveEntity(BasePlayer player, BaseEntity entity, RemoveType removeType)
        {
            if (entity.IsDestroyed)
            {
                PrintToChat(player, config.messages[7]);
                return false;
            }

            if (entity.OwnerID == 0)
            {
                PrintToChat(player, config.messages[8]);
                return false;
            }

            if (removeType == RemoveType.Admin || removeType == RemoveType.All) return true;

            if (entity.OwnerID != player.userID && !config.cupboard)
            {
                if (config.friends)
                {
                }
            }

            DateTime time;
            if (entity is DecayEntity && !permission.UserHasPermission(player.UserIDString, "removeupgradev2.vip") && config.blocktime > 0 && (!canremove.TryGetValue(entity.net.ID, out time) || time < DateTime.Now))
            {
                PrintToChat(player, config.messages[9]);
                return false;
            }

            if (NoEscape != null && (config.whatblock == 3 && (double)NoEscape?.Call("IsRaid", player) > 0 || config.whatblock == 0 && (double)NoEscape?.Call("ApiGetTime", player.userID) > 0 || config.whatblock == 1 && (bool)NoEscape?.Call("IsRaidBlocked", player)) || config.whatblock == 2 && (int)NoEscape?.Call("ApiGetTime", player.userID) > 0 || RaidBlock != null && RaidBlock.Call<bool>("IsRaidBlocked", player) || RaidZone != null && RaidZone.Call<bool>("HasBlock", player.userID))
            {
                PrintToChat(player, config.messages[10]);
                return false;
            }

            if (!player.CanBuild())
            {
                PrintToChat(player, config.messages[12]);
                return false;
            }
            if (!BaseEntity.RPC_Server.MaxDistance.Test("DoImmediateDemolish", entity, player, 3f))
            {
                PrintToChat(player, "Далеко от обьекта!");
                return false;
            }
            return true;
        }

        [ChatCommand("remove")]
        void cmdChatRemove(BasePlayer player, string command, string[] args)
        {
            removecommand(player, args);
        }

        [ChatCommand("up")]
        void cmdChatUpgrade(BasePlayer player, string command, string[] args)
        {
            upgradecommand(player, args);
        }

        [ConsoleCommand("upgrade.use")]
        void ConsoleUP(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            upgradecommand(player, arg.Args);
        }

        [ConsoleCommand("remove.use")]
        void ConsoleRemove(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            removecommand(player, arg.Args);
        }

        void removecommand(BasePlayer player, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "removeupgrade.use") && !permission.UserHasPermission(player.UserIDString, "removeupgradev2.remove"))
            {
                SendReply(player, config.messages[13]);
                return;
            }
            UpgradeConstruction tool = player.GetComponent<UpgradeConstruction>();
            if (tool != null)
            {
                tool.DoDestroy();
                return;
            }
            ToolRemover toolremover = player.GetComponent<ToolRemover>();
            if (toolremover != null)
            {
                toolremover.DoDestroy();
                return;
            }
            int removeTime = config.time;
            RemoveType removetype = permission.UserHasPermission(player.UserIDString, "removeupgrade.refund") ? RemoveType.Refund : RemoveType.Normal;

            if (args.Length != 0)
            {
                switch (args[0])
                {
                    case "admin":
                        if (!permission.UserHasPermission(player.UserIDString, "removeupgrade.admin") && !player.IsAdmin)
                        {
                            SendReply(player, config.messages[13]);
                            return;
                        }
                        removetype = RemoveType.Admin;
                        if (args.Length > 1) int.TryParse(args[1], out removeTime);
                        break;
                    case "all":
                        if (!permission.UserHasPermission(player.UserIDString, "removeupgrade.admin") && !player.IsAdmin)
                        {
                            SendReply(player, config.messages[13]);
                            return;
                        }
                        removetype = RemoveType.All;
                        if (args.Length > 1) int.TryParse(args[1], out removeTime);
                        break;
                    default:
                        int.TryParse(args[0], out removeTime);
                        break;
                }
            }
            if (removeTime == 0) removeTime = config.time;

            if (activegui != null && activegui.ContainsKey(player.userID))
            {
                activegui[player.userID]?.Destroy();
                activegui.Remove(player.userID);
            }
            toolremover = player.gameObject.AddComponent<ToolRemover>();

            PrintToChat(player, config.messages[14]);

            toolremover.SetCount(removeTime);
            toolremover.removeType = removetype;
        }


        #region Upgrade
        [ConsoleCommand("upgrade.off")]
        void ConsoleUasd1P(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            player.GetComponent<UpgradeConstruction>()?.DoDestroy();
        }

        [ConsoleCommand("remove.off")]
        void ConsoleUasd(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            player.GetComponent<ToolRemover>()?.DoDestroy();
        }

        bool IsUpgrade(BasePlayer player)
        {
            UpgradeConstruction uc = player.GetComponent<UpgradeConstruction>();
            if (uc == null) return false;
            return true;
        }

        bool IsRemove(BasePlayer player)
        {
            ToolRemover re = player.GetComponent<ToolRemover>();
            if (re == null) return false;
            return true;
        }

        void upgradecommand(BasePlayer player, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "removeupgrade.use") && !permission.UserHasPermission(player.UserIDString, "removeupgradev2.up"))
            {
                SendReply(player, config.messages[13]);
                return;
            }
            int current = 0;
            if (args != null && args.Length > 0) int.TryParse(args[0], out current);
            UpgradeConstruction tool = player.GetComponent<UpgradeConstruction>();
            if (tool != null)
            {
                if (current != 0) tool.changegrade(current);
                else tool.changegrade(tool.currentgrade + 1);
                return;
            }

            if (activegui != null && activegui.ContainsKey(player.userID))
            {
                activegui[player.userID]?.Destroy();
                activegui.Remove(player.userID);
            }
            tool = player.gameObject.AddComponent<UpgradeConstruction>();
            if (current != 0) tool.changegrade(current);
            PrintToChat(player, config.messages[15]);
        }

        class UpgradeConstruction : MonoBehaviour
        {
            BasePlayer player;
            public int count = _ins.config.time;
            public int currentgrade = 2;

            void Awake()
            {
                player = GetComponent<BasePlayer>();
                if (player == null) Destroy(this);
                ToolRemover tool = player.GetComponent<ToolRemover>();
                if (tool != null) tool.DoDestroy();
                InvokeRepeating("UpdateGUI", 0, 1f);
            }

            public void changegrade(int change)
            {
                if (change > 4) currentgrade = 1;
                else if (change <= 0) currentgrade = 2;
                else currentgrade = change;
                if (change != 0) PrintToChat(player, _ins.config.messages[16].Replace("{grade}", _ins.config.messages2[currentgrade]));
                count = _ins.config.time;
                UpdateGUI();
                EffectNetwork.Send(new Effect("assets/bundled/prefabs/fx/notice/loot.drag.grab.fx.prefab", player, 0, Vector3.up, Vector3.zero) { scale = UnityEngine.Random.Range(0f, 1f) }, player.net.connection);
            }

            void UpdateGUI()
            {
                if (count.Equals(0))
                {
                    DoDestroy();
                    return;
                }
                if (!_ins.config.disablegui)
                {
                    CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "RemoverGUIBackground");
                    CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", GUIjson.Replace("{text}", _ins.config.messages[17].Replace("{grade}", _ins.config.messages2[currentgrade]).Replace("{count}", count.ToString())).Replace("{max}", _ins.config.AnchorMax));
                }
                count--;
            }

            public void DoDestroy()
            {
                Destroy(this);
            }

            void OnDestroy()
            {
                if (!_ins.config.disablegui) CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "RemoverGUIBackground");
                PrintToChat(player, _ins.config.messages[18]);
            }
        }

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null) return;
            if (entity is BasePlayer)
            {
                BasePlayer player = entity.ToPlayer();
                if (player == null) return;
                ToolRemover tool = player.GetComponent<ToolRemover>();
                if (tool != null) tool.DoDestroy();
                UpgradeConstruction tool2 = player.GetComponent<UpgradeConstruction>();
                if (tool2 != null) tool2.DoDestroy();
            }
        }

        private void OnEntityBuilt(Planner plan, GameObject go)
        {
            if (plan == null || go == null) return;
            BasePlayer player = plan.GetOwnerPlayer();
            if (player == null) return;
            UpgradeConstruction gr = player.GetComponent<UpgradeConstruction>();
            if (gr == null) return;
            BuildingBlock block = go.GetComponent<BuildingBlock>();
            if (block == null) return;
            ServerMgr.Instance.StartCoroutine(TryUpgrade(player, block, gr));
        }
        #endregion
    }

}


// --- End of file: RemoveUpgradeV2.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/CopyPaste.cs ---
// --- Original Local Path: KualaRust/CopyPaste.cs ---

﻿//If debug is defined it will add a stopwatch to the paste and copydata which can be used to profile copying and pasting.
//#define DEBUG

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Linq;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using Graphics = System.Drawing.Graphics;

/*
 * CREDITS
 *
 * Orange - Saving ContainerIOEntity
 * UIP88 - Turrets fix
 * bsdinis - Wire fix
 * nivex - Ownership option, sign fix
 * DezLife - CCTV fix
 * 
 */

namespace Oxide.Plugins
{
    [Info("Copy Paste", "misticos", "4.1.27")] // Wulf skipped 24 :(
    [Description("Copy and paste buildings to save them or move them")]
    public class CopyPaste : RustPlugin
    {
        private int _copyLayer =
                LayerMask.GetMask("Construction", "Prevent Building", "Construction Trigger", "Trigger", "Deployed",
                    "Default", "Ragdoll"),
            _groundLayer = LayerMask.GetMask("Terrain", "Default"),
            _rayCopy = LayerMask.GetMask("Construction", "Deployed", "Tree", "Resource", "Prevent Building"),
            _rayPaste = LayerMask.GetMask("Construction", "Deployed", "Tree", "Terrain", "World", "Water",
                "Prevent Building");

        private string _copyPermission = "copypaste.copy",
            _listPermission = "copypaste.list",
            _pastePermission = "copypaste.paste",
            _pastebackPermission = "copypaste.pasteback",
            _undoPermission = "copypaste.undo",
            _serverId = "Server",
            _subDirectory = "copypaste/";

        private Dictionary<string, Stack<List<BaseEntity>>> _lastPastes =
            new Dictionary<string, Stack<List<BaseEntity>>>();

        private Dictionary<string, SignSize> _signSizes = new Dictionary<string, SignSize>
        {
            //{"spinner.wheel.deployed", new SignSize(512, 512)},
            {"sign.pictureframe.landscape", new SignSize(256, 128)},
            {"sign.pictureframe.tall", new SignSize(128, 512)},
            {"sign.pictureframe.portrait", new SignSize(128, 256)},
            {"sign.pictureframe.xxl", new SignSize(1024, 512)},
            {"sign.pictureframe.xl", new SignSize(512, 512)},
            {"sign.small.wood", new SignSize(128, 64)},
            {"sign.medium.wood", new SignSize(256, 128)},
            {"sign.large.wood", new SignSize(256, 128)},
            {"sign.huge.wood", new SignSize(512, 128)},
            {"sign.hanging.banner.large", new SignSize(64, 256)},
            {"sign.pole.banner.large", new SignSize(64, 256)},
            {"sign.post.single", new SignSize(128, 64)},
            {"sign.post.double", new SignSize(256, 256)},
            {"sign.post.town", new SignSize(256, 128)},
            {"sign.post.town.roof", new SignSize(256, 128)},
            {"sign.hanging", new SignSize(128, 256)},
            {"sign.hanging.ornate", new SignSize(256, 128)},
            {"sign.neon.xl.animated", new SignSize(250, 250)},
            {"sign.neon.xl", new SignSize(250, 250)},
            {"sign.neon.125x215.animated", new SignSize(215, 125)},
            {"sign.neon.125x215", new SignSize(215, 125)},
            {"sign.neon.125x125", new SignSize(125, 125)},
        };

        private List<BaseEntity.Slot> _checkSlots = new List<BaseEntity.Slot>
        {
            BaseEntity.Slot.Lock,
            BaseEntity.Slot.UpperModifier,
            BaseEntity.Slot.MiddleModifier,
            BaseEntity.Slot.LowerModifier
        };

        public enum CopyMechanics
        {
            Building,
            Proximity
        }

        private class SignSize
        {
            public int Width;
            public int Height;

            public SignSize(int width, int height)
            {
                Width = width;
                Height = height;
            }
        }

        //Config

        private ConfigData _config;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Copy Options")]
            public CopyOptions Copy { get; set; }

            [JsonProperty(PropertyName = "Paste Options")]
            public PasteOptions Paste { get; set; }

            [JsonProperty(PropertyName =
                "Amount of entities to paste per batch. Use to tweak performance impact of pasting")]
            [DefaultValue(15)]
            public int PasteBatchSize = 15;

            [JsonProperty(PropertyName =
                "Amount of entities to copy per batch. Use to tweak performance impact of copying")]
            [DefaultValue(100)]
            public int CopyBatchSize = 100;

            [JsonProperty(PropertyName =
                "Amount of entities to undo per batch. Use to tweak performance impact of undoing")]
            [DefaultValue(15)]
            public int UndoBatchSize = 15;

            [JsonProperty(PropertyName = "Enable data saving feature")]
            [DefaultValue(true)]
            public bool DataSaving = true;

            public class CopyOptions
            {
                [JsonProperty(PropertyName = "Check radius from each entity (true/false)")]
                [DefaultValue(true)]
                public bool EachToEach { get; set; } = true;

                [JsonProperty(PropertyName = "Share (true/false)")]
                [DefaultValue(false)]
                public bool Share { get; set; } = false;

                [JsonProperty(PropertyName = "Tree (true/false)")]
                [DefaultValue(false)]
                public bool Tree { get; set; } = false;

                [JsonProperty(PropertyName = "Default radius to look for entities from block")]
                [DefaultValue(3.0f)]
                public float Radius { get; set; } = 3.0f;
            }

            public class PasteOptions
            {
                [JsonProperty(PropertyName = "Auth (true/false)")]
                [DefaultValue(false)]
                public bool Auth { get; set; } = false;

                [JsonProperty(PropertyName = "Deployables (true/false)")]
                [DefaultValue(true)]
                public bool Deployables { get; set; } = true;

                [JsonProperty(PropertyName = "Inventories (true/false)")]
                [DefaultValue(true)]
                public bool Inventories { get; set; } = true;

                [JsonProperty(PropertyName = "Vending Machines (true/false)")]
                [DefaultValue(true)]
                public bool VendingMachines { get; set; } = true;

                [JsonProperty(PropertyName = "Stability (true/false)")]
                [DefaultValue(true)]
                public bool Stability { get; set; } = true;

                [JsonProperty(PropertyName = "EntityOwner (true/false)")]
                [DefaultValue(true)]
                public bool EntityOwner { get; set; } = true;
            }
        }

        private void LoadVariables()
        {
            Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;

            _config = Config.ReadObject<ConfigData>();

            Config.WriteObject(_config, true);
        }

        protected override void LoadDefaultConfig()
        {
            var configData = new ConfigData
            {
                Copy = new ConfigData.CopyOptions(),
                Paste = new ConfigData.PasteOptions()
            };

            Config.WriteObject(configData, true);
        }

        //Hooks

        private void Init()
        {
            permission.RegisterPermission(_copyPermission, this);
            permission.RegisterPermission(_listPermission, this);
            permission.RegisterPermission(_pastePermission, this);
            permission.RegisterPermission(_pastebackPermission, this);
            permission.RegisterPermission(_undoPermission, this);

            var compiledLangs = new Dictionary<string, Dictionary<string, string>>();

            foreach (var line in _messages)
            {
                foreach (var translate in line.Value)
                {
                    if (!compiledLangs.ContainsKey(translate.Key))
                        compiledLangs[translate.Key] = new Dictionary<string, string>();

                    compiledLangs[translate.Key][line.Key] = translate.Value;
                }
            }

            foreach (var cLangs in compiledLangs)
            {
                lang.RegisterMessages(cLangs.Value, this, cLangs.Key);
            }
        }

        private void OnServerInitialized()
        {
            LoadVariables();

            Vis.colBuffer = new Collider[8192 * 16];

            JsonConvert.DefaultSettings = () => new JsonSerializerSettings
            {
                Formatting = Formatting.Indented,
                ReferenceLoopHandling = ReferenceLoopHandling.Ignore
            };
        }

        #region API

        private object TryCopyFromSteamId(ulong userId, string filename, string[] args, Action callback = null)
        {
            var player = BasePlayer.FindByID(userId);

            if (player == null)
                return Lang("NOT_FOUND_PLAYER", userId.ToString());

            RaycastHit hit;

            if (!Physics.Raycast(player.eyes.HeadRay(), out hit, 1000f, _rayCopy))
                return Lang("NO_ENTITY_RAY", player.UserIDString);

            return TryCopy(hit.point, hit.GetEntity().GetNetworkRotation().eulerAngles, filename,
                DegreeToRadian(player.GetNetworkRotation().eulerAngles.y), args, player, callback);
        }

        private object TryPasteFromSteamId(ulong userId, string filename, string[] args, Action callback = null)
        {
            var player = BasePlayer.FindByID(userId);

            if (player == null)
                return Lang("NOT_FOUND_PLAYER", player.UserIDString);

            RaycastHit hit;

            if (!Physics.Raycast(player.eyes.HeadRay(), out hit, 1000f, _rayPaste))
                return Lang("NO_ENTITY_RAY", player.UserIDString);

            return TryPaste(hit.point, filename, player, DegreeToRadian(player.GetNetworkRotation().eulerAngles.y),
                args, callback: callback);
        }

        private object TryPasteFromVector3(Vector3 pos, float rotationCorrection, string filename, string[] args,
            Action callback = null)
        {
            return TryPaste(pos, filename, null, rotationCorrection, args, callback: callback);
        }

        #endregion

        //Other methods

        private object CheckCollision(HashSet<Dictionary<string, object>> entities, Vector3 startPos, float radius)
        {
            foreach (var entityobj in entities)
            {
                if (Physics.CheckSphere((Vector3) entityobj["position"], radius, _copyLayer))
                    return Lang("BLOCKING_PASTE");
            }

            return true;
        }

        private bool CheckPlaced(string prefabname, Vector3 pos, Quaternion rot)
        {
            const float maxDiff = 0.01f;

            var ents = new List<BaseEntity>();
            Vis.Entities(pos, maxDiff, ents);

            foreach (var ent in ents)
            {
                if (ent.PrefabName != prefabname)
                    continue;

                if (Vector3.Distance(ent.transform.position, pos) > maxDiff)
                {
                    continue;
                }

                if (Vector3.Distance(ent.transform.rotation.eulerAngles, rot.eulerAngles) > maxDiff)
                {
                    continue;
                }

                return true;
            }

            return false;
        }

        private object CmdPasteBack(BasePlayer player, string[] args)
        {
            var userIdString = player == null ? _serverId : player.UserIDString;

            if (args.Length < 1)
                return Lang("SYNTAX_PASTEBACK", userIdString);

            var success = TryPasteBack(args[0], player, args.Skip(1).ToArray());

            if (success is string)
                return (string) success;

            return true;
        }

        private object CmdUndo(string userIdString, string[] args)
        {
            var player = BasePlayer.Find(userIdString);
            if (!_lastPastes.ContainsKey(userIdString))
                return Lang("NO_PASTED_STRUCTURE", userIdString);

            var entities = new HashSet<BaseEntity>(_lastPastes[userIdString].Pop().ToList());

            UndoLoop(entities, player);

            return true;
        }

        private void UndoLoop(HashSet<BaseEntity> entities, BasePlayer player, int count = 0)
        {
            foreach (var storageContainer in entities.OfType<StorageContainer>().Where(x => !x.IsDestroyed))
            {
                storageContainer.Kill();
            }

            // Take an amount of entities from the entity list (defined in config) and kill them. Will be repeated for every tick until there are no entities left.
            entities
                .Take(_config.UndoBatchSize)
                .ToList()
                .ForEach(p =>
                {
                    entities.Remove(p);

                    // Cleanup the hotspot beloning to the node.
                    var ore = p as OreResourceEntity;
                    if (ore != null)
                    {
                        ore.CleanupBonus();
                    }

                    if (p != null && !p.IsDestroyed)
                        p.Kill();
                });

            // If it gets stuck in infinite loop break the loop.
            if (count != 0 && entities.Count != 0 && entities.Count == count)
            {
                if (player != null)
                    SendReply(player, "Undo cancelled because of infinite loop.");
                else
                    Puts("Undo cancelled because of infinite loop.");
                return;
            }

            if (entities.Count > 0)
                NextTick(() => UndoLoop(entities, player, entities.Count));
            else
            {
                if (player != null)
                    SendReply(player, Lang("UNDO_SUCCESS", player.UserIDString));
                else
                    Puts(Lang("UNDO_SUCCESS"));

                if (_lastPastes[player?.UserIDString ?? _serverId].Count == 0)
                    _lastPastes.Remove(player?.UserIDString ?? _serverId);
            }
        }

        private void Copy(Vector3 sourcePos, Vector3 sourceRot, string filename, float rotationCorrection,
            CopyMechanics copyMechanics, float range, bool saveTree, bool saveShare, bool eachToEach, BasePlayer player,
            Action callback)
        {
            var currentLayer = _copyLayer;

            if (saveTree)
                currentLayer |= LayerMask.GetMask("Tree");

            var copyData = new CopyData
            {
                Filename = filename,
                CurrentLayer = currentLayer,
                RotCor = rotationCorrection,
                Range = range,
                SaveShare = saveShare,
                SaveTree = saveTree,
                CopyMechanics = copyMechanics,
                EachToEach = eachToEach,
                SourcePos = sourcePos,
                SourceRot = sourceRot,
                Player = player,
                Callback = callback
            };

            copyData.CheckFrom.Push(sourcePos);

            NextTick(() => CopyLoop(copyData));
            ;
        }

        // Main loop for copy, will fetch all the data needed. Is called every tick untill copy is done (can't find any entities)
        private void CopyLoop(CopyData copyData)
        {
            var checkFrom = copyData.CheckFrom;
            var houseList = copyData.HouseList;
            var buildingId = copyData.BuildingId;
            var copyMechanics = copyData.CopyMechanics;
            var batchSize = checkFrom.Count < _config.CopyBatchSize ? checkFrom.Count : _config.CopyBatchSize;

            for (var i = 0; i < batchSize; i++)
            {
                if (checkFrom.Count == 0)
                    break;

                var list = Pool.GetList<BaseEntity>();
                Vis.Entities(checkFrom.Pop(), copyData.Range, list, copyData.CurrentLayer);

                foreach (var entity in list)
                {
                    if (!houseList.Add(entity))
                        continue;

                    if (copyMechanics == CopyMechanics.Building)
                    {
                        var buildingBlock = entity.GetComponentInParent<BuildingBlock>();

                        if (buildingBlock != null)
                        {
                            if (buildingId == 0)
                                buildingId = buildingBlock.buildingID;

                            if (buildingId != buildingBlock.buildingID)
                                continue;
                        }
                    }

                    if (copyData.EachToEach)
                        checkFrom.Push(entity.transform.position);
                    if (entity.GetComponent<BaseLock>() != null)
                        continue;
                    copyData.RawData.Add(EntityData(entity, entity.transform.position,
                        entity.transform.rotation.eulerAngles / 57.29578f, copyData));
                }

                copyData.BuildingId = buildingId;
            }

            if (checkFrom.Count > 0)
            {
                NextTick(() => CopyLoop(copyData));
            }
            else
            {
                var path = _subDirectory + copyData.Filename;
                var datafile = Interface.Oxide.DataFileSystem.GetDatafile(path);

                datafile.Clear();

                var sourcePos = copyData.SourcePos;

                datafile["default"] = new Dictionary<string, object>
                {
                    {
                        "position", new Dictionary<string, object>
                        {
                            {"x", sourcePos.x.ToString()},
                            {"y", sourcePos.y.ToString()},
                            {"z", sourcePos.z.ToString()}
                        }
                    },
                    {"rotationy", copyData.SourceRot.y.ToString()},
                    {"rotationdiff", copyData.RotCor.ToString()}
                };

                datafile["entities"] = copyData.RawData;
                datafile["protocol"] = new Dictionary<string, object>
                {
                    {"items", 2},
                    {"version", Version}
                };

                Interface.Oxide.DataFileSystem.SaveDatafile(path);

                SendReply(copyData.Player, Lang("COPY_SUCCESS", copyData.Player.UserIDString, copyData.Filename));

                copyData.Callback?.Invoke();

                Interface.CallHook("OnCopyFinished", copyData.RawData, copyData.Filename);
            }
        }

        private float DegreeToRadian(float angle)
        {
            return (float) (Math.PI * angle / 180.0f);
        }

        private Dictionary<string, object> EntityData(BaseEntity entity, Vector3 entPos, Vector3 entRot,
            CopyData copyData)
        {
            var normalizedPos = NormalizePosition(copyData.SourcePos, entPos, copyData.RotCor);

            entRot.y -= copyData.RotCor;

            var data = new Dictionary<string, object>
            {
                {"prefabname", entity.PrefabName},
                {"skinid", entity.skinID},
                {"flags", TryCopyFlags(entity)},
                {
                    "pos", new Dictionary<string, object>
                    {
                        {"x", normalizedPos.x.ToString()},
                        {"y", normalizedPos.y.ToString()},
                        {"z", normalizedPos.z.ToString()}
                    }
                },
                {
                    "rot", new Dictionary<string, object>
                    {
                        {"x", entRot.x.ToString()},
                        {"y", entRot.y.ToString()},
                        {"z", entRot.z.ToString()}
                    }
                },
                {"ownerid", entity.OwnerID}
            };

            TryCopySlots(entity, data, copyData.SaveShare);

            var buildingblock = entity as BuildingBlock;

            if (buildingblock != null)
            {
                data.Add("grade", buildingblock.grade);
            }

            var box = entity as StorageContainer;
            if (box?.inventory != null)
            {
                var itemlist = new List<object>();

                foreach (var item in box.inventory.itemList)
                {
                    var itemdata = new Dictionary<string, object>
                    {
                        {"condition", item.condition.ToString()},
                        {"id", item.info.itemid},
                        {"amount", item.amount},
                        {"skinid", item.skin},
                        {"position", item.position},
                        {"blueprintTarget", item.blueprintTarget}
                    };

                    if (!string.IsNullOrEmpty(item.text))
                        itemdata["text"] = item.text;

                    var heldEnt = item.GetHeldEntity();

                    if (heldEnt != null)
                    {
                        var projectiles = heldEnt.GetComponent<BaseProjectile>();

                        if (projectiles != null)
                        {
                            var magazine = projectiles.primaryMagazine;

                            if (magazine != null)
                            {
                                itemdata.Add("magazine", new Dictionary<string, object>
                                {
                                    {magazine.ammoType.itemid.ToString(), magazine.contents}
                                });
                            }
                        }
                    }

                    if (item?.contents?.itemList != null)
                    {
                        var contents = new List<object>();

                        foreach (var itemContains in item.contents.itemList)
                        {
                            contents.Add(new Dictionary<string, object>
                            {
                                {"id", itemContains.info.itemid},
                                {"amount", itemContains.amount}
                            });
                        }

                        itemdata["items"] = contents;
                    }

                    itemlist.Add(itemdata);
                }

                data.Add("items", itemlist);
            }

            var box2 = entity as ContainerIOEntity;
            if (box2 != null)
            {
                var itemlist = new List<object>();

                foreach (var item in box2.inventory.itemList)
                {
                    var itemdata = new Dictionary<string, object>
                    {
                        {"condition", item.condition.ToString()},
                        {"id", item.info.itemid},
                        {"amount", item.amount},
                        {"skinid", item.skin},
                        {"position", item.position},
                        {"blueprintTarget", item.blueprintTarget}
                    };

                    if (!string.IsNullOrEmpty(item.text))
                        itemdata["text"] = item.text;

                    var heldEnt = item.GetHeldEntity();

                    if (heldEnt != null)
                    {
                        var projectiles = heldEnt.GetComponent<BaseProjectile>();

                        if (projectiles != null)
                        {
                            var magazine = projectiles.primaryMagazine;

                            if (magazine != null)
                            {
                                itemdata.Add("magazine", new Dictionary<string, object>
                                {
                                    {magazine.ammoType.itemid.ToString(), magazine.contents}
                                });
                            }
                        }
                    }

                    if (item?.contents?.itemList != null)
                    {
                        var contents = new List<object>();

                        foreach (var itemContains in item.contents.itemList)
                        {
                            contents.Add(new Dictionary<string, object>
                            {
                                {"id", itemContains.info.itemid},
                                {"amount", itemContains.amount}
                            });
                        }

                        itemdata["items"] = contents;
                    }

                    itemlist.Add(itemdata);
                }

                data.Add("items", itemlist);
            }

            var sign = entity as Signage;
            if (sign != null && sign.textureIDs != null)
            {
                data.Add("sign", new Dictionary<string, object>
                {
                    {"locked", sign.IsLocked()}
                });

                var signData = (Dictionary<string, object>) data["sign"];

                for (int num = 0; num < sign.textureIDs.Length; num++)
                {
                    var textureId = sign.textureIDs[num];
                    if (textureId == 0)
                        continue;

                    var imageByte = FileStorage.server.Get(textureId, FileStorage.Type.png, sign.net.ID);
                    if (imageByte != null)
                    {
                        signData.Add($"texture{num}", Convert.ToBase64String(imageByte));
                    }
                }

                signData["amount"] = sign.textureIDs.Length;
            }

            if (copyData.SaveShare)
            {
                var sleepingBag = entity as SleepingBag;

                if (sleepingBag != null)
                {
                    data.Add("sleepingbag", new Dictionary<string, object>
                    {
                        {"niceName", sleepingBag.niceName},
                        {"deployerUserID", sleepingBag.deployerUserID},
                        {"isPublic", sleepingBag.IsPublic()}
                    });
                }

                var cupboard = entity as BuildingPrivlidge;

                if (cupboard != null)
                {
                    data.Add("cupboard", new Dictionary<string, object>
                    {
                        {"authorizedPlayers", cupboard.authorizedPlayers.Select(y => y.userid).ToList()}
                    });
                }

                var autoTurret = entity as AutoTurret;

                if (autoTurret != null)
                {
                    data.Add("autoturret", new Dictionary<string, object>
                    {
                        {"authorizedPlayers", autoTurret.authorizedPlayers.Select(p => p.userid).ToList()}
                    });
                }
            }

            var cctvRc = entity as CCTV_RC;
            if (cctvRc != null)
            {
                data.Add("cctv", new Dictionary<string, object>
                {
                    {"yaw", cctvRc.yawAmount},
                    {"pitch", cctvRc.pitchAmount},
                    {"rcIdentifier", cctvRc.rcIdentifier}
                });
            }

            var vendingMachine = entity as VendingMachine;

            if (vendingMachine != null)
            {
                var sellOrders = new List<object>();

                foreach (var vendItem in vendingMachine.sellOrders.sellOrders)
                {
                    sellOrders.Add(new Dictionary<string, object>
                    {
                        {"itemToSellID", vendItem.itemToSellID},
                        {"itemToSellAmount", vendItem.itemToSellAmount},
                        {"currencyID", vendItem.currencyID},
                        {"currencyAmountPerItem", vendItem.currencyAmountPerItem},
                        {"inStock", vendItem.inStock},
                        {"currencyIsBP", vendItem.currencyIsBP},
                        {"itemToSellIsBP", vendItem.itemToSellIsBP}
                    });
                }

                data.Add("vendingmachine", new Dictionary<string, object>
                {
                    {"shopName", vendingMachine.shopName},
                    {"isBroadcasting", vendingMachine.IsBroadcasting()},
                    {"sellOrders", sellOrders}
                });
            }

            var ioEntity = entity as IOEntity;

            if (ioEntity != null)
            {
                var ioData = new Dictionary<string, object>();
                var inputs = ioEntity.inputs.Select(input => new Dictionary<string, object>
                    {
                        {"connectedID", input.connectedTo.entityRef.uid},
                        {"connectedToSlot", input.connectedToSlot},
                        {"niceName", input.niceName},
                        {"type", (int) input.type}
                    })
                    .Cast<object>()
                    .ToList();

                ioData.Add("inputs", inputs);

                var outputs = new List<object>();
                foreach (var output in ioEntity.outputs)
                {
                    var ioConnection = new Dictionary<string, object>
                    {
                        {"connectedID", output.connectedTo.entityRef.uid},
                        {"connectedToSlot", output.connectedToSlot},
                        {"niceName", output.niceName},
                        {"type", (int) output.type},
                        {"linePoints", output.linePoints?.ToList() ?? new List<Vector3>()}
                    };

                    outputs.Add(ioConnection);
                }

                ioData.Add("outputs", outputs);
                ioData.Add("oldID", ioEntity.net.ID);
                var electricalBranch = ioEntity as ElectricalBranch;
                if (electricalBranch != null)
                {
                    ioData.Add("branchAmount", electricalBranch.branchAmount);
                }

                var counter = ioEntity as PowerCounter;
                if (counter != null)
                {
                    ioData.Add("targetNumber", counter.GetTarget());
                }

                var timerSwitch = ioEntity as TimerSwitch;
                if (timerSwitch != null)
                {
                    ioData.Add("timerLength", timerSwitch.timerLength);
                }

                var rfBroadcaster = ioEntity as IRFObject;
                if (rfBroadcaster != null)
                {
                    ioData.Add("frequency", rfBroadcaster.GetFrequency());
                }

                data.Add("IOEntity", ioData);
            }

            return data;
        }

        private object FindBestHeight(HashSet<Dictionary<string, object>> entities, Vector3 startPos)
        {
            var maxHeight = 0f;

            foreach (var entity in entities)
            {
                if (((string) entity["prefabname"]).Contains("/foundation/"))
                {
                    var foundHeight = GetGround((Vector3) entity["position"]);

                    if (foundHeight != null)
                    {
                        var height = (Vector3) foundHeight;

                        if (height.y > maxHeight)
                            maxHeight = height.y;
                    }
                }
            }

            maxHeight += 1f;

            return maxHeight;
        }

        private bool FindRayEntity(Vector3 sourcePos, Vector3 sourceDir, out Vector3 point, out BaseEntity entity,
            int rayLayer)
        {
            RaycastHit hitinfo;
            entity = null;
            point = Vector3.zero;

            if (!Physics.Raycast(sourcePos, sourceDir, out hitinfo, 1000f, rayLayer))
                return false;

            entity = hitinfo.GetEntity();
            point = hitinfo.point;

            return true;
        }

        private void FixSignage(Signage sign, byte[] imageBytes, int index)
        {
            if (!_signSizes.ContainsKey(sign.ShortPrefabName))
                return;

            var size = Math.Max(sign.paintableSources.Length, 1);
            if (sign.textureIDs == null || sign.textureIDs.Length != size)
            {
                Array.Resize(ref sign.textureIDs, size);
            }

            var resizedImage = ImageResize(imageBytes, _signSizes[sign.ShortPrefabName].Width,
                _signSizes[sign.ShortPrefabName].Height);

            sign.textureIDs[index] = FileStorage.server.Store(resizedImage, FileStorage.Type.png, sign.net.ID);
        }

        private object GetGround(Vector3 pos)
        {
            RaycastHit hitInfo;
            pos += new Vector3(0, 100, 0);

            if (Physics.Raycast(pos, Vector3.down, out hitInfo, 200, _groundLayer))
                return hitInfo.point;

            return null;
        }

        private int GetItemId(int itemId)
        {
            if (ReplaceItemId.ContainsKey(itemId))
                return ReplaceItemId[itemId];

            return itemId;
        }

        private bool HasAccess(BasePlayer player, string permName)
        {
            return player.IsAdmin || permission.UserHasPermission(player.UserIDString, permName);
        }

        private byte[] ImageResize(byte[] imageBytes, int width, int height)
        {
            Bitmap resizedImage = new Bitmap(width, height),
                sourceImage = new Bitmap(new MemoryStream(imageBytes));

            Graphics.FromImage(resizedImage).DrawImage(sourceImage, new Rectangle(0, 0, width, height),
                new Rectangle(0, 0, sourceImage.Width, sourceImage.Height), GraphicsUnit.Pixel);

            var ms = new MemoryStream();
            resizedImage.Save(ms, ImageFormat.Png);

            return ms.ToArray();
        }

        private string Lang(string key, string userId = null, params object[] args) =>
            string.Format(lang.GetMessage(key, this, userId), args);

        private Vector3 NormalizePosition(Vector3 initialPos, Vector3 currentPos, float diffRot)
        {
            var transformedPos = currentPos - initialPos;
            var newX = transformedPos.x * (float) Math.Cos(-diffRot) +
                       transformedPos.z * (float) Math.Sin(-diffRot);
            var newZ = transformedPos.z * (float) Math.Cos(-diffRot) -
                       transformedPos.x * (float) Math.Sin(-diffRot);

            transformedPos.x = newX;
            transformedPos.z = newZ;

            return transformedPos;
        }

        private void Paste(ICollection<Dictionary<string, object>> entities, Dictionary<string, object> protocol,
            bool ownership, Vector3 startPos, BasePlayer player, bool stability, float rotationCorrection,
            float heightAdj, bool auth, Action callback, string filename)
        {

            var ioEntities = new Dictionary<uint, Dictionary<string, object>>();
            uint buildingId = 0;

            //Settings

            var isItemReplace = !protocol.ContainsKey("items");

            var eulerRotation = new Vector3(0f, rotationCorrection * 57.2958f, 0f);
            var quaternionRotation = Quaternion.Euler(eulerRotation);

            var pasteData = new PasteData
            {
                HeightAdj = heightAdj,
                IsItemReplace = isItemReplace,
                Entities = entities,
                Player = player,
                QuaternionRotation = quaternionRotation,
                StartPos = startPos,
                Stability = stability,
                Auth = auth,
                Ownership = ownership,
                Callback = callback,
                Filename = filename
            };

            NextTick(() => PasteLoop(pasteData));
        }

        private void PasteLoop(PasteData pasteData)
        {
            var entities = pasteData.Entities;
            var todo = entities.Take(_config.PasteBatchSize).ToArray();
            var player = pasteData.Player;

            foreach (var data in todo)
            {
                entities.Remove(data);
                var prefabname = (string) data["prefabname"];
                var skinid = ulong.Parse(data["skinid"].ToString());
                var pos = (Vector3) data["position"];
                var rot = (Quaternion) data["rotation"];

                var ownerId = player?.userID ?? 0;
                if (data.ContainsKey("ownerid"))
                {
                    ownerId = Convert.ToUInt64(data["ownerid"]);
                }

                if (CheckPlaced(prefabname, pos, rot))
                    continue;

                if (prefabname.Contains("pillar"))
                    continue;

                // Used to copy locks for no reason in previous versions (is included in the slots info so no need to copy locks) so just skipping them.
                if (prefabname.Contains("locks"))
                    continue;

                var entity = GameManager.server.CreateEntity(prefabname, pos, rot);

                if (entity == null)
                    continue;

                entity.transform.position = pos;
                entity.transform.rotation = rot;

                if (player != null)
                    entity.SendMessage("SetDeployedBy", player, SendMessageOptions.DontRequireReceiver);

                if (pasteData.Ownership)
                    entity.OwnerID = ownerId;

                var buildingBlock = entity as BuildingBlock;

                if (buildingBlock != null)
                {
                    buildingBlock.blockDefinition = PrefabAttribute.server.Find<Construction>(buildingBlock.prefabID);
                    buildingBlock.SetGrade((BuildingGrade.Enum) data["grade"]);
                    if (!pasteData.Stability)
                        buildingBlock.grounded = true;
                }

                var decayEntity = entity as DecayEntity;

                if (decayEntity != null)
                {
                    if (pasteData.BuildingId == 0)
                        pasteData.BuildingId = BuildingManager.server.NewBuildingID();

                    decayEntity.AttachToBuilding(pasteData.BuildingId);
                }

                var stabilityEntity = entity as StabilityEntity;

                if (stabilityEntity != null)
                {
                    if (!stabilityEntity.grounded)
                    {
                        stabilityEntity.grounded = true;
                        pasteData.StabilityEntities.Add(stabilityEntity);
                    }
                }

                entity.skinID = skinid;
                entity.Spawn();

                var baseCombat = entity as BaseCombatEntity;

                if (baseCombat != null)
                    baseCombat.SetHealth(baseCombat.MaxHealth());

                pasteData.PastedEntities.AddRange(TryPasteSlots(entity, data, pasteData));

                var box = entity as StorageContainer;
                if (box != null)
                {
                    box.inventory.Clear();

                    var items = new List<object>();

                    if (data.ContainsKey("items"))
                        items = data["items"] as List<object>;

                    foreach (var itemDef in items)
                    {
                        var item = itemDef as Dictionary<string, object>;
                        var itemid = Convert.ToInt32(item["id"]);
                        var itemamount = Convert.ToInt32(item["amount"]);
                        var itemskin = ulong.Parse(item["skinid"].ToString());
                        var itemcondition = Convert.ToSingle(item["condition"]);

                        if (pasteData.IsItemReplace)
                            itemid = GetItemId(itemid);

                        var i = ItemManager.CreateByItemID(itemid, itemamount, itemskin);

                        if (i != null)
                        {
                            i.condition = itemcondition;

                            if (item.ContainsKey("text"))
                                i.text = item["text"].ToString();

                            if (item.ContainsKey("blueprintTarget"))
                            {
                                var blueprintTarget = Convert.ToInt32(item["blueprintTarget"]);

                                if (pasteData.IsItemReplace)
                                    blueprintTarget = GetItemId(blueprintTarget);

                                i.blueprintTarget = blueprintTarget;
                            }

                            if (item.ContainsKey("magazine"))
                            {
                                var heldent = i.GetHeldEntity();

                                if (heldent != null)
                                {
                                    var projectiles = heldent.GetComponent<BaseProjectile>();

                                    if (projectiles != null)
                                    {
                                        var magazine = item["magazine"] as Dictionary<string, object>;
                                        var ammotype = int.Parse(magazine.Keys.ToArray()[0]);
                                        var ammoamount = int.Parse(magazine[ammotype.ToString()].ToString());

                                        if (pasteData.IsItemReplace)
                                            ammotype = GetItemId(ammotype);

                                        projectiles.primaryMagazine.ammoType = ItemManager.FindItemDefinition(ammotype);
                                        projectiles.primaryMagazine.contents = ammoamount;
                                    }

                                    //TODO Doesn't add water to some containers

                                    if (item.ContainsKey("items"))
                                    {
                                        var itemContainsList = item["items"] as List<object>;

                                        foreach (var itemContains in itemContainsList)
                                        {
                                            var contents = itemContains as Dictionary<string, object>;

                                            var contentsItemId = Convert.ToInt32(contents["id"]);

                                            if (pasteData.IsItemReplace)
                                                contentsItemId = GetItemId(contentsItemId);

                                            i.contents.AddItem(ItemManager.FindItemDefinition(contentsItemId),
                                                Convert.ToInt32(contents["amount"]));
                                        }
                                    }
                                }
                            }

                            var targetPos = -1;

                            if (item.ContainsKey("position"))
                                targetPos = Convert.ToInt32(item["position"]);

                            i.position = targetPos;
                            box.inventory.Insert(i);
                        }
                    }
                }

                var autoTurret = entity as AutoTurret;
                if (autoTurret != null)
                {
                    var authorizedPlayers = new List<ulong>();

                    if (data.ContainsKey("autoturret"))
                    {
                        var autoTurretData = data["autoturret"] as Dictionary<string, object>;
                        authorizedPlayers = (autoTurretData["authorizedPlayers"] as List<object>)
                            .Select(Convert.ToUInt64).ToList();
                    }

                    if (player != null && !authorizedPlayers.Contains(player.userID) && pasteData.Auth)
                        authorizedPlayers.Add(player.userID);

                    foreach (var userId in authorizedPlayers)
                    {
                        autoTurret.authorizedPlayers.Add(new PlayerNameID
                        {
                            userid = Convert.ToUInt64(userId),
                            username = "Player"
                        });
                    }

                    autoTurret.SendNetworkUpdate();
                }

                var containerIo = entity as ContainerIOEntity;
                if (containerIo != null)
                {
                    containerIo.inventory.Clear();

                    var items = new List<object>();

                    if (data.ContainsKey("items"))
                        items = data["items"] as List<object>;

                    foreach (var itemDef in items)
                    {
                        var itemJson = itemDef as Dictionary<string, object>;
                        var itemid = Convert.ToInt32(itemJson["id"]);
                        var itemamount = Convert.ToInt32(itemJson["amount"]);
                        var itemskin = ulong.Parse(itemJson["skinid"].ToString());
                        var itemcondition = Convert.ToSingle(itemJson["condition"]);

                        if (pasteData.IsItemReplace)
                            itemid = GetItemId(itemid);

                        var item = ItemManager.CreateByItemID(itemid, itemamount, itemskin);

                        if (item != null)
                        {
                            item.condition = itemcondition;

                            if (itemJson.ContainsKey("text"))
                                item.text = itemJson["text"].ToString();

                            if (itemJson.ContainsKey("blueprintTarget"))
                            {
                                var blueprintTarget = Convert.ToInt32(itemJson["blueprintTarget"]);

                                if (pasteData.IsItemReplace)
                                    blueprintTarget = GetItemId(blueprintTarget);

                                item.blueprintTarget = blueprintTarget;
                            }

                            if (itemJson.ContainsKey("magazine"))
                            {
                                var heldent = item.GetHeldEntity();

                                if (heldent != null)
                                {
                                    var projectiles = heldent.GetComponent<BaseProjectile>();

                                    if (projectiles != null)
                                    {
                                        var magazine = itemJson["magazine"] as Dictionary<string, object>;
                                        var ammotype = int.Parse(magazine.Keys.ToArray()[0]);
                                        var ammoamount = int.Parse(magazine[ammotype.ToString()].ToString());

                                        if (pasteData.IsItemReplace)
                                            ammotype = GetItemId(ammotype);

                                        projectiles.primaryMagazine.ammoType = ItemManager.FindItemDefinition(ammotype);
                                        projectiles.primaryMagazine.contents = ammoamount;
                                    }

                                    //TODO Doesn't add water to some containers

                                    if (itemJson.ContainsKey("items"))
                                    {
                                        var itemContainsList = itemJson["items"] as List<object>;

                                        foreach (var itemContains in itemContainsList)
                                        {
                                            var contents = itemContains as Dictionary<string, object>;

                                            var contentsItemId = Convert.ToInt32(contents["id"]);

                                            if (pasteData.IsItemReplace)
                                                contentsItemId = GetItemId(contentsItemId);

                                            item.contents.AddItem(ItemManager.FindItemDefinition(contentsItemId),
                                                Convert.ToInt32(contents["amount"]));
                                        }
                                    }
                                }
                            }

                            var targetPos = -1;
                            if (itemJson.ContainsKey("position"))
                                targetPos = Convert.ToInt32(itemJson["position"]);

                            item.position = targetPos;
                            containerIo.inventory.Insert(item);
                        }
                    }

                    if (autoTurret != null)
                    {
                        autoTurret.Invoke(autoTurret.UpdateAttachedWeapon, 0.5f);
                    }

                    containerIo.SendNetworkUpdate();
                }

                var sign = entity as Signage;
                if (sign != null && data.ContainsKey("sign"))
                {
                    var signData = data["sign"] as Dictionary<string, object>;

                    if (signData.ContainsKey("amount"))
                    {
                        int amount;
                        if (int.TryParse(signData["amount"].ToString(), out amount))
                        {
                            for (int num = 0; num < amount; num++)
                            {
                                if (signData.ContainsKey($"texture{num}"))
                                {
                                    var imageBytes = Convert.FromBase64String(signData[$"texture{num}"].ToString());

                                    FixSignage(sign, imageBytes, num);
                                }
                            }
                        }
                    }
                    else if (signData.ContainsKey("texture"))
                    {
                        var imageBytes = Convert.FromBase64String(signData["texture"].ToString());

                        FixSignage(sign, imageBytes, 0);
                    }

                    if (Convert.ToBoolean(signData["locked"]))
                        sign.SetFlag(BaseEntity.Flags.Locked, true);

                    sign.SendNetworkUpdate();
                }

                var sleepingBag = entity as SleepingBag;
                if (sleepingBag != null && data.ContainsKey("sleepingbag"))
                {
                    var bagData = data["sleepingbag"] as Dictionary<string, object>;

                    sleepingBag.niceName = bagData["niceName"].ToString();
                    sleepingBag.deployerUserID = ulong.Parse(bagData["deployerUserID"].ToString());
                    sleepingBag.SetPublic(Convert.ToBoolean(bagData["isPublic"]));
                }

                var cupboard = entity as BuildingPrivlidge;
                if (cupboard != null)
                {
                    var authorizedPlayers = new List<ulong>();

                    if (data.ContainsKey("cupboard"))
                    {
                        var cupboardData = data["cupboard"] as Dictionary<string, object>;
                        authorizedPlayers = (cupboardData["authorizedPlayers"] as List<object>).Select(Convert.ToUInt64)
                            .ToList();
                    }

                    if (player != null && !authorizedPlayers.Contains(player.userID) && pasteData.Auth)
                        authorizedPlayers.Add(player.userID);

                    foreach (var userId in authorizedPlayers)
                    {
                        cupboard.authorizedPlayers.Add(new PlayerNameID
                        {
                            userid = Convert.ToUInt64(userId),
                            username = "Player"
                        });
                    }

                    cupboard.SendNetworkUpdate();
                }

                var cctvRc = entity as CCTV_RC;
                if (cctvRc != null && data.ContainsKey("cctv"))
                {
                    var cctv = (Dictionary<string, object>) data["cctv"];
                    cctvRc.yawAmount = Convert.ToSingle(cctv["yaw"]);
                    cctvRc.pitchAmount = Convert.ToSingle(cctv["pitch"]);
                    cctvRc.rcIdentifier = cctv["rcIdentifier"].ToString();
                    cctvRc.SendNetworkUpdate();
                }

                var vendingMachine = entity as VendingMachine;
                if (vendingMachine != null && data.ContainsKey("vendingmachine"))
                {
                    var vendingData = data["vendingmachine"] as Dictionary<string, object>;

                    vendingMachine.shopName = vendingData["shopName"].ToString();
                    vendingMachine.SetFlag(BaseEntity.Flags.Reserved4,
                        Convert.ToBoolean(vendingData["isBroadcasting"]));

                    var sellOrders = vendingData["sellOrders"] as List<object>;

                    foreach (var orderPreInfo in sellOrders)
                    {
                        var orderInfo = orderPreInfo as Dictionary<string, object>;

                        if (!orderInfo.ContainsKey("inStock"))
                        {
                            orderInfo["inStock"] = 0;
                            orderInfo["currencyIsBP"] = false;
                            orderInfo["itemToSellIsBP"] = false;
                        }

                        int itemToSellId = Convert.ToInt32(orderInfo["itemToSellID"]),
                            currencyId = Convert.ToInt32(orderInfo["currencyID"]);

                        if (pasteData.IsItemReplace)
                        {
                            itemToSellId = GetItemId(itemToSellId);
                            currencyId = GetItemId(currencyId);
                        }

                        vendingMachine.sellOrders.sellOrders.Add(new ProtoBuf.VendingMachine.SellOrder
                        {
                            ShouldPool = false,
                            itemToSellID = itemToSellId,
                            itemToSellAmount = Convert.ToInt32(orderInfo["itemToSellAmount"]),
                            currencyID = currencyId,
                            currencyAmountPerItem = Convert.ToInt32(orderInfo["currencyAmountPerItem"]),
                            inStock = Convert.ToInt32(orderInfo["inStock"]),
                            currencyIsBP = Convert.ToBoolean(orderInfo["currencyIsBP"]),
                            itemToSellIsBP = Convert.ToBoolean(orderInfo["itemToSellIsBP"])
                        });
                    }

                    vendingMachine.FullUpdate();
                }

                var ioEntity = entity as IOEntity;

                if (ioEntity != null)
                {
                    var ioData = new Dictionary<string, object>();

                    if (data.ContainsKey("IOEntity"))
                    {
                        ioData = data["IOEntity"] as Dictionary<string, object> ?? new Dictionary<string, object>();
                    }

                    ioData.Add("entity", ioEntity);
                    ioData.Add("newId", ioEntity.net.ID);

                    object oldIdObject = 0;
                    if (ioData.TryGetValue("oldID", out oldIdObject))
                    {
                        var oldId = Convert.ToUInt32(oldIdObject);
                        pasteData.IoEntities.Add(oldId, ioData);
                    }
                }

                var flagsData = new Dictionary<string, object>();

                if (data.ContainsKey("flags"))
                    flagsData = data["flags"] as Dictionary<string, object>;

                var flags = new Dictionary<BaseEntity.Flags, bool>();

                foreach (var flagData in flagsData)
                {
                    BaseEntity.Flags baseFlag;
                    if (Enum.TryParse(flagData.Key, out baseFlag))
                        flags.Add(baseFlag, Convert.ToBoolean(flagData.Value));
                }

                foreach (var flag in flags)
                {
                    entity.SetFlag(flag.Key, flag.Value);
                }

                pasteData.PastedEntities.Add(entity);
            }

            if (entities.Count > 0)
                NextTick(() => PasteLoop(pasteData));
            else
            {
                foreach (var ioData in pasteData.IoEntities.Values.ToArray())
                {
                    if (!ioData.ContainsKey("entity"))
                        continue;


                    var ioEntity = ioData["entity"] as IOEntity;

                    List<object> inputs = null;
                    if (ioData.ContainsKey("inputs"))
                        inputs = ioData["inputs"] as List<object>;

                    var electricalBranch = ioEntity as ElectricalBranch;
                    if (electricalBranch != null && ioData.ContainsKey("branchAmount"))
                    {
                        electricalBranch.branchAmount = Convert.ToInt32(ioData["branchAmount"]);
                    }

                    var counter = ioEntity as PowerCounter;
                    if (counter != null && ioData.ContainsKey("targetNumber"))
                    {
                        counter.targetCounterNumber = Convert.ToInt32(ioData["targetNumber"]);
                    }

                    var timer = ioEntity as TimerSwitch;
                    if (timer != null && ioData.ContainsKey("timerLength"))
                    {
                        timer.timerLength = Convert.ToInt32(ioData["timerLength"]);
                    }

                    var rfBroadcaster = ioEntity as RFBroadcaster;
                    if (rfBroadcaster != null && ioData.ContainsKey("frequency"))
                    {
                        rfBroadcaster.frequency = Convert.ToInt32(ioData["frequency"]);
                    }

                    var rfReceiver = ioEntity as RFReceiver;
                    if (rfReceiver != null && ioData.ContainsKey("frequency"))
                    {
                        rfReceiver.frequency = Convert.ToInt32(ioData["frequency"]);
                    }

                    var doorManipulator = ioEntity as CustomDoorManipulator;
                    if (doorManipulator != null)
                    {
                        var door = doorManipulator.FindDoor();
                        doorManipulator.SetTargetDoor(door);
                    }

                    if (inputs != null && inputs.Count > 0)
                    {
                        for (var index = 0; index < inputs.Count; index++)
                        {
                            var input = inputs[index] as Dictionary<string, object>;
                            object oldIdObject;
                            if (!input.TryGetValue("connectedID", out oldIdObject))
                                continue;

                            var oldId = Convert.ToUInt32(oldIdObject);

                            if (oldId != 0 && pasteData.IoEntities.ContainsKey(oldId))
                            {
                                if (ioEntity.inputs[index] == null)
                                    ioEntity.inputs[index] = new IOEntity.IOSlot();

                                var ioConnection = pasteData.IoEntities[oldId];

                                object temp;

                                if (ioConnection.ContainsKey("newId"))
                                {
                                    ioEntity.inputs[index].connectedTo.entityRef.uid =
                                        Convert.ToUInt32(ioConnection["newId"]);
                                }
                            }
                        }
                    }

                    List<object> outputs = null;
                    if (ioData.ContainsKey("outputs"))
                        outputs = ioData["outputs"] as List<object>;

                    if (outputs != null && outputs.Count > 0)
                    {
                        for (var index = 0; index < outputs.Count; index++)
                        {
                            var output = outputs[index] as Dictionary<string, object>;
                            var oldId = Convert.ToUInt32(output["connectedID"]);

                            if (oldId != 0 && pasteData.IoEntities.ContainsKey(oldId))
                            {
                                if (ioEntity.outputs[index] == null)
                                    ioEntity.outputs[index] = new IOEntity.IOSlot();

                                var ioConnection = pasteData.IoEntities[oldId];

                                if (ioConnection.ContainsKey("newId"))
                                {
                                    var ioEntity2 = ioConnection["entity"] as IOEntity;
                                    var connectedToSlot = Convert.ToInt32(output["connectedToSlot"]);
                                    var ioOutput = ioEntity.outputs[index];

                                    ioOutput.connectedTo = new IOEntity.IORef();
                                    ioOutput.connectedTo.Set(ioEntity2);
                                    ioOutput.connectedToSlot = connectedToSlot;
                                    ioOutput.connectedTo.Init();

                                    ioEntity2.inputs[connectedToSlot].connectedTo = new IOEntity.IORef();
                                    ioEntity2.inputs[connectedToSlot].connectedTo.Set(ioEntity);
                                    ioEntity2.inputs[connectedToSlot].connectedToSlot = index;
                                    ioEntity2.inputs[connectedToSlot].connectedTo.Init();

                                    ioOutput.niceName = output["niceName"] as string;

                                    ioOutput.type = (IOEntity.IOType) Convert.ToInt32(output["type"]);
                                }

                                if (output.ContainsKey("linePoints"))
                                {
                                    var linePoints = output["linePoints"] as List<object>;
                                    if (linePoints != null)
                                    {
                                        var lineList = new List<Vector3>();
                                        foreach (var point in linePoints)
                                        {
                                            var linePoint = point as Dictionary<string, object>;
                                            lineList.Add(new Vector3(
                                                Convert.ToSingle(linePoint["x"]),
                                                Convert.ToSingle(linePoint["y"]),
                                                Convert.ToSingle(linePoint["z"])));
                                        }

                                        ioEntity.outputs[index].linePoints = lineList.ToArray();
                                    }
                                }
                            }
                        }
                    }

                    ioEntity.MarkDirtyForceUpdateOutputs();
                    ioEntity.SendNetworkUpdate();
                }

                foreach (var entity in pasteData.StabilityEntities)
                {
                    entity.grounded = false;
                    entity.InitializeSupports();
                    entity.UpdateStability();
                }

                if (player != null)
                {
                    SendReply(player, Lang("PASTE_SUCCESS", player.UserIDString));
#if DEBUG
                    SendReply(player, $"Stopwatch took: {pasteData.Sw.Elapsed.TotalMilliseconds} ms");
#endif
                }
                else
                {
                    Puts(Lang("PASTE_SUCCESS"));
                }

                if (!_lastPastes.ContainsKey(player?.UserIDString ?? _serverId))
                    _lastPastes[player?.UserIDString ?? _serverId] = new Stack<List<BaseEntity>>();

                _lastPastes[player?.UserIDString ?? _serverId].Push(pasteData.PastedEntities);

                pasteData.Callback?.Invoke();

                Interface.CallHook("OnPasteFinished", pasteData.PastedEntities, pasteData.Filename);
            }
        }

        private HashSet<Dictionary<string, object>> PreLoadData(List<object> entities, Vector3 startPos,
            float rotationCorrection, bool deployables, bool inventories, bool auth, bool vending)
        {
            var eulerRotation = new Vector3(0f, rotationCorrection, 0f);
            var quaternionRotation = Quaternion.EulerRotation(eulerRotation);
            var preloaddata = new HashSet<Dictionary<string, object>>();

            foreach (var entity in entities)
            {
                var data = entity as Dictionary<string, object>;

                if (!deployables && !data.ContainsKey("grade"))
                    continue;

                var pos = (Dictionary<string, object>) data["pos"];
                var rot = (Dictionary<string, object>) data["rot"];

                data.Add("position",
                    quaternionRotation * new Vector3(Convert.ToSingle(pos["x"]), Convert.ToSingle(pos["y"]),
                        Convert.ToSingle(pos["z"])) + startPos);
                data.Add("rotation",
                    Quaternion.EulerRotation(eulerRotation + new Vector3(Convert.ToSingle(rot["x"]),
                        Convert.ToSingle(rot["y"]), Convert.ToSingle(rot["z"]))));

                if (!inventories && data.ContainsKey("items"))
                    data["items"] = new List<object>();

                if (!vending && data["prefabname"].ToString().Contains("vendingmachine"))
                    data.Remove("vendingmachine");

                preloaddata.Add(data);
            }

            return preloaddata;
        }

        private object TryCopy(Vector3 sourcePos, Vector3 sourceRot, string filename, float rotationCorrection,
            string[] args, BasePlayer player, Action callback)
        {
            bool saveShare = _config.Copy.Share, saveTree = _config.Copy.Tree, eachToEach = _config.Copy.EachToEach;
            var copyMechanics = CopyMechanics.Proximity;
            var radius = _config.Copy.Radius;

            for (var i = 0;; i = i + 2)
            {
                if (i >= args.Length)
                    break;

                var valueIndex = i + 1;

                if (valueIndex >= args.Length)
                    return Lang("SYNTAX_COPY");

                var param = args[i].ToLower();

                switch (param)
                {
                    case "e":
                    case "each":
                        if (!bool.TryParse(args[valueIndex], out eachToEach))
                            return Lang("SYNTAX_BOOL", null, param);

                        break;

                    case "m":
                    case "method":
                        switch (args[valueIndex].ToLower())
                        {
                            case "b":
                            case "building":
                                copyMechanics = CopyMechanics.Building;
                                break;

                            case "p":
                            case "proximity":
                                copyMechanics = CopyMechanics.Proximity;
                                break;
                        }

                        break;

                    case "r":
                    case "radius":
                        if (!float.TryParse(args[valueIndex], out radius))
                            return Lang("SYNTAX_RADIUS");

                        break;

                    case "s":
                    case "share":
                        if (!bool.TryParse(args[valueIndex], out saveShare))
                            return Lang("SYNTAX_BOOL", null, param);

                        break;

                    case "t":
                    case "tree":
                        if (!bool.TryParse(args[valueIndex], out saveTree))
                            return Lang("SYNTAX_BOOL", null, param);

                        break;

                    default:
                        return Lang("SYNTAX_COPY");
                }
            }

            Copy(sourcePos, sourceRot, filename, rotationCorrection, copyMechanics, radius, saveTree, saveShare,
                eachToEach, player, callback);

            return true;
        }

        private void TryCopySlots(BaseEntity ent, IDictionary<string, object> housedata, bool saveShare)
        {
            foreach (var slot in _checkSlots)
            {
                if (!ent.HasSlot(slot))
                    continue;

                var slotEntity = ent.GetSlot(slot);

                if (slotEntity == null)
                    continue;

                var codedata = new Dictionary<string, object>
                {
                    {"prefabname", slotEntity.PrefabName},
                    {"flags", TryCopyFlags(ent)}
                };

                if (slotEntity.GetComponent<CodeLock>())
                {
                    var codeLock = slotEntity.GetComponent<CodeLock>();

                    codedata.Add("code", codeLock.code);

                    if (saveShare)
                        codedata.Add("whitelistPlayers", codeLock.whitelistPlayers);

                    if (codeLock.guestCode != null && codeLock.guestCode.Length == 4)
                    {
                        codedata.Add("guestCode", codeLock.guestCode);

                        if (saveShare)
                            codedata.Add("guestPlayers", codeLock.guestPlayers);
                    }
                }
                else if (slotEntity.GetComponent<KeyLock>())
                {
                    var keyLock = slotEntity.GetComponent<KeyLock>();
                    var code = keyLock.keyCode;

                    if (keyLock.firstKeyCreated)
                        code |= 0x80;

                    codedata.Add("ownerId", keyLock.OwnerID.ToString());
                    codedata.Add("code", code.ToString());
                }

                var slotName = slot.ToString().ToLower();

                housedata.Add(slotName, codedata);
            }
        }

        private Dictionary<string, object> TryCopyFlags(BaseEntity entity)
        {
            var flags = new Dictionary<string, object>();

            foreach (BaseEntity.Flags flag in Enum.GetValues(typeof(BaseEntity.Flags)))
            {
                if (!_config.DataSaving || entity.HasFlag(flag))
                    flags.Add(flag.ToString(), entity.HasFlag(flag));
            }

            return flags;
        }

        private object TryPaste(Vector3 startPos, string filename, BasePlayer player, float rotationCorrection,
            string[] args, bool autoHeight = true, Action callback = null)
        {
            var userId = player?.UserIDString;

            var path = _subDirectory + filename;

            if (!Interface.Oxide.DataFileSystem.ExistsDatafile(path))
                return Lang("FILE_NOT_EXISTS", userId);

            var data = Interface.Oxide.DataFileSystem.GetDatafile(path);

            if (data["default"] == null || data["entities"] == null)
                return Lang("FILE_BROKEN", userId);

            float heightAdj = 0f, blockCollision = 0f;
            bool auth = _config.Paste.Auth,
                inventories = _config.Paste.Inventories,
                deployables = _config.Paste.Deployables,
                vending = _config.Paste.VendingMachines,
                stability = _config.Paste.Stability,
                ownership = _config.Paste.EntityOwner;

            for (var i = 0;; i = i + 2)
            {
                if (i >= args.Length)
                    break;

                var valueIndex = i + 1;

                if (valueIndex >= args.Length)
                    return Lang("SYNTAX_PASTE_OR_PASTEBACK", userId);

                var param = args[i].ToLower();

                switch (param)
                {
                    case "a":
                    case "auth":
                        if (!bool.TryParse(args[valueIndex], out auth))
                            return Lang("SYNTAX_BOOL", userId, param);

                        break;

                    case "b":
                    case "blockcollision":
                        if (!float.TryParse(args[valueIndex], out blockCollision))
                            return Lang("SYNTAX_BLOCKCOLLISION", userId);

                        break;

                    case "d":
                    case "deployables":
                        if (!bool.TryParse(args[valueIndex], out deployables))
                            return Lang("SYNTAX_BOOL", userId, param);

                        break;

                    case "h":
                    case "height":
                        if (!float.TryParse(args[valueIndex], out heightAdj))
                            return Lang("SYNTAX_HEIGHT", userId);

                        break;

                    case "i":
                    case "inventories":
                        if (!bool.TryParse(args[valueIndex], out inventories))
                            return Lang("SYNTAX_BOOL", userId, param);

                        break;

                    case "s":
                    case "stability":
                        if (!bool.TryParse(args[valueIndex], out stability))
                            return Lang("SYNTAX_BOOL", userId, param);

                        break;

                    case "v":
                    case "vending":
                        if (!bool.TryParse(args[valueIndex], out vending))
                            return Lang("SYNTAX_BOOL", userId, param);

                        break;

                    case "o":
                    case "entityowner":
                        if (!bool.TryParse(args[valueIndex], out ownership))
                            return Lang("SYNTAX_BOOL", userId, param);

                        break;

                    case "autoheight":
                        if (!bool.TryParse(args[valueIndex], out autoHeight))
                            return Lang("SYNTAX_BOOL", userId, param);

                        break;

                    default:
                        return Lang("SYNTAX_PASTE_OR_PASTEBACK", userId);
                }
            }

            startPos.y += heightAdj;

            var preloadData = PreLoadData(data["entities"] as List<object>, startPos, rotationCorrection, deployables,
                inventories, auth, vending);

            if (autoHeight)
            {
                var bestHeight = FindBestHeight(preloadData, startPos);

                if (bestHeight is string)
                    return bestHeight;

                heightAdj += (float) bestHeight - startPos.y;

                foreach (var entity in preloadData)
                {
                    var pos = (Vector3) entity["position"];
                    pos.y += heightAdj;

                    entity["position"] = pos;
                }
            }

            if (blockCollision > 0f)
            {
                var collision = CheckCollision(preloadData, startPos, blockCollision);

                if (collision is string)
                    return collision;
            }

            var protocol = new Dictionary<string, object>();

            if (data["protocol"] != null)
                protocol = data["protocol"] as Dictionary<string, object>;

            Paste(preloadData, protocol, ownership, startPos, player, stability, rotationCorrection,
                autoHeight ? heightAdj : 0, auth, callback, filename);
            return true;
        }

        private List<BaseEntity> TryPasteSlots(BaseEntity ent, Dictionary<string, object> structure,
            PasteData pasteData)
        {
            var entitySlots = new List<BaseEntity>();

            foreach (var slot in _checkSlots)
            {
                var slotName = slot.ToString().ToLower();

                if (!ent.HasSlot(slot) || !structure.ContainsKey(slotName))
                    continue;

                var slotData = structure[slotName] as Dictionary<string, object>;
                var slotEntity = GameManager.server.CreateEntity((string) slotData["prefabname"], Vector3.zero);

                if (slotEntity == null)
                    continue;

                slotEntity.gameObject.Identity();
                slotEntity.SetParent(ent, slotName);
                slotEntity.OnDeployed(ent, null);
                slotEntity.Spawn();

                ent.SetSlot(slot, slotEntity);

                entitySlots.Add(slotEntity);

                if (slotName != "lock" || !slotData.ContainsKey("code"))
                    continue;

                if (slotEntity.GetComponent<CodeLock>())
                {
                    var code = (string) slotData["code"];

                    if (!string.IsNullOrEmpty(code))
                    {
                        var codeLock = slotEntity.GetComponent<CodeLock>();
                        codeLock.code = code;
                        codeLock.hasCode = true;

                        if (pasteData.Auth && pasteData.Player != null)
                            codeLock.whitelistPlayers.Add(pasteData.Player.userID);

                        if (slotData.ContainsKey("whitelistPlayers"))
                        {
                            foreach (var userId in slotData["whitelistPlayers"] as List<object>)
                            {
                                codeLock.whitelistPlayers.Add(Convert.ToUInt64(userId));
                            }
                        }

                        if (slotData.ContainsKey("guestCode"))
                        {
                            var guestCode = (string) slotData["guestCode"];

                            codeLock.guestCode = guestCode;
                            codeLock.hasGuestCode = true;

                            if (slotData.ContainsKey("guestPlayers"))
                            {
                                foreach (var userId in slotData["guestPlayers"] as List<object>)
                                {
                                    codeLock.guestPlayers.Add(Convert.ToUInt64(userId));
                                }
                            }
                        }

                        codeLock.SetFlag(BaseEntity.Flags.Locked, true);
                    }
                }
                else if (slotEntity.GetComponent<KeyLock>())
                {
                    var code = Convert.ToInt32(slotData["code"]);
                    var keyLock = slotEntity.GetComponent<KeyLock>();

                    if ((code & 0x80) != 0)
                    {
                        keyLock.keyCode = code & 0x7F;
                        keyLock.firstKeyCreated = true;
                        keyLock.SetFlag(BaseEntity.Flags.Locked, true);
                    }

                    if (pasteData.Ownership && slotData.ContainsKey("ownerId"))
                    {
                        keyLock.OwnerID = Convert.ToUInt64(slotData["ownerId"]);
                    }
                }
            }

            return entitySlots;
        }

        private object TryPasteBack(string filename, BasePlayer player, string[] args)
        {
            var path = _subDirectory + filename;

            if (!Interface.Oxide.DataFileSystem.ExistsDatafile(path))
                return Lang("FILE_NOT_EXISTS", player?.UserIDString);

            var data = Interface.Oxide.DataFileSystem.GetDatafile(path);

            if (data["default"] == null || data["entities"] == null)
                return Lang("FILE_BROKEN", player?.UserIDString);

            var defaultdata = data["default"] as Dictionary<string, object>;
            var pos = defaultdata["position"] as Dictionary<string, object>;
            var rotationCorrection = Convert.ToSingle(defaultdata["rotationdiff"]);
            var startPos = new Vector3(Convert.ToSingle(pos["x"]), Convert.ToSingle(pos["y"]),
                Convert.ToSingle(pos["z"]));

            return TryPaste(startPos, filename, player, rotationCorrection, args, autoHeight: false);
        }

        //Сhat commands

        [ChatCommand("copy")]
        private void CmdChatCopy(BasePlayer player, string command, string[] args)
        {
            if (!HasAccess(player, _copyPermission))
            {
                SendReply(player, Lang("NO_ACCESS", player.UserIDString));
                return;
            }

            if (args.Length < 1)
            {
                SendReply(player, Lang("SYNTAX_COPY", player.UserIDString));
                return;
            }

            var savename = args[0];
            var success = TryCopyFromSteamId(player.userID, savename, args.Skip(1).ToArray());

            if (success is string)
            {
                SendReply(player, (string) success);
            }
        }

        [ChatCommand("paste")]
        private void CmdChatPaste(BasePlayer player, string command, string[] args)
        {
            if (!HasAccess(player, _pastePermission))
            {
                SendReply(player, Lang("NO_ACCESS", player.UserIDString));
                return;
            }

            if (args.Length < 1)
            {
                SendReply(player, Lang("SYNTAX_PASTE_OR_PASTEBACK", player.UserIDString));
                return;
            }

            var success = TryPasteFromSteamId(player.userID, args[0], args.Skip(1).ToArray());

            if (success is string)
            {
                SendReply(player, (string) success);
            }
        }

        [ChatCommand("copylist")]
        private void CmdChatList(BasePlayer player, string command, string[] args)
        {
            if (!HasAccess(player, _listPermission))
            {
                SendReply(player, Lang("NO_ACCESS", player.UserIDString));
                return;
            }

            var files = Interface.Oxide.DataFileSystem.GetFiles(_subDirectory);

            var fileList = new List<string>();

            foreach (var file in files)
            {
                var strFileParts = file.Split('/');
                var justfile = strFileParts[strFileParts.Length - 1].Replace(".json", "");
                fileList.Add(justfile);
            }

            SendReply(player, Lang("AVAILABLE_STRUCTURES", player.UserIDString));
            SendReply(player, string.Join(", ", fileList.ToArray()));
        }

        [ChatCommand("pasteback")]
        private void CmdChatPasteBack(BasePlayer player, string command, string[] args)
        {
            if (!HasAccess(player, _pastebackPermission))
            {
                SendReply(player, Lang("NO_ACCESS", player.UserIDString));
                return;
            }

            var result = CmdPasteBack(player, args);

            if (result is string)
                SendReply(player, (string) result);
        }

        [ChatCommand("undo")]
        private void CmdChatUndo(BasePlayer player, string command, string[] args)
        {
            if (!HasAccess(player, _undoPermission))
            {
                SendReply(player, Lang("NO_ACCESS", player.UserIDString));
                return;
            }

            CmdUndo(player.UserIDString, args);
        }

        //Console commands [From Server]

        [ConsoleCommand("pasteback")]
        private void CmdConsolePasteBack(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin)
                return;

            var result = CmdPasteBack(arg.Player(), arg.Args);

            if (result is string)
                SendReply(arg, (string) result);
        }

        [ConsoleCommand("undo")]
        private void CmdConsoleUndo(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin)
                return;

            var player = arg.Player();

            CmdUndo(player == null ? _serverId : player.UserIDString, arg.Args);
        }

        //Replace between old ItemID to new ItemID

        private static readonly Dictionary<int, int> ReplaceItemId = new Dictionary<int, int>
        {
            {-1461508848, 1545779598},
            {2115555558, 588596902},
            {-533875561, 785728077},
            {1621541165, 51984655},
            {-422893115, -1691396643},
            {815896488, -1211166256},
            {805088543, -1321651331},
            {449771810, 605467368},
            {1152393492, 1712070256},
            {1578894260, -742865266},
            {1436532208, 1638322904},
            {542276424, -1841918730},
            {1594947829, -17123659},
            {-1035059994, -1685290200},
            {1818890814, -1036635990},
            {1819281075, -727717969},
            {1685058759, -1432674913},
            {93029210, 1548091822},
            {-1565095136, 352130972},
            {-1775362679, 215754713},
            {-1775249157, 14241751},
            {-1280058093, -1023065463},
            {-420273765, -1234735557},
            {563023711, -2139580305},
            {790921853, -262590403},
            {-337261910, -2072273936},
            {498312426, -1950721390},
            {504904386, 1655650836},
            {-1221200300, -559599960},
            {510887968, 15388698},
            {-814689390, 866889860},
            {1024486167, 1382263453},
            {2021568998, 609049394},
            {97329, 1099314009},
            {1046072789, -582782051},
            {97409, -1273339005},
            {-1480119738, -1262185308},
            {1611480185, 1931713481},
            {-1386464949, 1553078977},
            {93832698, 1776460938},
            {-1063412582, -586342290},
            {-1887162396, -996920608},
            {-55660037, 1588298435},
            {919780768, 1711033574},
            {-365801095, 1719978075},
            {68998734, 613961768},
            {-853695669, 1443579727},
            {271534758, 833533164},
            {-770311783, -180129657},
            {-1192532973, 1424075905},
            {-307490664, 1525520776},
            {707427396, 602741290},
            {707432758, -761829530},
            {-2079677721, 1783512007},
            {-1342405573, -1316706473},
            {-139769801, 1946219319},
            {-1043746011, -700591459},
            {2080339268, 1655979682},
            {-171664558, -1941646328},
            {1050986417, -1557377697},
            {-1693683664, 1789825282},
            {523409530, 1121925526},
            {1300054961, 634478325},
            {-2095387015, 1142993169},
            {1428021640, 1104520648},
            {94623429, 1534542921},
            {1436001773, -1938052175},
            {1711323399, 1973684065},
            {1734319168, -1848736516},
            {-1658459025, -1440987069},
            {-726947205, -751151717},
            {-341443994, 363467698},
            {1540879296, 2009734114},
            {94756378, -858312878},
            {3059095, 204391461},
            {3059624, 1367190888},
            {2045107609, -778875547},
            {583366917, 998894949},
            {2123300234, 1965232394},
            {1983936587, -321733511},
            {1257201758, -97956382},
            {-1144743963, 296519935},
            {-1144542967, -113413047},
            {-1144334585, -2022172587},
            {1066729526, -1101924344},
            {-1598790097, 1390353317},
            {-933236257, 1221063409},
            {-1575287163, -1336109173},
            {-2104481870, -2067472972},
            {-1571725662, 1353298668},
            {1456441506, 1729120840},
            {1200628767, -1112793865},
            {-778796102, 1409529282},
            {1526866730, 674734128},
            {1925723260, -1519126340},
            {1891056868, 1401987718},
            {1295154089, -1878475007},
            {498591726, 1248356124},
            {1755466030, -592016202},
            {726730162, 798638114},
            {-1034048911, -1018587433},
            {252529905, 274502203},
            {471582113, -1065444793},
            {-1138648591, 16333305},
            {305916740, 649305914},
            {305916742, 649305916},
            {305916744, 649305918},
            {1908328648, -1535621066},
            {-2078972355, 1668129151},
            {-533484654, 989925924},
            {1571660245, 1569882109},
            {1045869440, -1215753368},
            {1985408483, 528668503},
            {97513422, 304481038},
            {1496470781, -196667575},
            {1229879204, 952603248},
            {-1722829188, 936496778},
            {1849912854, 1948067030},
            {-1266285051, 1413014235},
            {-1749787215, -1000573653},
            {28178745, -946369541},
            {-505639592, -1999722522},
            {1598149413, -1992717673},
            {-1779401418, -691113464},
            {-57285700, -335089230},
            {98228420, 479143914},
            {1422845239, 999690781},
            {277631078, -1819763926},
            {115739308, 1366282552},
            {-522149009, -690276911},
            {3175989, -1899491405},
            {718197703, -746030907},
            {384204160, 1840822026},
            {-1308622549, 143803535},
            {-217113639, -2124352573},
            {-1580059655, -265876753},
            {-1832205789, 1070894649},
            {305916741, 649305917},
            {936777834, 3222790},
            {-1224598842, 200773292},
            {-1976561211, -1506397857},
            {-1406876421, 1675639563},
            {-1397343301, -23994173},
            {1260209393, 850280505},
            {-1035315940, 1877339384},
            {-1381682752, 1714496074},
            {696727039, -1022661119},
            {-2128719593, -803263829},
            {-1178289187, -1903165497},
            {1351172108, 1181207482},
            {-450738836, -1539025626},
            {-966287254, -324675402},
            {340009023, 671063303},
            {124310981, -1478212975},
            {1501403549, -2094954543},
            {698310895, -1252059217},
            {523855532, 1266491000},
            {2045246801, -886280491},
            {583506109, -237809779},
            {-148163128, 794356786},
            {-132588262, -1773144852},
            {-1666761111, 196700171},
            {-465236267, 442289265},
            {-1211618504, 1751045826},
            {2133577942, -1982036270},
            {-1014825244, -682687162},
            {-991829475, 1536610005},
            {-642008142, -1709878924},
            {661790782, 1272768630},
            {-1440143841, -1780802565},
            {569119686, 1746956556},
            {1404466285, -1102429027},
            {-1616887133, -48090175},
            {-1167640370, -1163532624},
            {-1284735799, 1242482355},
            {-1278649848, -1824943010},
            {776005741, 1814288539},
            {108061910, -316250604},
            {255101535, -1663759755},
            {-51678842, 1658229558},
            {-789202811, 254522515},
            {516382256, -132516482},
            {50834473, 1381010055},
            {-975723312, 1159991980},
            {1908195100, -850982208},
            {-1097452776, -110921842},
            {146685185, -1469578201},
            {-1716193401, -1812555177},
            {193190034, -2069578888},
            {371156815, -852563019},
            {3343606, -1966748496},
            {825308669, -1137865085},
            {830965940, -586784898},
            {1662628660, -163828118},
            {1662628661, -163828117},
            {1662628662, -163828112},
            {-1832205788, 1070894648},
            {-1832205786, 1070894646},
            {1625090418, 181590376},
            {-1269800768, -874975042},
            {429648208, -1190096326},
            {-1832205787, 1070894647},
            {-1832205785, 1070894645},
            {107868, 696029452},
            {997973965, -2012470695},
            {-46188931, -702051347},
            {-46848560, -194953424},
            {-2066726403, -989755543},
            {-2043730634, 1873897110},
            {1325935999, -1520560807},
            {-225234813, -78533081},
            {-202239044, -1509851560},
            {-322501005, 1422530437},
            {-1851058636, 1917703890},
            {-1828062867, -1162759543},
            {-1966381470, -1130350864},
            {968732481, 1391703481},
            {991728250, -242084766},
            {-253819519, 621915341},
            {-1714986849, 1827479659},
            {-1691991080, 813023040},
            {179448791, -395377963},
            {431617507, -1167031859},
            {688032252, 69511070},
            {-1059362949, -4031221},
            {1265861812, 1110385766},
            {374890416, 317398316},
            {1567404401, 1882709339},
            {-1057402571, 95950017},
            {-758925787, -1130709577},
            {-1411620422, 1052926200},
            {88869913, -542577259},
            {-2094080303, 1318558775},
            {843418712, -1962971928},
            {-1569356508, -1405508498},
            {-1569280852, 1478091698},
            {449769971, 1953903201},
            {590532217, -2097376851},
            {3387378, 1414245162},
            {1767561705, 1992974553},
            {106433500, 237239288},
            {-1334615971, -1778159885},
            {-135651869, 1722154847},
            {-1595790889, 1850456855},
            {-459156023, -1695367501},
            {106434956, -1779183908},
            {-578028723, -1302129395},
            {-586116979, 286193827},
            {-1379225193, -75944661},
            {-930579334, 649912614},
            {548699316, 818877484},
            {142147109, 1581210395},
            {148953073, 1903654061},
            {102672084, 980333378},
            {640562379, -1651220691},
            {-1732316031, -1622660759},
            {-2130280721, 756517185},
            {-1725510067, -722241321},
            {1974032895, -1673693549},
            {-225085592, -567909622},
            {509654999, 1898094925},
            {466113771, -1511285251},
            {2033918259, 1373971859},
            {2069925558, -1736356576},
            {-1026117678, 803222026},
            {1987447227, -1861522751},
            {540154065, -544317637},
            {1939428458, 176787552},
            {-288010497, -2002277461},
            {-847065290, 1199391518},
            {3506021, 963906841},
            {649603450, 442886268},
            {3506418, 1414245522},
            {569935070, -1104881824},
            {113284, -1985799200},
            {1916127949, -277057363},
            {-1775234707, -1978999529},
            {-388967316, 1326180354},
            {2007564590, -575483084},
            {-1705696613, 177226991},
            {670655301, -253079493},
            {1148128486, -1958316066},
            {-141135377, 567235583},
            {109266897, -932201673},
            {-527558546, 2087678962},
            {-1745053053, -904863145},
            {1223860752, 573926264},
            {-419069863, 1234880403},
            {-1617374968, -1994909036},
            {2057749608, 1950721418},
            {24576628, -2025184684},
            {-1659202509, 1608640313},
            {2107229499, -1549739227},
            {191795897, -765183617},
            {-1009492144, 795371088},
            {2077983581, -1367281941},
            {378365037, 352499047},
            {-529054135, -1199897169},
            {-529054134, -1199897172},
            {486166145, -1023374709},
            {1628490888, 23352662},
            {1498516223, 1205607945},
            {-632459882, -1647846966},
            {-626812403, -845557339},
            {385802761, -1370759135},
            {2117976603, 121049755},
            {1338515426, -996185386},
            {-1455694274, 98508942},
            {1579245182, 2070189026},
            {-587434450, 1521286012},
            {-163742043, 1542290441},
            {-1224714193, -1832422579},
            {644359987, 826309791},
            {-1962514734, -143132326},
            {-705305612, 1153652756},
            {-357728804, -1819233322},
            {-698499648, -1138208076},
            {1213686767, -1850571427},
            {386382445, -855748505},
            {1859976884, 553887414},
            {960793436, 996293980},
            {1001265731, 2048317869},
            {1253290621, -1754948969},
            {470729623, -1293296287},
            {1051155022, -369760990},
            {865679437, -1878764039},
            {927253046, -1039528932},
            {109552593, 1796682209},
            {-2092529553, 1230323789},
            {691633666, -363689972},
            {-2055888649, 1629293099},
            {621575320, -41440462},
            {-2118132208, 1602646136},
            {-1127699509, 1540934679},
            {-685265909, -92759291},
            {552706886, -1100422738},
            {1835797460, -1021495308},
            {-892259869, 642482233},
            {-1623330855, -465682601},
            {-1616524891, 1668858301},
            {789892804, 171931394},
            {-1289478934, -1583967946},
            {-892070738, -2099697608},
            {-891243783, -1581843485},
            {889398893, -1157596551},
            {-1625468793, 1397052267},
            {1293049486, 1975934948},
            {1369769822, 559147458},
            {586484018, 1079279582},
            {110115790, 593465182},
            {1490499512, 1523195708},
            {3552619, 2019042823},
            {1471284746, 73681876},
            {456448245, -1758372725},
            {110547964, 795236088},
            {1588977225, -1667224349},
            {918540912, -209869746},
            {-471874147, 1686524871},
            {205978836, 1723747470},
            {-1044400758, -129230242},
            {-2073307447, -1331212963},
            {435230680, 2106561762},
            {-864578046, 223891266},
            {1660607208, 935692442},
            {260214178, -1478445584},
            {-1847536522, 198438816},
            {-496055048, -967648160},
            {-1792066367, 99588025},
            {562888306, -956706906},
            {-427925529, -1429456799},
            {995306285, 1451568081},
            {-378017204, -1117626326},
            {447918618, -148794216},
            {313836902, 1516985844},
            {1175970190, -796583652},
            {525244071, -148229307},
            {-1021702157, -819720157},
            {-402507101, 671706427},
            {-1556671423, -1183726687},
            {61936445, -1614955425},
            {112903447, -1779180711},
            {1817873886, -1100168350},
            {1824679850, -132247350},
            {-1628526499, -1863559151},
            {547302405, -119235651},
            {1840561315, 2114754781},
            {-460592212, -1379835144},
            {3655341, -151838493},
            {1554697726, 418081930},
            {-1883959124, 832133926},
            {-481416622, 1524187186},
            {-481416621, -41896755},
            {-481416620, -1607980696},
            {-1151126752, 1058261682},
            {-1926458555, 794443127}
        };

        //Languages phrases

        private readonly Dictionary<string, Dictionary<string, string>> _messages =
            new Dictionary<string, Dictionary<string, string>>
            {
                {
                    "FILE_NOT_EXISTS", new Dictionary<string, string>
                    {
                        {"en", "File does not exist"},
                        {"ru", "Файл не существует"},
                        {"nl", "Bestand bestaat niet."}
                    }
                },
                {
                    "FILE_BROKEN", new Dictionary<string, string>
                    {
                        {"en", "Something went wrong during pasting because of a error in the file."},
                        {"ru", "Файл поврежден, вставка невозможна"},
                        {"nl", "Er is iets misgegaan tijdens het plakken door een beschadigd bestand."}
                    }
                },
                {
                    "NO_ACCESS", new Dictionary<string, string>
                    {
                        {"en", "You don't have the permissions to use this command"},
                        {"ru", "У вас нет прав доступа к данной команде"},
                        {"nl", "U heeft geen toestemming/permissie om dit commando te gebruiken."}
                    }
                },
                {
                    "SYNTAX_PASTEBACK", new Dictionary<string, string>
                    {
                        {
                            "en", "Syntax: /pasteback <Target Filename> <options values>\n" +
                                  "height XX - Adjust the height\n" +
                                  "vending - Information and sellings in vending machine\n" +
                                  "stability <true/false> - Wether or not to disable stability\n" +
                                  "deployables <true/false> - Wether or not to copy deployables\n" +
                                  "auth <true/false> - Wether or not to copy lock and cupboard whitelists"
                        },
                        {
                            "ru", "Синтаксис: /pasteback <Название Объекта> <опция значение>\n" +
                                  "height XX - Высота от земли\n" +
                                  "vending - Информация и товары в торговом автомате"
                        },
                        {
                            "nl", "Syntax: /pasteback <Bestandsnaam> <opties waarden>\n" +
                                  "height XX - Pas de hoogte aan \n" +
                                  "vending <true/false> - Informatie en inventaris van \"vending machines\" kopiëren\n" +
                                  "stability <true/false> - of de stabiliteit van het gebouw uitgezet moet worden\n" +
                                  "deployables <true/false> - of de \"deployables\" gekopiërd moeten worden\n" +
                                  "auth <true/false> - Of authorisatie op sloten en tool cupboards gekopiërd moet worden"
                        }
                    }
                },
                {
                    "SYNTAX_PASTE_OR_PASTEBACK", new Dictionary<string, string>
                    {
                        {
                            "en", "Syntax: /paste or /pasteback <Target Filename> <options values>\n" +
                                  "height XX - Adjust the height\n" +
                                  "autoheight true/false - sets best height, carefull of the steep\n" +
                                  "blockcollision XX - blocks the entire paste if something the new building collides with something\n" +
                                  "deployables true/false - false to remove deployables\n" +
                                  "inventories true/false - false to ignore inventories\n" +
                                  "vending - Information and sellings in vending machine\n" +
                                  "stability <true/false> - Wether or not to disable stability on the building"
                        },
                        {
                            "ru", "Синтаксис: /paste or /pasteback <Название Объекта> <опция значение>\n" +
                                  "height XX - Высота от земли\n" +
                                  "autoheight true/false - автоматически подобрать высоту от земли\n" +
                                  "blockcollision XX - блокировать вставку, если что-то этому мешает\n" +
                                  "deployables true/false - false для удаления предметов\n" +
                                  "inventories true/false - false для игнорирования копирования инвентаря\n" +
                                  "vending - Информация и товары в торговом автомате"
                        },
                        {
                            "nl", "Syntax: /paste of /pasteback <Bestandsnaam> <opties waarden>\n" +
                                  "height XX - Pas de hoogte aan \n" +
                                  "autoheight true/false - probeert de optimale hoogte te vinden om gebouw te plaatsen. Werkt optimaal op vlakke grond.\n" +
                                  "vending true/false - Informatie en inventaris van \"vending machines\" kopiëren\n" +
                                  "stability <true/false> - of de stabiliteit van het gebouw uitgezet moet worden\n" +
                                  "deployables <true/false> - of de \"deployables\" gekopiërd moeten worden\n" +
                                  "auth <true/false> - Of authorisatie op sloten en tool cupboards gekopiërd moet worden"
                        }
                    }
                },
                {
                    "PASTEBACK_SUCCESS", new Dictionary<string, string>
                    {
                        {"en", "You've successfully placed back the structure"},
                        {"ru", "Постройка успешно вставлена на старое место"},
                        {"nl", "Het gebouw is succesvol teruggeplaatst."}
                    }
                },
                {
                    "PASTE_SUCCESS", new Dictionary<string, string>
                    {
                        {"en", "You've successfully pasted the structure"},
                        {"ru", "Постройка успешно вставлена"},
                        {"nl", "Het gebouw is succesvol geplaatst."}
                    }
                },
                {
                    "SYNTAX_COPY", new Dictionary<string, string>
                    {
                        {
                            "en", "Syntax: /copy <Target Filename> <options values>\n" +
                                  "radius XX (default 3) - The radius in which to search for the next object (performs this search from every other object)\n" +
                                  "method proximity/building (default proximity) - Building only copies objects which are part of the building, proximity copies everything (within the radius)\n" +
                                  "deployables true/false (saves deployables or not) - Wether to save deployables\n" +
                                  "inventories true/false (saves inventories or not) - Wether to save inventories of found objects with inventories."
                        },
                        {
                            "ru", "Синтаксис: /copy <Название Объекта> <опция значение>\n" +
                                  "radius XX (default 3)\n" +
                                  "method proximity/building (по умолчанию proximity)\n" +
                                  "deployables true/false (сохранять предметы или нет)\n" +
                                  "inventories true/false (сохранять инвентарь или нет)"
                        },
                        {
                            "nl", "Syntax: /copy <Bestandsnaam> <opties waarden>\n" +
                                  "radius XX (standaard 3) - De radius waarin copy paste naar het volgende object zoekt\n" +
                                  "method proximity/building (standaard proximity) - Building kopieërd alleen objecten die bij het gebouw horen, proximity kopieërd alles wat gevonden is\n" +
                                  "deployables true/false (saves deployables or not) - Of de data van gevonden \"deployables\" opgeslagen moet worden\n" +
                                  "inventories true/false (saves inventories or not) - Of inventarissen van objecten (kisten, tool cupboards, etc) opgeslagen moet worden"
                        }
                    }
                },
                {
                    "NO_ENTITY_RAY", new Dictionary<string, string>
                    {
                        {"en", "Couldn't ray something valid in front of you"},
                        {"ru", "Не удалось найти какой-либо объект перед вами"},
                        {"nl", "U kijkt niet naar een geschikt object om een kopie op te starten."}
                    }
                },
                {
                    "COPY_SUCCESS", new Dictionary<string, string>
                    {
                        {"en", "The structure was successfully copied as {0}"},
                        {"ru", "Постройка успешно скопирована под названием: {0}"},
                        {"nl", "Gebouw is succesvol gekopieërd"}
                    }
                },
                {
                    "NO_PASTED_STRUCTURE", new Dictionary<string, string>
                    {
                        {"en", "You must paste structure before undoing it"},
                        {"ru", "Вы должны вставить постройку перед тем, как отменить действие"},
                        {"nl", "U moet eerst een gebouw terugplaatsen alvorens deze ongedaan gemaakt kan worden (duhh)"}
                    }
                },
                {
                    "UNDO_SUCCESS", new Dictionary<string, string>
                    {
                        {"en", "You've successfully undid what you pasted"},
                        {"ru", "Вы успешно снесли вставленную постройку"},
                        {"nl", "Laatse geplaatste gebouw is succesvol ongedaan gemaakt."}
                    }
                },
                {
                    "NOT_FOUND_PLAYER", new Dictionary<string, string>
                    {
                        {"en", "Couldn't find the player"},
                        {"ru", "Не удалось найти игрока"},
                        {"nl", "Speler niet gevonden."}
                    }
                },
                {
                    "SYNTAX_BOOL", new Dictionary<string, string>
                    {
                        {"en", "Option {0} must be true/false"},
                        {"ru", "Опция {0} принимает значения true/false"},
                        {"nl", "Optie {0} moet true of false zijn"}
                    }
                },
                {
                    "SYNTAX_HEIGHT", new Dictionary<string, string>
                    {
                        {"en", "Option height must be a number"},
                        {"ru", "Опция height принимает только числовые значения"},
                        {"nl", "De optie height accepteert alleen nummers"}
                    }
                },
                {
                    "SYNTAX_BLOCKCOLLISION", new Dictionary<string, string>
                    {
                        {"en", "Option blockcollision must be a number, 0 will deactivate the option"},
                        {
                            "ru",
                            "Опция blockcollision принимает только числовые значения, 0 позволяет отключить проверку"
                        },
                        {"nl", "Optie blockcollision accepteert alleen nummers, 0 schakelt deze functionaliteit uit"}
                    }
                },
                {
                    "SYNTAX_RADIUS", new Dictionary<string, string>
                    {
                        {"en", "Option radius must be a number"},
                        {"ru", "Опция radius принимает только числовые значения"},
                        {"nl", "Optie height accepteert alleen nummers"}
                    }
                },
                {
                    "BLOCKING_PASTE", new Dictionary<string, string>
                    {
                        {"en", "Something is blocking the paste"},
                        {"ru", "Что-то препятствует вставке"},
                        {"nl", "Iets blokkeert het plaatsen van dit gebouw"}
                    }
                },
                {
                    "AVAILABLE_STRUCTURES", new Dictionary<string, string>
                    {
                        {"ru", "<color=orange>Доступные постройки:</color>"},
                        {"en", "<color=orange>Available structures:</color>"},
                        {"nl", "Beschikbare bestanden om te plaatsen zijn:"}
                    }
                }
            };

        public class CopyData
        {
            public BasePlayer Player;
            public Stack<Vector3> CheckFrom = new Stack<Vector3>();
            public HashSet<BaseEntity> HouseList = new HashSet<BaseEntity>();
            public List<object> RawData = new List<object>();
            public Vector3 SourcePos;
            public Vector3 SourceRot;
            public Action Callback;

            public string Filename;
            public int CurrentLayer;
            public float RotCor;
            public float Range;
            public bool SaveTree;
            public bool SaveShare;
            public CopyMechanics CopyMechanics;
            public bool EachToEach;
            public uint BuildingId = 0;

#if DEBUG
            public Stopwatch Sw = new Stopwatch();
#endif
        }

        public class PasteData
        {
            public ICollection<Dictionary<string, object>> Entities;
            public List<BaseEntity> PastedEntities = new List<BaseEntity>();
            public string Filename;

            public Dictionary<uint, Dictionary<string, object>> IoEntities =
                new Dictionary<uint, Dictionary<string, object>>();

            public BasePlayer Player;
            public List<StabilityEntity> StabilityEntities = new List<StabilityEntity>();
            public Quaternion QuaternionRotation;
            public Action Callback;

            public bool Auth;
            public Vector3 StartPos;
            public float HeightAdj;
            public bool Stability;
            public bool IsItemReplace;
            public bool Ownership;

            public uint BuildingId = 0;

#if DEBUG
            public Stopwatch Sw = new Stopwatch();
#endif
        }
    }
}

// --- End of file: CopyPaste.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/NTeleportation.cs ---
// --- Original Local Path: KualaRust/NTeleportation.cs ---

//#define DEBUG
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Game.Rust;
using Rust;
using UnityEngine;
using System.Reflection;
using Oxide.Core.Libraries.Covalence;
using Network;

/*
Fixed automatic TPA after using TPT to check the required nteleportation.tpt permission
Fixed `Interrupt -> Monument` not working on some maps that are missing topology
Fixed `Allow Cave` not working on some maps that are missing topology
*/

namespace Oxide.Plugins
{
    [Info("NTeleportation", "nivex", "1.4.7")]
    [Description("Multiple teleportation systems for admin and players")]
    class NTeleportation : RustPlugin
    {
        private bool newSave;
        private string banditPrefab;
        private string outpostPrefab;
        private const bool True = true;
        private const bool False = false;
        private Vector3 Zero = default(Vector3);
        private readonly Vector3 Up = Vector3.up;
        private readonly Vector3 Down = Vector3.down;
        private const string NewLine = "\n";
        private const string ConfigDefaultPermVip = "nteleportation.vip";
        private const string PermHome = "nteleportation.home";
        private const string PermTpR = "nteleportation.tpr";
        private const string PermTpT = "nteleportation.tpt";
        private const string PermDeleteHome = "nteleportation.deletehome";
        private const string PermHomeHomes = "nteleportation.homehomes";
        private const string PermImportHomes = "nteleportation.importhomes";
        private const string PermRadiusHome = "nteleportation.radiushome";
        private const string PermTp = "nteleportation.tp";
        private const string PermTpB = "nteleportation.tpb";
        private const string PermTpConsole = "nteleportation.tpconsole";
        private const string PermTpHome = "nteleportation.tphome";
        private const string PermTpTown = "nteleportation.tptown";
        private const string PermTpOutpost = "nteleportation.tpoutpost";
        private const string PermTpBandit = "nteleportation.tpbandit";
        private const string PermTpN = "nteleportation.tpn";
        private const string PermTpL = "nteleportation.tpl";
        private const string PermTpRemove = "nteleportation.tpremove";
        private const string PermTpSave = "nteleportation.tpsave";
        private const string PermWipeHomes = "nteleportation.wipehomes";
        private const string PermCraftHome = "nteleportation.crafthome";
        private const string PermCraftTown = "nteleportation.crafttown";
        private const string PermCraftOutpost = "nteleportation.craftoutpost";
        private const string PermCraftBandit = "nteleportation.craftbandit";
        private const string PermCraftTpR = "nteleportation.crafttpr";
        private DynamicConfigFile dataConvert;
        private DynamicConfigFile dataDisabled;
        private DynamicConfigFile dataAdmin;
        private DynamicConfigFile dataHome;
        private DynamicConfigFile dataTPR;
        private DynamicConfigFile dataTPT;
        private DynamicConfigFile dataTown;
        private DynamicConfigFile dataOutpost;
        private DynamicConfigFile dataBandit;
        private Dictionary<ulong, AdminData> Admin;
        private Dictionary<ulong, HomeData> Home;
        private Dictionary<ulong, TeleportData> TPR;
        private Dictionary<string, List<string>> TPT;
        private Dictionary<ulong, TeleportData> Town;
        private Dictionary<ulong, TeleportData> Outpost;
        private Dictionary<ulong, TeleportData> Bandit;
        private bool changedAdmin;
        private bool changedHome;
        private bool changedTPR;
        private bool changedTPT;
        private bool changedTown;
        private bool changedOutpost;
        private bool changedBandit;
        private float boundary;
        private readonly int triggerLayer = LayerMask.GetMask("Trigger");
        private readonly int groundLayer = LayerMask.GetMask("Terrain", "World");
        private int buildingLayer { get; set; } = LayerMask.GetMask("Terrain", "World", "Construction", "Deployed");
        private readonly int blockLayer = LayerMask.GetMask("Construction");
        private readonly int deployedLayer = LayerMask.GetMask("Deployed");
        private readonly Dictionary<ulong, TeleportTimer> TeleportTimers = new Dictionary<ulong, TeleportTimer>();
        private readonly Dictionary<ulong, Timer> PendingRequests = new Dictionary<ulong, Timer>();
        private readonly Dictionary<ulong, BasePlayer> PlayersRequests = new Dictionary<ulong, BasePlayer>();
        private readonly Dictionary<int, string> ReverseBlockedItems = new Dictionary<int, string>();
        private readonly Dictionary<ulong, Vector3> teleporting = new Dictionary<ulong, Vector3>();
        private SortedDictionary<string, Vector3> caves = new SortedDictionary<string, Vector3>();
        private SortedDictionary<string, MonInfo> monuments = new SortedDictionary<string, MonInfo>();
        private bool outpostEnabled;
        private string OutpostTPDisabledMessage = "OutpostTPDisabled";
        private bool banditEnabled;
        private string BanditTPDisabledMessage = "BanditTPDisabled";

        [PluginReference]
        private Plugin Clans, Economics, ServerRewards, Friends, CompoundTeleport, ZoneManager, NoEscape, Vanish;

        class MonInfo
        {
            public Vector3 Position;
            public float Radius;
        }

        #region Configuration

        private static Configuration config;

        public class InterruptSettings
        {
            [JsonProperty(PropertyName = "Above Water")]
            public bool AboveWater { get; set; } = True;

            [JsonProperty(PropertyName = "Balloon")]
            public bool Balloon { get; set; } = True;

            [JsonProperty(PropertyName = "Boats")]
            public bool Boats { get; set; }

            [JsonProperty(PropertyName = "Cargo Ship")]
            public bool Cargo { get; set; } = True;

            [JsonProperty(PropertyName = "Cold")]
            public bool Cold { get; set; } = False;

            [JsonProperty(PropertyName = "Excavator")]
            public bool Excavator { get; set; } = False;

            [JsonProperty(PropertyName = "Hot")]
            public bool Hot { get; set; } = False;

            [JsonProperty(PropertyName = "Hostile")]
            public bool Hostile { get; set; } = False;

            [JsonProperty(PropertyName = "Hurt")]
            public bool Hurt { get; set; } = True;

            [JsonProperty(PropertyName = "Lift")]
            public bool Lift { get; set; } = True;

            [JsonProperty(PropertyName = "Monument")]
            public bool Monument { get; set; } = False;

            [JsonProperty(PropertyName = "Mounted")]
            public bool Mounted { get; set; } = True;

            [JsonProperty(PropertyName = "Oil Rig")]
            public bool Oilrig { get; set; } = False;

            [JsonProperty(PropertyName = "Safe Zone")]
            public bool Safe { get; set; } = True;

            [JsonProperty(PropertyName = "Swimming")]
            public bool Swimming { get; set; } = False;
        }

        public class PluginSettings
        {
            [JsonProperty(PropertyName = "Interrupt TP")]
            public InterruptSettings Interrupt { get; set; } = new InterruptSettings();

            [JsonProperty(PropertyName = "Block Teleport (NoEscape)")]
            public bool BlockNoEscape { get; set; } = False;

            [JsonProperty(PropertyName = "Block Teleport (ZoneManager)")]
            public bool BlockZoneFlag { get; set; } = False;

            [JsonProperty(PropertyName = "Chat Name")]
            public string ChatName { get; set; } = "<color=red>Teleportation</color> \n\n";

            [JsonProperty(PropertyName = "Chat Steam64ID")]
            public ulong ChatID { get; set; } = 76561199056025689;

            [JsonProperty(PropertyName = "Check Boundaries On Teleport X Y Z")]
            public bool CheckBoundaries { get; set; } = True;

            [JsonProperty(PropertyName = "Draw Sphere On Set Home")]
            public bool DrawHomeSphere { get; set; } = True;

            [JsonProperty(PropertyName = "Homes Enabled")]
            public bool HomesEnabled { get; set; } = True;

            [JsonProperty(PropertyName = "TPR Enabled")]
            public bool TPREnabled { get; set; } = True;

            [JsonProperty(PropertyName = "Town Enabled")]
            public bool TownEnabled { get; set; } = True;

            [JsonProperty(PropertyName = "Outpost Enabled")]
            public bool OutpostEnabled { get; set; } = True;

            [JsonProperty(PropertyName = "Bandit Enabled")]
            public bool BanditEnabled { get; set; } = True;

            [JsonProperty(PropertyName = "Strict Foundation Check")]
            public bool StrictFoundationCheck { get; set; } = False;

            [JsonProperty(PropertyName = "Cave Distance Small")]
            public float CaveDistanceSmall { get; set; } = 50f;

            [JsonProperty(PropertyName = "Cave Distance Medium")]
            public float CaveDistanceMedium { get; set; } = 70f;

            [JsonProperty(PropertyName = "Cave Distance Large")]
            public float CaveDistanceLarge { get; set; } = 110f;

            [JsonProperty(PropertyName = "Default Monument Size")]
            public float DefaultMonumentSize { get; set; } = 50f;

            [JsonProperty(PropertyName = "Minimum Temp")]
            public float MinimumTemp { get; set; } = 0f;

            [JsonProperty(PropertyName = "Maximum Temp")]
            public float MaximumTemp { get; set; } = 40f;

            [JsonProperty(PropertyName = "Blocked Items", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, string> BlockedItems { get; set; } = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

            [JsonProperty(PropertyName = "Bypass CMD")]
            public string BypassCMD { get; set; } = "pay";

            [JsonProperty(PropertyName = "Use Economics")]
            public bool UseEconomics { get; set; } = False;

            [JsonProperty(PropertyName = "Use Server Rewards")]
            public bool UseServerRewards { get; set; } = False;

            [JsonProperty(PropertyName = "Wipe On Upgrade Or Change")]
            public bool WipeOnUpgradeOrChange { get; set; } = False;

            [JsonProperty(PropertyName = "Auto Generate Outpost Location")]
            public bool AutoGenOutpost { get; set; } = False;

            [JsonProperty(PropertyName = "Auto Generate Bandit Location")]
            public bool AutoGenBandit { get; set; } = False;
        }

        public class AdminSettings
        {
            [JsonProperty(PropertyName = "Announce Teleport To Target")]
            public bool AnnounceTeleportToTarget { get; set; } = False;

            [JsonProperty(PropertyName = "Usable By Admins")]
            public bool UseableByAdmins { get; set; } = True;

            [JsonProperty(PropertyName = "Usable By Moderators")]
            public bool UseableByModerators { get; set; } = True;

            [JsonProperty(PropertyName = "Location Radius")]
            public int LocationRadius { get; set; } = 25;

            [JsonProperty(PropertyName = "Teleport Near Default Distance")]
            public int TeleportNearDefaultDistance { get; set; } = 30;
        }

        public class HomesSettings
        {
            [JsonProperty(PropertyName = "Homes Limit")]
            public int HomesLimit { get; set; } = 2;

            [JsonProperty(PropertyName = "VIP Homes Limits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPHomesLimits { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "Cooldown")]
            public int Cooldown { get; set; } = 600;

            [JsonProperty(PropertyName = "Countdown")]
            public int Countdown { get; set; } = 15;

            [JsonProperty(PropertyName = "Daily Limit")]
            public int DailyLimit { get; set; } = 5;

            [JsonProperty(PropertyName = "VIP Daily Limits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPDailyLimits { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "VIP Cooldowns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPCooldowns { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "VIP Countdowns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPCountdowns { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "Location Radius")]
            public int LocationRadius { get; set; } = 25;

            [JsonProperty(PropertyName = "Force On Top Of Foundation")]
            public bool ForceOnTopOfFoundation { get; set; } = True;

            [JsonProperty(PropertyName = "Check Foundation For Owner")]
            public bool CheckFoundationForOwner { get; set; } = True;

            [JsonProperty(PropertyName = "Use Friends")]
            public bool UseFriends { get; set; } = True;

            [JsonProperty(PropertyName = "Use Clans")]
            public bool UseClans { get; set; } = True;

            [JsonProperty(PropertyName = "Use Teams")]
            public bool UseTeams { get; set; } = True;

            [JsonProperty(PropertyName = "Usable Out Of Building Blocked")]
            public bool UsableOutOfBuildingBlocked { get; set; } = False;

            [JsonProperty(PropertyName = "Usable Into Building Blocked")]
            public bool UsableIntoBuildingBlocked { get; set; } = False;

            [JsonProperty(PropertyName = "Allow Cupboard Owner When Building Blocked")]
            public bool CupOwnerAllowOnBuildingBlocked { get; set; } = True;

            [JsonProperty(PropertyName = "Allow Iceberg")]
            public bool AllowIceberg { get; set; } = False;

            [JsonProperty(PropertyName = "Allow Cave")]
            public bool AllowCave { get; set; } = False;

            [JsonProperty(PropertyName = "Allow Crafting")]
            public bool AllowCraft { get; set; } = False;

            [JsonProperty(PropertyName = "Allow Above Foundation")]
            public bool AllowAboveFoundation { get; set; } = True;

            [JsonProperty(PropertyName = "Check If Home Is Valid On Listhomes")]
            public bool CheckValidOnList { get; set; } = False;

            [JsonProperty(PropertyName = "Pay")]
            public int Pay { get; set; } = 0;

            [JsonProperty(PropertyName = "Bypass")]
            public int Bypass { get; set; } = 0;
        }

        public class TPTSettings
        {
            [JsonProperty(PropertyName = "Use Friends")]
            public bool UseFriends { get; set; }

            [JsonProperty(PropertyName = "Use Clans")]
            public bool UseClans { get; set; }

            [JsonProperty(PropertyName = "Use Teams")]
            public bool UseTeams { get; set; }

            [JsonProperty(PropertyName = "Allow Cave")]
            public bool AllowCave { get; set; }
        }

        public class TPRSettings
        {
            [JsonProperty(PropertyName = "Require Player To Be Friend, Clan Mate, Or Team Mate")]
            public bool UseClans_Friends_Teams { get; set; }

            [JsonProperty(PropertyName = "Allow Cave")]
            public bool AllowCave { get; set; } = False;

            [JsonProperty(PropertyName = "Allow TPB")]
            public bool AllowTPB { get; set; } = True;

            [JsonProperty(PropertyName = "Cooldown")]
            public int Cooldown { get; set; } = 600;

            [JsonProperty(PropertyName = "Countdown")]
            public int Countdown { get; set; } = 15;

            [JsonProperty(PropertyName = "Daily Limit")]
            public int DailyLimit { get; set; } = 5;

            [JsonProperty(PropertyName = "VIP Daily Limits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPDailyLimits { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "VIP Cooldowns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPCooldowns { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "VIP Countdowns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPCountdowns { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "Request Duration")]
            public int RequestDuration { get; set; } = 30;

            [JsonProperty(PropertyName = "Block TPA On Ceiling")]
            public bool BlockTPAOnCeiling { get; set; } = True;

            [JsonProperty(PropertyName = "Usable Out Of Building Blocked")]
            public bool UsableOutOfBuildingBlocked { get; set; } = False;

            [JsonProperty(PropertyName = "Usable Into Building Blocked")]
            public bool UsableIntoBuildingBlocked { get; set; } = False;

            [JsonProperty(PropertyName = "Allow Cupboard Owner When Building Blocked")]
            public bool CupOwnerAllowOnBuildingBlocked { get; set; } = True;

            [JsonProperty(PropertyName = "Allow Crafting")]
            public bool AllowCraft { get; set; } = False;

            [JsonProperty(PropertyName = "Pay")]
            public int Pay { get; set; } = 0;

            [JsonProperty(PropertyName = "Bypass")]
            public int Bypass { get; set; } = 0;
        }

        public class TownSettings
        {
            [JsonProperty(PropertyName = "Allow Cave")]
            public bool AllowCave { get; set; } = False;

            [JsonProperty(PropertyName = "Cooldown")]
            public int Cooldown { get; set; } = 600;

            [JsonProperty(PropertyName = "Countdown")]
            public int Countdown { get; set; } = 15;

            [JsonProperty(PropertyName = "Daily Limit")]
            public int DailyLimit { get; set; } = 5;

            [JsonProperty(PropertyName = "VIP Daily Limits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPDailyLimits { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "VIP Cooldowns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPCooldowns { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "VIP Countdowns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPCountdowns { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "Location")]
            public Vector3 Location { get; set; } = Vector3.zero;

            [JsonProperty(PropertyName = "Usable Out Of Building Blocked")]
            public bool UsableOutOfBuildingBlocked { get; set; } = False;

            [JsonProperty(PropertyName = "Allow Crafting")]
            public bool AllowCraft { get; set; } = False;

            [JsonProperty(PropertyName = "Pay")]
            public int Pay { get; set; } = 0;

            [JsonProperty(PropertyName = "Bypass")]
            public int Bypass { get; set; } = 0;
        }

        private class Configuration
        {
            [JsonProperty(PropertyName = "Settings")]
            public PluginSettings Settings = new PluginSettings();

            [JsonProperty(PropertyName = "Admin")]
            public AdminSettings Admin = new AdminSettings();

            [JsonProperty(PropertyName = "Home")]
            public HomesSettings Home = new HomesSettings();

            [JsonProperty(PropertyName = "TPT")]
            public TPTSettings TPT = new TPTSettings();

            [JsonProperty(PropertyName = "TPR")]
            public TPRSettings TPR = new TPRSettings();

            [JsonProperty(PropertyName = "Town")]
            public TownSettings Town = new TownSettings();

            [JsonProperty(PropertyName = "Outpost")]
            public TownSettings Outpost = new TownSettings();

            [JsonProperty(PropertyName = "Bandit")]
            public TownSettings Bandit = new TownSettings();
        }

        private bool pluginLoaded;

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                Config.Settings.Converters = new JsonConverter[] { new UnityVector3Converter() };
                config = Config.ReadObject<Configuration>();
                if (config == null) throw new Exception();
            }
            catch (JsonException)
            {
                PrintError("Your configuration file contains a json exception error. Please fix and reload.");
                LoadDefaultConfig();
                return;
            }
            catch (Exception)
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }

            pluginLoaded = true;
            SaveConfig();
        }

        protected override void SaveConfig()
        {
            if (!pluginLoaded) return;
            Config.WriteObject(config);
        }

        protected override void LoadDefaultConfig()
        {
            config = new Configuration();
            Puts("Loaded default configuration.");
        }

        #endregion

        class DisabledData
        {
            [JsonProperty("List of disabled commands")]
            public List<string> DisabledCommands = new List<string>();

            public DisabledData() { }
        }

        DisabledData DisabledTPT = new DisabledData();

        class AdminData
        {
            [JsonProperty("pl")]
            public Vector3 PreviousLocation { get; set; }

            [JsonProperty("l")]
            public Dictionary<string, Vector3> Locations { get; set; } = new Dictionary<string, Vector3>(StringComparer.OrdinalIgnoreCase);
        }

        class HomeData
        {
            [JsonProperty("l")]
            public Dictionary<string, Vector3> Locations { get; set; } = new Dictionary<string, Vector3>(StringComparer.OrdinalIgnoreCase);

            [JsonProperty("t")]
            public TeleportData Teleports { get; set; } = new TeleportData();
        }

        class TeleportData
        {
            [JsonProperty("a")]
            public int Amount { get; set; }

            [JsonProperty("d")]
            public string Date { get; set; }

            [JsonProperty("t")]
            public int Timestamp { get; set; }
        }

        class TeleportTimer
        {
            public Timer Timer { get; set; }
            public BasePlayer OriginPlayer { get; set; }
            public BasePlayer TargetPlayer { get; set; }
        }

        private enum checkmode
        {
            home, tpr, tpa, town
        };

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"AdminTP", "You teleported to {0}!"},
                {"AdminTPTarget", "{0} teleported to you!"},
                {"AdminTPPlayers", "You teleported {0} to {1}!"},
                {"AdminTPPlayer", "{0} teleported you to {1}!"},
                {"AdminTPPlayerTarget", "{0} teleported {1} to you!"},
                {"AdminTPCoordinates", "You teleported to {0}!"},
                {"AdminTPTargetCoordinates", "You teleported {0} to {1}!"},
                {"AdminTPOutOfBounds", "You tried to teleport to a set of coordinates outside the map boundaries!"},
                {"AdminTPBoundaries", "X and Z values need to be between -{0} and {0} while the Y value needs to be between -100 and 2000!"},
                {"AdminTPLocation", "You teleported to {0}!"},
                {"AdminTPLocationSave", "You have saved the current location!"},
                {"AdminTPLocationRemove", "You have removed the location {0}!"},
                {"AdminLocationList", "The following locations are available:"},
                {"AdminLocationListEmpty", "You haven't saved any locations!"},
                {"AdminTPBack", "You've teleported back to your previous location!"},
                {"AdminTPBackSave", "Your previous location has been saved, use /tpb to teleport back!"},
                {"AdminTPTargetCoordinatesTarget", "{0} teleported you to {1}!"},
                {"AdminTPConsoleTP", "You were teleported to {0}"},
                {"AdminTPConsoleTPPlayer", "You were teleported to {0}"},
                {"AdminTPConsoleTPPlayerTarget", "{0} was teleported to you!"},
                {"HomeTP", "You teleported to your home '{0}'!"},
                {"HomeAdminTP", "You teleported to {0}'s home '{1}'!"},
                {"HomeSave", "You have saved the current location as your home!"},
                {"HomeNoFoundation", "You can only use a home location on a foundation!"},
                {"HomeFoundationNotOwned", "You can't use home on someone else's house."},
                {"HomeFoundationUnderneathFoundation", "You can't use home on a foundation that is underneath another foundation."},
                {"HomeFoundationNotFriendsOwned", "You or a friend need to own the house to use home!"},
                {"HomeRemovedInvalid", "Your home '{0}' was removed because not on a foundation or not owned!"},
                {"HighWallCollision", "High Wall Collision!"},
                {"HomeRemovedInsideBlock", "Your home '{0}' was removed because inside a foundation!"},
                {"HomeRemove", "You have removed your home {0}!"},
                {"HomeDelete", "You have removed {0}'s home '{1}'!"},
                {"HomeList", "The following homes are available:"},
                {"HomeListEmpty", "You haven't saved any homes!"},
                {"HomeMaxLocations", "Unable to set your home here, you have reached the maximum of {0} homes!"},
                {"HomeQuota", "You have set {0} of the maximum {1} homes!"},
                {"HomeTPStarted", "Teleporting to your home {0} in {1} seconds!"},
                {"PayToHome", "Standard payment of {0} applies to all home teleports!"},
                {"PayToTown", "Standard payment of {0} applies to all town teleports!"},
                {"PayToTPR", "Standard payment of {0} applies to all tprs!"},
                {"HomeTPCooldown", "Your teleport is currently on cooldown. You'll have to wait {0} for your next teleport."},
                {"HomeTPCooldownBypass", "Your teleport was currently on cooldown. You chose to bypass that by paying {0} from your balance."},
                {"HomeTPCooldownBypassF", "Your teleport is currently on cooldown. You do not have sufficient funds - {0} - to bypass."},
                {"HomeTPCooldownBypassP", "You may choose to pay {0} to bypass this cooldown." },
                {"HomeTPCooldownBypassP2", "Type /home NAME {0}." },
                {"HomeTPLimitReached", "You have reached the daily limit of {0} teleports today!"},
                {"HomeTPAmount", "You have {0} home teleports left today!"},
                {"HomesListWiped", "You have wiped all the saved home locations!"},
                {"HomeTPBuildingBlocked", "You can't set your home if you are not allowed to build in this zone!"},
                {"HomeTPSwimming", "You can't set your home while swimming!"},
                {"HomeTPCrafting", "You can't set your home while crafting!"},
                {"Request", "You've requested a teleport to {0}!"},
                {"RequestTarget", "{0} requested to be teleported to you! Use '/tpa' to accept!"},
                {"TPR_NoClan_NoFriend_NoTeam", "This command is only available to friends or teammates or clanmates!"},
                {"PendingRequest", "You already have a request pending, cancel that request or wait until it gets accepted or times out!"},
                {"PendingRequestTarget", "The player you wish to teleport to already has a pending request, try again later!"},
                {"NoPendingRequest", "You have no pending teleport request!"},
                {"AcceptOnRoof", "You can't accept a teleport while you're on a ceiling, get to ground level!"},
                {"Accept", "{0} has accepted your teleport request! Teleporting in {1} seconds!"},
                {"AcceptTarget", "You've accepted the teleport request of {0}!"},
                {"NotAllowed", "You are not allowed to use this command!"},
                {"Success", "You teleported to {0}!"},
                {"SuccessTarget", "{0} teleported to you!"},
                {"Cancelled", "Your teleport request to {0} was cancelled!"},
                {"CancelledTarget", "{0} teleport request was cancelled!"},
                {"TPCancelled", "Your teleport was cancelled!"},
                {"TPCancelledTarget", "{0} cancelled teleport!"},
                {"TPYouCancelledTarget", "You cancelled {0} teleport!"},
                {"TimedOut", "{0} did not answer your request in time!"},
                {"TimedOutTarget", "You did not answer {0}'s teleport request in time!"},
                {"TargetDisconnected", "{0} has disconnected, your teleport was cancelled!"},
                {"TPRCooldown", "Your teleport requests are currently on cooldown. You'll have to wait {0} to send your next teleport request."},
                {"TPRCooldownBypass", "Your teleport request was on cooldown. You chose to bypass that by paying {0} from your balance."},
                {"TPRCooldownBypassF", "Your teleport is currently on cooldown. You do not have sufficient funds - {0} - to bypass."},
                {"TPRCooldownBypassP", "You may choose to pay {0} to bypass this cooldown." },
                {"TPMoney", "{0} deducted from your account!"},
                {"TPNoMoney", "You do not have {0} in any account!"},
                {"TPRCooldownBypassP2", "Type /tpr {0}." },
                {"TPRCooldownBypassP2a", "Type /tpr NAME {0}." },
                {"TPRLimitReached", "You have reached the daily limit of {0} teleport requests today!"},
                {"TPRAmount", "You have {0} teleport requests left today!"},
                {"TPRTarget", "Your target is currently not available!"},
                {"TPDead", "You can't teleport while being dead!"},
                {"TPWounded", "You can't teleport while wounded!"},
                {"TPTooCold", "You're too cold to teleport!"},
                {"TPTooHot", "You're too hot to teleport!"},
                {"TPBoat", "You can't teleport while on a boat!"},
                {"TPHostile", "Can't teleport to outpost or bandit when hostile!"},
                {"HostileTimer", "Teleport available in {0} minutes."},
                {"TPMounted", "You can't teleport while seated!"},
                {"TPBuildingBlocked", "You can't teleport while in a building blocked zone!"},
                {"TPAboveWater", "You can't teleport while above water!"},
                {"TPTargetBuildingBlocked", "You can't teleport in a building blocked zone!"},
                {"TPTargetInsideBlock", "You can't teleport into a foundation!"},
                {"TPSwimming", "You can't teleport while swimming!"},
                {"TPCargoShip", "You can't teleport from the cargo ship!"},
                {"TPOilRig", "You can't teleport from the oil rig!"},
                {"TPExcavator", "You can't teleport from the excavator!"},
                {"TPHotAirBalloon", "You can't teleport to or from a hot air balloon!"},
                {"TPLift", "You can't teleport while in an elevator or bucket lift!"},
                {"TPBucketLift", "You can't teleport while in a bucket lift!"},
                {"TPRegLift", "You can't teleport while in an elevator!"},
                {"TPSafeZone", "You can't teleport from a safezone!"},
                {"TPFlagZone", "You can't teleport from this zone!"},
                {"TPNoEscapeBlocked", "You can't teleport while blocked!"},
                {"TPCrafting", "You can't teleport while crafting!"},
                {"TPBlockedItem", "You can't teleport while carrying: {0}!"},
                {"TooCloseToMon", "You can't teleport so close to the {0}!"},
                {"TooCloseToCave", "You can't teleport so close to a cave!"},
                {"HomeTooCloseToCave", "You can't set home so close to a cave!"},
                {"TownTP", "You teleported to town!"},
                {"TownTPNotSet", "Town is currently not set!"},
                {"TownTPDisabled", "Town is currently not enabled!"},
                {"TownTPLocation", "You have set the town location to {0}!"},
                {"TownTPStarted", "Teleporting to town in {0} seconds!"},
                {"TownTPCooldown", "Your teleport is currently on cooldown. You'll have to wait {0} for your next teleport."},
                {"TownTPCooldownBypass", "Your teleport request was on cooldown. You chose to bypass that by paying {0} from your balance."},
                {"TownTPCooldownBypassF", "Your teleport is currently on cooldown. You do not have sufficient funds - {0} - to bypass."},
                {"TownTPCooldownBypassP", "You may choose to pay {0} to bypass this cooldown." },
                {"TownTPCooldownBypassP2", "Type /town {0}." },
                {"TownTPLimitReached", "You have reached the daily limit of {0} teleports today!"},
                {"TownTPAmount", "You have {0} town teleports left today!"},

                {"OutpostTP", "You teleported to the outpost!"},
                {"OutpostTPNotSet", "Outpost is currently not set!"},
                {"OutpostTPDisabled", "Outpost is currently not enabled!"},
                {"OutpostTPDisabledConfig", "Outpost is currently not enabled"},
                {"OutpostTPDisabledNoLocation", "Outpost is currently not enabled, location is not set and auto generation is disabled!"},
                {"OutpostTPDisabledNoLocationAutoGen", "Outpost is currently not enabled because auto generation failed!"},
                {"OutpostTPLocation", "You have set the outpost location to {0}!"},
                {"OutpostTPStarted", "Teleporting to the outpost in {0} seconds!"},
                {"OutpostTPCooldown", "Your teleport is currently on cooldown. You'll have to wait {0} for your next teleport."},
                {"OutpostTPCooldownBypass", "Your teleport request was on cooldown. You chose to bypass that by paying {0} from your balance."},
                {"OutpostTPCooldownBypassF", "Your teleport is currently on cooldown. You do not have sufficient funds - {0} - to bypass."},
                {"OutpostTPCooldownBypassP", "You may choose to pay {0} to bypass this cooldown." },
                {"OutpostTPCooldownBypassP2", "Type /outpost {0}." },
                {"OutpostTPLimitReached", "You have reached the daily limit of {0} teleports today!"},
                {"OutpostTPAmount", "You have {0} outpost teleports left today!"},

                {"BanditTP", "You teleported to bandit town!"},
                {"BanditTPNotSet", "Bandit is currently not set!"},
                {"BanditTPDisabled", "Bandit is currently not enabled!"},
                {"BanditTPDisabledConfig", "Bandit is currently not enabled because it isn't enabled in the config!"},
                {"BanditTPDisabledNoLocation", "Bandit is currently not enabled, location is not set and auto generation is disabled!"},
                {"BanditTPDisabledNoLocationAutoGen", "Bandit is currently not enabled because auto generation failed!"},
                {"BanditTPLocation", "You have set the bandit town location to {0}!"},
                {"BanditTPStarted", "Teleporting to bandit town in {0} seconds!"},
                {"BanditTPCooldown", "Your teleport is currently on cooldown. You'll have to wait {0} for your next teleport."},
                {"BanditTPCooldownBypass", "Your teleport request was on cooldown. You chose to bypass that by paying {0} from your balance."},
                {"BanditTPCooldownBypassF", "Your teleport is currently on cooldown. You do not have sufficient funds - {0} - to bypass."},
                {"BanditTPCooldownBypassP", "You may choose to pay {0} to bypass this cooldown." },
                {"BanditTPCooldownBypassP2", "Type /bandit {0}." },
                {"BanditTPLimitReached", "You have reached the daily limit of {0} teleports today!"},
                {"BanditTPAmount", "You have {0} bandit town teleports left today!"},

                {"Interrupted", "Your teleport was interrupted!"},
                {"InterruptedTarget", "{0}'s teleport was interrupted!"},
                {"Unlimited", "Unlimited"},
                {
                    "TPInfoGeneral", string.Join(NewLine, new[]
                    {
                        "Please specify the module you want to view the info of.",
                        "The available modules are: ",
                    })
                },
                {
                    "TPHelpGeneral", string.Join(NewLine, new[]
                    {
                        "/tpinfo - Shows limits and cooldowns.",
                        "Please specify the module you want to view the help of.",
                        "The available modules are: ",
                    })
                },
                {
                    "TPHelpadmintp", string.Join(NewLine, new[]
                    {
                        "As an admin you have access to the following commands:",
                        "/tp \"targetplayer\" - Teleports yourself to the target player.",
                        "/tp \"player\" \"targetplayer\" - Teleports the player to the target player.",
                        "/tp x y z - Teleports you to the set of coordinates.",
                        "/tpl - Shows a list of saved locations.",
                        "/tpl \"location name\" - Teleports you to a saved location.",
                        "/tpsave \"location name\" - Saves your current position as the location name.",
                        "/tpremove \"location name\" - Removes the location from your saved list.",
                        "/tpb - Teleports you back to the place where you were before teleporting.",
                        "/home radius \"radius\" - Find all homes in radius.",
                        "/home delete \"player name|id\" \"home name\" - Remove a home from a player.",
                        "/home tp \"player name|id\" \"name\" - Teleports you to the home location with the name 'name' from the player.",
                        "/home homes \"player name|id\" - Shows you a list of all homes from the player."
                    })
                },
                {
                    "TPHelphome", string.Join(NewLine, new[]
                    {
                        "With the following commands you can set your home location to teleport back to:",
                        "/home add \"name\" - Saves your current position as the location name.",
                        "/home list - Shows you a list of all the locations you have saved.",
                        "/home remove \"name\" - Removes the location of your saved homes.",
                        "/home \"name\" - Teleports you to the home location."
                    })
                },
                {
                    "TPHelptpr", string.Join(NewLine, new[]
                    {
                        "With these commands you can request to be teleported to a player or accept someone else's request:",
                        "/tpr \"player name\" - Sends a teleport request to the player.",
                        "/tpa - Accepts an incoming teleport request.",
                        "/tpc - Cancel teleport or request."
                    })
                },
                {
                    "TPSettingsGeneral", string.Join(NewLine, new[]
                    {
                        "Please specify the module you want to view the settings of. ",
                        "The available modules are:",
                    })
                },
                {
                    "TPSettingshome", string.Join(NewLine, new[]
                    {
                        "Home System has the current settings enabled:",
                        "Time between teleports: {0}",
                        "Daily amount of teleports: {1}",
                        "Amount of saved Home locations: {2}"
                    })
                },
                {
                    "TPSettingsbandit", string.Join(NewLine, new[]
                    {
                        "Bandit System has the current settings enabled:",
                        "Time between teleports: {0}",
                        "Daily amount of teleports: {1}"
                    })
                },
                {
                    "TPSettingsoutpost", string.Join(NewLine, new[]
                    {
                        "Outpost System has the current settings enabled:",
                        "Time between teleports: {0}",
                        "Daily amount of teleports: {1}"
                    })
                },
                {
                    "TPSettingstpr", string.Join(NewLine, new[]
                    {
                        "TPR System has the current settings enabled:",
                        "Time between teleports: {0}",
                        "Daily amount of teleports: {1}"
                    })
                },
                {
                    "TPSettingstown", string.Join(NewLine, new[]
                    {
                        "Town System has the current settings enabled:",
                        "Time between teleports: {0}",
                        "Daily amount of teleports: {1}"
                    })
                },
                {"TPT_True", "enabled"},
                {"TPT_False", "disabled"},
                {"TPT_clan", "TPT clan has been {0}."},
                {"TPT_friend", "TPT friend has been {0}."},
                {"TPT_team", "TPT team has been {0}."},
                {"NotValidTPT", "Not valid, player is not"},
                {"NotValidTPTFriend", " a friend!"},
                {"NotValidTPTTeam", " on your team!"},
                {"NotValidTPTClan", " in your clan!"},
                {"TPTInfo", "`/tpt clan|team|friend` - toggle allowing/blocking of players trying to TPT to you via one of these options."},
                {"PlayerNotFound", "The specified player couldn't be found please try again!"},
                {"MultiplePlayers", "Found multiple players: {0}"},
                {"CantTeleportToSelf", "You can't teleport to yourself!"},
                {"CantTeleportPlayerToSelf", "You can't teleport a player to himself!"},
                {"TeleportPendingTPC", "You can't initiate another teleport while you have a teleport pending! Use /tpc to cancel this."},
                {"TeleportPendingTarget", "You can't request a teleport to someone who's about to teleport!"},
                {"LocationExists", "A location with this name already exists at {0}!"},
                {"LocationExistsNearby", "A location with the name {0} already exists near this position!"},
                {"LocationNotFound", "Couldn't find a location with that name!"},
                {"NoPreviousLocationSaved", "No previous location saved!"},
                {"HomeExists", "You have already saved a home location by this name!"},
                {"HomeExistsNearby", "A home location with the name {0} already exists near this position!"},
                {"HomeNotFound", "Couldn't find your home with that name!"},
                {"InvalidCoordinates", "The coordinates you've entered are invalid!"},
                {"InvalidHelpModule", "Invalid module supplied!"},
                {"InvalidCharacter", "You have used an invalid character, please limit yourself to the letters a to z and numbers."},
                {
                    "SyntaxCommandTP", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tp command as follows:",
                        "/tp \"targetplayer\" - Teleports yourself to the target player.",
                        "/tp \"player\" \"targetplayer\" - Teleports the player to the target player.",
                        "/tp x y z - Teleports you to the set of coordinates.",
                        "/tp \"player\" x y z - Teleports the player to the set of coordinates."
                    })
                },
                {
                    "SyntaxCommandTPL", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tpl command as follows:",
                        "/tpl - Shows a list of saved locations.",
                        "/tpl \"location name\" - Teleports you to a saved location."
                    })
                },
                {
                    "SyntaxCommandTPSave", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tpsave command as follows:",
                        "/tpsave \"location name\" - Saves your current position as 'location name'."
                    })
                },
                {
                    "SyntaxCommandTPRemove", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tpremove command as follows:",
                        "/tpremove \"location name\" - Removes the location with the name 'location name'."
                    })
                },
                {
                    "SyntaxCommandTPN", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tpn command as follows:",
                        "/tpn \"targetplayer\" - Teleports yourself the default distance behind the target player.",
                        "/tpn \"targetplayer\" \"distance\" - Teleports you the specified distance behind the target player."
                    })
                },
                {
                    "SyntaxCommandSetHome", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /home add command as follows:",
                        "/home add \"name\" - Saves the current location as your home with the name 'name'."
                    })
                },
                {
                    "SyntaxCommandRemoveHome", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /home remove command as follows:",
                        "/home remove \"name\" - Removes the home location with the name 'name'."
                    })
                },
                {
                    "SyntaxCommandHome", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /home command as follows:",
                        "/home \"name\" - Teleports yourself to your home with the name 'name'.",
                        "/home \"name\" pay - Teleports yourself to your home with the name 'name', avoiding cooldown by paying for it.",
                        "/home add \"name\" - Saves the current location as your home with the name 'name'.",
                        "/home list - Shows you a list of all your saved home locations.",
                        "/home remove \"name\" - Removes the home location with the name 'name'."
                    })
                },
                {
                    "SyntaxCommandHomeAdmin", string.Join(NewLine, new[]
                    {
                        "/home radius \"radius\" - Shows you a list of all homes in radius(10).",
                        "/home delete \"player name|id\" \"name\" - Removes the home location with the name 'name' from the player.",
                        "/home tp \"player name|id\" \"name\" - Teleports you to the home location with the name 'name' from the player.",
                        "/home homes \"player name|id\" - Shows you a list of all homes from the player."
                    })
                },
                {
                    "SyntaxCommandTown", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /town command as follows:",
                        "/town - Teleports yourself to town.",
                        "/town pay - Teleports yourself to town, paying the penalty."
                    })
                },
                {
                    "SyntaxCommandTownAdmin", string.Join(NewLine, new[]
                    {
                        "/town set - Saves the current location as town.",
                    })
                },
                {
                    "SyntaxCommandOutpost", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /outpost command as follows:",
                        "/outpost - Teleports yourself to the Outpost.",
                        "/outpost pay - Teleports yourself to the Outpost, paying the penalty."
                    })
                },
                {
                    "SyntaxCommandOutpostAdmin", string.Join(NewLine, new[]
                    {
                        "/outpost set - Saves the current location as Outpost.",
                    })
                },
                {
                    "SyntaxCommandBandit", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /bandit command as follows:",
                        "/bandit - Teleports yourself to the Bandit Town.",
                        "/bandit pay - Teleports yourself to the Bandit Town, paying the penalty."
                    })
                },
                {
                    "SyntaxCommandBanditAdmin", string.Join(NewLine, new[]
                    {
                        "/bandit set - Saves the current location as Bandit Town.",
                    })
                },
                {
                    "SyntaxCommandHomeDelete", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /home delete command as follows:",
                        "/home delete \"player name|id\" \"name\" - Removes the home location with the name 'name' from the player."
                    })
                },
                {
                    "SyntaxCommandHomeAdminTP", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /home tp command as follows:",
                        "/home tp \"player name|id\" \"name\" - Teleports you to the home location with the name 'name' from the player."
                    })
                },
                {
                    "SyntaxCommandHomeHomes", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /home homes command as follows:",
                        "/home homes \"player name|id\" - Shows you a list of all homes from the player."
                    })
                },
                {
                    "SyntaxCommandListHomes", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /home list command as follows:",
                        "/home list - Shows you a list of all your saved home locations."
                    })
                },
                {
                    "SyntaxCommandTPT", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tpt command as follows:",
                        "/tpt \"player name\" - Teleports you to a team or clan member."
                    })
                },
                {
                    "SyntaxCommandTPR", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tpr command as follows:",
                        "/tpr \"player name\" - Sends out a teleport request to 'player name'."
                    })
                },
                {
                    "SyntaxCommandTPA", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tpa command as follows:",
                        "/tpa - Accepts an incoming teleport request."
                    })
                },
                {
                    "SyntaxCommandTPC", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tpc command as follows:",
                        "/tpc - Cancels an teleport request."
                    })
                },
                {
                    "SyntaxConsoleCommandToPos", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the teleport.topos console command as follows:",
                        " > teleport.topos \"player\" x y z"
                    })
                },
                {
                    "SyntaxConsoleCommandToPlayer", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the teleport.toplayer console command as follows:",
                        " > teleport.toplayer \"player\" \"target player\""
                    })
                },
                {"LogTeleport", "{0} teleported to {1}."},
                {"LogTeleportPlayer", "{0} teleported {1} to {2}."},
                {"LogTeleportBack", "{0} teleported back to previous location."}
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"AdminTP", "Вы телепортированы к {0}!"},
                {"AdminTPTarget", "{0} телепортировал вас!"},
                {"AdminTPPlayers", "Вы телепортировали {0} к {1}!"},
                {"AdminTPPlayer", "{0} телепортировал вас к {1}!"},
                {"AdminTPPlayerTarget", "{0} телепортировал {1} к вам!"},
                {"AdminTPCoordinates", "Вы телепортированы к {0}!"},
                {"AdminTPTargetCoordinates", "Вы телепортировали {0} к {1}!"},
                {"AdminTPOutOfBounds", "Вы пытались телепортироваться к координатам вне границ карты!"},
                {"AdminTPBoundaries", "Значения X и Z должны быть между -{0} и {0}, а значение Y между -100 и 2000!"},
                {"AdminTPLocation", "Вы телепортированы к {0}!"},
                {"AdminTPLocationSave", "Вы сохранили текущее местоположение!"},
                {"AdminTPLocationRemove", "Вы удалили местоположение {0}!"},
                {"AdminLocationList", "Доступны следующие местоположения:"},
                {"AdminLocationListEmpty", "Вы не сохранили никаких местоположений!"},
                {"AdminTPBack", "Вы телепортированы назад, в ваше предыдущее местоположение!"},
                {"AdminTPBackSave", "Ваше предыдущее местоположение сохранено, используйте <color=yellow>/tpb</color>, чтобы телепортироваться назад!"},
                {"AdminTPTargetCoordinatesTarget", "{0} телепортировал вас к {1}!"},
                {"AdminTPConsoleTP", "Вы были телепортированы к {0}"},
                {"AdminTPConsoleTPPlayer", "Вы были телепортированы к {0}"},
                {"AdminTPConsoleTPPlayerTarget", "{0} был телепортирован к вам!"},
                {"HomeTP", "Вы телепортированы в ваш дом '{0}'!"},
                {"HomeAdminTP", "Вы телепортированы к дому '{1}' принадлежащему {0}!"},
                {"HomeSave", "Вы сохранили текущее местоположение как ваш дом!"},
                {"HomeNoFoundation", "Использовать местоположение в качестве дома разрешено только на фундаменте!"},
                {"HomeFoundationNotOwned", "Вы не можете использовать команду home в чужом доме."},
                {"HomeFoundationUnderneathFoundation", "Вы не можете использовать команду home на фундаменте, который находится под другим фундаментом."},
                {"HomeFoundationNotFriendsOwned", "Вы, или ваш друг, должны быть владельцем дома, чтобы использовать команду home!"},
                {"HomeRemovedInvalid", "Ваш дом '{0}' был удалён потому, что не на фундаменте, или у фундамента новый владелец!"},
                {"HighWallCollision", "Столкновение Высоких Стен!"},
                {"HomeRemovedInsideBlock", "Ваш дом '{0}' был удалён потому, что внутри фундамента!"},
                {"HomeRemove", "Вы удалили свой дом {0}!"},
                {"HomeDelete", "Вы удалили дом '{1}' принадлежащий {0}!"},
                {"HomeList", "Доступны следующие дома:"},
                {"HomeListEmpty", "Вы не сохранили ни одного дома!"},
                {"HomeMaxLocations", "Невозможно установить здесь ваш дом, вы достигли лимита в {0} домов!"},
                {"HomeQuota", "Вы установили {0} из {1} максимально возможных домов!"},
                {"HomeTPStarted", "Телепортация в ваш дом {0} через {1} секунд!"},
                {"PayToHome", "Стандартный платеж {0} распространяется на все телепорты домой!"},
                {"PayToTown", "Стандартный платеж {0} распространяется на все телепорты в город!"},
                {"PayToTPR", "Стандартный платеж {0} распространяется на все tpr'ы!"},
                {"HomeTPCooldown", "Ваш телепорт перезаряжается. Вам необходимо подождать {0} до следующей телепортации."},
                {"HomeTPCooldownBypass", "Ваш телепорт был на перезарядке. Вы выбрали избежать ожидания, оплатив {0} с вашего баланса."},
                {"HomeTPCooldownBypassF", "Ваш телепорт перезаряжается. У вас недостаточно средств - {0} - чтобы избежать ожидания."},
                {"HomeTPCooldownBypassP", "Вы можете выбрать оплатить {0} чтобы избежать ожидания перезарядки." },
                {"HomeTPCooldownBypassP2", "Напишите <color=yellow>/home \"название дома\" {0}</color>." },
                {"HomeTPLimitReached", "Вы исчерпали ежедневный лимит {0} телепортаций сегодня!"},
                {"HomeTPAmount", "У вас осталось {0} телепортаций домой сегодня!"},
                {"HomesListWiped", "Вы очистили все местоположения, сохранённые как дом!"},
                {"HomeTPBuildingBlocked", "Вы не можете сохранить местоположение в качестве дома, если у вас нет прав на строительство в этой зоне!"},
                {"HomeTPSwimming", "Вы не можете устанавливать местоположение а качестве дома пока плывёте!"},
                {"HomeTPCrafting", "Вы не можете устанавливать местоположение а качестве дома в процессе крафта!"},
                {"Request", "Вы запросили телепортацию к {0}!"},
                {"RequestTarget", "{0} запросил телепортацию к вам! Используйте <color=yellow>/tpa</color>, чтобы принять!"},
                {"TPR_NoClan_NoFriend_NoTeam", "Эта команда доступна только друзьям, участникам команды или клана!"},
                {"PendingRequest", "У вас уже есть активный запрос, отмените его, ожидайте подтверждения, либо отмены по таймауту!"},
                {"PendingRequestTarget", "У игрока, к которому вы хотите телепортироваться уже есть активный запрос, попробуйте позже!"},
                {"NoPendingRequest", "У вас нет активных запросов на телепортацию!"},
                {"AcceptOnRoof", "Вы не можете принять запрос на телепортацию стоя на потолке, спуститесь на уровень фундамента!"},
                {"Accept", "{0} принял ваш запрос! Телепортация через {1} секунд!"},
                {"AcceptTarget", "Вы приняли запрос на телепортацию {0}!"},
                {"NotAllowed", "Вам не разрешено использовать эту команду!"},
                {"Success", "Вы телепортированы к {0}!"},
                {"SuccessTarget", "{0} телепортирован к вам!"},
                {"Cancelled", "Ваш запрос на телепортацию к {0} был отменён!"},
                {"CancelledTarget", "Запрос на телепортацию {0} был отменён!"},
                {"TPCancelled", "Ваша телепортация отменена!"},
                {"TPCancelledTarget", "{0} отменил телепортацию!"},
                {"TPYouCancelledTarget", "Вы отменили телепортацию {0}!"},
                {"TimedOut", "{0} не ответил на ваш запрос во время!"},
                {"TimedOutTarget", "Вы не ответили вовремя на запрос телепортации от {0}!"},
                {"TargetDisconnected", "{0} отключился, ваша телепортация отменена!"},
                {"TPRCooldown", "Ваши запросы на телепортацию в данный момент на перезарядке. Вам необходимо подождать {0} прежде чем отправить следующий запрос."},
                {"TPRCooldownBypass", "Ваши запросы на телепортацию были на перезарядке. Вы выбрали избежать ожидания, оплатив {0} с вашего баланса."},
                {"TPRCooldownBypassF", "Ваши запросы на телепортацию в данный момент на перезарядке. У вас недостаточно средств - {0} - чтобы избежать ожидания."},
                {"TPRCooldownBypassP", "Вы можете выбрать оплатить {0} чтобы избежать ожидания перезарядки." },
                {"TPMoney", "{0} списано с вашего аккаунта!"},
                {"TPNoMoney", "У вас нет {0} ни на одном аккаунте!"},
                {"TPRCooldownBypassP2", "Напишите <color=yellow>/tpr {0}</color>." },
                {"TPRCooldownBypassP2a", "Напишите <color=yellow>/tpr \"имя игрока\" {0}</color>." },
                {"TPRLimitReached", "Вы исчерпали ежедневный лимит {0} запросов на телепортацию сегодня!"},
                {"TPRAmount", "У вас осталось {0} запросов на телепортацию на сегодня!"},
                {"TPRTarget", "Ваша цель в данный момент не доступна!"},
                {"TPDead", "Вы не можете телепортироваться, пока мертвы!"},
                {"TPWounded", "Вы не можете телепортироваться, будучи раненым!"},
                {"TPTooCold", "Вам слишком холодно для телепортации!"},
                {"TPTooHot", "Вам слишком жарко для телепортации!"},
                {"TPBoat", "Вы не можете телепортироваться находясь на лодке!"},
                {"TPHostile", "Вы не можете телепортироваться в Город NPC или Лагерь бандитов пока враждебны!"},
                {"HostileTimer", "Телепорт станет доступен через {0} минут."},
                {"TPMounted", "Вы не можете телепортироваться, когда сидите!"},
                {"TPBuildingBlocked", "Вы не можете телепортироваться, находясь в зоне блокировки строительства!"},
                {"TPAboveWater", "Вы не можете телепортироваться находясь над водой!"},
                {"TPTargetBuildingBlocked", "Вы не можете телепортироваться в зону, где блокировано строительство!"},
                {"TPTargetInsideBlock", "Вы не можете телепортироваться в фундамент!"},
                {"TPSwimming", "Вы не можете телепортироваться, пока плывёте!"},
                {"TPCargoShip", "Вы не можете телепортироваться с грузового корабля!"},
                {"TPOilRig", "Вы не можете телепортироваться с нефтяной вышки!"},
                {"TPExcavator", "Вы не можете телепортироваться с экскаватора!"},
                {"TPHotAirBalloon", "Вы не можете телепортироваться с, или на воздушный шар!"},
                {"TPLift", "Вы не можете телепортироваться находясь в лифте или подъемнике!"},
                {"TPBucketLift", "Вы не можете телепортироваться находясь в ковшевом подъемнике!"},
                {"TPRegLift", "Вы не можете телепортироваться находясь в лифте!"},
                {"TPSafeZone", "Вы не можете телепортироваться из безопасной зоны!"},
                {"TPFlagZone", "Вы не можете телепортироваться из этой зоны!"},
                {"TPNoEscapeBlocked", "Вы не можете телепортироваться пока активна блокировка!"},
                {"TPCrafting", "Вы не можете телепортироваться в процессе крафта!"},
                {"TPBlockedItem", "Вы не можете телепортироваться пока несёте: {0}!"},
                {"TooCloseToMon", "Вы не можете телепортироваться так близко к {0}!"},
                {"TooCloseToCave", "Вы не можете телепортироваться так близко к пещере!"},
                {"HomeTooCloseToCave", "Вы не можете сохранить местоположение в качестве дома так близко к пещере!"},
                {"TownTP", "Вы телепортрованы в Город!"},
                {"TownTPNotSet", "Местоположение Города не задано!"},
                {"TownTPDisabled", "Город в данный момент не активирован!"},
                {"TownTPLocation", "Вы задали местоположение Города: {0}!"},
                {"TownTPStarted", "Телепортация в Город через {0} секунд!"},
                {"TownTPCooldown", "Ваш телепорт в данный момент на перезарядке. Вам необходимо подождать {0} до следующей телепортации."},
                {"TownTPCooldownBypass", "Ваш запрос на телепортацию был на перезарядке. Вы выбрали избежать ожидания, оплатив {0} с вашего баланса."},
                {"TownTPCooldownBypassF", "Ваш телепорт в данный момент на перезарядке. У вас недостаточно средств - {0} - чтобы избежать ожидания."},
                {"TownTPCooldownBypassP", "Вы можете выбрать оплатить {0} чтобы избежать ожидания перезарядки." },
                {"TownTPCooldownBypassP2", "Напишите <color=yellow>/town {0}</color>." },
                {"TownTPLimitReached", "Вы исчерпали ежедневный лимит {0} телепортаций на сегодня!"},
                {"TownTPAmount", "У вас осталось {0} телепортаций в Город на сегодня!"},

                {"OutpostTP", "Вы телепортированы в Город NPC!"},
                {"OutpostTPNotSet", "Местоположение Город NPC в данный момент не установлено!"},
                {"OutpostTPDisabled", "Город NPC в данный момент не активирован!"},
                {"OutpostTPDisabledConfig", "Город NPC не включен в конфиг-файле"},
                {"OutpostTPDisabledNoLocation", "Город NPC в данный момент не активирован, местоположение не задано и автоматическое генерирование местоположения отключено!"},
                {"OutpostTPDisabledNoLocationAutoGen", "Город NPC отключен потому, что автоматическое генерирование местоположения не удалось!"},
                {"OutpostTPLocation", "Вы установили местоположение города NPC {0}!"},
                {"OutpostTPStarted", "Телепортация в Город NPC через {0} секунд!"},
                {"OutpostTPCooldown", "Ваш телепорт в данный момент на перезарядке. Вам необходимо подождать {0} до следующей телепортации."},
                {"OutpostTPCooldownBypass", "Ваш запрос на телепортацию был на перезарядке. Вы выбрали избежать ожидания, оплатив {0} с вашего баланса."},
                {"OutpostTPCooldownBypassF", "Ваш телепорт в данный момент на перезарядке. У вас недостаточно средств - {0} - чтобы избежать ожидания."},
                {"OutpostTPCooldownBypassP", "Вы можете выбрать оплатить {0} чтобы избежать ожидания перезарядки." },
                {"OutpostTPCooldownBypassP2", "Напишите <color=yellow>/outpost {0}</color>." },
                {"OutpostTPLimitReached", "Вы исчерпали ежедневный лимит {0} телепортаций на сегодня!"},
                {"OutpostTPAmount", "У вас осталось {0} телепортаций в Город NPC на сегодня!"},

                {"BanditTP", "Вы телепортированы в Лагерь бандитов!"},
                {"BanditTPNotSet", "Местоположение Лагеря бандитов в данный момент не установлено!"},
                {"BanditTPDisabled", "Лагерь бандитов в данный момент не активирован!"},
                {"BanditTPDisabledConfig", "Лагерь бандитов не включен в конфиг-файле!"},
                {"BanditTPDisabledNoLocation", "Лагерь бандитов в данный момент не активирован, местоположение не задано и автоматическое генерирование местоположения отключено!"},
                {"BanditTPDisabledNoLocationAutoGen", "Лагерь бандитов отключен потому, что автоматическое генерирование местоположения не удалось!"},
                {"BanditTPLocation", "Вы установили местоположение Лагеря бандитов {0}!"},
                {"BanditTPStarted", "Телепортация в Лагерь бандитов через {0} секунд!"},
                {"BanditTPCooldown", "Ваш телепорт в данный момент на перезарядке. Вам необходимо подождать {0} до следующей телепортации."},
                {"BanditTPCooldownBypass", "Ваш запрос на телепортацию был на перезарядке. Вы выбрали избежать ожидания, оплатив {0} с вашего баланса."},
                {"BanditTPCooldownBypassF", "Ваш телепорт в данный момент на перезарядке. У вас недостаточно средств - {0} - чтобы избежать ожидания."},
                {"BanditTPCooldownBypassP", "Вы можете выбрать оплатить {0} чтобы избежать ожидания перезарядки." },
                {"BanditTPCooldownBypassP2", "Напишите <color=yellow>/bandit {0}</color>." },
                {"BanditTPLimitReached", "Вы исчерпали ежедневный лимит {0} телепортаций на сегодня!"},
                {"BanditTPAmount", "У вас осталось {0} телепортаций в Лагерь бандитов на сегодня!"},

                {"Interrupted", "Ваша телепортация была прервана!"},
                {"InterruptedTarget", "Телепортация {0} была прервана!"},
                {"Unlimited", "Не ограничено"},
                {
                    "TPInfoGeneral", string.Join(NewLine, new[]
                    {
                        "Пожалуйста, укажите модуль, о котором вы хотите просмотреть информацию.",
                        "Доступные модули: ",
                    })
                },
                {
                    "TPHelpGeneral", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/tpinfo</color> - Отображает лимиты и перезарядки.",
                        "Пожалуйста, укажите модуль, по которому вы хотите получить помощь.",
                        "Доступные модули: ",
                    })
                },
                {
                    "TPHelpadmintp", string.Join(NewLine, new[]
                    {
                        "Как админ, вы имеете доступ к следующим командам:",
                        "<color=yellow>/tp \"имя игрока\"</color> - Телепортирует вас к указанному игроку.",
                        "<color=yellow>/tp \"имя игрока\" \"имя игрока 2\"</color> - Телепортирует игрока с именем 'имя игрока' к игроку 'имя игрока 2'.",
                        "<color=yellow>/tp x y z</color> - Телепортирует вас к указанным координатам.",
                        "<color=yellow>/tpl</color> - Отображает список сохранённых местоположений.",
                        "<color=yellow>/tpl \"название местоположения\"</color> - Телепортирует вас в сохранённое местоположение.",
                        "<color=yellow>/tpsave \"название местоположения\"</color> - Сохраняет ваше текущее местоположение с указанным названием.",
                        "<color=yellow>/tpremove \"название местоположения\"</color> - Удаляет местоположение из списка сохранённых.",
                        "<color=yellow>/tpb</color> - Телепортирует вас назад на место, где вы были перед телепортацией.",
                        "<color=yellow>/home radius \"радиус\"</color> - Найти все дома в радиусе.",
                        "<color=yellow>/home delete \"имя игрока или ID\" \"название дома\"</color> - Удаляет дом с указанным именем принадлежащий указанному игроку.",
                        "<color=yellow>/home tp \"имя игрока или ID\" \"название дома\"</color> - Телепортирует вас в дом игрока с указанным названием принадлежащий указанному игроку.",
                        "<color=yellow>/home homes \"имя игрока или ID\"</color> - Отображает вам список всех домов, принадлежащих указанному игроку."
                    })
                },
                {
                    "TPHelphome", string.Join(NewLine, new[]
                    {
                        "Используя следующие команды, вы можете установить местоположение вашего дома, чтобы затем в него телепортироваться:",
                        "<color=yellow>/home add \"название дома\"</color> - Сохраняет ваше текущее местоположение как ваш дом с указанным названием.",
                        "<color=yellow>/home list</color> - Отображает список всех местоположений, сохранённых вами как дом.",
                        "<color=yellow>/home remove \"название дома\"</color> - Удаляет расположение сохранённого дома с указанным названием.",
                        "<color=yellow>/home \"название дома\"</color> - Телепортирует вас в местоположение дома с указанным названием."
                    })
                },
                {
                    "TPHelptpr", string.Join(NewLine, new[]
                    {
                        "Используя эти команды, вы можете отправить запрос на телепортацию к игроку, или принять чей-то запрос:",
                        "<color=yellow>/tpr \"имя игрока\"</color> - Отправляет запрос на телепортацию игроку с указанным именем.",
                        "<color=yellow>/tpa</color> - Принять входящий запрос на телепортацию.",
                        "<color=yellow>/tpc</color> - Отменить запрос на телепортацию."
                    })
                },
                {
                    "TPSettingsGeneral", string.Join(NewLine, new[]
                    {
                        "Пожалуйста, укажите модуль, настройки которого вы хотите просмотреть. ",
                        "Доступные модули:",
                    })
                },
                {
                    "TPSettingshome", string.Join(NewLine, new[]
                    {
                        "Система домов в данный момент имеет следующие включённые параметры:",
                        "Время между телепортами: {0}",
                        "Ежедневный лимит телепортаций: {1}",
                        "Количество сохранённых домов: {2}"
                    })
                },
                {
                    "TPSettingsbandit", string.Join(NewLine, new[]
                    {
                        "Система Лагерь бандитов в данный момент имеет следующие включённые параметры:",
                        "Время между телепортами: {0}",
                        "Ежедневный лимит телепортаций: {1}"
                    })
                },
                {
                    "TPSettingsoutpost", string.Join(NewLine, new[]
                    {
                        "Система Город NPC в данный момент имеет следующие включённые параметры:",
                        "Время между телепортами: {0}",
                        "Ежедневный лимит телепортаций: {1}"
                    })
                },
                {
                    "TPSettingstpr", string.Join(NewLine, new[]
                    {
                        "Система TPR в данный момент имеет следующие включённые параметры:",
                        "Время между телепортами: {0}",
                        "Ежедневный лимит телепортаций: {1}"
                    })
                },
                {
                    "TPSettingstown", string.Join(NewLine, new[]
                    {
                        "Town System has the current settings enabled:",
                        "Время между телепортами: {0}",
                        "Ежедневный лимит телепортаций: {1}"
                    })
                },
                {"TPT_True", "включено"},
                {"TPT_False", "выключено"},
                {"TPT_clan", "TPT clan теперь {0}."},
                {"TPT_friend", "TPT friend теперь {0}."},
                {"TPT_team", "TPT team теперь {0}."},
                {"NotValidTPT", "Неверно, игрок не"},
                {"NotValidTPTFriend", " друг!"},
                {"NotValidTPTTeam", " в вашей команде!"},
                {"NotValidTPTClan", " в вашем клане!"},
                {"TPTInfo", "`<color=yellow>/tpt clan|team|friend</color>` - чтобы разрешить/запретить игрокам пытающимся TPT к вам через одну из этих опций."},
                {"PlayerNotFound", "Указанный игрок не обнаружен, пожалуйста попробуйте ещё раз!"},
                {"MultiplePlayers", "Найдено несколько игроков: {0}"},
                {"CantTeleportToSelf", "Вы не можете телепортироваться к самому себе!"},
                {"CantTeleportPlayerToSelf", "Вы не можете телепортровать игрока к самому себе!"},
                {"TeleportPendingTPC", "Вы не можете инициировать телепортацию, пока у вас есть активный запрос! Используйте <color=yellow>/tpc</color> чтобы отменить его."},
                {"TeleportPendingTarget", "Вы не можете отправить запрос к тому, кто в процессе телепортации!"},
                {"LocationExists", "Местоположение с таким названием уже существует в {0}!"},
                {"LocationExistsNearby", "Местоположение с названием {0} уже существует рядом с текущей позицией!"},
                {"LocationNotFound", "Не найдено местоположение с таким названием!"},
                {"NoPreviousLocationSaved", "Предыдущее местоположение не сохранено!"},
                {"HomeExists", "Вы уже сохранили дом с таким названием!"},
                {"HomeExistsNearby", "Дом с названием {0} уже существует рядом с текущей позицией!"},
                {"HomeNotFound", "Дом с таким названием не найден!"},
                {"InvalidCoordinates", "Вы указали неверные координаты!"},
                {"InvalidHelpModule", "Указан неверный модуль!"},
                {"InvalidCharacter", "Вы использовали недопустимый символ, ограничьтесь буквами от a до z и цифрами."},
                {
                    "SyntaxCommandTP", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/tp</color> возможно только следующим образом:",
                        "<color=yellow>/tp \"имя игрока\"</color> - Телепортирует вас к указанному игроку.",
                        "<color=yellow>/tp \"имя игрока\" \"имя игрока 2\"</color> - Телепортирует игрока с именем 'имя игрока' к игроку 'имя игрока 2'.",
                        "<color=yellow>/tp x y z</color> - Телепортирует вас к указанным координатам.",
                        "<color=yellow>/tp \"имя игрока\" x y z</color> - Телепортирует игрока с именем 'имя игрока' к указанным координатам."
                    })
                },
                {
                    "SyntaxCommandTPL", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/tpl</color> возможно только следующим образом:",
                        "<color=yellow>/tpl</color> - Отображает список сохранённых местоположений.",
                        "<color=yellow>/tpl \"название местоположения\"</color> - Телепортирует вас в место с указанным названием."
                    })
                },
                {
                    "SyntaxCommandTPSave", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/tpsave</color> возможно только следующим образом:",
                        "<color=yellow>/tpsave \"название местоположения\"</color> - Сохраняет ваше текущее местоположение с указанным названием."
                    })
                },
                {
                    "SyntaxCommandTPRemove", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/tpremove</color> возможно только следующим образом:",
                        "<color=yellow>/tpremove \"название местоположения\"</color> - Удаляет местоположение с указанным названием."
                    })
                },
                {
                    "SyntaxCommandTPN", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/tpn</color> возможно только следующим образом:",
                        "<color=yellow>/tpn \"имя игрока\"</color> - Телепортирует вас на расстояние по умолчанию позади игрока с указанным именем.",
                        "<color=yellow>/tpn \"имя игрока\" \"расстояние\"</color> - Телепортирует вас на указанное расстояние позади игрока с указанным именем."
                    })
                },
                {
                    "SyntaxCommandSetHome", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/home add</color> возможно только следующим образом:",
                        "<color=yellow>/home add \"название\"</color> - Сохраняет ваше текущее местоположение как ваш дом с указанным названием."
                    })
                },
                {
                    "SyntaxCommandRemoveHome", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/home remove</color> возможно только следующим образом:",
                        "<color=yellow>/home remove \"название\"</color> - Удаляет местоположение дома с указанным названием."
                    })
                },
                {
                    "SyntaxCommandHome", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/home</color> возможно только следующим образом:",
                        "<color=yellow>/home \"название\"</color> - Телепортирует вас в ваш дом с указанным названием.",
                        "<color=yellow>/home \"название\" pay</color> - Телепортирует вас в ваш дом с указанным названием, избегая перезарядки, заплатив за это.",
                        "<color=yellow>/home add \"название\"</color> - Сохраняет ваше текущее местоположение как ваш дом с указанным названием.",
                        "<color=yellow>/home list</color> - Отображает список всех местоположений, сохранённых вами как дом.",
                        "<color=yellow>/home remove \"название\"</color> - Удаляет местоположение дома с указанным названием."
                    })
                },
                {
                    "SyntaxCommandHomeAdmin", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/home radius \"радиус\"</color> - Отображает список всех домов в радиусе(10).",
                        "<color=yellow>/home delete \"имя игрока или ID\" \"название\"</color> - Удаляет дом с указанным названием, принадлежащий указанному игроку.",
                        "<color=yellow>/home tp \"имя игрока или ID\" \"название\"</color> - Телепортирует вас в дом с указанным названием, принадлежащий указанному игроку.",
                        "<color=yellow>/home homes \"имя игрока или ID\"</color> - Отображает вам список всех домов, принадлежащих указанному игроку."
                    })
                },
                {
                    "SyntaxCommandTown", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/town</color> возможно только следующим образом:",
                        "<color=yellow>/town</color> - Телепортирует вас в Город.",
                        "<color=yellow>/town pay</color> - Телепортирует вас в Город с оплатой штрафа."
                    })
                },
                {
                    "SyntaxCommandTownAdmin", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/town set</color> - Сохраняет текущее местоположение как Город.",
                    })
                },
                {
                    "SyntaxCommandOutpost", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/outpost</color> возможно только следующим образом:",
                        "<color=yellow>/outpost</color> - Телепортирует вас в Город NPC.",
                        "<color=yellow>/outpost pay</color> - Телепортирует вас в Город NPC с оплатой штрафа."
                    })
                },
                {
                    "SyntaxCommandOutpostAdmin", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/outpost set</color> - Сохраняет текущее местоположение как Город NPC.",
                    })
                },
                {
                    "SyntaxCommandBandit", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/bandit</color> возможно только следующим образом:",
                        "<color=yellow>/bandit</color> - Телепортирует вас в Лагерь бандитов.",
                        "<color=yellow>/bandit pay</color> - Телепортирует вас в Лагерь бандитов с оплатой штрафа."
                    })
                },
                {
                    "SyntaxCommandBanditAdmin", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/bandit set</color> - Сохраняет текущее местоположение как Лагерь бандитов.",
                    })
                },
                {
                    "SyntaxCommandHomeDelete", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/home delete</color> возможно только следующим образом:",
                        "<color=yellow>/home delete \"имя игрока или ID\" \"название\"</color> - Удаляет дом с указанным названием, принадлежащий указанному игроку."
                    })
                },
                {
                    "SyntaxCommandHomeAdminTP", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/home tp</color> возможно только следующим образом:",
                        "<color=yellow>/home tp \"имя игрока или ID\" \"название\"</color> - Телепортирует вас в дом игрока с указанным названием, принадлежащий указанному игроку."
                    })
                },
                {
                    "SyntaxCommandHomeHomes", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/home homes</color> возможно только следующим образом:",
                        "<color=yellow>/home homes \"имя игрока или ID\"</color> - Отображает вам список всех домов, принадлежащих указанному игроку."
                    })
                },
                {
                    "SyntaxCommandListHomes", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/home list</color> возможно только следующим образом:",
                        "<color=yellow>/home list</color> - Отображает список всех местоположений, сохранённых вами как дом."
                    })
                },
                {
                    "SyntaxCommandTPT", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/tpt</color> возможно только следующим образом:",
                        "<color=yellow>/tpt \"имя игрока или ID\"</color> - Телепортирует вас к участнику команды, или клана."
                    })
                },
                {
                    "SyntaxCommandTPR", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/tpr</color> возможно только следующим образом:",
                        "<color=yellow>/tpr \"имя игрока или ID\"</color> - Отправляет указанному игроку запрос на телепортацию."
                    })
                },
                {
                    "SyntaxCommandTPA", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/tpa</color> возможно только следующим образом:",
                        "<color=yellow>/tpa</color> - Принять входящий запрос на телепортацию."
                    })
                },
                {
                    "SyntaxCommandTPC", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/tpc</color> возможно только следующим образом:",
                        "<color=yellow>/tpc</color> - Отменить запрос на телепортацию."
                    })
                },
                {
                    "SyntaxConsoleCommandToPos", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование консольной команды <color=orange>teleport.topos</color> возможно только следующим образом:",
                        " > <color=orange>teleport.topos \"имя игрока\" x y z</color>"
                    })
                },
                {
                    "SyntaxConsoleCommandToPlayer", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование консольной команды <color=orange>teleport.toplayer</color> возможно только следующим образом:",
                        " > <color=orange>teleport.toplayer \"имя игрока или ID\" \"имя игрока 2|id 2\"</color>"
                    })
                },
                {"LogTeleport", "{0} телепортирован к {1}."},
                {"LogTeleportPlayer", "{0} телепортировал {1} к {2}."},
                {"LogTeleportBack", "{0} телепортирован назад, в предыдущее местоположение."}
            }, this, "ru");
        }

        private void Init()
        {
            Unsubscribe(nameof(OnEntityTakeDamage));
            Unsubscribe(nameof(OnPlayerSleepEnded));
            Unsubscribe(nameof(OnPlayerDisconnected));
        }

        private void LoadDataAndPerms()
        {
            dataAdmin = GetFile(nameof(NTeleportation) + "Admin");
            Admin = dataAdmin.ReadObject<Dictionary<ulong, AdminData>>();
            dataHome = GetFile(nameof(NTeleportation) + "Home");
            Home = dataHome.ReadObject<Dictionary<ulong, HomeData>>();
            dataTPT = GetFile(nameof(NTeleportation) + "TPT");
            TPT = dataTPT.ReadObject<Dictionary<string, List<string>>>();
            dataTPR = GetFile(nameof(NTeleportation) + "TPR");
            TPR = dataTPR.ReadObject<Dictionary<ulong, TeleportData>>();
            dataTown = GetFile(nameof(NTeleportation) + "Town");
            Town = dataTown.ReadObject<Dictionary<ulong, TeleportData>>();
            dataOutpost = GetFile(nameof(NTeleportation) + "Outpost");
            Outpost = dataOutpost.ReadObject<Dictionary<ulong, TeleportData>>();
            dataBandit = GetFile(nameof(NTeleportation) + "Bandit");
            Bandit = dataBandit.ReadObject<Dictionary<ulong, TeleportData>>();
            dataDisabled = GetFile(nameof(NTeleportation) + "DisabledCommands");
            DisabledTPT = dataDisabled.ReadObject<DisabledData>();
            permission.RegisterPermission(PermDeleteHome, this);
            permission.RegisterPermission(PermHome, this);
            permission.RegisterPermission(PermHomeHomes, this);
            permission.RegisterPermission(PermImportHomes, this);
            permission.RegisterPermission(PermRadiusHome, this);
            permission.RegisterPermission(PermTp, this);
            permission.RegisterPermission(PermTpB, this);
            permission.RegisterPermission(PermTpR, this);
            permission.RegisterPermission(PermTpConsole, this);
            permission.RegisterPermission(PermTpHome, this);
            permission.RegisterPermission(PermTpTown, this);
            permission.RegisterPermission(PermTpT, this);
            permission.RegisterPermission(PermTpOutpost, this);
            permission.RegisterPermission(PermTpBandit, this);
            permission.RegisterPermission(PermTpN, this);
            permission.RegisterPermission(PermTpL, this);
            permission.RegisterPermission(PermTpRemove, this);
            permission.RegisterPermission(PermTpSave, this);
            permission.RegisterPermission(PermWipeHomes, this);
            permission.RegisterPermission(PermCraftHome, this);
            permission.RegisterPermission(PermCraftTown, this);
            permission.RegisterPermission(PermCraftOutpost, this);
            permission.RegisterPermission(PermCraftBandit, this);
            permission.RegisterPermission(PermCraftTpR, this);
            foreach (var key in config.Home.VIPCooldowns.Keys)
                if (!permission.PermissionExists(key, this)) permission.RegisterPermission(key, this);
            foreach (var key in config.Home.VIPCountdowns.Keys)
                if (!permission.PermissionExists(key, this)) permission.RegisterPermission(key, this);
            foreach (var key in config.Home.VIPDailyLimits.Keys)
                if (!permission.PermissionExists(key, this)) permission.RegisterPermission(key, this);
            foreach (var key in config.Home.VIPHomesLimits.Keys)
                if (!permission.PermissionExists(key, this)) permission.RegisterPermission(key, this);
            foreach (var key in config.TPR.VIPCooldowns.Keys)
                if (!permission.PermissionExists(key, this)) permission.RegisterPermission(key, this);
            foreach (var key in config.TPR.VIPCountdowns.Keys)
                if (!permission.PermissionExists(key, this)) permission.RegisterPermission(key, this);
            foreach (var key in config.TPR.VIPDailyLimits.Keys)
                if (!permission.PermissionExists(key, this)) permission.RegisterPermission(key, this);
            foreach (var key in config.Town.VIPCooldowns.Keys)
                if (!permission.PermissionExists(key, this)) permission.RegisterPermission(key, this);
            foreach (var key in config.Town.VIPCountdowns.Keys)
                if (!permission.PermissionExists(key, this)) permission.RegisterPermission(key, this);
            foreach (var key in config.Town.VIPDailyLimits.Keys)
                if (!permission.PermissionExists(key, this)) permission.RegisterPermission(key, this);
        }

        private DynamicConfigFile GetFile(string name)
        {
            var file = Interface.Oxide.DataFileSystem.GetFile(name);
            file.Settings.ReferenceLoopHandling = ReferenceLoopHandling.Ignore;
            file.Settings.Converters = new JsonConverter[] { new UnityVector3Converter(), new CustomComparerDictionaryCreationConverter<string>(StringComparer.OrdinalIgnoreCase) };
            return file;
        }

        private void CheckNewSave()
        {
            if (!newSave && BuildingManager.server.buildingDictionary.Count == 0)
            {
                newSave = true;
            }

            if (!newSave)
            {
                return;
            }

            if (config.Settings.WipeOnUpgradeOrChange)
            {
                Puts("Rust was upgraded or map changed - clearing homes, town, outpost and bandit!");
                Home.Clear();
                changedHome = True;
                config.Town.Location = Zero;
                config.Outpost.Location = Zero;
                config.Bandit.Location = Zero;
                SaveConfig();
            }
            else
            {
                Puts("Rust was upgraded or map changed - homes, town, outpost and bandit may be invalid!");
            }
        }

        void OnServerInitialized()
        {
            LoadDataAndPerms();
            CheckNewSave();
            banditPrefab = StringPool.Get(2074025910);
            banditEnabled = config.Settings.BanditEnabled;
            outpostPrefab = StringPool.Get(1879405026);
            outpostEnabled = config.Settings.OutpostEnabled;

            if (config.Settings.Interrupt.Hurt || config.Settings.Interrupt.Cold || config.Settings.Interrupt.Hot)
            {
                Subscribe(nameof(OnEntityTakeDamage));
            }

            Subscribe(nameof(OnPlayerSleepEnded));
            Subscribe(nameof(OnPlayerDisconnected));

            boundary = TerrainMeta.Size.x / 2;
            CheckPerms(config.Home.VIPHomesLimits);
            CheckPerms(config.Home.VIPDailyLimits);
            CheckPerms(config.Home.VIPCooldowns);
            CheckPerms(config.TPR.VIPDailyLimits);
            CheckPerms(config.TPR.VIPCooldowns);
            CheckPerms(config.Town.VIPDailyLimits);
            CheckPerms(config.Town.VIPCooldowns);
            CheckPerms(config.Outpost.VIPDailyLimits);
            CheckPerms(config.Outpost.VIPCooldowns);
            CheckPerms(config.Bandit.VIPDailyLimits);
            CheckPerms(config.Bandit.VIPCooldowns);

            foreach (var item in config.Settings.BlockedItems)
            {
                var definition = ItemManager.FindItemDefinition(item.Key);
                if (definition == null)
                {
                    Puts("Blocked item not found: {0}", item.Key);
                    continue;
                }
                ReverseBlockedItems[definition.itemid] = item.Value;
            }

            if (CompoundTeleport == null)
            {
                if (outpostEnabled) AddCovalenceCommand("outpost", nameof(CommandOutpost));
                if (banditEnabled) AddCovalenceCommand("bandit", nameof(CommandBandit));
            }
            if (config.Settings.TownEnabled) AddCovalenceCommand("town", nameof(CommandTown));
            if (config.Settings.TPREnabled) AddCovalenceCommand("tpr", nameof(CommandTeleportRequest));
            if (config.Settings.HomesEnabled)
            {
                AddCovalenceCommand("home", nameof(CommandHome));
                AddCovalenceCommand("sethome", nameof(CommandSetHome));
                AddCovalenceCommand("listhomes", nameof(CommandListHomes));
                AddCovalenceCommand("removehome", nameof(CommandRemoveHome));
                AddCovalenceCommand("radiushome", nameof(CommandHomeRadius));
                AddCovalenceCommand("deletehome", nameof(CommandHomeDelete));
                AddCovalenceCommand("tphome", nameof(CommandHomeAdminTP));
                AddCovalenceCommand("homehomes", nameof(CommandHomeHomes));
            }

            AddCovalenceCommand("tnt", nameof(CommandToggle));
            AddCovalenceCommand("tp", nameof(CommandTeleport));
            AddCovalenceCommand("tpn", nameof(CommandTeleportNear));
            AddCovalenceCommand("tpl", nameof(CommandTeleportLocation));
            AddCovalenceCommand("tpsave", nameof(CommandSaveTeleportLocation));
            AddCovalenceCommand("tpremove", nameof(CommandRemoveTeleportLocation));
            AddCovalenceCommand("tpb", nameof(CommandTeleportBack));
            AddCovalenceCommand("tpt", nameof(CommandTeleportTeam));
            AddCovalenceCommand("tpa", nameof(CommandTeleportAccept));
            AddCovalenceCommand("wipehomes", nameof(CommandWipeHomes));
            AddCovalenceCommand("tphelp", nameof(CommandTeleportHelp));
            AddCovalenceCommand("tpinfo", nameof(CommandTeleportInfo));
            AddCovalenceCommand("tpc", nameof(CommandTeleportCancel));
            AddCovalenceCommand("teleport.toplayer", nameof(CommandTeleportII));
            AddCovalenceCommand("teleport.topos", nameof(CommandTeleportII));
            AddCovalenceCommand("teleport.importhomes", nameof(CommandImportHomes));
            //AddCovalenceCommand("spm", nameof(CommandSphereMonuments));
            FindMonuments();  // 1.2.2 location moved from Loaded() to fix outpost and bandit location not being set after a wipe
        }

        List<string> validCommands = new List<string> { "outpost", "bandit", "tp", "home", "sethome", "listhomes", "tpn", "tpl", "tpsave", "tpremove", "tpb", "removehome", "radiushome", "deletehome", "tphome", "homehomes", "tpt", "tpr", "tpa", "wipehomes", "tphelp", "tpinfo", "teleport.toplayer", "teleport.topos", "teleport.importhomes", "town", "spm" };

        void OnNewSave(string strFilename)
        {
            newSave = true;
        }

        void OnServerSave()
        {
            SaveTeleportsAdmin();
            SaveTeleportsHome();
            SaveTeleportsTPR();
            SaveTeleportsTPT();
            SaveTeleportsTown();
            SaveTeleportsOutpost();
            SaveTeleportsBandit();
        }

        void OnServerShutdown() => OnServerSave();

        void Unload() => OnServerSave();

        void OnPluginLoaded(Plugin plugin)
        {
            if (plugin.Name == "Economics")
            {
                Economics = plugin;
            }
            if (plugin.Name == "ServerRewards")
            {
                ServerRewards = plugin;
            }
            if (plugin.Name == "Friends")
            {
                Friends = plugin;
            }
            if (plugin.Name == "Clans")
            {
                Clans = plugin;
            }
            if (plugin.Name == "CompoundTeleport")
            {
                CompoundTeleport = plugin;
            }
        }

        void OnPluginUnloaded(Plugin plugin)
        {
            if (plugin.Name == "Economics")
            {
                Economics = null;
            }
            if (plugin.Name == "ServerRewards")
            {
                ServerRewards = null;
            }
            if (plugin.Name == "Friends")
            {
                Friends = null;
            }
            if (plugin.Name == "Clans")
            {
                Clans = null;
            }
            if (plugin.Name == "CompoundTeleport")
            {
                CompoundTeleport = null;
            }
        }

        void OnEntityTakeDamage(BasePlayer player, HitInfo hitInfo)
        {
            if (player == null || player.IsNpc || hitInfo == null) return;
            if (hitInfo.damageTypes.Has(DamageType.Fall) && teleporting.ContainsKey(player.userID))
            {
                hitInfo.damageTypes = new DamageTypeList();
                teleporting.Remove(player.userID);
                return;
            }
            TeleportTimer teleportTimer;
            if (!TeleportTimers.TryGetValue(player.userID, out teleportTimer)) return;
            DamageType major = hitInfo.damageTypes.GetMajorityDamageType();

            NextTick(() =>
            {
                if (!player || !hitInfo.hasDamage) return;
                // 1.0.84 new checks for cold/heat based on major damage for the player
                if (major == DamageType.Cold)
                {
                    if (config.Settings.Interrupt.Cold && player.metabolism.temperature.value <= config.Settings.MinimumTemp)
                    {
                        PrintMsgL(teleportTimer.OriginPlayer, "TPTooCold");
                        if (teleportTimer.TargetPlayer != null)
                        {
                            PrintMsgL(teleportTimer.TargetPlayer, "InterruptedTarget", teleportTimer.OriginPlayer?.displayName);
                        }
                        teleportTimer.Timer.Destroy();
                        TeleportTimers.Remove(player.userID);
                    }
                }
                else if (major == DamageType.Heat)
                {
                    if (config.Settings.Interrupt.Hot && player.metabolism.temperature.value >= config.Settings.MaximumTemp)
                    {
                        PrintMsgL(teleportTimer.OriginPlayer, "TPTooHot");
                        if (teleportTimer.TargetPlayer != null)
                        {
                            PrintMsgL(teleportTimer.TargetPlayer, "InterruptedTarget", teleportTimer.OriginPlayer?.displayName);
                        }
                        teleportTimer.Timer.Destroy();
                        TeleportTimers.Remove(player.userID);
                    }
                }
                else if (config.Settings.Interrupt.Hurt)
                {
                    PrintMsgL(teleportTimer.OriginPlayer, "Interrupted");
                    if (teleportTimer.TargetPlayer != null)
                    {
                        PrintMsgL(teleportTimer.TargetPlayer, "InterruptedTarget", teleportTimer.OriginPlayer?.displayName);
                    }
                    teleportTimer.Timer.Destroy();
                    TeleportTimers.Remove(player.userID);
                }
            });
        }

        void OnPlayerSleepEnded(BasePlayer player)
        {
            if (!player || !teleporting.ContainsKey(player.userID)) return;
            ulong userID = player.userID;
            timer.Once(3f, () => teleporting.Remove(userID));
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            if (!player) return;
            Timer reqTimer;
            if (PendingRequests.TryGetValue(player.userID, out reqTimer))
            {
                var originPlayer = PlayersRequests[player.userID];
                if (originPlayer)
                {
                    PlayersRequests.Remove(originPlayer.userID);
                    PrintMsgL(originPlayer, "RequestTargetOff");
                }
                reqTimer.Destroy();
                PendingRequests.Remove(player.userID);
                PlayersRequests.Remove(player.userID);
            }
            TeleportTimer teleportTimer;
            if (TeleportTimers.TryGetValue(player.userID, out teleportTimer))
            {
                teleportTimer.Timer.Destroy();
                TeleportTimers.Remove(player.userID);
            }
            teleporting.Remove(player.userID);
        }

        private void SaveTeleportsAdmin()
        {
            if (Admin == null || !changedAdmin) return;
            dataAdmin.WriteObject(Admin);
            changedAdmin = False;
        }

        private void SaveTeleportsHome()
        {
            if (Home == null || !changedHome) return;
            dataHome.WriteObject(Home);
            changedHome = False;
        }

        private void SaveTeleportsTPR()
        {
            if (TPR == null || !changedTPR) return;
            dataTPR.WriteObject(TPR);
            changedTPR = False;
        }

        private void SaveTeleportsTPT()
        {
            if (TPT == null || !changedTPT) return;
            dataTPT.WriteObject(TPT);
            changedTPT = False;
        }

        private void SaveTeleportsTown()
        {
            if (Town == null || !changedTown) return;
            dataTown.WriteObject(Town);
            changedTown = False;
        }

        private void SaveTeleportsOutpost()
        {
            if (Outpost == null || !changedOutpost) return;
            dataOutpost.WriteObject(Outpost);
            changedOutpost = False;
        }

        private void SaveTeleportsBandit()
        {
            if (Bandit == null || !changedBandit) return;
            dataBandit.WriteObject(Bandit);
            changedBandit = False;
        }

        private void SaveLocation(BasePlayer player)
        {
            if (!IsAllowed(player, PermTpB)) return;
            AdminData adminData;
            if (!Admin.TryGetValue(player.userID, out adminData))
                Admin[player.userID] = adminData = new AdminData();
            adminData.PreviousLocation = player.transform.position;
            changedAdmin = True;
            PrintMsgL(player, "AdminTPBackSave");
        }

        private void RemoveLocation(BasePlayer player)
        {
            AdminData adminData;
            if (!Admin.TryGetValue(player.userID, out adminData))
                return;
            adminData.PreviousLocation = Zero;
            changedAdmin = True;
        }

        char[] chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".ToCharArray();
        private readonly System.Text.StringBuilder _sb = new System.Text.StringBuilder();

        string RandomString(int minAmount = 5, int maxAmount = 10)
        {
            _sb.Length = 0;

            for (int i = 0; i <= UnityEngine.Random.Range(minAmount, maxAmount); i++)
                _sb.Append(chars[UnityEngine.Random.Range(0, chars.Length)]);

            return _sb.ToString();
        }

        void FindMonuments()
        {
            var realWidth = 0f;
            string name = null;
            foreach (var monument in UnityEngine.Object.FindObjectsOfType<MonumentInfo>())
            {
                var monPos = monument.transform.position;
                name = monument.displayPhrase.english.TrimEnd();
                if (string.IsNullOrEmpty(name))
                {
                    if (monument.name.Contains("cave"))
                    {
                        name = (monument.name.Contains("cave_small") ? "Small Cave" : monument.name.Contains("cave_medium") ? "Medium Cave" : "Large Cave") + ":" + RandomString();
                    }
                    else name = monument.name;
                }
                realWidth = monument.name == "OilrigAI" ? 100f : monument.name == "OilrigAI2" ? 200f : 0f;
#if DEBUG
                Puts($"Found {name}, extents {monument.Bounds.extents}");
#endif
                if (realWidth > 0f)
                {
#if DEBUG
                    Puts($"  corrected to {realWidth}");
#endif
                }
                if (monument.name.Contains("cave"))
                {
#if DEBUG
                    Puts("  Adding to cave list");
#endif
                    if (caves.ContainsKey(name)) name += RandomString();
                    caves.Add(name, monPos);
                }
                else if (monument.name == outpostPrefab)
                {
                    if (config.Outpost.Location != Zero && Vector3.Distance(monument.transform.position, config.Outpost.Location) > 100f)
                    {
#if DEBUG
                        Puts("Invalid Outpost location detected");
#endif
                        config.Outpost.Location = Zero;
                    }
                    if (config.Settings.AutoGenOutpost && config.Outpost.Location == Zero)
                    {
#if DEBUG
                        Puts("  Adding Outpost target");
#endif
                        var ents = new List<BaseEntity>();
                        Vis.Entities<BaseEntity>(monPos, 50, ents);
                        foreach (BaseEntity entity in ents)
                        {
                            if (entity.prefabID == 3858860623)
                            {
                                config.Outpost.Location = entity.transform.position + entity.transform.forward + new Vector3(0f, 1f, 0f);
                                SaveConfig();
                                break;
                            }
                            else if (entity is Workbench)
                            {
                                config.Outpost.Location = entity.transform.position + entity.transform.forward + new Vector3(0f, 1f, 0f);
                                SaveConfig();
                                break;
                            }
                            else if (entity is BaseChair)
                            {
                                config.Outpost.Location = entity.transform.position + entity.transform.right + new Vector3(0f, 1f, 0f);
                                SaveConfig();
                                break;
                            }
                        }

                        if (!config.Settings.OutpostEnabled) OutpostTPDisabledMessage = "OutpostTPDisabledConfig";
                        else if (config.Outpost.Location == Zero) OutpostTPDisabledMessage = "OutpostTPDisabledNoLocationAutoGen";
                    }
                }
                else if (monument.name == banditPrefab)
                {
                    if (config.Bandit.Location != Zero && Vector3.Distance(monument.transform.position, config.Bandit.Location) > 100f)
                    {
#if DEBUG
                        Puts("Invalid Bandit location detected");
#endif
                        config.Bandit.Location = Zero;
                    }
                    if (config.Settings.AutoGenBandit && config.Bandit.Location == Zero)
                    {
#if DEBUG
                        Puts("  Adding BanditTown target");
#endif
                        var ents = new List<BaseEntity>();
                        Vis.Entities<BaseEntity>(monPos, 50, ents);
                        foreach (BaseEntity entity in ents)
                        {
                            if (entity.prefabID == 3858860623)
                            {
                                config.Bandit.Location = entity.transform.position + entity.transform.forward + new Vector3(0f, 1f, 0f);
                                SaveConfig();
                                break;
                            }
                            else if (entity is Workbench)
                            {
                                config.Bandit.Location = entity.transform.position + entity.transform.forward + new Vector3(0f, 1f, 0f);
                                SaveConfig();
                                break;
                            }
                            else if (entity is BaseChair)
                            {
                                config.Bandit.Location = entity.transform.position + entity.transform.right + new Vector3(0f, 1f, 0f);
                                SaveConfig();
                                break;
                            }
                        }
                    }

                    if (!config.Settings.BanditEnabled) BanditTPDisabledMessage = "BanditTPDisabledConfig";
                    else if (config.Bandit.Location == Zero) BanditTPDisabledMessage = "BanditTPDisabledNoLocationAutoGen";
                }
                else
                {
                    if (monuments.ContainsKey(name)) name += ":" + RandomString(5, 5);
                    if (monument.name.Contains("power_sub")) name = monument.name.Substring(monument.name.LastIndexOf("/") + 1).Replace(".prefab", "") + ":" + RandomString(5, 5);
                    float radius = GetMonumentFloat(name);
                    monuments[name] = new MonInfo() { Position = monPos, Radius = radius };
#if DEBUG
                    Puts($"Adding Monument: {name}, pos: {monPos}, size: {radius}");
#endif
                }
            }

            if (config.Outpost.Location == Zero)
            {
                if (!config.Settings.AutoGenOutpost) OutpostTPDisabledMessage = "OutpostTPDisabledNoLocation";
                outpostEnabled = False;
            }

            if (config.Bandit.Location == Zero)
            {
                if (!config.Settings.AutoGenBandit) BanditTPDisabledMessage = "BanditTPDisabledNoLocation";
                banditEnabled = False;
            }
        }

        private void CommandToggle(IPlayer p, string command, string[] args)
        {
            if (!p.IsAdmin) return;

            if (args.Length == 0)
            {
                p.Reply("tnt commandname");
                return;
            }

            string arg = args[0].ToLower();

            if (!validCommands.Contains(arg))
            {
                p.Reply("Invalid command name: {0}", null, string.Join(", ", validCommands.ToList()));
                return;
            }

            if (arg == command.ToLower()) return;

            if (!DisabledTPT.DisabledCommands.Contains(arg))
                DisabledTPT.DisabledCommands.Add(arg);
            else DisabledTPT.DisabledCommands.Remove(arg);

            dataDisabled.WriteObject(DisabledTPT);
            p.Reply("{0} {1}", null, DisabledTPT.DisabledCommands.Contains(arg) ? "Disabled:" : "Enabled:", arg);
        }

        private void CommandTeleport(IPlayer p, string command, string[] args)
        {
            if (DisabledTPT.DisabledCommands.Contains(command.ToLower())) { p.Reply("Disabled command: " + command); return; }
            var player = p.Object as BasePlayer;
            if (!player || !IsAllowedMsg(player, PermTp) || !player.IsConnected || (player.IsSleeping() && !player.IsAdmin)) return;
            BasePlayer target;
            float x, y, z;
            switch (args.Length)
            {
                case 1:
                    target = FindPlayersSingle(args, player);
                    if (target == null) return;
                    if (target == player)
                    {
#if DEBUG
                        Puts("Debug mode - allowing self teleport.");
#else
                PrintMsgL(player, "CantTeleportToSelf");
                return;
#endif
                    }
                    Teleport(player, target, TeleportType.TP);
                    PrintMsgL(player, "AdminTP", target.displayName);
                    Puts(_("LogTeleport", null, player.displayName, target.displayName));
                    if (config.Admin.AnnounceTeleportToTarget)
                        PrintMsgL(target, "AdminTPTarget", player.displayName);
                    break;
                case 2:
                    var origin = FindPlayersSingle(args, player);
                    if (origin == null) return;
                    target = FindPlayersSingle(args.Skip(1).ToArray(), player);
                    if (target == null) return;
                    if (target == origin)
                    {
                        PrintMsgL(player, "CantTeleportPlayerToSelf");
                        return;
                    }
                    Teleport(origin, target, TeleportType.TP);
                    PrintMsgL(player, "AdminTPPlayers", origin.displayName, target.displayName);
                    PrintMsgL(origin, "AdminTPPlayer", player.displayName, target.displayName);
                    if (config.Admin.AnnounceTeleportToTarget)
                        PrintMsgL(target, "AdminTPPlayerTarget", player.displayName, origin.displayName);
                    Puts(_("LogTeleportPlayer", null, player.displayName, origin.displayName, target.displayName));
                    break;
                case 3:
                    if (!float.TryParse(args[0], out x) || !float.TryParse(args[1], out y) || !float.TryParse(args[2], out z))
                    {
                        PrintMsgL(player, "InvalidCoordinates");
                        return;
                    }
                    if (config.Settings.CheckBoundaries && !CheckBoundaries(x, y, z)) // added this option because I HATE boundaries
                    {
                        PrintMsgL(player, "AdminTPOutOfBounds");
                        PrintMsgL(player, "AdminTPBoundaries", boundary);
                        return;
                    }
                    Teleport(player, x, y, z, TeleportType.TP);
                    PrintMsgL(player, "AdminTPCoordinates", player.transform.position);
                    Puts(_("LogTeleport", null, player.displayName, player.transform.position));
                    break;
                case 4:
                    target = FindPlayersSingle(args, player);
                    if (target == null) return;
                    if (!float.TryParse(args[1], out x) || !float.TryParse(args[2], out y) || !float.TryParse(args[3], out z))
                    {
                        PrintMsgL(player, "InvalidCoordinates");
                        return;
                    }
                    if (!CheckBoundaries(x, y, z))
                    {
                        PrintMsgL(player, "AdminTPOutOfBounds");
                        PrintMsgL(player, "AdminTPBoundaries", boundary);
                        return;
                    }
                    Teleport(target, x, y, z, TeleportType.TP);
                    if (player == target)
                    {
                        PrintMsgL(player, "AdminTPCoordinates", player.transform.position);
                        Puts(_("LogTeleport", null, player.displayName, player.transform.position));
                    }
                    else
                    {
                        PrintMsgL(player, "AdminTPTargetCoordinates", target.displayName, player.transform.position);
                        if (config.Admin.AnnounceTeleportToTarget)
                            PrintMsgL(target, "AdminTPTargetCoordinatesTarget", player.displayName, player.transform.position);
                        Puts(_("LogTeleportPlayer", null, player.displayName, target.displayName, player.transform.position));
                    }
                    break;
                default:
                    PrintMsgL(player, "SyntaxCommandTP");
                    break;
            }
        }

        private void CommandTeleportNear(IPlayer p, string command, string[] args)
        {
            if (DisabledTPT.DisabledCommands.Contains(command.ToLower())) { p.Reply("Disabled command: " + command); return; }
            var player = p.Object as BasePlayer;
            if (!player || !IsAllowedMsg(player, PermTpN) || !player.IsConnected || player.IsSleeping()) return;
            switch (args.Length)
            {
                case 1:
                case 2:
                    var target = FindPlayersSingle(args, player);
                    if (target == null) return;
                    if (target == player)
                    {
#if DEBUG
                        Puts("Debug mode - allowing self teleport.");
#else
                        PrintMsgL(player, "CantTeleportToSelf");
                        return;
#endif
                    }
                    int distance = config.Admin.TeleportNearDefaultDistance;
                    if (args.Length == 2 && !int.TryParse(args[1], out distance))
                        distance = config.Admin.TeleportNearDefaultDistance;
                    float x = UnityEngine.Random.Range(-distance, distance);
                    var z = (float)System.Math.Sqrt(System.Math.Pow(distance, 2) - System.Math.Pow(x, 2));
                    var destination = target.transform.position;
                    destination.x = destination.x - x;
                    destination.z = destination.z - z;
                    Teleport(player, GetGroundBuilding(destination), TeleportType.Near);
                    PrintMsgL(player, "AdminTP", target.displayName);
                    Puts(_("LogTeleport", null, player.displayName, target.displayName));
                    if (config.Admin.AnnounceTeleportToTarget)
                        PrintMsgL(target, "AdminTPTarget", player.displayName);
                    break;
                default:
                    PrintMsgL(player, "SyntaxCommandTPN");
                    break;
            }
        }

        private void CommandTeleportLocation(IPlayer p, string command, string[] args)
        {
            if (DisabledTPT.DisabledCommands.Contains(command.ToLower())) { p.Reply("Disabled command: " + command); return; }
            var player = p.Object as BasePlayer;
            if (!player || !IsAllowedMsg(player, PermTpL) || !player.IsConnected || player.IsSleeping()) return;
            AdminData adminData;
            if (!Admin.TryGetValue(player.userID, out adminData) || adminData.Locations.Count <= 0)
            {
                PrintMsgL(player, "AdminLocationListEmpty");
                return;
            }
            switch (args.Length)
            {
                case 0:
                    PrintMsgL(player, "AdminLocationList");
                    foreach (var location in adminData.Locations)
                        PrintMsgL(player, $"{location.Key} {location.Value}");
                    break;
                case 1:
                    Vector3 loc;
                    if (!adminData.Locations.TryGetValue(args[0], out loc))
                    {
                        PrintMsgL(player, "LocationNotFound");
                        return;
                    }
                    Teleport(player, loc, TeleportType.TPL);
                    PrintMsgL(player, "AdminTPLocation", args[0]);
                    break;
                default:
                    PrintMsgL(player, "SyntaxCommandTPL");
                    break;
            }
        }

        private void CommandSaveTeleportLocation(IPlayer p, string command, string[] args)
        {
            if (DisabledTPT.DisabledCommands.Contains(command.ToLower())) { p.Reply("Disabled command: " + command); return; }
            var player = p.Object as BasePlayer;
            if (!player || !IsAllowedMsg(player, PermTpSave) || !player.IsConnected || player.IsSleeping()) return;
            if (args.Length != 1)
            {
                PrintMsgL(player, "SyntaxCommandTPSave");
                return;
            }
            AdminData adminData;
            if (!Admin.TryGetValue(player.userID, out adminData))
                Admin[player.userID] = adminData = new AdminData();
            Vector3 location;
            if (adminData.Locations.TryGetValue(args[0], out location))
            {
                PrintMsgL(player, "LocationExists", location);
                return;
            }
            var positionCoordinates = player.transform.position;
            foreach (var loc in adminData.Locations)
            {
                if ((positionCoordinates - loc.Value).magnitude < config.Admin.LocationRadius)
                {
                    PrintMsgL(player, "LocationExistsNearby", loc.Key);
                    return;
                }
            }
            adminData.Locations[args[0]] = positionCoordinates;
            PrintMsgL(player, "AdminTPLocationSave");
            changedAdmin = True;
        }

        private void CommandRemoveTeleportLocation(IPlayer p, string command, string[] args)
        {
            if (DisabledTPT.DisabledCommands.Contains(command.ToLower())) { p.Reply("Disabled command: " + command); return; }
            var player = p.Object as BasePlayer;
            if (!player || !IsAllowedMsg(player, PermTpRemove) || !player.IsConnected || player.IsSleeping()) return;
            if (args.Length != 1)
            {
                PrintMsgL(player, "SyntaxCommandTPRemove");
                return;
            }
            AdminData adminData;
            if (!Admin.TryGetValue(player.userID, out adminData) || adminData.Locations.Count <= 0)
            {
                PrintMsgL(player, "AdminLocationListEmpty");
                return;
            }
            if (adminData.Locations.Remove(args[0]))
            {
                PrintMsgL(player, "AdminTPLocationRemove", args[0]);
                changedAdmin = True;
                return;
            }
            PrintMsgL(player, "LocationNotFound");
        }

        private void CommandTeleportBack(IPlayer p, string command, string[] args)
        {
            if (DisabledTPT.DisabledCommands.Contains(command.ToLower())) { p.Reply("Disabled command: " + command); return; }
            var player = p.Object as BasePlayer;
            if (!player || !IsAllowedMsg(player, PermTpB) || !player.IsConnected || player.IsSleeping()) return;
            if (args.Length != 0)
            {
                PrintMsgL(player, "SyntaxCommandTPB");
                return;
            }
            AdminData adminData;
            if (!Admin.TryGetValue(player.userID, out adminData) || adminData.PreviousLocation == Zero)
            {
                PrintMsgL(player, "NoPreviousLocationSaved");
                return;
            }

            Teleport(player, adminData.PreviousLocation, TeleportType.TPB);
            adminData.PreviousLocation = Zero;
            changedAdmin = True;
            PrintMsgL(player, "AdminTPBack");
            Puts(_("LogTeleportBack", null, player.displayName));
        }

        private void CommandSetHome(IPlayer p, string command, string[] args)
        {
            if (DisabledTPT.DisabledCommands.Contains(command.ToLower())) { p.Reply("Disabled command: " + command); return; }
            var player = p.Object as BasePlayer;
            if (!player || !IsAllowed(player, PermHome) || !player.IsConnected || player.IsSleeping()) return;
            if (!config.Settings.HomesEnabled) { p.Reply("Homes are not enabled in the config."); return; }
            if (args.Length != 1)
            {
                PrintMsgL(player, "SyntaxCommandSetHome");
                return;
            }
            var err = CheckPlayer(player, player.transform.position, False, CanCraftHome(player), True, "home");
            if (err != null)
            {
                PrintMsgL(player, err);
                return;
            }
            if (!player.CanBuild())
            {
                PrintMsgL(player, "HomeTPBuildingBlocked");
                return;
            }
            if (!args[0].All(char.IsLetterOrDigit))
            {
                PrintMsgL(player, "InvalidCharacter");
                return;
            }
            HomeData homeData;
            if (!Home.TryGetValue(player.userID, out homeData))
                Home[player.userID] = homeData = new HomeData();
            var limit = GetHigher(player, config.Home.VIPHomesLimits, config.Home.HomesLimit, true);
            if (limit > 0 && homeData.Locations.Count >= limit)
            {
                PrintMsgL(player, "HomeMaxLocations", limit);
                return;
            }
            Vector3 location;
            if (homeData.Locations.TryGetValue(args[0], out location))
            {
                PrintMsgL(player, "HomeExists", location);
                return;
            }
            var positionCoordinates = player.transform.position;
            foreach (var loc in homeData.Locations)
            {
                if ((positionCoordinates - loc.Value).magnitude < config.Home.LocationRadius)
                {
                    PrintMsgL(player, "HomeExistsNearby", loc.Key);
                    return;
                }
            }
            err = CanPlayerTeleport(player);
            if (err != null)
            {
                SendReply(player, err);
                return;
            }

            if (player.IsAdmin && config.Settings.DrawHomeSphere) player.SendConsoleCommand("ddraw.sphere", 30f, Color.blue, GetGround(positionCoordinates), 2.5f);

            err = CheckFoundation(player.userID, positionCoordinates);
            if (err != null)
            {
                PrintMsgL(player, err);
                return;
            }
            err = CheckInsideBlock(positionCoordinates);
            if (err != null)
            {
                PrintMsgL(player, err);
                return;
            }
            err = CheckInsideBattery(positionCoordinates);
            if (err != null)
            {
                PrintMsgL(player, err);
                return;
            }
            homeData.Locations[args[0]] = positionCoordinates;
            changedHome = True;
            PrintMsgL(player, "HomeSave");
            PrintMsgL(player, "HomeQuota", homeData.Locations.Count, limit);
        }

        private void CommandRemoveHome(IPlayer p, string command, string[] args)
        {
            if (DisabledTPT.DisabledCommands.Contains(command.ToLower())) { p.Reply("Disabled command: " + command); return; }
            if (!config.Settings.HomesEnabled) { p.Reply("Homes are not enabled in the config."); return; }
            var player = p.Object as BasePlayer;
            if (!player || !IsAllowed(player, PermHome) || !player.IsConnected || player.IsSleeping()) return;
            if (args.Length != 1)
            {
                PrintMsgL(player, "SyntaxCommandRemoveHome");
                return;
            }
            HomeData homeData;
            if (!Home.TryGetValue(player.userID, out homeData) || homeData.Locations.Count <= 0)
            {
                PrintMsgL(player, "HomeListEmpty");
                return;
            }
            if (homeData.Locations.Remove(args[0]))
            {
                changedHome = True;
                PrintMsgL(player, "HomeRemove", args[0]);
            }
            else
                PrintMsgL(player, "HomeNotFound");
        }

        private void CommandHome(IPlayer p, string command, string[] args)
        {
            if (DisabledTPT.DisabledCommands.Contains(command.ToLower())) { p.Reply("Disabled command: " + command); return; }
            if (!config.Settings.HomesEnabled) { p.Reply("Homes are not enabled in the config."); return; }
            var player = p.Object as BasePlayer;
            if (!player || !IsAllowed(player, PermHome) || !player.IsConnected || player.IsSleeping()) return;
            if (args.Length == 0)
            {
                PrintMsgL(player, "SyntaxCommandHome");
                if (IsAllowed(player)) PrintMsgL(player, "SyntaxCommandHomeAdmin");
                return;
            }
            switch (args[0].ToLower())
            {
                case "add":
                    CommandSetHome(p, command, args.Skip(1).ToArray());
                    break;
                case "list":
                    CommandListHomes(p, command, args.Skip(1).ToArray());
                    break;
                case "remove":
                    CommandRemoveHome(p, command, args.Skip(1).ToArray());
                    break;
                case "radius":
                    CommandHomeRadius(p, command, args.Skip(1).ToArray());
                    break;
                case "delete":
                    CommandHomeDelete(p, command, args.Skip(1).ToArray());
                    break;
                case "tp":
                    CommandHomeAdminTP(p, command, args.Skip(1).ToArray());
                    break;
                case "homes":
                    CommandHomeHomes(p, command, args.Skip(1).ToArray());
                    break;
                case "wipe":
                    CommandWipeHomes(p, command, args.Skip(1).ToArray());
                    break;
                default:
                    cmdChatHomeTP(player, command, args);
                    break;
            }
        }

        private void CommandHomeRadius(IPlayer p, string command, string[] args)
        {
            if (DisabledTPT.DisabledCommands.Contains(command.ToLower())) { p.Reply("Disabled command: " + command); return; }
            var player = p.Object as BasePlayer;
            if (!player || !IsAllowedMsg(player, PermRadiusHome) || !player.IsConnected || player.IsSleeping()) return;
            float radius;
            if (args.Length != 1 || !float.TryParse(args[0], out radius)) radius = 10;
            var found = False;
            foreach (var homeData in Home)
            {
                var toRemove = new List<string>();
                var target = RustCore.FindPlayerById(homeData.Key)?.displayName ?? homeData.Key.ToString();
                foreach (var location in homeData.Value.Locations)
                {
                    if ((player.transform.position - location.Value).magnitude <= radius)
                    {
                        if (CheckFoundation(homeData.Key, location.Value) != null)
                        {
                            toRemove.Add(location.Key);
                            continue;
                        }
                        var entity = GetFoundationOwned(location.Value, homeData.Key);
                        if (entity == null) continue;
                        player.SendConsoleCommand("ddraw.text", 30f, Color.blue, entity.CenterPoint() + new Vector3(0, .5f), $"<size=20>{target} - {location.Key} {location.Value}</size>");
                        DrawBox(player, entity.CenterPoint(), entity.transform.rotation, entity.bounds.size);
                        PrintMsg(player, $"{target} - {location.Key} {location.Value}");
                        found = True;
                    }
                }
                foreach (var loc in toRemove)
                {
                    homeData.Value.Locations.Remove(loc);
                    changedHome = True;
                }
            }
            if (!found)
                PrintMsgL(player, "HomeNoFound");
        }

        private void CommandHomeDelete(IPlayer p, string command, string[] args)
        {
            if (DisabledTPT.DisabledCommands.Contains(command.ToLower())) { p.Reply("Disabled command: " + command); return; }
            var player = p.Object as BasePlayer;
            if (!player || !IsAllowedMsg(player, PermDeleteHome) || !player.IsConnected || player.IsSleeping()) return;
            if (args.Length != 2)
            {
                PrintMsgL(player, "SyntaxCommandHomeDelete");
                return;
            }
            var userId = FindPlayersSingleId(args[0], player);
            if (userId <= 0) return;
            HomeData targetHome;
            if (!Home.TryGetValue(userId, out targetHome) || !targetHome.Locations.Remove(args[1]))
            {
                PrintMsgL(player, "HomeNotFound");
                return;
            }
            changedHome = True;
            PrintMsgL(player, "HomeDelete", args[0], args[1]);
        }

        private void CommandHomeAdminTP(IPlayer p, string command, string[] args)
        {
            if (DisabledTPT.DisabledCommands.Contains(command.ToLower())) { p.Reply("Disabled command: " + command); return; }
            var player = p.Object as BasePlayer;
            if (!player || !IsAllowedMsg(player, PermTpHome) || !player.IsConnected || player.IsSleeping()) return;
            if (args.Length != 2)
            {
                PrintMsgL(player, "SyntaxCommandHomeAdminTP");
                return;
            }
            var userId = FindPlayersSingleId(args[0], player);
            if (userId <= 0) return;
            HomeData targetHome;
            Vector3 location;
            if (!Home.TryGetValue(userId, out targetHome) || !targetHome.Locations.TryGetValue(args[1], out location))
            {
                PrintMsgL(player, "HomeNotFound");
                return;
            }

            Teleport(player, location, TeleportType.AdminHome);
            PrintMsgL(player, "HomeAdminTP", args[0], args[1]);
        }

        // Check that plugins are available and enabled for CheckEconomy()
        private bool UseEconomy()
        {
            if ((config.Settings.UseEconomics && Economics) ||
                (config.Settings.UseServerRewards && ServerRewards))
            {
                return True;
            }
            return False;
        }

        // Check balance on multiple plugins and optionally withdraw money from the player
        private bool CheckEconomy(BasePlayer player, double bypass, bool withdraw = False, bool deposit = False)
        {
            double balance = 0;
            bool foundmoney = False;

            // Check Economics first.  If not in use or balance low, check ServerRewards below
            if (config.Settings.UseEconomics && Economics)
            {
                balance = (double)Economics?.CallHook("Balance", player.UserIDString);
                if (balance >= bypass)
                {
                    foundmoney = True;
                    if (withdraw)
                    {
                        var w = (bool)Economics?.CallHook("Withdraw", player.userID, bypass);
                        return w;
                    }
                    else if (deposit)
                    {
                        Economics?.CallHook("Deposit", player.userID, bypass);
                    }
                }
            }

            // No money via Economics, or plugin not in use.  Try ServerRewards.
            if (config.Settings.UseServerRewards && ServerRewards)
            {
                object bal = ServerRewards?.Call("CheckPoints", player.userID);
                balance = Convert.ToDouble(bal);
                if (balance >= bypass && !foundmoney)
                {
                    foundmoney = True;
                    if (withdraw)
                    {
                        var w = (bool)ServerRewards?.Call("TakePoints", player.userID, (int)bypass);
                        return w;
                    }
                    else if (deposit)
                    {
                        ServerRewards?.Call("AddPoints", player.userID, (int)bypass);
                    }
                }
            }

            // Just checking balance without withdrawal - did we find anything?
            if (foundmoney)
            {
                return True;
            }
            return False;
        }

        private void cmdChatHomeTP(BasePlayer player, string command, string[] args)
        {
            if (DisabledTPT.DisabledCommands.Contains(command.ToLower())) { player.ChatMessage("Disabled command."); return; }
            if (!IsAllowed(player, PermHome) || !player.IsConnected || player.IsSleeping()) return;
            bool paidmoney = False;
            if (!config.Settings.HomesEnabled) { player.ChatMessage("Homes are not enabled in the config."); return; }
            if (args.Length < 1)
            {
                PrintMsgL(player, "SyntaxCommandHome");
                return;
            }
            HomeData homeData;
            if (!Home.TryGetValue(player.userID, out homeData) || homeData.Locations.Count <= 0)
            {
                PrintMsgL(player, "HomeListEmpty");
                return;
            }
            Vector3 location;
            if (!homeData.Locations.TryGetValue(args[0], out location))
            {
                PrintMsgL(player, "HomeNotFound");
                return;
            }
            var err = CheckPlayer(player, player.transform.position, config.Home.UsableOutOfBuildingBlocked, CanCraftHome(player), True, "home");
            if (err != null)
            {
                PrintMsgL(player, err);
                return;
            }
            err = CheckFoundation(player.userID, location) ?? CheckTargetLocation(player, location, config.Home.UsableIntoBuildingBlocked, config.Home.CupOwnerAllowOnBuildingBlocked);
            if (err != null)
            {
                PrintMsgL(player, "HomeRemovedInvalid", args[0]);
                homeData.Locations.Remove(args[0]);
                changedHome = True;
                return;
            }
            err = CheckInsideBlock(location);
            if (err != null)
            {
                PrintMsgL(player, "HomeRemovedInsideBlock", args[0]);
                homeData.Locations.Remove(args[0]);
                changedHome = True;
                return;
            }
            var timestamp = Facepunch.Math.Epoch.Current;
            var currentDate = DateTime.Now.ToString("d");
            if (homeData.Teleports.Date != currentDate)
            {
                homeData.Teleports.Amount = 0;
                homeData.Teleports.Date = currentDate;
            }
            var cooldown = GetLower(player, config.Home.VIPCooldowns, config.Home.Cooldown);
            if (cooldown > 0 && timestamp - homeData.Teleports.Timestamp < cooldown)
            {
                var cmdSent = "";
                bool foundmoney = CheckEconomy(player, config.Home.Bypass);
                try
                {
                    cmdSent = args[1].ToLower();
                }
                catch { }

                bool payalso = False;
                if (config.Home.Pay > 0)
                {
                    payalso = True;
                }
                if ((config.Settings.BypassCMD != null) && (cmdSent == config.Settings.BypassCMD.ToLower()))
                {
                    if (foundmoney)
                    {
                        CheckEconomy(player, config.Home.Bypass, True);
                        paidmoney = True;
                        PrintMsgL(player, "HomeTPCooldownBypass", config.Home.Bypass);
                        if (payalso)
                        {
                            PrintMsgL(player, "PayToHome", config.Home.Pay);
                        }
                    }
                    else
                    {
                        PrintMsgL(player, "HomeTPCooldownBypassF", config.Home.Bypass);
                        return;
                    }
                }
                else if (UseEconomy())
                {
                    var remain = cooldown - (timestamp - homeData.Teleports.Timestamp);
                    PrintMsgL(player, "HomeTPCooldown", FormatTime(remain));
                    if (config.Home.Bypass > 0 && config.Settings.BypassCMD != null)
                    {
                        PrintMsgL(player, "HomeTPCooldownBypassP", config.Home.Bypass);
                        PrintMsgL(player, "HomeTPCooldownBypassP2", config.Settings.BypassCMD);
                    }
                    return;
                }
                else
                {
                    var remain = cooldown - (timestamp - homeData.Teleports.Timestamp);
                    PrintMsgL(player, "HomeTPCooldown", FormatTime(remain));
                    return;
                }
            }
            var limit = GetHigher(player, config.Home.VIPDailyLimits, config.Home.DailyLimit, true);
            if (limit > 0 && homeData.Teleports.Amount >= limit)
            {
                PrintMsgL(player, "HomeTPLimitReached", limit);
                return;
            }
            if (TeleportTimers.ContainsKey(player.userID))
            {
                PrintMsgL(player, "TeleportPendingTPC");
                return;
            }
            err = CanPlayerTeleport(player);
            if (err != null)
            {
                SendReply(player, err);
                return;
            }
            err = CheckItems(player);
            if (err != null)
            {
                PrintMsgL(player, "TPBlockedItem", err);
                return;
            }

            var countdown = GetLower(player, config.Home.VIPCountdowns, config.Home.Countdown);
            TeleportTimers[player.userID] = new TeleportTimer
            {
                OriginPlayer = player,
                Timer = timer.Once(countdown, () =>
                {
#if DEBUG
                    Puts("Calling CheckPlayer from cmdChatHomeTP");
#endif
                    err = CheckPlayer(player, player.transform.position, config.Home.UsableOutOfBuildingBlocked, CanCraftHome(player), True, "home");
                    if (err != null)
                    {
                        PrintMsgL(player, "Interrupted");
                        PrintMsgL(player, err);
                        if (paidmoney)
                        {
                            paidmoney = False;
                            CheckEconomy(player, config.Home.Bypass, False, True);
                        }
                        TeleportTimers.Remove(player.userID);
                        return;
                    }
                    err = CanPlayerTeleport(player);
                    if (err != null)
                    {
                        PrintMsgL(player, "Interrupted");
                        PrintMsgL(player, err);
                        if (paidmoney)
                        {
                            paidmoney = False;
                            CheckEconomy(player, config.Home.Bypass, False, True);
                        }
                        TeleportTimers.Remove(player.userID);
                        return;
                    }
                    err = CheckItems(player);
                    if (err != null)
                    {
                        PrintMsgL(player, "Interrupted");
                        PrintMsgL(player, "TPBlockedItem", err);
                        if (paidmoney)
                        {
                            paidmoney = False;
                            CheckEconomy(player, config.Home.Bypass, False, True);
                        }
                        TeleportTimers.Remove(player.userID);
                        return;
                    }
                    err = CheckFoundation(player.userID, location) ?? CheckTargetLocation(player, location, config.Home.UsableIntoBuildingBlocked, config.Home.CupOwnerAllowOnBuildingBlocked);
                    if (err != null)
                    {
                        PrintMsgL(player, "HomeRemovedInvalid", args[0]);
                        homeData.Locations.Remove(args[0]);
                        changedHome = True;
                        if (paidmoney)
                        {
                            paidmoney = False;
                            CheckEconomy(player, config.Home.Bypass, False, True);
                        }
                        return;
                    }
                    err = CheckInsideBlock(location);
                    if (err != null)
                    {
                        PrintMsgL(player, "HomeRemovedInsideBlock", args[0]);
                        homeData.Locations.Remove(args[0]);
                        changedHome = True;
                        if (paidmoney)
                        {
                            paidmoney = False;
                            CheckEconomy(player, config.Home.Bypass, False, True);
                        }
                        return;
                    }

                    if (UseEconomy())
                    {
                        if (config.Home.Pay > 0 && !CheckEconomy(player, config.Home.Pay))
                        {
                            PrintMsgL(player, "Interrupted");
                            PrintMsgL(player, "TPNoMoney", config.Home.Pay);

                            TeleportTimers.Remove(player.userID);
                            return;
                        }
                        else if (config.Home.Pay > 0)
                        {
                            var w = CheckEconomy(player, (double)config.Home.Pay, True);
                            PrintMsgL(player, "TPMoney", (double)config.Home.Pay);
                        }
                    }

                    Teleport(player, location, TeleportType.Home);
                    homeData.Teleports.Amount++;
                    homeData.Teleports.Timestamp = timestamp;
                    changedHome = True;
                    PrintMsgL(player, "HomeTP", args[0]);
                    if (limit > 0) PrintMsgL(player, "HomeTPAmount", limit - homeData.Teleports.Amount);
                    TeleportTimers.Remove(player.userID);
                })
            };
            PrintMsgL(player, "HomeTPStarted", args[0], countdown);
        }

        private void CommandListHomes(IPlayer p, string command, string[] args)
        {
            if (DisabledTPT.DisabledCommands.Contains(command.ToLower())) { p.Reply("Disabled command: " + command); return; }
            var player = p.Object as BasePlayer;
            if (!player || !player.IsConnected || player.IsSleeping()) return;
            if (!config.Settings.HomesEnabled) { p.Reply("Homes are not enabled in the config."); return; }
            if (args.Length != 0)
            {
                PrintMsgL(player, "SyntaxCommandListHomes");
                return;
            }
            HomeData homeData;
            if (!Home.TryGetValue(player.userID, out homeData) || homeData.Locations.Count <= 0)
            {
                PrintMsgL(player, "HomeListEmpty");
                return;
            }
            PrintMsgL(player, "HomeList");
            if (config.Home.CheckValidOnList)
            {
                var toRemove = new List<string>();
                foreach (var location in homeData.Locations)
                {
                    var err = CheckFoundation(player.userID, location.Value);
                    if (err != null)
                    {
                        toRemove.Add(location.Key);
                        continue;
                    }
                    PrintMsgL(player, $"{location.Key} {location.Value}");
                }
                foreach (var loc in toRemove)
                {
                    PrintMsgL(player, "HomeRemovedInvalid", loc);
                    homeData.Locations.Remove(loc);
                    changedHome = True;
                }
                return;
            }
            foreach (var location in homeData.Locations)
                PrintMsgL(player, $"{location.Key} {location.Value}");
        }

        private void CommandHomeHomes(IPlayer p, string command, string[] args)
        {
            if (DisabledTPT.DisabledCommands.Contains(command.ToLower())) { p.Reply("Disabled command: " + command); return; }
            var player = p.Object as BasePlayer;
            if (!player || !IsAllowedMsg(player, PermHomeHomes) || !player.IsConnected || player.IsSleeping()) return;
            if (args.Length != 1)
            {
                PrintMsgL(player, "SyntaxCommandHomeHomes");
                return;
            }
            var userId = FindPlayersSingleId(args[0], player);
            if (userId <= 0) return;
            HomeData homeData;
            if (!Home.TryGetValue(userId, out homeData) || homeData.Locations.Count <= 0)
            {
                PrintMsgL(player, "HomeListEmpty");
                return;
            }
            PrintMsgL(player, "HomeList");
            var toRemove = new List<string>();
            foreach (var location in homeData.Locations)
            {
                var err = CheckFoundation(userId, location.Value);
                if (err != null)
                {
                    toRemove.Add(location.Key);
                    continue;
                }
                PrintMsgL(player, $"{location.Key} {location.Value}");
            }
            foreach (var loc in toRemove)
            {
                PrintMsgL(player, "HomeRemovedInvalid", loc);
                homeData.Locations.Remove(loc);
                changedHome = True;
            }
        }

        private void CommandTeleportTeam(IPlayer p, string command, string[] args)
        {
            if (DisabledTPT.DisabledCommands.Contains(command.ToLower())) { p.Reply("Disabled command: " + command); return; }
            if (!config.TPT.UseClans && !config.TPT.UseFriends && !config.TPT.UseTeams) return;

            var player = p.Object as BasePlayer;
            if (!player || !IsAllowedMsg(player, PermTpT))
                return;

            if (args.Length < 1)
            {
                PrintMsgL(player, "TPTInfo");
                return;
            }

            switch (args[0].ToLower())
            {
                case "friend":
                case "clan":
                case "team":
                    {
                        SetDisabled(player, args[0].ToLower());
                        return;
                    }
            }

            PrintMsgL(player, "TPTInfo");
        }

        public bool IsOnSameTeam(ulong playerId, ulong targetId)
        {
            RelationshipManager.PlayerTeam team1;
            if (!RelationshipManager.Instance.playerToTeam.TryGetValue(playerId, out team1))
            {
                return false;
            }

            RelationshipManager.PlayerTeam team2;
            if (!RelationshipManager.Instance.playerToTeam.TryGetValue(targetId, out team2))
            {
                return false;
            }

            return team1.teamID == team2.teamID;
        }

        private bool AreFriends(string playerId, string targetId)
        {
            var success = Friends?.Call("AreFriends", playerId, targetId);

            if (success is bool)
            {
                return (bool)success;
            }

            return false;
        }

        private bool IsInSameClan(string playerId, string targetId)
        {
            string targetClan = Clans?.Call("GetClanOf", targetId) as string;

            if (targetClan == null)
            {
                return false;
            }

            string playerClan = Clans?.Call("GetClanOf", playerId) as string;

            if (playerClan == null)
            {
                return false;
            }

            return targetClan == playerClan;
        }

        private void OnTeleportRequested(BasePlayer target, BasePlayer player)
        {
            if (!permission.UserHasPermission(target.UserIDString, PermTpT) || !permission.UserHasPermission(player.UserIDString, PermTpT))
            {
                return;
            }

            if (config.TPT.UseClans && IsEnabled(target.UserIDString, "clan") && IsInSameClan(player.UserIDString, target.UserIDString))
            {
                target.SendConsoleCommand("chat.say /tpa");
            }
            else if (config.TPT.UseFriends && IsEnabled(target.UserIDString, "friend") && AreFriends(player.UserIDString, target.UserIDString))
            {
                target.SendConsoleCommand("chat.say /tpa");
            }
            else if (config.TPT.UseTeams && IsEnabled(target.UserIDString, "team") && IsOnSameTeam(player.userID, target.userID))
            {
                target.SendConsoleCommand("chat.say /tpa");
            }
        }

        bool IsEnabled(string targetId, string value)
        {
            if (TPT.ContainsKey(targetId) && TPT[targetId].Contains(value))
            {
                return false;
            }

            return true;
        }

        void SetDisabled(BasePlayer target, string value)
        {
            List<string> list;
            if (!TPT.TryGetValue(target.UserIDString, out list))
            {
                TPT[target.UserIDString] = list = new List<string>();
            }

            if (list.Contains(value))
            {
                list.Remove(value);
            }
            else
            {
                list.Add(value);
            }

            string status = lang.GetMessage($"TPT_{!list.Contains(value)}", this, target.UserIDString);
            string message = string.Format(lang.GetMessage($"TPT_{value}", this, target.UserIDString), status);

            PrintMsg(target, message);
            changedTPT = True;
        }

        private void CommandTeleportRequest(IPlayer p, string command, string[] args)
        {
            if (DisabledTPT.DisabledCommands.Contains(command.ToLower())) { p.Reply("Disabled command: " + command); return; }
            var player = p.Object as BasePlayer;
            if (!player || !IsAllowedMsg(player, PermTpR) || !player.IsConnected || player.IsSleeping()) return;
            if (!config.Settings.TPREnabled) { p.Reply("TPR is not enabled in the config."); return; }
            if (args.Length == 0)
            {
                PrintMsgL(player, "SyntaxCommandTPR");
                return;
            }
            var targets = FindPlayers(args[0]);
            if (targets.Count <= 0)
            {
                PrintMsgL(player, "PlayerNotFound");
                return;
            }
            BasePlayer target = null;
            if (args.Length >= 2)
            {
                int index;
                foreach (var arg in args)
                {
                    if (int.TryParse(arg.Replace("#", string.Empty), out index) && --index < targets.Count && index > -1)
                    {
                        target = targets[index];
                        break;
                    }
                }

                if (target == null)
                {
                    if (targets.Count > 1)
                    {
                        PrintMsgL(player, "MultiplePlayers", string.Join(", ", targets.Select(x => x.displayName).ToArray()));
                        return;
                    }
                    else target = targets[0];
                }
            }
            else
            {
                if (targets.Count > 1)
                {
                    PrintMsgL(player, "MultiplePlayers", string.Join(", ", targets.Select(x => x.displayName).ToArray()));
                    return;
                }

                target = targets[0];
            }

            if (target == player)
            {
#if DEBUG
                Puts("Debug mode - allowing self teleport.");
#else
                PrintMsgL(player, "CantTeleportToSelf");
                return;
#endif
            }
#if DEBUG
            Puts("Calling CheckPlayer from cmdChatTeleportRequest");
#endif

            var err = CheckPlayer(player, player.transform.position, config.TPR.UsableOutOfBuildingBlocked, CanCraftTPR(player), True, "tpr");
            if (err != null)
            {
                PrintMsgL(player, err);
                return;
            }
            err = CheckTargetLocation(target, target.transform.position, config.TPR.UsableIntoBuildingBlocked, config.TPR.CupOwnerAllowOnBuildingBlocked);
            if (err != null)
            {
                PrintMsgL(player, err);
                return;
            }
            var timestamp = Facepunch.Math.Epoch.Current;
            var currentDate = DateTime.Now.ToString("d");
            TeleportData tprData;
            if (!TPR.TryGetValue(player.userID, out tprData))
                TPR[player.userID] = tprData = new TeleportData();
            if (tprData.Date != currentDate)
            {
                tprData.Amount = 0;
                tprData.Date = currentDate;
            }

            var cooldown = player.IsAdmin ? 0 : GetLower(player, config.TPR.VIPCooldowns, config.TPR.Cooldown);
            if (cooldown > 0 && timestamp - tprData.Timestamp < cooldown)
            {
                var cmdSent = "";
                bool foundmoney = CheckEconomy(player, config.TPR.Bypass);
                try
                {
                    cmdSent = args[1].ToLower();
                }
                catch { }

                bool payalso = False;
                if (config.TPR.Pay > 0)
                {
                    payalso = True;
                }
                if ((config.Settings.BypassCMD != null) && (cmdSent == config.Settings.BypassCMD.ToLower()))
                {
                    if (foundmoney)
                    {
                        CheckEconomy(player, config.TPR.Bypass, True);
                        PrintMsgL(player, "TPRCooldownBypass", config.TPR.Bypass);
                        if (payalso)
                        {
                            PrintMsgL(player, "PayToTPR", config.TPR.Pay);
                        }
                    }
                    else
                    {
                        PrintMsgL(player, "TPRCooldownBypassF", config.TPR.Bypass);
                        return;
                    }
                }
                else if (UseEconomy())
                {
                    var remain = cooldown - (timestamp - tprData.Timestamp);
                    PrintMsgL(player, "TPRCooldown", FormatTime(remain));
                    if (config.TPR.Bypass > 0 && config.Settings.BypassCMD != null)
                    {
                        PrintMsgL(player, "TPRCooldownBypassP", config.TPR.Bypass);
                        if (payalso)
                        {
                            PrintMsgL(player, "PayToTPR", config.TPR.Pay);
                        }
                        PrintMsgL(player, "TPRCooldownBypassP2a", config.Settings.BypassCMD);
                    }
                    return;
                }
                else
                {
                    var remain = cooldown - (timestamp - tprData.Timestamp);
                    PrintMsgL(player, "TPRCooldown", FormatTime(remain));
                    return;
                }
            }
            var limit = GetHigher(player, config.TPR.VIPDailyLimits, config.TPR.DailyLimit, true);
            if (limit > 0 && tprData.Amount >= limit)
            {
                PrintMsgL(player, "TPRLimitReached", limit);
                return;
            }
            if (TeleportTimers.ContainsKey(player.userID))
            {
                PrintMsgL(player, "TeleportPendingTPC");
                return;
            }
            if (TeleportTimers.ContainsKey(target.userID))
            {
                PrintMsgL(player, "TeleportPendingTarget");
                return;
            }
            if (PlayersRequests.ContainsKey(player.userID))
            {
                PrintMsgL(player, "PendingRequest");
                return;
            }
            if (PlayersRequests.ContainsKey(target.userID))
            {
                PrintMsgL(player, "PendingRequestTarget");
                return;
            }
            err = CanPlayerTeleport(player);
            if (err != null)
            {
                SendReply(player, err);
                return;
            }
            err = CanPlayerTeleport(target);
            if (err != null)
            {
                PrintMsgL(player, "TPRTarget");
                return;
            }
            err = CheckItems(player);
            if (err != null)
            {
                PrintMsgL(player, "TPBlockedItem", err);
                return;
            }

            if (config.TPR.UseClans_Friends_Teams)
            {
                if (IsInSameClan(player.UserIDString, target.UserIDString) || AreFriends(player.UserIDString, target.UserIDString) || IsOnSameTeam(player.userID, target.userID))
                {
                    PlayersRequests[player.userID] = target;
                    PlayersRequests[target.userID] = player;
                    PendingRequests[target.userID] = timer.Once(config.TPR.RequestDuration, () => { RequestTimedOut(player, target); });
                    PrintMsgL(player, "Request", target.displayName);
                    PrintMsgL(target, "RequestTarget", player.displayName);
                    Interface.CallHook("OnTeleportRequested", target, player);
                }
                else
                {
                    PrintMsgL(player, "TPR_NoClan_NoFriend_NoTeam");
                }
            }
            else
            {
                PlayersRequests[player.userID] = target;
                PlayersRequests[target.userID] = player;
                PendingRequests[target.userID] = timer.Once(config.TPR.RequestDuration, () => { RequestTimedOut(player, target); });
                PrintMsgL(player, "Request", target.displayName);
                PrintMsgL(target, "RequestTarget", player.displayName);
                Interface.CallHook("OnTeleportRequested", target, player);
            }
        }

        private void CommandTeleportAccept(IPlayer p, string command, string[] args)
        {
            if (DisabledTPT.DisabledCommands.Contains(command.ToLower())) { p.Reply("Disabled command: " + command); return; }
            var player = p.Object as BasePlayer;
            if (!player || !player.IsConnected || player.IsSleeping()) return;
            if (!config.Settings.TPREnabled) { p.Reply("TPR is not enabled in the config."); return; }
            if (args.Length != 0)
            {
                PrintMsgL(player, "SyntaxCommandTPA");
                return;
            }
            Timer reqTimer;
            if (!PendingRequests.TryGetValue(player.userID, out reqTimer))
            {
                PrintMsgL(player, "NoPendingRequest");
                return;
            }
#if DEBUG
            Puts("Calling CheckPlayer from cmdChatTeleportAccept");
#endif
            var err = CheckPlayer(player, player.transform.position, False, CanCraftTPR(player), False, "tpa");
            if (err != null)
            {
                PrintMsgL(player, err);
                return;
            }
            err = CanPlayerTeleport(player);
            if (err != null)
            {
                SendReply(player, err);
                return;
            }
            var originPlayer = PlayersRequests[player.userID];
            err = CheckTargetLocation(originPlayer, player.transform.position, config.TPR.UsableIntoBuildingBlocked, config.TPR.CupOwnerAllowOnBuildingBlocked);
            if (err != null)
            {
                SendReply(player, err);
                return;
            }
            if (config.TPR.BlockTPAOnCeiling)
            {
                if (GetFloor(player.transform.position).Count > 0)
                {
                    PrintMsgL(player, "AcceptOnRoof");
                    return;
                }
            }
            var countdown = GetLower(originPlayer, config.TPR.VIPCountdowns, config.TPR.Countdown);
            PrintMsgL(originPlayer, "Accept", player.displayName, countdown);
            PrintMsgL(player, "AcceptTarget", originPlayer.displayName);
            var timestamp = Facepunch.Math.Epoch.Current;
            TeleportTimers[originPlayer.userID] = new TeleportTimer
            {
                OriginPlayer = originPlayer,
                TargetPlayer = player,
                Timer = timer.Once(countdown, () =>
                {
#if DEBUG
                    Puts("Calling CheckPlayer from cmdChatTeleportAccept timer loop");
#endif
                    err = CheckPlayer(originPlayer, originPlayer.transform.position, config.TPR.UsableOutOfBuildingBlocked, CanCraftTPR(originPlayer), True, "tpa") ?? CheckPlayer(player, player.transform.position, False, CanCraftTPR(player), True, "tpa");
                    if (err != null)
                    {
                        PrintMsgL(player, "InterruptedTarget", originPlayer.displayName);
                        PrintMsgL(originPlayer, "Interrupted");
                        PrintMsgL(originPlayer, err);
                        TeleportTimers.Remove(originPlayer.userID);
                        return;
                    }
                    err = CheckTargetLocation(originPlayer, player.transform.position, config.TPR.UsableIntoBuildingBlocked, config.TPR.CupOwnerAllowOnBuildingBlocked);
                    if (err != null)
                    {
                        SendReply(player, err);
                        PrintMsgL(originPlayer, "Interrupted");
                        SendReply(originPlayer, err);
                        TeleportTimers.Remove(originPlayer.userID);
                        return;
                    }
                    err = CanPlayerTeleport(originPlayer) ?? CanPlayerTeleport(player);
                    if (err != null)
                    {
                        SendReply(player, err);
                        PrintMsgL(originPlayer, "Interrupted");
                        SendReply(originPlayer, err);
                        TeleportTimers.Remove(originPlayer.userID);
                        return;
                    }
                    err = CheckItems(originPlayer);
                    if (err != null)
                    {
                        PrintMsgL(player, "InterruptedTarget", originPlayer.displayName);
                        PrintMsgL(originPlayer, "Interrupted");
                        PrintMsgL(originPlayer, "TPBlockedItem", err);
                        TeleportTimers.Remove(originPlayer.userID);
                        return;
                    }
                    if (UseEconomy())
                    {
                        if (config.TPR.Pay > 0)
                        {
                            if (!CheckEconomy(originPlayer, config.TPR.Pay))
                            {
                                PrintMsgL(player, "InterruptedTarget", originPlayer.displayName);
                                PrintMsgL(originPlayer, "TPNoMoney", config.TPR.Pay);
                                TeleportTimers.Remove(originPlayer.userID);
                                return;
                            }
                            else
                            {
                                CheckEconomy(originPlayer, config.TPR.Pay, True);
                                PrintMsgL(originPlayer, "TPMoney", (double)config.TPR.Pay);
                            }
                        }
                    }
                    Teleport(originPlayer, player.transform.position, TeleportType.TPA);
                    if (!config.TPR.AllowTPB) RemoveLocation(originPlayer);
                    var tprData = TPR[originPlayer.userID];
                    tprData.Amount++;
                    tprData.Timestamp = timestamp;
                    changedTPR = True;
                    PrintMsgL(player, "SuccessTarget", originPlayer.displayName);
                    PrintMsgL(originPlayer, "Success", player.displayName);
                    var limit = GetHigher(player, config.TPR.VIPDailyLimits, config.TPR.DailyLimit, true);
                    if (limit > 0) PrintMsgL(originPlayer, "TPRAmount", limit - tprData.Amount);
                    TeleportTimers.Remove(originPlayer.userID);
                })
            };
            reqTimer.Destroy();
            PendingRequests.Remove(player.userID);
            PlayersRequests.Remove(player.userID);
            PlayersRequests.Remove(originPlayer.userID);
        }

        private void CommandWipeHomes(IPlayer p, string command, string[] args)
        {
            if (DisabledTPT.DisabledCommands.Contains(command.ToLower())) { p.Reply("Disabled command: " + command); return; }
            var player = p.Object as BasePlayer;
            if (!player || !IsAllowedMsg(player, PermWipeHomes) || !player.IsConnected || player.IsSleeping()) return;
            Home.Clear();
            changedHome = True;
            PrintMsgL(player, "HomesListWiped");
        }

        private void CommandTeleportHelp(IPlayer p, string command, string[] args)
        {
            if (DisabledTPT.DisabledCommands.Contains(command.ToLower())) { p.Reply("Disabled command: " + command); return; }
            var player = p.Object as BasePlayer;
            if (!player || !player.IsConnected || player.IsSleeping()) return;
            if (!config.Settings.HomesEnabled && !config.Settings.TPREnabled && !IsAllowedMsg(player)) return;
            if (args.Length == 1)
            {
                var key = $"TPHelp{args[0].ToLower()}";
                var msg = _(key, player);
                if (key.Equals(msg))
                    PrintMsgL(player, "InvalidHelpModule");
                else
                    PrintMsg(player, msg);
            }
            else
            {
                var msg = _("TPHelpGeneral", player);
                if (IsAllowed(player))
                    msg += NewLine + "/tphelp AdminTP";
                if (config.Settings.HomesEnabled)
                    msg += NewLine + "/tphelp Home";
                if (config.Settings.TPREnabled)
                    msg += NewLine + "/tphelp TPR";
                PrintMsg(player, msg);
            }
        }

        private void CommandTeleportInfo(IPlayer p, string command, string[] args)
        {
            if (DisabledTPT.DisabledCommands.Contains(command.ToLower())) { p.Reply("Disabled command: " + command); return; }
            if (!config.Settings.HomesEnabled && !config.Settings.TPREnabled && !config.Settings.TownEnabled) { p.Reply($"{command} is not enabled in the config."); return; }
            var player = p.Object as BasePlayer;
            if (!player || !player.IsConnected || player.IsSleeping()) return;
            if (args.Length == 1)
            {
                var module = args[0].ToLower();
                var msg = _($"TPSettings{module}", player);
                var timestamp = Facepunch.Math.Epoch.Current;
                var currentDate = DateTime.Now.ToString("d");
                TeleportData teleportData;
                int limit;
                int cooldown;
                switch (module)
                {
                    case "home":
                        limit = GetHigher(player, config.Home.VIPDailyLimits, config.Home.DailyLimit, true);
                        cooldown = GetLower(player, config.Home.VIPCooldowns, config.Home.Cooldown);
                        PrintMsg(player, string.Format(msg, FormatTime(cooldown), limit > 0 ? limit.ToString() : _("Unlimited", player), GetLower(player, config.Home.VIPHomesLimits, config.Home.HomesLimit)));
                        HomeData homeData;
                        if (!Home.TryGetValue(player.userID, out homeData))
                            Home[player.userID] = homeData = new HomeData();
                        if (homeData.Teleports.Date != currentDate)
                        {
                            homeData.Teleports.Amount = 0;
                            homeData.Teleports.Date = currentDate;
                        }
                        if (limit > 0) PrintMsgL(player, "HomeTPAmount", limit - homeData.Teleports.Amount);
                        if (cooldown > 0 && timestamp - homeData.Teleports.Timestamp < cooldown)
                        {
                            var remain = cooldown - (timestamp - homeData.Teleports.Timestamp);
                            PrintMsgL(player, "HomeTPCooldown", FormatTime(remain));
                        }
                        break;
                    case "tpr":
                        limit = GetHigher(player, config.TPR.VIPDailyLimits, config.TPR.DailyLimit, true);
                        cooldown = GetLower(player, config.TPR.VIPCooldowns, config.TPR.Cooldown);
                        PrintMsg(player, string.Format(msg, FormatTime(cooldown), limit > 0 ? limit.ToString() : _("Unlimited", player)));
                        if (!TPR.TryGetValue(player.userID, out teleportData))
                            TPR[player.userID] = teleportData = new TeleportData();
                        if (teleportData.Date != currentDate)
                        {
                            teleportData.Amount = 0;
                            teleportData.Date = currentDate;
                        }
                        if (limit > 0) PrintMsgL(player, "TPRAmount", limit - teleportData.Amount);
                        if (cooldown > 0 && timestamp - teleportData.Timestamp < cooldown)
                        {
                            var remain = cooldown - (timestamp - teleportData.Timestamp);
                            PrintMsgL(player, "TPRCooldown", FormatTime(remain));
                        }
                        break;
                    case "town":
                        limit = GetHigher(player, config.Town.VIPDailyLimits, config.Town.DailyLimit, true);
                        cooldown = GetLower(player, config.Town.VIPCooldowns, config.Town.Cooldown);
                        PrintMsg(player, string.Format(msg, FormatTime(cooldown), limit > 0 ? limit.ToString() : _("Unlimited", player)));
                        if (!Town.TryGetValue(player.userID, out teleportData))
                            Town[player.userID] = teleportData = new TeleportData();
                        if (teleportData.Date != currentDate)
                        {
                            teleportData.Amount = 0;
                            teleportData.Date = currentDate;
                        }
                        if (limit > 0) PrintMsgL(player, "TownTPAmount", limit - teleportData.Amount);
                        if (cooldown > 0 && timestamp - teleportData.Timestamp < cooldown)
                        {
                            var remain = cooldown - (timestamp - teleportData.Timestamp);
                            PrintMsgL(player, "TownTPCooldown", FormatTime(remain));
                            PrintMsgL(player, "TownTPCooldownBypassP", config.Town.Bypass);
                            PrintMsgL(player, "TownTPCooldownBypassP2", config.Settings.BypassCMD);
                        }
                        break;
                    case "outpost":
                        limit = GetHigher(player, config.Outpost.VIPDailyLimits, config.Outpost.DailyLimit, true);
                        cooldown = GetLower(player, config.Outpost.VIPCooldowns, config.Outpost.Cooldown);
                        PrintMsg(player, string.Format(msg, FormatTime(cooldown), limit > 0 ? limit.ToString() : _("Unlimited", player)));
                        if (!Outpost.TryGetValue(player.userID, out teleportData))
                            Outpost[player.userID] = teleportData = new TeleportData();
                        if (teleportData.Date != currentDate)
                        {
                            teleportData.Amount = 0;
                            teleportData.Date = currentDate;
                        }
                        if (limit > 0) PrintMsgL(player, "OutpostTPAmount", limit - teleportData.Amount);
                        if (cooldown > 0 && timestamp - teleportData.Timestamp < cooldown)
                        {
                            var remain = cooldown - (timestamp - teleportData.Timestamp);
                            PrintMsgL(player, "OutpostTPCooldown", FormatTime(remain));
                            PrintMsgL(player, "OutpostTPCooldownBypassP", config.Outpost.Bypass);
                            PrintMsgL(player, "OutpostTPCooldownBypassP2", config.Settings.BypassCMD);
                        }
                        break;
                    case "bandit":
                        limit = GetHigher(player, config.Bandit.VIPDailyLimits, config.Bandit.DailyLimit, true);
                        cooldown = GetLower(player, config.Bandit.VIPCooldowns, config.Bandit.Cooldown);
                        PrintMsg(player, string.Format(msg, FormatTime(cooldown), limit > 0 ? limit.ToString() : _("Unlimited", player)));
                        if (!Bandit.TryGetValue(player.userID, out teleportData))
                            Bandit[player.userID] = teleportData = new TeleportData();
                        if (teleportData.Date != currentDate)
                        {
                            teleportData.Amount = 0;
                            teleportData.Date = currentDate;
                        }
                        if (limit > 0) PrintMsgL(player, "BanditTPAmount", limit - teleportData.Amount);
                        if (cooldown > 0 && timestamp - teleportData.Timestamp < cooldown)
                        {
                            var remain = cooldown - (timestamp - teleportData.Timestamp);
                            PrintMsgL(player, "BanditTPCooldown", FormatTime(remain));
                            PrintMsgL(player, "BanditTPCooldownBypassP", config.Bandit.Bypass);
                            PrintMsgL(player, "BanditTPCooldownBypassP2", config.Settings.BypassCMD);
                        }
                        break;
                    default:
                        PrintMsgL(player, "InvalidHelpModule");
                        break;
                }
            }
            else
            {
                var msg = _("TPInfoGeneral", player);
                if (config.Settings.HomesEnabled)
                    msg += NewLine + "/tpinfo Home";
                if (config.Settings.TPREnabled)
                    msg += NewLine + "/tpinfo TPR";
                if (config.Settings.TownEnabled)
                    msg += NewLine + "/tpinfo Town";
                if (outpostEnabled)
                    msg += NewLine + "/tpinfo Outpost";
                if (banditEnabled)
                    msg += NewLine + "/tpinfo Bandit";
                PrintMsgL(player, msg);
            }
        }

        private void CommandTeleportCancel(IPlayer p, string command, string[] args)
        {
            var player = p.Object as BasePlayer;
            if (!player || !player.IsConnected || player.IsSleeping()) return;
            if (args.Length != 0)
            {
                PrintMsgL(player, "SyntaxCommandTPC");
                return;
            }
            TeleportTimer teleportTimer;
            if (TeleportTimers.TryGetValue(player.userID, out teleportTimer))
            {
                teleportTimer.Timer?.Destroy();
                PrintMsgL(player, "TPCancelled");
                PrintMsgL(teleportTimer.TargetPlayer, "TPCancelledTarget", player.displayName);
                TeleportTimers.Remove(player.userID);
                return;
            }
            foreach (var keyValuePair in TeleportTimers)
            {
                if (keyValuePair.Value.TargetPlayer != player) continue;
                keyValuePair.Value.Timer?.Destroy();
                PrintMsgL(keyValuePair.Value.OriginPlayer, "TPCancelledTarget", player.displayName);
                PrintMsgL(player, "TPYouCancelledTarget", keyValuePair.Value.OriginPlayer.displayName);
                TeleportTimers.Remove(keyValuePair.Key);
                return;
            }
            BasePlayer target;
            if (!PlayersRequests.TryGetValue(player.userID, out target))
            {
                PrintMsgL(player, "NoPendingRequest");
                return;
            }
            Timer reqTimer;
            if (PendingRequests.TryGetValue(player.userID, out reqTimer))
            {
                reqTimer.Destroy();
                PendingRequests.Remove(player.userID);
            }
            else if (PendingRequests.TryGetValue(target.userID, out reqTimer))
            {
                reqTimer.Destroy();
                PendingRequests.Remove(target.userID);
                var temp = player;
                player = target;
                target = temp;
            }
            PlayersRequests.Remove(target.userID);
            PlayersRequests.Remove(player.userID);
            PrintMsgL(player, "Cancelled", target.displayName);
            PrintMsgL(target, "CancelledTarget", player.displayName);
        }

        private void CommandOutpost(IPlayer p, string command, string[] args)
        {
            CommandTown(p, "outpost", args);
        }

        private void CommandBandit(IPlayer p, string command, string[] args)
        {
            CommandTown(p, "bandit", args);
        }

        private void CommandTown(IPlayer p, string command, string[] args)
        {


            if (DisabledTPT.DisabledCommands.Contains(command.ToLower())) { p.Reply("Disabled command: " + command); return; }
            var player = p.Object as BasePlayer;
            if (!player || !player.IsConnected || player.IsSleeping()) return;
#if DEBUG
            Puts($"cmdChatTown: command={command}");
#endif
            switch (command)
            {
                case "outpost":
                    if (!IsAllowedMsg(player, PermTpOutpost)) return;
                    break;
                case "bandit":
                    if (!IsAllowedMsg(player, PermTpBandit)) return;
                    break;
                case "town":
                default:
                    if (!IsAllowedMsg(player, PermTpTown)) return;
                    break;
            }

            // For admin using set command
            if (args.Length == 1 && IsAllowed(player) && args[0].ToLower().Equals("set"))
            {
                switch (command)
                {
                    case "outpost":
                        config.Outpost.Location = player.transform.position;
                        SaveConfig();
                        PrintMsgL(player, "OutpostTPLocation", config.Outpost.Location);
                        break;
                    case "bandit":
                        config.Bandit.Location = player.transform.position;
                        SaveConfig();
                        PrintMsgL(player, "BanditTPLocation", config.Bandit.Location);
                        break;
                    case "town":
                    default:
                        config.Town.Location = player.transform.position;
                        SaveConfig();
                        PrintMsgL(player, "TownTPLocation", config.Town.Location);
                        break;
                }
                return;
            }

            bool paidmoney = False;

            // Is outpost/bandit/town usage enabled?
            if (!outpostEnabled && command == "outpost")
            {
                PrintMsgL(player, OutpostTPDisabledMessage);
                return;
            }
            else if (!banditEnabled && command == "bandit")
            {
                PrintMsgL(player, BanditTPDisabledMessage);
                return;
            }
            else if (!config.Settings.TownEnabled && command == "town")
            {
                PrintMsgL(player, "TownTPDisabled");
                return;
            }

            // Are they trying to bypass cooldown or did they just type something else?
            if (args.Length == 1 && (args[0].ToLower() != config.Settings.BypassCMD.ToLower()))
            {
                string com = command ?? "town";
                string msg = "SyntaxCommand" + char.ToUpper(com[0]) + com.Substring(1);
                PrintMsgL(player, msg);
                if (IsAllowed(player)) PrintMsgL(player, msg + "Admin");
                return;
            }

            // Is outpost/bandit/town location set?
            if (config.Outpost.Location == Zero && command == "outpost")
            {
                PrintMsgL(player, "OutpostTPNotSet");
                return;
            }
            else if (config.Bandit.Location == Zero && command == "bandit")
            {
                PrintMsgL(player, "BanditTPNotSet");
                return;
            }
            else if (config.Town.Location == Zero && command == "town")
            {
                PrintMsgL(player, "TownTPNotSet");
                return;
            }

            TeleportData teleportData = new TeleportData();
            var timestamp = Facepunch.Math.Epoch.Current;
            var currentDate = DateTime.Now.ToString("d");

            string err = null;
            int cooldown = 0;
            int limit = 0;
            int targetPay = 0;
            int targetBypass = 0;
            string msgPay = null;
            string msgCooldown = null;
            string msgCooldownBypass = null;
            string msgCooldownBypassF = null;
            string msgCooldownBypassP = null;
            string msgCooldownBypassP2 = null;
            string msgLimitReached = null;
#if DEBUG
            Puts("Calling CheckPlayer from cmdChatTown");
#endif
            // Setup vars for checks below
            switch (command)
            {
                case "outpost":
                    err = CheckPlayer(player, player.transform.position, config.Outpost.UsableOutOfBuildingBlocked, CanCraftOutpost(player), True, "outpost");
                    if (err != null)
                    {
                        PrintMsgL(player, err);
                        return;
                    }
                    cooldown = GetLower(player, config.Outpost.VIPCooldowns, config.Outpost.Cooldown);
                    if (!Outpost.TryGetValue(player.userID, out teleportData))
                    {
                        Outpost[player.userID] = teleportData = new TeleportData();
                    }
                    if (teleportData.Date != currentDate)
                    {
                        teleportData.Amount = 0;
                        teleportData.Date = currentDate;
                    }

                    targetPay = config.Outpost.Pay;
                    targetBypass = config.Outpost.Bypass;

                    msgPay = "PayToOutpost";
                    msgCooldown = "OutpostTPCooldown";
                    msgCooldownBypass = "OutpostTPCooldownBypass";
                    msgCooldownBypassF = "OutpostTPCooldownBypassF";
                    msgCooldownBypassP = "OutpostTPCooldownBypassP";
                    msgCooldownBypassP2 = "OutpostTPCooldownBypassP2";
                    msgLimitReached = "OutpostTPLimitReached";
                    limit = GetHigher(player, config.Outpost.VIPDailyLimits, config.Outpost.DailyLimit, true);
                    break;
                case "bandit":
                    err = CheckPlayer(player, player.transform.position, config.Bandit.UsableOutOfBuildingBlocked, CanCraftBandit(player), True, "bandit");
                    if (err != null)
                    {
                        PrintMsgL(player, err);
                        return;
                    }
                    cooldown = GetLower(player, config.Bandit.VIPCooldowns, config.Bandit.Cooldown);
                    if (!Bandit.TryGetValue(player.userID, out teleportData))
                    {
                        Bandit[player.userID] = teleportData = new TeleportData();
                    }
                    if (teleportData.Date != currentDate)
                    {
                        teleportData.Amount = 0;
                        teleportData.Date = currentDate;
                    }
                    targetPay = config.Bandit.Pay;
                    targetBypass = config.Bandit.Bypass;

                    msgPay = "PayToBandit";
                    msgCooldown = "BanditTPCooldown";
                    msgCooldownBypass = "BanditTPCooldownBypass";
                    msgCooldownBypassF = "BanditTPCooldownBypassF";
                    msgCooldownBypassP = "BanditTPCooldownBypassP";
                    msgCooldownBypassP2 = "BanditTPCooldownBypassP2";
                    msgLimitReached = "BanditTPLimitReached";
                    limit = GetHigher(player, config.Bandit.VIPDailyLimits, config.Bandit.DailyLimit, true);
                    break;
                case "town":
                default:
                    err = CheckPlayer(player, player.transform.position, config.Town.UsableOutOfBuildingBlocked, CanCraftTown(player), True, "town");
                    if (err != null)
                    {
                        PrintMsgL(player, err);
                        return;
                    }
                    cooldown = GetLower(player, config.Town.VIPCooldowns, config.Town.Cooldown);
                    if (!Town.TryGetValue(player.userID, out teleportData))
                    {
                        Town[player.userID] = teleportData = new TeleportData();
                    }
                    if (teleportData.Date != currentDate)
                    {
                        teleportData.Amount = 0;
                        teleportData.Date = currentDate;
                    }
                    targetPay = config.Town.Pay;
                    targetBypass = config.Town.Bypass;

                    msgPay = "PayToTown";
                    msgCooldown = "TownTPCooldown";
                    msgCooldownBypass = "TownTPCooldownBypass";
                    msgCooldownBypassF = "TownTPCooldownBypassF";
                    msgCooldownBypassP = "TownTPCooldownBypassP";
                    msgCooldownBypassP2 = "TownTPCooldownBypassP2";
                    msgLimitReached = "TownTPLimitReached";
                    limit = GetHigher(player, config.Town.VIPDailyLimits, config.Town.DailyLimit, true);
                    break;
            }

            // Check and process cooldown, bypass, and payment for all modes
            if (cooldown > 0 && timestamp - teleportData.Timestamp < cooldown)
            {
                var cmdSent = "";
                bool foundmoney = CheckEconomy(player, targetBypass);
                try
                {
                    cmdSent = args[0].ToLower();
                }
                catch { }

                bool payalso = False;
                if (targetPay > 0)
                {
                    payalso = True;
                }
                if ((config.Settings.BypassCMD != null) && (cmdSent == config.Settings.BypassCMD.ToLower()))
                {
                    if (foundmoney)
                    {
                        CheckEconomy(player, targetBypass, True);
                        paidmoney = True;
                        PrintMsgL(player, msgCooldownBypass, targetBypass);
                        if (payalso)
                        {
                            PrintMsgL(player, msgPay, targetPay);
                        }
                    }
                    else
                    {
                        PrintMsgL(player, msgCooldownBypassF, targetBypass);
                        return;
                    }
                }
                else if (UseEconomy())
                {
                    var remain = cooldown - (timestamp - teleportData.Timestamp);
                    PrintMsgL(player, msgCooldown, FormatTime(remain));
                    if (targetBypass > 0 && config.Settings.BypassCMD != null)
                    {
                        PrintMsgL(player, msgCooldownBypassP, targetBypass);
                        PrintMsgL(player, msgCooldownBypassP2, config.Settings.BypassCMD);
                    }
                    return;
                }
                else
                {
                    var remain = cooldown - (timestamp - teleportData.Timestamp);
                    PrintMsgL(player, msgCooldown, FormatTime(remain));
                    return;
                }
            }

            if (limit > 0 && teleportData.Amount >= limit)
            {
                PrintMsgL(player, msgLimitReached, limit);
                return;
            }
            if (TeleportTimers.ContainsKey(player.userID))
            {
                PrintMsgL(player, "TeleportPendingTPC");
                return;
            }
            err = CanPlayerTeleport(player);
            if (err != null)
            {
                SendReply(player, err);
                return;
            }
            err = CheckItems(player);
            if (err != null)
            {
                PrintMsgL(player, "TPBlockedItem", err);
                return;
            }

            int countdown = 0;
            switch (command)
            {
                case "outpost":
                    countdown = GetLower(player, config.Outpost.VIPCountdowns, config.Outpost.Countdown);
                    TeleportTimers[player.userID] = new TeleportTimer
                    {
                        OriginPlayer = player,
                        Timer = timer.Once(countdown, () =>
                        {
#if DEBUG
                            Puts("Calling CheckPlayer from cmdChatTown outpost timer loop");
#endif
                            err = CheckPlayer(player, player.transform.position, config.Outpost.UsableOutOfBuildingBlocked, CanCraftOutpost(player), True, "outpost");
                            if (err != null)
                            {
                                PrintMsgL(player, "Interrupted");
                                PrintMsgL(player, err);
                                if (paidmoney)
                                {
                                    paidmoney = False;
                                    CheckEconomy(player, config.Outpost.Bypass, False, True);
                                }
                                TeleportTimers.Remove(player.userID);
                                return;
                            }
                            err = CanPlayerTeleport(player);
                            if (err != null)
                            {
                                PrintMsgL(player, "Interrupted");
                                PrintMsgL(player, err);
                                if (paidmoney)
                                {
                                    paidmoney = False;
                                    CheckEconomy(player, config.Outpost.Bypass, False, True);
                                }
                                TeleportTimers.Remove(player.userID);
                                return;
                            }
                            err = CheckItems(player);
                            if (err != null)
                            {
                                PrintMsgL(player, "Interrupted");
                                PrintMsgL(player, "TPBlockedItem", err);
                                if (paidmoney)
                                {
                                    paidmoney = False;
                                    CheckEconomy(player, config.Outpost.Bypass, False, True);
                                }
                                TeleportTimers.Remove(player.userID);
                                return;
                            }

                            if (UseEconomy())
                            {
                                if (config.Outpost.Pay > 0 && !CheckEconomy(player, config.Outpost.Pay))
                                {
                                    PrintMsgL(player, "Interrupted");
                                    PrintMsgL(player, "TPNoMoney", config.Outpost.Pay);
                                    TeleportTimers.Remove(player.userID);
                                    return;
                                }
                                else if (config.Outpost.Pay > 0)
                                {
                                    CheckEconomy(player, config.Outpost.Pay, True);
                                    PrintMsgL(player, "TPMoney", (double)config.Outpost.Pay);
                                }
                            }
                            Teleport(player, config.Outpost.Location, TeleportType.Outpost);
                            teleportData.Amount++;
                            teleportData.Timestamp = timestamp;

                            changedOutpost = True;
                            PrintMsgL(player, "OutpostTP");
                            if (limit > 0) PrintMsgL(player, "OutpostTPAmount", limit - teleportData.Amount);
                            TeleportTimers.Remove(player.userID);
                        })
                    };
                    PrintMsgL(player, "OutpostTPStarted", countdown);
                    break;
                case "bandit":
                    countdown = GetLower(player, config.Bandit.VIPCountdowns, config.Bandit.Countdown);
                    TeleportTimers[player.userID] = new TeleportTimer
                    {
                        OriginPlayer = player,
                        Timer = timer.Once(countdown, () =>
                        {
#if DEBUG
                            Puts("Calling CheckPlayer from cmdChatTown bandit timer loop");
#endif
                            err = CheckPlayer(player, player.transform.position, config.Bandit.UsableOutOfBuildingBlocked, CanCraftBandit(player), True, "bandit");
                            if (err != null)
                            {
                                PrintMsgL(player, "Interrupted");
                                PrintMsgL(player, err);
                                if (paidmoney)
                                {
                                    paidmoney = False;
                                    CheckEconomy(player, config.Bandit.Bypass, False, True);
                                }
                                TeleportTimers.Remove(player.userID);
                                return;
                            }
                            err = CanPlayerTeleport(player);
                            if (err != null)
                            {
                                PrintMsgL(player, "Interrupted");
                                PrintMsgL(player, err);
                                if (paidmoney)
                                {
                                    paidmoney = False;
                                    CheckEconomy(player, config.Bandit.Bypass, False, True);
                                }
                                TeleportTimers.Remove(player.userID);
                                return;
                            }
                            err = CheckItems(player);
                            if (err != null)
                            {
                                PrintMsgL(player, "Interrupted");
                                PrintMsgL(player, "TPBlockedItem", err);
                                if (paidmoney)
                                {
                                    paidmoney = False;
                                    CheckEconomy(player, config.Bandit.Bypass, False, True);
                                }
                                TeleportTimers.Remove(player.userID);
                                return;
                            }

                            if (UseEconomy())
                            {
                                if (config.Bandit.Pay > 0 && !CheckEconomy(player, config.Bandit.Pay))
                                {
                                    PrintMsgL(player, "Interrupted");
                                    PrintMsgL(player, "TPNoMoney", config.Bandit.Pay);
                                    TeleportTimers.Remove(player.userID);
                                    return;
                                }
                                else if (config.Bandit.Pay > 0)
                                {
                                    CheckEconomy(player, config.Bandit.Pay, True);
                                    PrintMsgL(player, "TPMoney", (double)config.Bandit.Pay);
                                }
                            }
                            Teleport(player, config.Bandit.Location, TeleportType.Bandit);
                            teleportData.Amount++;
                            teleportData.Timestamp = timestamp;

                            changedBandit = True;
                            PrintMsgL(player, "BanditTP");
                            if (limit > 0) PrintMsgL(player, "BanditTPAmount", limit - teleportData.Amount);
                            TeleportTimers.Remove(player.userID);
                        })
                    };
                    PrintMsgL(player, "BanditTPStarted", countdown);
                    break;
                case "town":
                default:
                    countdown = GetLower(player, config.Town.VIPCountdowns, config.Town.Countdown);
                    TeleportTimers[player.userID] = new TeleportTimer
                    {
                        OriginPlayer = player,
                        Timer = timer.Once(countdown, () =>
                        {
#if DEBUG
                            Puts("Calling CheckPlayer from cmdChatTown town timer loop");
#endif
                            err = CheckPlayer(player, player.transform.position, config.Town.UsableOutOfBuildingBlocked, CanCraftTown(player), True, "town");
                            if (err != null)
                            {
                                PrintMsgL(player, "Interrupted");
                                PrintMsgL(player, err);
                                if (paidmoney)
                                {
                                    paidmoney = False;
                                    CheckEconomy(player, config.Town.Bypass, False, True);
                                }
                                TeleportTimers.Remove(player.userID);
                                return;
                            }
                            err = CanPlayerTeleport(player);
                            if (err != null)
                            {
                                PrintMsgL(player, "Interrupted");
                                PrintMsgL(player, err);
                                if (paidmoney)
                                {
                                    paidmoney = False;
                                    CheckEconomy(player, config.Town.Bypass, False, True);
                                }
                                TeleportTimers.Remove(player.userID);
                                return;
                            }
                            err = CheckItems(player);
                            if (err != null)
                            {
                                PrintMsgL(player, "Interrupted");
                                PrintMsgL(player, "TPBlockedItem", err);
                                if (paidmoney)
                                {
                                    paidmoney = False;
                                    CheckEconomy(player, config.Town.Bypass, False, True);
                                }
                                TeleportTimers.Remove(player.userID);
                                return;
                            }

                            if (UseEconomy())
                            {
                                if (config.Town.Pay > 0 && !CheckEconomy(player, config.Town.Pay))
                                {
                                    PrintMsgL(player, "Interrupted");
                                    PrintMsgL(player, "TPNoMoney", config.Town.Pay);
                                    TeleportTimers.Remove(player.userID);
                                    return;
                                }
                                else if (config.Town.Pay > 0)
                                {
                                    CheckEconomy(player, config.Town.Pay, True);
                                    PrintMsgL(player, "TPMoney", (double)config.Town.Pay);
                                }
                            }
                            Teleport(player, config.Town.Location, TeleportType.Town);
                            teleportData.Amount++;
                            teleportData.Timestamp = timestamp;

                            changedTown = True;
                            PrintMsgL(player, "TownTP");
                            if (limit > 0) PrintMsgL(player, "TownTPAmount", limit - teleportData.Amount);
                            TeleportTimers.Remove(player.userID);
                        })
                    };
                    PrintMsgL(player, "TownTPStarted", countdown);
                    break;
            }
        }

        private void CommandTeleportII(IPlayer p, string command, string[] args)
        {
            if (DisabledTPT.DisabledCommands.Contains(command.ToLower())) { p.Reply("Disabled command: " + command); return; }
            var player = p.Object as BasePlayer;
            if (player != null && (!IsAllowedMsg(player, PermTpConsole) || !player.IsConnected || player.IsSleeping())) return;

            List<BasePlayer> players;
            switch (command)
            {
                case "teleport.topos":
                    if (args.Length < 4)
                    {
                        p.Reply(_("SyntaxConsoleCommandToPos", player));
                        return;
                    }
                    players = FindPlayers(args[0], true);
                    if (players.Count <= 0)
                    {
                        p.Reply(_("PlayerNotFound", player));
                        return;
                    }
                    if (players.Count > 1)
                    {
                        p.Reply(_("MultiplePlayers", player, string.Join(", ", players.Select(t => t.displayName).ToArray())));
                        return;
                    }
                    var targetPlayer = players.First();
                    players.Clear();
                    float x;
                    if (!float.TryParse(args[1], out x)) x = -10000f;
                    float y;
                    if (!float.TryParse(args[2], out y)) y = -10000f;
                    float z;
                    if (!float.TryParse(args[3], out z)) z = -10000f;
                    if (!CheckBoundaries(x, y, z))
                    {
                        p.Reply(_("AdminTPOutOfBounds", player) + Environment.NewLine + _("AdminTPBoundaries", player, boundary));
                        return;
                    }
                    Teleport(targetPlayer, x, y, z, TeleportType.Console);
                    if (config.Admin.AnnounceTeleportToTarget)
                        PrintMsgL(targetPlayer, "AdminTPConsoleTP", targetPlayer.transform.position);
                    p.Reply(_("AdminTPTargetCoordinates", player, targetPlayer.displayName, targetPlayer.transform.position));
                    Puts(_("LogTeleportPlayer", null, player?.displayName, targetPlayer.displayName, targetPlayer.transform.position));
                    break;
                case "teleport.toplayer":
                    if (args.Length < 2)
                    {
                        p.Reply(_("SyntaxConsoleCommandToPlayer", player));
                        return;
                    }
                    players = FindPlayers(args[0], true);
                    if (players.Count <= 0)
                    {
                        p.Reply(_("PlayerNotFound", player));
                        return;
                    }
                    if (players.Count > 1)
                    {
                        p.Reply(_("MultiplePlayers", player, string.Join(", ", players.Select(t => t.displayName).ToArray())));
                        return;
                    }
                    var originPlayer = players.First();
                    players = FindPlayers(args[1], true);
                    if (players.Count <= 0)
                    {
                        p.Reply(_("PlayerNotFound", player));
                        return;
                    }
                    if (players.Count > 1)
                    {
                        p.Reply(_("MultiplePlayers", player, string.Join(", ", players.Select(t => t.displayName).ToArray())));
                        players.Clear();
                        return;
                    }
                    targetPlayer = players.First();
                    if (targetPlayer == originPlayer)
                    {
                        players.Clear();
                        p.Reply(_("CantTeleportPlayerToSelf", player));
                        return;
                    }
                    players.Clear();
                    Teleport(originPlayer, targetPlayer, TeleportType.Console);
                    p.Reply(_("AdminTPPlayers", player, originPlayer.displayName, targetPlayer.displayName));
                    PrintMsgL(originPlayer, "AdminTPConsoleTPPlayer", targetPlayer.displayName);
                    if (config.Admin.AnnounceTeleportToTarget)
                        PrintMsgL(targetPlayer, "AdminTPConsoleTPPlayerTarget", originPlayer.displayName);
                    Puts(_("LogTeleportPlayer", null, player?.displayName, originPlayer.displayName, targetPlayer.displayName));
                    break;
            }
        }

        private string GetHostileTime(BasePlayer player)
        {
            return Math.Ceiling((player.State.unHostileTimestamp - TimeEx.currentTimestamp) / 60).ToString();
        }

        float GetMonumentFloat(string monumentName)
        {
            string name = monumentName.Contains(":") ? monumentName.Substring(0, monumentName.LastIndexOf(":")) : monumentName.TrimEnd();

            switch (name)
            {
                case "Abandoned Cabins":
                    return 24f + 30f;
                case "Abandoned Supermarket":
                    return 50f;
                case "Airfield":
                    return 200f;
                case "Bandit Camp":
                    return 100f + 25f;
                case "Giant Excavator Pit":
                    return 200f + 25f;
                case "Harbor":
                    return 100f + 50f;
                case "HQM Quarry":
                    return 27.5f + 10f;
                case "Large Oil Rig":
                    return 200f;
                case "Launch Site":
                    return 200f + 100f;
                case "Lighthouse":
                    return 24f + 24f;
                case "Military Tunnel":
                    return 100f;
                case "Mining Outpost":
                    return 25f + 15f;
                case "Oil Rig":
                    return 100f;
                case "Outpost":
                    return 100f + 25f;
                case "Oxum's Gas Station":
                    return 50f + 15f;
                case "Power Plant":
                    return 100f + 40f;
                case "power_sub_small_1":
                case "power_sub_small_2":
                case "power_sub_big_1":
                case "power_sub_big_2":
                    return 30f;
                case "Satellite Dish":
                    return 75f + 15f;
                case "Sewer Branch":
                    return 75f + 25f;
                case "Stone Quarry":
                    return 27.5f;
                case "Sulfur Quarry":
                    return 27.5f;
                case "The Dome":
                    return 50f + 20f;
                case "Train Yard":
                    return 100 + 50f;
                case "Water Treatment Plant":
                    return 100f + 85f;
                case "Water Well":
                    return 24f;
                case "Wild Swamp":
                    return 24f;
            }

            return config.Settings.DefaultMonumentSize;
        }

        /*private void CommandSphereMonuments(IPlayer p, string command, string[] args)
        {
            if (DisabledTPT.DisabledCommands.Contains(command.ToLower())) { p.Reply("Disabled command: " + command); return; }
            var player = p?.Object as BasePlayer;
            if (!player || !player.IsAdmin || !player.IsConnected || player.IsSleeping()) return;

            player.ChatMessage("near monument: " + IsNearMonument(player).ToString());
            player.ChatMessage("near cave: " + IsNearCave(player).ToString());

            foreach (var monument in monuments)
            {
                string name = monument.Key.Contains(":") ? monument.Key.Substring(0, monument.Key.LastIndexOf(":")) : monument.Key.TrimEnd();

                player.SendConsoleCommand("ddraw.sphere", 30f, Color.red, monument.Value.Position, GetMonumentFloat(name));
                player.SendConsoleCommand("ddraw.text", 30f, Color.blue, monument.Value.Position, name);
            }

            foreach (var cave in caves)
            {
                string name = cave.Key.Contains(":") ? cave.Key.Substring(0, cave.Key.LastIndexOf(":")) : cave.Key.TrimEnd();
                float realdistance = cave.Key.Contains("Small") ? config.Settings.CaveDistanceSmall : cave.Key.Contains("Medium") ? config.Settings.CaveDistanceMedium : config.Settings.CaveDistanceLarge;
                realdistance += 50f;

                player.SendConsoleCommand("ddraw.sphere", 30f, Color.black, cave.Value, realdistance);
                player.SendConsoleCommand("ddraw.text", 30f, Color.cyan, cave.Value, name);
            }
        }*/

        private void CommandImportHomes(IPlayer p, string command, string[] args)
        {
            if (DisabledTPT.DisabledCommands.Contains(command.ToLower())) { p.Reply("Disabled command: " + command); return; }
            var player = p.Object as BasePlayer;

            if (player != null && (!IsAllowedMsg(player, PermImportHomes) || !player.IsConnected || player.IsSleeping()))
            {
                p.Reply(_("NotAllowed", player));
                return;
            }
            var datafile = Interface.Oxide.DataFileSystem.GetFile("m-Teleportation");
            if (!datafile.Exists())
            {
                p.Reply("No m-Teleportation.json exists.");
                return;
            }
            datafile.Load();
            var allHomeData = datafile["HomeData"] as Dictionary<string, object>;
            if (allHomeData == null)
            {
                p.Reply(_("HomeListEmpty", player));
                return;
            }
            var count = 0;
            foreach (var kvp in allHomeData)
            {
                var homeDataOld = kvp.Value as Dictionary<string, object>;
                if (homeDataOld == null) continue;
                if (!homeDataOld.ContainsKey("HomeLocations")) continue;
                var homeList = homeDataOld["HomeLocations"] as Dictionary<string, object>;
                if (homeList == null) continue;
                var userId = Convert.ToUInt64(kvp.Key);
                HomeData homeData;
                if (!Home.TryGetValue(userId, out homeData))
                    Home[userId] = homeData = new HomeData();
                foreach (var kvp2 in homeList)
                {
                    var positionData = kvp2.Value as Dictionary<string, object>;
                    if (positionData == null) continue;
                    if (!positionData.ContainsKey("x") || !positionData.ContainsKey("y") || !positionData.ContainsKey("z")) continue;
                    var position = new Vector3(Convert.ToSingle(positionData["x"]), Convert.ToSingle(positionData["y"]), Convert.ToSingle(positionData["z"]));
                    homeData.Locations[kvp2.Key] = position;
                    changedHome = True;
                    count++;
                }
            }
            p.Reply(string.Format("Imported {0} homes.", count));
        }

        private void RequestTimedOut(BasePlayer player, BasePlayer target)
        {
            PlayersRequests.Remove(player.userID);
            PlayersRequests.Remove(target.userID);
            PendingRequests.Remove(target.userID);
            PrintMsgL(player, "TimedOut", target.displayName);
            PrintMsgL(target, "TimedOutTarget", player.displayName);
        }

        #region Util
        private string FormatTime(long seconds)
        {
            var timespan = TimeSpan.FromSeconds(seconds);
            return string.Format(timespan.TotalHours >= 1 ? "{2:00}:{0:00}:{1:00}" : "{0:00}:{1:00}", timespan.Minutes, timespan.Seconds, System.Math.Floor(timespan.TotalHours));
        }

        private double ConvertToRadians(double angle)
        {
            return System.Math.PI / 180 * angle;
        }
        #endregion

        #region Teleport

        public enum TeleportType
        {
            Home,
            TPR,
            TP,
            Bandit,
            Outpost,
            Near,
            TPL,
            TPB,
            AdminHome,
            TPA,
            Town,
            Console,
        }

        public void Teleport(BasePlayer player, BasePlayer target, TeleportType type) => Teleport(player, target.transform.position, type);

        public void Teleport(BasePlayer player, float x, float y, float z, TeleportType type) => Teleport(player, new Vector3(x, y, z), type);

        public void Teleport(BasePlayer player, Vector3 newPosition, TeleportType type)
        {
            if (!player.IsValid() || Vector3.Distance(newPosition, Zero) < 5f) return;

            SaveLocation(player);
            teleporting[player.userID] = newPosition;

            var oldPosition = player.transform.position;

            try
            {
                player.EnsureDismounted(); // 1.1.2 @Def

                if (player.HasParent())
                {
                    player.SetParent(null, True, True);
                }

                if (player.IsConnected) // 1.1.2 @Def
                {
                    player.EndLooting();
                    StartSleeping(player);
                }

                player.RemoveFromTriggers(); // 1.1.2 @Def recommendation to use natural method for issue with triggers
                player.Teleport(newPosition); // 1.1.6

                if (player.IsConnected && !Network.Net.sv.visibility.IsInside(player.net.group, newPosition))
                {
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, True);
                    player.ClientRPCPlayer(null, player, "StartLoading");
                    player.SendEntityUpdate();
                    if (!IsInvisible(player)) // fix for becoming networked briefly with vanish while teleporting
                    {
                        player.UpdateNetworkGroup(); // 1.1.1 building fix @ctv
                        player.SendNetworkUpdateImmediate(False);
                    }
                }
            }
            finally
            {
                player.ForceUpdateTriggers(); // 1.1.4 exploit fix for looting sleepers in safe zones
            }

            Interface.CallHook("OnPlayerTeleported", player, oldPosition, newPosition);
        }

        bool IsInvisible(BasePlayer player)
        {
            return Vanish != null && Vanish.Call<bool>("IsInvisible", player);
        }

        public void StartSleeping(BasePlayer player) // custom as to not cancel crafting, or remove player from vanish
        {
            if (!player.IsSleeping())
            {
                Interface.CallHook("OnPlayerSleep", player);
                player.SetPlayerFlag(BasePlayer.PlayerFlags.Sleeping, True);
                player.sleepStartTime = Time.time;
                BasePlayer.sleepingPlayerList.Add(player);
                player.CancelInvoke("InventoryUpdate");
                player.CancelInvoke("TeamUpdate");
            }
        }

        #endregion

        #region Checks
        private string CanPlayerTeleport(BasePlayer player)
        {
            return Interface.Oxide.CallHook("CanTeleport", player) as string;
        }

        private bool CanCraftHome(BasePlayer player)
        {
            return config.Home.AllowCraft || permission.UserHasPermission(player.UserIDString, PermCraftHome);
        }

        private bool CanCraftTown(BasePlayer player)
        {
            return config.Town.AllowCraft || permission.UserHasPermission(player.UserIDString, PermCraftTown);
        }

        private bool CanCraftOutpost(BasePlayer player)
        {
            return config.Outpost.AllowCraft || permission.UserHasPermission(player.UserIDString, PermCraftOutpost);
        }

        private bool CanCraftBandit(BasePlayer player)
        {
            return config.Bandit.AllowCraft || permission.UserHasPermission(player.UserIDString, PermCraftBandit);
        }

        private bool CanCraftTPR(BasePlayer player)
        {
            return config.TPR.AllowCraft || permission.UserHasPermission(player.UserIDString, PermCraftTpR);
        }

        public bool AboveWater(BasePlayer player)
        {
            var pos = player.transform.position;
#if DEBUG
            Puts($"Player position: {pos}.  Checking for water...");
#endif
            if ((TerrainMeta.HeightMap.GetHeight(pos) - TerrainMeta.WaterMap.GetHeight(pos)) >= 0)
            {
#if DEBUG
                Puts("Player not above water.");
#endif
                return False;
            }
            else
            {
#if DEBUG
                Puts("Player is above water!");
#endif
                return True;
            }
        }

        private string NearMonument(BasePlayer player)
        {
            foreach (var entry in monuments)
            {
                if (entry.Key.ToLower().Contains("power")) continue;

                var pos = entry.Value.Position;
                pos.y = player.transform.position.y;
                float dist = (player.transform.position - pos).magnitude;
#if DEBUG
                Puts($"Checking {entry.Key} dist: {dist}, realdistance: {entry.Value.Radius}");
#endif
                if (dist < entry.Value.Radius)
                {
#if DEBUG
                    Puts($"Player in range of {entry.Key}");
#endif
                    return entry.Key;
                }
            }

            if (IsMonument(player.transform.position))
            {
                return "monument";
            }

            return null;
        }

        private bool ContainsTopology(TerrainTopology.Enum mask, Vector3 position)
        {
            return (TerrainMeta.TopologyMap.GetTopology(position) & (int)mask) != 0;
        }

        public bool IsMonument(Vector3 position)
        {
            return !ContainsTopology(TerrainTopology.Enum.Building, position) && ContainsTopology(TerrainTopology.Enum.Monument, position);
        }

        public bool IsNearCave(BasePlayer player)
        {
            return !player.IsOutside() && ContainsTopology(TerrainTopology.Enum.Building | TerrainTopology.Enum.Monument, player.transform.position);
        }

        private string NearCave(BasePlayer player)
        {
            foreach (var entry in caves)
            {
                string caveName = entry.Key.Contains(":") ? entry.Key.Substring(0, entry.Key.LastIndexOf(":")) : entry.Key;
                float realdistance = entry.Key.Contains("Small") ? config.Settings.CaveDistanceSmall : entry.Key.Contains("Medium") ? config.Settings.CaveDistanceMedium : config.Settings.CaveDistanceLarge;

                if (Vector3.Distance(player.transform.position, entry.Value) < realdistance + 50f && !player.IsOutside())
                {
#if DEBUG
                    Puts($"NearCave: {caveName} nearby.");
#endif
                    return caveName;
                }
                else
                {
#if DEBUG
                    Puts("NearCave: Not near this cave, or above it.");
#endif
                }
            }

            if (IsNearCave(player))
            {
                return "cave";
            }

            return null;
        }

        private string CheckPlayer(BasePlayer player, Vector3 target, bool build = False, bool craft = False, bool origin = True, string mode = "home")
        {
            var onship = player.GetComponentInParent<CargoShip>();
            var onballoon = player.GetComponentInParent<HotAirBalloon>();
            var inlift = player.GetComponentInParent<Lift>();
            var pos = player.transform.position;

            string monname = NearMonument(player);
            if (config.Settings.Interrupt.Monument)
            {
                if (monname != null)
                {
                    return _("TooCloseToMon", player, monname);
                }
            }
            if (config.Settings.Interrupt.Oilrig)
            {
                if (monname != null && monname.Contains("Oil Rig"))
                {
                    return _("TooCloseToMon", player, monname);
                }
            }
            bool allowcave = True;

#if DEBUG
            Puts($"CheckPlayer(): called mode is {mode}");
#endif
            switch (mode)
            {
                case "tpt":
                    allowcave = config.TPT.AllowCave;
                    break;
                case "home":
                    allowcave = config.Home.AllowCave;
                    break;
                case "tpa":
                case "tpr":
                    allowcave = config.TPR.AllowCave;
                    break;
                case "town":
                    allowcave = config.Town.AllowCave;
                    break;
                case "outpost":
                    allowcave = config.Outpost.AllowCave;
                    break;
                case "bandit":
                    allowcave = config.Bandit.AllowCave;
                    break;
                default:
#if DEBUG
                    Puts("Skipping cave check...");
#endif
                    break;
            }
            if (!allowcave)
            {
#if DEBUG
                Puts("Checking cave distance...");
#endif
                string cavename = NearCave(player);
                if (cavename != null)
                {
                    return "TooCloseToCave";
                }
            }

            if (config.Settings.Interrupt.Hostile && (mode == "bandit" || mode == "outpost"))
            {
                if (player.IsHostile())
                {
                    return "TPHostile";
                }
            }
            if (player.isMounted && config.Settings.Interrupt.Mounted)
                return "TPMounted";
            if (!player.IsAlive())
                return "TPDead";
            // Block if hurt if the config is enabled.  If the player is not the target in a tpa condition, allow.
            if ((player.IsWounded() && origin) && config.Settings.Interrupt.Hurt)
                return "TPWounded";

            if (player.metabolism.temperature.value <= config.Settings.MinimumTemp && config.Settings.Interrupt.Cold)
            {
                return "TPTooCold";
            }
            if (player.metabolism.temperature.value >= config.Settings.MaximumTemp && config.Settings.Interrupt.Hot)
            {
                return "TPTooHot";
            }

            if (config.Settings.Interrupt.Boats && player.isMounted && player.GetMounted() is BaseBoat)
                return "TPBoat";
            if (config.Settings.Interrupt.AboveWater)
                if (AboveWater(player))
                    return "TPAboveWater";
            if (!build && !player.CanBuild(target, default(Quaternion), default(Bounds)))
                return "TPBuildingBlocked";
            if (player.IsSwimming() && config.Settings.Interrupt.Swimming)
                return "TPSwimming";
            // This will have to do until we have a proper parent name for this
            if (monname != null && monname.Contains("Oil Rig") && config.Settings.Interrupt.Oilrig)
                return "TPOilRig";
            if (monname != null && monname.Contains("Excavator") && config.Settings.Interrupt.Excavator)
                return "TPExcavator";
            if (onship && config.Settings.Interrupt.Cargo)
                return "TPCargoShip";
            if (onballoon && config.Settings.Interrupt.Balloon)
                return "TPHotAirBalloon";
            if (inlift && config.Settings.Interrupt.Lift)
                return "TPBucketLift";
            if (GetLift(pos) && config.Settings.Interrupt.Lift)
                return "TPRegLift";
            if (player.InSafeZone() && config.Settings.Interrupt.Safe)
                return "TPSafeZone";
            if (!craft && player.inventory.crafting.queue.Count > 0)
                return "TPCrafting";

            if (config.Settings.BlockZoneFlag && ZoneManager != null)
            {
                var success = ZoneManager?.Call("PlayerHasFlag", player, "notp");

                if (success is bool && (bool)success)
                {
                    return "TPFlagZone";
                }
            }

            if (config.Settings.BlockNoEscape && NoEscape != null)
            {
                var success = NoEscape?.Call("IsBlocked", player);

                if (success is bool && (bool)success)
                {
                    return "TPNoEscapeBlocked";
                }
            }

            return null;
        }

        private string CheckTargetLocation(BasePlayer player, Vector3 targetLocation, bool ubb, bool obb)
        {
            // ubb == UsableIntoBuildingBlocked
            // obb == CupOwnerAllowOnBuildingBlocked
            var entities = Pool.GetList<BuildingBlock>();
            Vis.Entities(targetLocation, 3f, entities, Layers.Mask.Construction, QueryTriggerInteraction.Ignore);
            bool denied = False;

            foreach (var block in entities)
            {
                if (CheckCupboardBlock(block, player, obb))
                {
                    denied = False;
#if DEBUG
                    Puts("Cupboard either owned or there is no cupboard");
#endif
                }
                else if (ubb && (player.userID != block.OwnerID))
                {
                    denied = False;
#if DEBUG
                    Puts("Player does not own block, but UsableIntoBuildingBlocked=true");
#endif
                }
                else if (player.userID == block.OwnerID)
                {
#if DEBUG
                    Puts("Player owns block");
#endif

                    if (!player.IsBuildingBlocked(targetLocation, new Quaternion(), block.bounds))
                    {
#if DEBUG
                        Puts("Player not BuildingBlocked. Likely unprotected building.");
#endif
                        denied = False;
                        break;
                    }
                    else if (ubb)
                    {
#if DEBUG
                        Puts("Player not blocked because UsableIntoBuildingBlocked=true");
#endif
                        denied = False;
                        break;
                    }
                    else
                    {
#if DEBUG
                        Puts("Player owns block but blocked by UsableIntoBuildingBlocked=false");
#endif
                        denied = True;
                        break;
                    }
                }
                else
                {
#if DEBUG
                    Puts("Player blocked");
#endif
                    denied = True;
                    break;
                }
            }
            Pool.FreeList(ref entities);

            return denied ? "TPTargetBuildingBlocked" : null;
        }

        // Check that a building block is owned by/attached to a cupboard, allow tp if not blocked unless allowed by config
        private bool CheckCupboardBlock(BuildingBlock block, BasePlayer player, bool obb)
        {
            // obb == CupOwnerAllowOnBuildingBlocked
            var building = block.GetBuilding();
            if (building != null)
            {
#if DEBUG
                Puts("Found building, checking privileges...");
                Puts($"Building ID: {building.ID}");
#endif
                // cupboard overlap.  Check privs.
                if (building.buildingPrivileges == null)
                {
#if DEBUG
                    Puts("No cupboard found, allowing teleport");
#endif
                    return player.CanBuild();
                }

                foreach (var priv in building.buildingPrivileges)
                {
                    if (priv.IsAuthed(player))
                    {
                        // player is authorized to the cupboard
#if DEBUG
                        Puts("Player owns cupboard with auth");
#endif
                        return True;
                    }
                }

                if (player.userID == block.OwnerID)
                {
                    if (obb)
                    {
#if DEBUG
                        // player set the cupboard and is allowed in by config
                        Puts("Player owns cupboard with no auth, but allowed by CupOwnerAllowOnBuildingBlocked=true");
#endif
                        return True;
                    }
#if DEBUG
                    // player set the cupboard but is blocked by config
                    Puts("Player owns cupboard with no auth, but blocked by CupOwnerAllowOnBuildingBlocked=false");
#endif
                    return False;
                }

#if DEBUG
                // player not authed
                Puts("Player does not own cupboard and is not authorized");
#endif
                return False;
            }
#if DEBUG
            Puts("No cupboard or building found - we cannot tell the status of this block");
#endif
            return True;
        }

        private string CheckInsideBlock(Vector3 targetLocation)
        {
            List<BuildingBlock> blocks = Pool.GetList<BuildingBlock>();
            Vis.Entities(targetLocation + new Vector3(0, 0.25f), 0.1f, blocks, blockLayer);
            bool inside = blocks.Count > 0;
            Pool.FreeList(ref blocks);

            return inside ? "TPTargetInsideBlock" : null;
        }

        private string CheckInsideBattery(Vector3 targetLocation)
        {
            var batteries = new List<ElectricBattery>();
            Vis.Entities(targetLocation, 0.35f, batteries, deployedLayer);
            return batteries.Count > 0 ? "TPTargetInsideBlock" : null;
        }

        private string CheckItems(BasePlayer player)
        {
            foreach (var blockedItem in ReverseBlockedItems)
            {
                if (player.inventory.FindItemID(blockedItem.Key) != null)
                {
                    return blockedItem.Value;
                }
            }
            return null;
        }

        private string CheckFoundation(ulong userID, Vector3 position)
        {
            if (CheckInsideBattery(position) != null)
            {
                return "HomeNoFoundation";
            }
            if (!config.Home.ForceOnTopOfFoundation) return null; // Foundation/floor not required
            if (UnderneathFoundation(position))
            {
                return "HomeFoundationUnderneathFoundation";
            }

            var entities = new List<BuildingBlock>();
            if (config.Home.AllowAboveFoundation) // Can set on a foundation or floor
            {
#if DEBUG
                Puts($"CheckFoundation() looking for foundation or floor at {position}");
#endif
                entities = GetFoundationOrFloor(position);
            }
            else // Can only use foundation, not floor/ceiling
            {
#if DEBUG
                Puts($"CheckFoundation() looking for foundation at {position}");
#endif
                entities = GetFoundation(position);
            }

            entities.RemoveAll(x => !x.IsValid() || x.IsDestroyed);
            if (entities.Count == 0) return "HomeNoFoundation";

            if (!config.Home.CheckFoundationForOwner) return null;
            for (var i = 0; i < entities.Count; i++)
            {
                if (entities[i].OwnerID == userID || IsFriend(userID, entities[i].OwnerID)) return null;
            }

            return "HomeFoundationNotFriendsOwned";
        }

        private BuildingBlock GetFoundationOwned(Vector3 position, ulong userID)
        {
#if DEBUG
            Puts("GetFoundationOwned() called...");
#endif
            var entities = GetFoundation(position);
            if (entities.Count == 0) return null;
            if (!config.Home.CheckFoundationForOwner) return entities[0];

            for (var i = 0; i < entities.Count; i++)
            {
                if (entities[i].OwnerID == userID) return entities[i];
                else if (IsFriend(userID, entities[i].OwnerID)) return entities[i];
            }
            return null;
        }

        // Borrowed/modified from PreventLooting and Rewards
        // playerid = active player, ownerid = owner of building block, who may be offline
        bool IsFriend(ulong playerid, ulong ownerid)
        {
            if (config.Home.UseFriends && Friends != null && Friends.IsLoaded)
            {
#if DEBUG
                Puts("Checking Friends...");
#endif
                var fr = Friends?.CallHook("AreFriends", playerid, ownerid);
                if (fr != null && fr is bool && (bool)fr)
                {
#if DEBUG
                    Puts("  IsFriend: true based on Friends plugin");
#endif
                    return True;
                }
            }
            if (config.Home.UseClans && Clans != null && Clans.IsLoaded)
            {
#if DEBUG
                Puts("Checking Clans...");
#endif
                string playerclan = (string)Clans?.CallHook("GetClanOf", playerid);
                string ownerclan = (string)Clans?.CallHook("GetClanOf", ownerid);
                if (playerclan != null && ownerclan != null && playerclan == ownerclan)
                {
#if DEBUG
                    Puts("  IsFriend: true based on Clans plugin");
#endif
                    return True;
                }
            }
            if (config.Home.UseTeams)
            {
#if DEBUG
                Puts("Checking Rust teams...");
#endif
                BasePlayer player = BasePlayer.FindByID(playerid);
                if (player != null && player.currentTeam != (long)0)
                {
                    RelationshipManager.PlayerTeam playerTeam = RelationshipManager.Instance.FindTeam(player.currentTeam);
                    if (playerTeam == null) return False;
                    if (playerTeam.members.Contains(ownerid))
                    {
#if DEBUG
                        Puts("  IsFriend: true based on Rust teams");
#endif
                        return True;
                    }
                }
            }
            return False;
        }

        // Check that we are near the middle of a block.  Also check for high wall overlap
        private bool ValidBlock(BaseEntity entity, Vector3 position)
        {
            if (!config.Settings.StrictFoundationCheck)
            {
                return True;
            }
#if DEBUG
            Puts($"ValidBlock() called for {entity.ShortPrefabName}");
#endif
            Vector3 center = entity.CenterPoint();

            List<BaseEntity> ents = new List<BaseEntity>();
            Vis.Entities<BaseEntity>(center, 1.5f, ents);
            foreach (BaseEntity wall in ents)
            {
                if (wall.name.Contains("external.high"))
                {
#if DEBUG
                    Puts($"    Found: {wall.name} @ center {center}, pos {position}");
#endif
                    return False;
                }
            }
#if DEBUG
            Puts($"  Checking block: {entity.name} @ center {center}, pos: {position.ToString()}");
#endif
            if (entity.PrefabName.Contains("triangle.prefab"))
            {
                if (Math.Abs(center.x - position.x) < 0.45f && Math.Abs(center.z - position.z) < 0.45f)
                {
#if DEBUG
                    Puts($"    Found: {entity.ShortPrefabName} @ center: {center}, pos: {position}");
#endif
                    return True;
                }
            }
            else if (entity.PrefabName.Contains("foundation.prefab") || entity.PrefabName.Contains("floor.prefab"))
            {
                if (Math.Abs(center.x - position.x) < 0.7f && Math.Abs(center.z - position.z) < 0.7f)
                {
#if DEBUG
                    Puts($"    Found: {entity.ShortPrefabName} @ center: {center}, pos: {position}");
#endif
                    return True;
                }
            }

            return False;
        }

        private List<BuildingBlock> GetFoundation(Vector3 position)
        {
            RaycastHit hitinfo;
            var entities = new List<BuildingBlock>();

            if (Physics.Raycast(position, Down, out hitinfo, 2.5f, blockLayer) && hitinfo.GetEntity().IsValid())
            {
                var entity = hitinfo.GetEntity();
                if (entity.PrefabName.Contains("foundation") || position.y < entity.WorldSpaceBounds().ToBounds().max.y)
                {
                    if (ValidBlock(entity, position))
                    {
#if DEBUG
                        Puts($"  GetFoundation() found {entity.PrefabName} at {entity.transform.position}");
#endif
                        entities.Add(entity as BuildingBlock);
                    }
                }
            }
            else
            {
#if DEBUG
                Puts("  GetFoundation() none found.");
#endif
            }

            return entities;
        }

        private List<BuildingBlock> GetFloor(Vector3 position)
        {
            RaycastHit hitinfo;
            var entities = new List<BuildingBlock>();

            if (Physics.Raycast(position, Down, out hitinfo, 0.25f, Layers.Mask.Construction, QueryTriggerInteraction.Ignore) && hitinfo.GetEntity().IsValid())
            {
                var entity = hitinfo.GetEntity();

                if (entity.IsValid() && entity.PrefabName.Contains("floor"))
                {
#if DEBUG
                    Puts($"  GetFloor() found {entity.PrefabName} at {entity.transform.position}");
#endif
                    entities.Add(entity as BuildingBlock);
                }
            }
            else
            {
#if DEBUG
                Puts("  GetFloor() none found.");
#endif
            }

            return entities;
        }

        private List<BuildingBlock> GetFoundationOrFloor(Vector3 position)
        {
            RaycastHit hitinfo;
            var entities = new List<BuildingBlock>();

            if (Physics.Raycast(position, Down, out hitinfo, 0.25f, blockLayer) && hitinfo.GetEntity().IsValid())
            {
                var entity = hitinfo.GetEntity();
                if (entity.PrefabName.Contains("floor") || entity.PrefabName.Contains("foundation"))// || position.y < entity.WorldSpaceBounds().ToBounds().max.y))
                {
#if DEBUG
                    Puts($"  GetFoundationOrFloor() found {entity.PrefabName} at {entity.transform.position}");
#endif
                    if (ValidBlock(entity, position))
                    {
                        entities.Add(entity as BuildingBlock);
                    }
                }
            }
            else
            {
#if DEBUG
                Puts("  GetFoundationOrFloor() none found.");
#endif
            }

            return entities;
        }

        private bool CheckBoundaries(float x, float y, float z)
        {
            return x <= boundary && x >= -boundary && y <= 2000 && y >= -100 && z <= boundary && z >= -boundary;
        }

        private Vector3 GetGround(Vector3 sourcePos)
        {
            if (!config.Home.AllowAboveFoundation) return sourcePos;
            var newPos = sourcePos;
            newPos.y = TerrainMeta.HeightMap.GetHeight(newPos);
            sourcePos.y += .5f;
            RaycastHit hitinfo;
            var done = False;

#if DEBUG
            Puts("GetGround(): Looking for iceberg or cave");
#endif
            //if (Physics.SphereCast(sourcePos, .1f, down, out hitinfo, 250, groundLayer))
            if (Physics.Raycast(sourcePos, Down, out hitinfo, 250f, groundLayer))
            {
                if ((config.Home.AllowIceberg && hitinfo.collider.name.Contains("iceberg")) || (config.Home.AllowCave && hitinfo.collider.name.Contains("cave_")))
                {
#if DEBUG
                    Puts("GetGround():   found iceberg or cave");
#endif
                    sourcePos.y = hitinfo.point.y;
                    done = True;
                }
                else
                {
                    var mesh = hitinfo.collider.GetComponentInChildren<MeshCollider>();
                    if (mesh != null && mesh.sharedMesh.name.Contains("rock_"))
                    {
                        sourcePos.y = hitinfo.point.y;
                        done = True;
                    }
                }
            }
#if DEBUG
            Puts("GetGround(): Looking for cave or rock");
#endif
            //if (!_config.Home.AllowCave && Physics.SphereCast(sourcePos, .1f, up, out hitinfo, 250, groundLayer) && hitinfo.collider.name.Contains("rock_"))
            if (!config.Home.AllowCave && Physics.Raycast(sourcePos, Up, out hitinfo, 250f, groundLayer) && hitinfo.collider.name.Contains("rock_"))
            {
#if DEBUG
                Puts("GetGround():   found cave or rock");
#endif
                sourcePos.y = newPos.y - 10;
                done = True;
            }
            return done ? sourcePos : newPos;
        }

        private bool GetLift(Vector3 position)
        {
            List<ProceduralLift> nearObjectsOfType = new List<ProceduralLift>();
            Vis.Entities<ProceduralLift>(position, 0.5f, nearObjectsOfType);
            if (nearObjectsOfType.Count > 0)
            {
                return True;
            }
            return False;
        }

        private Vector3 GetGroundBuilding(Vector3 sourcePos)
        {
            sourcePos.y = TerrainMeta.HeightMap.GetHeight(sourcePos);
            RaycastHit hitinfo;
            if (Physics.Raycast(sourcePos, Down, out hitinfo, buildingLayer))
            {
                sourcePos.y = Mathf.Max(hitinfo.point.y, sourcePos.y);
                return sourcePos;
            }
            if (Physics.Raycast(sourcePos, Up, out hitinfo, buildingLayer))
                sourcePos.y = Mathf.Max(hitinfo.point.y, sourcePos.y);
            return sourcePos;
        }

        private bool UnderneathFoundation(Vector3 position)
        {
            // Check for foundation half-height above where home was set
            foreach (var hit in Physics.RaycastAll(position, Up, 2f, buildingLayer))
            {
                if (hit.GetCollider().name.Contains("foundation"))
                {
                    return True;
                }
            }
            // Check for foundation full-height above where home was set
            // Since you can't see from inside via ray, start above.
            foreach (var hit in Physics.RaycastAll(position + Up + Up + Up + Up, Down, 2f, buildingLayer))
            {
                if (hit.GetCollider().name.Contains("foundation"))
                {
                    return True;
                }
            }

            return False;
        }

        private bool IsAllowed(BasePlayer player, string perm = null)
        {
            var playerAuthLevel = player.net?.connection?.authLevel;

            int requiredAuthLevel = 3;
            if (config.Admin.UseableByModerators)
            {
                requiredAuthLevel = 1;
            }
            else if (config.Admin.UseableByAdmins)
            {
                requiredAuthLevel = 2;
            }
            if (playerAuthLevel >= requiredAuthLevel) return True;

            return !string.IsNullOrEmpty(perm) && permission.UserHasPermission(player.UserIDString, perm);
        }

        private bool IsAllowedMsg(BasePlayer player, string perm = null)
        {
            if (IsAllowed(player, perm)) return True;
            PrintMsg(player, "NotAllowed");
            return False;
        }

        private int GetHigher(BasePlayer player, Dictionary<string, int> limits, int limit, bool unlimited)
        {
            if (unlimited && limit == 0) return limit;

            foreach (var l in limits)
            {
                if (permission.UserHasPermission(player.UserIDString, l.Key))
                {
                    if (unlimited && l.Value == 0) return l.Value;

                    limit = Math.Max(l.Value, limit);
                }
            }
            return limit;
        }

        private int GetLower(BasePlayer player, Dictionary<string, int> times, int time)
        {
            foreach (var l in times)
            {
                if (permission.UserHasPermission(player.UserIDString, l.Key))
                {
                    time = Math.Min(l.Value, time);
                }
            }
            return time;
        }

        private void CheckPerms(Dictionary<string, int> limits)
        {
            foreach (var limit in limits)
            {
                if (!permission.PermissionExists(limit.Key))
                {
                    permission.RegisterPermission(limit.Key, this);
                }
            }
        }
        #endregion

        #region Message
        private string _(string msgId, BasePlayer player, params object[] args)
        {
            var msg = lang.GetMessage(msgId, this, player?.UserIDString);
            return args.Length > 0 ? string.Format(msg, args) : msg;
        }

        private void PrintMsgL(BasePlayer player, string msgId, params object[] args)
        {
            if (player == null) return;
            PrintMsg(player, _(msgId, player, args));
        }

        private void PrintMsg(BasePlayer player, string msg)
        {
            if (player == null) return;
            //SendReply(player, $"{config.Settings.ChatName}{msg}");
            Player.Message(player, $"{config.Settings.ChatName}{msg}", config.Settings.ChatID);
        }
        #endregion

        #region DrawBox
        private static void DrawBox(BasePlayer player, Vector3 center, Quaternion rotation, Vector3 size)
        {
            size = size / 2;
            var point1 = RotatePointAroundPivot(new Vector3(center.x + size.x, center.y + size.y, center.z + size.z), center, rotation);
            var point2 = RotatePointAroundPivot(new Vector3(center.x + size.x, center.y - size.y, center.z + size.z), center, rotation);
            var point3 = RotatePointAroundPivot(new Vector3(center.x + size.x, center.y + size.y, center.z - size.z), center, rotation);
            var point4 = RotatePointAroundPivot(new Vector3(center.x + size.x, center.y - size.y, center.z - size.z), center, rotation);
            var point5 = RotatePointAroundPivot(new Vector3(center.x - size.x, center.y + size.y, center.z + size.z), center, rotation);
            var point6 = RotatePointAroundPivot(new Vector3(center.x - size.x, center.y - size.y, center.z + size.z), center, rotation);
            var point7 = RotatePointAroundPivot(new Vector3(center.x - size.x, center.y + size.y, center.z - size.z), center, rotation);
            var point8 = RotatePointAroundPivot(new Vector3(center.x - size.x, center.y - size.y, center.z - size.z), center, rotation);

            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point1, point2);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point1, point3);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point1, point5);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point4, point2);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point4, point3);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point4, point8);

            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point5, point6);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point5, point7);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point6, point2);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point8, point6);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point8, point7);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point7, point3);
        }

        private static Vector3 RotatePointAroundPivot(Vector3 point, Vector3 pivot, Quaternion rotation)
        {
            return rotation * (point - pivot) + pivot;
        }
        #endregion

        #region FindPlayer
        private ulong FindPlayersSingleId(string nameOrIdOrIp, BasePlayer player)
        {
            var targets = FindPlayers(nameOrIdOrIp, true);
            if (targets.Count > 1)
            {
                PrintMsgL(player, "MultiplePlayers", string.Join(", ", targets.Select(p => p.displayName).ToArray()));
                return 0;
            }
            ulong userId;
            if (targets.Count <= 0)
            {
                if (ulong.TryParse(nameOrIdOrIp, out userId)) return userId;
                PrintMsgL(player, "PlayerNotFound");
                return 0;
            }
            else
                userId = targets.First().userID;

            return userId;
        }

        private BasePlayer FindPlayersSingle(string[] args, BasePlayer player)
        {
            if (args.Length == 0) return null;
            string nameOrIdOrIp = args[0];
            var targets = FindPlayers(nameOrIdOrIp, true);
            if (targets.Count <= 0)
            {
                PrintMsgL(player, "PlayerNotFound");
                return null;
            }
            if (targets.Count > 1)
            {
                int index;
                foreach (var arg in args)
                {
                    if (int.TryParse(arg.Replace("#", string.Empty), out index) && targets.Count < --index && index > -1)
                    {
                        return targets[index];
                    }
                }
                PrintMsgL(player, "MultiplePlayers", string.Join(", ", targets.Select(p => p.displayName).ToArray()));

                return null;
            }

            return targets.First();
        }

        private static List<BasePlayer> FindPlayers(string nameOrIdOrIp, bool all = false)
        {
            var players = new List<BasePlayer>();

            if (string.IsNullOrEmpty(nameOrIdOrIp))
            {
                return players;
            }

            foreach (var p in all ? BasePlayer.allPlayerList : BasePlayer.activePlayerList)
            {
                if (p == null || string.IsNullOrEmpty(p.displayName) || players.Contains(p))
                {
                    continue;
                }

                if (p.UserIDString == nameOrIdOrIp || p.displayName.Contains(nameOrIdOrIp, CompareOptions.OrdinalIgnoreCase) || (p.IsConnected && p.net.connection.ipaddress.StartsWith(nameOrIdOrIp)))
                {
                    players.Add(p);
                }
            }

            return players;
        }
        #endregion

        #region API
        private Dictionary<string, Vector3> GetHomes(object playerObj)
        {
            if (playerObj == null) return null;
            if (playerObj is string) playerObj = Convert.ToUInt64(playerObj);
            if (!(playerObj is ulong)) throw new ArgumentException("playerObj");
            var playerId = (ulong)playerObj;
            HomeData homeData;
            if (!Home.TryGetValue(playerId, out homeData) || homeData.Locations.Count == 0) return null;
            return homeData.Locations;
        }

        private int GetLimitRemaining(BasePlayer player, string type)
        {
            if (player == null || string.IsNullOrEmpty(type)) return 0;
            var currentDate = DateTime.Now.ToString("d");
            int limit;
            var remaining = -1;
            switch (type.ToLower())
            {
                case "home":
                    limit = GetHigher(player, config.Home.VIPDailyLimits, config.Home.DailyLimit, true);
                    HomeData homeData;
                    if (!Home.TryGetValue(player.userID, out homeData))
                    {
                        Home[player.userID] = homeData = new HomeData();
                    }
                    if (homeData.Teleports.Date != currentDate)
                    {
                        homeData.Teleports.Amount = 0;
                        homeData.Teleports.Date = currentDate;
                    }
                    if (limit > 0)
                    {
                        remaining = limit - homeData.Teleports.Amount;
                    }
                    break;
                case "town":
                    limit = GetHigher(player, config.Town.VIPDailyLimits, config.Town.DailyLimit, true);
                    TeleportData townData;
                    if (!Town.TryGetValue(player.userID, out townData))
                    {
                        Town[player.userID] = townData = new TeleportData();
                    }
                    if (townData.Date != currentDate)
                    {
                        townData.Amount = 0;
                        townData.Date = currentDate;
                    }
                    if (limit > 0)
                    {
                        remaining = limit - townData.Amount;
                    }
                    break;
                case "outpost":
                    limit = GetHigher(player, config.Outpost.VIPDailyLimits, config.Outpost.DailyLimit, true);
                    TeleportData outpostData;
                    if (!Outpost.TryGetValue(player.userID, out outpostData))
                    {
                        Outpost[player.userID] = outpostData = new TeleportData();
                    }
                    if (outpostData.Date != currentDate)
                    {
                        outpostData.Amount = 0;
                        outpostData.Date = currentDate;
                    }
                    if (limit > 0)
                    {
                        remaining = limit - outpostData.Amount;
                    }
                    break;
                case "bandit":
                    limit = GetHigher(player, config.Bandit.VIPDailyLimits, config.Bandit.DailyLimit, true);
                    TeleportData banditData;
                    if (!Bandit.TryGetValue(player.userID, out banditData))
                    {
                        Bandit[player.userID] = banditData = new TeleportData();
                    }
                    if (banditData.Date != currentDate)
                    {
                        banditData.Amount = 0;
                        banditData.Date = currentDate;
                    }
                    if (limit > 0)
                    {
                        remaining = limit - banditData.Amount;
                    }
                    break;
                case "tpr":
                    limit = GetHigher(player, config.TPR.VIPDailyLimits, config.TPR.DailyLimit, true);
                    TeleportData tprData;
                    if (!TPR.TryGetValue(player.userID, out tprData))
                    {
                        TPR[player.userID] = tprData = new TeleportData();
                    }
                    if (tprData.Date != currentDate)
                    {
                        tprData.Amount = 0;
                        tprData.Date = currentDate;
                    }
                    if (limit > 0)
                    {
                        remaining = limit - tprData.Amount;
                    }
                    break;
            }
            return remaining;
        }

        private int GetCooldownRemaining(BasePlayer player, string type)
        {
            if (player == null || string.IsNullOrEmpty(type)) return 0;
            var currentDate = DateTime.Now.ToString("d");
            var timestamp = Facepunch.Math.Epoch.Current;
            int cooldown;
            var remaining = -1;
            switch (type.ToLower())
            {
                case "home":
                    cooldown = GetLower(player, config.Home.VIPCooldowns, config.Home.Cooldown);
                    HomeData homeData;
                    if (!Home.TryGetValue(player.userID, out homeData))
                    {
                       