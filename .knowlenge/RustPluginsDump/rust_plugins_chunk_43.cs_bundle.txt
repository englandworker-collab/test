 Home[player.userID] = homeData = new HomeData();
                    }
                    if (homeData.Teleports.Date != currentDate)
                    {
                        homeData.Teleports.Amount = 0;
                        homeData.Teleports.Date = currentDate;
                    }
                    if (cooldown > 0 && timestamp - homeData.Teleports.Timestamp < cooldown)
                    {
                        remaining = cooldown - (timestamp - homeData.Teleports.Timestamp);
                    }
                    break;
                case "town":
                    cooldown = GetLower(player, config.Town.VIPCooldowns, config.Town.Cooldown);
                    TeleportData townData;
                    if (!Town.TryGetValue(player.userID, out townData))
                    {
                        Town[player.userID] = townData = new TeleportData();
                    }
                    if (townData.Date != currentDate)
                    {
                        townData.Amount = 0;
                        townData.Date = currentDate;
                    }
                    if (cooldown > 0 && timestamp - townData.Timestamp < cooldown)
                    {
                        remaining = cooldown - (timestamp - townData.Timestamp);
                    }
                    break;
                case "outpost":
                    cooldown = GetLower(player, config.Outpost.VIPCooldowns, config.Outpost.Cooldown);
                    TeleportData outpostData;
                    if (!Outpost.TryGetValue(player.userID, out outpostData))
                    {
                        Outpost[player.userID] = outpostData = new TeleportData();
                    }
                    if (outpostData.Date != currentDate)
                    {
                        outpostData.Amount = 0;
                        outpostData.Date = currentDate;
                    }
                    if (cooldown > 0 && timestamp - outpostData.Timestamp < cooldown)
                    {
                        remaining = cooldown - (timestamp - outpostData.Timestamp);
                    }
                    break;
                case "bandit":
                    cooldown = GetLower(player, config.Bandit.VIPCooldowns, config.Bandit.Cooldown);
                    TeleportData banditData;
                    if (!Bandit.TryGetValue(player.userID, out banditData))
                    {
                        Bandit[player.userID] = banditData = new TeleportData();
                    }
                    if (banditData.Date != currentDate)
                    {
                        banditData.Amount = 0;
                        banditData.Date = currentDate;
                    }
                    if (cooldown > 0 && timestamp - banditData.Timestamp < cooldown)
                    {
                        remaining = cooldown - (timestamp - banditData.Timestamp);
                    }
                    break;
                case "tpr":
                    cooldown = GetLower(player, config.TPR.VIPCooldowns, config.TPR.Cooldown);
                    TeleportData tprData;
                    if (!TPR.TryGetValue(player.userID, out tprData))
                    {
                        TPR[player.userID] = tprData = new TeleportData();
                    }
                    if (tprData.Date != currentDate)
                    {
                        tprData.Amount = 0;
                        tprData.Date = currentDate;
                    }
                    if (cooldown > 0 && timestamp - tprData.Timestamp < cooldown)
                    {
                        remaining = cooldown - (timestamp - tprData.Timestamp);
                    }
                    break;
            }
            return remaining;
        }
        #endregion

        private class UnityVector3Converter : JsonConverter
        {
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                var vector = (Vector3)value;
                writer.WriteValue($"{vector.x} {vector.y} {vector.z}");
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                if (reader.TokenType == JsonToken.String)
                {
                    var values = reader.Value.ToString().Trim().Split(' ');
                    return new Vector3(Convert.ToSingle(values[0]), Convert.ToSingle(values[1]), Convert.ToSingle(values[2]));
                }
                var o = JObject.Load(reader);
                return new Vector3(Convert.ToSingle(o["x"]), Convert.ToSingle(o["y"]), Convert.ToSingle(o["z"]));
            }

            public override bool CanConvert(Type objectType)
            {
                return objectType == typeof(Vector3);
            }
        }

        private class CustomComparerDictionaryCreationConverter<T> : CustomCreationConverter<IDictionary>
        {
            private readonly IEqualityComparer<T> comparer;

            public CustomComparerDictionaryCreationConverter(IEqualityComparer<T> comparer)
            {
                if (comparer == null)
                    throw new ArgumentNullException(nameof(comparer));
                this.comparer = comparer;
            }

            public override bool CanConvert(Type objectType)
            {
                return HasCompatibleInterface(objectType) && HasCompatibleConstructor(objectType);
            }

            private static bool HasCompatibleInterface(Type objectType)
            {
                return objectType.GetInterfaces().Where(i => HasGenericTypeDefinition(i, typeof(IDictionary<,>))).Any(i => typeof(T).IsAssignableFrom(i.GetGenericArguments().First()));
            }

            private static bool HasGenericTypeDefinition(Type objectType, Type typeDefinition)
            {
                return objectType.GetTypeInfo().IsGenericType && objectType.GetGenericTypeDefinition() == typeDefinition;
            }

            private static bool HasCompatibleConstructor(Type objectType)
            {
                return objectType.GetConstructor(new[] { typeof(IEqualityComparer<T>) }) != null;
            }

            public override IDictionary Create(Type objectType)
            {
                return Activator.CreateInstance(objectType, comparer) as IDictionary;
            }
        }

        [HookMethod("SendHelpText")]
        private void SendHelpText(BasePlayer player)
        {
            PrintMsgL(player, "<size=14>NTeleportation</size> by <color=#ce422b>Nogrod</color>\n<color=#ffd479>/sethome NAME</color> - Set home on current foundation\n<color=#ffd479>/home NAME</color> - Go to one of your homes\n<color=#ffd479>/home list</color> - List your homes\n<color=#ffd479>/town</color> - Go to town, if set\n/tpb - Go back to previous location\n/tpr PLAYER - Request teleport to PLAYER\n/tpa - Accept teleport request");
        }

        private bool API_HavePendingRequest(BasePlayer player)
        {
            return PendingRequests.ContainsKey(player.userID) || PlayersRequests.ContainsKey(player.userID) || TeleportTimers.ContainsKey(player.userID);
        }

        private bool API_HaveAvailableHomes(BasePlayer player)
        {
            HomeData homeData;
            if (!Home.TryGetValue(player.userID, out homeData))
            {
                Home[player.userID] = homeData = new HomeData();
            }

            var limit = GetHigher(player, config.Home.VIPHomesLimits, config.Home.HomesLimit, true);

            if (limit == 0) return True;

            return homeData.Locations.Count < limit;
        }

        private List<string> API_GetHomes(BasePlayer player)
        {
            HomeData homeData;
            if (!Home.TryGetValue(player.userID, out homeData))
            {
                Home[player.userID] = homeData = new HomeData();
            }

            return homeData.Locations.Keys.ToList();
        }
    }
}

// --- End of file: NTeleportation.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/Backpack.cs ---
// --- Original Local Path: KualaRust/Backpack.cs ---

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Physics = UnityEngine.Physics;
using System.IO;
namespace Oxide.Plugins
{
    [Info("Backpack", "OxideBro", "1.4.6")]
    public class Backpack : RustPlugin
    {
        static Backpack ins;
        object OnEntityGroundMissing(BaseEntity entity)
        {
            var container = entity as StorageContainer;
            if (container != null)
            {
                var opened = openedBackpacks.Values.Select(x => x.storage);
                if (opened.Contains(container)) return false;
            }
            return null;
        }


        public class BackpackBox : MonoBehaviour
        {
            public StorageContainer storage;
            BasePlayer owner;
            public void Init(StorageContainer storage, BasePlayer owner)
            {
                this.storage = storage;
                this.owner = owner;
            }
            public static BackpackBox Spawn(BasePlayer player, ulong ownerid, int size = 1)
            {
                player.EndLooting();
                var storage = SpawnContainer(player, size, false, ownerid);
                var box = storage.gameObject.AddComponent<BackpackBox>();
                box.Init(storage, player);
                return box;
            }
            static int rayColl = LayerMask.GetMask("Construction", "Deployed", "Tree", "Terrain", "Resource", "World", "Water", "Default", "Prevent Building");
            public static StorageContainer SpawnContainer(BasePlayer player, int size, bool die, ulong ownerid)
            {
                var pos = player.transform.position;
                if (die)
                {
                    RaycastHit hit;
                    if (Physics.Raycast(new Ray(player.GetCenter(), Vector3.down), out hit, 1000, rayColl, QueryTriggerInteraction.Ignore))
                    {
                        pos = hit.point;
                    }
                }
                else
                {
                    pos -= new Vector3(0, 100, 0);
                }
                return SpawnContainer(player, size, pos, ownerid);
            }

            private static StorageContainer SpawnContainer(BasePlayer player, int size, Vector3 position, ulong ownerid, ulong playerid = 533504)
            {
                var storage = GameManager.server.CreateEntity("assets/prefabs/deployable/large wood storage/box.wooden.large.prefab") as StorageContainer;
                if (storage == null) return null;
                storage.transform.position = position;
                storage.panelName = "genericlarge";
                ItemContainer container = new ItemContainer();
                container.ServerInitialize(null, !ownerid.IsSteamId() ? ins.GetBackpackSize(player.UserIDString) : ins.GetBackpackSize(ownerid.ToString()));
                if ((int)container.uid == 0) container.GiveUID();
                storage.inventory = container;
                if (!storage) return null;
                storage.SendMessage("SetDeployedBy", player, (SendMessageOptions)1);
                storage.OwnerID = player.userID;
                storage.Spawn();
                return storage;
            }

            private void PlayerStoppedLooting(BasePlayer player)
            {
                Interface.Oxide.RootPluginManager.GetPlugin("Backpack").Call("BackpackHide", player.userID);
            }
            public void Close()
            {
                ClearItems();
                storage.Kill();
            }
            public void StartLoot()
            {
                storage.SetFlag(BaseEntity.Flags.Open, true, false);
                owner.inventory.loot.StartLootingEntity(storage, false);
                owner.inventory.loot.AddContainer(storage.inventory);
                owner.inventory.loot.SendImmediate();
                owner.ClientRPCPlayer(null, owner, "RPC_OpenLootPanel", storage.panelName);
                storage.DecayTouch();
                storage.SendNetworkUpdate();
            }
            public void Push(List<Item> items)
            {
                for (int i = items.Count - 1;
                i >= 0;
                i--) items[i].MoveToContainer(storage.inventory);
            }
            public void ClearItems()
            {
                storage.inventory.itemList.Clear();
            }
            public List<Item> GetItems => storage.inventory.itemList.Where(i => i != null).ToList();
        }
        public Dictionary<ulong, BackpackBox> openedBackpacks = new Dictionary<ulong, BackpackBox>();
        public Dictionary<ulong, List<SavedItem>> savedBackpacks;
        public Dictionary<ulong, BaseEntity> visualBackpacks = new Dictionary<ulong, BaseEntity>();
        public Color GetBPColor(int count, int max)
        {
            float n = max > 0 ? (float)clrs.Length / max : 0;
            var index = (int)(count * n);
            if (index > 0) index--;
            return hexToColor(clrs[index]);
        }
        public static Color hexToColor(string hex)
        {
            hex = hex.Replace("0x", "");
            hex = hex.Replace("#", "");
            byte a = 160;
            byte r = byte.Parse(hex.Substring(0, 2), System.Globalization.NumberStyles.HexNumber);
            byte g = byte.Parse(hex.Substring(2, 2), System.Globalization.NumberStyles.HexNumber);
            byte b = byte.Parse(hex.Substring(4, 2), System.Globalization.NumberStyles.HexNumber);
            if (hex.Length == 8)
            {
                a = byte.Parse(hex.Substring(6, 2), System.Globalization.NumberStyles.HexNumber);
            }
            return new Color32(r, g, b, a);
        }
        private string[] clrs = {
            "#ffffff", "#fffbf5", "#fff8ea", "#fff4e0", "#fff0d5", "#ffedcb", "#ffe9c1", "#ffe5b6", "#ffe2ac", "#ffdea1", "#ffda97", "#ffd78d", "#ffd382", "#ffcf78", "#ffcc6d", "#ffc863", "#ffc458", "#ffc14e", "#ffbd44", "#ffb939", "#ffb62f", "#ffb224", "#ffae1a", "#ffab10", "#ffa705", "#ffa200", "#ff9b00", "#ff9400", "#ff8d00", "#ff8700", "#ff8000", "#ff7900", "#ff7200", "#ff6c00", "#ff6500", "#ff5e00", "#ff5800", "#ff5100", "#ff4a00", "#ff4300", "#ff3d00", "#ff3600", "#ff2f00", "#ff2800", "#ff2200", "#ff1b00", "#ff1400", "#ff0d00", "#ff0700", "#ff0000"
        }
        ;
        DynamicConfigFile backpacksFile = Interface.Oxide.DataFileSystem.GetFile("Backpack_Data");
        void LoadBackpacks()
        {
            try
            {
                savedBackpacks = backpacksFile.ReadObject<Dictionary<ulong, List<SavedItem>>>();
            }
            catch (Exception)
            {
                savedBackpacks = new Dictionary<ulong, List<SavedItem>>();
            }
        }
        void OnServerSave()
        {
            SaveBackpacks();
        }
        void SaveBackpacks() => backpacksFile.WriteObject(savedBackpacks);
        object CanMoveItem(Item item, PlayerInventory playerLoot, uint targetContainer, int targetSlot, int amount)
        {
            if (item == null || playerLoot == null) return null;
            var player = playerLoot.GetComponent<BasePlayer>();
            if (player == null) return null;
            if (openedBackpacks.ContainsKey(player.userID))
            {
                var target = playerLoot.FindContainer(targetContainer)?.GetSlot(targetSlot);
                if (target != null && targetContainer != item.GetRootContainer().uid)
                {
                    if (!PermissionService.HasPermission(player.UserIDString, BPIgnoreBlackListed)) if (BlackListed.Contains(target.info.shortname))
                        {
                            SendReply(player, $"<color=#AF5085>[Backpack]:</color> Извините но данный предмет <color=#AF5085>{target.info.displayName.english}</color> находиться в <color=RED>черном списке</color>. Его нельзя перенести в рюкзак.\nРазблокировка доступна для VIP игроков");
                            return false;
                        }
                }
                if (openedBackpacks[player.userID].storage.inventory.uid == targetContainer)
                {
                    if (!PermissionService.HasPermission(player.UserIDString, BPIgnoreBlackListed)) if (BlackListed.Contains(item.info.shortname))
                        {
                            SendReply(player, $"<color=#AF5085>[Backpack]:</color> Извините но данный предмет <color=#AF5085>{item.info.displayName.english}</color> находиться в <color=RED>черном списке</color>. Его нельзя перенести в рюкзак.\nРазблокировка доступна для VIP игроков");
                            return false;
                        }
                }
                if (DisabledMoveOtherBackpack && openedBackpacks[player.userID].storage.OwnerID != player.userID && openedBackpacks[player.userID].storage.inventory.uid == targetContainer)
                {
                    SendReply(player, $"<color=#AF5085>[Backpack]:</color> Запрещено переносить предметы в чужой рюкзак");
                    return false;
                }
            }
            return null;
        }
        bool IsBackpackContainer(uint uid, ulong userId) => openedBackpacks.ContainsKey(userId) ? true : false;
        void OnEntityDeath(BaseCombatEntity ent, HitInfo info)
        {
            if (!(ent is BasePlayer)) return;
            var player = (BasePlayer)ent;
            if (InDuel(player) || InEvent(player)) return;
            BackpackHide(player.userID);
            if (PermissionService.HasPermission(player.UserIDString, BPIGNORE)) return;
            List<SavedItem> savedItems;
            List<Item> items = new List<Item>();
            if (savedBackpacks.TryGetValue(player.userID, out savedItems))
            {
                items = RestoreItems(savedItems);
                savedBackpacks.Remove(player.userID);
            }
            if (items.Count <= 0) return;
            if (DropWithoutBackpack)
            {
                foreach (var item in items)
                {
                    item.Drop(player.transform.position + Vector3.up, Vector3.up);
                }
                return;
            }
            var iContainer = new ItemContainer();
            iContainer.ServerInitialize(null, items.Count);
            iContainer.GiveUID();
            iContainer.entityOwner = player;
            iContainer.SetFlag(ItemContainer.Flag.NoItemInput, true);
            for (int i = items.Count - 1;
            i >= 0;
            i--) items[i].MoveToContainer(iContainer);
            DroppedItemContainer droppedItemContainer = ItemContainer.Drop("assets/prefabs/misc/item drop/item_drop_backpack.prefab", player.transform.position + Vector3.up, Quaternion.identity, iContainer);
            if (droppedItemContainer != null)
            {
                droppedItemContainer.playerName = $"Рюкзак игрока <color=#FF8080>{player.displayName}</color>";
                droppedItemContainer.playerSteamID = player.userID;
                timer.Once(KillTimeout, () =>
                {
                    if (droppedItemContainer != null && !droppedItemContainer.IsDestroyed) droppedItemContainer.Kill();
                }
                );
                Effect.server.Run("assets/bundled/prefabs/fx/dig_effect.prefab", droppedItemContainer.transform.position);
            }
        }
        string BPIGNORE = "backpack.ignore";
        string BPIgnoreBlackListed = "backpack.blignore";
        string BPPrivilageMainLoot = "backpack.otherloot";
        bool DropWithoutBackpack = false;
        bool EnabledMainBackpackLoot = true;
        float KillTimeout = 300f;
        string ImageURL = "https://i.imgur.com/afIPQeW.png";
        static Dictionary<string, int> permisions = new Dictionary<string, int>();
        List<string> BlackListed = new List<string>();
        private string TextInButton = "<b>ОТКРЫТЬ</b>";
        private bool SizeEnabled = true;
        private bool AutoWipe = false;
        private bool DisabledMoveOtherBackpack = true;
        private bool EnabledUI = true;
        private bool DisabledOpenBPInFly = true;
        private int Type = 1;
        private void LoadConfigValues()
        {
            bool changed = false;
            if (GetConfig("Основные настройки", "При смерти игрока выкидывать вещи без рюкзака", ref DropWithoutBackpack))
            {
                changed = true;
            }
            if (GetConfig("Основные настройки", "Время удаления рюкзака после выпадения", ref KillTimeout))
            {
                changed = true;
            }
            if (GetConfig("Основные настройки", "Привилегия игнорирования выпадение рюкзака", ref BPIGNORE))
            {
                changed = true;
            }
            if (GetConfig("Основные настройки", "Привилегия игнорирования чёрного списка", ref BPIgnoreBlackListed))
            {
                changed = true;
            }
            if (GetConfig("Основные настройки", "Запретить открывать рюкзак в полёте", ref DisabledOpenBPInFly))
            {
                PrintWarning("Конфигурация обновлена! Добавлен пункт: Запретить открывать рюкзак в полёте");
                changed = true;
            }
            if (GetConfig("Основные настройки", "ССылка на изображение иконки UI", ref ImageURL))
            {
                PrintWarning("Конфигурация обновлена! Добавлен пункт: Ссылка на изображение иконки UI");
                changed = true;
            }
            if (GetConfig("Основные настройки", "Текст в кнопке UI (Если не хотите надпись, оставте поле пустым)", ref TextInButton))
            {
                PrintWarning("Конфигурация обновлена! Добавлен пункт: Текст в кнопке UI");
                changed = true;
            }
            if (GetConfig("Основные настройки", "Включить отображение размера рюкзака в UI", ref SizeEnabled))
            {
                PrintWarning("Конфигурация обновлена! Добавлен пункт: Включить отображение размера рюкзака в UI");
                changed = true;
            }
            if (GetConfig("Основные настройки", "Включить отображение UI рюкзака", ref EnabledUI))
            {
                PrintWarning("Конфигурация обновлена! Добавлен пункт: Включить отображение UI рюкзака");
                changed = true;
            }
            if (GetConfig("Основные настройки", "Включить автоматическую очистку рюкзаков при вайпе карты", ref AutoWipe))
            {
                PrintWarning("Конфигурация обновлена! Добавлен пункт: Включить автоматическую очистку рюкзаков при вайпе карты");
                changed = true;
            }
            if (GetConfig("Основные настройки", "Разрешить лутание чужих рюкзаков по привилегии указаной в конфигурации", ref EnabledMainBackpackLoot))
            {
                PrintWarning("Конфигурация обновлена! Добавлен пункт: Разрешить лутание чужих рюкзаков по привилегии указаной в конфигурации");
                changed = true;
            }
            if (GetConfig("Основные настройки", "Привилегия на разрешение лутания чужих рюкзаков", ref BPPrivilageMainLoot))
            {
                PrintWarning("Конфигурация обновлена! Добавлен пункт: Привилегия на разрешение лутания чужих рюкзаков");
                changed = true;
            }
            if (GetConfig("Основные настройки", "Запретить переносить свои предметы в чужой рюкзак (если включена функция лутания чужих рюкзаков)", ref DisabledMoveOtherBackpack))
            {
                PrintWarning("Конфигурация обновлена! Добавлен пункт: Запретить переносить свои предметы в чужой рюкзак (если включена функция лутания чужих рюкзаков)");
                changed = true;
            }
            if (GetConfig("Основные настройки", "Разрешить лутание чужих рюкзаков по привилегии указаной в конфигурации", ref EnabledMainBackpackLoot))
            {
                PrintWarning("Конфигурация обновлена! Добавлен пункт: Разрешить лутание чужих рюкзаков по привилегии указаной в конфигурации");
                changed = true;
            }
            if (GetConfig("Основные настройки", "Какой вид заполнения использовать в UI (Примеры есть в описании плагина на сайте RustPlugin.ru)", ref Type))
            {
                PrintWarning("Конфигурация обновлена! Добавлен пункт: Какой вид заполнения использовать в UI (Примеры есть в описании плагина на сайте RustPlugin.ru)");
                changed = true;
            }
            var _permisions = new Dictionary<string, object>() {
                    {
                    "backpack.size1", 1
                }
                , {
                    "backpack.size6", 6
                }
                , {
                    "backpack.size15", 15
                }
                , {
                    "backpack.size30", 30
                }
                , {
                    "backpack.size40", 40
                }
                ,
            }
            ;
            if (GetConfig("Основные настройки", "Список привилегий и размера рюкзака (Привилегия (формат: backpack.): Размер слотов)", ref _permisions))
            {
                PrintWarning("Новые привилегии загружены.");
                changed = true;
            }
            permisions = _permisions.ToDictionary(p => p.Key.ToString(), p => Convert.ToInt32(p.Value));
            var _BlackListed = new List<object>() {
                    {
                    "ammo.rocket.basic"
                }
                , {
                    "ammo.rifle.explosive"
                }
            }
            ;
            if (GetConfig("Основные настройки", "Список запрещенных вещей какие нельзя носить в рюкзаке", ref _BlackListed))
            {
                PrintWarning("Чёрный список предметов обновлен и загружен!");
                changed = true;
            }
            BlackListed = _BlackListed.Select(p => p.ToString()).ToList();
            if (changed) SaveConfig();
        }
        private bool GetConfig<T>(string MainMenu, string Key, ref T var)
        {
            if (Config[MainMenu, Key] != null)
            {
                var = (T)Convert.ChangeType(Config[MainMenu, Key], typeof(T));
                return false;
            }
            Config[MainMenu, Key] = var;
            return true;
        }
        void OnNewSave()
        {
            if (AutoWipe)
            {
                LoadBackpacks();
                savedBackpacks = new Dictionary<ulong, List<SavedItem>>();
                SaveBackpacks();
                PrintWarning("Wipe detected! Player backpacks clear!");
            }
        }
        void Loaded()
        {
            ins = this;
            LoadBackpacks();
        }
        private bool loaded = false;
        void OnServerInitialized()
        {
            LoadConfig();
            LoadConfigValues();
            InitFileManager();
            ServerMgr.Instance.StartCoroutine(m_FileManager.LoadFile("backpackImage", ImageURL));
            PermissionService.RegisterPermissions(this, permisions.Keys.ToList());
            PermissionService.RegisterPermissions(this, new List<string>() {
                BPIGNORE, BPIgnoreBlackListed, BPPrivilageMainLoot
            }
            );
            BasePlayer.activePlayerList.ToList().ForEach(OnPLayerConnection);
        }
        void OnPLayerConnection(BasePlayer player)
        {
            if (!EnabledUI) return;
            DrawUI(player);
        }
        void Unload()
        {
            var keys = openedBackpacks.Keys.ToList();
            for (int i = openedBackpacks.Count - 1;
            i >= 0;
            i--) BackpackHide(keys[i]);
            SaveBackpacks();
            foreach (var player in BasePlayer.activePlayerList) DestroyUI(player);
            UnityEngine.Object.Destroy(FileManagerObject);
        }
        void OnPreServerRestart()
        {
            foreach (var dt in Resources.FindObjectsOfTypeAll<StashContainer>()) dt.Kill();
            foreach (var ent in Resources.FindObjectsOfTypeAll<TimedExplosive>().Where(ent => ent.name == "backpack")) ent.KillMessage();
        }
        void OnPlayerSleepEnded(BasePlayer player)
        {
            if (player == null || !player.IsConnected) return;
            if (OpenOtherBackpack.ContainsKey(player.userID))
                OpenOtherBackpack[player.userID].EndLooting();
            if (!EnabledUI) return;
            DrawUI(player);

        }
        void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            var target = entity.GetComponent<BasePlayer>();
            if (target != null) ShowUIPlayer(player, target);
        }



        void BackpackShow(BasePlayer player, ulong target = 0)
        {
            if (InDuel(player) || InEvent(player)) return;
            if (BackpackHide(player.userID)) return;
            var canBackpack = Interface.Call("CanBackpack", player);
            if (canBackpack != null)
                return;
            var reply = 521;
            if (reply == 0) { }
            if (player.inventory.loot?.entitySource != null) player.EndLooting();
            var backpackSize = GetBackpackSize(player.UserIDString);
            if (backpackSize == 0) return;
            timer.Once(0.1f, () =>
            {
                if (DisabledOpenBPInFly && !player.IsOnGround()) return;
                List<SavedItem> savedItems;
                List<Item> items = new List<Item>();
                if (target != 0 && savedBackpacks.TryGetValue(target, out savedItems)) items = RestoreItems(savedItems);
                if (target == 0 && savedBackpacks.TryGetValue(player.userID, out savedItems)) items = RestoreItems(savedItems);
                BackpackBox box = BackpackBox.Spawn(player, target, backpackSize);
                openedBackpacks.Add(player.userID, box);
                box.storage.OwnerID = target != 0 ? target : player.userID;
                if (box.GetComponent<StorageContainer>() != null)
                {
                    box.GetComponent<StorageContainer>().OwnerID = target != 0 ? target : player.userID;
                    box.GetComponent<StorageContainer>().SendNetworkUpdate();
                }
                if (items.Count > 0) box.Push(items);
                box.StartLoot();
            }
            );
        }

        void OnPlayerLootEnd(PlayerLoot inventory)
        {
            var player = inventory.GetComponent<BasePlayer>();
            if (player != null) CuiHelper.DestroyUi(player, "backpack_playermain");
        }

        void ShowUIPlayer(BasePlayer player, BasePlayer target)
        {
            CuiHelper.DestroyUi(player, "backpack_playermain");
            if (EnabledMainBackpackLoot && !permission.UserHasPermission(player.UserIDString, BPPrivilageMainLoot)) return;
            CuiElementContainer container = new CuiElementContainer();
            container.Add(new CuiButton
            {
                RectTransform = {
                    AnchorMin="0.5 0", AnchorMax="0.5 0", OffsetMin="215 18", OffsetMax="430 60"
                }
                ,
                Button = {
                    Color="1 1 1 0.03", Command=savedBackpacks.ContainsKey(target.userID) ? $"backpack_mainopen {target.userID}": "", Material="assets/content/ui/uibackgroundblur-ingamemenu.mat"
                }
                ,
                Text = {
                    Text="", Align=TextAnchor.MiddleCenter, Font="robotocondensed-regular.ttf", FontSize=24
                }
                ,
            }
            , "Overlay", "backpack_playermain");
            container.Add(new CuiElement
            {
                Parent = "backpack_playermain",
                Components = {
                    new CuiRawImageComponent {
                        Png=m_FileManager.GetPng("backpackImage"), Color="0.91 0.87 0.84 1.00"
                    }
                    , new CuiRectTransformComponent {
                        AnchorMin="0.005 0.1", AnchorMax="0.18 0.9"
                    }
                    ,
                }
                ,
            }
            );
            container.Add(new CuiElement
            {
                Parent = "backpack_playermain",
                Components = {
                    new CuiTextComponent {
                        Color=savedBackpacks.ContainsKey(target.userID) ? "0.91 0.87 0.84 1.00": "1.00 0.37 0.38 1.00", Text=savedBackpacks.ContainsKey(target.userID) ? $"ОТКРЫТЬ РЮКЗАК ИГРОКА": "РЮКЗАК ИГРОКА ПУСТ", FontSize=14, Align=TextAnchor.MiddleCenter,
                    }
                    , new CuiRectTransformComponent {
                        AnchorMin=$"0.14 0", AnchorMax=$"1 1"
                    }
                    ,
                }
                ,
            }
            );
            CuiHelper.AddUi(player, container);
        }

        public Dictionary<ulong, BasePlayer> OpenOtherBackpack = new Dictionary<ulong, BasePlayer>();

        [ConsoleCommand("backpack_mainopen")]
        private void ConsoleOpenMainBackpack(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            ulong targetID = ulong.Parse(args.Args[0]);
            if (EnabledMainBackpackLoot && !permission.UserHasPermission(player.UserIDString, BPPrivilageMainLoot)) return;

            if (OpenOtherBackpack.ContainsKey(targetID))
                if (OpenOtherBackpack[targetID] != player)
                {
                    SendReply(player, $"<color=#AF5085>[Backpack]:</color> Рюкзак уже кто то лутает");
                    return;
                }

            if (!OpenOtherBackpack.ContainsKey(targetID))
                OpenOtherBackpack.Add(targetID, player);
            else
                OpenOtherBackpack[targetID] = player;

            BackpackShow(player, targetID);
        }
        int GetBackpackSize(string UserID)
        {
            int size = 0;
            permisions.ToList().ForEach(p =>
            {
                if (PermissionService.HasPermission(UserID, p.Key)) if (p.Value > size) size = p.Value;
            }
            );
            return size;
        }

        [HookMethod("BackpackHide")]
        bool BackpackHide(ulong userId)
        {
            BackpackBox box;
            if (!openedBackpacks.TryGetValue(userId, out box)) return false;
            openedBackpacks.Remove(userId);
            if (box == null) return false;
            var items = SaveItems(box.GetItems);
            var owner = box.GetComponent<StorageContainer>();
            if (OpenOtherBackpack.ContainsKey(owner.OwnerID))
                OpenOtherBackpack.Remove(owner.OwnerID);
            if (items.Count > 0) savedBackpacks[owner.OwnerID] = SaveItems(box.GetItems);
            else savedBackpacks.Remove(owner.OwnerID);
            box.Close();
            var otherPlayer = BasePlayer.FindByID(owner.OwnerID);

            if (otherPlayer != null) DrawUI(otherPlayer);
            else
                DrawUI(BasePlayer.FindByID(userId));
            return true;

        }
        void OnUserPermissionGranted(string id, string permName)
        {
            if (permisions.ContainsKey(permName))
            {
                var player = BasePlayer.Find(id);
                if (player != null) DrawUI(player);
            }
        }
        void OnUserPermissionRevoked(string id, string permName)
        {
            if (permisions.ContainsKey(permName))
            {
                var player = BasePlayer.Find(id);
                if (player != null) DrawUI(player);
            }
        }
        void DrawUI(BasePlayer player)
        {
            if (!EnabledUI) return;
            if (!m_FileManager.IsFinished)
            {
                timer.Once(1f, () => DrawUI(player));
                return;
            }
            CuiHelper.DestroyUi(player, "backpack.image");
            List<SavedItem> savedItems;
            if (!savedBackpacks.TryGetValue(player.userID, out savedItems)) savedItems = new List<SavedItem>();
            var bpSize = GetBackpackSize(player.UserIDString);
            if (bpSize == 0) return;
            int backpackCount = savedItems?.Count ?? 0;
            if (backpackCount > bpSize) backpackCount = bpSize;
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                Image = {
                    Color="1 1 1 0.03", Material="assets/content/ui/uibackgroundblur-ingamemenu.mat"
                }
                ,
                RectTransform = {
                    AnchorMin="0.296 0.025", AnchorMax="0.295 0.025", OffsetMax="60 60"
                }
                ,
            }
            , "Overlay", "backpack.image");
            var AnchorType = (float)backpackCount / bpSize - 0.03f;
            string AcnhorMax = "1 1";
            string alpha = "1";
            switch (Type)
            {
                case 1:
                    AnchorType = (float)Math.Min(backpackCount, bpSize) / bpSize - 0.03f;
                    AcnhorMax = $"0.05 {AnchorType}";
                    break;
                case 2:
                    AnchorType = (float)backpackCount / bpSize - 0.03f;
                    AcnhorMax = $"1 {AnchorType}";
                    alpha = "0.5";
                    break;
                case 3:
                    AnchorType = (float)backpackCount / bpSize - 0.03f;
                    AcnhorMax = $"{AnchorType} 1";
                    alpha = "0.5";
                    break;
                default:
                    AnchorType = (float)Math.Min(backpackCount, bpSize) + bpSize - 0.03f;
                    AcnhorMax = $"0.05 {AnchorType}";
                    break;
            }
            container.Add(new CuiPanel
            {
                Image = {
                    Color=SetColor(GetBPColor(backpackCount, bpSize), alpha), Material="assets/content/ui/uibackgroundblur-ingamemenu.mat"
                }
                ,
                RectTransform = {
                    AnchorMin="0 0", AnchorMax=$"{AcnhorMax}"
                }
                ,
            }
            , "backpack.image");
            container.Add(new CuiElement
            {
                Parent = "backpack.image",
                Components = {
                    new CuiRawImageComponent {
                        Png=m_FileManager.GetPng("backpackImage"), Color="1 1 1 0.5"
                    }
                    , new CuiRectTransformComponent {
                        AnchorMin="0.1 0.25", AnchorMax="0.9 0.95"
                    }
                    ,
                }
                ,
            }
            );
            if (!string.IsNullOrEmpty(TextInButton)) container.Add(new CuiElement
            {
                Parent = "backpack.image",
                Components = {
                    new CuiTextComponent {
                        Color="1 1 1 0.5", Text=TextInButton, FontSize=11, Align=TextAnchor.MiddleCenter,
                    }
                    , new CuiRectTransformComponent {
                        AnchorMin=$"0 0", AnchorMax=$"1 0.3"
                    }
                    ,
                }
                ,
            }
            );
            if (SizeEnabled) container.Add(new CuiElement
            {
                Parent = "backpack.image",
                Components = {
                    new CuiTextComponent {
                        Color="1 1 1 0.2", Text=$"{backpackCount}/{bpSize}", FontSize=11, Align=TextAnchor.MiddleRight,
                    }
                    , new CuiRectTransformComponent {
                        AnchorMin=$"0.5 0.79", AnchorMax=$"0.997 1"
                    }
                    ,
                }
                ,
            }
            );
            container.Add(new CuiElement
            {
                Parent = "backpack.image",
                Components = {
                    new CuiButtonComponent {
                        Color="0 0 0 0", Command="backpack.open"
                    }
                    , new CuiRectTransformComponent {
                        AnchorMin="0 0", AnchorMax="1 1"
                    }
                    ,
                }
                ,
            }
            );
            CuiHelper.AddUi(player, container);
        }
        string SetColor(Color color, string alpha) => $"{color.r} {color.g} {color.b} {alpha}";
        void DestroyUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "backpack.image");
        }

        [ChatCommand("bp")]
        void cmdBackpackShow(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;
            player.EndLooting();
            NextTick(() => BackpackShow(player));
        }

        [ConsoleCommand("backpack.open")]
        void cmdOnBackPackShowClick(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            if (player.inventory.loot?.entitySource != null)
            {
                BackpackBox bpBox;
                if (openedBackpacks.TryGetValue(player.userID, out bpBox) && bpBox.gameObject == player.inventory.loot.entitySource.gameObject) return;
                player.EndLooting();
                NextTick(() => BackpackShow(player));
                return;
            }
            else BackpackShow(player);
        }
        public class SavedItem
        {
            public string shortname;
            public string name;
            public int itemid;
            public float condition;
            public float maxcondition;
            public int amount;
            public int ammoamount;
            public string ammotype;
            public int flamefuel;
            public ulong skinid;
            public bool weapon;
            public int blueprint;
            public List<SavedItem> mods;
        }
        List<SavedItem> SaveItems(List<Item> items) => items.Select(SaveItem).ToList();
        SavedItem SaveItem(Item item)
        {
            SavedItem iItem = new SavedItem
            {
                shortname = item.info?.shortname,
                name = item.name,
                amount = item.amount,
                mods = new List<SavedItem>(),
                skinid = item.skin,
                blueprint = item.blueprintTarget
            }
            ;
            if (item.info == null) return iItem;
            iItem.itemid = item.info.itemid;
            iItem.weapon = false;
            if (item.hasCondition)
            {
                iItem.condition = item.condition;
                iItem.maxcondition = item.maxCondition;
            }
            FlameThrower flameThrower = item.GetHeldEntity()?.GetComponent<FlameThrower>();
            if (flameThrower != null) iItem.flamefuel = flameThrower.ammo;
            Chainsaw chainsaw = item.GetHeldEntity()?.GetComponent<Chainsaw>();
            if (chainsaw != null) iItem.flamefuel = chainsaw.ammo;
            if (item.contents != null) foreach (var mod in item.contents.itemList) if (mod.info.itemid != 0) iItem.mods.Add(SaveItem(mod));
            if (item.info.category.ToString() != "Weapon") return iItem;
            BaseProjectile weapon = item.GetHeldEntity() as BaseProjectile;
            if (weapon == null) return iItem;
            if (weapon.primaryMagazine == null) return iItem;
            iItem.ammoamount = weapon.primaryMagazine.contents;
            iItem.ammotype = weapon.primaryMagazine.ammoType.shortname;
            iItem.weapon = true;
            return iItem;
        }
        List<Item> RestoreItems(List<SavedItem> sItems)
        {
            return sItems.Select(sItem =>
            {
                if (sItem.weapon) return BuildWeapon(sItem);
                return BuildItem(sItem);
            }
            ).Where(i => i != null).ToList();
        }
        Item BuildItem(SavedItem sItem)
        {
            if (sItem.amount < 1) sItem.amount = 1;
            Item item = ItemManager.CreateByItemID(sItem.itemid, sItem.amount, sItem.skinid);
            if (!string.IsNullOrEmpty(sItem.name)) item.name = sItem.name;
            item.blueprintTarget = sItem.blueprint;
            if (item.hasCondition)
            {
                item.condition = sItem.condition;
                item.maxCondition = sItem.maxcondition;
            }
            FlameThrower flameThrower = item.GetHeldEntity()?.GetComponent<FlameThrower>();
            if (flameThrower) flameThrower.ammo = sItem.flamefuel;
            Chainsaw chainsaw = item.GetHeldEntity()?.GetComponent<Chainsaw>();
            if (chainsaw) chainsaw.ammo = sItem.flamefuel;
            if (sItem.mods != null) foreach (var mod in sItem.mods) item.contents.AddItem(BuildItem(mod).info, mod.amount);
            return item;
        }
        Item BuildWeapon(SavedItem sItem)
        {
            Item item = ItemManager.CreateByItemID(sItem.itemid, 1, sItem.skinid);
            if (item.hasCondition)
            {
                item.condition = sItem.condition;
                item.maxCondition = sItem.maxcondition;
            }
            var weapon = item.GetHeldEntity() as BaseProjectile;
            if (weapon != null)
            {
                var def = ItemManager.FindItemDefinition(sItem.ammotype);
                weapon.primaryMagazine.ammoType = def;
                weapon.primaryMagazine.contents = sItem.ammoamount;
            }
            if (sItem.mods != null) foreach (var mod in sItem.mods) item.contents.AddItem(BuildItem(mod).info, 1);
            return item;
        }
        [PluginReference] Plugin Duel, OneVSOne;
        bool InDuel(BasePlayer player) => Duel?.Call<bool>("IsPlayerOnActiveDuel", player) ?? false;
        bool InEvent(BasePlayer player) => OneVSOne?.Call<bool>("IsEventPlayer", player) ?? false;
        public static class PermissionService
        {
            public static Permission permission = Interface.GetMod().GetLibrary<Permission>();
            public static bool HasPermission(string userId, string permissionName)
            {
                if (string.IsNullOrEmpty(userId) || string.IsNullOrEmpty(permissionName)) return false;
                if (permission.UserHasPermission(userId, permissionName)) return true;
                return false;
            }
            public static void RegisterPermissions(Plugin owner, List<string> permissions)
            {
                if (owner == null) throw new ArgumentNullException("owner");
                if (permissions == null) throw new ArgumentNullException("commands");
                foreach (var permissionName in permissions.Where(permissionName => !permission.PermissionExists(permissionName)))
                {
                    permission.RegisterPermission(permissionName, owner);
                }
            }
        }
        private GameObject FileManagerObject;
        private FileManager m_FileManager;
        void InitFileManager()
        {
            FileManagerObject = new GameObject("MAP_FileManagerObject⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠");
            m_FileManager = FileManagerObject.AddComponent<FileManager>();
        }
        class FileManager : MonoBehaviour
        {
            int loaded = 0;
            int needed = 0;
            public bool IsFinished => needed == loaded;
            const ulong MaxActiveLoads = 10;
            Dictionary<string, FileInfo> files = new Dictionary<string, FileInfo>();
            private class FileInfo
            {
                public string Url;
                public string Png;
            }
            public string GetPng(string name) => files[name].Png;
            public IEnumerator LoadFile(string name, string url)
            {
                if (files.ContainsKey(name) && files[name].Url == url && !string.IsNullOrEmpty(files[name].Png)) yield break;
                files[name] = new FileInfo()
                {
                    Url = url
                }
                ;
                needed++;
                yield return StartCoroutine(LoadImageCoroutine(name, url));
            }
            IEnumerator LoadImageCoroutine(string name, string url)
            {
                using (WWW www = new WWW(url))
                {
                    yield return www;
                    using (MemoryStream stream = new MemoryStream())
                    {
                        if (string.IsNullOrEmpty(www.error))
                        {
                            var entityId = CommunityEntity.ServerInstance.net.ID;
                            var crc32 = FileStorage.server.Store(www.bytes, FileStorage.Type.png, entityId).ToString();
                            files[name].Png = crc32;
                        }
                    }
                }
                loaded++;
            }
        }
    }
}

// --- End of file: Backpack.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/XAntiCheat.cs ---
// --- Original Local Path: KualaRust/XAntiCheat.cs ---

﻿using System;
using System.Collections.Generic;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using System.Linq;
using UnityEngine;
using Oxide.Core;
using Random = UnityEngine.Random;
using Rust;
using ProtoBuf;

namespace Oxide.Plugins
{
    [Info("XAntiCheat", "fermens", "0.3.73")]
    public class XAntiCheat : RustPlugin
    {
        const string ipinnfourl = "https://ipinfo.io/{ip}/privacy?token={token}";
        const bool enablefull = true;
        const string ipinfosingup = "https://ipinfo.io/signup";

        #region CODE LOCK
        private static bool IsBanned(ulong userid)
        {
            return ServerUsers.Is(userid, ServerUsers.UserGroup.Banned);
        }

        private static bool IsImprisoned(ulong userid)
        {
            if (ins.PrisonBitch == null) return false;
            return ins.PrisonBitch.Call<bool>("ISIMPRISONED", userid);
        }

        private void OnCodeEntered(CodeLock codeLock, BasePlayer player, string code)
        {
            if (player == null) return;
            ulong owner = codeLock.OwnerID;
            if (owner == 0UL || code  != codeLock.code) return;
            bool bann = IsBanned(owner);
            bool unprisoned = IsImprisoned(owner);

            if(bann || unprisoned)
            {
                ADDLOG($"{player.displayName}({player.UserIDString}) ввёл пароль от кодового замка {(bann ? "забанненого" : "заключенного")} игрока({owner})!", 2);
                if (config.cODELOCK.enable)
                {
                    timer.Once(config.cODELOCK.seconds, () =>
                    {
                        BAN(player.UserIDString, config.cODELOCK.reason, config.cODELOCK.hours, player.displayName);
                    });
                }
            }

        }
        #endregion

        #region КОНФИГ
        private static PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        class SILENT
        {
            [JsonProperty("Автобан (не знаешь, не трогай!)")]
            public int xdetects;

            [JsonProperty("Причина бана")]
            public string reason;

            [JsonProperty("На сколько часов бан?")]
            public int hours;
        }

        class SPIDER
        {
            [JsonProperty("Причина бана")]
            public string reason;

            [JsonProperty("На сколько часов бан?")]
            public int hours;
        }

        class FLY
        {
            [JsonProperty("Причина бана")]
            public string reason;

            [JsonProperty("На сколько часов бан?")]
            public int hours;
        }

        class HITMOD
        {
            [JsonProperty("Причина бана")]
            public string reason;

            [JsonProperty("На сколько часов бан?")]
            public int hours;
        }

        class CODELOCK
        {
            [JsonProperty("Банить?")]
            public bool enable;

            [JsonProperty("Причина бана")]
            public string reason;

            [JsonProperty("Задержка в секундах перед баном, после детекта")]
            public float seconds;

            [JsonProperty("На сколько часов бан?")]
            public int hours;
        }

        class TEAMBAN
        {
            [JsonProperty("Банить?")]
            public bool enable;

            [JsonProperty("Причина бана")]
            public string reason;

            [JsonProperty("Банить, если в команде N забаненных")]
            public int num;

            [JsonProperty("Учитывать бан за макрос?")]
            public bool macros;

            [JsonProperty("На сколько часов бан?")]
            public int hours;
        }

        class SMARTBAN
        {
            [JsonProperty("Банить?")]
            public bool enable;

            [JsonProperty("Причина бана")]
            public string reason;

            [JsonProperty("Fly: очков")]
            public int fly;

            [JsonProperty("EspStash: очков")]
            public int espstash;

            [JsonProperty("Macro: очков")]
            public int macro;

            [JsonProperty("HitMod: очков")]
            public int hitmod;

            [JsonProperty("Spider: очков")]
            public int spider;

            [JsonProperty("Silent: очков")]
            public int silent;

            [JsonProperty("На сколько часов бан?")]
            public int hours;
        }

        class ESPSTASH
        {
            [JsonProperty("Количество")]
            public int amount;

            [JsonProperty("Возможный лут")]
            public Dictionary<string, int> loots;
        }

        class MACROS
        {
            [JsonProperty("Причина бана")]
            public string reason;

            [JsonProperty("Количество выстрелов")]
            public int shoots;

            [JsonProperty("Количество детектов")]
            public int amount;

            [JsonProperty("На сколько часов бан?")]
            public int hours;
        }

        private class PluginConfig
        {
            [JsonProperty("SteamAPI")]
            public string steampi;

            [JsonProperty("Silent Aim: настройка")]
            public SILENT sILENT;

            [JsonProperty("Spider: настройка")]
            public SPIDER sPIDER;

            [JsonProperty("ESP SmallStash: настройка")]
            public ESPSTASH ESPStash;

            [JsonProperty("FLY: настройка")]
            public FLY fLY;

            [JsonProperty("TEAMBAN: настройка")]
            public TEAMBAN tEAMBAN;

            [JsonProperty("CODELOCK: настройка")]
            public CODELOCK cODELOCK;

            [JsonProperty("HITMOD: настройка")]
            public HITMOD hITMOD;

            [JsonProperty("MACROS: настройка")]
            public MACROS mACROS;

            [JsonProperty("Debug camera: Банить?")]
            public bool debugcamera;

            [JsonProperty("Отображать данные при подключении игрока?")]
            public bool show;

            [JsonProperty("Не банить Steam игроков?")]
            public bool steamplayer;

            [JsonProperty("Отправлять в тюрьму, если есть плагин PrisonBitch")]
            public bool prison;

            [JsonProperty("Банить не настроеные аккаунты?")]
            public bool bannensatroyen;

            [JsonProperty("Банить аккаунты, которым меньше X дней")]
            public int banday;

            [JsonProperty("На сколько часов банить новые аккаунты")]
            public int bannewaccountday;

            [JsonProperty("Кикать не настроенные аккаунты")]
            public bool kicknenastoyen;

            [JsonProperty("Кикать приватные аккаунты")]
            public bool kickprivate;

            [JsonProperty("Кикать игроков использующих VPN")]
            public bool kickvpn;

            [JsonProperty("Не кикать лицухи?")]
            public bool steamkick;

            [JsonProperty("Не банить лицушников за новые аккаунты?")]
            public bool steam;

            [JsonProperty("Писать/сохранять логи [0 - нет | 1 - только баны | 2 - все]")]
            public int logspriority;

            [JsonProperty("Discord: ID канала")]
            public string discordid;

            [JsonProperty(" Логи попаданий с огнестрела в консоль")]
            public bool logs;

            [JsonProperty("IPINFO ТОКЕН")]
            public string ipinfotoken;

            [JsonProperty("tt")]
            public string tt;

            [JsonProperty("Сообщения")]
            public Dictionary<string, string> messages;

            [JsonProperty("Шаблоны банов")]
            public Dictionary<string, string> pattern;

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    ipinfotoken = ipinfosingup,
                    kickvpn = false,
                    tEAMBAN = new TEAMBAN
                    {
                        enable = true,
                        hours = 168,
                        reason = "\"bb with teammates\"",
                        num = 2
                    },
                    cODELOCK = new CODELOCK
                    {
                        enable = true,
                        hours = 336,
                        reason = "\"Ban Detected! (1)\"",
                        seconds = 75
                    },
                    sPIDER = new SPIDER
                    {
                        hours = 720,
                        reason = "\"Cheat Detected! (2)\""
                    },
                    sILENT = new SILENT
                    {
                        xdetects = 7,
                        hours = 1440,
                        reason = "\"Cheat Detected! (1)\""
                    },
                    fLY = new FLY
                    {
                        hours = 720,
                        reason = "\"Cheat Detected! (3)\""
                    },
                    hITMOD = new HITMOD
                    {
                        hours = 720,
                        reason = "\"Cheat Detected! (6)\""
                    },
                    mACROS = new MACROS
                    {
                        amount = 5,
                        hours = 168,
                        reason = "\"Macros Detected!\"",
                        shoots = 10
                    },
                    prison = true,
                    steamkick = true,
                    debugcamera = true,
                    logs = false,
                    steam = true,
                    steampi = defaultsteamapi,
                    banday = 5,
                    kicknenastoyen = true,
                    kickprivate = true,
                    bannensatroyen = false,
                    show = true,
                    bannewaccountday = 120,
                    steamplayer = false,
                    messages = new Dictionary<string, string>
                    {
                        { "NEW.ACCOUNT", "\"Подозрительный аккаунт\"" },
                        { "KICK.PRIVATE", "\"Откройте профиль, что бы играть на этом сервере! (Make your Steam profile public to play on this server)\"" },
                        { "KICK.NENASTROYEN", "\"Настройте профиль, что бы играть на этом сервере! (Make your Steam profile public to play on this server)\""},
                        { "KICK.VPN", "\"На сервере запрещено играть с VPN! (VPN DETECTED)\""}
                    },
                    pattern = new Dictionary<string, string>
                    {
                        { "BAN.ACCOUNT", "ban {steamid} {reason} {time}" },
                        { "PRISON.ACCOUNT", "prison.add {steamid} {time} {reason}" },
                    },
                    logspriority = 2,
                    ESPStash = new ESPSTASH
                    {
                        amount = 100,
                        loots = new Dictionary<string, int>
                        {
                            { "rifle.ak", 1 },
                            { "rifle.bolt", 1 },
                            { "rifle.l96", 1 },
                            { "rifle.lr300", 1 },
                            { "rifle.semiauto", 1 },
                            { "wood", 10000 },
                            { "stones", 10000 },
                            { "metal.refined", 50 },
                            { "metal.fragments", 10000 },
                            { "metal.facemask", 1 },
                            { "scrap", 500 },
                        }
                    },
                    discordid = ""
                };
            }
        }
        #endregion

        int nsnext = 0;
        [ChatCommand("ns")]
        private void COMMANSTASH(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin) return;
            player.Teleport(stashContainers[nsnext].transform.position + Vector3.up * 1.5f);
            nsnext++;
            if (stashContainers.Count >= nsnext) nsnext = 0;
        }

        Vector3 lastshash;
        [ChatCommand("ls")]
        private void COMMALS(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin) return;
            if(lastshash == Vector3.zero)
            {
                player.ChatMessage("<color=yellow>Еще не раскопали ни одного стеша!</color>");
                return;
            }
            player.Teleport(lastshash + Vector3.up * 1.5f);
        }

        [ChatCommand("testaim")]
        private void COMMANDERAIM(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin) return;
            TESTAIM(player);
        }

        [ConsoleCommand("test.aim")]
        private void cmdtest(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin || !arg.HasArgs()) return;
            ulong ID;
            if(!ulong.TryParse(arg.Args[0], out ID))
            {
                arg.ReplyWith("ЭТО НЕ СТИМ ИД!");
                return;
            }
            BasePlayer player = BasePlayer.FindByID(ID);
            if(player == null)
            {
                arg.ReplyWith("ИГРОК НЕ НАЙДЕН!");
                return;
            }
            TESTAIM(player);
        }

      /* Dictionary<BasePlayer, DateTime> lastbowtime = new Dictionary<BasePlayer, DateTime>();
        void OnWeaponFired(BaseProjectile projectile, BasePlayer player, ItemModProjectile mod, ProtoBuf.ProjectileShoot projectiles)
        {
            if (player == null || projectile == null || mod == null || projectiles == null)  return;
            Item item = player.GetActiveItem();
            if (item == null || item.info.itemid != 1443579727)  return;
            DateTime dateTime;
            if (!lastbowtime.TryGetValue(player, out dateTime))
            {
                lastbowtime[player] = DateTime.Now;
                return;
            }
            Debug.Log(player.displayName + " - " + (DateTime.Now- dateTime).TotalMilliseconds);
            lastbowtime[player] = DateTime.Now;
        }*/

        private void TESTAIM(BasePlayer player)
        {
            int i = 0;
            Vector3 head = player.eyes.MovementForward();
            Debug.Log($"{i}. {player.displayName} - {player.eyes.HeadForward()} - {player.eyes.MovementForward()}");
            Vector3 pos = new Vector3(player.transform.position.x + (10f * player.eyes.MovementForward().x), 500f, player.transform.position.z + (10f * head.z));
          //  Vector3 vector3 = player.eyes.
            BasePlayer npc = GameManager.server.CreateEntity("assets/prefabs/player/player.prefab", new Vector3(pos.x, TerrainMeta.HeightMap.GetHeight(pos) - 2f, pos.z), new Quaternion(), true) as BasePlayer;
            if (npc == null) return;
            npc.enableSaving = false;
            npc.Spawn();
            NextTick(() =>
            {
                PlayerInventory inv = npc.GetComponent<PlayerInventory>();
                inv.Strip();
            });

            timer.Repeat(0.1f, 20, () => {i++; Debug.Log($"{i}. {player.displayName} - {player.eyes.HeadForward()}"); });
            timer.Once(2.5f, () => { if (!npc.IsDead()) npc.Kill(); });
        }

        [ChatCommand("testfly")]
        private void COMMANDER(BasePlayer player, string command, string[] args)
        {
            if (player.IsAdmin)
            {
                List<BaseEntity> list = Pool.GetList<BaseEntity>();
                Vis.Entities<BaseEntity>(player.transform.position, 2f, list);
                List<TreeEntity> list2 = Pool.GetList<TreeEntity>();
                Vis.Entities<TreeEntity>(player.transform.position, 8.5f, list2);
                string elements = "";
                bool pl = false;
                foreach (var z in list)
                {
                    if (z is BasePlayer && (z as BasePlayer) != player) pl = true;
                    elements += z.ShortPrefabName + (list.Count > 1 ? " | " : "");
                }
                RaycastHit hit;
                var raycast = Physics.Raycast(player.transform.position, Vector3.down, out hit, 500f);
                if (raycast)
                {
                    bool spider = false;
                    RaycastHit hit2;
                    var raycast2 = Physics.Raycast(player.transform.position, player.eyes.BodyForward(), out hit2, 1f);
                    if (raycast2)
                    {
                        spider = hit2.collider.name.Contains("wall");
                        Debug.Log(hit2.collider.name);
                    }
                    bool ins = hit.collider.name.Contains("assets/prefabs/building core");
                    float distance = player.Distance(hit.point);
                    Debug.Log($"-[TEST]- {player.displayName}({player.UserIDString}) - [{elements}] - высота: {distance.ToString("F1")} м. ({hit.collider.name}) | Дерево: {(list2.Count > 0 ? "Да" : "Нет")} | Игрок: {(pl ? "Да" : "Нет")} | В здании: {(ins ? "Да" : "Нет")} | Спайдер: {(spider ? "Да" : "Нет")}");
                }
            }
        }

        [PluginReference] private Plugin PrisonBitch;

        private static void BAN(string steamid, string reason, int time, string displayname, bool checkteam = true)
        {
            if (!enablefull) return;

            ulong usteam = Convert.ToUInt64(steamid);
            if (config.steamplayer)
            {
                BasePlayer pl = BasePlayer.FindByID(usteam);
                if(pl != null)
                {
                    if (ins.ISSTEAM(pl.Connection))
                    {
                        ADDLOG($"{pl.displayName}({pl.UserIDString}) отмазали от бана.", 2);
                        return;
                    }
                }
            }

            ulong usteamid = Convert.ToUInt64(steamid);

            if (checkteam && (reason != config.mACROS.reason || config.tEAMBAN.macros))
            {
                if (config.tEAMBAN.enable)
                {
                    BasePlayer basePlayer = BasePlayer.FindByID(usteam);
                    if (basePlayer != null && basePlayer.Team != null && basePlayer.Team.members.Count > 1)
                    {
                        int banned = basePlayer.Team.members.Count(x => IsBanned(x) || IsImprisoned(x));
                        if (banned >= config.tEAMBAN.num - 1)
                        {
                            foreach (var z in basePlayer.Team.members)
                            {
                                if (basePlayer.userID == z) continue;
                                string strid = z.ToString();
                                BasePlayer basePlayer2 = BasePlayer.FindByID(z);
                                string name = basePlayer2 != null ? basePlayer2.displayName : strid;
                                ins.timer.Once(1f, () => BAN(z.ToString(), config.tEAMBAN.reason, config.tEAMBAN.hours, name, false));
                            }
                        }
                    }
                }
            }

            if (config.prison && prison)
            {
                if (!IsImprisoned(usteamid))
                {
                    ADDLOG($"Отправили в тюрьму {displayname}({steamid}) на {(time * 1f / 24f).ToString("F1")} дней [{reason}]", 1);
                    time = (int)(time * 60f);
                    ins.Server.Command(config.pattern["PRISON.ACCOUNT"].Replace("{steamid}", steamid).Replace("{time}", time.ToString()).Replace("{reason}", reason));
                }
            }
            else
            {
                if (!IsBanned(usteamid))
                {
                    ins.Server.Command(config.pattern["BAN.ACCOUNT"].Replace("{steamid}", steamid).Replace("{time}", time.ToString()).Replace("{reason}", reason));
                    ADDLOG($"Забанили {displayname}({steamid}) на {(time * 1f / 24f).ToString("F1")} дней [{reason}]", 1);
                }
            }
        }

        const int flylimit = 2;
        const int spiderlimit = 2;

        private static Dictionary<ulong, int> macros = new Dictionary<ulong, int>();

        class ANTICHEAT : MonoBehaviour
        {
            private int stash;
            private int silent;
            private int spider;
            private int fly;
            BasePlayer player;
            private DateTime lastban;

            private DateTime firsthit;
            private DateTime hitmod;
            string lasthit;
            int hits;
            float distancehit;
            string weaponhit;

            public DateTime LastFires;
            public int fires;
            string weaponfire;
            float posfire;
            float posfirel;
            float posfirer;

            private int numdetecthit;

            bool macromove;
            Vector3 startshoots;

            private void Awake()
            {
                player = GetComponent<BasePlayer>();
                if (player == null || enablefull && (player.IsAdmin || ins.permission.UserHasPermission(player.UserIDString, "xanticheat.allow")))
                {
                    Destroy(this);
                    return;
                }
          //      if (!enablefull) Debug.Log(player.displayName + " добавили в античит.");
                lasthit = "";
                silent = 0;
                weaponhit = "";
                weaponfire = "";
                if (config.debugcamera) InvokeRepeating(nameof(TICK), 0f, 10f);
                InvokeRepeating(nameof(SILENTCLEAR), 120f, 120f);
               // InvokeRepeating(nameof(WH), 0f, 1f);
            }

            private void SILENTCLEAR()
            {
                spider = 0;
                silent = 0;
                fly = 0;
            }

            public void ADDFLY()
            {
                fly++;
                ADDLOG($"-[Fly]- {player.displayName}({player.UserIDString}) детектов {fly}/{flylimit}", 2);
                if (fly >= flylimit && lastban < DateTime.Now)
                {
                    BAN(player.UserIDString, config.fLY.reason, config.fLY.hours, player.displayName);
                    lastban = DateTime.Now.AddSeconds(10f);
                    fly = 0;
                    return;
                }
            }

            public void ADDFIRE(string weapon)
            {
                if (weapon != "ak47u.item") return;
                double sec = (DateTime.Now - LastFires).TotalSeconds;
                Vector3 current = player.eyes.HeadForward();
                if (fires == 0)
                {
                    startshoots = player.transform.position;
                    macromove = false;
                    sec = 0;
                    posfire = current.y;
                    posfirel = current.x;
                    posfirer = current.z;
                }
                else
                {
                    if (!macromove && startshoots != player.transform.position)
                    {
                        macromove = true;
                    }
                }
                float razn = Mathf.Abs(posfire - current.y);
                float raznl = Mathf.Abs(posfirel - current.x);
                float raznr = Mathf.Abs(posfirer - current.z);
                //    Debug.Log(razn.ToString());
                if (sec < 0.2f && razn <= 0.009f && raznl <= 0.009f && raznr <= 0.009f)
                {
                    fires++;
                    LastFires = DateTime.Now;
                    weaponfire = weapon;
                    if (IsInvoking(nameof(FIREEND))) CancelInvoke(nameof(FIREEND));
                    Invoke(nameof(FIREEND), 0.21f);
                }
            }

            private void FIREEND()
            {
                if (fires >= config.mACROS.shoots)
                {
                    if (!macros.ContainsKey(player.userID)) macros.Add(player.userID, 1);
                    else macros[player.userID] += 1;

                    if(macros[player.userID] >= config.mACROS.amount)
                    {
                        BAN(player.UserIDString, config.mACROS.reason, config.mACROS.hours, player.displayName);
                        lastban = DateTime.Now.AddSeconds(10f);
                    }

                    ADDLOG($"-[Macro]- {player.displayName}({player.UserIDString}) | выстрелов {fires} | использовал {weaponfire} | двигался: {(macromove ? "да" : "нет")} | детект #{macros[player.userID]}", 2);
                }
                fires = 0;
            }

            public void ADDHIT(string hitbone, string weapon, float distance)
            {
                if (hitbone == "N/A" || distance < 30f) return;
                if(hitbone != lasthit && lasthit != "")
                {
                    CLEARHIT();
                    return;
                }
                if (hits == 0)
                {
                    hitmod = DateTime.Now;
                    firsthit = DateTime.Now;
                }
                 hits++;

                //  if (!enablefull) Debug.Log(player.displayName + " - " + hits);
                lasthit = hitbone;
                distancehit += distance;
                if(hits >= 2) distancehit /= 2;
                if(!weaponhit.Contains(weapon)) weaponhit += (hits >= 2 ? ", " : string.Empty) + weapon;
                if (hits >= 5)
                {
                    ADDLOG($"-[HitMod]- {player.displayName}({player.UserIDString}) | {hitbone} | средняя дистанция {distancehit.ToString("F1")} | использовал {weaponhit} | ({(DateTime.Now-firsthit).TotalMinutes.ToString("F1")})", 2);
                    if (distancehit > 100 && (weaponhit.Contains("bow_hunting.entity") || weaponhit.Contains("crossbow.entity") || weaponhit.Contains("bow.compound") || weaponhit.Contains("pistol_eoka.entity"))
                        || distancehit > 65 && (weaponhit == "bow_hunting.entity" || weaponhit == "crossbow.entity" || weaponhit == "bow.compound")
                        || distancehit > 40 && weaponhit == "pistol_eoka.entity")
                    {
                        BAN(player.UserIDString, config.hITMOD.reason, config.hITMOD.hours, player.displayName);
                        lastban = DateTime.Now.AddSeconds(10f);
                    }

                    if(!weapon.Contains("l96.entity"))
                    {
                        if ((DateTime.Now - hitmod).TotalMinutes < 10f)
                        {
                            numdetecthit++;
                            if (numdetecthit >= 3)
                            {
                                BAN(player.UserIDString, config.hITMOD.reason, config.hITMOD.hours, player.displayName);
                                lastban = DateTime.Now.AddSeconds(10f);
                            }
                        }
                        else
                        {
                            numdetecthit = 0;
                        }
                    }

                    hitmod = DateTime.Now;
                    CLEARHIT();
                }
            }
            /*
            private void WH()
            {
                RaycastHit hitInfo;
                if (GamePhysics.Trace(new Ray(player.eyes.position, player.eyes.HeadForward()), 0.0f, out hitInfo, 300f, 1219701521, QueryTriggerInteraction.UseGlobal))
                {
                    //targetPos = hitInfo.point;
                    if ((bool)((UnityEngine.Object)hitInfo.collider))
                    {
                        BaseEntity entity = hitInfo.GetEntity();
                        if ((bool)((UnityEngine.Object)entity))
                        {
                            BaseCombatEntity baseCombatEntity = entity as BaseCombatEntity;
                            if (baseCombatEntity is BasePlayer)
                            {
                                BasePlayer basePlayer = baseCombatEntity as BasePlayer;
                                RaycastHit hitInfo2;
                                if (GamePhysics.Trace(new Ray(player.eyes.position, player.eyes.HeadForward()), 0.0f, out hitInfo2, 300f, 1218652417, QueryTriggerInteraction.UseGlobal))
                                {
                                    BaseEntity entity2 = hitInfo2.GetEntity();
                                    if ((bool)((UnityEngine.Object)entity2))
                                    {
                                        BaseCombatEntity baseCombatEntity2 = entity as BaseCombatEntity;
                                        if (!(baseCombatEntity2 is BasePlayer))
                                        {
                                            ADDLOG($"[#] {player.displayName} -> {basePlayer.displayName} [{player.Distance(basePlayer)} м. | {(basePlayer.eyes.transform.position.y - hitInfo.point.y).ToString("F1")} м. | {baseCombatEntity2.ShortPrefabName}]", 2);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            */
            private void CLEARHIT()
            {
                hits = 0;
                lasthit = "";
                weaponhit = "";
                distancehit = 0;
            }

            public void ADDSTASH()
            {
                stash++;
                if (stash >= 2 && lastban < DateTime.Now)
                {
                    BAN(player.UserIDString, "\"CheatDetected (6)\"", config.fLY.hours, player.displayName);
                    lastban = DateTime.Now.AddSeconds(10f);
                    stash = 0;
                    return;
                }
            }

            public void ADDSPIDER()
            {
                spider++;
                ADDLOG($"-[Spider]- {player.displayName}({player.UserIDString}) детектов {spider}/{spiderlimit}", 2);
                if (spider >= spiderlimit && lastban < DateTime.Now)
                {
                    BAN(player.UserIDString, config.sPIDER.reason, config.sPIDER.hours, player.displayName);
                    lastban = DateTime.Now.AddSeconds(10f);
                    spider = 0;
                    return;
                }
            }

            public void ADDSILENT(int amount)
            {
                silent += amount;
                ADDLOG($"-[SAim]- {player.displayName}({player.UserIDString}) детектов {silent}/{config.sILENT.xdetects}", 2);
                if (silent >= config.sILENT.xdetects && lastban < DateTime.Now)
                {
                    BAN(player.UserIDString, config.sILENT.reason, config.sILENT.hours, player.displayName);
                    lastban = DateTime.Now.AddSeconds(10f);
                    silent = 0;
                    return;
                }
            }

            private void TICK()
            {
                /*    if (player.IsFlying)
                    {
                        if (!IsInvoking(nameof(FLYTICK)))
                        {
                            height = player.transform.position.y;
                            InvokeRepeating(nameof(FLYTICK), 1f, 1f);
                        }
                    }*/

                if (enablefull)
                {
                    player.SendConsoleCommand("noclip");
                    player.SendConsoleCommand("camspeed 0");
                }

               

                /* if (player.modelState.flying && !player.IsAdmin && !player.IsDeveloper)
                {
                    BAN(player.UserIDString, "\"Cheat Detected! (4)\"", 60, player.displayName);
                    lastban = DateTime.Now.AddSeconds(10f);
                }*/
            }

         /*   private float height;
            private void FLYTICK()
            {
                if (!player.IsFlying)
                {
                    fly = 0;
                    CancelInvoke(nameof(FLYTICK));
                }

                fly++;
                if (fly >= 5)
                {
                    ADDLOG($"[Fly] {player.displayName}({player.UserIDString}) возможно флай.", 2);
                    fly = 0;
                    CancelInvoke(nameof(FLYTICK));
                }
            }*/

            public void DoDestroy() => Destroy(this);

            private void OnDestroy()
            {
                if (IsInvoking(nameof(TICK))) CancelInvoke(nameof(TICK));
               // if (IsInvoking(nameof(WH))) CancelInvoke(nameof(WH));
                if (IsInvoking(nameof(FIREEND))) CancelInvoke(nameof(FIREEND));
                //  if (IsInvoking(nameof(FLYTICK))) CancelInvoke(nameof(FLYTICK));
            }
        }

      /*  private void OnWeaponFired(BaseProjectile projectile, BasePlayer player, ItemModProjectile mod, ProtoBuf.ProjectileShoot projectiles)
        {
            if (player == null || projectile == null || mod == null || projectiles == null) return;
            RaycastHit hitInfo;
            if (GamePhysics.Trace(new Ray(player.eyes.position, player.eyes.HeadForward()), 0.0f, out hitInfo, 300f, 1219701521, QueryTriggerInteraction.UseGlobal))
            {
                //targetPos = hitInfo.point;
                if ((bool)((UnityEngine.Object)hitInfo.collider))
                {
                    BaseEntity entity = hitInfo.GetEntity();
                    if ((bool)((UnityEngine.Object)entity))
                    {
                        BaseCombatEntity baseCombatEntity = entity as BaseCombatEntity;
                        if (baseCombatEntity is BasePlayer)
                        {
                            BasePlayer basePlayer = baseCombatEntity as BasePlayer;
                          //  if(basePlayer)
                            Debug.Log($"{player.displayName} -> {basePlayer.displayName} [{player.Distance(basePlayer)} м. | {(basePlayer.eyes.transform.position.y - hitInfo.point.y).ToString("F1")} м.]");
                        }
                    }
                }
            }
        }*/

        private void OnPlayerBanned(string name, ulong id, string address, string reason)
        {
            if (reason == "Cheat Detected!") ADDLOG($"Забанили {name}({id}) [FakeAdmin/DebugCamera]", 1);
        }

        const string defaultsteamapi = "https://steamcommunity.com/dev/apikey";
        class resp
        {
            public avatar response;
        }

        class avatar
        {
            public List<Players> players;
        }

        class Players
        {
            public int? profilestate;
            public int? timecreated;
        }

        class INFO
        {
            public DateTime dateTime;
            public bool profilestate;
            public bool steam;
            public Dictionary<string, Dictionary<string, int>> hitinfo;
        }

        Dictionary<ulong, INFO> PLAYERINFO = new Dictionary<ulong, INFO>();

        static XAntiCheat ins;
        private void Init()
        {
            ins = this;
            //   Unsubscribe(nameof(OnPlayerConnected));
        }

        #region Grid
        Dictionary<string, Vector3> Grids = new Dictionary<string, Vector3>();
        const float calgon = 0.0066666666666667f;
        void CreateSpawnGrid()
        {
            var worldSize = (ConVar.Server.worldsize);
            float offset = worldSize / 2;
            var gridWidth = (calgon * worldSize);
            float step = worldSize / gridWidth;

            string start = "";

            char letter = 'A';
            int number = 0;

            for (float zz = offset; zz > -offset; zz -= step)
            {
                for (float xx = -offset; xx < offset; xx += step)
                {
                    Grids.Add($"{start}{letter}{number}", new Vector3(xx - 55f, 0, zz));
                    if (letter.ToString().ToUpper() == "Z")
                    {
                        start = "A";
                        letter = 'A';
                    }
                    else
                    {
                        letter = (char)(((int)letter) + 1);
                    }


                }
                number++;
                start = "";
                letter = 'A';
            }
        }

        private string GetNameGrid(Vector3 pos)
        {
            return Grids.Where(x => x.Value.x < pos.x && x.Value.x + 150f > pos.x && x.Value.z > pos.z && x.Value.z - 150f < pos.z).FirstOrDefault().Key;
        }
        #endregion

        private static bool prison = false;
        private List<StashContainer> stashContainers = new List<StashContainer>();
        private float sizeworldx;
        private float sizeworldz;

        List<Vector3> OntheMap = new List<Vector3>();
        void foundmonuments()
        {
            OntheMap.Clear();
            foreach (var z in UnityEngine.Object.FindObjectsOfType<MonumentInfo>())
            {
                if (z.name.Contains("/cave") || z.name.Contains("/tiny") || z.name.Contains("/power substations") || z.name.Contains("OilrigAI")) continue;
                Vector3 pos = z.transform.position;
                if (!OntheMap.Contains(pos)) OntheMap.Add(pos);
            }
        }

        private Vector3 RANDOMPOS() => new Vector3(Random.Range(-sizeworldx, sizeworldx), 400f, Random.Range(-sizeworldz, sizeworldz));

        List<string> names = new List<string>();

        private Vector3 FINDSPAWNPOINT(int num = 1)
        {
            if (num >= 300) return Vector3.zero;
            Vector3 pos = RANDOMPOS();

            RaycastHit hitInfo;
            if (!Physics.Raycast(pos, Vector3.down, out hitInfo, 450f, Layers.Solid)) return FINDSPAWNPOINT(num++);
            if (hitInfo.collider == null || hitInfo.collider.name != "Terrain" && hitInfo.collider.name != "Road Mesh") return FINDSPAWNPOINT(num++);
            if (hitInfo.point.y - TerrainMeta.WaterMap.GetHeight(hitInfo.point) < 0) return FINDSPAWNPOINT(num++);
            if (WaterLevel.Test(hitInfo.point)) return FINDSPAWNPOINT(num++);
            if (OntheMap.Any(x => Vector3.Distance(x, hitInfo.point) < 170f)) return FINDSPAWNPOINT(num++);
            if (stashContainers.Any(x => Vector3.Distance(x.transform.position, hitInfo.point) < 30f)) return FINDSPAWNPOINT(num++);
            if (Mathf.Abs((TerrainMeta.HeightMap.GetHeight(hitInfo.point) - hitInfo.point.y)) > 0.1f) return FINDSPAWNPOINT(num++);
            if (Mathf.Abs((TerrainMeta.HeightMap.GetHeight(hitInfo.point + Vector3.left * 0.2f) - hitInfo.point.y)) > 0.01f) return FINDSPAWNPOINT(num++);
            if (Mathf.Abs((TerrainMeta.HeightMap.GetHeight(hitInfo.point + Vector3.right * 0.2f) - hitInfo.point.y)) > 0.01f) return FINDSPAWNPOINT(num++);
            if (Mathf.Abs((TerrainMeta.HeightMap.GetHeight(hitInfo.point + Vector3.forward * 0.2f) - hitInfo.point.y)) > 0.01f) return FINDSPAWNPOINT(num++);
            if (Mathf.Abs((TerrainMeta.HeightMap.GetHeight(hitInfo.point + Vector3.back * 0.2f) - hitInfo.point.y)) > 0.01f) return FINDSPAWNPOINT(num++);
            return hitInfo.point;
        }

        private void CanSeeStash(BasePlayer player, StashContainer stash)
        {
            if (stash.OwnerID != 0 || !stashContainers.Contains(stash)) return;
            ADDLOG($"-[ESPStash]- {player.displayName}({player.UserIDString}) - квадрат {GetNameGrid(stash.transform.position)}", 2);
            timer.Once(75f, () => 
            {
                if (!player.IsConnected) return;
                ANTICHEAT aNTICHEAT;
                if (!player.TryGetComponent<ANTICHEAT>(out aNTICHEAT)) return;
                aNTICHEAT.ADDSTASH();
            });
            lastshash = stash.transform.position;
            stashContainers.Remove(stash);
        }

        private void OnServerInitialized()
        {
            SaveConfig();
            if(config.tt == null)
            {
                config.tt = "1";
                config.tEAMBAN.enable = true;
                config.cODELOCK.enable = true;
                SaveConfig();
            }

            if (config.tEAMBAN == null)
            {
                config.tEAMBAN = new TEAMBAN
                {
                    hours = 168,
                    reason = "\"bb with teammates\"",
                    num = 2
                };
                config.cODELOCK = new CODELOCK
                {
                    hours = 336,
                    reason = "\"Ban Detected! (1)\"",
                    seconds = 75
                };
                SaveConfig();
            }

            if(config.tEAMBAN.num == 0)
            {
                config.tEAMBAN.num = 2;
                SaveConfig();
            }

            if (config.discordid == null)
            {
                config.discordid = "";
                SaveConfig();
            }
            CreateSpawnGrid();
            if(config.ipinfotoken == null)
            {
                config.ipinfotoken = ipinfosingup;
                if (!config.messages.ContainsKey("KICK.VPN")) config.messages.Add("KICK.VPN", "\"На сервере запрещено играть с VPN! (VPN DETECTED)\"");
                config.kickvpn = true;
                SaveConfig();
            }

            if(config.mACROS == null)
            {
                config.hITMOD = new HITMOD
                {
                    hours = 720,
                    reason = "\"Cheat Detected! (6)\""
                };
                config.mACROS = new MACROS
                {
                    amount = 5,
                    hours = 168,
                    shoots = 10,
                    reason = "\"Cheat Detected! (7)\""
                };
                SaveConfig();
            }

            if(config.mACROS.shoots == 0)
            {
                config.mACROS.shoots = 10;
                SaveConfig();
            }

            if (config.ESPStash == null) // патч 04.06 
            {
                config.ESPStash = new ESPSTASH
                {
                    amount = 100,
                    loots = new Dictionary<string, int>
                    {
                        { "rifle.ak", 1 },
                        { "rifle.bolt", 1 },
                        { "rifle.l96", 1 },
                        { "rifle.lr300", 1 },
                        { "rifle.semiauto", 1 },
                        { "wood", 10000 },
                        { "stones", 10000 },
                        { "metal.refined", 50 },
                        { "metal.fragments", 10000 },
                        { "metal.facemask", 1 },
                        { "scrap", 500 },
                    }
                };
                config.steam = true;
                SaveConfig();
            }

            if(config.ipinfotoken == ipinfosingup)
            {
                Debug.LogWarning("Введите в конфиг токен для IPINFO, если хотите включить автоопределение использования игроком VPN!");
            }
            foundmonuments();

            sizeworldx = TerrainMeta.Size.x / 2.5f;
            sizeworldz = TerrainMeta.Size.z / 2.5f;

            namefile = DateTime.Now.ToString("MM/dd");
            LOGS = Interface.Oxide.DataFileSystem.ReadObject<List<string>>("XAC/" + namefile);
            if (config.sPIDER == null)
            {
                config.sPIDER = new SPIDER
                {
                    hours = 720,
                    reason = "\"Cheat Detected! (2)\""
                };
                SaveConfig();
            }
            if (config.sILENT == null)
            {
                config.sILENT = new SILENT
                {
                    xdetects = 7,
                    hours = 1440,
                    reason = "\"Cheat Detected! (1)\""
                };
                config.pattern = new Dictionary<string, string>
                {
                    { "BAN.ACCOUNT", "ban {steamid} {reason} {time}" },
                    { "PRISON.ACCOUNT", "prison.add {steamid} {time} {reason}" },
                };
                SaveConfig();
            }
            if(config.fLY == null)
            {
                config.fLY = new FLY
                {
                    hours = 720,
                    reason = "\"Cheat Detected! (3)\""
                };
                SaveConfig();
            }
            if (config.sILENT.xdetects == 0)
            {
                config.sILENT.xdetects = 7;
                config.debugcamera = true;
                SaveConfig();
            }

            if (!config.messages.ContainsKey("KICK.NENASTROYEN"))
            {
                config.messages.Add("KICK.NENASTROYEN", "Настройте профиль, что бы играть на этом сервере! (Make your Steam profile public to play on this server)");
                SaveConfig();
            }

            if (string.IsNullOrEmpty(config.steampi) || config.steampi == defaultsteamapi)
            {
                Debug.LogError("УКАЖИТЕ STEAMAPI В КОНФИГЕ!");
                return;
            }

            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
             /*   HeldEntity heldEntity = player.GetHeldEntity();
                if (heldEntity != null)
                {
                    BaseProjectile baseProjectile = heldEntity.GetComponent<BaseProjectile>();
                    if (baseProjectile == null) continue;
                    baseProjectile.recoil.recoilYawMin = -2f;
                    baseProjectile.recoil.recoilPitchMin = -4f;
                    baseProjectile.recoil.recoilYawMax = 8f;
                    baseProjectile.recoil.recoilPitchMax = -30f;
                    baseProjectile.recoil.ADSScale = 0.5f;
                    baseProjectile.recoil.movementPenalty = 0.5f;

                    Debug.Log(player.displayName + " " + baseProjectile.recoil.recoilYawMin + " " + heldEntity.GetComponent<BaseProjectile>().recoil.recoilPitchMin + " " + heldEntity.GetComponent<BaseProjectile>().recoil.recoilYawMax + " " + heldEntity.GetComponent<BaseProjectile>().recoil.recoilPitchMax + " " + heldEntity.GetComponent<BaseProjectile>().recoil.ADSScale + " " + heldEntity.GetComponent<BaseProjectile>().recoil.movementPenalty);
                }*/
                if (player.GetComponent<ANTICHEAT>() == null) player.gameObject.AddComponent<ANTICHEAT>();
            }
            timer.Once(5f, () => { if (PrisonBitch != null) prison = true; });
            permission.RegisterPermission("xanticheat.allow", this);
            permission.RegisterPermission("xanticheat.skip", this);
            permission.RegisterPermission("xanticheat.command", this);
            permission.RegisterPermission("xanticheat.chat", this);
            // Subscribe(nameof(OnPlayerConnected));
            timer.Every(3600f, () => Save());

            stashContainers.Clear();

            int i = 0;
            while(i < config.ESPStash.amount)
            {
                Vector3 pos = FINDSPAWNPOINT();
                if (pos == Vector3.zero) continue;
                StashContainer stashContainer = GameManager.server.CreateEntity("assets/prefabs/deployable/small stash/small_stash_deployed.prefab", pos, new Quaternion(), true) as StashContainer;
                stashContainer.enableSaving = false;
                stashContainer.Spawn();
                int max = Random.Range(2, 7);
                int current = 0;
                foreach (var z in config.ESPStash.loots)
                {
                    if (Random.Range(0f, 1f) >= 0.65f)
                    {
                        if (current < max)
                        {
                            Item item = ItemManager.CreateByName(z.Key, Random.Range(1, z.Value));
                            if (item != null)
                            {
                                if (item.hasCondition)
                                {
                                    item.LoseCondition(Random.Range(0f, 100f));
                                    BaseProjectile weapon = item.GetHeldEntity() as BaseProjectile;
                                    if (weapon != null)
                                    {
                                        if (weapon.primaryMagazine != null)
                                        {
                                            weapon.primaryMagazine.contents = Random.Range(1, weapon.primaryMagazine.capacity + 1);
                                        }
                                    }
                                }
                                if (!item.MoveToContainer(stashContainer.inventory, Random.Range(0, 6), false)) item.MoveToContainer(stashContainer.inventory);
                                current++;
                            }
                        }
                    }
                }
                stashContainer.SetHidden(true);
                stashContainers.Add(stashContainer);
                i++;
            }
            Debug.Log($"Создали {stashContainers.Count} стешей-ловушек");

            moders.Clear();
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (ins.permission.UserHasPermission(player.UserIDString, "xanticheat.chat") && !moders.Contains(player)) moders.Add(player);
            }
        }

        private readonly int constructionColl = LayerMask.GetMask(new string[] { "Construction", "Deployable", "Prevent Building", "Deployed" });
        private readonly int buildingLayer = LayerMask.GetMask("Terrain", "World", "Construction", "Deployed");
        //   private static Dictionary<ulong, int> FLYHACK = new Dictionary<ulong, int>();
        const string sspiral = "block.stair.spiral";
        const string sroof = "roof";
        const string sfly = "supply_drop";
        const string prefroof = "roof";
        const string prefspiral = "stairs.spiral";
        const string iceberg = "iceberg";
        private void OnPlayerViolation(BasePlayer player, AntiHackType type, float amount)
        {
            if (type == AntiHackType.FlyHack && !IsBattles(player.userID))
            {
                ANTICHEAT aNTICHEAT;
                if (!player.TryGetComponent<ANTICHEAT>(out aNTICHEAT)) return;
                List<BaseEntity> list = Pool.GetList<BaseEntity>();
                Vis.Entities<BaseEntity>(player.transform.position, 2f, list);
                List<TreeEntity> list2 = Pool.GetList<TreeEntity>();
                Vis.Entities<TreeEntity>(player.transform.position, 6f, list2);
                string elements = "";
                bool pl = false;
                bool more1 = list.Count > 1;
                foreach (var z in list)
                {
                    if (z is BasePlayer && (z as BasePlayer) != player) pl = true;
                    elements += z.ShortPrefabName + (more1 ? " | " : "");
                }
                RaycastHit hit;
                var raycast = Physics.Raycast(player.transform.position, Vector3.down, out hit, 500f);
                if (raycast)
                {
                    bool spider = false;
                    bool drop = hit.collider.name.Contains(sfly);
                    bool spiral = hit.collider.name.Contains(prefspiral); 
                    bool roof = hit.collider.name.Contains(prefroof);
                    bool ice = hit.collider.name.Contains(iceberg);

                    RaycastHit hit2;
                    var raycast2 = Physics.Raycast(player.transform.position, player.eyes.BodyForward(), out hit2, 1f);
                    if (raycast2)
                    {
                        spider = hit2.collider.name.Contains("wall");
                    }
                    if(!spiral)
                    {
                        spiral = elements.Contains(sspiral);
                    }
                    if (!drop)
                    {
                        drop = elements.Contains(sfly);
                    }
                    if (!roof) roof = elements.Contains(sroof);


                    bool tree = list2.Count > 0;
                    bool ins = hit.collider.name.Contains("assets/prefabs/building core");
                    float distance = player.Distance(hit.point);
                    ADDLOG($"-[Fly]- {player.displayName}({player.UserIDString}) - [{elements}] - высота: {distance.ToString("F1")} м. ({hit.collider.name}) | Дерево: {(tree ? "Да" : "Нет")} | Игрок: {(pl ? "Да" : "Нет")} | В здании: {(ins ? "Да" : "Нет")} | Спайдер: {(spider ? "Да" : "Нет")} | Спиральная лестница: {(spiral ? "Да" : "Нет")} | Крыша: {(roof ? "Да" : "Нет")} | Аир: {(drop ? "Да" : "Нет")}", 1);
                    if (roof || drop || spiral || ice || tree || pl || distance < 3f || distance > 7f) return;
                    if (spider) aNTICHEAT.ADDSPIDER();
                    else if(!more1) aNTICHEAT.ADDFLY();
                }
            }
            /*
            if (elements.Contains("wall"))
            {
                ANTICHEAT aNTICHEAT;
                if (!player.TryGetComponent<ANTICHEAT>(out aNTICHEAT)) return;
                RaycastHit hit;
                var raycast = Physics.Raycast(player.transform.position, Vector3.down, out hit, 500f, buildingLayer);
                if (raycast)
                {
                    float distance = player.Distance(hit.point);
                    ADDLOG($"-[Spider]- {player.displayName}({player.UserIDString}) - [{elements}] - высота: {distance.ToString("F1")} м.", 2);
                    if (distance >= 3f && distance <= 7f) aNTICHEAT.ADDSPIDER();
                }
            }
            else if(elements.Count() == 0)
            {
                if (player.IsAdmin || ins.permission.UserHasPermission(player.UserIDString, "xanticheat.allow")) return;
                RaycastHit hit;
                var raycast = Physics.Raycast(player.transform.position, Vector3.down, out hit, 500f, buildingLayer);
                if (raycast)
                {
                    ANTICHEAT aNTICHEAT;
                    if (!player.TryGetComponent<ANTICHEAT>(out aNTICHEAT)) return;
                    float distance = player.Distance(hit.point);
                    ADDLOG($"-[Fly]- {player.displayName}({player.UserIDString}) - высота: {distance.ToString("F1")} м.", 2);
                    if(distance >= 3f && distance <= 7f) aNTICHEAT.ADDFLY();
                }
            }*/
        }
        

        private static string namefile;
        private static List<string> LOGS = new List<string>();
        private static List<BasePlayer> moders = new List<BasePlayer>();
        private static void ADDLOG(string text, int priority)
        {
            if (config.logspriority >= priority)
            {
                Debug.LogWarning(text);
                if (!string.IsNullOrEmpty(config.discordid))
                {
                    if (ins.DiscordCore != null) ins.DiscordCore.Call("SendMessageToChannel", config.discordid, text);
                    if (ins.HaxBot != null) ins.HaxBot.Call("MESSAGE", text, 14177041, config.discordid);
                }

                foreach(var z in moders)
                {
                    z.ChatMessage(text); 
                }

                LOGS.Add($"[{DateTime.Now.ToShortTimeString()}] " + text);
            }
        }

        private void Save()
        {
            Interface.Oxide.DataFileSystem.WriteObject($"XAC/{namefile}", LOGS);
            Debug.Log("[XAntiCheat] Сохранили логи в файлик.");
        }

        [ConsoleCommand("ac.logs")]
        private void cmdlastlogs(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (arg.IsAdmin || player != null && permission.UserHasPermission(player.UserIDString, "xanticheat.command"))
            {
                if (LOGS.Count > 0)
                {
                    int number;
                    if (!arg.HasArgs() || !int.TryParse(arg.Args[0], out number)) number = 10;
                    int skip = LOGS.Count - number;
                    if (skip < 0) skip = 0;
                    string text = string.Join("\n", LOGS.Skip(skip).Take(number).ToArray());
                    arg.ReplyWith("XAC - Последние логи:\n" + text + "\n------------------");
                }
                else
                {
                    arg.ReplyWith("XAC - В логах пусто :(");
                }
            }
        }

        [ConsoleCommand("ac.save")]
        private void cmdsavecommand(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin) return;
            Save();
        }

        private void Unload()
        {
            foreach(var z in stashContainers)
            {
                if (!z.IsDestroyed) z.Kill();
            }

            Save();

            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                ANTICHEAT aNTICHEAT;
                if (player.TryGetComponent<ANTICHEAT>(out aNTICHEAT)) aNTICHEAT.DoDestroy();
            }
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (!player.IsConnected) return;
            if (player.IsReceivingSnapshot)
            {
                timer.Once(1f, () => OnPlayerConnected(player));
                return;
            }
            if (player.GetComponent<ANTICHEAT>() == null) player.gameObject.AddComponent<ANTICHEAT>();
            if (ins.permission.UserHasPermission(player.UserIDString, "xanticheat.chat") && !moders.Contains(player)) moders.Add(player);
            
            timer.Once(1f, () => GETINFO(player));
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            ANTICHEAT aNTICHEAT;
            if (player.TryGetComponent<ANTICHEAT>(out aNTICHEAT)) aNTICHEAT.DoDestroy();
            if (moders.Contains(player)) moders.Remove(player);
        }

        private object OnPlayerAttack(BasePlayer player, HitInfo info)
        {
            if (player == null || info.HitEntity == null || !(info.HitEntity is BasePlayer) || IsBattles(player.userID)) return null;
            float distnace = info.HitEntity.Distance(player);
            if (distnace < 15f) return null;
            float y = Mathf.Abs(info.HitPositionWorld.y - info.HitEntity.CenterPoint().y);
            if (y >= 2.05f)
            {
                string weapon = info.WeaponPrefab.ShortPrefabName ?? "x";
                ADDLOG($"-[SAim]- {player.displayName}({player.UserIDString}) - {y.ToString("F1")} м.- [{weapon} | {info.boneName ?? "x"} | {distnace.ToString("F1")} м.]", 2);
                if (info.boneName != "head" && info.boneName != "neck") return null;
                ANTICHEAT aNTICHEAT;
                if (!player.TryGetComponent<ANTICHEAT>(out aNTICHEAT)) return null;
                int amount = 4;
                if (weapon == "crossbow.entity" || weapon == "bow_hunting.entity" || weapon == "bow_compound.entity" || weapon == "pistol_eoka.entity") amount = 7;
                aNTICHEAT.ADDSILENT(amount);
                return true;
            }
            return null;
        }


        private void OnWeaponFired(BaseProjectile projectile, BasePlayer player, ItemModProjectile itemModProjectile, ProjectileShoot projectileShoot)
        {
            if (projectile == null || player == null || itemModProjectile == null || projectileShoot == null) return;
            ANTICHEAT aNTICHEAT;
            if (!player.TryGetComponent<ANTICHEAT>(out aNTICHEAT)) return;
            aNTICHEAT.ADDFIRE(projectile.GetItem().info.name);
        }

        private void OnEntityTakeDamage(object entity, HitInfo info)
        {
            if (info == null || info.Weapon == null || info.InitiatorPlayer == null || info.damageTypes.IsMeleeType()) return;
            if (IsNPC(info.InitiatorPlayer) || !(entity is BasePlayer)) return;

            BasePlayer player = entity as BasePlayer;
            if (player == null || IsNPC(player) || !player.IsConnected || player.IsSleeping() || info.InitiatorPlayer == player || player.Team != null && player.Team.members.Contains(info.InitiatorPlayer.userID)) return;

          //  info.damageTypes.ScaleAll(0f);

            string weapon = info.WeaponPrefab != null ? info.WeaponPrefab.ShortPrefabName : "x";
            string bone = !string.IsNullOrEmpty(info.boneName) ? info.boneName : "x";
            float distance = info.InitiatorPlayer.Distance(player);
            //{(info.InitiatorPlayer.IsFlying? " | в полёте" : "")}{(!info.InitiatorPlayer.IsAiming ? " | от бедра" : "")}
            if (config.logs) Debug.Log($"-- {info.InitiatorPlayer.displayName}({info.InitiatorPlayer.UserIDString}) [{weapon} | {bone} | {distance.ToString("F1")} м.] => {player.displayName}({player.UserIDString})");
            ANTICHEAT aNTICHEAT;
            if (!info.InitiatorPlayer.TryGetComponent<ANTICHEAT>(out aNTICHEAT)) return;
            aNTICHEAT.ADDHIT(bone, weapon, distance);
        }

        private bool IsNPC(BasePlayer player)
        {
            if (player is NPCPlayer) return true;
            if (!(player.userID >= 76560000000000000L || player.userID <= 0L)) return true;
            return false;
        }

        [PluginReference] Plugin MultiFighting, Battles, HaxBot, DiscordCore;

        private bool IsBattles(ulong userid)
        {
            return Battles != null && Battles.Call<bool>("IsPlayerOnBattle", userid);
        }

        private bool ISSTEAM(Network.Connection connection)
        {
            if (MultiFighting == null) return true;
            return MultiFighting.Call<bool>("IsSteam", connection);
        }

        private void GETINFO(BasePlayer player) // пиздим инфу со стима
        {
            if (!player.IsConnected) return;
            webrequest.Enqueue($"https://api.steampowered.com/ISteamUser/GetPlayerSummaries/v0002/?key={config.steampi}&steamids={player.UserIDString}&format=json", null, (code, response) =>
            {
                if (response != null && code == 200)
                {
                    string steamid = player.UserIDString;
                    string text = $"------------\n{player.displayName} ({steamid})";
                    bool act = false;
                    INFO iNFO = new INFO();
                    resp sr = JsonConvert.DeserializeObject<resp>(response);
                    int datetime = sr.response.players[0].timecreated ?? 0;
                    DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);
                    DateTime create = epoch.AddSeconds(datetime).AddHours(3);
                    bool steam = ISSTEAM(player.Connection);
                    text += $"\nВерсия игры: {(steam ? "Лицензия" : "Пиратка")}";
                    int nastr = sr.response.players[0].profilestate ?? 0;
                    bool ns = ISNASTROEN(nastr);
                    text += $"\nАккаунт настроен: {(ns ? "Да" : "Нет")}";
                    if (!ns && config.kicknenastoyen)
                    {
                        if (!permission.UserHasPermission(steamid, "xanticheat.allow") && !permission.UserHasPermission(steamid, "xanticheat.skip"))
                        {
                            Server.Command($"kick {steamid} {config.messages["KICK.NENASTROYEN"]}");
                            act = true;
                        }
                    }
                    if (datetime > 0)
                    {
                        text += $"\nАккаунт создан: {create.ToShortDateString()}";
                    }
                    else
                    {
                        text += "\nПрофиль закрытый: Да";
                        if (!steam || !config.steamkick)
                        {
                            if (config.kickprivate && !permission.UserHasPermission(steamid, "xanticheat.allow") && !permission.UserHasPermission(steamid, "xanticheat.skip"))
                            {
                                Server.Command($"kick {steamid} {config.messages["KICK.PRIVATE"]}");
                                act = true;
                            }
                        }
                    }

                    if (config.show) Debug.Log(text + "\n------------");

                    if (!permission.UserHasPermission(steamid, "xanticheat.allow") && !permission.UserHasPermission(steamid, "xanticheat.skip") && (config.bannensatroyen && nastr != 1 || create.AddDays(config.banday) > DateTime.Now))
                    {
                        if (act || steam && config.steam) return;
                        Server.Command(config.pattern["BAN.ACCOUNT"].Replace("{steamid}", steamid).Replace("{reason}", config.messages["NEW.ACCOUNT"]).Replace("{time}", config.bannewaccountday.ToString()));
                        return;
                    }
                }
            }, this);


            //VPN
            if (config.ipinfotoken == ipinfosingup) return;
            string[] ip = player.IPlayer.Address.Split(':');
            webrequest.Enqueue(ipinnfourl.Replace("{token}", config.ipinfotoken).Replace("{ip}", ip[0]), null, (code, response) =>
            {
                if (response != null && code == 200)
                {
                    if (!player.IsConnected) return;
                    VPNINFO sr = JsonConvert.DeserializeObject<VPNINFO>(response);
                    bool VPN = sr.vpn;
                    Debug.Log($"[{player.displayName}({player.UserIDString}) | IP: {ip[0]} | VPN: {(VPN ? "Да" : "Нет")}]");
                    if (!VPN) return;
                    if (config.kickvpn && !permission.UserHasPermission(player.UserIDString, "xanticheat.allow") && !permission.UserHasPermission(player.UserIDString, "xanticheat.skip"))
                    {
                        Server.Command($"kick {player.UserIDString} {config.messages["KICK.VPN"]}");
                    }
                }
            }, this);
        }

        class VPNINFO
        {
            public bool vpn;
            public bool proxy;
            public bool tor;
            public bool hosting;
        }

        private bool ISNASTROEN(int num)
        {
            if (num == 1) return true;
            return false;
        }

      /*  #region FakeWorkbench
        private object CanCraft(ItemCrafter itemCrafter, ItemBlueprint bp, int amount)
        {
            BasePlayer player = itemCrafter.GetComponent<BasePlayer>();
            if (player == null) return null;
            Debug.Log(player.currentCraftLevel + "/" + bp.workbenchLevelRequired);
            return null;
        }
        #endregion*/
    }
}


// --- End of file: XAntiCheat.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/IQReportSystem.cs ---
// --- Original Local Path: KualaRust/IQReportSystem.cs ---

﻿using System;
using System.Collections.Generic;
using UnityEngine;
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Libraries.Covalence;
using ConVar;
using Newtonsoft.Json.Linq;
using Oxide.Core.Libraries;
using System.Linq;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("IQReportSystem", "Mercury", "0.2.1")]
    class IQReportSystem : RustPlugin
    {
        /// <summary>
        /// - Поправил , когда игроки с меню в режиме оффлайн пропадали
        /// 
        /// Обновление 0.2.0 :
        /// - Исправлены страницы
        /// Обновление 0.2.1
        /// - Добавил проверку на игрока, есть ли он на сервере во время проверки на АФК
        /// - Полностью изменил проверку на АФК
        /// - Изменен метод с отслеживанием движения игрока на проверке
        /// - Добавлена проверка на актиность в чате в проверке на АФК
        /// - Добавлена проверка на использование команды в проверке на АФК
        /// - Добавлена поддержка NoEscape
        /// - Добавлена возможность запретить проверку игрока,если у него рейдблок
        /// </summary>

        #region Reference
        [PluginReference] Plugin GameWerAC, ImageLibrary, MultiFighting, IQChat, Friends, IQPersonal, IQFakeActive, NoEscape;
        public string GetImage(string shortname, ulong skin = 0) => (string)ImageLibrary?.Call("GetImage", shortname, skin);
        public bool AddImage(string url, string shortname, ulong skin = 0) => (bool)ImageLibrary?.Call("AddImage", url, shortname, skin);
        public void SetCheck(BasePlayer player) => IQPersonal?.CallHook("API_SET_CHECK", player.userID);
        public void SetBans(BasePlayer player) => IQPersonal?.CallHook("API_SET_BANS", player.userID);
        public void SetScore(ulong UserID, int Amount) => IQPersonal?.CallHook("API_SET_SCORE", UserID, Amount);
        public void RemoveScore(ulong UserID, int Amount) => IQPersonal?.CallHook("API_REMOVE_SCORE", UserID, Amount);
        public bool IsRaidBlocked(BasePlayer player)
        {
            if (NoEscape)
                return (bool)NoEscape?.Call("IsRaidBlocked", player);
            else return false;
        }

        #region IQFakeActive
        public bool IsFake(ulong userID)
        {
            if (!IQFakeActive) return false;
            if (!config.IQFakeActiveSettings.UseIQFakeActive) return false;

            return (bool)IQFakeActive?.Call("IsFake", userID);
        }
        public string FindFakeName(ulong userID) => (string)IQFakeActive?.Call("FindFakeName", userID);
        public void StartSysncFakeActive() => IQFakeActive?.Call("SyncReserved");
        void SyncReservedFinish(string JSON)
        {
            if (!config.IQFakeActiveSettings.UseIQFakeActive) return;
            List<FakePlayer> ContentDeserialize = JsonConvert.DeserializeObject<List<FakePlayer>>(JSON);
            PlayerBases = ContentDeserialize;

            PrintWarning("IQReportSystem - успешно синхронизирована с IQFakeActive");
            PrintWarning("=============SYNC==================");            
        }
        public List<FakePlayer> PlayerBases = new List<FakePlayer>();
        public class FakePlayer
        {
            public ulong UserID;
            public string DisplayName;
            public string IQChatPreifx;
            public string IQChatColorChat;
            public string IQChatColorNick;
        }
        #endregion

        #endregion

        #region Vars

        #region Permission
        string PermissionModeration = "iqreportsystem.moderation";
        string PermissionAdmin = "iqreportsystem.admin";
        #endregion

        #region Lists
        public Dictionary<ulong, int> CooldownPC = new Dictionary<ulong, int>();
        public Dictionary<ulong, PlayerSaveCheckClass> PlayerSaveCheck = new Dictionary<ulong, PlayerSaveCheckClass>();
        public class PlayerSaveCheckClass
        {
            public string Discord;
            public string NickName;
            public string StatusNetwork;

            public ulong ModeratorID;
        }
        #endregion

        #region JSON
        private class Response
        {
            public List<string> last_ip;
            public string last_nick;
            public List<ulong> another_accs;
            public List<last_checks> last_check;
            public class last_checks
            {
                public ulong moderSteamID;
                public string serverName;
                public int time;
            }
            public List<RustCCBans> bans;
            public class RustCCBans
            {
                public int banID;
                public string reason;
                public string serverName;
                public int OVHserverID;
                public int banDate;
            }
        }
        #endregion

        #endregion

        #region Configuration
        private static Configuration config = new Configuration();
        public class Configuration
        {
            [JsonProperty("Основные настройки")]
            public Settings Setting = new Settings();
            [JsonProperty("Причины репорта")]
            public List<string> ReasonReport = new List<string>();
            [JsonProperty("Причины блокировки")] 
            public List<BanReason> ReasonBan = new List<BanReason>();
            [JsonProperty("Настройки RustCheatCheck(Будет при проверке выдавать доступ в чекер и выводить информацию модератору)")]
            public RCCSettings RCCSetting = new RCCSettings();
            [JsonProperty("Настройка репутации для проверяющих")]
            public RaitingSettings RaitingSetting = new RaitingSettings();
            [JsonProperty("Настройка совместной работы с IQFakeActive")]
            public IQFakeActive IQFakeActiveSettings = new IQFakeActive();
            internal class BanReason
            {
                [JsonProperty("Название")]
                public string DisplayName;
                [JsonProperty("Команда")]
                public string Command;
            }
            internal class RCCSettings
            {
                [JsonProperty("Включить поддержку RCC")]
                public bool RCCUse;
                [JsonProperty("Ключ от RCC")]
                public string Key;
            }
            internal class RaitingSettings
            {
                [JsonProperty("Сколько репутации снимать за 1-2 звезды(IQPersonal)")]
                public int RemoveAmountOneTwo;
                [JsonProperty("Сколько репутации давать за 3-4 звезды(IQPersonal)")]
                public int GiveAmountThreeFour;
                [JsonProperty("Сколько репутации давать за 5 звезд(IQPersonal)")]
                public int GiveAmountFive;
            }
            internal class IQFakeActive
            {
                [JsonProperty("Использовать IQFakeActive")]
                public bool UseIQFakeActive;
            }
            internal class Settings
            {
                [JsonProperty("Настройки IQChat")]
                public ChatSettings ChatSetting = new ChatSettings();
                [JsonProperty("Настройки интерфейса")]
                public InterfaceSetting Interface = new InterfaceSetting();
                [JsonProperty("NoEscape: Перенести проверку игрока если у него есть рейдблок")]
                public bool NoEscapeCheckStop;

                [JsonProperty("Включить/отключить общее оповоещение для всех игроков(если игрока вызвали на проверку или вынесли вердикт,сообщение будет видно всем)")]
                public bool UseAlertUsers;

                [JsonProperty("Включить/отключить оповещение о максимальном кол-во репортов")]
                public bool MaxReportAlert;
                [JsonProperty("Максимальное количество репортов")]
                public int MaxReport;
                [JsonProperty("Перезарядка для отправки репорта(секунды)")]
                public int CooldownTime;
                [JsonProperty("Запретить друзьям репортить друг друга")]
                public bool FriendNoReport;
                [JsonProperty("Включить логирование в беседу ВК")]
                public bool VKMessage;
                [JsonProperty("Включить логирование в Discord")]
                public bool DiscrodMessage;
                [JsonProperty("Webhooks для дискорда")]
                public string WebHook;
                [JsonProperty("Настройки ВК")]
                public VKSetting VKSettings = new VKSetting();

                internal class ChatSettings
                {
                    [JsonProperty("IQChat : Кастомный префикс в чате")]
                    public string CustomPrefix;
                    [JsonProperty("IQChat : Кастомный аватар в чате(Если требуется)")]
                    public string CustomAvatar;
                }
                internal class VKSetting
                {
                    [JsonProperty("Токен от группы ВК(От группы будут идти сообщения в беседу.Вам нужно добавить свою группу в беседу!)")]
                    public string Token;
                    [JsonProperty("ID беседы для группы")]
                    public string ChatID;
                }
                internal class InterfaceSetting
                {
                    [JsonProperty("Настройка интерфейса для отправки жалобы")]
                    public ReasonInterfaceSetting ReasonInterface = new ReasonInterfaceSetting();
                    [JsonProperty("Настройка интерфейса для уведомления")]
                    public AlertInterfaceSettings AlertInterface = new AlertInterfaceSettings(); 
                    [JsonProperty("Настройка интерфейса для мини-панели модератора")]
                    public ModeratorPanelInterfaceSettings ModderatorPanel = new ModeratorPanelInterfaceSettings(); 
                    [JsonProperty("Настройка интерфейса для рейтинга")]
                    public RaitingInterfaceSettings RaitingInterface = new RaitingInterfaceSettings();
                    [JsonProperty("Sprite для рейтинга(звезды)")]
                    public string SpriteRaiting;
                    [JsonProperty("Sprite для кнопки жалоб в панели модератора")]
                    public string SpriteReportModeration;
                    [JsonProperty("Sprite для иконки жалоб")]
                    public string SpriteReport;
                    [JsonProperty("Цвет текста в плагине")]
                    public string HexLabels;
                    [JsonProperty("Цвет боковой панели")]
                    public string HexRightMenu;
                    [JsonProperty("Цвет кнопок боковой панели")]
                    public string HexButtonRightMenu;
                    [JsonProperty("Цвет основной панели")]
                    public string HexMainPanel;
                    [JsonProperty("Цвет панели поиска и заднего фона игроков")]
                    public string HexSearchPanel; 
                    [JsonProperty("Цвет кнопки у игрока для перехода к действию")]
                    public string HexPlayerButton;
                    [JsonProperty("Sprite кнопки у игрока для преехода к действию")]
                    public string SpritePlayerButton;

                    internal class ReasonInterfaceSetting
                    {
                        [JsonProperty("Цвет основной панели")]
                        public string HexMain;
                        [JsonProperty("Цвет панели с заголовком")]
                        public string HexTitlePanel;
                        [JsonProperty("Цвет жалоб")]
                        public string HexButton;
                        [JsonProperty("Цвет текста с жалобами")]
                        public string HexLabel;
                        [JsonProperty("Sprite кнопки закрыть")]
                        public string SpriteClose;             
                        [JsonProperty("Sprite панели с заголовком")]
                        public string SpriteTitlePanel;
                        [JsonProperty("Цвет кнопки закрыть")]
                        public string HexClose;
                    }
                    internal class AlertInterfaceSettings
                    {
                        [JsonProperty("Цвет основной панели")]
                        public string HexMain;
                        [JsonProperty("Цвет заголовка и полоски")]
                        public string HexTitle;
                        [JsonProperty("Цвет текста")]
                        public string HexLabel;
                    }
                    internal class ModeratorPanelInterfaceSettings
                    {
                        [JsonProperty("Цвет основной панели")]
                        public string HexMain;
                        [JsonProperty("Цвет панели с заголовком")]
                        public string HexTitlePanel;
                        [JsonProperty("Sprite панели с заголовком")]
                        public string SpriteTitlePanel;
                        [JsonProperty("Цвет текста")]
                        public string HexLabel;
                        [JsonProperty("Цвет кнопки вердикт и задний фон причин")]
                        public string HexBanButton;
                        [JsonProperty("Цвет кнопки окончания проверки")]
                        public string HexStopButton;
                    }
                    internal class RaitingInterfaceSettings
                    {
                        [JsonProperty("Цвет основной панели")]
                        public string HexMain;
                        [JsonProperty("Цвет панели с заголовком")]
                        public string HexTitlePanel;
                        [JsonProperty("Sprite панели с заголовком")]
                        public string SpriteTitlePanel;
                        [JsonProperty("Цвет текста")]
                        public string HexLabel;
                        [JsonProperty("Цвет иконок с рейтингом")]
                        public string HexRaitingButton;
                        [JsonProperty("Sprite рейтинга")]
                        public string SpriteRaiting;
                    }
                }
            }

            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    Setting = new Settings
                    {
                        NoEscapeCheckStop = false,
                        UseAlertUsers = true,
                        FriendNoReport = false,
                        MaxReport = 3,
                        MaxReportAlert = true,
                        CooldownTime = 600,
                        VKMessage = true,
                        DiscrodMessage = false,
                        WebHook = "",
                        ChatSetting = new Settings.ChatSettings
                        {
                            CustomAvatar = "",
                            CustomPrefix = ""
                        },
                        VKSettings = new Settings.VKSetting
                        {
                            Token = "",
                            ChatID = ""
                        },
                        Interface = new Settings.InterfaceSetting
                        {
                            SpriteRaiting = "assets/icons/favourite_servers.png",
                            SpriteReportModeration = "assets/icons/subtract.png",
                            SpriteReport = "assets/icons/examine.png",
                            SpritePlayerButton = "assets/icons/vote_up.png",
                            HexPlayerButton = "#45542BFF",
                            HexLabels = "#DAD1C7FF",
                            HexButtonRightMenu = "#802A2AFF",
                            HexMainPanel = "#21211AF2",
                            HexRightMenu = "#762424FF",
                            HexSearchPanel = "#3B3D37FF",
                            ReasonInterface = new Settings.InterfaceSetting.ReasonInterfaceSetting
                            {
                                HexMain = "#585450FF",
                                HexTitlePanel = "#54514DFF",
                                HexButton = "#3E482EFF",
                                HexClose = "#B4371EFF",
                                HexLabel = "#bdd197",
                                SpriteClose = "assets/icons/vote_down.png",
                                SpriteTitlePanel = "assets/icons/connection.png"
                            },
                            AlertInterface = new Settings.InterfaceSetting.AlertInterfaceSettings
                            {
                                HexMain = "#21211AF2",
                                HexLabel = "#DAD1C7FF",
                                HexTitle = "#B4371EFF",
                            },
                            ModderatorPanel = new Settings.InterfaceSetting.ModeratorPanelInterfaceSettings
                            {
                                HexMain = "#575450FF",
                                HexTitlePanel = "#54514DFF",
                                HexLabel = "#DAD1C7FF",
                                SpriteTitlePanel = "assets/icons/study.png",
                                HexBanButton = "#B4371EFF",
                                HexStopButton = "#3E482EFF"
                            },
                            RaitingInterface = new Settings.InterfaceSetting.RaitingInterfaceSettings
                            {
                                HexMain = "#575450FF",
                                HexTitlePanel = "#54514DFF",
                                HexLabel = "#DAD1C7FF",
                                HexRaitingButton = "#cdb980",
                                SpriteTitlePanel = "assets/icons/ignite.png",
                                SpriteRaiting = "assets/icons/favourite_servers.png"
                            }
                        }
                    },
                    ReasonReport = new List<string>
                    {
                        "Использование читов",
                        "Макросы",
                        "Игра 3+",                      
                    },
                    ReasonBan = new List<BanReason>
                    { 
                        new BanReason
                        {
                            DisplayName = "Использование читов",
                            Command = "ban {0} soft",
                        },
                        new BanReason
                        {
                            DisplayName = "Макросы",
                            Command = "ban {0} 30d macros",
                        },
                        new BanReason
                        {
                            DisplayName = "Игра 3+",
                            Command = "ban {0} 14d 3+",
                        },
                        new BanReason
                        {
                            DisplayName = "Отказ",
                            Command = "ban {0} 7d otkaz",
                        },
                    },
                    RCCSetting = new RCCSettings
                    {
                        RCCUse = false,
                        Key = "xxxxxxxxxxxxxxRCCKey",
                    },
                    IQFakeActiveSettings = new IQFakeActive
                    {
                      UseIQFakeActive = false,
                    },
                    RaitingSetting = new RaitingSettings
                    {
                        RemoveAmountOneTwo = 4,
                        GiveAmountThreeFour = 3,
                        GiveAmountFive = 5
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Ошибка чтения конфигурации #93 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region Data
        public Dictionary<ulong, PlayerInfo> ReportInformation = new Dictionary<ulong, PlayerInfo>();
        public Dictionary<ulong, ModeratorInfo> ModeratorInformation = new Dictionary<ulong, ModeratorInfo>();
        public class PlayerInfo
        {
            [JsonProperty("Отображаемое имя")]
            public string DisplayName;
            [JsonProperty("IP Адреса")]
            public List<string> IP;
            [JsonProperty("Последняя жалоба")]
            public string LastReport;
            [JsonProperty("Последний проверяющий модератор")]
            public string LastCheckModerator;
            [JsonProperty("Количество проверок")]
            public int CheckCount;
            [JsonProperty("История жалоб")]
            public List<string> ReportHistory;
            [JsonProperty("Количество жалоб")]
            public int ReportCount;
            [JsonProperty("Игровой статус")]
            public string GameStatus;
        }

        public class ModeratorInfo
        {
            [JsonProperty("Проверки игроков с вердиктами")]
            public Dictionary<string, string> CheckPlayerModerator = new Dictionary<string, string>();
            [JsonProperty("Блокировки игроков с вердиктом")]
            public Dictionary<string, string> BanPlayerModerator = new Dictionary<string, string>();
            [JsonProperty("Общее количество проверок")]
            public int CheckCount;
            [JsonProperty("История оценок модератора")]
            public List<int> Arrayrating;
            [JsonProperty("Средняя оценка качества")]
            public float AverageRating;
        }
        #endregion

        #region Metods

        #region MetodsReport

        void Metods_PlayerConnected(BasePlayer player)
        {
            if (player == null)
                return;
            if (!ReportInformation.ContainsKey(player.userID))
            {
                PlayerInfo pInfo = new PlayerInfo
                {
                    DisplayName = player.displayName,
                    IP = new List<string>(),
                    LastReport = "",
                    LastCheckModerator = "",
                    CheckCount = 0,
                    ReportCount = 0,
                    GameStatus = IsSteam(player.UserIDString),
                    ReportHistory = new List<string>(),
                };
                ReportInformation.Add(player.userID, pInfo);
            }
            else
            {
                var User = ReportInformation[player.userID];
                var IP = covalence.Players.FindPlayerById(player.UserIDString).Address;

                User.GameStatus = IsSteam(player.UserIDString);
                if (!String.IsNullOrWhiteSpace(IP))
                    if (!User.IP.Contains(IP))
                        User.IP.Add(IP);
            }

            if (permission.UserHasPermission(player.UserIDString, PermissionModeration))
            {
                if (!ModeratorInformation.ContainsKey(player.userID))
                {
                    ModeratorInfo mInfo = new ModeratorInfo
                    {
                        CheckCount = 0,
                        BanPlayerModerator = new Dictionary<string, string>(),
                        CheckPlayerModerator = new Dictionary<string, string>(),
                        Arrayrating = new List<int>(),
                        AverageRating = 0,
                    };
                    ModeratorInformation.Add(player.userID, mInfo);
                }
            }
            else
            {
                if (ModeratorInformation.ContainsKey(player.userID))
                    ModeratorInformation.Remove(player.userID);
            }
            Metods_StatusNetwork(player, lang.GetMessage("NETWORD_STATUS_ONLINE", this, player.UserIDString));
        }

        void Metods_Report(BasePlayer target, int ReasonIndex)
        {
            if (permission.UserHasPermission(target.UserIDString, PermissionAdmin))
                return;

            if (IsSteam(target.UserIDString) == lang.GetMessage("IS_STEAM_STATUS_PIRATE", this, target.UserIDString))
            {
                if (GameWerAC != null)
                {
                    GameWerAC.Call("GetScreenReport", target);
                    Puts("Выполнен скриншот экрана для пирата");
                }
            }

            string ReasonReport = config.ReasonReport[ReasonIndex];

            var User = ReportInformation[target.userID];
            User.ReportCount++;
            User.LastReport = ReasonReport;
            User.ReportHistory.Insert(0, ReasonReport);

            if (config.Setting.MaxReportAlert)
                if (User.ReportCount >= config.Setting.MaxReport)
                {
                    foreach (var MList in BasePlayer.activePlayerList)
                        if (permission.UserHasPermission(MList.UserIDString, PermissionModeration))
                            SendChat(MList, String.Format(lang.GetMessage("METODS_HELP_MODERS", this, MList.UserIDString), target.displayName, User.ReportCount));
                    VKSendMessage(String.Format(lang.GetMessage("METODS_HELP_MODERS_VK", this), target.displayName, User.ReportCount));
                    DiscordSendMessage(String.Format(lang.GetMessage("METODS_HELP_MODERS_VK", this), target.displayName, User.ReportCount));
                }
        }

        #endregion

        #region MetodsCooldown
        void Metods_GiveCooldown(ulong ID,  int cooldown)
        {
            CooldownPC[ID] = cooldown + (int)CurrentTime();          
        }

        bool Metods_GetCooldown(ulong ID)
        {
            if (!CooldownPC.ContainsKey(ID) || Math.Max(0, CooldownPC[ID]) < 1 || CooldownPC[ID] <= (int)CurrentTime())
                return false;
            else return true;
        }

        #endregion

        #region MetodsModeration

        void Metods_CheckModeration(BasePlayer Suspect, BasePlayer Moderator)
        {
            if (PlayerSaveCheck.ContainsKey(Suspect.userID))
            {
                SendChat(Moderator, lang.GetMessage("PLAYER_CHECKED", this));
                return;
            }
            if(config.Setting.NoEscapeCheckStop)
                if(IsRaidBlocked(Suspect))
                {
                    SendChat(Moderator, lang.GetMessage("RAID_BLOCK_TRUE_STOP", this, Moderator.UserIDString));
                    return;
                }
            else PlayerSaveCheck.Add(Suspect.userID, new PlayerSaveCheckClass
            {
                Discord = lang.GetMessage("DISCORD_NULL", this),
                NickName = Suspect.displayName,
                StatusNetwork = lang.GetMessage("NETWORD_STATUS_ONLINE", this, Suspect.UserIDString),

                ModeratorID = Moderator.userID,
            });
            SendChat(Moderator, String.Format(lang.GetMessage("METODS_MODER_START_CHECK",this, Moderator.UserIDString),Suspect.displayName));
            VKSendMessage(String.Format(lang.GetMessage("METODS_MODER_START_CHECK_VK", this),Moderator.displayName,Moderator.UserIDString,Suspect.displayName,Suspect.UserIDString));           
            Metods_AFK(Suspect.userID, Moderator);

            if(config.Setting.UseAlertUsers)
                foreach(var p in BasePlayer.activePlayerList)
                    SendChat(p, String.Format(lang.GetMessage("METODS_MODER_START_CHECK_VK", this, p.UserIDString), Moderator.displayName, Moderator.UserIDString, Suspect.displayName, Suspect.UserIDString));
        }

        void Metods_CheckModerationFinish(BasePlayer moderator, ulong SuspectID)
        {
            IPlayer Suspect = covalence.Players.FindPlayerById(SuspectID.ToString());
            if (Suspect.IsConnected)
            {
                BasePlayer SOnline = BasePlayer.FindByID(ulong.Parse(Suspect.Id));
                CuiHelper.DestroyUi(SOnline, PARENT_UI_ALERT_SEND);
                SendChat(SOnline, lang.GetMessage("MSG_CHECK_CHECK_STOP", this, moderator.UserIDString));
            }

            CuiHelper.DestroyUi(moderator, PARENT_UI_MODERATOR_MINI_PANEL);
            PlayerSaveCheck.Remove(ulong.Parse(Suspect.Id));

            var User = ReportInformation[ulong.Parse(Suspect.Id)];
            var Moderator = ModeratorInformation[moderator.userID];

            Moderator.CheckCount++;
            if (!Moderator.CheckPlayerModerator.ContainsKey(Suspect.Name))
                Moderator.CheckPlayerModerator.Add(Suspect.Name, User.LastReport);

            User.ReportCount = 0;
            User.ReportHistory.Clear();
            User.LastReport = lang.GetMessage("NON_REPORT",this);
            User.CheckCount++;
            User.LastCheckModerator = moderator.displayName;

            SendChat(moderator, lang.GetMessage("METODS_MODER_STOP_CHECK",this, moderator.UserIDString));
            VKSendMessage(String.Format(lang.GetMessage("METODS_MODER_STOP_CHECK_VK",this),moderator.displayName));
            DiscordSendMessage(String.Format(lang.GetMessage("METODS_MODER_STOP_CHECK_VK",this),moderator.displayName));
            SetCheck(moderator);

            if (config.Setting.UseAlertUsers)
                foreach (var p in BasePlayer.activePlayerList)
                    SendChat(p, String.Format(lang.GetMessage("METODS_MODER_STOP_CHECK_ALERT", this, p.UserIDString), moderator.displayName, Suspect.Name));
        }

        void Metods_StatusNetwork(BasePlayer Suspect, string Reason)
        {
            if (Suspect == null) return;
            if (PlayerSaveCheck.ContainsKey(Suspect.userID))
            {
                if (Suspect.IsConnected)
                    if (Suspect.IsReceivingSnapshot)
                    {
                        timer.Once(3, () => Metods_StatusNetwork(Suspect, lang.GetMessage("NETWORD_STATUS_ONLINE", this, Suspect.UserIDString)));
                        return;
                    }

                PlayerSaveCheck[Suspect.userID].StatusNetwork = Reason;
                BasePlayer Moderator = BasePlayer.FindByID(PlayerSaveCheck[Suspect.userID].ModeratorID);

                CuiHelper.DestroyUi(Moderator, UI_MODERATION_CHECK_MENU_NETWORK);
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.6782616 0.5478261", AnchorMax = "0.9884076 0.7333333" },
                    Text = { Text = $"{PlayerSaveCheck[Suspect.userID].StatusNetwork}", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.UpperCenter, Color = HexToRustFormat("#FFFFFFFF") }
                }, PARENT_UI_MODERATOR_MINI_PANEL, UI_MODERATION_CHECK_MENU_NETWORK);

                CuiHelper.AddUi(Moderator, container);
                UI_AlertSendPlayer(Suspect);             

                SendChat(Moderator, String.Format(lang.GetMessage("STATUS_CHANGED", this, Moderator.UserIDString), Suspect.displayName, Reason));
                VKSendMessage(String.Format(lang.GetMessage("STATUS_CHANGED_VK", this), Suspect.displayName, Reason));
                DiscordSendMessage(String.Format(lang.GetMessage("STATUS_CHANGED_VK", this), Suspect.displayName, Reason));
            }
        }

        public Timer ModerTimeOutTimer;
        void Metods_ModeratorExitCheck(BasePlayer Moderator)
        {
            foreach (var ModeratorCritical in PlayerSaveCheck)
                if (ModeratorCritical.Value.ModeratorID == Moderator.userID)
                {
                    IPlayer ModeratorOffline = covalence.Players.FindPlayerById(ModeratorCritical.Value.ModeratorID.ToString());
                    IPlayer Suspect = covalence.Players.FindPlayerById(ModeratorCritical.Key.ToString());
                    int TimeOutCount = 0;
                    ModerTimeOutTimer = timer.Repeat(5, 10, () =>
                        {
                            if (ModeratorOffline.IsConnected)
                            {
                                UI_MiniPanelModerator(Moderator, ModeratorCritical.Key);
                                SendChat(Moderator, lang.GetMessage("MODERATOR_RETURN_WELCOME",this, Moderator.UserIDString));
                                if (ModerTimeOutTimer != null)
                                {
                                    ModerTimeOutTimer.Destroy();
                                    ModerTimeOutTimer = null;
                                }
                                return;
                            }
                            else
                            {
                                TimeOutCount++;
                                if (TimeOutCount >= 10)
                                {
                                    PlayerSaveCheck.Remove(ModeratorCritical.Key);

                                    foreach (var OnlineModeration in BasePlayer.activePlayerList)
                                        if (permission.UserHasPermission(OnlineModeration.UserIDString, PermissionModeration))
                                            if (Suspect.IsConnected)
                                            {                                             
                                                BasePlayer SOnline = BasePlayer.FindByID(ulong.Parse(Suspect.Id));
                                                CuiHelper.DestroyUi(SOnline, PARENT_UI_ALERT_SEND);
                                           
                                                SendChat(SOnline, String.Format(lang.GetMessage("MODERATOR_DISCONNECTED_STOP_CHECK",this, Moderator.UserIDString),ModeratorOffline.Name));
                                                SendChat(OnlineModeration, String.Format(lang.GetMessage("MODERATOR_DISCONNECTED_STOP_RESEND",this, Moderator.UserIDString),ModeratorOffline.Name,Suspect.Name));
                                                VKSendMessage(String.Format(lang.GetMessage("MODERATOR_DISCONNECTED_STOP_RESEND", this), ModeratorOffline.Name, Suspect.Name));
                                                DiscordSendMessage(String.Format(lang.GetMessage("MODERATOR_DISCONNECTED_STOP_RESEND", this), ModeratorOffline.Name, Suspect.Name));

                                                if (ModerTimeOutTimer != null)
                                                {
                                                    ModerTimeOutTimer.Destroy();
                                                    ModerTimeOutTimer = null;
                                                }
                                            }
                                    return;
                                }
                            }
                        });

                }
        }

        void Metods_ModeratorBanned(BasePlayer Moderator,ulong SuspectID, int i)
        {
            CuiHelper.DestroyUi(Moderator, PARENT_UI_MODERATOR_MINI_PANEL);
            IPlayer Suspect = covalence.Players.FindPlayerById(SuspectID.ToString());
            string Reason = config.ReasonBan[i].DisplayName;

            rust.RunClientCommand(Moderator, String.Format(config.ReasonBan[i].Command, SuspectID));
            PlayerSaveCheck.Remove(SuspectID);

            var ModeratorInfo = ModeratorInformation[Moderator.userID];
            ModeratorInfo.CheckCount++;
            if (!ModeratorInfo.CheckPlayerModerator.ContainsKey(Suspect.Name))
                ModeratorInfo.CheckPlayerModerator.Add(Suspect.Name, Reason);
            if (!ModeratorInfo.BanPlayerModerator.ContainsKey(Suspect.Name))
                ModeratorInfo.BanPlayerModerator.Add(Suspect.Name, Reason);

            SendChat(Moderator, String.Format(lang.GetMessage("MODERATOR_COMPLETED_CHECK", this, Moderator.UserIDString), Reason));
            VKSendMessage(String.Format(lang.GetMessage("MODERATOR_COMPLETED_CHECK_VK", this), Moderator.displayName, Moderator.UserIDString, Suspect.Name, SuspectID, Reason, AFKCheckedTry[SuspectID]));
            DiscordSendMessage(String.Format(lang.GetMessage("MODERATOR_COMPLETED_CHECK_VK", this), Moderator.displayName, Moderator.UserIDString, Suspect.Name, SuspectID, Reason, AFKCheckedTry[SuspectID]));
            SetBans(Moderator);

            if (config.Setting.UseAlertUsers)
                foreach (var p in BasePlayer.activePlayerList)
                    SendChat(p, String.Format(lang.GetMessage("MODERATOR_COMPLETED_CHECK_ALERT", this, p.UserIDString), Moderator.displayName, Suspect.Name, Reason));
        }

        #endregion

        #region MetodsAFK
        void Metods_CheckStopInAFK(BasePlayer moderator, string ID)
        {
            IPlayer Suspect = covalence.Players.FindPlayerById(ID);
            if (Suspect.IsConnected)
            {
                BasePlayer SOnline = BasePlayer.FindByID(ulong.Parse(Suspect.Id));
                CuiHelper.DestroyUi(SOnline, PARENT_UI_ALERT_SEND);
            }
            CuiHelper.DestroyUi(moderator, PARENT_UI_MODERATOR_MINI_PANEL);
            PlayerSaveCheck.Remove(ulong.Parse(Suspect.Id));

            SendChat(moderator, lang.GetMessage("PLAYER_AFK_CHECK_STOP",this));
            VKSendMessage(String.Format(lang.GetMessage("PLAYER_AFK_CHECK_STOP_VK", this), moderator.displayName, moderator.userID, Suspect.Name));
            DiscordSendMessage(String.Format(lang.GetMessage("PLAYER_AFK_CHECK_STOP_VK", this), moderator.displayName, moderator.userID, Suspect.Name));
        }

        public Dictionary<ulong, GenericPosition> AFKPositionTry = new Dictionary<ulong, GenericPosition>();
        public Dictionary<ulong, int> AFKCheckedTry = new Dictionary<ulong, int>();
        void Metods_AFK(ulong SuspectID, BasePlayer Moderator)
        {
            IPlayer Suspect = covalence.Players.FindPlayerById(SuspectID.ToString());
            if (!AFKCheckedTry.ContainsKey(SuspectID))
                AFKCheckedTry.Add(SuspectID, 0);
            else AFKCheckedTry[SuspectID] = 0;

            StartAFKCheck(Suspect, Moderator);
        }
        public void StartAFKCheck(IPlayer Suspect, BasePlayer Moderator)
        {
            ulong SuspectID = ulong.Parse(Suspect.Id);
            var Postion = Suspect.Position();

            if (!AFKPositionTry.ContainsKey(SuspectID))
                AFKPositionTry.Add(SuspectID, Postion);

            int Try = 1;
            timer.Repeat(5f, 5, () =>
            {
                Postion = Suspect.Position();
                if (AFKPositionTry[SuspectID] != Postion)
                {
                    SendChat(Moderator, String.Format(lang.GetMessage("PLAYER_AFK_CHANGE_POS", this, Moderator.UserIDString), Try));
                    AFKCheckedTry[SuspectID]++;
                }
                else SendChat(Moderator, String.Format(lang.GetMessage("PLAYER_AFK_CHANGE_NO_POS", this, Moderator.UserIDString), Try));

                AFKPositionTry[SuspectID] = Postion;
                Try++;
            });
            timer.Once(30f, () =>
            {
                if(AFKCheckedTry[SuspectID] < 3)
                  Metods_CheckStopInAFK(Moderator, Suspect.Id);
                else
                {
                    BasePlayer SuspectOnline = BasePlayer.FindByID(ulong.Parse(Suspect.Id));
                    if (SuspectOnline == null || !SuspectOnline.IsConnected)
                    {
                        SendChat(Moderator, lang.GetMessage("PLAYER_LEAVE_AFK_METOD", this, Moderator.UserIDString));
                        CuiHelper.DestroyUi(Moderator, PARENT_UI_MODERATOR_MINI_PANEL);
                        if (PlayerSaveCheck.ContainsKey(SuspectID))
                            PlayerSaveCheck.Remove(SuspectID);
                        return;
                    }
                    UI_AlertSendPlayer(SuspectOnline);
                    PlayerSaveCheck = new Dictionary<ulong, PlayerSaveCheckClass>
                    {
                        [SuspectOnline.userID] = new PlayerSaveCheckClass
                        {
                            Discord = lang.GetMessage("DISCORD_NULL", this),
                            NickName = SuspectOnline.displayName,
                            StatusNetwork = lang.GetMessage("NETWORD_STATUS_ONLINE", this, SuspectOnline.UserIDString),

                            ModeratorID = Moderator.userID,
                        }
                    };
                    UI_MiniPanelModerator(Moderator, SuspectOnline.userID);
                    SendChat(Moderator, lang.GetMessage("PLAYER_NON_AFK", this, Moderator.UserIDString));

                    if (config.RCCSetting.RCCUse)
                    {
                        string Key = config.RCCSetting.Key;
                        if (String.IsNullOrEmpty(Key)) return;
                        try
                        {
                            string API = $"https://rustcheatcheck.ru/panel/api?action=addPlayer&key={Key}&player={Suspect.Id}";
                            webrequest.Enqueue(API, null, (code, response) => { }, this);
                        }
                        catch { }
                    }
                }
                if (AFKCheckedTry.ContainsKey(SuspectID))
                    AFKCheckedTry.Remove(SuspectID);
            });
        }
        #endregion

        #endregion

        #region Command

        #region UseCommand
        [ChatCommand("report")]
        void ReportChatCommand(BasePlayer player, string command, string[] args)
        {
            if (player == null)
                return;

            if (args == null || args.Length == 0)
            {
                UI_Interface(player);
                return;
            }
        }

        [ConsoleCommand("report.list")]
        void ReportList(ConsoleSystem.Arg arg)
        {
            PrintError(lang.GetMessage("REPORT_LIST_CONSOLE",this));
            foreach (var List in BasePlayer.activePlayerList)
                if (ReportInformation[List.userID].ReportCount >= config.Setting.MaxReport)
                    PrintError($"{List.displayName} : {ReportInformation[List.userID].ReportCount}");

        }

        [ChatCommand("discord")]
        void SendDiscord(BasePlayer Suspect, string command, string[] args)
        {
            if (!PlayerSaveCheck.ContainsKey(Suspect.userID))
            {
                SendChat(Suspect, lang.GetMessage("MSG_CHECK_DISCORD", this, Suspect.UserIDString));
                return;
            }
            string Discord = "";
            foreach (var arg in args)
                Discord += " " + arg;

            PlayerSaveCheck[Suspect.userID].Discord = Discord;

            SendChat(Suspect, String.Format(lang.GetMessage("MSG_DISCORD_SEND", this, Suspect.UserIDString),Discord));
            VKSendMessage(String.Format(lang.GetMessage("DISCROD_VK_SEND", this), Suspect.displayName, Suspect.userID, Discord));
            DiscordSendMessage(String.Format(lang.GetMessage("DISCROD_VK_SEND", this), Suspect.displayName, Suspect.userID, Discord));

            BasePlayer Moderator = BasePlayer.FindByID(PlayerSaveCheck[Suspect.userID].ModeratorID);
            CuiHelper.DestroyUi(Moderator, UI_MODERATION_CHECK_MENU_DISCORD);
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.01159436 0.5478261", AnchorMax = "0.7072465 0.7333333" },
                Text = { Text = $"Discord : {PlayerSaveCheck[Suspect.userID].Discord}", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.UpperCenter, Color = HexToRustFormat("#FFFFFFFF") }
            }, PARENT_UI_MODERATOR_MINI_PANEL, UI_MODERATION_CHECK_MENU_DISCORD);

            CuiHelper.AddUi(Moderator, container);
        }
       
        [ConsoleCommand("call")]
        void CallAdminCheck(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (!player.IsAdmin) return;
            ulong SuspectID = ulong.Parse(arg.Args[0]);
            if(player == null)
            {
                PrintWarning("Вы должны быть на сервере");
                SendChat(player, "Вы должны быть на сервере");
                return;
            }
            BasePlayer Suspect = BasePlayer.FindByID(SuspectID);
            if(Suspect == null)
            {
                PrintWarning("Игрока нет");
                SendChat(player, "Игрока нет");
                return;
            }
            Metods_CheckModeration(Suspect, player);
            Puts("Вы вызвали игрока на проверку"); 
            SendChat(player, "Вы вызвали игрока на проверку");
        }

        [ConsoleCommand("report")]
        void ReportCommand(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();

            if (arg == null || arg.Args == null || arg.Args.Length == 0)
            {
                if (player == null) return;
                UI_Interface(player);
                return;
            }

            switch (arg.Args[0].ToLower())
            {
                case "give":
                    {
                        if (arg.Args.Length != 3)
                        {
                            PrintWarning("Используйте правильный синтаксис : report give SteamID Amount");
                            return;
                        }
                        if (string.IsNullOrWhiteSpace(arg.Args[1]))
                        {
                            PrintWarning("Укажите корректный Steam64ID");
                            return;
                        }
                        if (!arg.Args[1].IsSteamId())
                        {
                            PrintWarning("Укажите корректный Steam64ID");
                            return;
                        }
                        if (string.IsNullOrWhiteSpace(arg.Args[2]))
                        {
                            PrintWarning("Укажите корректное количество");
                            return;
                        }

                        ReportInformation[ulong.Parse(arg.Args[1])].ReportCount += Convert.ToInt32(arg.Args[2]);
                        if (player != null)
                        {
                            VKSendMessage(String.Format(lang.GetMessage("CONSOLE_REPORT_GIVE", this), arg.Args[1], arg.Args[2], ReportInformation[ulong.Parse(arg.Args[1])].ReportCount));
                            DiscordSendMessage(String.Format(lang.GetMessage("CONSOLE_REPORT_GIVE", this), arg.Args[1], arg.Args[2], ReportInformation[ulong.Parse(arg.Args[1])].ReportCount));
                        }
                        PrintWarning("ACCESS");
                        return;
                    }
                case "remove":
                    {
                        if (arg.Args.Length != 3)
                        {
                            PrintWarning("Используйте правильный синтаксис : report remove SteamID Amount");
                            return;
                        }
                        if (string.IsNullOrWhiteSpace(arg.Args[1]))
                        {
                            PrintWarning("Укажите корректный Steam64ID");
                            return;
                        }
                        if (!arg.Args[1].IsSteamId())
                        {
                            PrintWarning("Укажите корректный Steam64ID");
                            return;
                        }
                        if (string.IsNullOrWhiteSpace(arg.Args[2]))
                        {
                            PrintWarning("Укажите корректное количество");
                            return;
                        }
                        ReportInformation[ulong.Parse(arg.Args[1])].ReportCount -= Convert.ToInt32(arg.Args[2]);
                        if (player != null)
                        {
                            VKSendMessage(String.Format(lang.GetMessage("CONSOLE_REPORT_REMOVE", this), arg.Args[1], arg.Args[2], ReportInformation[ulong.Parse(arg.Args[1])].ReportCount));
                        }
                        PrintWarning("ACCESS");
                        return;
                    }
            }
        }

        #endregion

        #region FuncCommand
        [ConsoleCommand("iqreport")]
        void IQReportSystemCommands(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            string Key = arg.Args[0].ToLower();

            switch (Key)
            {
                case "page":
                    {
                        string PageAction = arg.Args[1];
                        bool Moderation = Convert.ToBoolean(arg.Args[2]);
                        int Page = Convert.ToInt32(arg.Args[3]);
                        switch (PageAction)
                        {
                            case "next":
                                {
                                    PrintError($"{Page}");
                                    UI_Player_Loaded(player, Moderation, Page + 1);
                                    break;
                                }
                            case "back":
                                {
                                    PrintError($"{Page}");

                                    UI_Player_Loaded(player, Moderation, Page - 1);
                                    break;
                                }
                        }
                        break;
                    };
                case "moderation_menu":
                    {
                        UI_PanelReportsPlayer(player, true);
                        break;
                    };
                case "reports_menu":
                    {
                        //  int BaseID = int.Parse(arg.Args[1]);
                        
                        ulong UserID = ulong.Parse(arg.Args[1]);
                        UI_SendReport(player, UserID);
                        break;
                    }
                case "moderation_send":
                    {
                        ulong SuspectID = ulong.Parse(arg.Args[1]);
                        BasePlayer Suspect = BasePlayer.FindByID(SuspectID);

                        UI_ModerReport(player, Suspect);
                        break;
                    }
                case "send_report":
                    {
                        ulong SuspectID = ulong.Parse(arg.Args[1]);
                        int IndexReason = Convert.ToInt32(arg.Args[2]);
                        string ReasonReport = config.ReasonReport[IndexReason];

                        if (player == null) return;
                        CuiHelper.DestroyUi(player, PARENT_UI);

                        if (Metods_GetCooldown(player.userID) == true)
                        {
                            SendChat(player, String.Format(lang.GetMessage("MSG_COOLDOWN", this, player.UserIDString), FormatTime(TimeSpan.FromSeconds(Math.Max(0, CooldownPC[player.userID] - CurrentTime())))));
                            return;
                        }
                        
                        if(IsFake(SuspectID))
                        {
                            Metods_GiveCooldown(player.userID, config.Setting.CooldownTime);
                            SendChat(player, String.Format(lang.GetMessage("MSG_REPORTED_SUSPECT", this, player.UserIDString), FindFakeName(SuspectID), ReasonReport));
                            return;
                        }
                        BasePlayer Suspect = BasePlayer.FindByID(SuspectID);
                        if (Suspect == null) return;

                        Metods_Report(Suspect, IndexReason);
                        Metods_GiveCooldown(player.userID, config.Setting.CooldownTime);
                        SendChat(player, String.Format(lang.GetMessage("MSG_REPORTED_SUSPECT", this, player.UserIDString), Suspect.displayName, ReasonReport));
                        VKSendMessage(String.Format(lang.GetMessage("METODS_SEND_REPORT_VK", this), Suspect.displayName, Suspect.UserIDString, ReasonReport, player.displayName, player.userID));
                        DiscordSendMessage(String.Format(lang.GetMessage("METODS_SEND_REPORT_VK", this), Suspect.displayName, Suspect.UserIDString, ReasonReport, player.displayName, player.userID));
                        break;
                    }
                case "search":
                    {
                        if (arg.Args.Length != 4) return;

                        bool Moderation = Convert.ToBoolean(arg.Args[1]);
                        int Page = Convert.ToInt32(arg.Args[2]);
                        string SearchSay = arg.Args[3];

                        UI_Player_Loaded(player, Moderation, Page, SearchSay);
                        break;
                    }
                case "send_check":
                    {
                        if (player == null) return;
                        ulong SuspectID = ulong.Parse(arg.Args[1]);
                        BasePlayer Suspect = BasePlayer.FindByID(SuspectID);
                        if (permission.UserHasPermission(player.UserIDString, PermissionModeration))
                            Metods_CheckModeration(Suspect, player);

                        break;
                    }
                case "moderator_reason_ban":
                    {
                        if (player == null) return;
                        ulong SuspectID = ulong.Parse(arg.Args[1]);
                        BasePlayer Suspect = BasePlayer.FindByID(SuspectID);
                        if (permission.UserHasPermission(player.UserIDString, PermissionModeration))
                            UI_OpenReasonsBan(player, SuspectID);
                        break;
                    }
                case "moderator_ban":
                    {
                        if (player == null) return;
                        ulong SuspectID = ulong.Parse(arg.Args[1]);
                        BasePlayer Suspect = BasePlayer.FindByID(SuspectID);
                        int Index = Convert.ToInt32(arg.Args[2]);
                        Metods_ModeratorBanned(player, SuspectID, Index);
                        break;
                    }
                case "moderator_stop":
                    {
                        if (player == null) return;
                        ulong SuspectID = ulong.Parse(arg.Args[1]);
                        BasePlayer Suspect = BasePlayer.FindByID(SuspectID);
                        if (permission.UserHasPermission(player.UserIDString, PermissionModeration))
                            Metods_CheckModerationFinish(player, SuspectID);
                        UI_RaitingSend(Suspect, player);
                        return;
                    }
                case "raiting": 
                    {
                        BasePlayer Moderator = BasePlayer.FindByID(ulong.Parse(arg.Args[1]));
                        int Raiting = Convert.ToInt32(arg.Args[2]);
                        var RaitingModerator = ModeratorInformation[Moderator.userID].Arrayrating;

                        VKSendMessage(String.Format(lang.GetMessage("UI_RAITING_MODERATION_VK_GIVE", this), player.displayName, player.UserIDString, Moderator.displayName, Moderator.UserIDString, Raiting));
                        DiscordSendMessage(String.Format(lang.GetMessage("UI_RAITING_MODERATION_VK_GIVE", this), player.displayName, player.UserIDString, Moderator.displayName, Moderator.UserIDString, Raiting));
                        SendChat(player, lang.GetMessage("UI_RAITING_MODERATION_VK_GIVE_THX", this, player.UserIDString));

                        RaitingModerator.Add(Raiting);

                        if (Raiting <= 2)
                        {
                            RemoveScore(Moderator.userID, config.RaitingSetting.RemoveAmountOneTwo);
                            SendChat(Moderator, String.Format(lang.GetMessage("UI_RAIT_ALERT_MODER", this, Moderator.UserIDString), Raiting, $"-{config.RaitingSetting.RemoveAmountOneTwo}"));
                            return;
                        }
                        if (Raiting > 2 && Raiting < 5)
                        {
                            SetScore(Moderator.userID, config.RaitingSetting.GiveAmountThreeFour);
                            SendChat(Moderator, String.Format(lang.GetMessage("UI_RAIT_ALERT_MODER", this, Moderator.UserIDString), Raiting, $"{config.RaitingSetting.GiveAmountThreeFour}"));
                            return;
                        }
                        if (Raiting >= 5)
                        {
                            SetScore(Moderator.userID, config.RaitingSetting.GiveAmountFive);
                            SendChat(Moderator, String.Format(lang.GetMessage("UI_RAIT_ALERT_MODER", this, Moderator.UserIDString), Raiting, $"{config.RaitingSetting.GiveAmountFive}"));
                            return;
                        }
                        break;
                    }
            }
        }
        #endregion

        public float GetAverageRaiting(ulong userID)
        {
            var Data = ModeratorInformation[userID];
            float AverageRaiting = Data.AverageRating;
            int RaitingFull = 0;
            for(int i = 0; i < Data.Arrayrating.Count; i++)
                RaitingFull += Data.Arrayrating[i];

            int FormulDivision = Data.Arrayrating.Count == 0 ? 1 : Data.Arrayrating.Count;
            AverageRaiting = RaitingFull / FormulDivision;
            return AverageRaiting;
        }

        #endregion

        #region Lang
        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["PLAYER_CHECKED"] = "The player had already check!",

                ["MSG_REPORTED_SUSPECT"] = "You have successfully submitted a player report - {0}\nReported : {1}\nThe moderator will review your complaint as soon as possible!",
                ["MSG_CHECK_DISCORD"] = "You can't send Discord without checking!",
                ["MSG_CHECK_CHECK_STOP"] = "You have successfully passed the test!\nWe wish you a pleasant game on our server!",
                ["MSG_COOLDOWN"] = "You have recently sent a complaint!\nWait <color=#47AF5DFF>{0}</color>",
                ["MSG_DISCORD_SEND"] = "You have successfully submitted the information!\nDiscord - {0}\nExpect a call from the moderator",

                ["UI_MODERATOR_PANEL_TITLE"] = "Server moderator menu",
                ["UI_MODERATOR_PANEL_DESCRIPTION"] = "This list shows players who have reached the limit of complaints,click on the player to get more information",
                ["UI_MODERATOR_PANEL_START_CHECK"] = "Call for verification",
                ["UI_STATUS"] = "Status",

                ["NETWORD_STATUS_ONLINE"] = "Online",
                ["IS_STEAM_STATUS_PIRATE"] = "Pirate",
                ["IS_STEAM_STATUS_LICENSE"] = "License",

                ["METODS_SEND_REPORT_VK"] = "[IQReportSystem]\nA complaint has been sent to player {0} ({1})!\nComplaint - {2}\nReporter : {3}({4})",
                ["METODS_HELP_MODERS"] = "Player <color=#47AF5DFF>{0}</color> reached the limit of reports!\nThe number of his reports - <color=#47AF5DFF>{1}</color>\nModeration that is free - check the player!",
                ["METODS_HELP_MODERS_VK"] = "[IQReportSystem]\nPlayer {0} reached the limit of reports!\nThe number of his reports - {1}\nModeration that is free - check the player!",
                ["METODS_MODER_START_CHECK"] = "You started checking!\nSuspect - <color=#47AF5DFF>{0}</color>\nGetting started with AFK!\nIf the player is not AFK, they will receive a notification of verification!",
                ["METODS_MODER_START_CHECK_VK"] = "[IQReportSystem]\nModerator {0}({1}) started checking!\nSuspect - {2}({3})",
                ["METODS_MODER_STOP_CHECK"] = "Verification completed.\nHave a nice day!\nDo not forget to check the complaint list!",
                ["METODS_MODER_STOP_CHECK_VK"] = "[IQReportSystem]\nModerator {0} finished checking!",
                ["METODS_MODER_STOP_CHECK_ALERT"] = "Moderator {0} has finished Player check - {1}\nNo illegal found",

                ["NON_REPORT"] = "No complaints",
                ["RAID_BLOCK_TRUE_STOP"] = "You cannot start checking on a player because he has a raid block. Start checking later",
                ["PLAYER_LEAVE_AFK_METOD"] = "The player left the server during a hidden AFK check!\nThe check was canceled automatically.",
                ["MODERATOR_RETURN_WELCOME"] = "Welcome back!\nthe check was not canceled, continue!",
                ["STATUS_CHANGED"] = "The player's {0} status has changed to: {1}\n Wait for the player on the server for 10 minutes!\nIf the player does not enter after 10 minutes-issue a ban for Refusal",
                ["STATUS_CHANGED_VK"] = "[IQReportSystem]The player's {0} status has changed to: {1}\n Wait for the player on the server for 10 minutes!\nIf the player does not enter after 10 minutes-issue a ban for Refusal",
                ["MODERATOR_DISCONNECTED_STOP_CHECK"] = "The check was removed!\nModerator {0} left the server\nReason: connection Failure\nWe apologize!\nWe will inform the other moderation!",
                ["MODERATOR_DISCONNECTED_STOP_RESEND"] = "Moderator {0} finally left the server during verification!\n Player {1} is waiting for other moderators to check!",
                ["MODERATOR_COMPLETED_CHECK"] = "You successfully completed the review and delivered your verdict\nYour verdict : {0}",
                ["MODERATOR_COMPLETED_CHECK_ALERT"] = "Moderator {0} successfully completed the review  {1}\nVerdict: {2}",
                ["MODERATOR_COMPLETED_CHECK_VK"] = "[[IQ Report System]\nModerator {0}[(1)] finished checking \nSuspect {2}[{3}]\nVerdict : {4}\n[AFK Check]Player didn't move : {5}/5",
                ["PLAYER_AFK_CHECK_STOP"] = "Suspect AFK\nThe check is removed automatically!",
                ["PLAYER_AFK_CHECK_STOP_VK"] = "[IQReportSystem]\nModerator {0}({1}) checking the player {2}.\nThe AFK suspect and the check was removed!",
                ["PLAYER_AFK_CHANGE_POS"] = "The player was moving! Check {0}/5",
                ["PLAYER_AFK_CHANGE_NO_POS"] = "The player didn't move! Check {0}/5",
                ["PLAYER_AFK_ACTIVE_CHAT"] = "The player is active in the chat!",
                ["PLAYER_AFK_ACTIVE_CMD"] = "Player used command {0}",
                ["PLAYER_NON_AFK"] = "The player moves.\nProverite on!",
                ["DISCORD_NULL"] = "Not provided",
                ["REPORT_LIST_CONSOLE"] = "\n[IQReportSystem]:\nList of players in the Moderation Panel",
                ["DISCROD_VK_SEND"] = "[IQReportSystem]\nSuspect {0}({1}) provided Discord for verification!\nDiscord - {2}",
                ["CONSOLE_REPORT_GIVE"] = "Player {0} is successfully added to the report in the amount of {1}. Its number is - {2}",
                ["CONSOLE_REPORT_REMOVE"] = "Player {0} successfully removed reports in the amount of - {1} His number is - {2}",
                ["MODERATOR_NON_OPEN_MENU"] = "You can't open the moderator menu when checking a player!\nFinish checking!",
                ["UI_RAITING_MODERATION_VK_GIVE"] = "[IQReportSystem]:\nPlayer {0}({1}) rated the work of moderator {2}({3}) on {4} stars",
                ["UI_RAITING_MODERATION_VK_GIVE_THX"] = "Thx!",
                ["UI_RAIT_ALERT_MODER"] = "Your work has been rated with {0} stars. You gain {1} reputation.",

                ["UI_NEW_CHECKED_COUNT"] = "<size=14>CHECKED: {0}</size>",
                ["UI_NEW_CLOSE"] = "<size=24><b>CLOSE</b></size>",

                ["UI_NEW_MODERATION_TITLE_PANEL"] = "<size=18>PANEL MODERATION</size>",
                ["UI_NEW_MODERATION_REPORT_BTN"] = "<size=20><b>REPORTS</b></size>",

                ["UI_NEW_MODERATION_TITLE_STATS"] = "<size=18><b>CHECK STATISTICS</b></size>",
                ["UI_NEW_MODERATION_STATS_COUNTCHECK"] = "<size=12>NUMBER OF CHECKS: {0}</size>",
                ["UI_NEW_MODERATION_STATS_COUNTBANS"] = "<size=12>BLOCKEDS: {0}</size>",
                ["UI_NEW_MODERATION_STATS_STARS"] = "<size=15><b>QUALITY CONTROL : {0}</b></size>",

                ["UI_NEW_MODERATION_REPORT_PANEL_TITLE"] = "<size=70><b>REPORTS</b></size>",
                ["UI_NEW_MODERATION_REPORT_PANEL_DESCRIPTION"] = "<size=10>CHOOSE A PLAYER TO SEND TO IT'S COMPLAINT</size>",
                ["UI_NEW_MODERATION_REPORT_PANEL_SEARCH_DESCRIPTION"] = "<size=14>ENTER NICK OR STEAM64ID TO SEARCH A PLAYER</size>",
                ["UI_NEW_MODERATION_REPORT_PANEL_DESCRIPTION_MODERATOR"] = "<size=10>SELECT A PLAYER IN THE PANEL TO START A CHECK</size>",
                ["UI_NEW_MODERATION_REPORT_PANEL_SEARCH_TITLE"] = "<size=50><b>SEARCH</b></size>",

                ["UI_NEW_MODERATION_REPORT_PANEL_PLAYER_REPORTEDS"] = "<size=14><b>REPORTS : {0}</b></size>",

                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_TITLE"] = "<size=30><b>COMPLAINT INFORMATION</b></size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_DESC"] = "<size=12>CHOOSE THE REASON FOR THE PLAYER COMPLAINT</size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_TITLE"] = "<size=25><b>PLAYER</b></size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_CLOSE"] = "<size=18><b>CLOSE</b></size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_LIST"] = "<size=20><b>CHOOSE THE REASON FROM THE LIST</b></size>",


                ["UI_NEW_MODERATION_MODER_GO_CHECK_TITLE"] = "<size=30><b>PLAYER INFORMATION</b></size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_DESC"] = "<size=12>CHOOSE ACTION WHICH YOU WANT TO PERFORM</size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_TITLE"] = "<size=25><b>DETAILED INFORMATION</b></size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_HISTORY_REPORT"] = "<size=18>HISTORY OF COMPLAINTS</size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_HISTORY_RCC"] = "<size=18>INFO RCC</size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_REPORTS"] = "<size=25><b>REPORTS</b></size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_LAST_CHECK"] = "<size=14>LAST CHECKER: {0}</size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_COUNT_CHECK"] = "<size=14>CHECK COUNTS: {0}</size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_GOCHECK"] = "<size=18>START</size>",

                ["UI_NEW_ALERT_PLAYER_WARNING"] = "<size=40><b>YOU CALLED TO THE TEST</b></size>",
                ["UI_NEW_ALERT_PLAYER_TITLE"] = "<size=18>You exceeded the maximum allowable number of complaints.\npoetomu,provide your ex, in order to be contacted by our moderation!\nPV case of ignoring this message, you will get a lock! (You have 5 minutes)</size>",
                ["UI_NEW_ALERT_PLAYER_DESC"] = "<size=15>to provide data for communication,use the commands:\n/discord\npdale you will be contacted by the moderator</size>",

                ["UI_NEW_MINI_PANEL_MODERATOR_TITLE"] = "<size=14><b>MENU MODERATOR</b></size>",
                ["UI_NEW_MINI_PANEL_MODERATOR_BAN"] = "<size=18><b>BAN</b></size>",
                ["UI_NEW_MINI_PANEL_MODERATOR_STOP"] = "<size=18><b>STOP</b></size>",

                ["UI_NEW_RAITING_PANEL"] = "<size=13><b>GIVE RAITING</b>></size>",

            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["PLAYER_CHECKED"] = "Данного игрока уже проверяют!",

                ["MSG_REPORTED_SUSPECT"] = "Вы успешно отправили жалобу на игрока - {0}\nЖалоба : {1}\nМодератор рассмотрит вашу жалобу как можно скорее!",
                ["MSG_CHECK_DISCORD"] = "Вы не можете отправить Discord без проверки!",
                ["MSG_CHECK_CHECK_STOP"] = "Вы успешно прошли проверку!\nЖелаем приятной игры на нашем сервере!",
                ["MSG_COOLDOWN"] = "Вы недавно отправляли жалобу!\nПодождите еще <color=#47AF5DFF>{0}</color>",
                ["MSG_DISCORD_SEND"] = "Вы успешно предоставили данные!\nDiscord - {0}\nОжидайте звонка от модератора",

                ["UI_MODERATOR_PANEL_TITLE"] = "Меню модератора сервера",
                ["UI_MODERATOR_PANEL_DESCRIPTION"] = "В данном списке отображены игроки - достигшие предела жалоб,нажмите по игроку чтобы получить больше информации",
                ["UI_MODERATOR_PANEL_START_CHECK"] = "Вызвать на проверку",
                ["UI_STATUS"] = "Статус",

                ["NETWORD_STATUS_ONLINE"] = "Онлайн",
                ["IS_STEAM_STATUS_PIRATE"] = "Пират",
                ["IS_STEAM_STATUS_LICENSE"] = "Лицензия", 

                ["METODS_SEND_REPORT_VK"] = "[IQReportSystem]\nНа игрока {0}({1}) отправили жалобу!\nЖалоба - {2}\nОтправил жалобу : {3}({4})",
                ["METODS_HELP_MODERS"] = "Игрок <color=#47AF5DFF>{0}</color> достиг предельного количества репортов!\nКоличество его репортов - <color=#47AF5DFF>{1}</color>\nМодерация которая свободна - проверьте игрока!",
                ["METODS_HELP_MODERS_VK"] = "[IQReportSystem]\nИгрок {0} достиг предельного количества репортов!\nКоличество его репортов - {1}\nМодерация которая свободна - проверьте игрока!",
                ["METODS_MODER_START_CHECK"] = "Вы начали проверку!\nПодозреваемый - <color=#47AF5DFF>{0}</color>\nНачинаем проверку на AFK!\nЕсли игрок не AFK - ему выведут уведомление о проверке!",
                ["METODS_MODER_START_CHECK_VK"] = "[IQReportSystem]\nМодератор {0}({1}) начал проверку!\nПодозреваемый - {2}({3})",
                ["METODS_MODER_STOP_CHECK"] = "Проверка завершена.\nУдачного дня!\nНе забывай проверять список жалоб!",
                ["METODS_MODER_STOP_CHECK_VK"] = "[IQReportSystem]\nМодератор {0} закончил проверку!",
                ["METODS_MODER_STOP_CHECK_ALERT"] = "Модератор {0} закончил проверку игрока - {1}\nЗапрещенного не обнаружено",
                ["NON_REPORT"] = "Жалоб нет",
                ["RAID_BLOCK_TRUE_STOP"] = "Вы не можете начать проверку над игроком т.к у него рейдблок.Начните проверку позже",
                ["MODERATOR_RETURN_WELCOME"] = "С возвращением!\nПроверка не была отменена,продолжайте!",
                ["STATUS_CHANGED"] = "У игрока {0} изменился статус на : {1}\nОжидайте игрока на сервере в течении 10 минут!\nЕсли игрок не зайдет после 10 минут - выдавайте бан за Отказ",
                ["STATUS_CHANGED_VK"] = "[IQReportSystem]У игрока {0} изменился статус на : {1}\nОжидайте игрока на сервере в течении 10 минут!\nЕсли игрок не зайдет после 10 минут - выдавайте бан за Отказ",
                ["MODERATOR_DISCONNECTED_STOP_CHECK"] = "Проверка была снята!\nМодератор {0} покинул сервер\n Причина : Разрыв соединения\nПриносим свои извинения!\nМы сообщим другой модерации!",
                ["MODERATOR_DISCONNECTED_STOP_RESEND"] = "Модератор {0} окончательно покинул сервер во время проверки!\nИгрок {1} ожидает других модераторов для проверки!",
                ["MODERATOR_COMPLETED_CHECK"] = "Вы успешно завершили проверку и вынесли свой вердикт\nВаш вердикт : {0}",
                ["MODERATOR_COMPLETED_CHECK_ALERT"] = "Модератор {0} закончил проверку игрока {1}\nВердикт: {2}",
                ["MODERATOR_COMPLETED_CHECK_VK"] = "[IQReportSystem]\nМодератор {0}[(1)] закончил проверку\n Подозреваемый {2}[{3}]\nВердикт : {4}\n[Проверка на AFK]Игрок не двигался : {5}/5",
                ["PLAYER_AFK_CHECK_STOP"] = "Игрок AFK\nПроверка снята автоматически!",
                ["PLAYER_AFK_CHECK_STOP_VK"] = "[IQReportSystem]\nМодератор {0}({1}) проверял игрока {2}.\nИгрок AFK и проверка была снята!",
                ["PLAYER_AFK_CHANGE_POS"] = "Игрок двигался! Проверка {0}/5",
                ["PLAYER_AFK_ACTIVE_CHAT"] = "Игрок проявил активность в чате!",
                ["PLAYER_AFK_ACTIVE_CMD"] = "Игрок использовал команду {0}",
                ["PLAYER_AFK_CHANGE_NO_POS"] = "Игрок не двигался! Проверка {0}/5",
                ["PLAYER_NON_AFK"] = "Игрок двигается.\nПроверяйте дальше!",
                ["PLAYER_LEAVE_AFK_METOD"] = "Игрок покинул сервер во время скрытой проверки на АФК!\nПроверка была снята автоматически",
                ["DISCORD_NULL"] = "Не предоставлен",
                ["REPORT_LIST_CONSOLE"] = "\n[IQReportSystem]:\nСписок игроков в Панели-Модерации",
                ["DISCROD_VK_SEND"] = "[IQReportSystem]\nИгрок {0}({1}) предоставил Discord на проверку!\nDiscord - {2}",
                ["CONSOLE_REPORT_GIVE"] = "Игроку {0} успешно добавлены репорты в количестве - {1}. Его количество составляет - {2}",
                ["CONSOLE_REPORT_REMOVE"] = "Игроку {0} успешно сняты репорты в количестве - {1} Его количество составляет - {2}",
                ["MODERATOR_NON_OPEN_MENU"] = "Вы не можете открыть меню модератора при проверке игрока!\nОкончите проверку!",
                ["UI_RAITING_MODERATION_VK_GIVE"] = "[IQReportSystem]:\nИгрок {0}({1}) оценил работу модератора {2}({3}) на {4} звезды",
                ["UI_RAITING_MODERATION_VK_GIVE_THX"] = "Спасибо за ваш отзыв!",
                ["UI_RAIT_ALERT_MODER"] = "Вашу работу оценили в {0} звезд(ы). Вы получаете {1} репутации",


                ["UI_NEW_CHECKED_COUNT"] = "<size=14>ПРОВЕРЕН: {0}</size>",
                ["UI_NEW_CLOSE"] = "<size=24><b>ЗАКРЫТЬ</b></size>",

                ["UI_NEW_MODERATION_TITLE_PANEL"] = "<size=18>ПАНЕЛЬ ПРОВЕРЯЮЩЕГО</size>",
                ["UI_NEW_MODERATION_REPORT_BTN"] = "<size=20><b>ЖАЛОБЫ</b></size>",

                ["UI_NEW_MODERATION_TITLE_STATS"] = "<size=18><b>СТАТИСТИКА ПРОВЕРЯЮЩЕГО</b></size>",
                ["UI_NEW_MODERATION_STATS_COUNTCHECK"] = "<size=12>КОЛИЧЕСТВО ПРОВЕРОК: {0}</size>",
                ["UI_NEW_MODERATION_STATS_COUNTBANS"] = "<size=12>БЛОКИРОВОК ВЫДАНО: {0}</size>",
                ["UI_NEW_MODERATION_STATS_STARS"] = "<size=15><b>ОЦЕНКА КАЧЕСТВА : {0}</b></size>",

                ["UI_NEW_MODERATION_REPORT_PANEL_TITLE"] = "<size=70><b>ЖАЛОБЫ</b></size>",
                ["UI_NEW_MODERATION_REPORT_PANEL_DESCRIPTION"] = "<size=10>ВЫБЕРИТЕ ИГРОКА ЧТОБЫ ОТПРАВИТЬ НА НЕГО ЖАЛОБУ</size>",
                ["UI_NEW_MODERATION_REPORT_PANEL_DESCRIPTION_MODERATOR"] = "<size=10>ВЫБЕРИТЕ ИГРОКА В ПАНЕЛИ ЧТОБЫ НАЧАТЬ ПРОВЕРКУ</size>",
                ["UI_NEW_MODERATION_REPORT_PANEL_SEARCH_DESCRIPTION"] = "<size=14>ВВЕДИТЕ НИК ИЛИ STEAM64ID ДЛЯ ПОИСКА ИГРОКА</size>",
                ["UI_NEW_MODERATION_REPORT_PANEL_SEARCH_TITLE"] = "<size=50><b>ПОИСК</b></size>",

                ["UI_NEW_MODERATION_REPORT_PANEL_PLAYER_REPORTEDS"] = "<size=14><b>ЖАЛОБЫ : {0}</b></size>",

                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_TITLE"] = "<size=30><b>ИНФОРМАЦИЯ О ЖАЛОБЕ</b></size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_DESC"] = "<size=12>ВЫБЕРИТЕ ПРИЧИНУ ДЛЯ ЖАЛОБЫ НА ИГРОКА</size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_TITLE"] = "<size=25><b>ИГРОК</b></size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_CLOSE"] = "<size=18><b>ЗАКРЫТЬ</b></size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_LIST"] = "<size=20><b>ВЫБЕРИТЕ ПРИЧИНУ ИЗ СПИСКА</b></size>",

                ["UI_NEW_MODERATION_MODER_GO_CHECK_TITLE"] = "<size=30><b>ИНФОРМАЦИЯ О ИГРОКЕ</b></size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_DESC"] = "<size=12>ВЫБЕРИТЕ ДЕЙСТВИЯ КОТОРОЕ ХОТИТЕ СОВЕРШИТЬ</size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_TITLE"] = "<size=25><b>ПОДРОБНАЯ ИНФОРМАЦИЯ</b></size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_HISTORY_REPORT"] = "<size=18>ИСТОРИЯ ЖАЛОБ</size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_HISTORY_RCC"] = "<size=18>ИНФОРМАЦИЯ RCC</size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_REPORTS"] = "<size=25><b>ЖАЛОБ</b></size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_LAST_CHECK"] = "<size=14>ПОСЛЕДНИЙ ПРОВЕРЯЮЩИЙ : {0}</size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_COUNT_CHECK"] = "<size=14>КОЛИЧЕСТВО ПРОВЕРОК: {0}</size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_GOCHECK"] = "<size=18>ПРОВЕРИТЬ</size>",

                ["UI_NEW_ALERT_PLAYER_WARNING"] = "<size=40><b>ВАС ВЫЗВАЛИ НА ПРОВЕРКУ</b></size>",
                ["UI_NEW_ALERT_PLAYER_TITLE"] = "<size=18>Вы превысили максимально-допустимое количество жалоб.\nПоэтому,предоставьте ваш Discord, для того чтобы с вами связалась наша модерация!\nВ случае игнорирования данного сообщения - вы получите блокировку! (У вас имеется 5 минут)</size>",
                ["UI_NEW_ALERT_PLAYER_DESC"] = "<size=15>Чтобы предоставить данные для связи,используйте команды:\n/discord\nДалее с вами свяжется модератор</size>",

                ["UI_NEW_MINI_PANEL_MODERATOR_TITLE"] = "<size=14><b>МЕНЮ ПРОВЕРЯЮЩЕГО</b></size>",
                ["UI_NEW_MINI_PANEL_MODERATOR_BAN"] = "<size=18><b>ВЕРДИКТ</b></size>",
                ["UI_NEW_MINI_PANEL_MODERATOR_STOP"] = "<size=18><b>СТОП</b></size>",


                ["UI_NEW_RAITING_PANEL"] = "<size=13><b>ОЦЕНИТЕ ПРОВЕРЯЮЩЕГО</b>></size>",
            }, this, "ru");
            PrintWarning("Языковой файл загружен успешно");
        }
        #endregion

        #region Interface

        public static string PARENT_UI =  "MAIN_PARENT_UI";
        public static string PARENT_UI_REPORT_MENU = "PARENT_UI_REPORT_MENU";
        public static string PARENT_UI_PLAYER_PANEL = "PARENT_UI_PLAYER_PANEL";
        public static string PARENT_UI_PLAYER_REPORT = "PARENT_UI_PLAYER_REPORT";
        public static string PARENT_UI_MODER_REPORT = "PARENT_UI_MODER_REPORT";
        public static string PARENT_UI_ALERT_SEND = "PARENT_UI_ALERT_SEND";
        public static string PARENT_UI_MODERATOR_MINI_PANEL = "PARENT_UI_MODERATOR_MINI_PANEL";
        private static string UI_MODERATION_CHECK_MENU_DISCORD = "UI_MODERATION_CHECK_MENU_DISCORD_PARENT";
        private static string UI_MODERATION_CHECK_MENU_NETWORK = "UI_MODERATION_CHECK_MENU_NETWORK_PARENT";
        private static string UI_MODERATION_RAITING = "UI_MODERATION_RAITING";


        #region UI Main Interface
        void UI_Interface(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, PARENT_UI);
            var Interface = config.Setting.Interface;
            var InformationUser = ReportInformation[player.userID];

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-200 0", OffsetMax = "0 720" },
                Image = { FadeIn = 0.15f, Color = HexToRustFormat(Interface.HexRightMenu), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            }, "Overlay", PARENT_UI);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.006666541 0.7046295", AnchorMax = "1 0.7462999" },
                Text = { Text = $"<b><size=22>{player.displayName}</size></b>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperCenter }
            }, PARENT_UI);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.6851852", AnchorMax = "1 0.7166605" },
                Text = { Text = String.Format(lang.GetMessage("UI_NEW_CHECKED_COUNT", this, player.UserIDString), InformationUser.CheckCount), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperCenter }
            }, PARENT_UI);

            string ImageAvatar = GetImage(player.UserIDString, 0);
            container.Add(new CuiElement
            {
                Parent = PARENT_UI,
                Name = $"AVATAR",
                Components =
                 {
                    new CuiRawImageComponent { Png = ImageAvatar,Color = HexToRustFormat("#FFFFFFFF") },
                    new CuiRectTransformComponent{ AnchorMin = "0.08076949 0.7518547", AnchorMax = $"0.9341028 0.9888917"},
                 }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.05555556" },
                Button = { Close = PARENT_UI, Color = "0 0 0 0" },
                Text = { Text = lang.GetMessage("UI_NEW_CLOSE", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Align = TextAnchor.MiddleCenter }
            }, PARENT_UI);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.6851852", AnchorMax = "1 0.7166605" },
                Text = { Text = String.Format(lang.GetMessage("UI_NEW_CHECKED_COUNT", this, player.UserIDString), InformationUser.CheckCount), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperCenter }
            }, PARENT_UI);

            if (permission.UserHasPermission(player.UserIDString, PermissionModeration))
            {
                if (!ModeratorInformation.ContainsKey(player.userID))
                    Metods_PlayerConnected(player);

                var InformationModerator = ModeratorInformation[player.userID];

                #region PANEL MODERATION MENU

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0.4907467", AnchorMax = "1 0.5574059" },
                    Text = { Text = lang.GetMessage("UI_NEW_MODERATION_TITLE_PANEL", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                }, PARENT_UI);

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.1533333 0.4212967", AnchorMax = "1 0.47963" },
                    Button = { Command = "iqreport moderation_menu", Color = HexToRustFormat(Interface.HexButtonRightMenu), Material = "assets/content/ui/uibackgroundblur.mat" },
                    Text = { Text = lang.GetMessage("UI_NEW_MODERATION_REPORT_BTN", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Align = TextAnchor.MiddleCenter }
                },  PARENT_UI, "BTN_REPORTS");

                container.Add(new CuiElement
                {
                    Parent = "BTN_REPORTS",
                    Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = Interface.SpriteReportModeration },
                        new CuiRectTransformComponent { AnchorMin = "0.02362165 0", AnchorMax = "0.2755902 1" }
                    }
                });

                #endregion

                #region STATS PANEL MODERATION MENU

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0.2574087", AnchorMax = "1 0.3138935" },
                    Text = { Text = lang.GetMessage("UI_NEW_MODERATION_TITLE_STATS", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                }, PARENT_UI);

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0.003333271 0.1240732", AnchorMax = "1 0.2500008" },
                    Image = { Color = HexToRustFormat(Interface.HexButtonRightMenu), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
                },  PARENT_UI, "STATS_MODERATION");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0.6911764", AnchorMax = "1 1" },
                    Text = { Text = String.Format(lang.GetMessage("UI_NEW_MODERATION_STATS_COUNTCHECK", this, player.UserIDString), InformationModerator.CheckCount), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                },  "STATS_MODERATION");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0.5441177", AnchorMax = "1 0.7499995" },
                    Text = { Text = String.Format(lang.GetMessage("UI_NEW_MODERATION_STATS_COUNTBANS", this, player.UserIDString), InformationModerator.BanPlayerModerator.Count), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                }, "STATS_MODERATION");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.2573562" },
                    Text = { Text = String.Format(lang.GetMessage("UI_NEW_MODERATION_STATS_STARS", this, player.UserIDString), GetAverageRaiting(player.userID)), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.LowerCenter }
                }, "STATS_MODERATION");

                for (int i = 0; i < 5; i++)
                {
                    string ColorStar = Math.Floor(GetAverageRaiting(player.userID)) == 0 ? "#D9BA6AA2" : Math.Floor(GetAverageRaiting(player.userID)) >= i+1 ? "#d9ba6a" : "#D9BA6AA2";
                    container.Add(new CuiElement
                    {
                        Parent = "STATS_MODERATION",
                        Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(ColorStar), Sprite = Interface.SpriteRaiting },
                        new CuiRectTransformComponent { AnchorMin = $"{0.07023425 + (i * 0.175)} 0.2058797", AnchorMax = $"{0.2307694 + (i * 0.175)} 0.5661694" }
                    }
                    });
                }

                #endregion
            }

            CuiHelper.AddUi(player, container);
            UI_PanelReportsPlayer(player);
        }

        #endregion

        #region UI Panel Reports Interface

        void UI_PanelReportsPlayer(BasePlayer player, bool Moderation = false)
        {
            var Interface = config.Setting.Interface;
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, PARENT_UI_REPORT_MENU);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "-1080 0", OffsetMax = "0 720" },
                Image = { Color = HexToRustFormat(Interface.HexMainPanel), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            },  PARENT_UI, PARENT_UI_REPORT_MENU);

            container.Add(new CuiElement
            {
                Parent = PARENT_UI_REPORT_MENU,
                Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = Interface.SpriteReport },
                        new CuiRectTransformComponent { AnchorMin = "0.007901235 0.8648087", AnchorMax = "0.09876543 0.9833272" }
                    }
            });

            string SearchName = "";
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.3799841 0.8888888", AnchorMax = "0.7234193 0.925926" },
                Image = { Color = HexToRustFormat(Interface.HexSearchPanel), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            },  PARENT_UI_REPORT_MENU, PARENT_UI_REPORT_MENU + ".Input");

            container.Add(new CuiElement
            {
                Parent = PARENT_UI_REPORT_MENU + ".Input",
                Name = PARENT_UI_REPORT_MENU + ".Input.Current",
                Components =
                { 
                    new CuiInputFieldComponent { Text = SearchName, FontSize = 14,Command = $"iqreport search {Moderation} {0} {SearchName}", Align = TextAnchor.MiddleLeft, Color = HexToRustFormat(Interface.HexLabels), CharsLimit = 15},
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.09925909 0.8462963", AnchorMax = "0.4113576 0.9805495" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_REPORT_PANEL_TITLE", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, PARENT_UI_REPORT_MENU);

            string DescriptionReportTitle = Moderation ? "UI_NEW_MODERATION_REPORT_PANEL_DESCRIPTION_MODERATOR" : "UI_NEW_MODERATION_REPORT_PANEL_DESCRIPTION";
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.1 0.9546276", AnchorMax = "0.38 0.98" },
                Text = { Text = lang.GetMessage(DescriptionReportTitle, this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, PARENT_UI_REPORT_MENU);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.7315881 0.8675926", AnchorMax = "0.9332193 0.9527193" }, 
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_REPORT_PANEL_SEARCH_TITLE", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, PARENT_UI_REPORT_MENU);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.3799841 0.9277778", AnchorMax = "0.7313576 0.95" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_REPORT_PANEL_SEARCH_DESCRIPTION", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, PARENT_UI_REPORT_MENU);

            CuiHelper.AddUi(player, container);
            UI_Player_Loaded(player, Moderation);
        }

        #endregion

        #region UI Player Loaded Interface

        void UI_Player_Loaded(BasePlayer player, bool Moderation = false, int Page = 0, string TargetName = "", bool debug = true)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, PARENT_UI_PLAYER_PANEL);
            var Interface = config.Setting.Interface;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.8296296" },
                Image = { Color = "0 0 0 0" }
            }, PARENT_UI_REPORT_MENU, PARENT_UI_PLAYER_PANEL);


            int x = 0, y = 0, i = 20 * Page;

            IEnumerable<FakePlayer> playerList = (IEnumerable<FakePlayer>)(Moderation ? PlayerBases.Where(z => ReportInformation[z.UserID].ReportCount >= config.Setting.MaxReport && (z.DisplayName.ToLower().Contains(TargetName.ToLower()) || z.UserID.ToString().Contains(TargetName)))
                                                            : PlayerBases.Where(z => z.DisplayName.ToLower().Contains(TargetName.ToLower()) || z.UserID.ToString().Contains(TargetName)));

            var ActiviteList = ((Moderation ? BasePlayer.activePlayerList.Where(z => ReportInformation[z.userID].ReportCount >= config.Setting.MaxReport && (z.displayName.ToLower().Contains(TargetName.ToLower()) || z.userID.ToString().Contains(TargetName)))
                                                : BasePlayer.activePlayerList.Where(z => z.displayName.ToLower().Contains(TargetName.ToLower()) || z.userID.ToString().Contains(TargetName))));
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.4866512 0.008887243", AnchorMax = "0.5140741 0.05357143" },
                Text = { Text = $"<size=20>{Page}</size>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, PARENT_UI_PLAYER_PANEL);

            if (IQFakeActive && config.IQFakeActiveSettings.UseIQFakeActive)
            {
                int CountPage = playerList.Skip(20 * (Page + 1)).Count();

                if (CountPage != 0)
                {
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0.5222067 0.008887243", AnchorMax = "0.5496294 0.05357143" },
                        Button = { Command = $"iqreport page next {Moderation} {Page}", Color = HexToRustFormat(Interface.HexPlayerButton), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                        Text = { Text = "<b><size=20>></size></b>", Align = TextAnchor.MiddleCenter }
                    }, PARENT_UI_PLAYER_PANEL);
                }
            }
            else
            {
                int CountPage = ActiviteList.Skip(20 * (Page + 1)).Take(20).Count();

                if (CountPage != 0)
                {
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0.5222067 0.008887243", AnchorMax = "0.5496294 0.05357143" },
                        Button = { Command = $"iqreport page next {Moderation} {Page}", Color = HexToRustFormat(Interface.HexPlayerButton), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                        Text = { Text = "<b><size=20>></size></b>", Align = TextAnchor.MiddleCenter }
                    }, PARENT_UI_PLAYER_PANEL);
                }
            }

            if (Page != 0)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.4510956 0.008887243", AnchorMax = "0.4785185 0.05357143" },
                    Button = { Command = $"iqreport page back {Moderation} {Page}", Color = HexToRustFormat(Interface.HexPlayerButton), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                    Text = { Text = "<b><size=20><</size></b>", Align = TextAnchor.MiddleCenter }
                }, PARENT_UI_PLAYER_PANEL);
            }
           
            if (IQFakeActive && config.IQFakeActiveSettings.UseIQFakeActive)
                foreach (var Plist in playerList.Skip(20 * Page).Take(20))
                {
                    ulong UserID = Plist.UserID;
                    string DisplayName = Plist.DisplayName;
                    if (Friends != null)
                        if (config.Setting.FriendNoReport)
                            if ((bool)Friends.Call("HasFriend", player.userID, UserID)) continue;

                    if (UserID == player.userID) continue;
                    if (!IsFake(UserID))
                        if (permission.UserHasPermission(UserID.ToString(), PermissionAdmin)) continue;

                    container.Add(new CuiPanel
                    {
                        RectTransform = { AnchorMin = $"{0.00246954 + (x * 0.2585)} {0.8671876 - (y * 0.2)}", AnchorMax = $"{0.2 + (x * 0.2585)} {0.9910715 - (y * 0.2)}" },
                        Image = { Color = HexToRustFormat(Interface.HexSearchPanel), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
                    }, PARENT_UI_PLAYER_PANEL, $"PLAYER_{i}");

                    string ImageAvatar = GetImage(UserID.ToString(), 0);
                    container.Add(new CuiElement
                    {
                        Parent = $"PLAYER_{i}",
                        Components =
                 {
                    new CuiRawImageComponent { Png = ImageAvatar,Color = HexToRustFormat("#FFFFFFAA") },
                    new CuiRectTransformComponent{ AnchorMin = "0 0", AnchorMax = $"0.3600007 1"},
                 }
                    });

                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0.3699992 0.6756751", AnchorMax = "1 1" },
                        Text = { Text = $"<b><size=16>{DisplayName}</size></b>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
                    }, $"PLAYER_{i}");

                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0.3699992 0.432432", AnchorMax = "1 0.7567569" },
                        Text = { Text = $"<size=14>{UserID}</size>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
                    }, $"PLAYER_{i}");

                    string CMDD = Moderation ? $"iqreport moderation_send {UserID}" : $"iqreport reports_menu {UserID}"; ///// DEBUG
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "2 0", OffsetMax = "22 75" },
                        Button = { Command = CMDD, Color = HexToRustFormat(Interface.HexPlayerButton) },
                        Text = { Text = "" }
                    }, $"PLAYER_{i}", $"BTN_ACTION_{i}");

                    container.Add(new CuiElement
                    {
                        Parent = $"BTN_ACTION_{i}",
                        Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = Interface.SpritePlayerButton },
                        new CuiRectTransformComponent { AnchorMin = "0 0.41", AnchorMax = "0.96 0.62" }
                    }
                    });

                    if (Moderation)
                    {
                        if (IsFake(UserID)) continue;

                        var InformationUser = ReportInformation[UserID];
                        string IsSteamSprite = IsSteam(UserID.ToString()) == lang.GetMessage("IS_STEAM_STATUS_LICENSE", this, UserID.ToString()) ? "assets/icons/steam.png" : "assets/icons/poison.png";

                        container.Add(new CuiLabel
                        {
                            RectTransform = { AnchorMin = "0.3699992 0.01801781", AnchorMax = "1 0.2342333" },
                            Text = { Text = String.Format(lang.GetMessage("UI_NEW_MODERATION_REPORT_PANEL_PLAYER_REPORTEDS", this, UserID.ToString()), InformationUser.ReportCount), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
                        }, $"PLAYER_{i}");

                        container.Add(new CuiElement
                        {
                            Parent = $"PLAYER_{i}",
                            Components =
                        {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = IsSteamSprite },
                        new CuiRectTransformComponent { AnchorMin = "0.9100056 0.01801781", AnchorMax = "0.9900023 0.2432426" }
                        }
                        });
                    }

                    i++;
                    x++;
                    if (x == 4)
                    {
                        x = 0;
                        y++;
                    }
                    if (y == 5 && x == 0)
                        break;
                }
            else
            {
                foreach (var Plist in ActiviteList.Skip(20 * Page).Take(20))
                {
                    ulong UserID = Plist.userID;
                    string DisplayName = Plist.displayName;
                    if (Friends != null)
                        if (config.Setting.FriendNoReport)
                            if ((bool)Friends.Call("HasFriend", player.userID, UserID)) continue;

                    if (UserID == player.userID) continue;
                    if (permission.UserHasPermission(UserID.ToString(), PermissionAdmin)) continue;

                    container.Add(new CuiPanel
                    {
                        RectTransform = { AnchorMin = $"{0.00246954 + (x * 0.2585)} {0.8671876 - (y * 0.2)}", AnchorMax = $"{0.2 + (x * 0.2585)} {0.9910715 - (y * 0.2)}" },
                        Image = { Color = HexToRustFormat(Interface.HexSearchPanel), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
                    }, PARENT_UI_PLAYER_PANEL, $"PLAYER_{i}");

                    string ImageAvatar = GetImage(UserID.ToString(), 0);
                    container.Add(new CuiElement
                    {
                        Parent = $"PLAYER_{i}",
                        Components =
                 {
                    new CuiRawImageComponent { Png = ImageAvatar,Color = HexToRustFormat("#FFFFFFAA") },
                    new CuiRectTransformComponent{ AnchorMin = "0 0", AnchorMax = $"0.3600007 1"},
                 }
                    });

                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0.3699992 0.6756751", AnchorMax = "1 1" },
                        Text = { Text = $"<b><size=16>{DisplayName}</size></b>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
                    }, $"PLAYER_{i}");

                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0.3699992 0.432432", AnchorMax = "1 0.7567569" },
                        Text = { Text = $"<size=14>{UserID}</size>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
                    }, $"PLAYER_{i}");

                    string CMDD = Moderation ? $"iqreport moderation_send {UserID}" : $"iqreport reports_menu {UserID}"; 
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "2 0", OffsetMax = "22 75" },
                        Button = { Command = CMDD, Color = HexToRustFormat(Interface.HexPlayerButton) },
                        Text = { Text = "" }
                    }, $"PLAYER_{i}", $"BTN_ACTION_{i}");

                    container.Add(new CuiElement
                    {
                        Parent = $"BTN_ACTION_{i}",
                        Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = Interface.SpritePlayerButton },
                        new CuiRectTransformComponent { AnchorMin = "0 0.41", AnchorMax = "0.96 0.62" }
                    }
                    });

                    if (Moderation)
                    {
                        if (IsFake(UserID)) continue;

                        var InformationUser = ReportInformation[UserID];
                        string IsSteamSprite = IsSteam(UserID.ToString()) == lang.GetMessage("IS_STEAM_STATUS_LICENSE", this, UserID.ToString()) ? "assets/icons/steam.png" : "assets/icons/poison.png";

                        container.Add(new CuiLabel
                        {
                            RectTransform = { AnchorMin = "0.3699992 0.01801781", AnchorMax = "1 0.2342333" },
                            Text = { Text = String.Format(lang.GetMessage("UI_NEW_MODERATION_REPORT_PANEL_PLAYER_REPORTEDS", this, UserID.ToString()), InformationUser.ReportCount), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
                        }, $"PLAYER_{i}");

                        container.Add(new CuiElement
                        {
                            Parent = $"PLAYER_{i}",
                            Components =
                        {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = IsSteamSprite },
                        new CuiRectTransformComponent { AnchorMin = "0.9100056 0.01801781", AnchorMax = "0.9900023 0.2432426" }
                        }
                        });
                    }

                    i++;
                    x++;
                    if (x == 4)
                    {
                        x = 0;
                        y++;
                    }
                    if (y == 5 && x == 0)
                        break;
                }
            }
            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region UI Send Report
        void UI_SendReport(BasePlayer player, ulong UserID)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, PARENT_UI_PLAYER_REPORT);
         //   ulong UserID = IQFakeActive ? PlayerBases.FirstOrDefault(x => x.UserID == UserID).use : BasePlayer.activePlayerList[BaseID].userID;
            string DisplayName = IQFakeActive ? PlayerBases.FirstOrDefault(j => j.UserID == UserID).DisplayName : BasePlayer.FindByID(UserID).displayName;

            var InterfaceReport = config.Setting.Interface.ReasonInterface;
            var Interface= config.Setting.Interface;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Color = HexToRustFormat("#21211AF2") }
            },  "Overlay", PARENT_UI_PLAYER_REPORT);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.25 0.1768519", AnchorMax = "0.7 0.8" },
                Image = { Color = HexToRustFormat(InterfaceReport.HexMain) }
            },  PARENT_UI_PLAYER_REPORT,"PANEL_MAIN_REPORT");

            #region TitlePanel

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.8662704", AnchorMax = "1 1" },
                Image = { Color = HexToRustFormat(InterfaceReport.HexTitlePanel) }
            },  "PANEL_MAIN_REPORT", "TITLE_PANEL");

            container.Add(new CuiElement
            {
                Parent = $"TITLE_PANEL",
                Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = InterfaceReport.SpriteTitlePanel },
                        new CuiRectTransformComponent { AnchorMin = "0.01851851 0.1000004", AnchorMax = "0.09259258 0.8111112" }
                    }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.09953713 0", AnchorMax = "1 0.6333335" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_SEND_REPORT_PANEL_TITLE",this,player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            },  "TITLE_PANEL");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.09953713 0.4444447", AnchorMax = "1 0.9" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_SEND_REPORT_PANEL_DESC", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "TITLE_PANEL");

            #endregion

            #region MainPanel
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.09143519 0.7028232", AnchorMax = "0.2731481 0.768202" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_TITLE", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "PANEL_MAIN_REPORT");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.5973254", AnchorMax = "1 0.6493313" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_LIST", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, "PANEL_MAIN_REPORT");

            string ImageAvatar = GetImage((string)UserID.ToString(), 0);
            container.Add(new CuiElement
            {
                Parent = $"PANEL_MAIN_REPORT",
                Components =
                 {
                    new CuiRawImageComponent { Png = ImageAvatar,Color = HexToRustFormat("#FFFFFFAA") },
                    new CuiRectTransformComponent{ AnchorMin = "0.33449 0.6909361", AnchorMax = $"0.4085641 0.7860327"},
                 }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.412036 0.7444279", AnchorMax = "0.9918982 0.7860327" },
                Text = { Text = $"<b><size=14>{DisplayName}</size></b>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
            }, "PANEL_MAIN_REPORT");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.412036 0.6909361", AnchorMax = "0.9918982 0.7265974" },
                Text = { Text = $"<size=12>{UserID.ToString()}</size>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
            }, "PANEL_MAIN_REPORT");
            #endregion

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.3263901 0.01188706", AnchorMax = "0.6678232 0.08023772" },
                Button = { Close = PARENT_UI_PLAYER_REPORT, Color = HexToRustFormat(InterfaceReport.HexClose) },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_CLOSE",this,player.UserIDString), Align = TextAnchor.MiddleCenter }
            }, $"PANEL_MAIN_REPORT", $"BTN_CLOSE");

            container.Add(new CuiElement
            {
                Parent = $"BTN_CLOSE",
                Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = InterfaceReport.SpriteClose },
                        new CuiRectTransformComponent { AnchorMin = "0.006779703 0.04347827", AnchorMax = "0.1491535 0.9565219" }
                    }
            });

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.09509653", AnchorMax = "1 0.5884101" },
                Image = { Color = "0 0 0 0" }
            }, "PANEL_MAIN_REPORT", "PANEL_MAIN_REPORT_REASON");

            int x = 0, y = 0, i = 0;
            foreach(var Reason in config.ReasonReport)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{0.06944443 + (x * 0.45)} {0.8253011 - (y * 0.2)}", AnchorMax = $"{0.4895834 + (x * 0.45)} {0.9879518 - (y * 0.2)}" },
                    Button = { Close = PARENT_UI_PLAYER_REPORT, Command = $"iqreport send_report {UserID} {i}", Color = HexToRustFormat(InterfaceReport.HexButton) },
                    Text = { Text = Reason, Align = TextAnchor.MiddleCenter, Color = HexToRustFormat(InterfaceReport.HexLabel) }
                }, $"PANEL_MAIN_REPORT_REASON", $"REASON_{i}");

                x++;
                i++;
                if (x == 2)
                {
                    x = 0;
                    y++;
                }
                if (x == 0 && y == 5)
                    break;
            }

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region UI Moder Report
        void UI_ModerReport(BasePlayer player, BasePlayer Suspect)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, PARENT_UI_MODER_REPORT);
            var InterfaceReport = config.Setting.Interface.ReasonInterface;
            var Interface = config.Setting.Interface;
            var Data = ReportInformation[Suspect.userID];

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Color = HexToRustFormat("#21211AF2") }
            }, "Overlay", PARENT_UI_MODER_REPORT);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.25 0.1768519", AnchorMax = "0.7 0.8" },
                Image = { Color = HexToRustFormat(InterfaceReport.HexMain) }
            }, PARENT_UI_MODER_REPORT, "PANEL_MAIN_REPORT");

            #region TitlePanel

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.8662704", AnchorMax = "1 1" },
                Image = { Color = HexToRustFormat(InterfaceReport.HexTitlePanel) }
            }, "PANEL_MAIN_REPORT", "TITLE_PANEL");

            container.Add(new CuiElement
            {
                Parent = $"TITLE_PANEL",
                Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = InterfaceReport.SpriteTitlePanel },
                        new CuiRectTransformComponent { AnchorMin = "0.01851851 0.1000004", AnchorMax = "0.09259258 0.8111112" }
                    }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.09953713 0", AnchorMax = "1 0.6333335" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_MODER_GO_CHECK_TITLE", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "TITLE_PANEL");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.09953713 0.4444447", AnchorMax = "1 0.9" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_MODER_GO_CHECK_DESC", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "TITLE_PANEL");

            #endregion

            #region MainPanel
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.09143519 0.7028232", AnchorMax = "0.2731481 0.768202" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_TITLE", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "PANEL_MAIN_REPORT");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.5482913", AnchorMax = "1 0.6136701" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_MODER_GO_CHECK_MORE_TITLE", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, "PANEL_MAIN_REPORT");

            string ImageAvatar = GetImage(Suspect.UserIDString, 0);
            container.Add(new CuiElement
            {
                Parent = $"PANEL_MAIN_REPORT",
                Components =
                 {
                    new CuiRawImageComponent { Png = ImageAvatar,Color = HexToRustFormat("#FFFFFFAA") },
                    new CuiRectTransformComponent{ AnchorMin = "0.33449 0.6909361", AnchorMax = $"0.4085641 0.7860327"},
                 }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.412036 0.7444279", AnchorMax = "0.9918982 0.7860327" },
                Text = { Text = $"<b><size=14>{Suspect.displayName}</size></b>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
            }, "PANEL_MAIN_REPORT");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.412036 0.6909361", AnchorMax = "0.9918982 0.7265974" },
                Text = { Text = $"<size=12>{Suspect.UserIDString}</size>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
            }, "PANEL_MAIN_REPORT");
            #endregion

            #region MoreDetalis

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.00925926 0.4695395", AnchorMax = "0.3611112 0.5349182" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_MODER_GO_CHECK_MORE_HISTORY_REPORT", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            },  "PANEL_MAIN_REPORT");

            string LastCheck = String.IsNullOrWhiteSpace(Data.LastCheckModerator) ? "Не был проверен" : Data.LastCheckModerator;
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.01041757 0.1738484", AnchorMax = "0.6319444 0.2392275" },
                Text = { Text = String.Format(lang.GetMessage("UI_NEW_MODERATION_MODER_GO_CHECK_MORE_LAST_CHECK", this, player.UserIDString), LastCheck), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "PANEL_MAIN_REPORT");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.0104176 0.127786", AnchorMax = "0.5497685 0.1931651" },
                Text = { Text = String.Format(lang.GetMessage("UI_NEW_MODERATION_MODER_GO_CHECK_MORE_COUNT_CHECK", this, player.UserIDString), Data.CheckCount), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "PANEL_MAIN_REPORT");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.6377296 0.1456166", AnchorMax = "0.8194424 0.2139673" },
                Text = { Text = String.Format(lang.GetMessage("UI_NEW_MODERATION_MODER_GO_CHECK_MORE_REPORTS", this, player.UserIDString)), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "PANEL_MAIN_REPORT");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.8275464 0.1411597", AnchorMax = "0.9953676 0.2243681" },
                Text = { Text = $"<size=30><b>{Data.ReportCount}</b></size>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, "PANEL_MAIN_REPORT");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.009259251 0.2496285", AnchorMax = "0.3611112 0.4680535" },
                Image = { Color = "0 0 0 0" }
            }, "PANEL_MAIN_REPORT", "REPORT_HISTORY_PANEL");

            for (int i = 0; i < ReportInformation[Suspect.userID].ReportHistory.Count; i++)
            {
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = $"0 {0.7755102 - (i * 0.18)}", AnchorMax = $"1 {1 - (i * 0.18)}" },
                    Text = { Text = ReportInformation[Suspect.userID].ReportHistory[i], FontSize = 15, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter, Color = HexToRustFormat(Interface.HexLabels) }
                },  "REPORT_HISTORY_PANEL", $"REASON_{i}");

                if (i >= 5) break;
            }

            if (config.RCCSetting.RCCUse)
            {
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.6400454 0.4695393", AnchorMax = "0.9918971 0.5349184" },
                    Text = { Text = lang.GetMessage("UI_NEW_MODERATION_MODER_GO_CHECK_MORE_HISTORY_RCC", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                }, "PANEL_MAIN_REPORT");

                string Key = config.RCCSetting.Key;
                if (!String.IsNullOrEmpty(Key))
                {
                    try
                    {
                        string API = $"https://rustcheatcheck.ru/panel/api?action=getInfo&key={Key}&player={Suspect.userID}";
                        webrequest.Enqueue(API, null, (code, response) =>
                        {
                            string ServersCheck = "Был проверен на серверах:";
                            var resources = JsonConvert.DeserializeObject<Response>(response);
                            if (resources.last_check == null)
                                ServersCheck += $"\nНе проверялся";
                            else
                            {
                                foreach (var resource in resources.last_check)
                                    ServersCheck += $"\n{resource.serverName}";
                            }

                            CuiHelper.DestroyUi(player, "LABELRCC");
                            CuiElementContainer RCCCONT = new CuiElementContainer();

                            RCCCONT.Add(new CuiLabel
                            {
                                RectTransform = { AnchorMin = $"0.6400445 0.3254086", AnchorMax = $"0.9918977 0.4665672" },
                                Text = { Text = ServersCheck, FontSize = 15, Font = "robotocondensed-regular.ttf", Align = TextAnchor.UpperCenter, Color = HexToRustFormat(Interface.HexLabels) }
                            }, "PANEL_MAIN_REPORT", "LABELRCC");

                            CuiHelper.AddUi(player, RCCCONT);
                        }, this);
                    }
                    catch (Exception ex) { }
                }
            }

            #endregion

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.1006964 0.01188706", AnchorMax = "0.4421295 0.08023772" },
                Button = { Close = PARENT_UI_MODER_REPORT, Color = HexToRustFormat(InterfaceReport.HexClose) },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_CLOSE", this, player.UserIDString), Align = TextAnchor.MiddleCenter }
            }, $"PANEL_MAIN_REPORT", $"BTN_CLOSE");

            container.Add(new CuiElement
            {
                Parent = $"BTN_CLOSE",
                Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = InterfaceReport.SpriteClose },
                        new CuiRectTransformComponent { AnchorMin = "0.006779703 0.04347827", AnchorMax = "0.1491535 0.9565219" }
                    }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5462967 0.01188706", AnchorMax = "0.8877298 0.08023772" },
                Button = { Close = PARENT_UI_MODER_REPORT, Command = $"iqreport send_check {Suspect.userID}", Color = HexToRustFormat(InterfaceReport.HexButton) },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_GOCHECK", this, player.UserIDString), Align = TextAnchor.MiddleCenter }
            }, $"PANEL_MAIN_REPORT", $"BTN_GO_CHECK");

            container.Add(new CuiElement
            {
                Parent = $"BTN_GO_CHECK",
                Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = InterfaceReport.SpriteClose },
                        new CuiRectTransformComponent { AnchorMin = "0.006779703 0.04347827", AnchorMax = "0.1491535 0.9565219" }
                    }
            });

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region UI Alert Player Check
        void UI_AlertSendPlayer(BasePlayer Suspect)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(Suspect, PARENT_UI_ALERT_SEND);
            var InterfaceAlert = config.Setting.Interface.AlertInterface;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.575", AnchorMax = "1 0.8888889" },
                Image = { FadeIn = 0.15f, Color = HexToRustFormat(InterfaceAlert.HexMain), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            }, "Overlay", PARENT_UI_ALERT_SEND);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.365625 0.2595869", AnchorMax = "0.6463541 0.2772861" },
                Image = { Color = HexToRustFormat(InterfaceAlert.HexTitle), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            },  PARENT_UI_ALERT_SEND);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.7079645", AnchorMax = "1 1" },
                Text = { Text = lang.GetMessage("UI_NEW_ALERT_PLAYER_WARNING",this, Suspect.UserIDString), Color = HexToRustFormat(InterfaceAlert.HexTitle), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperCenter }
            }, PARENT_UI_ALERT_SEND);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.2949852", AnchorMax = "1 0.761062" },
                Text = { Text = lang.GetMessage("UI_NEW_ALERT_PLAYER_TITLE", this, Suspect.UserIDString), Color = HexToRustFormat(InterfaceAlert.HexLabel), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperCenter }
            }, PARENT_UI_ALERT_SEND);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.2300885" },
                Text = { Text = lang.GetMessage("UI_NEW_ALERT_PLAYER_DESC", this, Suspect.UserIDString), Color = HexToRustFormat(InterfaceAlert.HexLabel), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperCenter }
            }, PARENT_UI_ALERT_SEND);

            CuiHelper.AddUi(Suspect, container);
        }
        #endregion

        #region UI Moder Menu
        
        void UI_MiniPanelModerator(BasePlayer player, ulong SuspectID)
        {
            CuiHelper.DestroyUi(player, PARENT_UI_MODERATOR_MINI_PANEL);
            CuiElementContainer container = new CuiElementContainer();
            var Interface = config.Setting.Interface.ModderatorPanel;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-450 15", OffsetMax = "-220 130" },
                Image = { Color = HexToRustFormat(Interface.HexMain) }
            }, "Overlay", PARENT_UI_MODERATOR_MINI_PANEL);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.7797101", AnchorMax = "1 1" },
                Image = { Color = HexToRustFormat(Interface.HexTitlePanel) }
            }, PARENT_UI_MODERATOR_MINI_PANEL, "TITLE_PANEL");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.1130193", AnchorMax = "1 1" }, 
                Text = { Text = lang.GetMessage("UI_NEW_MINI_PANEL_MODERATOR_TITLE", this, player.UserIDString), Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter, Color = HexToRustFormat(Interface.HexLabel) }
            },  "TITLE_PANEL");

            container.Add(new CuiElement
            {
                Parent = $"TITLE_PANEL",
                Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabel), Sprite = Interface.SpriteTitlePanel },
                        new CuiRectTransformComponent { AnchorMin = "0.005797102 0.07894736", AnchorMax = "0.09855073 0.9210525" }
                    }
            }); 
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.008695543 0.03614452", AnchorMax = $"0.48 0.5" },
                Button = { Command = $"iqreport moderator_stop {SuspectID}", Color = HexToRustFormat(Interface.HexStopButton) },
                Text = { Text = lang.GetMessage("UI_NEW_MINI_PANEL_MODERATOR_STOP", this, player.UserIDString), Align = TextAnchor.MiddleCenter, Color = HexToRustFormat(Interface.HexLabel) }
            }, PARENT_UI_MODERATOR_MINI_PANEL);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.5188398 0.03614452", AnchorMax = $"0.9913077 0.5" },
                Button = { Command = $"iqreport moderator_reason_ban {SuspectID}", Color = HexToRustFormat(Interface.HexBanButton) },
                Text = { Text = lang.GetMessage("UI_NEW_MINI_PANEL_MODERATOR_BAN", this, player.UserIDString), Align = TextAnchor.MiddleCenter, Color = HexToRustFormat(Interface.HexLabel) }
            }, PARENT_UI_MODERATOR_MINI_PANEL);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.01159436 0.5478261", AnchorMax = "0.7072465 0.7333333" },
                Text = { Text = $"Discord : {PlayerSaveCheck[SuspectID].Discord}", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.UpperCenter, Color = HexToRustFormat("#FFFFFFFF") }
            }, PARENT_UI_MODERATOR_MINI_PANEL, UI_MODERATION_CHECK_MENU_DISCORD);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.6782616 0.5478261", AnchorMax = "0.9884076 0.7333333" },
                Text = { Text = $"{PlayerSaveCheck[SuspectID].StatusNetwork}", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.UpperCenter, Color = HexToRustFormat("#FFFFFFFF") }
            }, PARENT_UI_MODERATOR_MINI_PANEL, UI_MODERATION_CHECK_MENU_NETWORK);

            CuiHelper.AddUi(player, container);
        }
        void UI_OpenReasonsBan(BasePlayer player, ulong SuspectID)
        {
            CuiElementContainer container = new CuiElementContainer();
            var Interface = config.Setting.Interface.ModderatorPanel;

            for (int i = 0; i < config.ReasonBan.Count; i++)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0 1", AnchorMax = $"0 1", OffsetMin = $"0 {2 + (i * 30)}", OffsetMax = $"230 {30 + (i * 30)}" },
                    Button = { FadeIn = 0.3f + (i / 10), Command = $"iqreport moderator_ban {SuspectID} {i}", Color = HexToRustFormat(Interface.HexBanButton) },
                    Text = { Text = config.ReasonBan[i].DisplayName, FontSize = 15, Align = TextAnchor.MiddleCenter, Color = HexToRustFormat(Interface.HexLabel) }
                },  PARENT_UI_MODERATOR_MINI_PANEL);
            }

            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region UI Raiting Moderation
        void UI_RaitingSend(BasePlayer player, BasePlayer Moderator)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, UI_MODERATION_RAITING);
            var Interface = config.Setting.Interface.RaitingInterface;

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-450 15", OffsetMax = "-220 100" },
                Image = { Color = HexToRustFormat(Interface.HexMain), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            }, "Overlay", UI_MODERATION_RAITING);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.6", AnchorMax = "0.99 0.99" },
                Image = { Color = HexToRustFormat(Interface.HexTitlePanel), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            }, UI_MODERATION_RAITING,"TITLE_PANEL");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.1536232 0", AnchorMax = "1 1" },
                Text = { Text = lang.GetMessage("UI_NEW_RAITING_PANEL", this, player.UserIDString), Font = "robotocondensed-regular.ttf", Color = HexToRustFormat(Interface.HexLabel), Align = TextAnchor.MiddleCenter }
            }, "TITLE_PANEL");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.01449275 0.07843139", AnchorMax = $"0.1362319 0.901961" },
                Image = { Color = HexToRustFormat(Interface.HexLabel), Sprite = Interface.SpriteTitlePanel}
            },  "TITLE_PANEL");

            for (int i = 1, x = 0; i < 6; i++, x++)
            {
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"{0.02451923 + (x * 0.2)} 0.1933336", AnchorMax = $"{0.1886218 + (x * 0.2)} 0.6200002" },
                    Image = { Color = HexToRustFormat(Interface.HexRaitingButton), Sprite = Interface.SpriteRaiting}
                }, UI_MODERATION_RAITING, $"STAR_{i}");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Close = UI_MODERATION_RAITING, Command = $"iqreport raiting {Moderator.userID} {i}", Color = "0 0 0 0" },
                    Text = { Text = "", Color = "0 0 0 0", FontSize = 30, Align = TextAnchor.MiddleLeft }
                }, $"STAR_{i}");
            }

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #endregion

        #region Hooks
        private void OnServerInitialized()
        {
            ReportInformation = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, PlayerInfo>>("IQReportSystem/Reports");
            ModeratorInformation = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, ModeratorInfo>>("IQReportSystem/Moders");

            foreach (var player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);

            permission.RegisterPermission(PermissionModeration, this);
            permission.RegisterPermission(PermissionAdmin, this);
        }
        object OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel)
        {
            if (AFKCheckedTry.ContainsKey(player.userID))
            {
                BasePlayer Moderator = BasePlayer.FindByID(PlayerSaveCheck[player.userID].ModeratorID);
                if(Moderator != null)
                    SendChat(Moderator, lang.GetMessage("PLAYER_AFK_ACTIVE_CHAT", this, Moderator.UserIDString));
                
                AFKCheckedTry[player.userID]++;
            }
            return null;
        }

        void OnPlayerCommand(BasePlayer player, string command, string[] args)
        {
            if (AFKCheckedTry.ContainsKey(player.userID))
            {
                BasePlayer Moderator = BasePlayer.FindByID(PlayerSaveCheck[player.userID].ModeratorID);
                if (Moderator != null)
                    SendChat(Moderator, String.Format(lang.GetMessage("PLAYER_AFK_ACTIVE_CMD", this, Moderator.UserIDString), command));

                AFKCheckedTry[player.userID]++;
            }
        }
        void OnPlayerConnected(BasePlayer player) => Metods_PlayerConnected(player);
        private void Unload()
        {
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQReportSystem/Reports", ReportInformation);
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQReportSystem/Moders", ModeratorInformation);

            foreach (var p in BasePlayer.activePlayerList)
                DestroyAll(p);
        }
        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            Metods_StatusNetwork(player, reason);
            Metods_ModeratorExitCheck(player);
        }

        void DestroyAll(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PARENT_UI);
            CuiHelper.DestroyUi(player, PARENT_UI_REPORT_MENU);
            CuiHelper.DestroyUi(player, PARENT_UI_PLAYER_PANEL);
            CuiHelper.DestroyUi(player, PARENT_UI_PLAYER_REPORT);
            CuiHelper.DestroyUi(player, PARENT_UI_MODER_REPORT);
            CuiHelper.DestroyUi(player, PARENT_UI_ALERT_SEND);
            CuiHelper.DestroyUi(player, PARENT_UI_MODERATOR_MINI_PANEL);
            CuiHelper.DestroyUi(player, UI_MODERATION_CHECK_MENU_DISCORD);
            CuiHelper.DestroyUi(player, UI_MODERATION_CHECK_MENU_NETWORK);
            CuiHelper.DestroyUi(player, UI_MODERATION_RAITING);
        }

        #endregion

        #region Helps

        #region PluginsAPI

        void VKSendMessage(string Message)
        {
            if (!config.Setting.VKMessage) return;
            var VK = config.Setting.VKSettings;
            if (String.IsNullOrEmpty(VK.ChatID) || String.IsNullOrEmpty(VK.Token))
            {
                PrintWarning("Вы не настроили конфигурацию,в пункте с ВК");
                return;
            }
            int RandomID = UnityEngine.Random.Range(0, 9999);
            while (Message.Contains("#"))
                Message = Message.Replace("#", "%23");
            webrequest.Enqueue($"https://api.vk.com/method/messages.send?chat_id={VK.ChatID}&random_id={RandomID}&message={Message}&access_token={VK.Token}&v=5.92", null, (code, response) => { }, this);
        }

        void DiscordSendMessage(string key, ulong userID = 0, params object[] args)
        {
            if (!config.Setting.DiscrodMessage) return;
            if (String.IsNullOrEmpty(config.Setting.WebHook)) return;

            List<Fields> fields = new List<Fields>
                {
                    new Fields("IQReportSystem", key, true),
                };

            FancyMessage newMessage = new FancyMessage(null, false, new FancyMessage.Embeds[1] { new FancyMessage.Embeds(null, 635133, fields, new Authors("IQReportSystem", "https://vk.com/mercurydev", "https://i.imgur.com/ILk3uJc.png", null), new Footer("Author: Mercury[https://vk.com/mercurydev]", "https://i.imgur.com/ILk3uJc.png", null)) });
            Request($"{config.Setting.WebHook}", newMessage.toJSON());
        }

        #region FancyDiscord
        public class FancyMessage
        {
            public string content { get; set; }
            public bool tts { get; set; }
            public Embeds[] embeds { get; set; }

            public class Embeds
            {
                public string title { get; set; }
                public int color { get; set; }
                public List<Fields> fields { get; set; }
                public Footer footer { get; set; }
                public Authors author { get; set; }

                public Embeds(string title, int color, List<Fields> fields, Authors author, Footer footer)
                {
                    this.title = title;
                    this.color = color;
                    this.fields = fields;
                    this.author = author;
                    this.footer = footer;

                }
            }

            public FancyMessage(string content, bool tts, Embeds[] embeds)
            {
                this.content = content;
                this.tts = tts;
                this.embeds = embeds;
            }

            public string toJSON() => JsonConvert.SerializeObject(this);
        }

        public class Footer
        {
            public string text { get; set; }
            public string icon_url { get; set; }
            public string proxy_icon_url { get; set; }
            public Footer(string text, string icon_url, string proxy_icon_url)
            {
                this.text = text;
                this.icon_url = icon_url;
                this.proxy_icon_url = proxy_icon_url;
            }
        }

        public class Authors
        {
            public string name { get; set; }
            public string url { get; set; }
            public string icon_url { get; set; }
            public string proxy_icon_url { get; set; }
            public Authors(string name, string url, string icon_url, string proxy_icon_url)
            {
                this.name = name;
                this.url = url;
                this.icon_url = icon_url;
                this.proxy_icon_url = proxy_icon_url;
            }
        }

        public class Fields
        {
            public string name { get; set; }
            public string value { get; set; }
            public bool inline { get; set; }
            public Fields(string name, string value, bool inline)
            {
                this.name = name;
                this.value = value;
                this.inline = inline;
            }
        }

        private void Request(string url, string payload, Action<int> callback = null)
        {
            Dictionary<string, string> header = new Dictionary<string, string>();
            header.Add("Content-Type", "application/json");
            webrequest.Enqueue(url, payload, (code, response) =>
            {
                if (code != 200 && code != 204)
                {
                    if (response != null)
                    {
                        try
                        {
                            JObject json = JObject.Parse(response);
                            if (code == 429)
                            {
                                float seconds = float.Parse(Math.Ceiling((double)(int)json["retry_after"] / 1000).ToString());
                            }
                            else
                            {
                                PrintWarning($" Discord rejected that payload! Responded with \"{json["message"].ToString()}\" Code: {code}");
                            }
                        }
                        catch
                        {
                            PrintWarning($"Failed to get a valid response from discord! Error: \"{response}\" Code: {code}");
                        }
                    }
                    else
                    {
                        PrintWarning($"Discord didn't respond (down?) Code: {code}");
                    }
                }
                try
                {
                    callback?.Invoke(code);
                }
                catch (Exception ex) { }

            }, this, RequestMethod.POST, header);
        }
        #endregion

        int API_GET_REPORT_COUNT(ulong UserID)
        {
            var User = ReportInformation[UserID];
            return User.ReportCount;
        }
        int API_GET_CHECK_COUNT(ulong UserID)
        {
            var User = ReportInformation[UserID];
            return User.CheckCount;
        }
        List<string> API_GET_LIST_API(ulong UserID)
        {
            var User = ReportInformation[UserID];
            return User.IP;
        }
        string API_GET_GAME_STATUS(ulong UserID)
        {
            var User = ReportInformation[UserID];
            return User.GameStatus;
        }
        string API_GET_LAST_CHECK_MODERATOR(ulong UserID)
        {
            var User = ReportInformation[UserID];
            return User.LastCheckModerator;
        }
        string API_GET_LAST_REPORT(ulong UserID)
        {
            var User = ReportInformation[UserID];
            return User.LastReport;
        }
        List<string> API_GET_REPORT_HISTORY(ulong UserID)
        {
            var User = ReportInformation[UserID];
            return User.ReportHistory;
        }

        #endregion

        #region MSG
        public void SendChat(BasePlayer player,string Message, Chat.ChatChannel channel = Chat.ChatChannel.Global)
        {
            var Chat = config.Setting.ChatSetting;
            if (IQChat)
                IQChat?.Call("API_ALERT_PLAYER", player, Message, Chat.CustomPrefix, Chat.CustomAvatar);
            else player.SendConsoleCommand("chat.add", channel, 0, Message);
        }

        #endregion

        #region Hex
        private static string HexToRustFormat(string hex)
        {
            Color color;
            ColorUtility.TryParseHtmlString(hex, out color);
            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }
        #endregion

        #region Steam

        string IsSteam(string id)
        {        
            if (MultiFighting != null)
            {
                var player = BasePlayer.Find(id);
                if (player == null)
                {
                    return "ERROR #1";
                }
                var obj = MultiFighting.CallHook("IsSteam", player.Connection);
                if (obj is bool)
                {
                    if ((bool)obj)
                    {
                        return lang.GetMessage("IS_STEAM_STATUS_LICENSE", this, id); 
                    }
                    else
                    {
                        return lang.GetMessage("IS_STEAM_STATUS_PIRATE",this,id);
                    }
                }
                else
                {
                    return "ERROR #2";
                }
            }
            else return lang.GetMessage("IS_STEAM_STATUS_LICENSE", this, id);
        }

        #endregion

        #region Format

        static DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        static double CurrentTime() => DateTime.UtcNow.Subtract(epoch).TotalSeconds;

        public static string FormatTime(TimeSpan time)
        {
            string result = string.Empty;
            if (time.Days != 0)
                result += $"{Format(time.Days, "дней", "дня", "день")} ";

            if (time.Hours != 0)
                result += $"{Format(time.Hours, "часов", "часа", "час")} ";

            if (time.Minutes != 0)
                result += $"{Format(time.Minutes, "минут", "минуты", "минута")} ";

            if (time.Seconds != 0)
                result += $"{Format(time.Seconds, "секунд", "секунды", "секунда")} ";

            return result;
        }

        private static string Format(int units, string form1, string form2, string form3)
        {
            var tmp = units % 10;

            if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                return $"{units} {form1}";

            if (tmp >= 2 && tmp <= 4)
                return $"{units} {form2}";

            return $"{units} {form3}";
        }

        #endregion

        #endregion
    }
}


// --- End of file: IQReportSystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/RealisticWeather.cs ---
// --- Original Local Path: KualaRust/RealisticWeather.cs ---

using System.Collections.Generic;
using System.Linq;
namespace Oxide.Plugins
{
    [Info("Realistic Weather", "OuTSMoKE", "1.1.4", ResourceId = 2519)]
    [Description("Calls weather events with console commands.")]
    class RealisticWeather : RustPlugin
    {
        public Timer StormTimer;
        public int time = 0;
		public List<string> cmds = new List<string>
        {
            "rw rain",
            "rw lightrain",
            "rw longrain",
			"rw storm",
			"rw longstorm",
			"rw lightfog",
			"rw fog",
			"rw heavyfog",
			"rw overcast"
        };

        void Unload()
        {
            if (StormTimer != null)
                StormTimer.Destroy();
            time = 0;
        }

        [ConsoleCommand("rw")]
        void cmdSpecial(ConsoleSystem.Arg arg)
        {
            if (!arg.IsServerside) return;
            if (arg.Args == null || arg.Args.Count() == 0) return;
            var stormType = arg.Args[0];
            if (stormType.Equals("random"))
            {
                stormType = Storms.Keys.ToList().GetRandom();
                arg.ReplyWith($"Running random storm: {stormType}");
            }
            if (!Storms.ContainsKey(stormType)) return;
            NewStormTimer(stormType);
        }

        void NewStormTimer(string TypeOfStorm)
        {
            if (StormTimer != null)
                StormTimer.Destroy();
            time = 0;
            StormTimer = timer.Every(1, () => ProcessStorm(Storms[TypeOfStorm]));
        }

        void ProcessStorm(Dictionary<int, List<string>> StormData)
        {
            time++;
            if (StormData.ContainsKey(time))
                foreach (var entry in StormData[time])
                {
                    if (entry == "STOP") { StormTimer.Destroy(); time = 0; return; }
                    ConsoleSystem.Run(ConsoleSystem.Option.Server, entry);
                }
        }

        public Dictionary<string, Dictionary<int, List<string>>> Storms = new Dictionary<string, Dictionary<int, List<string>>>
                {
                    {"storm", new Dictionary<int, List<string>>
                    {
                        {1, new List<string> {"weather.clouds 0.02" } },
						{10, new List<string> {"weather.clouds 0.04" } },
						{20, new List<string> {"weather.clouds 0.06" } },
						{30, new List<string> {"weather.clouds 0.08" } },
						{40, new List<string> {"weather.clouds 0.1" } },
						{50, new List<string> {"weather.clouds 0.12" } },
						{60, new List<string> {"weather.clouds 0.14" } },
						{70, new List<string> {"weather.clouds 0.16" } },
						{80, new List<string> {"weather.clouds 0.18" } },
						{90, new List<string> {"weather.clouds 0.2" } },
						{100, new List<string> {"weather.clouds 0.22" } },
						{110, new List<string> {"weather.clouds 0.24" } },
						{120, new List<string> {"weather.clouds 0.26" } },
						{130, new List<string> {"weather.clouds 0.28" } },
						{140, new List<string> {"weather.clouds 0.3" } },
						{150, new List<string> {"weather.clouds 0.32" } },
						{160, new List<string> {"weather.clouds 0.34" } },
						{170, new List<string> {"weather.clouds 0.36" } },
						{180, new List<string> {"weather.clouds 0.38" } },
						{190, new List<string> {"weather.clouds 0.4" } },
						{200, new List<string> {"weather.clouds 0.42" } },
						{210, new List<string> {"weather.clouds 0.44" } },
						{220, new List<string> {"weather.clouds 0.46" } },
						{230, new List<string> {"weather.clouds 0.48" } },
						{240, new List<string> {"weather.clouds 0.5" } },
						{250, new List<string> {"weather.fog 0.02" } },
						{260, new List<string> {"weather.clouds 0.52" } },
						{270, new List<string> {"weather.fog 0.04" } },
						{280, new List<string> {"weather.clouds 0.54" } },
						{290, new List<string> {"weather.fog 0.06" } },
						{300, new List<string> {"weather.clouds 0.56" } },
						{310, new List<string> {"weather.fog 0.08" } },
						{320, new List<string> {"weather.clouds 0.58" } },
						{330, new List<string> {"weather.fog 0.1" } },
						{340, new List<string> {"weather.clouds 0.6" } },
						{350, new List<string> {"weather.fog 0.12" } },
						{360, new List<string> {"weather.clouds 0.62" } },
						{370, new List<string> {"weather.fog 0.14" } },
						{380, new List<string> {"weather.clouds 0.64" } },
						{390, new List<string> {"weather.fog 0.16" } },
						{400, new List<string> {"weather.clouds 0.66" } },
						{410, new List<string> {"weather.fog 0.18" } },
						{420, new List<string> {"weather.clouds 0.68" } },
						{430, new List<string> {"weather.fog 0.20" } },
						{440, new List<string> {"weather.clouds 0.7" } },
						{450, new List<string> {"weather.fog 0.22" } },
						{460, new List<string> {"weather.clouds 0.72" } },
						{470, new List<string> {"weather.fog 0.24" } },
						{480, new List<string> {"weather.clouds 0.74" } },
						{490, new List<string> {"weather.fog 0.26" } },
						{500, new List<string> {"weather.clouds 0.76" } },
						{510, new List<string> {"weather.fog 0.28" } },
						{520, new List<string> {"weather.clouds 0.78" } },
						{530, new List<string> {"weather.fog 0.3" } },
						{540, new List<string> {"weather.clouds 0.8" } },
						{550, new List<string> {"weather.fog 0.32" } },
						{560, new List<string> {"weather.clouds 0.82" } },
						{570, new List<string> {"weather.fog 0.34" } },
						{580, new List<string> {"weather.clouds 0.84" } },
						{590, new List<string> {"weather.fog 0.36" } },
						{600, new List<string> {"weather.clouds 0.86" } },
						{605, new List<string> {"weather.wind 0.2" } },
						{610, new List<string> {"weather.fog 0.38" } },
						{620, new List<string> {"weather.clouds 0.88" } },
						{630, new List<string> {"weather.fog 0.4" } },
						{640, new List<string> {"weather.clouds 0.9" } },
						{650, new List<string> {"weather.fog 0.42" } },
						{660, new List<string> {"weather.clouds 0.92" } },
						{670, new List<string> {"weather.fog 0.44" } },
						{680, new List<string> {"weather.clouds 0.94" } },
						{690, new List<string> {"weather.fog 0.46" } },
						{700, new List<string> {"weather.clouds 0.96" } },
						{710, new List<string> {"weather.fog 0.48" } },
						{720, new List<string> {"weather.clouds 0.98" } },
						{725, new List<string> {"weather.wind 0.4" } },
						{730, new List<string> {"weather.fog 0.5" } },
						{740, new List<string> {"weather.clouds 1" } },
						{750, new List<string> {"weather.fog 0.52" } },
						{760, new List<string> {"weather.fog 0.54" } },
						{780, new List<string> {"weather.fog 0.56" } },
						{790, new List<string> {"weather.fog 0.58" } },
						{800, new List<string> {"weather.fog 0.6" } },
						{810, new List<string> {"weather.fog 0.62" } },
						{820, new List<string> {"weather.fog 0.64" } },
						{830, new List<string> {"weather.fog 0.66" } },
						{840, new List<string> {"weather.fog 0.68" } },
						{850, new List<string> {"weather.fog 0.7", "weather.wind 0.6" } },
						{860, new List<string> {"weather.fog 0.72" } },
						{870, new List<string> {"weather.fog 0.74" } },
						{880, new List<string> {"weather.fog 0.76" } },
						{890, new List<string> {"weather.fog 0.78" } },
						{900, new List<string> {"weather.fog 0.8" } },
						{905, new List<string> {"weather.wind 0.8" } },
						{910, new List<string> {"weather.fog 0.82" } },
						{920, new List<string> {"weather.fog 0.84" } },
						{930, new List<string> {"weather.fog 0.86" } },
						{940, new List<string> {"weather.fog 0.88" } },
						{950, new List<string> {"weather.fog 0.9" } },
						{960, new List<string> {"weather.fog 0.92" } },
						{965, new List<string> {"weather.wind 1" } },
						{970, new List<string> {"weather.fog 0.94" } },
						{980, new List<string> {"weather.fog 0.96" } },
						{990, new List<string> {"weather.fog 0.98" } },
						{1000, new List<string> {"weather.fog 1" } },
						{1300, new List<string> {"weather.fog 0.98" } },
						{1310, new List<string> {"weather.fog 0.96" } },
						{1320, new List<string> {"weather.fog 0.94" } },
						{1330, new List<string> {"weather.fog 0.92" } },
						{1340, new List<string> {"weather.fog 0.9" } },
						{1350, new List<string> {"weather.fog 0.88" } },
						{1360, new List<string> {"weather.fog 0.86" } },
						{1365, new List<string> {"weather.wind 0.8" } },
						{1370, new List<string> {"weather.fog 0.84" } },
						{1380, new List<string> {"weather.fog 0.82" } },
						{1390, new List<string> {"weather.fog 0.8" } },
						{1395, new List<string> {"weather.wind 0.6" } },
						{1400, new List<string> {"weather.fog 0.78" } },
						{1410, new List<string> {"weather.fog 0.76" } },
						{1420, new List<string> {"weather.fog 0.74" } },
						{1430, new List<string> {"weather.fog 0.72" } },
						{1440, new List<string> {"weather.fog 0.7" } },
						{1450, new List<string> {"weather.fog 0.68" } },
						{1460, new List<string> {"weather.fog 0.66", "weather.wind 0.4" } },
						{1470, new List<string> {"weather.fog 0.64" } },
						{1480, new List<string> {"weather.fog 0.62" } },
						{1490, new List<string> {"weather.fog 0.6" } },
						{1500, new List<string> {"weather.fog 0.58" } },
						{1510, new List<string> {"weather.fog 0.56" } },
						{1520, new List<string> {"weather.fog 0.54" } },
						{1530, new List<string> {"weather.fog 0.52" } },
						{1540, new List<string> {"weather.fog 0.5", "weather.wind 0.2" } },
						{1550, new List<string> {"weather.clouds 0.98" } },
						{1560, new List<string> {"weather.fog 0.48" } },
						{1570, new List<string> {"weather.clouds 0.96" } },
						{1580, new List<string> {"weather.fog 0.46" } },
						{1590, new List<string> {"weather.clouds 0.94" } },
						{1600, new List<string> {"weather.fog 0.44" } },
						{1610, new List<string> {"weather.clouds 0.92" } },
						{1620, new List<string> {"weather.fog 0.42" } },
						{1630, new List<string> {"weather.clouds 0.9" } },
						{1635, new List<string> {"weather.wind 0" } },
						{1640, new List<string> {"weather.fog 0.4" } },
						{1650, new List<string> {"weather.clouds 0.88" } },
						{1660, new List<string> {"weather.fog 0.38" } },
						{1670, new List<string> {"weather.clouds 0.86" } },
						{1680, new List<string> {"weather.fog 0.36" } },
						{1690, new List<string> {"weather.clouds 0.84" } },
						{1700, new List<string> {"weather.fog 0.34" } },
						{1710, new List<string> {"weather.clouds 0.82" } },
						{1720, new List<string> {"weather.fog 0.32" } },
						{1730, new List<string> {"weather.clouds 0.8" } },
						{1740, new List<string> {"weather.fog 0.3" } },
						{1750, new List<string> {"weather.clouds 0.78" } },
						{1760, new List<string> {"weather.fog 0.28" } },
						{1770, new List<string> {"weather.clouds 0.76" } },
						{1780, new List<string> {"weather.fog 0.26" } },
						{1790, new List<string> {"weather.clouds 0.74" } },
						{1800, new List<string> {"weather.fog 0.24" } },
						{1810, new List<string> {"weather.clouds 0.72" } },
						{1820, new List<string> {"weather.fog 0.22" } },
						{1830, new List<string> {"weather.clouds 0.7" } },
						{1840, new List<string> {"weather.fog 0.2" } },
						{1850, new List<string> {"weather.clouds 0.68" } },
						{1860, new List<string> {"weather.fog 0.18" } },
						{1870, new List<string> {"weather.clouds 0.66" } },
						{1880, new List<string> {"weather.fog 0.16" } },
						{1890, new List<string> {"weather.clouds 0.64" } },
						{1900, new List<string> {"weather.fog 0.14" } },
						{1910, new List<string> {"weather.clouds 0.62" } },
						{1920, new List<string> {"weather.fog 0.12" } },
						{1930, new List<string> {"weather.clouds 0.6" } },
						{1940, new List<string> {"weather.fog 0.1" } },
						{1950, new List<string> {"weather.clouds 0.58" } },
						{1960, new List<string> {"weather.fog 0.08" } },
						{1970, new List<string> {"weather.clouds 0.56" } },
						{1980, new List<string> {"weather.fog 0.06" } },
						{1990, new List<string> {"weather.clouds 0.54" } },
						{2000, new List<string> {"weather.fog 0.04" } },
						{2010, new List<string> {"weather.clouds 0.52" } },
						{2020, new List<string> {"weather.fog 0.02" } },
						{2030, new List<string> {"weather.clouds 0.5" } },
						{2040, new List<string> {"weather.fog 0" } },
						{2050, new List<string> {"weather.clouds 0.48" } },
						{2060, new List<string> {"weather.clouds 0.46" } },
						{2070, new List<string> {"weather.clouds 0.44" } },
						{2080, new List<string> {"weather.clouds 0.42" } },
						{2090, new List<string> {"weather.clouds 0.4" } },
						{2100, new List<string> {"weather.clouds 0.38" } },
						{2110, new List<string> {"weather.clouds 0.36" } },
						{2120, new List<string> {"weather.clouds 0.34" } },
						{2130, new List<string> {"weather.clouds 0.32" } },
						{2140, new List<string> {"weather.clouds 0.3" } },
						{2150, new List<string> {"weather.clouds 0.28" } },
						{2160, new List<string> {"weather.clouds 0.26" } },
						{2170, new List<string> {"weather.clouds 0.24" } },
						{2180, new List<string> {"weather.clouds 0.22" } },
						{2190, new List<string> {"weather.clouds 0.2" } },
						{2200, new List<string> {"weather.clouds 0.18" } },
						{2210, new List<string> {"weather.clouds 0.16" } },
						{2220, new List<string> {"weather.clouds 0.14" } },
						{2230, new List<string> {"weather.clouds 0.12" } },
						{2240, new List<string> {"weather.clouds 0.1" } },
						{2250, new List<string> {"weather.clouds 0.08" } },
						{2260, new List<string> {"weather.clouds 0.06" } },
						{2270, new List<string> {"weather.clouds 0.04" } },
						{2280, new List<string> {"weather.clouds 0.02" } },						
                        {2290, new List<string> {"weather.clouds 0", "STOP" } },
                    }
                    },
                    {"longstorm", new Dictionary<int, List<string>>
                    {
                        {1, new List<string> {"weather.clouds 0.02" } },
						{10, new List<string> {"weather.clouds 0.04" } },
						{20, new List<string> {"weather.clouds 0.06" } },
						{30, new List<string> {"weather.clouds 0.08" } },
						{40, new List<string> {"weather.clouds 0.1" } },
						{50, new List<string> {"weather.clouds 0.12" } },
						{60, new List<string> {"weather.clouds 0.14" } },
						{70, new List<string> {"weather.clouds 0.16" } },
						{80, new List<string> {"weather.clouds 0.18" } },
						{90, new List<string> {"weather.clouds 0.2" } },
						{100, new List<string> {"weather.clouds 0.22" } },
						{110, new List<string> {"weather.clouds 0.24" } },
						{120, new List<string> {"weather.clouds 0.26" } },
						{130, new List<string> {"weather.clouds 0.28" } },
						{140, new List<string> {"weather.clouds 0.3" } },
						{150, new List<string> {"weather.clouds 0.32" } },
						{160, new List<string> {"weather.clouds 0.34" } },
						{170, new List<string> {"weather.clouds 0.36" } },
						{180, new List<string> {"weather.clouds 0.38" } },
						{190, new List<string> {"weather.clouds 0.4" } },
						{200, new List<string> {"weather.clouds 0.42" } },
						{210, new List<string> {"weather.clouds 0.44" } },
						{220, new List<string> {"weather.clouds 0.46" } },
						{230, new List<string> {"weather.clouds 0.48" } },
						{240, new List<string> {"weather.clouds 0.5" } },
						{250, new List<string> {"weather.fog 0.02" } },
						{260, new List<string> {"weather.clouds 0.52" } },
						{270, new List<string> {"weather.fog 0.04" } },
						{280, new List<string> {"weather.clouds 0.54" } },
						{290, new List<string> {"weather.fog 0.06" } },
						{300, new List<string> {"weather.clouds 0.56" } },
						{310, new List<string> {"weather.fog 0.08" } },
						{320, new List<string> {"weather.clouds 0.58" } },
						{330, new List<string> {"weather.fog 0.1" } },
						{340, new List<string> {"weather.clouds 0.6" } },
						{350, new List<string> {"weather.fog 0.12" } },
						{360, new List<string> {"weather.clouds 0.62" } },
						{370, new List<string> {"weather.fog 0.14" } },
						{380, new List<string> {"weather.clouds 0.64" } },
						{390, new List<string> {"weather.fog 0.16" } },
						{400, new List<string> {"weather.clouds 0.66" } },
						{410, new List<string> {"weather.fog 0.18" } },
						{420, new List<string> {"weather.clouds 0.68" } },
						{430, new List<string> {"weather.fog 0.20" } },
						{440, new List<string> {"weather.clouds 0.7" } },
						{450, new List<string> {"weather.fog 0.22" } },
						{460, new List<string> {"weather.clouds 0.72" } },
						{470, new List<string> {"weather.fog 0.24" } },
						{480, new List<string> {"weather.clouds 0.74" } },
						{490, new List<string> {"weather.fog 0.26" } },
						{500, new List<string> {"weather.clouds 0.76" } },
						{510, new List<string> {"weather.fog 0.28" } },
						{520, new List<string> {"weather.clouds 0.78" } },
						{530, new List<string> {"weather.fog 0.3" } },
						{540, new List<string> {"weather.clouds 0.8" } },
						{550, new List<string> {"weather.fog 0.32" } },
						{560, new List<string> {"weather.clouds 0.82" } },
						{570, new List<string> {"weather.fog 0.34" } },
						{580, new List<string> {"weather.clouds 0.84" } },
						{590, new List<string> {"weather.fog 0.36" } },
						{600, new List<string> {"weather.clouds 0.86" } },
						{605, new List<string> {"weather.wind 0.2" } },
						{610, new List<string> {"weather.fog 0.38" } },
						{620, new List<string> {"weather.clouds 0.88" } },
						{630, new List<string> {"weather.fog 0.4" } },
						{640, new List<string> {"weather.clouds 0.9" } },
						{650, new List<string> {"weather.fog 0.42" } },
						{660, new List<string> {"weather.clouds 0.92" } },
						{670, new List<string> {"weather.fog 0.44" } },
						{680, new List<string> {"weather.clouds 0.94" } },
						{690, new List<string> {"weather.fog 0.46" } },
						{700, new List<string> {"weather.clouds 0.96" } },
						{710, new List<string> {"weather.fog 0.48" } },
						{720, new List<string> {"weather.clouds 0.98" } },
						{725, new List<string> {"weather.wind 0.4" } },
						{730, new List<string> {"weather.fog 0.5" } },
						{740, new List<string> {"weather.clouds 1" } },
						{750, new List<string> {"weather.fog 0.52" } },
						{760, new List<string> {"weather.fog 0.54" } },
						{780, new List<string> {"weather.fog 0.56" } },
						{790, new List<string> {"weather.fog 0.58" } },
						{800, new List<string> {"weather.fog 0.6" } },
						{810, new List<string> {"weather.fog 0.62" } },
						{820, new List<string> {"weather.fog 0.64" } },
						{830, new List<string> {"weather.fog 0.66" } },
						{840, new List<string> {"weather.fog 0.68" } },
						{850, new List<string> {"weather.fog 0.7", "weather.wind 0.6" } },
						{860, new List<string> {"weather.fog 0.72" } },
						{870, new List<string> {"weather.fog 0.74" } },
						{880, new List<string> {"weather.fog 0.76" } },
						{890, new List<string> {"weather.fog 0.78" } },
						{900, new List<string> {"weather.fog 0.8" } },
						{905, new List<string> {"weather.wind 0.8" } },
						{910, new List<string> {"weather.fog 0.82" } },
						{920, new List<string> {"weather.fog 0.84" } },
						{930, new List<string> {"weather.fog 0.86" } },
						{940, new List<string> {"weather.fog 0.88" } },
						{950, new List<string> {"weather.fog 0.9" } },
						{960, new List<string> {"weather.fog 0.92" } },
						{965, new List<string> {"weather.wind 1" } },
						{970, new List<string> {"weather.fog 0.94" } },
						{980, new List<string> {"weather.fog 0.96" } },
						{990, new List<string> {"weather.fog 0.98" } },
						{1000, new List<string> {"weather.fog 1" } },
						{1600, new List<string> {"weather.fog 0.98" } },
						{1610, new List<string> {"weather.fog 0.96" } },
						{1620, new List<string> {"weather.fog 0.94" } },
						{1630, new List<string> {"weather.fog 0.92" } },
						{1640, new List<string> {"weather.fog 0.9" } },
						{1650, new List<string> {"weather.fog 0.88" } },
						{1660, new List<string> {"weather.fog 0.86" } },
						{1665, new List<string> {"weather.wind 0.8" } },
						{1670, new List<string> {"weather.fog 0.84" } },
						{1680, new List<string> {"weather.fog 0.82" } },
						{1690, new List<string> {"weather.fog 0.8" } },
						{1695, new List<string> {"weather.wind 0.6" } },
						{1700, new List<string> {"weather.fog 0.78" } },
						{1710, new List<string> {"weather.fog 0.76" } },
						{1720, new List<string> {"weather.fog 0.74" } },
						{1730, new List<string> {"weather.fog 0.72" } },
						{1740, new List<string> {"weather.fog 0.7" } },
						{1750, new List<string> {"weather.fog 0.68" } },
						{1760, new List<string> {"weather.fog 0.66", "weather.wind 0.4" } },
						{1770, new List<string> {"weather.fog 0.64" } },
						{1780, new List<string> {"weather.fog 0.62" } },
						{1790, new List<string> {"weather.fog 0.6" } },
						{1800, new List<string> {"weather.fog 0.58" } },
						{1810, new List<string> {"weather.fog 0.56" } },
						{1820, new List<string> {"weather.fog 0.54" } },
						{1830, new List<string> {"weather.fog 0.52" } },
						{1840, new List<string> {"weather.fog 0.5", "weather.wind 0.2" } },
						{1850, new List<string> {"weather.clouds 0.98" } },
						{1860, new List<string> {"weather.fog 0.48" } },
						{1870, new List<string> {"weather.clouds 0.96" } },
						{1880, new List<string> {"weather.fog 0.46" } },
						{1890, new List<string> {"weather.clouds 0.94" } },
						{1900, new List<string> {"weather.fog 0.44" } },
						{1910, new List<string> {"weather.clouds 0.92" } },
						{1920, new List<string> {"weather.fog 0.42" } },
						{1930, new List<string> {"weather.clouds 0.9" } },
						{1935, new List<string> {"weather.wind 0" } },
						{1940, new List<string> {"weather.fog 0.4" } },
						{1950, new List<string> {"weather.clouds 0.88" } },
						{1960, new List<string> {"weather.fog 0.38" } },
						{1970, new List<string> {"weather.clouds 0.86" } },
						{1980, new List<string> {"weather.fog 0.36" } },
						{1990, new List<string> {"weather.clouds 0.84" } },
						{2000, new List<string> {"weather.fog 0.34" } },
						{2010, new List<string> {"weather.clouds 0.82" } },
						{2020, new List<string> {"weather.fog 0.32" } },
						{2030, new List<string> {"weather.clouds 0.8" } },
						{2040, new List<string> {"weather.fog 0.3" } },
						{2050, new List<string> {"weather.clouds 0.78" } },
						{2060, new List<string> {"weather.fog 0.28" } },
						{2070, new List<string> {"weather.clouds 0.76" } },
						{2080, new List<string> {"weather.fog 0.26" } },
						{2090, new List<string> {"weather.clouds 0.74" } },
						{2100, new List<string> {"weather.fog 0.24" } },
						{2110, new List<string> {"weather.clouds 0.72" } },
						{2120, new List<string> {"weather.fog 0.22" } },
						{2130, new List<string> {"weather.clouds 0.7" } },
						{2140, new List<string> {"weather.fog 0.2" } },
						{2150, new List<string> {"weather.clouds 0.68" } },
						{2160, new List<string> {"weather.fog 0.18" } },
						{2170, new List<string> {"weather.clouds 0.66" } },
						{2180, new List<string> {"weather.fog 0.16" } },
						{2190, new List<string> {"weather.clouds 0.64" } },
						{2200, new List<string> {"weather.fog 0.14" } },
						{2210, new List<string> {"weather.clouds 0.62" } },
						{2220, new List<string> {"weather.fog 0.12" } },
						{2230, new List<string> {"weather.clouds 0.6" } },
						{2240, new List<string> {"weather.fog 0.1" } },
						{2250, new List<string> {"weather.clouds 0.58" } },
						{2260, new List<string> {"weather.fog 0.08" } },
						{2270, new List<string> {"weather.clouds 0.56" } },
						{2280, new List<string> {"weather.fog 0.06" } },
						{2290, new List<string> {"weather.clouds 0.54" } },
						{2300, new List<string> {"weather.fog 0.04" } },
						{2310, new List<string> {"weather.clouds 0.52" } },
						{2320, new List<string> {"weather.fog 0.02" } },
						{2330, new List<string> {"weather.clouds 0.5" } },
						{2340, new List<string> {"weather.fog 0" } },
						{2350, new List<string> {"weather.clouds 0.48" } },
						{2360, new List<string> {"weather.clouds 0.46" } },
						{2370, new List<string> {"weather.clouds 0.44" } },
						{2380, new List<string> {"weather.clouds 0.42" } },
						{2390, new List<string> {"weather.clouds 0.4" } },
						{2400, new List<string> {"weather.clouds 0.38" } },
						{2410, new List<string> {"weather.clouds 0.36" } },
						{2420, new List<string> {"weather.clouds 0.34" } },
						{2430, new List<string> {"weather.clouds 0.32" } },
						{2440, new List<string> {"weather.clouds 0.3" } },
						{2450, new List<string> {"weather.clouds 0.28" } },
						{2460, new List<string> {"weather.clouds 0.26" } },
						{2470, new List<string> {"weather.clouds 0.24" } },
						{2480, new List<string> {"weather.clouds 0.22" } },
						{2490, new List<string> {"weather.clouds 0.2" } },
						{2500, new List<string> {"weather.clouds 0.18" } },
						{2510, new List<string> {"weather.clouds 0.16" } },
						{2520, new List<string> {"weather.clouds 0.14" } },
						{2530, new List<string> {"weather.clouds 0.12" } },
						{2540, new List<string> {"weather.clouds 0.1" } },
						{2550, new List<string> {"weather.clouds 0.08" } },
						{2560, new List<string> {"weather.clouds 0.06" } },
						{2570, new List<string> {"weather.clouds 0.04" } },
						{2580, new List<string> {"weather.clouds 0.02" } },						
                        {2590, new List<string> {"weather.clouds 0", "STOP" } },
                    }
                    },
					{"lightrain", new Dictionary<int, List<string>>
                    {
                        {1, new List<string> {"weather.clouds 0.01" } },
						{10, new List<string> {"weather.clouds 0.02" } },
						{20, new List<string> {"weather.clouds 0.04" } },
						{30, new List<string> {"weather.clouds 0.06" } },
						{40, new List<string> {"weather.clouds 0.08" } },
						{50, new List<string> {"weather.clouds 0.1" } },
						{60, new List<string> {"weather.clouds 0.12" } },
						{70, new List<string> {"weather.clouds 0.14" } },
						{80, new List<string> {"weather.clouds 0.16" } },
						{90, new List<string> {"weather.clouds 0.18" } },
						{100, new List<string> {"weather.clouds 0.2" } },
						{110, new List<string> {"weather.clouds 0.22" } },
						{120, new List<string> {"weather.clouds 0.24" } },
						{130, new List<string> {"weather.clouds 0.26" } },
						{140, new List<string> {"weather.clouds 0.28" } },
						{150, new List<string> {"weather.clouds 0.3" } },
						{160, new List<string> {"weather.clouds 0.32" } },
						{170, new List<string> {"weather.clouds 0.34" } },
						{180, new List<string> {"weather.clouds 0.36" } },
						{190, new List<string> {"weather.clouds 0.38" } },
						{200, new List<string> {"weather.clouds 0.4" } },
						{210, new List<string> {"weather.clouds 0.42" } },
						{220, new List<string> {"weather.clouds 0.44" } },
						{230, new List<string> {"weather.clouds 0.46" } },
						{240, new List<string> {"weather.clouds 0.48" } },
						{250, new List<string> {"weather.clouds 0.5" } },
						{260, new List<string> {"weather.clouds 0.52" } },
						{270, new List<string> {"weather.clouds 0.54" } },
						{280, new List<string> {"weather.clouds 0.56" } },
						{290, new List<string> {"weather.clouds 0.58" } },
						{300, new List<string> {"weather.clouds 0.6" } },
						{310, new List<string> {"weather.clouds 0.62" } },
						{320, new List<string> {"weather.clouds 0.64" } },
						{330, new List<string> {"weather.clouds 0.66" } },
						{340, new List<string> {"weather.clouds 0.68" } },
						{350, new List<string> {"weather.clouds 0.7" } },
						{360, new List<string> {"weather.clouds 0.72" } },
						{370, new List<string> {"weather.clouds 0.74" } },
						{380, new List<string> { "weather.clouds 0.75" } },
						{390, new List<string> { "weather.fog 0.02" } },
						{400, new List<string> { "weather.clouds 0.76" } },
						{410, new List<string> { "weather.fog 0.04" } },
						{420, new List<string> { "weather.clouds 0.78" } },
						{430, new List<string> { "weather.fog 0.06" } },
						{440, new List<string> { "weather.clouds 0.8" } },
						{450, new List<string> { "weather.fog 0.08" } },
						{460, new List<string> { "weather.clouds 0.82" } },
						{470, new List<string> { "weather.fog 0.1" } },
						{490, new List<string> { "weather.clouds 0.84" } },
						{500, new List<string> { "weather.fog 0.12" } },
						{520, new List<string> { "weather.clouds 0.86" } },
						{530, new List<string> { "weather.fog 0.14" } },
						{540, new List<string> { "weather.clouds 0.88" } },
						{550, new List<string> { "weather.fog 0.16" } },
						{570, new List<string> { "weather.clouds 0.9" } },
						{580, new List<string> { "weather.fog 0.18" } },
						{600, new List<string> { "weather.clouds 0.92" } },
						{610, new List<string> { "weather.fog 0.2" } },
						{630, new List<string> { "weather.clouds 0.94" } },
						{640, new List<string> { "weather.fog 0.22" } },
						{650, new List<string> { "weather.clouds 0.96" } },
						{660, new List<string> { "weather.fog 0.24" } },
						{670, new List<string> { "weather.clouds 0.98" } },
						{680, new List<string> { "weather.fog 0.26" } },
						{690, new List<string> { "weather.clouds 1" } },
						{700, new List<string> { "weather.fog 0.28" } },
						{710, new List<string> { "weather.fog 0.3" } },
						{720, new List<string> { "weather.fog 0.32" } },
						{730, new List<string> { "weather.fog 0.34" } },
						{740, new List<string> { "weather.fog 0.35" } },
						{1040, new List<string> { "weather.clouds 0.98" } },
						{1050, new List<string> { "weather.clouds 0.96" } },
						{1060, new List<string> { "weather.clouds 0.94" } },
						{1070, new List<string> { "weather.clouds 0.92" } },
						{1080, new List<string> { "weather.clouds 0.9" } },
						{1100, new List<string> { "weather.clouds 0.88" } },
						{1110, new List<string> { "weather.clouds 0.86" } },
						{1120, new List<string> { "weather.clouds 0.84" } },
						{1130, new List<string> { "weather.clouds 0.82" } },
						{1140, new List<string> { "weather.clouds 0.8" } },
						{1160, new List<string> { "weather.clouds 0.78" } },
						{1170, new List<string> { "weather.clouds 0.76" } },
						{1180, new List<string> { "weather.clouds 0.74" } },
						{1190, new List<string> { "weather.clouds 0.72" } },
						{1200, new List<string> { "weather.clouds 0.7" } },
						{1220, new List<string> { "weather.clouds 0.68" } },
						{1230, new List<string> { "weather.clouds 0.66" } },
						{1240, new List<string> { "weather.clouds 0.64" } },
						{1250, new List<string> { "weather.clouds 0.62" } },
						{1270, new List<string> { "weather.clouds 0.6" } },
						{1280, new List<string> { "weather.clouds 0.58" } },
						{1290, new List<string> { "weather.clouds 0.56" } },
						{1300, new List<string> { "weather.clouds 0.54" } },
						{1310, new List<string> { "weather.clouds 0.52" } },
						{1320, new List<string> { "weather.clouds 0.5" } },
						{1340, new List<string> { "weather.fog 0.34" } },
						{1350, new List<string> { "weather.clouds 0.48" } },
						{1360, new List<string> { "weather.fog 0.32" } },
						{1370, new List<string> { "weather.clouds 0.46" } },
						{1380, new List<string> { "weather.fog 0.3" } },
						{1390, new List<string> { "weather.clouds 0.44" } },
						{1400, new List<string> { "weather.fog 0.28" } },
						{1410, new List<string> { "weather.clouds 0.42" } },
						{1420, new List<string> { "weather.fog 0.26" } },
						{1430, new List<string> { "weather.clouds 0.4" } },
						{1440, new List<string> { "weather.fog 0.24" } },
						{1450, new List<string> { "weather.clouds 0.38" } },
						{1460, new List<string> { "weather.fog 0.22" } },
						{1470, new List<string> { "weather.clouds 0.36" } },
						{1480, new List<string> { "weather.fog 0.2" } },
						{1490, new List<string> { "weather.clouds 0.34" } },
						{1500, new List<string> { "weather.fog 0.18" } },
						{1510, new List<string> { "weather.clouds 0.32" } },
						{1520, new List<string> { "weather.fog 0.16" } },
						{1530, new List<string> { "weather.clouds 0.3" } },
						{1540, new List<string> { "weather.fog 0.14" } },
						{1550, new List<string> { "weather.clouds 0.28" } },
						{1560, new List<string> { "weather.fog 0.12" } },
						{1570, new List<string> { "weather.clouds 0.26" } },
						{1580, new List<string> { "weather.fog 0.1" } },
						{1590, new List<string> { "weather.clouds 0.24" } },
						{1600, new List<string> { "weather.fog 0.08" } },
						{1610, new List<string> { "weather.clouds 0.22" } },
						{1620, new List<string> { "weather.fog 0.06" } },
						{1630, new List<string> { "weather.clouds 0.2" } },
						{1640, new List<string> { "weather.fog 0.04" } },
						{1650, new List<string> { "weather.clouds 0.18" } },
						{1660, new List<string> { "weather.fog 0.02" } },
						{1670, new List<string> { "weather.clouds 0.16" } },
						{1680, new List<string> { "weather.fog 0.01" } },
						{1690, new List<string> { "weather.clouds 0.14" } },
						{1700, new List<string> { "weather.fog 0" } },
						{1710, new List<string> { "weather.clouds 0.12" } },
						{1720, new List<string> { "weather.clouds 0.1" } },
						{1730, new List<string> { "weather.clouds 0.08" } },
						{1740, new List<string> { "weather.clouds 0.06" } },
						{1750, new List<string> { "weather.clouds 0.04" } },
						{1760, new List<string> { "weather.clouds 0.02" } },
                        {1770, new List<string> {"weather.clouds 0", "STOP" } },
                    }
                    },
                    {"rain", new Dictionary<int, List<string>>
                    {
                        {1, new List<string> { "weather.clouds 0.05" } },
                        {30, new List<string> { "weather.clouds 0.1" } },
                        {60, new List<string> { "weather.clouds 0.15" } },
                        {90, new List<string> { "weather.clouds 0.2" } },
                        {120, new List<string> { "weather.clouds 0.25" } },
                        {150, new List<string> { "weather.clouds 0.3" } },
                        {180, new List<string> { "weather.clouds 0.35" } },
                        {210, new List<string> { "weather.clouds 0.4" } },
                        {240, new List<string> { "weather.clouds 0.45" } },
                        {270, new List<string> { "weather.clouds 0.5" } },
                        {300, new List<string> { "weather.clouds 0.55" } },
                        {330, new List<string> { "weather.clouds 0.6" } },
						{360, new List<string> { "weather.clouds 0.85" } },
                        {390, new List<string> { "weather.fog 0.05" } },
                        {410, new List<string> { "weather.clouds 0.9" } },
                        {420, new List<string> { "weather.fog 0.1" } },
                        {450, new List<string> { "weather.fog 0.15" } },
                        {440, new List<string> { "weather.clouds 0.95" } },
                        {470, new List<string> { "weather.clouds 1" } },
                        {480, new List<string> { "weather.fog 0.2" } },
						{500, new List<string> { "weather.fog 0.25" } },
						{520, new List<string> { "weather.fog 0.3" } },
						{540, new List<string> { "weather.fog 0.35" } },
						{560, new List<string> { "weather.fog 0.4" } },
						{580, new List<string> { "weather.fog 0.45" } },
						{600, new List<string> { "weather.fog 0.5" } },
						{980, new List<string> { "weather.clouds 0.95" } },
						{995, new List<string> { "weather.clouds 0.9" } },
						{1000, new List<string> { "weather.fog 0.45" } },
						{1010, new List<string> { "weather.clouds 0.85" } },
						{1030, new List<string> { "weather.fog 0.4" } },
						{1040, new List<string> { "weather.clouds 0.80" } },
						{1060, new List<string> { "weather.fog 0.35" } },
						{1070, new List<string> { "weather.clouds 0.75" } },
						{1090, new List<string> { "weather.fog 0.25" } },
						{1100, new List<string> { "weather.clouds 0.7" } },
						{1110, new List<string> { "weather.fog 0.2" } },
						{1120, new List<string> { "weather.clouds 0.65" } },
						{1130, new List<string> { "weather.fog 0.15" } },
						{1140, new List<string> { "weather.clouds 0.6" } },
						{1150, new List<string> { "weather.fog 0.1" } },
						{1160, new List<string> { "weather.clouds 0.55" } },
						{1170, new List<string> { "weather.fog 0.05" } },
						{1180, new List<string> { "weather.clouds 0.5" } },
						{1200, new List<string> { "weather.fog 0" } },
						{1210, new List<string> { "weather.clouds 0.45" } },
						{1230, new List<string> { "weather.clouds 0.4" } },
						{1250, new List<string> { "weather.clouds 0.35" } },
						{1270, new List<string> { "weather.clouds 0.3" } },
						{1290, new List<string> { "weather.clouds 0.25" } },
						{1310, new List<string> { "weather.clouds 0.20" } },
						{1330, new List<string> { "weather.clouds 0.15" } },
						{1350, new List<string> { "weather.clouds 0.1" } },
						{1370, new List<string> { "weather.clouds 0.05" } },
                        {1390, new List<string> {"weather.clouds 0", "STOP" } },
                    }
                    },
                    {"longrain", new Dictionary<int, List<string>>
                    {
                        {1, new List<string> { "weather.clouds 0.05" } },
                        {30, new List<string> { "weather.clouds 0.1" } },
                        {60, new List<string> { "weather.clouds 0.15" } },
                        {90, new List<string> { "weather.clouds 0.2" } },
                        {120, new List<string> { "weather.clouds 0.25" } },
                        {150, new List<string> { "weather.clouds 0.3" } },
                        {180, new List<string> { "weather.clouds 0.35" } },
                        {210, new List<string> { "weather.clouds 0.4" } },
                        {240, new List<string> { "weather.clouds 0.45" } },
                        {270, new List<string> { "weather.clouds 0.5" } },
                        {300, new List<string> { "weather.clouds 0.55" } },
                        {330, new List<string> { "weather.clouds 0.6" } },
						{360, new List<string> { "weather.clouds 0.85" } },
                        {390, new List<string> { "weather.fog 0.0" } },
                        {410, new List<string> { "weather.clouds 0.9" } },
                        {420, new List<string> { "weather.fog 0.1" } },
                        {450, new List<string> { "weather.fog 0.15" } },
                        {440, new List<string> { "weather.clouds 0.95" } },
                        {470, new List<string> { "weather.clouds 1" } },
                        {480, new List<string> { "weather.fog 0.2" } },
						{500, new List<string> { "weather.fog 0.25" } },
						{520, new List<string> { "weather.fog 0.3" } },
						{540, new List<string> { "weather.fog 0.35" } },
						{560, new List<string> { "weather.fog 0.4" } },
						{580, new List<string> { "weather.fog 0.45" } },
						{600, new List<string> { "weather.fog 0.5" } },
						{1580, new List<string> { "weather.clouds 0.95" } },
						{1595, new List<string> { "weather.clouds 0.9" } },
						{1600, new List<string> { "weather.fog 0.45" } },
						{1610, new List<string> { "weather.clouds 0.85" } },
						{1630, new List<string> { "weather.fog 0.4" } },
						{1640, new List<string> { "weather.clouds 0.80" } },
						{1660, new List<string> { "weather.fog 0.35" } },
						{1670, new List<string> { "weather.clouds 0.75" } },
						{1690, new List<string> { "weather.fog 0.25" } },
						{1700, new List<string> { "weather.clouds 0.7" } },
						{1710, new List<string> { "weather.fog 0.2" } },
						{1720, new List<string> { "weather.clouds 0.65" } },
						{1730, new List<string> { "weather.fog 0.15" } },
						{1740, new List<string> { "weather.clouds 0.6" } },
						{1750, new List<string> { "weather.fog 0.1" } },
						{1760, new List<string> { "weather.clouds 0.55" } },
						{1770, new List<string> { "weather.fog 0.05" } },
						{1780, new List<string> { "weather.clouds 0.5" } },
						{1800, new List<string> { "weather.fog 0" } },
						{1810, new List<string> { "weather.clouds 0.45" } },
						{1830, new List<string> { "weather.clouds 0.4" } },
						{1850, new List<string> { "weather.clouds 0.35" } },
						{1870, new List<string> { "weather.clouds 0.3" } },
						{1890, new List<string> { "weather.clouds 0.25" } },
						{1910, new List<string> { "weather.clouds 0.20" } },
						{1930, new List<string> { "weather.clouds 0.15" } },
						{1950, new List<string> { "weather.clouds 0.1" } },
						{1970, new List<string> { "weather.clouds 0.05" } },
                        {1990, new List<string> {"weather.clouds 0", "STOP" } },
                    }
                    },
					{"lightfog", new Dictionary<int, List<string>>
                    {
                        {1, new List<string> {"weather.clouds 0.02" } },
						{10, new List<string> {"weather.clouds 0.04" } },
						{20, new List<string> {"weather.clouds 0.06" } },
						{30, new List<string> {"weather.clouds 0.08" } },
						{40, new List<string> {"weather.clouds 0.1" } },
						{50, new List<string> {"weather.clouds 0.12" } },
						{60, new List<string> {"weather.clouds 0.14" } },
						{70, new List<string> {"weather.clouds 0.16" } },
						{80, new List<string> {"weather.clouds 0.18" } },
						{90, new List<string> {"weather.clouds 0.2" } },
						{100, new List<string> {"weather.clouds 0.22" } },
						{110, new List<string> {"weather.clouds 0.24" } },
						{120, new List<string> {"weather.clouds 0.26" } },
						{130, new List<string> {"weather.clouds 0.28" } },
						{140, new List<string> {"weather.clouds 0.3" } },
						{150, new List<string> {"weather.clouds 0.32" } },
						{160, new List<string> {"weather.clouds 0.34" } },
						{170, new List<string> {"weather.clouds 0.36" } },
						{180, new List<string> {"weather.clouds 0.38" } },
						{190, new List<string> {"weather.clouds 0.4" } },
						{200, new List<string> {"weather.clouds 0.42" } },
						{210, new List<string> {"weather.clouds 0.44" } },
						{220, new List<string> {"weather.clouds 0.46" } },
						{230, new List<string> {"weather.clouds 0.48" } },
						{240, new List<string> {"weather.clouds 0.5" } },
						{250, new List<string> {"weather.fog 0.02" } },
						{260, new List<string> {"weather.clouds 0.52" } },
						{270, new List<string> {"weather.fog 0.04" } },
						{280, new List<string> {"weather.clouds 0.54" } },
						{290, new List<string> {"weather.fog 0.06" } },
						{300, new List<string> {"weather.clouds 0.56" } },
						{310, new List<string> {"weather.fog 0.08" } },
						{320, new List<string> {"weather.clouds 0.58" } },
						{330, new List<string> {"weather.fog 0.1" } },
						{340, new List<string> {"weather.clouds 0.6" } },
						{350, new List<string> {"weather.fog 0.12" } },
						{360, new List<string> {"weather.clouds 0.62" } },
						{370, new List<string> {"weather.fog 0.14" } },
						{380, new List<string> {"weather.clouds 0.64" } },
						{390, new List<string> {"weather.fog 0.16" } },
						{400, new List<string> {"weather.clouds 0.66" } },
						{410, new List<string> {"weather.fog 0.18" } },
						{420, new List<string> {"weather.clouds 0.68" } },
						{430, new List<string> {"weather.fog 0.20" } },
						{440, new List<string> {"weather.clouds 0.7" } },
						{450, new List<string> {"weather.fog 0.22" } },
						{460, new List<string> {"weather.clouds 0.72" } },
						{470, new List<string> {"weather.fog 0.24" } },
						{480, new List<string> {"weather.clouds 0.74" } },
						{490, new List<string> {"weather.fog 0.25" } },
						{500, new List<string> {"weather.clouds 0.75" } },
						{1190, new List<string> {"weather.clouds 0.74" } },
						{1200, new List<string> {"weather.fog 0.24" } },
						{1210, new List<string> {"weather.clouds 0.72" } },
						{1220, new List<string> {"weather.fog 0.22" } },
						{1230, new List<string> {"weather.clouds 0.7" } },
						{1240, new List<string> {"weather.fog 0.2" } },
						{1250, new List<string> {"weather.clouds 0.68" } },
						{1260, new List<string> {"weather.fog 0.18" } },
						{1270, new List<string> {"weather.clouds 0.66" } },
						{1280, new List<string> {"weather.fog 0.16" } },
						{1290, new List<string> {"weather.clouds 0.64" } },
						{1300, new List<string> {"weather.fog 0.14" } },
						{1310, new List<string> {"weather.clouds 0.62" } },
						{1320, new List<string> {"weather.fog 0.12" } },
						{1330, new List<string> {"weather.clouds 0.6" } },
						{1340, new List<string> {"weather.fog 0.1" } },
						{1350, new List<string> {"weather.clouds 0.58" } },
						{1360, new List<string> {"weather.fog 0.08" } },
						{1370, new List<string> {"weather.clouds 0.56" } },
						{1380, new List<string> {"weather.fog 0.06" } },
						{1390, new List<string> {"weather.clouds 0.54" } },
						{1400, new List<string> {"weather.fog 0.04" } },
						{1410, new List<string> {"weather.clouds 0.52" } },
						{1420, new List<string> {"weather.fog 0.02" } },
						{1430, new List<string> {"weather.clouds 0.5" } },
						{1440, new List<string> {"weather.fog 0" } },
						{1450, new List<string> {"weather.clouds 0.48" } },
						{1460, new List<string> {"weather.clouds 0.46" } },
						{1470, new List<string> {"weather.clouds 0.44" } },
						{1480, new List<string> {"weather.clouds 0.42" } },
						{1490, new List<string> {"weather.clouds 0.4" } },
						{1500, new List<string> {"weather.clouds 0.38" } },
						{1510, new List<string> {"weather.clouds 0.36" } },
						{1520, new List<string> {"weather.clouds 0.34" } },
						{1530, new List<string> {"weather.clouds 0.32" } },
						{1540, new List<string> {"weather.clouds 0.3" } },
						{1550, new List<string> {"weather.clouds 0.28" } },
						{1560, new List<string> {"weather.clouds 0.26" } },
						{1570, new List<string> {"weather.clouds 0.24" } },
						{1580, new List<string> {"weather.clouds 0.22" } },
						{1590, new List<string> {"weather.clouds 0.2" } },
						{1600, new List<string> {"weather.clouds 0.18" } },
						{1610, new List<string> {"weather.clouds 0.16" } },
						{1620, new List<string> {"weather.clouds 0.14" } },
						{1630, new List<string> {"weather.clouds 0.12" } },
						{1640, new List<string> {"weather.clouds 0.1" } },
						{1650, new List<string> {"weather.clouds 0.08" } },
						{1660, new List<string> {"weather.clouds 0.06" } },
						{1670, new List<string> {"weather.clouds 0.04" } },
						{1680, new List<string> {"weather.clouds 0.02" } },						
                        {1690, new List<string> {"weather.clouds 0", "STOP" } },
                    }
                    },
					{"fog", new Dictionary<int, List<string>>
                    {
                        {1, new List<string> {"weather.clouds 0.02" } },
						{10, new List<string> {"weather.clouds 0.04" } },
						{20, new List<string> {"weather.clouds 0.06" } },
						{30, new List<string> {"weather.clouds 0.08" } },
						{40, new List<string> {"weather.clouds 0.1" } },
						{50, new List<string> {"weather.clouds 0.12" } },
						{60, new List<string> {"weather.clouds 0.14" } },
						{70, new List<string> {"weather.clouds 0.16" } },
						{80, new List<string> {"weather.clouds 0.18" } },
						{90, new List<string> {"weather.clouds 0.2" } },
						{100, new List<string> {"weather.clouds 0.22" } },
						{110, new List<string> {"weather.clouds 0.24" } },
						{120, new List<string> {"weather.clouds 0.26" } },
						{130, new List<string> {"weather.clouds 0.28" } },
						{140, new List<string> {"weather.clouds 0.3" } },
						{150, new List<string> {"weather.clouds 0.32" } },
						{160, new List<string> {"weather.clouds 0.34" } },
						{170, new List<string> {"weather.clouds 0.36" } },
						{180, new List<string> {"weather.clouds 0.38" } },
						{190, new List<string> {"weather.clouds 0.4" } },
						{200, new List<string> {"weather.clouds 0.42" } },
						{210, new List<string> {"weather.clouds 0.44" } },
						{220, new List<string> {"weather.clouds 0.46" } },
						{230, new List<string> {"weather.clouds 0.48" } },
						{240, new List<string> {"weather.clouds 0.5" } },
						{250, new List<string> {"weather.fog 0.02" } },
						{260, new List<string> {"weather.clouds 0.52" } },
						{270, new List<string> {"weather.fog 0.04" } },
						{280, new List<string> {"weather.clouds 0.54" } },
						{290, new List<string> {"weather.fog 0.06" } },
						{300, new List<string> {"weather.clouds 0.56" } },
						{310, new List<string> {"weather.fog 0.08" } },
						{320, new List<string> {"weather.clouds 0.58" } },
						{330, new List<string> {"weather.fog 0.1" } },
						{340, new List<string> {"weather.clouds 0.6" } },
						{350, new List<string> {"weather.fog 0.12" } },
						{360, new List<string> {"weather.clouds 0.62" } },
						{370, new List<string> {"weather.fog 0.14" } },
						{380, new List<string> {"weather.clouds 0.64" } },
						{390, new List<string> {"weather.fog 0.16" } },
						{400, new List<string> {"weather.clouds 0.66" } },
						{410, new List<string> {"weather.fog 0.18" } },
						{420, new List<string> {"weather.clouds 0.68" } },
						{430, new List<string> {"weather.fog 0.20" } },
						{440, new List<string> {"weather.clouds 0.7" } },
						{450, new List<string> {"weather.fog 0.22" } },
						{460, new List<string> {"weather.clouds 0.72" } },
						{470, new List<string> {"weather.fog 0.24" } },
						{480, new List<string> {"weather.clouds 0.74" } },
						{490, new List<string> {"weather.fog 0.26" } },
						{500, new List<string> {"weather.clouds 0.76" } },
						{510, new List<string> {"weather.fog 0.28" } },
						{520, new List<string> {"weather.clouds 0.78" } },
						{530, new List<string> {"weather.fog 0.3" } },
						{540, new List<string> {"weather.clouds 0.8" } },
						{550, new List<string> {"weather.fog 0.32" } },
						{560, new List<string> {"weather.clouds 0.82" } },
						{570, new List<string> {"weather.fog 0.34" } },
						{580, new List<string> {"weather.clouds 0.84" } },
						{590, new List<string> {"weather.fog 0.36" } },
						{600, new List<string> {"weather.clouds 0.86" } },
						{610, new List<string> {"weather.fog 0.38" } },
						{620, new List<string> {"weather.clouds 0.88" } },
						{630, new List<string> {"weather.fog 0.4" } },
						{640, new List<string> {"weather.clouds 0.9" } },
						{650, new List<string> {"weather.fog 0.42" } },
						{660, new List<string> {"weather.clouds 0.92" } },
						{670, new List<string> {"weather.fog 0.44" } },
						{680, new List<string> {"weather.clouds 0.94" } },
						{690, new List<string> {"weather.fog 0.46" } },
						{700, new List<string> {"weather.clouds 0.96" } },
						{710, new List<string> {"weather.fog 0.48" } },
						{720, new List<string> {"weather.clouds 0.98" } },
						{730, new List<string> {"weather.fog 0.5" } },
						{740, new List<string> {"weather.clouds 1" } },
						{1350, new List<string> {"weather.clouds 0.98" } },
						{1360, new List<string> {"weather.fog 0.48" } },
						{1370, new List<string> {"weather.clouds 0.96" } },
						{1380, new List<string> {"weather.fog 0.46" } },
						{1390, new List<string> {"weather.clouds 0.94" } },
						{1400, new List<string> {"weather.fog 0.44" } },
						{1410, new List<string> {"weather.clouds 0.92" } },
						{1420, new List<string> {"weather.fog 0.42" } },
						{1430, new List<string> {"weather.clouds 0.9" } },
						{1440, new List<string> {"weather.fog 0.4" } },
						{1450, new List<string> {"weather.clouds 0.88" } },
						{1460, new List<string> {"weather.fog 0.38" } },
						{1470, new List<string> {"weather.clouds 0.86" } },
						{1480, new List<string> {"weather.fog 0.36" } },
						{1490, new List<string> {"weather.clouds 0.84" } },
						{1500, new List<string> {"weather.fog 0.34" } },
						{1510, new List<string> {"weather.clouds 0.82" } },
						{1520, new List<string> {"weather.fog 0.32" } },
						{1530, new List<string> {"weather.clouds 0.8" } },
						{1540, new List<string> {"weather.fog 0.3" } },
						{1550, new List<string> {"weather.clouds 0.78" } },
						{1560, new List<string> {"weather.fog 0.28" } },
						{1570, new List<string> {"weather.clouds 0.76" } },
						{1580, new List<string> {"weather.fog 0.26" } },
						{1590, new List<string> {"weather.clouds 0.74" } },
						{1600, new List<string> {"weather.fog 0.24" } },
						{1610, new List<string> {"weather.clouds 0.72" } },
						{1620, new List<string> {"weather.fog 0.22" } },
						{1630, new List<string> {"weather.clouds 0.7" } },
						{1640, new List<string> {"weather.fog 0.2" } },
						{1650, new List<string> {"weather.clouds 0.68" } },
						{1660, new List<string> {"weather.fog 0.18" } },
						{1670, new List<string> {"weather.clouds 0.66" } },
						{1680, new List<string> {"weather.fog 0.16" } },
						{1690, new List<string> {"weather.clouds 0.64" } },
						{1700, new List<string> {"weather.fog 0.14" } },
						{1710, new List<string> {"weather.clouds 0.62" } },
						{1720, new List<string> {"weather.fog 0.12" } },
						{1730, new List<string> {"weather.clouds 0.6" } },
						{1740, new List<string> {"weather.fog 0.1" } },
						{1750, new List<string> {"weather.clouds 0.58" } },
						{1760, new List<string> {"weather.fog 0.08" } },
						{1770, new List<string> {"weather.clouds 0.56" } },
						{1780, new List<string> {"weather.fog 0.06" } },
						{1790, new List<string> {"weather.clouds 0.54" } },
						{1800, new List<string> {"weather.fog 0.04" } },
						{1810, new List<string> {"weather.clouds 0.52" } },
						{1820, new List<string> {"weather.fog 0.02" } },
						{1830, new List<string> {"weather.clouds 0.5" } },
						{1840, new List<string> {"weather.fog 0" } },
						{1850, new List<string> {"weather.clouds 0.48" } },
						{1860, new List<string> {"weather.clouds 0.46" } },
						{1870, new List<string> {"weather.clouds 0.44" } },
						{1880, new List<string> {"weather.clouds 0.42" } },
						{1890, new List<string> {"weather.clouds 0.4" } },
						{1900, new List<string> {"weather.clouds 0.38" } },
						{1910, new List<string> {"weather.clouds 0.36" } },
						{1920, new List<string> {"weather.clouds 0.34" } },
						{1930, new List<string> {"weather.clouds 0.32" } },
						{1940, new List<string> {"weather.clouds 0.3" } },
						{1950, new List<string> {"weather.clouds 0.28" } },
						{1960, new List<string> {"weather.clouds 0.26" } },
						{1970, new List<string> {"weather.clouds 0.24" } },
						{1980, new List<string> {"weather.clouds 0.22" } },
						{1990, new List<string> {"weather.clouds 0.2" } },
						{2000, new List<string> {"weather.clouds 0.18" } },
						{2010, new List<string> {"weather.clouds 0.16" } },
						{2020, new List<string> {"weather.clouds 0.14" } },
						{2030, new List<string> {"weather.clouds 0.12" } },
						{2040, new List<string> {"weather.clouds 0.1" } },
						{2050, new List<string> {"weather.clouds 0.08" } },
						{2060, new List<string> {"weather.clouds 0.06" } },
						{2070, new List<string> {"weather.clouds 0.04" } },
						{2080, new List<string> {"weather.clouds 0.02" } },						
                        {2090, new List<string> {"weather.clouds 0", "STOP" } },
                    }
                    },
					{"heavyfog", new Dictionary<int, List<string>>
                    {
                        {1, new List<string> {"weather.clouds 0.02" } },
						{10, new List<string> {"weather.clouds 0.04" } },
						{20, new List<string> {"weather.clouds 0.06" } },
						{30, new List<string> {"weather.clouds 0.08" } },
						{40, new List<string> {"weather.clouds 0.1" } },
						{50, new List<string> {"weather.clouds 0.12" } },
						{60, new List<string> {"weather.clouds 0.14" } },
						{70, new List<string> {"weather.clouds 0.16" } },
						{80, new List<string> {"weather.clouds 0.18" } },
						{90, new List<string> {"weather.clouds 0.2" } },
						{100, new List<string> {"weather.clouds 0.22" } },
						{110, new List<string> {"weather.clouds 0.24" } },
						{120, new List<string> {"weather.clouds 0.26" } },
						{130, new List<string> {"weather.clouds 0.28" } },
						{140, new List<string> {"weather.clouds 0.3" } },
						{150, new List<string> {"weather.clouds 0.32" } },
						{160, new List<string> {"weather.clouds 0.34" } },
						{170, new List<string> {"weather.clouds 0.36" } },
						{180, new List<string> {"weather.clouds 0.38" } },
						{190, new List<string> {"weather.clouds 0.4" } },
						{200, new List<string> {"weather.clouds 0.42" } },
						{210, new List<string> {"weather.clouds 0.44" } },
						{220, new List<string> {"weather.clouds 0.46" } },
						{230, new List<string> {"weather.clouds 0.48" } },
						{240, new List<string> {"weather.clouds 0.5" } },
						{250, new List<string> {"weather.fog 0.02" } },
						{260, new List<string> {"weather.clouds 0.52" } },
						{270, new List<string> {"weather.fog 0.04" } },
						{280, new List<string> {"weather.clouds 0.54" } },
						{290, new List<string> {"weather.fog 0.06" } },
						{300, new List<string> {"weather.clouds 0.56" } },
						{310, new List<string> {"weather.fog 0.08" } },
						{320, new List<string> {"weather.clouds 0.58" } },
						{330, new List<string> {"weather.fog 0.1" } },
						{340, new List<string> {"weather.clouds 0.6" } },
						{350, new List<string> {"weather.fog 0.12" } },
						{360, new List<string> {"weather.clouds 0.62" } },
						{370, new List<string> {"weather.fog 0.14" } },
						{380, new List<string> {"weather.clouds 0.64" } },
						{390, new List<string> {"weather.fog 0.16" } },
						{400, new List<string> {"weather.clouds 0.66" } },
						{410, new List<string> {"weather.fog 0.18" } },
						{420, new List<string> {"weather.clouds 0.68" } },
						{430, new List<string> {"weather.fog 0.20" } },
						{440, new List<string> {"weather.clouds 0.7" } },
						{450, new List<string> {"weather.fog 0.22" } },
						{460, new List<string> {"weather.clouds 0.72" } },
						{470, new List<string> {"weather.fog 0.24" } },
						{480, new List<string> {"weather.clouds 0.74" } },
						{490, new List<string> {"weather.fog 0.26" } },
						{500, new List<string> {"weather.clouds 0.76" } },
						{510, new List<string> {"weather.fog 0.28" } },
						{520, new List<string> {"weather.clouds 0.78" } },
						{530, new List<string> {"weather.fog 0.3" } },
						{540, new List<string> {"weather.clouds 0.8" } },
						{550, new List<string> {"weather.fog 0.32" } },
						{560, new List<string> {"weather.clouds 0.82" } },
						{570, new List<string> {"weather.fog 0.34" } },
						{580, new List<string> {"weather.clouds 0.84" } },
						{590, new List<string> {"weather.fog 0.36" } },
						{600, new List<string> {"weather.clouds 0.86" } },
						{610, new List<string> {"weather.fog 0.38" } },
						{620, new List<string> {"weather.clouds 0.88" } },
						{630, new List<string> {"weather.fog 0.4" } },
						{640, new List<string> {"weather.clouds 0.9" } },
						{650, new List<string> {"weather.fog 0.42" } },
						{660, new List<string> {"weather.clouds 0.92" } },
						{670, new List<string> {"weather.fog 0.44" } },
						{680, new List<string> {"weather.clouds 0.94" } },
						{690, new List<string> {"weather.fog 0.46" } },
						{700, new List<string> {"weather.clouds 0.96" } },
						{710, new List<string> {"weather.fog 0.48" } },
						{720, new List<string> {"weather.clouds 0.98" } },
						{730, new List<string> {"weather.fog 0.5" } },
						{740, new List<string> {"weather.clouds 1" } },
						{750, new List<string> {"weather.fog 0.52" } },
						{760, new List<string> {"weather.fog 0.54" } },
						{780, new List<string> {"weather.fog 0.56" } },
						{790, new List<string> {"weather.fog 0.58" } },
						{800, new List<string> {"weather.fog 0.6" } },
						{810, new List<string> {"weather.fog 0.62" } },
						{820, new List<string> {"weather.fog 0.64" } },
						{830, new List<string> {"weather.fog 0.66" } },
						{840, new List<string> {"weather.fog 0.68" } },
						{850, new List<string> {"weather.fog 0.7" } },
						{860, new List<string> {"weather.fog 0.72" } },
						{870, new List<string> {"weather.fog 0.74" } },
						{880, new List<string> {"weather.fog 0.76" } },
						{890, new List<string> {"weather.fog 0.78" } },
						{900, new List<string> {"weather.fog 0.8" } },
						{910, new List<string> {"weather.fog 0.82" } },
						{920, new List<string> {"weather.fog 0.84" } },
						{930, new List<string> {"weather.fog 0.86" } },
						{940, new List<string> {"weather.fog 0.88" } },
						{950, new List<string> {"weather.fog 0.9" } },
						{960, new List<string> {"weather.fog 0.92" } },
						{970, new List<string> {"weather.fog 0.94" } },
						{980, new List<string> {"weather.fog 0.96" } },
						{990, new List<string> {"weather.fog 0.98" } },
						{1000, new List<string> {"weather.fog 1" } },
						{1300, new List<string> {"weather.fog 0.98" } },
						{1310, new List<string> {"weather.fog 0.96" } },
						{1320, new List<string> {"weather.fog 0.94" } },
						{1330, new List<string> {"weather.fog 0.92" } },
						{1340, new List<string> {"weather.fog 0.9" } },
						{1350, new List<string> {"weather.fog 0.88" } },
						{1360, new List<string> {"weather.fog 0.86" } },
						{1370, new List<string> {"weather.fog 0.84" } },
						{1380, new List<string> {"weather.fog 0.82" } },
						{1390, new List<string> {"weather.fog 0.8" } },
						{1400, new List<string> {"weather.fog 0.78" } },
						{1410, new List<string> {"weather.fog 0.76" } },
						{1420, new List<string> {"weather.fog 0.74" } },
						{1430, new List<string> {"weather.fog 0.72" } },
						{1440, new List<string> {"weather.fog 0.7" } },
						{1450, new List<string> {"weather.fog 0.68" } },
						{1460, new List<string> {"weather.fog 0.66" } },
						{1470, new List<string> {"weather.fog 0.64" } },
						{1480, new List<string> {"weather.fog 0.62" } },
						{1490, new List<string> {"weather.fog 0.6" } },
						{1500, new List<string> {"weather.fog 0.58" } },
						{1510, new List<string> {"weather.fog 0.56" } },
						{1520, new List<string> {"weather.fog 0.54" } },
						{1530, new List<string> {"weather.fog 0.52" } },
						{1540, new List<string> {"weather.fog 0.5" } },
						{1550, new List<string> {"weather.clouds 0.98" } },
						{1560, new List<string> {"weather.fog 0.48" } },
						{1570, new List<string> {"weather.clouds 0.96" } },
						{1580, new List<string> {"weather.fog 0.46" } },
						{1590, new List<string> {"weather.clouds 0.94" } },
						{1600, new List<string> {"weather.fog 0.44" } },
						{1610, new List<string> {"weather.clouds 0.92" } },
						{1620, new List<string> {"weather.fog 0.42" } },
						{1630, new List<string> {"weather.clouds 0.9" } },
						{1640, new List<string> {"weather.fog 0.4" } },
						{1650, new List<string> {"weather.clouds 0.88" } },
						{1660, new List<string> {"weather.fog 0.38" } },
						{1670, new List<string> {"weather.clouds 0.86" } },
						{1680, new List<string> {"weather.fog 0.36" } },
						{1690, new List<string> {"weather.clouds 0.84" } },
						{1700, new List<string> {"weather.fog 0.34" } },
						{1710, new List<string> {"weather.clouds 0.82" } },
						{1720, new List<string> {"weather.fog 0.32" } },
						{1730, new List<string> {"weather.clouds 0.8" } },
						{1740, new List<string> {"weather.fog 0.3" } },
						{1750, new List<string> {"weather.clouds 0.78" } },
						{1760, new List<string> {"weather.fog 0.28" } },
						{1770, new List<string> {"weather.clouds 0.76" } },
						{1780, new List<string> {"weather.fog 0.26" } },
						{1790, new List<string> {"weather.clouds 0.74" } },
						{1800, new List<string> {"weather.fog 0.24" } },
						{1810, new List<string> {"weather.clouds 0.72" } },
						{1820, new List<string> {"weather.fog 0.22" } },
						{1830, new List<string> {"weather.clouds 0.7" } },
						{1840, new List<string> {"weather.fog 0.2" } },
						{1850, new List<string> {"weather.clouds 0.68" } },
						{1860, new List<string> {"weather.fog 0.18" } },
						{1870, new List<string> {"weather.clouds 0.66" } },
						{1880, new List<string> {"weather.fog 0.16" } },
						{1890, new List<string> {"weather.clouds 0.64" } },
						{1900, new List<string> {"weather.fog 0.14" } },
						{1910, new List<string> {"weather.clouds 0.62" } },
						{1920, new List<string> {"weather.fog 0.12" } },
						{1930, new List<string> {"weather.clouds 0.6" } },
						{1940, new List<string> {"weather.fog 0.1" } },
						{1950, new List<string> {"weather.clouds 0.58" } },
						{1960, new List<string> {"weather.fog 0.08" } },
						{1970, new List<string> {"weather.clouds 0.56" } },
						{1980, new List<string> {"weather.fog 0.06" } },
						{1990, new List<string> {"weather.clouds 0.54" } },
						{2000, new List<string> {"weather.fog 0.04" } },
						{2010, new List<string> {"weather.clouds 0.52" } },
						{2020, new List<string> {"weather.fog 0.02" } },
						{2030, new List<string> {"weather.clouds 0.5" } },
						{2040, new List<string> {"weather.fog 0" } },
						{2050, new List<string> {"weather.clouds 0.48" } },
						{2060, new List<string> {"weather.clouds 0.46" } },
						{2070, new List<string> {"weather.clouds 0.44" } },
						{2080, new List<string> {"weather.clouds 0.42" } },
						{2090, new List<string> {"weather.clouds 0.4" } },
						{2100, new List<string> {"weather.clouds 0.38" } },
						{2110, new List<string> {"weather.clouds 0.36" } },
						{2120, new List<string> {"weather.clouds 0.34" } },
						{2130, new List<string> {"weather.clouds 0.32" } },
						{2140, new List<string> {"weather.clouds 0.3" } },
						{2150, new List<string> {"weather.clouds 0.28" } },
						{2160, new List<string> {"weather.clouds 0.26" } },
						{2170, new List<string> {"weather.clouds 0.24" } },
						{2180, new List<string> {"weather.clouds 0.22" } },
						{2190, new List<string> {"weather.clouds 0.2" } },
						{2200, new List<string> {"weather.clouds 0.18" } },
						{2210, new List<string> {"weather.clouds 0.16" } },
						{2220, new List<string> {"weather.clouds 0.14" } },
						{2230, new List<string> {"weather.clouds 0.12" } },
						{2240, new List<string> {"weather.clouds 0.1" } },
						{2250, new List<string> {"weather.clouds 0.08" } },
						{2260, new List<string> {"weather.clouds 0.06" } },
						{2270, new List<string> {"weather.clouds 0.04" } },
						{2280, new List<string> {"weather.clouds 0.02" } },						
                        {2290, new List<string> {"weather.clouds 0", "STOP" } },
                    }
                    },
					{"overcast", new Dictionary<int, List<string>>
                    {
                        {1, new List<string> {"weather.clouds 0.01" } },
						{10, new List<string> {"weather.clouds 0.02" } },
						{20, new List<string> {"weather.clouds 0.04" } },
						{30, new List<string> {"weather.clouds 0.06" } },
						{40, new List<string> {"weather.clouds 0.08" } },
						{50, new List<string> {"weather.clouds 0.1" } },
						{60, new List<string> {"weather.clouds 0.12" } },
						{70, new List<string> {"weather.clouds 0.14" } },
						{80, new List<string> {"weather.clouds 0.16" } },
						{90, new List<string> {"weather.clouds 0.18" } },
						{100, new List<string> {"weather.clouds 0.2" } },
						{110, new List<string> {"weather.clouds 0.22" } },
						{120, new List<string> {"weather.clouds 0.24" } },
						{130, new List<string> {"weather.clouds 0.26" } },
						{140, new List<string> {"weather.clouds 0.28" } },
						{150, new List<string> {"weather.clouds 0.3" } },
						{160, new List<string> {"weather.clouds 0.32" } },
						{170, new List<string> {"weather.clouds 0.34" } },
						{180, new List<string> {"weather.clouds 0.36" } },
						{190, new List<string> {"weather.clouds 0.38" } },
						{200, new List<string> {"weather.clouds 0.4" } },
						{210, new List<string> {"weather.clouds 0.42" } },
						{220, new List<string> {"weather.clouds 0.44" } },
						{230, new List<string> {"weather.clouds 0.46" } },
						{240, new List<string> {"weather.clouds 0.48" } },
						{250, new List<string> {"weather.clouds 0.5" } },
						{260, new List<string> {"weather.clouds 0.52" } },
						{270, new List<string> {"weather.clouds 0.54" } },
						{280, new List<string> {"weather.clouds 0.56" } },
						{290, new List<string> {"weather.clouds 0.58" } },
						{300, new List<string> {"weather.clouds 0.6" } },
						{310, new List<string> {"weather.clouds 0.62" } },
						{320, new List<string> {"weather.clouds 0.64" } },
						{330, new List<string> {"weather.clouds 0.66" } },
						{340, new List<string> {"weather.clouds 0.68" } },
						{350, new List<string> {"weather.clouds 0.7" } },
						{360, new List<string> {"weather.clouds 0.72" } },
						{370, new List<string> {"weather.clouds 0.74" } },
						{380, new List<string> {"weather.clouds 0.76" } },
						{390, new List<string> {"weather.clouds 0.78" } },
						{400, new List<string> {"weather.clouds 0.8" } },
						{410, new List<string> {"weather.clouds 0.82" } },
						{420, new List<string> {"weather.clouds 0.84" } },
						{430, new List<string> {"weather.clouds 0.86" } },
						{440, new List<string> {"weather.clouds 0.88" } },
						{450, new List<string> {"weather.clouds 0.9" } },
						{460, new List<string> {"weather.clouds 0.92" } },
						{470, new List<string> {"weather.clouds 0.94" } },
						{480, new List<string> {"weather.clouds 0.96" } },
						{490, new List<string> {"weather.clouds 0.98" } },
						{500, new List<string> {"weather.clouds 1" } },
						{1100, new List<string> {"weather.clouds 0.98" } },
						{1110, new List<string> {"weather.clouds 0.96" } },
						{1120, new List<string> {"weather.clouds 0.94" } },
						{1130, new List<string> {"weather.clouds 0.92" } },
						{1140, new List<string> {"weather.clouds 0.9" } },
						{1150, new List<string> {"weather.clouds 0.88" } },
						{1160, new List<string> {"weather.clouds 0.86" } },
						{1170, new List<string> {"weather.clouds 0.84" } },
						{1180, new List<string> {"weather.clouds 0.82" } },
						{1190, new List<string> {"weather.clouds 0.8" } },
						{1200, new List<string> {"weather.clouds 0.78" } },
						{1210, new List<string> {"weather.clouds 0.76" } },
						{1220, new List<string> {"weather.clouds 0.74" } },
						{1230, new List<string> {"weather.clouds 0.72" } },
						{1240, new List<string> {"weather.clouds 0.7" } },
						{1250, new List<string> {"weather.clouds 0.68" } },
						{1260, new List<string> {"weather.clouds 0.66" } },
						{1270, new List<string> {"weather.clouds 0.64" } },
						{1280, new List<string> {"weather.clouds 0.62" } },
						{1290, new List<string> {"weather.clouds 0.6" } },
						{1300, new List<string> {"weather.clouds 0.58" } },
						{1310, new List<string> {"weather.clouds 0.56" } },
						{1320, new List<string> {"weather.clouds 0.54" } },
						{1330, new List<string> {"weather.clouds 0.52" } },
						{1340, new List<string> {"weather.clouds 0.5" } },
						{1350, new List<string> {"weather.clouds 0.48" } },
						{1360, new List<string> {"weather.clouds 0.46" } },
						{1370, new List<string> {"weather.clouds 0.44" } },
						{1380, new List<string> {"weather.clouds 0.42" } },
						{1390, new List<string> {"weather.clouds 0.4" } },
						{1400, new List<string> {"weather.clouds 0.38" } },
						{1410, new List<string> {"weather.clouds 0.36" } },
						{1420, new List<string> {"weather.clouds 0.34" } },
						{1430, new List<string> {"weather.clouds 0.32" } },
						{1440, new List<string> {"weather.clouds 0.3" } },
						{1450, new List<string> {"weather.clouds 0.28" } },
						{1460, new List<string> {"weather.clouds 0.26" } },
						{1470, new List<string> {"weather.clouds 0.24" } },
						{1480, new List<string> {"weather.clouds 0.22" } },
						{1490, new List<string> {"weather.clouds 0.2" } },
						{1500, new List<string> {"weather.clouds 0.18" } },
						{1510, new List<string> {"weather.clouds 0.16" } },
						{1520, new List<string> {"weather.clouds 0.14" } },
						{1530, new List<string> {"weather.clouds 0.12" } },
						{1540, new List<string> {"weather.clouds 0.1" } },
						{1550, new List<string> {"weather.clouds 0.08" } },
						{1560, new List<string> {"weather.clouds 0.06" } },
						{1570, new List<string> {"weather.clouds 0.04" } },
						{1580, new List<string> {"weather.clouds 0.02" } },
                        {1590, new List<string> {"weather.clouds 0", "STOP" } },
                    }
                    }
            };
    }
}

// --- End of file: RealisticWeather.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/ZetaVehicle.cs ---
// --- Original Local Path: KualaRust/ZetaVehicle.cs ---

﻿using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Facepunch;

namespace Oxide.Plugins
{
    [Info("ZetaVehicle", "fermens", "0.1.3")]
    [Description("ПОЛНОЦЕННОЕ МЕНЮ ДЛЯ ПРОДАЖИ ЛИЧНОГО ТРАНСПОРТА ИГРОКАМ")]
    class ZetaVehicle : RustPlugin
    {
        #region Config
        private PluginConfig config;
        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        private class PluginConfig
        {
            [JsonProperty("Транспортные средства")]
            public Dictionary<string, vehicle> prefabs;

            [JsonProperty("Фон-картинки")]
            public Dictionary<string, string> list;

            [JsonProperty("Сообщения")]
            public List<string> messages;

            [JsonProperty("Запретить садиться в чужой транспорт?")]
            public bool onlyfriends;

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    prefabs = new Dictionary<string, vehicle>(),
                    list = new Dictionary<string, string>
                    {
                        { "background2", "https://img1.goodfon.ru/wallpaper/nbig/0/e8/abandoned-chevy-tucumcari-new.jpg" },
                        { "fon5", "https://gspics.org/images/2020/01/24/5MyHe.jpg"}
                    },
                    messages = new List<string>
                    {
                        "НЕ АБУЗЬ!",
                        "ВЫЙДИТЕ С ЧУЖОЙ ТЕРИТОРИИ!",
                        "У ВАС НЕТ РАЗРЕШЕНИЯ ДЛЯ ЭТОЙ КОМАНДЫ!",
                        "У ВАС УЖЕ ЕСТЬ АКТИВНЫЙ ТРАНСПОРТ ТЕКУЩЕГО ТИПА!\nОТОЗВИТЕ ЕГО, ЧТО БЫ ПРИЗВАТЬ НОВЫЙ!",
                        "У ВАС КД НА ЭТО ТРАНСПОРТНОЕ СРЕДСТВО,\nПОДОЖДИТЕ {time}.", // 4
                        "<color=#ffd479>{name}</color> В ВАШЕМ РАСПОРЯЖЕНИИ",
                        "У ВАС НЕТ ТРАНСПОРТНОГО СРЕДСТВА ТАКОГО ТИПА!",
                        "ВЫ НЕ МОЖЕТЕ ОТОЗВАТЬ ТРАНСПОРТНОЕ СРЕДСТВО,\nКОГДА В НЕМ КТО-ТО СИДИТ!", //7
                        "ВЫ УСПЕШНО ОТОЗВАЛИ ВАШЕ ТРАНСПОРТНОЕ СРЕДСТВО!",
                        "СЛЕДУЮЩАЯ СТРАНИЦА",
                        "ПРЕДЫДУЩАЯ СТРАНИЦА", //10
                        "НЕДОСТУПНО",
                        "ПРИЗВАТЬ",
                        "ОТОЗВАТЬ",//13
                        "ЗАКРЫТЬ МЕНЮ",
                        "подсказка: прыгните, чтобы закрыть меню",
                        "ДОСТУПНЫЕ ВАМ ТРАНСПОРТНЫЕ СРЕДСТВА", //16
                        "У ВАС НЕТ ДОСТУПНЫХ ТРАНСПОРТНЫХ СРЕДСТВ,\nКУПИТЕ РАЗРЕШЕНИЕ НА НИХ <color=#ffd479>В МАГАЗИНЕ</color>!",
                        "ВЫ ДОЛЖНЫ НАХОДИТЬСЯ В ВОДЕ!",
                    },
                    onlyfriends = false
                };
            }
        }
        #endregion

        #region Head
        [PluginReference] Plugin ImageLibrary;
        string GetImage(string shortname, ulong skin = 0) => (string)ImageLibrary.Call("GetImage", shortname, skin);
        void AddImage(string url, string shortname, ulong skin = 0)
        {
            ImageLibrary?.Call("AddImage", url, shortname, skin);
            gettimage(shortname);
        }

        class MyVehicles
        {
            public int lastpage = 0;
            public Dictionary<string, BaseEntity> vehicles = new Dictionary<string, BaseEntity>();
            public Dictionary<string, DateTime> cooldowns = new Dictionary<string, DateTime>();
        }

        Dictionary<ulong, MyVehicles> vehicles = new Dictionary<ulong, MyVehicles>();

        class vehicle
        {
            [JsonProperty("Префаб")]
            public string prefab;

            [JsonProperty("Отображаемое название")]
            public string displayname;

            [JsonProperty("Картинка")]
            public string img;

            [JsonProperty("КД(минуты)")]
            public int cooldown;

            [JsonProperty("Бесконечное топливо")]
            public bool infinitefuel;

            [JsonProperty("Топливо")]
            public int fuel;

            [JsonProperty("Дистанция спавна")]
            public float distancespawn;
        }

        const string mainUI = "ZetaVehicle-01";
        const string nomainUI = "ZetaVehicle-02";
        const string drawUI = "ZetaVehicle-03";
        bool onJump;
        List<BasePlayer> active = new List<BasePlayer>();
        #endregion

        #region Main
        Dictionary<string, string> images = new Dictionary<string, string>();
        private void Init()
        {
            Unsubscribe("CanMountEntity");
        }

        void OnServerInitialized()
        {
            if (config.prefabs.Count.Equals(0))
            {
                config.prefabs.Add("testridablehorse", new vehicle { prefab = "assets/rust.ai/nextai/testridablehorse.prefab", displayname = "ЕЗДОВАЯ ЛОШАДЬ", img = "https://gspics.org/images/2020/01/24/5MNpI.png", cooldown = 60, distancespawn = 2f, infinitefuel = false, fuel = 0 });
                config.prefabs.Add("minicopter.entity", new vehicle { prefab = "assets/content/vehicles/minicopter/minicopter.entity.prefab", displayname = "МИНИКОПТЕР", img = "https://gspics.org/images/2020/01/24/5MfnD.png", cooldown = 60, distancespawn = 2f, fuel = 10, infinitefuel = true });
                config.prefabs.Add("scraptransporthelicopter", new vehicle { prefab = "assets/content/vehicles/scrap heli carrier/scraptransporthelicopter.prefab", displayname = "САМОДЕЛЬНЫЙ ВЕРТОЛЕТ", img = "https://gspics.org/images/2020/01/24/5mLnZ.png", cooldown = 60, distancespawn = 5f, fuel = 10, infinitefuel = false });
                config.prefabs.Add("sedantest.entity", new vehicle { prefab = "assets/content/vehicles/sedan_a/sedantest.entity.prefab", displayname = "МАШИНА", img = "https://pic.moscow.ovh/images/2019/01/26/28c44213d440f9708aeb9c9ddc73dff5.png", cooldown = 60, distancespawn = 4f, infinitefuel = false, fuel = 0 });
                config.prefabs.Add("rowboat", new vehicle { prefab = "assets/content/vehicles/boats/rowboat/rowboat.prefab", displayname = "МОТОРНАЯ ЛОДКА", img = "https://gspics.org/images/2020/01/24/5UEMw.png", cooldown = 60, distancespawn = 3f, fuel = 10, infinitefuel = true });
                config.prefabs.Add("rhib", new vehicle { prefab = "assets/content/vehicles/boats/rhib/rhib.prefab", displayname = "НАДУВНАЯ ЛОДКА", img = "https://gspics.org/images/2020/01/24/5UcxQ.png", cooldown = 60, distancespawn = 5f, fuel = 10, infinitefuel = true });
                config.prefabs.Add("hotairballoon", new vehicle { prefab = "assets/prefabs/deployable/hot air balloon/hotairballoon.prefab", displayname = "ВОЗДУШНЫЙ ШАР", img = "https://gspics.org/images/2020/01/24/5Uthx.png", cooldown = 60, distancespawn = 5f, fuel = 10, infinitefuel = true });
                //  prefabs.Add("chinook", new vehicle { prefab = "assets/prefabs/npc/ch47/ch47.entity.prefab", displayname = "ТРАНСПОРТНЫЙ ВЕРТОЛЕТ", img = "https://gspics.org/images/2020/01/24/5Udte.png" });
                SaveConfig();
            }

            permission.RegisterPermission(Name + ".all", this);
            permission.RegisterPermission(Name + ".nocoldown", this);
            foreach (var z in config.prefabs)
            {
                permission.RegisterPermission(Name + "." + z.Key, this);
                AddImage(z.Value.img, z.Key);
            }

            foreach (var z in config.list)
            {
                AddImage(z.Value, z.Key);
            }
            NextTick(() => Unsubscribe(nameof(OnPlayerInput)));

            if (config.onlyfriends) Subscribe("CanMountEntity");
        }

        object CanMountEntity(BasePlayer player, BaseMountable baseMountable)
        {
            BaseVehicle baseVehicle = baseMountable.VehicleParent();
            if (baseVehicle == null || baseVehicle.OwnerID == 0) return null;
            if (baseVehicle is MiniCopter || baseVehicle is BasicCar || baseVehicle is BaseBoat)
            {
                if (baseVehicle.OwnerID == player.userID || player.Team != null && player.Team.members.Any(x => x == baseVehicle.OwnerID)) return null;
                player.ChatMessage("<color=yellow>ЭТО ТРАНСПОРТНОЕ СРЕДСТВО ПРИНАДЛЕЖИТ ДРУГОМУ ИГРОКУ!</color>");
                return false;
            }
            return null;
        }

        void gettimage(string name)
        {
            string img = GetImage(name) ?? "39274839";
            if (!img.Equals("39274839"))
            {
                if (!images.ContainsKey(name)) images.Add(name, img);
                return;
            }

            timer.Once(1f, () => gettimage(name));
        }

        string CanSpawn(BasePlayer player, string name)
        {
            if (!config.prefabs.ContainsKey(name)) return config.messages[0];
            if (player.IsBuildingBlocked()) return config.messages[1];
            if (!permission.UserHasPermission(player.UserIDString, Name + ".all") && !permission.UserHasPermission(player.UserIDString, Name + "." + name)) return config.messages[2];
            if (vehicles[player.userID].vehicles.ContainsKey(name)) return config.messages[3];
            if (vehicles[player.userID].cooldowns.ContainsKey(name))
            {
                DateTime col = vehicles[player.userID].cooldowns[name];
                if (col > DateTime.Now) return config.messages[4].Replace("{time}", FormatTime(col - DateTime.Now));
            }
            if ((name.Equals("rhib") || name.Equals("rowboat")) && player.modelState != null && player.modelState.waterLevel <= 0f) return config.messages[18];
            return null;
        }

        void remove(BaseEntity ent)
        {
            ulong owner = ent.OwnerID;
            if (owner.Equals(0)) return;
            string prefab = ent.ShortPrefabName;
            if (!vehicles.ContainsKey(owner) || !vehicles[owner].vehicles.ContainsKey(prefab) || !ent.Equals(vehicles[owner].vehicles[prefab])) return;
            MyVehicles veh = vehicles[owner];
            veh.vehicles.Remove(prefab);
            ent?.Kill();
            if (!permission.UserHasPermission(owner.ToString(), Name + ".nocoldown"))
            {
                int cooldown = config.prefabs[prefab].cooldown;
                if (!veh.cooldowns.ContainsKey(prefab)) vehicles[owner].cooldowns.Add(prefab, DateTime.Now.AddMinutes(cooldown));
                else veh.cooldowns[prefab] = DateTime.Now.AddMinutes(cooldown);
            }
        }

        void spawn(BasePlayer player, string prefab)
        {
            check(player);
            string can = CanSpawn(player, prefab);
            if (can is string)
            {
                UiMSG(player, can);
                return;
            }
            vehicle che = config.prefabs[prefab];
            Vector3 vector = player.transform.position + (player.eyes.MovementForward() * che.distancespawn) + Vector3.up * 2f;
            RaycastHit hit;
            if (!Physics.Raycast(vector, Vector3.down, out hit, 1000f, LayerMask.GetMask("Terrain", "World", "Construction"), QueryTriggerInteraction.Ignore))
            {
                UiMSG(player, "ВЫБЕРИТЕ БОЛЕЕ ПОДХОДЯЩЕЕ МЕСТО ДЛЯ СПАВНА!");
                return;
            }
            Vector3 spawnpos = hit.point;
            float water = TerrainMeta.WaterMap.GetHeight(vector);
            if (prefab.Equals("rhib") || prefab.Equals("rowboat"))
            {
                spawnpos.y = TerrainMeta.WaterMap.GetHeight(vector) + 2f;
            }
            else
            {
                if (water > hit.point.y)
                {
                    UiMSG(player, "ЭТОТ ВИД ТРАНСПОРТА НЕ ПЛАВАЕТ ПО ВОДЕ!");
                    return;
                }
            }
            BaseEntity entity = GameManager.server.CreateEntity(che.prefab, spawnpos);
            if (entity == null)
            {
                Debug.LogError($"[ZetaVehicle] Префаб для {che.displayname} не существует!");
                return;
            }
            entity.OwnerID = player.userID;
            entity.Spawn();
            if (entity is MiniCopter)
            {
                if (che.infinitefuel) entity.GetComponent<MiniCopter>().fuelPerSec = 0;
                StorageContainer str = entity.GetComponent<MiniCopter>().GetFuelSystem().fuelStorageInstance.Get(entity.isServer) as StorageContainer;
                givefuel(str.inventory, che.fuel, che.infinitefuel);
            }
            else if (entity is HotAirBalloon)
            {
                HotAirBalloon hotAirBalloon = entity as HotAirBalloon;
                if (che.infinitefuel) hotAirBalloon.fuelPerSec = 0;
                Debug.Log(entity.name);
                foreach (var z in hotAirBalloon.children)
                {
                    Debug.Log(z.PrefabName + " " + z.prefabID);
                    if (z.prefabID == 1394312733)
                    {
                        givefuel((z as StorageContainer).inventory, che.fuel, che.infinitefuel);
                        break;
                    }
                }
            }
            else if (entity is MotorRowboat)
            {
                MotorRowboat motorRowboat = entity as MotorRowboat;
                if (che.infinitefuel) motorRowboat.fuelPerSec = 0;
                foreach (var z in motorRowboat.children)
                {
                    if(z.prefabID == 198420611 || z.prefabID == 1394312733)
                    {
                        givefuel((z as StorageContainer).inventory, che.fuel, che.infinitefuel);
                        break;
                    }
                }
            }
            vehicles[player.userID].vehicles.Add(prefab, entity);
            DestroyUI(player);
            UiMSG(player, config.messages[5].Replace("{name}", che.displayname));
        }

        private void givefuel(ItemContainer container, int fuel, bool locked)
        {
            Item item = ItemManager.CreateByItemID(-946369541, fuel);
            if (locked && container.HasFlag(ItemContainer.Flag.IsLocked) != true) container.SetFlag(ItemContainer.Flag.IsLocked, true);
            item.MoveToContainer(container);
        }

        void destroytimer(Timer ss)
        {
            if (!ss.Destroyed) timer.Destroy(ref ss);
        }

        void destroyUIMSG(BasePlayer player)
        {
            if (Uitimer.ContainsKey(player))
            {
                destroytimer(Uitimer[player]);
                Uitimer.Remove(player);
            }
            CuiHelper.DestroyUi(player, drawUI);
        }
        Dictionary<BasePlayer, Timer> Uitimer = new Dictionary<BasePlayer, Timer>();
        void UiMSG(BasePlayer player, string msg)
        {
            destroyUIMSG(player);
            CuiElementContainer container = LMUI.CreateElementContainer(drawUI, "0.5 0.5", "0.5 0.5");
            LMUI.OutlineText(ref container, drawUI, "1 1 1 0.9", msg, 30);
            CuiHelper.AddUi(player, container);
            Uitimer.Add(player, timer.Once(2f, () =>
            {
                CuiHelper.DestroyUi(player, drawUI);
                if (Uitimer.ContainsKey(player)) Uitimer.Remove(player);
            }));
        }

        void Unload()
        {
            foreach (var z in BasePlayer.activePlayerList)
            {
                DestroyUI(z);
                CuiHelper.DestroyUi(z, drawUI);
            }
            foreach (var z in vehicles)
            {
                foreach (var x in z.Value.vehicles) x.Value?.KillMessage();
            }
        }

        private void OnEntityKill(BaseNetworkable entity)
        {
            if (entity == null) return;
            if (entity is BaseMountable || entity is HotAirBalloon) remove((BaseEntity)entity);
        }

        void DestroyUI(BasePlayer player)
        {
            if (active.Contains(player)) active.Remove(player);
            CuiHelper.DestroyUi(player, mainUI);
            CuiHelper.DestroyUi(player, nomainUI);
            if (active.Count.Equals(0))
            {
                Unsubscribe(nameof(OnPlayerInput));
                onJump = false;
            }
        }
        #endregion

        #region FormatTime
        private string FormatTime(TimeSpan time)
=> (time.Days == 0 ? string.Empty : FormatDays(time.Days)) + (time.Hours == 0 ? string.Empty : FormatHours(time.Hours)) + (time.Minutes == 0 ? string.Empty : FormatMinutes(time.Minutes)) + ((time.Seconds == 0 || time.Days != 0 || time.Hours != 0) ? string.Empty : FormatSeconds(time.Seconds));

        private string FormatDays(int days) => FormatUnits(days, "ДНЕЙ", "ДНЯ", "ДЕНЬ");

        private string FormatHours(int hours) => FormatUnits(hours, "ЧАСОВ", "ЧАСА", "ЧАС");

        private string FormatMinutes(int minutes) => FormatUnits(minutes, "МИНУТ", "МИНУТЫ", "МИНУТУ");

        private string FormatSeconds(int seconds) => FormatUnits(seconds, "СЕКУНД", "СЕКУНДЫ", "СЕКУНД");

        private string FormatUnits(int units, string form1, string form2, string form3)
        {
            var tmp = units % 10;

            if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                return $"{units} {form1} ";

            if (tmp >= 2 && tmp <= 4)
                return $"{units} {form2} ";

            return $"{units} {form3} ";
        }
        #endregion

        #region Commands
        [ChatCommand("vm")]
        void cmdvm(BasePlayer player, string cmd, string[] args)
        {
            if (!active.Contains(player)) opengui(player, vehicles.ContainsKey(player.userID) ? vehicles[player.userID].lastpage : 0);
            else DestroyUI(player);
        }

        [ConsoleCommand("zeta.open")]
        private void cmdzetaspawn(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            check(player);
            EffectNetwork.Send(new Effect("assets/bundled/prefabs/fx/notice/loot.drag.grab.fx.prefab", player, 0, Vector3.up, Vector3.zero) { scale = 1f }, player.net.connection);
            int page = 0;
            if (arg.HasArgs() && !int.TryParse(arg.Args[0], out page) && !arg.Args[0].Equals("True"))
            {
                if (arg.Args[0].Equals("close")) DestroyUI(player);
                else if (arg.Args[0].Equals("remove") && arg.Args.Length > 1)
                {
                    if (!vehicles.ContainsKey(player.userID) || !vehicles[player.userID].vehicles.ContainsKey(arg.Args[1]))
                    {
                        UiMSG(player, config.messages[6]);
                        return;
                    }
                    BaseEntity ent = vehicles[player.userID].vehicles[arg.Args[1]];
                    BaseMountable mount = ent.GetComponent<BaseMountable>();
                    if (mount != null && mount.IsMounted())
                    {
                        UiMSG(player, config.messages[7]);
                        return;
                    }
                    remove(ent);
                    DestroyUI(player);
                    UiMSG(player, config.messages[8]);
                }
                else spawn(player, arg.Args[0]);
            }
            else
            {
                if (arg.HasArgs() && !arg.Args[0].Equals("True") || !active.Contains(player)) opengui(player, (!arg.HasArgs() || arg.Args[0].Equals("True")) ? vehicles[player.userID].lastpage : page);
                else DestroyUI(player);
            }
        }

        void check(BasePlayer player)
        {
            if (!vehicles.ContainsKey(player.userID)) vehicles.Add(player.userID, new MyVehicles());
        }

        void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (input.WasJustPressed(BUTTON.JUMP) && active.Contains(player))
            {
                DestroyUI(player);
            }
        }

        void opengui(BasePlayer player, int page = 0)
        {
            check(player);
            vehicles[player.userID].lastpage = page;
            destroyUIMSG(player);
            Dictionary<string, vehicle> allowed = new Dictionary<string, vehicle>();
            if (permission.UserHasPermission(player.UserIDString, Name + ".all"))
            {
                allowed = config.prefabs;
            }
            else
            {
                foreach (var z in config.prefabs)
                {
                    if (!permission.UserHasPermission(player.UserIDString, Name + "." + z.Key)) continue;
                    allowed.Add(z.Key, z.Value);
                }
            }
            int count = allowed.Count;
            int max = 5;

            CuiHelper.DestroyUi(player, nomainUI);
            CuiElementContainer nocontainer = LMUI.CreateElementContainerNO(nomainUI, "0 0 0 0", "0 0", "1 1", false);
            if (count > 0)
            {
                float x = 0.06f;
                int le = count - max * page;
                if (le == 1) x = 0.42f;
                else if (le == 2) x = 0.33f;
                else if (le == 3) x = 0.24f;
                else if (le == 4) x = 0.15f;
                if (count > max && count > max * (page + 1)) LMUI.CreateButton(ref nocontainer, nomainUI, "0 0 0 0", config.messages[9], 20, "0.4 0.16", "0.6 0.21", $"zeta.open {page + 1}");
                if (page > 0) LMUI.CreateButton(ref nocontainer, nomainUI, "0 0 0 0", config.messages[10], 20, "0.4 0.16", "0.6 0.21", $"zeta.open {page - 1}");

                foreach (var z in allowed.Skip(max * page).Take(max * (page + 1)))
                {

                    LMUI.CreatePanel(ref nocontainer, nomainUI, "0 0 0 1", $"{x} 0.3", $"{x + 0.16017f} 0.681");
                    LMUI.LoadImage(ref nocontainer, nomainUI, images["fon5"], $"{x} 0.3", $"{x + 0.16f} 0.68", "1 1 1 0.5");
                    LMUI.LoadImage(ref nocontainer, nomainUI, images[z.Key], $"{x + 0.02f} 0.35", $"{x + 0.14f} 0.6");
                    LMUI.CreateLabel(ref nocontainer, nomainUI, "1 1 1 0.5", z.Value.displayname, 24, $"{x} 0.59", $"{x + 0.16f} 0.68", TextAnchor.MiddleCenter);
                    if (vehicles[player.userID].cooldowns.ContainsKey(z.Key) && vehicles[player.userID].cooldowns[z.Key] > DateTime.Now)
                    {
                        LMUI.CreatePanel(ref nocontainer, nomainUI, "0 0 0 0.8", $"{x} 0.3", $"{x + 0.1602f} 0.681");
                        LMUI.CreateLabel(ref nocontainer, nomainUI, "1 1 1 0.5", FormatTime(vehicles[player.userID].cooldowns[z.Key] - DateTime.Now), 24, $"{x} 0.34", $"{x + 0.16f} 0.68", TextAnchor.MiddleCenter);
                        LMUI.CreateButton(ref nocontainer, nomainUI, "0 0 0 0.98", config.messages[11], 20, $"{x} 0.3", $"{x + 0.1606f} 0.34", "");
                        //vehicles[player.userID].cooldowns[z.Key]
                    }
                    else if (vehicles.ContainsKey(player.userID) && vehicles[player.userID].vehicles.ContainsKey(z.Key)) LMUI.CreateButton(ref nocontainer, nomainUI, "0 0 0 0.98", config.messages[13], 20, $"{x} 0.3", $"{x + 0.1606f} 0.34", "zeta.open remove " + z.Key);
                    else LMUI.CreateButton(ref nocontainer, nomainUI, "0 0 0 0.98", config.messages[12], 20, $"{x} 0.3", $"{x + 0.1606f} 0.34", "zeta.open " + z.Key);
                    x += 0.18f;
                }
            }
            LMUI.CreateButton(ref nocontainer, nomainUI, "0 0 0 0", "", 20, "0.4 0.1", "0.6 0.15", "zeta.open close");
            mainui(player, count);
            CuiHelper.AddUi(player, nocontainer);
        }
        void mainui(BasePlayer player, int count)
        {
            if (!active.Contains(player))
            {
                active.Add(player);
                if (!onJump)
                {
                    onJump = true;
                    Subscribe(nameof(OnPlayerInput));
                }
                CuiHelper.DestroyUi(player, mainUI);
                CuiElementContainer container = LMUI.CreateElementContainerNO(mainUI, "0 0 0 0", "0 0", "1 1", true);
                LMUI.LoadImage(ref container, mainUI, images["background2"], "0 0", "1 1");
                LMUI.CreateButton(ref container, mainUI, "0 0 0 0.98", config.messages[14], 20, "0.4 0.1", "0.6 0.15", "zeta.open close");
                LMUI.CreateLabel(ref container, mainUI, "1 1 1 0.8", config.messages[15], 10, "0.3 0.96", "0.7 1", TextAnchor.MiddleCenter);


                if (count > 0)
                {
                    LMUI.CreatePanel(ref container, mainUI, "0 0 0 0.95", "0.2 0.78", "0.8 0.86");
                    LMUI.CreateLabel(ref container, mainUI, "1 1 1 0.8", config.messages[16], 36, "0.2 0.75", "0.8 0.89", TextAnchor.MiddleCenter);
                    if (count > 5) LMUI.CreatePanel(ref container, mainUI, "0 0 0 0.98", "0.4 0.16", "0.6 0.21");
                }
                else
                {
                    LMUI.CreatePanel(ref container, mainUI, "0 0 0 0.95", "0.15 0.5", "0.85 0.7");
                    LMUI.CreateLabel(ref container, mainUI, "1 1 1 0.8", config.messages[17], 36, "0.15 0.5", "0.85 0.7", TextAnchor.MiddleCenter);
                }
                CuiHelper.AddUi(player, container);
            }
        }
        #endregion

        #region UI
        class LMUI
        {
            static public CuiElementContainer CreateElementContainerNO(string panelName, string color, string aMin, string aMax, bool cursor = false, string parent = "Overlay")
            {
                var NewElement = new CuiElementContainer()
            {
                {
                    new CuiPanel
                    {
                        Image = {Color = color, Sprite =  "assets/content/ui/ui.background.transparent.radial.psd"},
                        RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                        CursorEnabled = cursor,
                        FadeOut = 0f
                    },
                    new CuiElement().Parent = parent,
                    panelName
                }
            };
                return NewElement;
            }
            static public CuiElementContainer CreateElementContainer(string panelName, string anch1 = "0.5 0", string anch2 = "0.5 0")
            {
                var NewElement = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            RectTransform = {AnchorMin = anch1, AnchorMax = anch2},
                            CursorEnabled = false,
                            FadeOut = 0f
                        },
                        new CuiElement().Parent = "Overlay",
                        panelName
                    }
                };
                return NewElement;
            }
            static public void CreatePanel(ref CuiElementContainer container, string panel, string color, string aMin, string aMax, string oMin = "0 0", string oMax = "0 0", bool cursor = false, string material = "assets/content/ui/uibackgroundblur-ingamemenu.mat")
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax },
                    CursorEnabled = cursor
                },
                panel, CuiHelper.GetGuid());
            }
            static public void CreateLabel(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleLeft, string oMin = "0 0", string oMax = "0 0", string font = "RobotoCondensed-Bold.ttf", float fadeIn = 0f, float fadeout = 0f)
            {
                container.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, FadeIn = fadeIn, Text = text, Font = font },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax },
                    FadeOut = fadeout
                },
                panel, CuiHelper.GetGuid());

            }
            static public void CreateButton(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align = TextAnchor.MiddleCenter, string oMin = "0 0", string oMax = "0 0", float fadeIn = 0f, float fade = 0f, string material = "assets/content/ui/uibackgroundblur-ingamemenu.mat")
            {
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = fadeIn },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax },
                    Text = { Text = text, FontSize = size, Align = align },
                    FadeOut = fade
                },
                panel, CuiHelper.GetGuid());
            }
            static public void OutlineText(ref CuiElementContainer container, string panel, string color, string text, int size)
            {
                container.Add(new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = panel,
                    Components =
                    {
                        new CuiTextComponent {Color = color, FontSize = size, Align = TextAnchor.MiddleCenter, FadeIn = 0.5f, Text = text },
                        new CuiOutlineComponent { Distance = "0.6 0.6", Color = "0 0 0 0.8" },
                        new CuiRectTransformComponent {AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-450 -60", OffsetMax = "450 60" },
                    }
                });
            }
            static public void LoadImage(ref CuiElementContainer container, string panel, string png, string aMin, string aMax, string color = "1 1 1 1")
            {
                container.Add(new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = panel,
                    Components =
                    {
                        new CuiRawImageComponent {Png = png, Color = color },
                        new CuiRectTransformComponent { AnchorMin = aMin, AnchorMax = aMax }
                    }
                });
            }
        }
        #endregion
    }
}

// --- End of file: ZetaVehicle.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/XDCarLiftRadtown.cs ---
// --- Original Local Path: KualaRust/XDCarLiftRadtown.cs ---

﻿using UnityEngine;
using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("XDCarLiftRadtown", "DezLife", "0.1.3")]
    [Description("Лифты в супермаркетах и на заправках")]
    class XDCarLiftRadtown : RustPlugin
    {
        #region Var
        List<uint> modularCars = new List<uint>();
        #endregion

        #region Hooks
        object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            try
            {
                if (modularCars != null)
                {
                    for(int i = 0; i < modularCars.Count; i++)
                    {
                        if (modularCars[i] == entity.net.ID) return false;
                    }
                }
            }
            catch (NullReferenceException) { }
            return null;
        }
        private void OnServerInitialized()
        {        
            foreach (var mount in UnityEngine.Object.FindObjectsOfType<MonumentInfo>())
            {
                if (mount.name.Contains("gas_station_1") && config.pluginSettings.gasstation)
                {
                    var pos = mount.transform.position + mount.transform.rotation * new Vector3(4.2f, 0f, -0.5f);
                    pos.y = TerrainMeta.HeightMap.GetHeight(pos);
                    CrateLift(pos, mount.transform.rotation);
                }
                else if (mount.name.Contains("supermarket_1") && config.pluginSettings.supermarket)
                {
                    var pos = mount.transform.position + mount.transform.rotation * new Vector3(0.2f, 0f, 17.5f);
                    pos.y = TerrainMeta.HeightMap.GetHeight(pos);
                    CrateLift(pos, mount.transform.rotation);
                }
            }
        }
        #endregion

        #region Metods
        private void CrateLift(Vector3 pos, Quaternion quaternion)
        {
            RaycastHit[] rHit = Physics.SphereCastAll(pos, 5f, Vector3.one);
            
            for(int i = 0; i < rHit.Length; i++)
            {
                var ent = rHit[i].GetEntity();
                if (ent != null && (ent is ModularCarGarage))
                {
                    ent.SetFlag(BaseEntity.Flags.On, true);
                    modularCars.Add(ent.net.ID);
                    return;
                }
            }
           
            ModularCarGarage modularCar = GameManager.server.CreateEntity("assets/prefabs/deployable/modular car lift/electrical.modularcarlift.deployed.prefab", pos, quaternion) as ModularCarGarage;
            modularCar.Spawn();
            modularCar.OwnerID = 23423423;
            modularCar.SetFlag(BaseEntity.Flags.On, true);
            modularCars.Add(modularCar.net.ID);
        }

        #endregion

        #region Configuration

        public static Configuration config = new Configuration();
        public class Configuration
        {
            public class PluginSettings
            {
                [JsonProperty("Спавнить у супермаркетов ?")]
                public bool supermarket;
                [JsonProperty("Спавнить у заправок ?")]
                public bool gasstation;
            }

            [JsonProperty("Настройки спавна")]
            public PluginSettings pluginSettings;

            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    pluginSettings = new PluginSettings
                    {
                        gasstation = true,
                        supermarket = true
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning("Ошибка#skykey чтения конфигурации 'oxide/config/', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config, true);

        #endregion
    }
}


// --- End of file: XDCarLiftRadtown.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/XRate.cs ---
// --- Original Local Path: KualaRust/XRate.cs ---

﻿using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using UnityEngine;
using Random = UnityEngine.Random;
using System;
using Oxide.Core;
using ConVar;
using ru = Oxide.Game.Rust;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("XRate", "fermens", "0.2.51")]
    [Description("НАСТРОЙКА РЕЙТОВ ДОБЫЧИ (ОПТИМИЗИРОВАНО)")]
    public class XRate : RustPlugin
    {
        #region Config
        private PluginConfig config;
        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        class rateset
        {
            [JsonProperty("Поднимаемые ресурсы")]
            public float grab;

            [JsonProperty("Добываемые ресурсы")]
            public float gather;

            [JsonProperty("Сульфур")]
            public float sulfur;

            [JsonProperty("С карьера")]
            public float carier;

            [JsonProperty("С ящиков/бочек")]
            public float box;

            [JsonProperty("Запертый ящик")]
            public float lockbox;

            [JsonProperty("С ученых")]
            public float npc;

            [JsonProperty("Скорость переплавки")]
            public float speed;
        }

        class daynight
        {
            [JsonProperty("Включить?")]
            public bool enable;

            [JsonProperty("Длина ночи")]
            public float night;

            [JsonProperty("Длина дня")]
            public float day;

            [JsonProperty("Автопропуск ночи")]
            public bool skipnight;

            [JsonProperty("Голосование за пропуск ночи")]
            public bool vote;

            [JsonProperty("Ночное увелечение рейтов (прим. 1.0 - на 100%, 0 - выключить)")]
            public float upnight;
        }

        private class PluginConfig
        {
            [JsonProperty("Экспериментально. Не трогать!")]
            public bool exp;

            [JsonProperty("Рейты у обычных игроков")]
            public rateset rates;

            [JsonProperty("Настройка дня и ночи")]
            public daynight daynight;

            [JsonProperty("Сообщения")]
            public List<string> messages;

            [JsonProperty("Привилегии")]
            public Dictionary<string, rateset> privilige;

            [JsonProperty("На что не увеличивать рейты?")]
            public string[] blacklist;

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    privilige = new Dictionary<string, rateset>()
                    {
                        { "xrate.x3", new rateset{ box = 3f, carier = 3f, gather = 3f, grab = 3f, npc = 3f, speed = 4f, sulfur = 2.5f } },
                        { "xrate.x4", new rateset{ box = 4f, carier = 4f, gather = 4f, grab = 4f, npc = 4f, speed = 4f, sulfur = 2.5f } }
                    },
                    rates = new rateset { box = 2f, carier = 2f, gather = 2f, grab = 2f, npc = 2f, speed = 2f, sulfur = 2f },
                    daynight = new daynight
                    {
                        day = 50f,
                        night = 10f,
                        enable = true,
                        skipnight = false,
                        upnight = 0f,
                        vote = false
                    },
                    exp = false,
                    messages = new List<string>
                    {
                        "<size=15><color=#ccff33>Наступила ночь</color>, рейты добычи увеличены на <color=#ccff33>{num}%</color>!</size>\n<size=10><color=#ccff33>/rate</color> - узнать текущие ваши рейты.</size>",
                        "<size=15><color=#ccff33>Наступил день</color>, рейты добычи стали прежними!</size>\n<size=10><color=#ccff33>/rate</color> - узнать текущие ваши рейты.</size>",
                        "<color=#ccff33>INFORATE | {name}</color>\nПоднимаемые: x<color=#F0E68C>{0}</color>\nДобываемые: x<color=#F0E68C>{1}</color> <size=10>(cульфур: x<color=#F0E68C>{6}</color>)</size>\nКарьер: x<color=#F0E68C>{2}</color>\nЯщики/бочки: x<color=#F0E68C>{3}</color>\nNPC: x<color=#F0E68C>{4}</color>\nСкорость переплавки: x<color=#F0E68C>{5}</color>"
                    },
                    blacklist = new string[]
                    {
                        "sticks",
                        "flare"
                    }
                };
            }
        }
        #endregion

        #region getrate
        Dictionary<string, rateset> cash = new Dictionary<string, rateset>();
        Dictionary<ulong, float> cashcariers = new Dictionary<ulong, float>();
        static XRate ins;
        void Init()
        {
            ins = this;
        }

        bool skip;
        bool isday;
        void OnHour()
        {
            if (TOD_Sky.Instance.Cycle.Hour > TOD_Sky.Instance.SunriseTime && TOD_Sky.Instance.Cycle.Hour <= 19f && !isday) OnSunrise();
            else if ((TOD_Sky.Instance.Cycle.Hour >= 19f || TOD_Sky.Instance.Cycle.Hour < TOD_Sky.Instance.SunriseTime) && isday) OnSunset();
        }

        void OnSunrise()
        {
            TOD_Sky.Instance.Components.Time.DayLengthInMinutes = daytime;
            isday = true;
            if (upnight > 1f)
            {
                Server.Broadcast(config.messages[1]);
                nightupdate();
            }
        }

        #region ГОЛОСОВАНИЕ
        const string REFRESHGUI = "[{\"name\":\"daytext\",\"parent\":\"day\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{day}\",\"fontSize\":18,\"align\":\"MiddleCenter\",\"color\":\"1 1 1 0.7921728\",\"fadeIn\":0.5},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.392941\",\"distance\":\"0.5 0.5\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]},{\"name\":\"neighttext\",\"parent\":\"night\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{night}\",\"fontSize\":18,\"align\":\"MiddleCenter\",\"color\":\"1 1 1 0.7921569\",\"fadeIn\":0.5},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.3948711\",\"distance\":\"0.5 0.5\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]}]";
        const string GUI = "[{\"name\":\"Main\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0 0 0 0.2035446\",\"fadeIn\":0.5},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 1\",\"anchormax\":\"0.5 1\",\"offsetmin\":\"-100 -65\",\"offsetmax\":\"100 -35\"}]},{\"name\":\"day\",\"parent\":\"Main\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"chat.say /voteday\",\"color\":\"1 1 1 0.3929416\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"0.5 1\",\"offsetmax\":\"0 0\"}]},{\"name\":\"daytext\",\"parent\":\"day\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{day}\",\"fontSize\":18,\"align\":\"MiddleCenter\",\"color\":\"1 1 1 0.7921728\",\"fadeIn\":0.5},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.392941\",\"distance\":\"0.5 0.5\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]},{\"name\":\"night\",\"parent\":\"Main\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"chat.say /votenight\",\"color\":\"0 0 0 0.3929408\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]},{\"name\":\"neighttext\",\"parent\":\"night\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{night}\",\"fontSize\":18,\"align\":\"MiddleCenter\",\"color\":\"1 1 1 0.7921569\",\"fadeIn\":0.5},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.3948711\",\"distance\":\"0.5 0.5\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]}]";
        static string CONSTVOTE = "";

        void CLEARVOTE()
        {
            Vtimer?.Destroy();
            Vday = 0;
            Vnight = 0;
            voted.Clear();
        }

        void StartVote()
        {
            activevote = true;
            CLEARVOTE();
            Debug.LogWarning("-Голосование за пропуск ночи-");
            Server.Broadcast("<color=yellow>Начато голосование за пропуск ночи. Нажмите на ДЕНЬ или НОЧЬ или пропишите в чат /voteday - за день или /votenight - за ночь.</color>");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = Network.Net.sv.connections }, null, "DestroyUI", "Main");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = Network.Net.sv.connections }, null, "AddUI", CONSTVOTE);
            Vtimer = timer.Once(30f, () => EndVote());
        }

        void EndVote()
        {
            activevote = false;
            if (Vday > Vnight)
            {
                TOD_Sky.Instance.Cycle.Hour += (24 - TOD_Sky.Instance.Cycle.Hour) + TOD_Sky.Instance.SunriseTime;
                OnSunrise();
                Server.Broadcast("<color=yellow>Большинство проголосовало за день. Пропускаем ночь...</color>");
                Debug.LogWarning("-Пропускаем ночь-");
            }
            else
            {
                Debug.LogWarning("-Ночь остается-");
                Server.Broadcast("<color=yellow>— Да будет свет! — сказал электрик и перерезал провода.</color>");
            }
            CLEARVOTE();
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = Network.Net.sv.connections }, null, "DestroyUI", "Main");
        }

        Timer Vtimer;
        bool activevote;
        static int Vday;
        static int Vnight;
        static List<ulong> voted = new List<ulong>();

        private void REFRESHME()
        {
            List<Network.Connection> sendto = Network.Net.sv.connections.Where(x => voted.Contains(x.userid)).ToList();
            string RGUI = REFRESHGUI.Replace("{day}", Vday.ToString()).Replace("{night}", Vnight.ToString());
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "DestroyUI", "daytext");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "DestroyUI", "neighttext");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "AddUI", RGUI);
        }

        private void cmdvoteday(BasePlayer player, string command, string[] args)
        {
            if (!CHECKPOINT(player)) return;

            player.ChatMessage("<color=yellow>Голос за ДЕНЬ успешно принят.</color>");
            Vday++;
            voted.Add(player.userID);
            REFRESHME();
            if (Vday > BasePlayer.activePlayerList.Count * 0.6f) EndVote();
        }

        private void cmdvotenight(BasePlayer player, string command, string[] args)
        {
            if (!CHECKPOINT(player)) return;

            player.ChatMessage("<color=yellow>Голос за НОЧЬ успешно принят.</color>");
            Vnight++;
            voted.Add(player.userID);
            REFRESHME();
            if (Vnight > BasePlayer.activePlayerList.Count * 0.6f) EndVote();
        }

        bool CHECKPOINT(BasePlayer player)
        {
            if (!activevote)
            {
                player.ChatMessage("<color=yellow>ГОЛОСОВАНИЕ НЕ АКТИВНО!</color>");
                return false;
            }

            if (voted.Contains(player.userID))
            {
                player.ChatMessage("<color=yellow>ВЫ УЖЕ ГОЛОСОВАЛИ!</color>");
                return false;
            }

            return true;
        }
        #endregion

        void OnSunset()
        {
            if (skip) return;
            if (config.daynight.skipnight)
            {
                Env.time = 23.99f;
                skip = true;
                timer.Once(8f, () =>
                {
                    Env.time = TOD_Sky.Instance.SunriseTime;
                    skip = false;
                });
                Debug.Log("Пропускаем ночь.");
                return;
            }
            else if (config.daynight.vote) StartVote();

            TOD_Sky.Instance.Components.Time.DayLengthInMinutes = nighttime;
            isday = false;
            if (upnight > 1f)
            {
                Server.Broadcast(config.messages[0].Replace("{num}", (config.daynight.upnight * 100f).ToString()));
                nightupdate();
            }
        }

        void nightupdate()
        {
            if (cash.Count > 0) foreach (var id in cash.ToList()) getuserrate(id.Key);
            if (cashcariers.Count > 0) foreach (var id in cashcariers.ToList()) CashCarier(id.Key);
        }

        float daytime;
        float nighttime;
        float upnight;
        TOD_Time comp;
        void OnServerInitialized()
        {
            if(config.blacklist == null || config.blacklist.Length == 0)
            {
                config.blacklist = new string[]
                {
                    "sticks",
                    "flare"
                };
                SaveConfig();
            }

            if(config.daynight == null)
            {
                config.daynight = new daynight
                {
                    day = 50f,
                    night = 10f,
                    enable = true,
                    skipnight = false,
                    upnight = 0f,
                    vote = false
                };
                SaveConfig();
            }

            if (config.rates.lockbox == 0f)
            {
                config.rates.lockbox = config.rates.box;
                foreach (var x in config.privilige) x.Value.lockbox = x.Value.box;
                SaveConfig();
            }

            if (config.daynight.enable)
            {
                if (config.daynight.vote)
                {
                    CONSTVOTE = GUI.Replace("{day}", "ДЕНЬ").Replace("{night}", "НОЧЬ");
                    Interface.Oxide.GetLibrary<ru.Libraries.Command>(null).AddChatCommand("voteday", this, "cmdvoteday");
                    Interface.Oxide.GetLibrary<ru.Libraries.Command>(null).AddChatCommand("votenight", this, "cmdvotenight");
                }
                daytime = config.daynight.day * 24f / (19f - TOD_Sky.Instance.SunriseTime);
                nighttime = config.daynight.night * 24f / (24f - (19f - TOD_Sky.Instance.SunriseTime));
                upnight = 1f + config.daynight.upnight;
                comp = TOD_Sky.Instance.Components.Time;
                comp.ProgressTime = true;
                comp.UseTimeCurve = false;
                comp.OnSunrise += OnSunrise;
                comp.OnSunset += OnSunset;
                comp.OnHour += OnHour;

                if (TOD_Sky.Instance.Cycle.Hour > TOD_Sky.Instance.SunriseTime && TOD_Sky.Instance.Cycle.Hour <= 19f) OnSunrise();
                else OnSunset();
            }

            var ovens = UnityEngine.Object.FindObjectsOfType<BaseOven>();
            for (var i = 0; i < ovens.Length; i++)
            {
                OnEntitySpawned(ovens[i]);
            }
            timer.Once(1f, () =>
            {
                foreach (BaseOven oven in ovens)
                {
                    var component = oven.GetComponent<FurnaceController>();
                    if (oven == null || oven.IsDestroyed || !oven.IsOn()) continue;
                    component.StartCooking();
                }
            });
            foreach (string perm in config.privilige.Keys) permission.RegisterPermission(perm, this);
            foreach (BasePlayer player in BasePlayer.activePlayerList) getuserrate(player.UserIDString);
        }

        void OnGroupPermissionGranted(string name, string perm)
        {
            foreach (BasePlayer player in BasePlayer.allPlayerList)
            {
                if (permission.UserHasGroup(player.UserIDString, name)) getuserrate(player.UserIDString);
            }
        }

        void OnGroupPermissionRevoked(string name, string perm)
        {
            foreach (BasePlayer player in BasePlayer.allPlayerList)
            {
                if (permission.UserHasGroup(player.UserIDString, name)) getuserrate(player.UserIDString);
            }
        }

        void OnUserGroupRemoved(string id, string groupName)
        {
            getuserrate(id);
        }

        void OnUserGroupAdded(string id, string groupName)
        {
            getuserrate(id);
        }

        void OnUserPermissionGranted(string id, string permName)
        {
            getuserrate(id);
        }

        void OnUserPermissionRevoked(string id, string permName)
        {
            getuserrate(id);
        }

        void OnPlayerConnected(BasePlayer player)
        {
            getuserrate(player.UserIDString);
        }

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (cash.ContainsKey(player.UserIDString)) cash.Remove(player.UserIDString);
        }
        #endregion

        #region Rates
        [ChatCommand("rate")]
        private void cmdRATE(BasePlayer player, string command, string[] args)
        {
            player.ChatMessage(config.messages[2].Replace("{name}", player.displayName).Replace("{0}", cash[player.UserIDString].grab.ToString()).Replace("{1}", cash[player.UserIDString].gather.ToString()).Replace("{2}", cash[player.UserIDString].carier.ToString()).Replace("{3}", cash[player.UserIDString].box.ToString()).Replace("{4}", cash[player.UserIDString].npc.ToString()).Replace("{5}", cash[player.UserIDString].speed.ToString()).Replace("{6}", cash[player.UserIDString].sulfur.ToString()));
        }

        [PluginReference] private Plugin ZREWARDME;

        void getuserrate(string id, float bonus = 0f)
        {
            rateset rate = config.privilige.LastOrDefault(x => permission.UserHasPermission(id, x.Key)).Value ?? config.rates;
            if (!cash.ContainsKey(id)) cash[id] = new rateset();
            if (ZREWARDME != null && bonus == 0f) bonus = ZREWARDME.Call<float>("APIBONUS", id);
            if (upnight > 1f && !isday)
            {
                cash[id].box = rate.box * upnight;
                cash[id].carier = rate.carier * upnight;
                cash[id].gather = rate.gather * upnight;
                cash[id].grab = rate.grab * upnight;
                cash[id].lockbox = rate.lockbox * upnight;
                cash[id].npc = rate.npc * upnight;
                cash[id].sulfur = rate.sulfur * upnight;
            }
            else
            {
                cash[id].box = rate.box;
                cash[id].carier = rate.carier;
                cash[id].gather = rate.gather;
                cash[id].grab = rate.grab;
                cash[id].lockbox = rate.lockbox;
                cash[id].npc = rate.npc;
                cash[id].sulfur = rate.sulfur;
            }

            if(bonus > 0f)
            {
                cash[id].gather += bonus;
                cash[id].grab += bonus;
                cash[id].sulfur += bonus;
            }

            cash[id].speed = rate.speed;
        }

        void OnCollectiblePickup(Item item, BasePlayer player)
        {
            if (config.blacklist.Contains(item.info.shortname)) return;
            item.amount = (int)(item.amount * cash[player.UserIDString].grab);
        }

        void OnGrowableGather(GrowableEntity plant, Item item, BasePlayer player)
        {
            if (player == null || item == null) return;
            if (config.blacklist.Contains(item.info.shortname)) return;
            item.amount = (int)(item.amount * cash[player.UserIDString].grab);
        }

        void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            if (config.blacklist.Contains(item.info.shortname)) return;
            if (item.info.itemid.Equals(-1157596551)) item.amount = (int)(item.amount * cash[player.UserIDString].sulfur);
            else item.amount = (int)(item.amount * cash[player.UserIDString].gather);
        }

        void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            if (config.blacklist.Contains(item.info.shortname)) return;
            BasePlayer player = entity.ToPlayer();
            if (player != null)
            {
                if (item.info.itemid.Equals(-1157596551)) item.amount = (int)(item.amount * cash[player.UserIDString].sulfur);
                else item.amount = (int)(item.amount * cash[player.UserIDString].gather);
            }
            else
            {
                if (item.info.itemid.Equals(-1157596551)) item.amount *= (int)(item.amount * config.rates.sulfur);
                else item.amount *= (int)(item.amount * config.rates.gather);
            }
        }

        private void CashCarier(ulong id)
        {
            rateset rate = config.privilige.LastOrDefault(x => permission.UserHasPermission(id.ToString(), x.Key)).Value ?? config.rates;
            if (!isday && upnight > 1f) cashcariers[id] = rate.carier * upnight;
            else cashcariers[id] = rate.carier;
        }

        private object OnExcavatorGather(ExcavatorArm arm, Item item)
        {
            if (config.blacklist.Contains(item.info.shortname)) return null;
            item.amount = (int)(item.amount * config.rates.carier);
            return null;
        }

        private void OnQuarryToggled(BaseEntity entity, BasePlayer player)
        {
            CashCarier(entity.OwnerID);
        }

        void OnQuarryGather(MiningQuarry quarry, Item item)
        {
            if (config.blacklist.Contains(item.info.shortname)) return;
            float rate;
            if (!cashcariers.TryGetValue(quarry.OwnerID, out rate))
            {
                CashCarier(quarry.OwnerID);
                rate = cashcariers[quarry.OwnerID];
            }
            item.amount = (int)(item.amount * rate);
        }
        /*
        object OnQuarryGather(MiningQuarry quarry, List<ResourceDepositManager.ResourceDeposit.ResourceDepositEntry> itemList)
        {
            if (!cashcariers.ContainsKey(quarry.OwnerID)) CashCarier(quarry.OwnerID);
            foreach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in itemList)
            {
                if ((quarry.canExtractLiquid || !resource.isLiquid) && (quarry.canExtractSolid || resource.isLiquid))
                {
                    resource.workDone += quarry.workToAdd;
                    if ((double)resource.workDone >= (double)resource.workNeeded)
                    {
                        int iAmount = Mathf.FloorToInt(resource.workDone / resource.workNeeded);
                        resource.workDone -= (float)iAmount * resource.workNeeded;
                        Item obj = ItemManager.Create(resource.type, (int)(iAmount * cashcariers[quarry.OwnerID]), 0UL);
                        if (!obj.MoveToContainer(quarry.hopperPrefab.instance.GetComponent<StorageContainer>().inventory, -1, true))
                        {
                            obj.Remove(0.0f);
                            quarry.SetOn(false);
                        }
                    }
                }
            }
            if (!quarry.FuelCheck()) quarry.SetOn(false);
            return false;
        }*/

        void OnContainerDropItems(ItemContainer container)
        {
            LootContainer lootcont = container.entityOwner as LootContainer;
            if (lootcont == null || lootcont.OwnerID != 0) return;
            var player = lootcont?.lastAttacker?.ToPlayer();
            if (lootcont.HasFlag(BaseEntity.Flags.Reserved7) || lootcont.HasFlag(BaseEntity.Flags.Reserved8)) return;
            
            if (player != null && cash.ContainsKey(player.UserIDString))
            {
                foreach (var item in lootcont.inventory.itemList)
                {
                    int maxstack = item.MaxStackable();
                    if (maxstack  == 1 || config.blacklist.Contains(item.info.shortname) || item.IsBlueprint()) continue;
                    item.amount = (int)(item.amount * cash[player.UserIDString].box);
                    if (item.amount > maxstack) item.amount = maxstack;
                }
            }
            else
            {
                foreach (var item in lootcont.inventory.itemList.Where(x => x.info.stackable > 1))
                {
                    int maxstack = item.MaxStackable();
                    if (maxstack == 1 || config.blacklist.Contains(item.info.shortname) || item.IsBlueprint()) continue;
                    item.amount = (int)(item.amount * config.rates.box);
                    if (item.amount > maxstack) item.amount = maxstack;
                }
            }
        }

        private void OnEntityDeath(BaseNetworkable entity, HitInfo info)
        {
            if (entity is BaseHelicopter && config.exp)
            {
                HackableLockedCrate ent = (HackableLockedCrate)GameManager.server.CreateEntity("assets/prefabs/deployable/chinooklockedcrate/codelockedhackablecrate.prefab", entity.transform.position, entity.transform.rotation);
                ent.Spawn();
            }
        }

        private void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            if (player == null || entity == null) return;
            if (entity is NPCPlayerCorpse)
            {
                if (entity.HasFlag(BaseEntity.Flags.Reserved7) || entity.HasFlag(BaseEntity.Flags.Reserved8)) return;
                ItemContainer cont = entity.GetComponent<NPCPlayerCorpse>().containers.FirstOrDefault();
                foreach (var item in cont.itemList.Where(x => x.info.stackable > 1))
                {
                    int maxstack = item.MaxStackable();
                    if (maxstack == 1 || config.blacklist.Contains(item.info.shortname) || item.IsBlueprint()) continue;
                    item.amount = (int)(item.amount * cash[player.UserIDString].npc);
                    if (item.amount > maxstack) item.amount = maxstack;
                }
                entity.SetFlag(BaseEntity.Flags.Reserved7, true);
            }
            else if (entity is LootContainer)
            {
                LootContainer lootcont = entity.GetComponent<LootContainer>();
                if (lootcont == null || lootcont.HasFlag(BaseEntity.Flags.Reserved7) || lootcont.HasFlag(BaseEntity.Flags.Reserved8)) return;
                if (entity is HackableLockedCrate)
                {
                    foreach (var item in lootcont.inventory.itemList.Where(x => x.info.stackable > 1))
                    {
                        int maxstack = item.MaxStackable();
                        if (maxstack == 1 || config.blacklist.Contains(item.info.shortname) || item.IsBlueprint()) continue;
                        item.amount = (int)(item.amount * cash[player.UserIDString].lockbox);
                        if (item.amount > maxstack) item.amount = maxstack;
                    }
                }
                else
                {
                    foreach (var item in lootcont.inventory.itemList.Where(x => x.info.stackable > 1))
                    {
                        int maxstack = item.MaxStackable();
                        if (maxstack == 1 || config.blacklist.Contains(item.info.shortname) || item.IsBlueprint()) continue;
                        item.amount = (int)(item.amount * cash[player.UserIDString].box);
                        if (item.amount > maxstack) item.amount = maxstack;
                    }
                }
                lootcont.SetFlag(BaseEntity.Flags.Reserved7, true);
            }
        }
        #endregion

        #region Smelt
        private void Unload()
        {

            if (comp != null)
            {
                comp.OnSunrise -= OnSunrise;
                comp.OnSunset -= OnSunset;
                comp.OnHour -= OnHour;
            }
            if (config.daynight.vote) CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = Network.Net.sv.connections }, null, "DestroyUI", "Main");
            
            var ovens = UnityEngine.Object.FindObjectsOfType<BaseOven>();

            foreach (BaseOven oven in ovens)
            {
                var component = oven.GetComponent<FurnaceController>();
                if (oven.IsOn())
                {
                    component.StopCooking();
                    oven.StartCooking();
                }
                UnityEngine.Object.Destroy(component);
            }
        }

        private void OnEntitySpawned(BaseNetworkable entity)
        {
            if (entity == null) return;
            else if (entity is BaseOven) entity?.gameObject?.AddComponent<FurnaceController>();
        }

        private object OnOvenToggle(StorageContainer oven, BasePlayer player)
        {
            if (oven is BaseFuelLightSource) return null;
            FurnaceController component = oven.GetComponent<FurnaceController>();
            if (component == null) component = oven.gameObject.AddComponent<FurnaceController>();
            if (oven.IsOn())
            {
                component.StopCooking();
            }
            else
            {
                component.StartCooking();
                component.SetSpeed(cash[player.UserIDString].speed);
            }
            return false;
        }

        public class FurnaceController : FacepunchBehaviour
        {
            private BaseOven _oven;
            private BaseOven Furnace
            {
                get
                {
                    if (_oven == null) _oven = GetComponent<BaseOven>();
                    return _oven;
                }
            }
            private float _speedMultiplier;
            private int amountmultiplier;
            private int amount;

            private void Awake()
            {
                SetSpeed(ins.config.rates.speed);
                amount = amountmultiplier;
            }

            public void SetSpeed(float newspeed)
            {
                _speedMultiplier = newspeed;
                amountmultiplier = (int)newspeed;
            }

            private Item FindBurnable()
            {
                if (Furnace.inventory == null) return null;

                foreach (var item in Furnace.inventory.itemList)
                {
                    var component = item.info.GetComponent<ItemModBurnable>();
                    if (component && (Furnace.fuelType == null || item.info == Furnace.fuelType))
                    {
                        return item;
                    }
                }

                return null;
            }

            public void Cook()
            {
                var item = FindBurnable();
                if (item == null)
                {
                    StopCooking();
                    return;
                }

                SmeltItems();
                var slot = Furnace.GetSlot(BaseEntity.Slot.FireMod);
                if (slot) slot.SendMessage("Cook", 0.5f, SendMessageOptions.DontRequireReceiver);

                var component = item.info.GetComponent<ItemModBurnable>();
                item.fuel -= 5f;
                if (!item.HasFlag(global::Item.Flag.OnFire))
                {
                    item.SetFlag(global::Item.Flag.OnFire, true);
                    item.MarkDirty();
                }

                if (item.fuel <= 0f) ConsumeFuel(item, component);
            }

            private void ConsumeFuel(Item fuel, ItemModBurnable burnable)
            {
                if (Furnace.allowByproductCreation && burnable.byproductItem != null && Random.Range(0f, 1f) > burnable.byproductChance)
                {
                    var def = burnable.byproductItem;
                    var item = ItemManager.Create(def, burnable.byproductAmount * amountmultiplier);
                    if (!item.MoveToContainer(Furnace.inventory))
                    {
                        StopCooking();
                        item.Drop(Furnace.inventory.dropPosition, Furnace.inventory.dropVelocity);
                    }
                }
                amount = amountmultiplier;
                if (fuel.amount <= amountmultiplier)
                {
                    fuel.Remove();
                    return;
                }
                fuel.amount -= amountmultiplier;
                fuel.fuel = burnable.fuelAmount;
                fuel.MarkDirty();
            }
            private Dictionary<Item, float> cook = new Dictionary<Item, float>();
            private void SmeltItems()
            {
                for (var i = 0; i < Furnace.inventory.itemList.Count; i++)
                {
                    var item = Furnace.inventory.itemList[i];
                    if (item == null || !item.IsValid()) continue;

                    var cookable = item.info.GetComponent<ItemModCookable>();
                    if (cookable == null) continue;

                    var temperature = item.temperature;
                    if ((temperature < cookable.lowTemp || temperature > cookable.highTemp))
                    {
                        if (!cookable.setCookingFlag || !item.HasFlag(global::Item.Flag.Cooking)) continue;
                        item.SetFlag(global::Item.Flag.Cooking, false);
                        item.MarkDirty();
                        continue;
                    }
                    if (cook.ContainsKey(item)) cook[item] += 0.5f;
                    else cook[item] = 0.5f;
                    if (cook[item] < (cookable.cookTime / _speedMultiplier)) continue;
                    cook[item] = 0f;
                    if (cookable.setCookingFlag && !item.HasFlag(global::Item.Flag.Cooking))
                    {
                        item.SetFlag(global::Item.Flag.Cooking, true);
                        item.MarkDirty();
                    }
                    int position = item.position;
                    int amount2 = item.amount;
                    if (amount2 > amount)
                    {
                        item.amount -= amount;
                        item.MarkDirty();
                    }
                    else
                    {
                        item.Remove();
                    }

                    if (cookable.becomeOnCooked == null) continue;
                    int newamount = cookable.amountOfBecome * amount;
                    var item2 = ItemManager.Create(cookable.becomeOnCooked, amount2 < newamount ? amount2 : newamount);

                    if (item2 == null || item2.MoveToContainer(item.parent, position) || item2.MoveToContainer(item.parent)) continue;
                    item2.Drop(item.parent.dropPosition, item.parent.dropVelocity);
                    if (!item.parent.entityOwner) continue;
                    StopCooking();
                }
            }

            public void StartCooking()
            {
                if (FindBurnable() == null) return;

                StopCooking();

                Furnace.inventory.temperature = Furnace.cookingTemperature;
                Furnace.UpdateAttachmentTemperature();

                Furnace.InvokeRepeating(Cook, 0.5f, 0.5f);
                Furnace.SetFlag(BaseEntity.Flags.On, true);
            }

            public void StopCooking()
            {
                cook.Clear();
                Furnace.CancelInvoke(Cook);
                Furnace.StopCooking();
            }
        }
        #endregion
    }
}

// --- End of file: XRate.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/Logger.cs ---
// --- Original Local Path: KualaRust/Logger.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;

// TODO: Finish implementing ItemList and ItemListType config settings
// TODO: Finish implementing RotateLog config option
// TODO: Fix RCON clients screwing up with log output from select commands
/*
    playerlist
    status
    banlist
    banlistex
    bans
    server.fps
    server.hostname
    server.description
    serverinfo
    plugins
*/

namespace Oxide.Plugins
{
    [Info("Logger", "Wulf/lukespragg", "2.2.1")]
    [Description("Configurable logging of chat, commands, connections, and more")]
    public class Logger : CovalencePlugin
    {
        #region Configuration

        private Configuration config;

        public class Configuration
        {
            [JsonProperty(PropertyName = "Log chat messages (true/false)")]
            public bool LogChat { get; set; } = true;

            [JsonProperty(PropertyName = "Log command usage (true/false)")]
            public bool LogCommands { get; set; } = true;

            [JsonProperty(PropertyName = "Log player connections (true/false)")]
            public bool LogConnections { get; set; } = true;

            [JsonProperty(PropertyName = "Log player disconnections (true/false)")]
            public bool LogDisconnections { get; set; } = true;

            [JsonProperty(PropertyName = "Log player respawns (true/false)")]
            public bool LogRespawns { get; set; } = true;

#if RUST

            [JsonProperty(PropertyName = "Log when crafting started (true/false)")]
            public bool LogCraftingStarted { get; set; } = true;

            [JsonProperty(PropertyName = "Log when crafting cancelled (true/false)")]
            public bool LogCraftingCancelled { get; set; } = true;

            [JsonProperty(PropertyName = "Log when crafting finished (true/false)")]
            public bool LogCraftingFinished { get; set; } = true;

            [JsonProperty(PropertyName = "Log items dropped by players (true/false)")]
            public bool LogItemDrops { get; set; } = true;

#endif

            [JsonProperty(PropertyName = "Log output to console (true/false)")]
            public bool LogToConsole { get; set; } = false;

            // TODO: Option to listen to commands from admin, moderator, or all

            [JsonProperty(PropertyName = "Rotate logs daily (true/false)")]
            public bool RotateLogs { get; set; } = true;

            [JsonProperty(PropertyName = "Command list (full or short commands)")]
            public List<string> CommandList { get; set; } = new List<string>
            {
                /*"help", "version", "chat.say", "craft.add", "craft.canceltask", "global.kill",
                "global.respawn", "global.respawn_sleepingbag", "global.status", "global.wakeup",
                "inventory.endloot", "inventory.unlockblueprint"*/
            };

            [JsonProperty(PropertyName = "Command list type (blacklist or whitelist)")]
            public string CommandListType { get; set; } = "blacklist";

            //[JsonProperty(PropertyName = "Item list (full or short names)")]
            //public List<string> ItemList { get; set; } = new List<string>
            //{
            //    /*"rock", "torch"*/
            //};

            //[JsonProperty(PropertyName = "Item list type (blacklist or whitelist)")]
            //public string ItemListType { get; set; } = "blacklist";
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            string configPath = $"{Interface.Oxide.ConfigDirectory}{Path.DirectorySeparatorChar}{Name}.json";
            LogWarning($"Could not load a valid configuration file, creating a new configuration file at {configPath}");
            config = new Configuration();
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion Configuration

        #region Localization

        private new void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CommandReason"] = "reason",
                ["CraftingCancelled"] = "{0} ({1}) cancelled crafting {2} {3}",
                ["CraftingFinished"] = "{0} ({1}) finished crafting {2} {3}",
                ["CraftingStarted"] = "{0} ({1}) started crafting {2} {3}",
                ["ItemDropped"] = "{0} ({1}) dropped {2} {3}",
                ["NotAllowed"] = "You are not allowed to use the '{0}' command",
                ["PlayerCommand"] = "{0} ({1}) ran command: {2} {3}",
                ["PlayerConnected"] = "{0} ({1}) connected from {2}",
                ["PlayerDisconnected"] = "{0} ({1}) disconnected",
                ["PlayerMessage"] = "{0} ({1}) said: {2}",
                ["PlayerRespawned"] = "{0} ({1}) respawned at {2}",
                ["RconCommand"] = "{0} ran command: {1} {2}",
                ["ServerCommand"] = "SERVER ran command: {0} {1}"
            }, this);
        }

        #endregion Localization

        #region Initialization

        private const string commandReason = "loggerreason";
        private const string permReason = "logger.reason";

        private void Init()
        {
            permission.RegisterPermission(permReason, this);

            AddCovalenceCommand(commandReason, "ReasonCommand");
            AddLocalizedCommand("CommandReason", "ReasonCommand");

            if (!config.LogChat) Unsubscribe("OnUserChat");
            if (!config.LogCommands) Unsubscribe("OnServerCommand");
            if (!config.LogConnections) Unsubscribe("OnUserConnected");
            if (!config.LogDisconnections) Unsubscribe("OnUserDisconnected");
            if (!config.LogRespawns) Unsubscribe("OnUserRespawned");
#if RUST
            if (!config.LogCraftingStarted) Unsubscribe("OnItemCraft");
            if (!config.LogCraftingCancelled) Unsubscribe("OnItemCraftCancelled");
            if (!config.LogCraftingFinished) Unsubscribe("OnItemCraftFinished");
            if (!config.LogItemDrops) Unsubscribe("OnItemAction");
#endif
        }

        #endregion Initialization

        #region Logging

        private void OnUserChat(IPlayer player, string message) => Log("chat", "PlayerMessage", player.Name, player.Id, message);

        private void OnUserConnected(IPlayer player) => Log("connections", "PlayerConnected", player.Name, player.Id, player.Address);

        private void OnUserDisconnected(IPlayer player) => Log("disconnections", "PlayerDisconnected", player.Name, player.Id);

        private void OnUserRespawned(IPlayer player) => Log("respawns", "PlayerRespawned", player.Name, player.Id, player.Position().ToString());

#if RUST
        private void OnItemAction(Item item, string action)
        {
            BasePlayer player = item.parent?.playerOwner;

            if (action.ToLower() == "drop" && player != null)
            {
                Log("itemdrops", "ItemDropped", player.displayName.Sanitize(), player.UserIDString, item.amount, item.info.displayName?.english ?? item.name);
            }
        }

        private void OnItemCraft(ItemCraftTask task)
        {
            BasePlayer player = task.owner;
            ItemDefinition item = task.blueprint.targetItem;
            Log("crafting", "CraftingStarted", player.displayName.Sanitize(), player.UserIDString, task.amount, item.displayName.english);
        }

        private void OnItemCraftCancelled(ItemCraftTask task)
        {
            BasePlayer player = task.owner;
            ItemDefinition item = task.blueprint.targetItem;
            Log("crafting", "CraftingCancelled", player.displayName.Sanitize(), player.UserIDString, task.amount, item.displayName.english);
        }

        private void OnItemCraftFinished(ItemCraftTask task, Item item)
        {
            BasePlayer player = task.owner;
            Log("crafting", "CraftingFinished", player.displayName.Sanitize(), player.UserIDString, item.amount, item.info.displayName.english);
        }

        private void OnRconCommand(IPEndPoint ip, string command, string[] args)
        {
            if (command == "chat.say" || command == "say")
            {
                return;
            }

            if (config.CommandListType.ToLower() == "blacklist" && config.CommandList.Contains(command) || config.CommandList.Contains(command))
            {
                return;
            }

            if (config.CommandListType.ToLower() == "whitelist" && !config.CommandList.Contains(command) && !config.CommandList.Contains(command))
            {
                return;
            }

            Log("commands", "RconCommand", ip.Address, command, string.Join(" ", args));
        }

        private void OnServerCommand(ConsoleSystem.Arg arg)
        {
            string command = arg.cmd.Name;
            string fullCommand = arg.cmd.FullName;

            if (fullCommand == "chat.say")
            {
                return;
            }

            if (config.CommandListType.ToLower() == "blacklist" && config.CommandList.Contains(command) || config.CommandList.Contains(fullCommand))
            {
                return;
            }

            if (config.CommandListType.ToLower() == "whitelist" && !config.CommandList.Contains(command) && !config.CommandList.Contains(fullCommand))
            {
                return;
            }

            if (arg.Connection != null)
            {
                Log("commands", "PlayerCommand", arg.Connection.username.Sanitize(), arg.Connection.userid, fullCommand, arg.FullString);
            }
            else
            {
                Log("commands", "ServerCommand", fullCommand, arg.FullString);
            }
        }
#endif

        private void OnUserCommand(IPlayer player, string command, string[] args)
        {
            if (config.CommandListType.ToLower() == "blacklist" && config.CommandList.Contains(command) || config.CommandList.Contains("/" + command))
            {
                return;
            }

            if (config.CommandListType.ToLower() == "whitelist" && !config.CommandList.Contains(command) && !config.CommandList.Contains("/" + command))
            {
                return;
            }

            Log("commands", "PlayerCommand", player.Name, player.Id, command, string.Join(" ", args));
        }

        // TODO: Add command logged message in player's console/chat?
        // TODO: Prompt for reason within X seconds when command is used?

        #endregion Logging

        #region Command

        private void ReasonCommand(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permReason))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            Log("reasons", "Reason");
            Message(player, "ReasonLogged", string.Join(" ", args));
        }

        #endregion Command

        #region Helpers

        private string Lang(string key, string id = null, params object[] args)
        {
            return string.Format(lang.GetMessage(key, this, id), args);
        }

        private void AddLocalizedCommand(string key, string command)
        {
            foreach (string language in lang.GetLanguages(this))
            {
                Dictionary<string, string> messages = lang.GetMessages(language, this);
                foreach (KeyValuePair<string, string> message in messages.Where(m => m.Key.Equals(key)))
                {
                    if (!string.IsNullOrEmpty(message.Value))
                    {
                        AddCovalenceCommand(message.Value, command);
                    }
                }
            }
        }

        private void Log(string filename, string key, params object[] args)
        {
            if (config.LogToConsole)
            {
                Puts(Lang(key, null, args));
            }
            LogToFile(filename, $"[{DateTime.Now}] {Lang(key, null, args)}", this);
        }

        private void Message(IPlayer player, string key, params object[] args)
        {
            player.Reply(Lang(key, player.Id, args));
        }

        #endregion Helpers
    }
}


// --- End of file: Logger.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/RandomWrappedGift.cs ---
// --- Original Local Path: KualaRust/RandomWrappedGift.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;
using Random = System.Random;

namespace Oxide.Plugins
{
    [Info("Random Wrapped Gift", "Ryz0r", "1.1.1")]
    [Description("Enables players with permission to receive a randomly wrapped gift in a configured interval.")]
    public class RandomWrappedGift : RustPlugin
    {
        private const string GifteePerm = "randomwrappedgift.giftee";
        private const string GifterPerm = "randomwrappedgift.gifter";
        public string EffectToUse = "assets/prefabs/misc/easter/painted eggs/effects/gold_open.prefab";
        private Random random = new Random();
        
        #region Config/Lang
        private Configuration _config;
        protected override void SaveConfig() => Config.WriteObject(_config);
        protected override void LoadDefaultConfig() => _config = new Configuration();

        private class Configuration
        {
            [JsonProperty(PropertyName = "Gift Items (Item Shortname)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> GiftItems = new Dictionary<string, int>
            {
                {"rifle.ak", 1},
                {"stones", 1500}
            };

            [JsonProperty(PropertyName = "Wrapped Gift Interval (Seconds)")]
            public float WrappedGiftInterval = 300f;

            [JsonProperty(PropertyName = "Play Effect When Opened?")]
            public bool EffectWhenOpened = true;
            
            [JsonProperty(PropertyName = "Give gift to sleepers with permissions?")]
            public bool GiftToSleepers = false;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoPerm"] = "You do not have permissions to use this command.",
                ["Given"] = "You have given players gifts. Yay!",
                ["Gifted"] = "You have received a randomly wrapped gift. Enjoy!"
            }, this); 
        }
        #endregion
        
        private void CreateGift(BasePlayer bp)
        {
            var theItem = _config.GiftItems.ElementAt(random.Next(0, _config.GiftItems.Count));
            var createdItem = ItemManager.CreateByName(theItem.Key);
            
            var soonWrapped = ItemManager.CreateByItemID(204970153, 1);
            
            soonWrapped.contents.AddItem(createdItem.info, theItem.Value);
            bp.GiveItem(soonWrapped);
            bp.ChatMessage(lang.GetMessage("Gifted", this, bp.UserIDString));

            if (_config.EffectWhenOpened)
            {
                EffectNetwork.Send(new Effect(EffectToUse, bp.GetNetworkPosition(), Vector3.zero), bp.net.connection);
            }
        }
        
        
        private void Init()
        {
            AddCovalenceCommand("give", nameof(GiveGiftCommand));
            permission.RegisterPermission(GifteePerm, this);
            permission.RegisterPermission(GifterPerm, this);
        }

        private void OnServerInitialized()
        {
            GiveGifts();
            timer.Every(_config.WrappedGiftInterval, GiveGifts);
        }

        private void GiveGifts()
        {
            if (_config.GiftToSleepers)
            {
                foreach (var p in BasePlayer.allPlayerList)
                {
                    if (permission.UserHasPermission(p.UserIDString, GifteePerm))
                    {
                        CreateGift(p);
                    }
                }
            }
            else
            {
                foreach (var p in BasePlayer.activePlayerList)
                {
                    if (permission.UserHasPermission(p.UserIDString, GifteePerm))
                    {
                        CreateGift(p);
                    }
                }
            }
        }

        private void GiveGiftCommand(IPlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.Id, GifterPerm))
            {
                player.Reply(lang.GetMessage("NoPerm", this, player.Id));
                return;
            }
            
            player.Reply(lang.GetMessage("Given", this, player.Id));
            GiveGifts();
        }
    }
}

// --- End of file: RandomWrappedGift.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/ZetaQuest.cs ---
// --- Original Local Path: KualaRust/ZetaQuest.cs ---

﻿using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using System;
using Random = UnityEngine.Random;
using Rust;

namespace Oxide.Plugins
{
    [Info("ZetaQuest", "fermenspwnz", "0.1.0")]
    [Description("Достали кактусы...")]
    class ZetaQuest : RustPlugin
    {
        #region Plugins
        Plugin Kits => Interface.Oxide.RootPluginManager.GetPlugin("Kits");
        Plugin XKits => Interface.Oxide.RootPluginManager.GetPlugin("XKits");
        Plugin ImageLibrary => Interface.Oxide.RootPluginManager.GetPlugin("ImageLibrary");
        public string GetImage(string shortname, ulong skin = 0) => (string)ImageLibrary.Call("GetImage", shortname, skin);
        public bool AddImage(string url, string shortname, ulong skin = 0) => (bool)ImageLibrary?.Call("AddImage", url, shortname, skin);
        #endregion

        BaseEntity scientist;
        BaseEntity bandit;
        BaseEntity chair;

        private List<ulong> _page = new List<ulong>();
        private List<ulong> _page2 = new List<ulong>();
        private Dictionary<string, baseplayer> currentquests = new Dictionary<string, baseplayer>();
        class baseplayer
        {
            public bool refresh = false;
            public List<string> listquests = new List<string>();
            public Dictionary<string, currentquest> quests = new Dictionary<string, currentquest>();
        }

        class currentquest
        {
            public int count = 0;
            public bool finish = false;
        }

        private ItemDefinition FindItem(string itemNameOrId)
        {
            ItemDefinition itemDef = ItemManager.FindItemDefinition(itemNameOrId.ToLower());
            if (itemDef == null)
            {
                int itemId;
                if (int.TryParse(itemNameOrId, out itemId))
                {
                    itemDef = ItemManager.FindItemDefinition(itemId);
                }
            }
            return itemDef;
        }

        private void ItemSpawner(Item item, Vector3 dropPosition)
        {
            ItemContainer container = new ItemContainer();
            container.Insert(item);
            DropUtil.DropItems(container, dropPosition);
        }

        void God(BasePlayer player)
        {
            player._maxHealth = float.MaxValue;
            player.health = float.MaxValue;
            player.metabolism.bleeding.max = 0;
            player.metabolism.bleeding.value = 0;
            player.metabolism.calories.min = 500;
            player.metabolism.calories.value = 500;
            player.metabolism.dirtyness.max = 0;
            player.metabolism.dirtyness.value = 0;
            player.metabolism.heartrate.min = 0.5f;
            player.metabolism.heartrate.max = 0.5f;
            player.metabolism.heartrate.value = 0.5f;
            player.metabolism.hydration.min = 250;
            player.metabolism.hydration.value = 250;
            player.metabolism.oxygen.min = 1;
            player.metabolism.oxygen.value = 1;
            player.metabolism.poison.max = 0;
            player.metabolism.poison.value = 0;
            player.metabolism.radiation_level.max = 0;
            player.metabolism.radiation_level.value = 0;
            player.metabolism.radiation_poison.max = 0;
            player.metabolism.radiation_poison.value = 0;
            player.metabolism.temperature.min = 32;
            player.metabolism.temperature.max = 32;
            player.metabolism.temperature.value = 32;
            player.metabolism.wetness.max = 0;
            player.metabolism.wetness.value = 0;
            player.metabolism.SendChangesToClient();
        }

        private bool IsNPC(BasePlayer player)
        {
            if (player is NPCPlayer) return true;
            if (!(player.userID >= 76560000000000000L || player.userID <= 0L)) return true;
            return false;
        }

        const string MainNpcName = "Тех.Админ";
        private void OnEntityEnter(TriggerBase trigger, BaseEntity entity)
        {
            if (trigger == null) return;
            if (trigger.name == "QuestNPC")
            {
                BasePlayer player = entity.ToPlayer();
                if (player == null || IsNPC(player)) return;
                if (!_page.Contains(player.userID)) player.SendConsoleCommand("quest.open");
            }
            else if (trigger.name == "Pepa")
            {
                BasePlayer player = entity.ToPlayer();
                if (player == null || IsNPC(player)) return;
                if (!_page2.Contains(player.userID))
                {
                    player.SendConsoleCommand("quest.bandit");
                    _page2.Add(player.userID);
                }
            }
        }

        private void OnEntityLeave(TriggerBase trigger, BaseEntity entity)
        {
            if (trigger == null) return;
            if (trigger.name == "QuestNPC")
            {
                BasePlayer player = entity.ToPlayer();
                if (player == null || IsNPC(player)) return;
                if (_page.Contains(player.userID)) player.SendConsoleCommand("quest.exit");
            }
            else if (trigger.name == "Pepa")
            {
                BasePlayer player = entity.ToPlayer();
                if (player == null || IsNPC(player)) return;
                if (_page2.Contains(player.userID)) _page2.Remove(player.userID);
            }
        }
        List<GameObject> gameObjects = new List<GameObject>();

        private void SpawnScientist()
        {
            foreach (var z in BasePlayer.sleepingPlayerList.Where(x => IsNPC(x) && x.displayName.Equals(MainNpcName))) z.Kill();
            scientist = GameManager.server.CreateEntity("assets/prefabs/player/player.prefab", compound.transform.position + new Vector3(compound.transform.forward.x * 10f, 0.3f, compound.transform.forward.z * 8f), compound.transform.rotation, true);
            if (scientist != null)
            {
                scientist.enableSaving = false;
                scientist.Spawn();
                BasePlayer player = scientist.GetComponent<BasePlayer>();
                player.displayName = MainNpcName;
                player._name = MainNpcName;
                God(player);
                player.SendNetworkUpdateImmediate();
                Kits?.Call("GiveKit", player, "bot", true);
                Kits?.Call("GiveKit", player, "bot", 0, true);
                XKits?.Call("GiveKit", player, "bot", true);
                GameObject sphere = GameObject.CreatePrimitive(PrimitiveType.Sphere);
                sphere.transform.position = player.transform.position;
                TriggerBase trigger = sphere.GetComponent<TriggerBase>() ?? sphere.gameObject.AddComponent<TriggerBase>();
                trigger.interestLayers = LayerMask.GetMask("Player (Server)");
                trigger.enabled = true;
                sphere.layer = (int)Layer.Reserved1;
                sphere.name = "QuestNPC";
                SphereCollider sphereCollider = sphere.GetComponent<SphereCollider>();
                sphereCollider.radius = 3f;
                sphereCollider.isTrigger = true;
                sphereCollider.enabled = true;
                gameObjects.Add(sphere);
            }

            bandit = GameManager.server.CreateEntity("assets/prefabs/player/player.prefab", bandit_town.transform.position);
            if (bandit != null)
            {
                bandit.enableSaving = false;
                bandit.Spawn();
                BasePlayer player = bandit.GetComponent<BasePlayer>();
                player.displayName = "Авдос";
                player._name = "Авдос";
                God(player);
                player.SendNetworkUpdateImmediate();
                Kits?.Call("GiveKit", player, "bot", true);
                Kits?.Call("GiveKit", player, "bot", 0, true);
                XKits?.Call("GiveKit", player, "bot", true);
                Vector3 pos2 = bandit_town.transform.position + new Vector3(bandit_town.transform.forward.x * -19f, 1.8f, bandit_town.transform.forward.z * -22f);
                chair = GameManager.server.CreateEntity("assets/bundled/prefabs/static/chair.static.prefab", pos2);
                chair.enableSaving = false;
                chair.transform.localEulerAngles = bandit_town.transform.eulerAngles + new Vector3(0f, 45f);
                chair.Spawn();
                chair.GetComponent<BaseMountable>().MountPlayer(player);
                GameObject sphere = GameObject.CreatePrimitive(PrimitiveType.Sphere);
                sphere.transform.position = pos2;
                TriggerBase trigger = sphere.GetComponent<TriggerBase>() ?? sphere.gameObject.AddComponent<TriggerBase>();
                trigger.interestLayers = LayerMask.GetMask("Player (Server)");
                trigger.enabled = true;
                sphere.layer = (int)Layer.Reserved1;
                sphere.name = "Pepa";
                SphereCollider sphereCollider = sphere.GetComponent<SphereCollider>();
                sphereCollider.radius = 2f;
                sphereCollider.isTrigger = true;
                sphereCollider.enabled = true;
                gameObjects.Add(sphere);
            }
        }

        void agclose(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            DestroyUI(player);
        }

        void agcloseinfo(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            CuiHelper.DestroyUi(player, "questglobal");
        }

        void agopen(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            MenuLeftUI(player);
        }

        void agopeninfo(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null || !_page.Contains(player.userID)) return;
            GUIGlobal(player);
        }

        private bool TryGetPlayerView(BasePlayer player, out Quaternion viewAngle)
        {
            viewAngle = new Quaternion(0f, 0f, 0f, 0f);
            if (player.serverInput?.current == null) return false;
            viewAngle = Quaternion.Euler(player.serverInput.current.aimAngles);
            return true;
        }

        void revokeitem(PlayerInventory inv, string name, int amount)
        {
            List<Item> source2 = inv.FindItemIDs(FindItem(name).itemid).ToList();
            int num6 = 0;
            foreach (Item obj2 in source2)
            {
                int split_Amount = Mathf.Min(amount - num6, obj2.amount);
                (obj2.amount > split_Amount ? obj2.SplitItem(split_Amount) : obj2).DoRemove();
                num6 += split_Amount;
                if (num6 >= amount) break;
            }
        }

        #region questprogress
        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null || info == null) return;
            BasePlayer attacker = info.InitiatorPlayer;
            if (entity is BaseHelicopter)
            {
                List<BaseCombatEntity> Keys = LastHeliHit.Keys.ToList();
                if (Keys.Contains(entity))
                {
                    BasePlayer player = BasePlayer.FindByID(LastHeliHit[entity]);
                    if (player != null) ProgressQuest(player, typequest.helicopter, 1);
                    LastHeliHit.Remove(entity);
                }
            }
            if (attacker != null)
            {
                if (entity is Wolf)
                {
                    ProgressQuest(attacker, typequest.wolf, 1);
                }
                else if (entity is Bear)
                {
                    ProgressQuest(attacker, typequest.bear, 1);
                }
                else if (entity is BradleyAPC)
                {
                    ProgressQuest(attacker, typequest.tank, 1);
                }
                else if (entity is ScientistNPC)
                {
                    if (entity.name.Equals("assets/rust.ai/agents/npcplayer/humannpc/heavyscientist/heavyscientist.prefab")) ProgressQuest(attacker, typequest.heavynpc, 1);
                }
            }
        }

        void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            BasePlayer player = entity?.ToPlayer();
            if (player != null)
            {
                if (item.info.shortname.Equals("wood")) ProgressQuest(player, typequest.wood, item.amount);
                if (item.info.shortname.Equals("stones")) ProgressQuest(player, typequest.stones, item.amount);
            }
        }

        void OnCollectiblePickup(Item item, BasePlayer player)
        {
            if (player != null)
            {
                if (item.info.shortname.Equals("mushroom"))
                {
                    string user = player.UserIDString;
                    check(user);
                    if (currentquests[user].quests.Count(x => quests[x.Key].type == typequest.spoiledapple && !x.Value.finish) == 0) return;
                    float rand = Random.Range(0, 1f);
                    if (rand < 0.2f)
                    {
                        giveitem(player, "apple.spoiled", 1);
                    }
                }
                else if (item.info.shortname.Equals("wood")) ProgressQuest(player, typequest.wood, item.amount);
                else if (item.info.shortname.Equals("stones")) ProgressQuest(player, typequest.stones, item.amount);
            }
        }

        void OnItemCraftFinished(ItemCraftTask task, Item item)
        {
            var player = task.owner;
            if (player != null)
            {
                if (item.info.shortname.Equals("autoturret") || item.info.shortname.Equals("samsite") || item.info.shortname.Equals("guntrap") || item.info.shortname.Equals("flameturret")) ProgressQuest(player, typequest.craftturel, item.amount);
            }
        }

        void ProgressQuest(BasePlayer player, typequest typer, int count)
        {
            string user = player.UserIDString;
            check(user);
            if (currentquests[user].quests.Count(x => quests[x.Key].type == typer && !x.Value.finish) == 0) return;
            List<string> keys = currentquests[user].quests.Keys.Where(x => quests[x].type == typer && currentquests[user].quests[x].count < quests[x].count).ToList();
            foreach (var z in keys)
            {
                currentquests[user].quests[z].count += count;
                if (currentquests[user].quests[z].count >= quests[z].count)
                {
                    GuiInfo(player, $"Задание ⟪{z}⟫ выполнено!\nЗаберите награду в городе.");
                    currentquests[user].quests[z].count = quests[z].count;
                }
                else if (typer.Equals(typequest.online))
                {
                    if (onlinetimer.ContainsKey(player.UserIDString))
                    {
                        Timer ss = onlinetimer[player.UserIDString];
                        timer.Destroy(ref ss);
                        onlinetimer.Remove(player.UserIDString);
                    }
                    onlinetimer.Add(player.UserIDString, timer.Once(60, () => ProgressQuest(player, typequest.online, 1)));
                }
            }
        }
        #endregion

        #region guiinfo
        const string GUIINFO = "[{\"name\":\"MiddlePanelquest\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.00 0.00 0.50 0.2\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.6\",\"anchormax\":\"1 .7\"}]},{\"name\":\"1c685dcb8da54498a6531a1f8c74ab27\",\"parent\":\"MiddlePanelquest\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.3 0.3 0.3 0.95\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\"}]},{\"name\":\"5ce694cf4a684bc89633e2ad1c3a2f0b\",\"parent\":\"MiddlePanelquest\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{text}\",\"fontSize\":20,\"align\":\"MiddleCenter\",\"color\":\"1 1 1 0.5\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 1\",\"distance\":\"0.6 0.6\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.05 0\",\"anchormax\":\"0.95 1\"}]}]";
        Dictionary<string, Timer> timers = new Dictionary<string, Timer>();
        void GuiInfo(BasePlayer player, string text, float time = 3f)
        {
            Effect.server.Run("assets/bundled/prefabs/fx/notice/loot.drag.grab.fx.prefab", player.transform.position);
            Timer ss;
            if (timers.TryGetValue(player.UserIDString, out ss)) ss?.Destroy();
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "MiddlePanelquest");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", GUIINFO.Replace("{text}", text));
            timers[player.UserIDString] = timer.Once(time, () => CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "MiddlePanelquest"));
        }
        #endregion

        private Dictionary<BaseCombatEntity, ulong> LastHeliHit = new Dictionary<BaseCombatEntity, ulong>();
        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null) return;
            if (entity is BaseHelicopter && info.Initiator is BasePlayer)
            {
                LastHeliHit[entity] = info.InitiatorPlayer.userID;
            }
        }


        private void DestroyUI(BasePlayer player)
        {
            if (_page.Contains(player.userID)) _page.Remove(player.userID);
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "questglobal");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "questmainui");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "questui");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "MiddlePanelquest");
        }

        enum typequest
        {
            wolf, wood, bot1, heavynpc, stones, cookedfish, spoiledapple, bear, craftturel, online, helicopter, tank
        }

        class quest
        {
            public typequest type;
            public int count;
            public string description;
            public List<items> rewards;
        }

        class items
        {
            public string name;
            public int count;
            public string command;
            public string image;
        }

        Dictionary<string, quest> quests = new Dictionary<string, quest>();
        void check(string user)
        {
            if (!currentquests.ContainsKey(user)) currentquests.Add(user, new baseplayer());
        }
        Dictionary<string, Timer> onlinetimer = new Dictionary<string, Timer>();
        void agquest(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null || !arg.HasArgs()) return;
            check(player.UserIDString);
            string name = string.Join(" ", arg.Args.Skip(0));
            if (!quests.ContainsKey(name))
            {
                GuiInfo(player, "Задание не найдено!");
                return;
            }
            if (currentquests[player.UserIDString].quests.Count() >= 5)
            {
                GuiInfo(player, "В день можно выполнить только 5 заданий.");
                return;
            }
            if (player.Distance(scientist) > 2f)
            {
                GuiInfo(player, $"Взять задание можно у {scientist.ToPlayer().displayName}а в мирном городе!");
                return;
            }
            if (currentquests[player.UserIDString].quests.ContainsKey(name))
            {
                GuiInfo(player, "Вы уже выполняете это задание!");
                return;
            }
            if (quests[name].type == typequest.bot1)
            {
                giveitem(player, "blood", 3);
            }
            if (quests[name].type == typequest.online)
            {
                if (onlinetimer.ContainsKey(player.UserIDString))
                {
                    Timer ss = onlinetimer[player.UserIDString];
                    timer.Destroy(ref ss);
                    onlinetimer.Remove(player.UserIDString);
                }

                onlinetimer.Add(player.UserIDString, timer.Once(60, () => ProgressQuest(player, typequest.online, 1)));
            }
            currentquests[player.UserIDString].quests.Add(name, new currentquest());
            MenuLeftUI(player);
            if (quests[name].type == typequest.cookedfish || quests[name].type == typequest.spoiledapple) currentquests[player.UserIDString].quests[name].count = quests[name].count;
        }

        bool haveinventory(PlayerInventory inv, string name, int count, string desc = null)
        {
            List<Item> source2 = new List<Item>();
            if (FindItem(name) != null) source2 = inv.FindItemIDs(FindItem(name).itemid).ToList();
            if (source2.Count > 0)
            {
                int num3 = source2.Sum<Item>((Func<Item, int>)(x => x.amount));
                if (num3 >= count) return true;
            }
            return false;
        }

        void agquestbandit(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null || arg.HasArgs()) return;
            check(player.UserIDString);
            string name = quests.Where(x => x.Value.type == typequest.bot1).FirstOrDefault().Key;
            if (player.Distance(bandit) > 2f) return;

            if (!currentquests[player.UserIDString].quests.ContainsKey(name) || currentquests[player.UserIDString].quests[name].count >= quests[name].count)
            {
                List<string> messages = new List<string>
                {
                "власть, заставляющая уважать себя на законодательном уровне, только за одно это заслуживает всего лишь презрение.",
                "актеры в советских фильмах с каждым годом играют все лучше.",
                "любой червяк может попасть в яблочко!",
                "я готовлю хреново, зато как наливаю!",
                "нa cxoдкe в Maгaданe виpyc был pacкopoнoвaн.",
                "иногда бывает так плохо, что не знаешь: или 03 набрать, или 0,5 открыть…",
                "сейчас проблема не в том, что мы пользуемся говном китайского производства, а в том, что сами и такого не производим.",
                "мой друг любит кофе, я предпочитаю чай, поэтому, когда мы встречаемся, то пьем водку.",
                "верующих много. Одни верят в Бога. Другие – в деньги. Знающих мало."
                };
                GuiInfo(player, "Авдос: " + messages[Random.Range(0, messages.Count())], 4f);
                return;
            }

            if (!haveinventory(player.inventory, "antiradpills", 1))
            {
                GuiInfo(player, "Авдос: " + "без пилюлей мне не о чем с тобой разговарить!", 3f);
                return;
            }

            if (!haveinventory(player.inventory, "blood", 3))
            {
                GuiInfo(player, "Авдос: " + "где кровь то?", 3f);
                return;
            }
            revokeitem(player.inventory, "blood", 3);
            revokeitem(player.inventory, "antiradpills", 1);
            ProgressQuest(player, typequest.bot1, 1);
        }

        void agquestrefresh(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null || !arg.HasArgs() || arg.Args.Length != 1) return;
            int INT;
            bool isint = int.TryParse(arg.Args[0], out INT);
            if (!isint) return;

            check(player.UserIDString);

            if (!currentquests[player.UserIDString].refresh)
            {
                if (currentquests[player.UserIDString].quests.Count() > 0 && !player.IsAdmin)
                {
                    GuiInfo(player, "Нельзя обновить задания, если у вас есть активные задания или выполненые!");
                    return;
                }
                if (!haveinventory(player.inventory, "apple", 10))
                {
                    GuiInfo(player, "Для обновления заданий нужно 10 яблок!");
                    return;
                }
                revokeitem(player.inventory, "apple", 10);
            }
            if (INT == 1) refreshlist(player.UserIDString);
            currentquests[player.UserIDString].refresh = false;
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "MiddlePanelquest");
            MenuLeftUI(player);
            if (INT == 1) if (!currentquests[player.UserIDString].refresh) GuiInfo(player, "Задания обновлены!");
        }

        void refreshlist(string user)
        {
            List<string> list = quests.Keys.ToList();
            List<string> list2 = new List<string>();
            for (int i = 0; i < 6; i++)
            {
                if (list.Count() == 0) break;
                int rand = Random.Range(0, list.Count());
                list2.Add(list[rand]);
                list.Remove(list[rand]);
            }
            currentquests[user].quests.Clear();
            currentquests[user].listquests = list2;
        }
        void agquestend(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null || !arg.HasArgs()) return;
            check(player.UserIDString);
            string name = string.Join(" ", arg.Args.Skip(0));
            if (!quests.ContainsKey(name))
            {
                GuiInfo(player, "Задание не найдено!");
                return;
            }
            if (!currentquests[player.UserIDString].quests.ContainsKey(name))
            {
                GuiInfo(player, "У вас нет такого задания!");
                return;
            }
            if (currentquests[player.UserIDString].quests[name].count < quests[name].count)
            {
                GuiInfo(player, "Задание не выполнено!");
                return;
            }
            if (Vector3.Distance(player.transform.position, scientist.transform.position) > 2f)
            {
                GuiInfo(player, $"Награду нужно забрать у {scientist.ToPlayer().displayName}а!");
                return;
            }
            if (currentquests[player.UserIDString].quests[name].finish)
            {
                GuiInfo(player, "Вы уже получили награду за это задание!");
                return;
            }
            if (quests[name].type == typequest.wood && !haveinventory(player.inventory, "wood", quests[name].count))
            {
                GuiInfo(player, "А где дерево? Нарубить - нарубил, а принести забыл...");
                return;
            }
            if (quests[name].type == typequest.stones && !haveinventory(player.inventory, "stones", quests[name].count))
            {
                GuiInfo(player, "А где камень? Добыть - добыл, а принести забыл...");
                return;
            }
            if (quests[name].type == typequest.cookedfish && !haveinventory(player.inventory, "fish.cooked", quests[name].count))
            {
                GuiInfo(player, "Ну и где же мой завтрак?");
                return;
            }
            if (quests[name].type == typequest.cookedfish && !haveinventory(player.inventory, "fish.cooked", quests[name].count))
            {
                GuiInfo(player, "Ну и где же мой завтрак?");
                return;
            }
            if (quests[name].type == typequest.spoiledapple && !haveinventory(player.inventory, "fertilizer", quests[name].count))
            {
                GuiInfo(player, "Принеси мне мое удобрение!");
                return;
            }

            if (quests[name].type == typequest.wood) revokeitem(player.inventory, "wood", quests[name].count);
            else if (quests[name].type == typequest.stones) revokeitem(player.inventory, "stones", quests[name].count);
            else if (quests[name].type == typequest.cookedfish) revokeitem(player.inventory, "fish.cooked", quests[name].count);
            else if (quests[name].type == typequest.spoiledapple) revokeitem(player.inventory, "fertilizer", quests[name].count);

            foreach (var z in quests[name].rewards)
            {
                if (z.command == null)
                {
                    giveitem(player, z.name, z.count);
                }
                else
                {
                    Server.Command(z.command.Replace("{steamid}", player.UserIDString));
                }
            }
            currentquests[player.UserIDString].quests[name].finish = true;
            MenuLeftUI(player);
            LogIt($"[{DateTime.Now.ToShortDateString()}] Выполнил задание - {player.displayName} ({player.UserIDString}) - {name}");
            if (quests[name].type == typequest.spoiledapple) GuiInfo(player, "Спасибо, с этим удобрением процессы мутации ускорились, как минимум на десять суток! Награда получена.", 3f);
            else GuiInfo(player, "Награда получена.", 2f);
        }

        void LogIt(string text)
        {
            logs.Add(text);
        }

        void giveitem(BasePlayer player, string name, int amount)
        {
            Item item = ItemManager.Create(FindItem(name));
            item.amount = amount;
            player.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);
        }

        void agquestremove(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null || !arg.HasArgs()) return;
            check(player.UserIDString);
            string name = string.Join(" ", arg.Args.Skip(0));
            if (!quests.ContainsKey(name))
            {
                GuiInfo(player, "Задание не найдено!");
                return;
            }
            if (Vector3.Distance(player.transform.position, scientist.transform.position) > 2f)
            {
                GuiInfo(player, $"Отменить задание можно у {scientist.ToPlayer().displayName}а!");
                return;
            }
            if (!currentquests[player.UserIDString].quests.ContainsKey(name))
            {
                GuiInfo(player, "У вас нет такого задания!");
                return;
            }
            if (quests[name].type == typequest.bot1 && !haveinventory(player.inventory, "blood", 3))
            {
                GuiInfo(player, "Это задание нельзя отменить без предметов которые вам дали для выполнения его!");
                return;
            }
            if (quests[name].type == typequest.bot1)
            {
                revokeitem(player.inventory, "blood", 3);
            }
            currentquests[player.UserIDString].quests.Remove(name);
            MenuLeftUI(player);
        }

        #region GUI
        const string GLOBALGUI = "[{\"name\":\"questglobal\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.1 0.1 0.1 0.98\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\"}]}{main},{\"name\":\"ea83ada0eb804d15a57f1da9d9960136\",\"parent\":\"questglobal\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"quest.infoexit\",\"material\":\"assets/content/ui/uibackgroundblur-ingamemenu.mat\",\"color\":\"0 0 0 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\"}]}]";
        const string GLOBALMAIN = ",{\"name\":\"50dd878184b2434abd8f5a695393426c\",\"parent\":\"questglobal\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.3 0.3 0.3 0.9\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.35 {end}\",\"anchormax\":\"0.7 {start}\"}]},{\"name\":\"4d1209178ec244e6a1c09421e4401856\",\"parent\":\"questglobal\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.3 0.6 0.3 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.35 {end}\",\"anchormax\":\"{xmax} {start}\"}]},{\"name\":\"600b5e0444304a62a7711f74c59802f5\",\"parent\":\"questglobal\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{key}\",\"fontSize\":16,\"align\":\"MiddleLeft\",\"color\":\"1 1 1 0.5\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 1\",\"distance\":\"0.6 0.6\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.36 {end}\",\"anchormax\":\"0.7 {start}\"}]},{\"name\":\"6987ef1611f64b8fa4be65331d711cd5\",\"parent\":\"questglobal\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{count}\",\"fontSize\":16,\"align\":\"MiddleRight\",\"color\":\"1 1 1 0.5\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 1\",\"distance\":\"0.6 0.6\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.36 {end}\",\"anchormax\":\"0.69 {start}\"}]}";
        const string GLOBALNOMAIN = ",{\"name\":\"bb6154fe410c47f990078f31371ae657\",\"parent\":\"questglobal\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"У вас нет активных заданий\",\"fontSize\":16,\"align\":\"MiddleCenter\",\"color\":\"1 1 1 0.5\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 1\",\"distance\":\"0.6 0.6\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.4 0.55\",\"anchormax\":\"0.6 0.65\"}]}";
        private void GUIGlobal(BasePlayer player)
        {
            check(player.UserIDString);
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "questglobal");
            string GUI = "";
            float start = 0.7f;
            float end = 0f;
            if (currentquests[player.UserIDString].quests.Count > 0)
            {
                foreach (var z in currentquests[player.UserIDString].quests.Where(x => !x.Value.finish))
                {
                    end = start - 0.05f;
                    GUI += GLOBALMAIN.Replace("{count}", $"{z.Value.count}/{quests[z.Key].count}").Replace("{end}", end.ToString()).Replace("{key}", z.Key).Replace("{xmax}", (0.35f + z.Value.count * 1f / quests[z.Key].count * 0.35f).ToString()).Replace("{start}", start.ToString());
                    start -= start - end + 0.005f;
                }
            }
            else GUI += GLOBALNOMAIN;
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", GLOBALGUI.Replace("{main}", GUI));
        }

        const string MAINGUI = "[{\"name\":\"questui\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.005 0.005 0.005 0.99\",\"fadeIn\":0.5},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\"},{\"type\":\"NeedsCursor\"}]},{\"name\":\"961b572ae9bd47678cb0a9d23ea44fd2\",\"parent\":\"questui\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"quest.refresh 1\",\"material\":\"assets/content/ui/uibackgroundblur-ingamemenu.mat\",\"color\":\"1.00 0.00 0.50 0.20\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.27 0.02\",\"anchormax\":\"0.42 0.07\"}]},{\"parent\":\"961b572ae9bd47678cb0a9d23ea44fd2\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"Обновить задания\",\"fontSize\":16,\"align\":\"MiddleCenter\"},{\"type\":\"RectTransform\"}]},{\"name\":\"2471f5bee84246e4904e8f0eb8ab9236\",\"parent\":\"questui\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"quest.info\",\"material\":\"assets/content/ui/uibackgroundblur-ingamemenu.mat\",\"color\":\"0.00 1.00 0.00 0.20\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.44 0.02\",\"anchormax\":\"0.64 0.07\"}]},{\"parent\":\"2471f5bee84246e4904e8f0eb8ab9236\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"Прогресс выполнения\",\"fontSize\":16,\"align\":\"MiddleCenter\"},{\"type\":\"RectTransform\"}]},{\"name\":\"ffe15c9be17b44a9830d55c4e0319d95\",\"parent\":\"questui\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"quest.exit\",\"material\":\"assets/content/ui/uibackgroundblur-ingamemenu.mat\",\"color\":\"1.00 0.00 0.00 0.20\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.66 0.02\",\"anchormax\":\"0.8 0.07\"}]},{\"parent\":\"ffe15c9be17b44a9830d55c4e0319d95\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"Выйти\",\"fontSize\":16,\"align\":\"MiddleCenter\"},{\"type\":\"RectTransform\"}]}]";
        private void MenuLeftUI(BasePlayer player, int type = 1, int next = 0)
        {
            check(player.UserIDString);
            if (currentquests[player.UserIDString].listquests.Count == 0)
            {
                refreshlist(player.UserIDString);
                timer.Once(0.1f, () => MenuLeftUI(player, type, next));
                return;
            }
            if (!_page.Contains(player.userID))
            {
                _page.Add(player.userID);
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "questui");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", MAINGUI);
            }

            var container = LMUI.CreateElementContainer("questmain", "0 0 0 0", "0 0.1", "1 1", false, "questui");
            float start = 0.98f;
            float xline = 0.1f;
            float end = 0f;
            int i = 0;
            foreach (var z in currentquests[player.UserIDString].listquests)
            {
                end = start - 0.29f * 1.1f;
                LMUI.CreatePanel(ref container, "questmain", "0.3 0.3 0.3 0.4", xline + " " + end, (xline + 0.38f) + " " + start);

                if (!currentquests[player.UserIDString].quests.ContainsKey(z)) LMUI.CreateButton(ref container, "questmain", "1.00 0.50 0.00 0.20", "Выполнить", 16, (xline + 0.3f) + " " + (start - 0.05f), (xline + 0.38f) + " " + (start - 0.01f), "quest.take " + z);
                else if (currentquests[player.UserIDString].quests.ContainsKey(z) && !currentquests[player.UserIDString].quests[z].finish && currentquests[player.UserIDString].quests[z].count < quests[z].count) LMUI.CreateButton(ref container, "questmain", "0.7 0.5 0.5 0.4", "Отказаться", 16, (xline + 0.3f) + " " + (start - 0.05f), (xline + 0.38f) + " " + (start - 0.01f), "quest.remove " + z);
                else if (currentquests[player.UserIDString].quests.ContainsKey(z) && !currentquests[player.UserIDString].quests[z].finish && currentquests[player.UserIDString].quests[z].count >= quests[z].count) LMUI.CreateButton(ref container, "questmain", "0.5 0.5 0.7 0.4", "Завершить задание", 16, (xline + 0.26f) + " " + (start - 0.05f), (xline + 0.38f) + " " + (start - 0.01f), "quest.end " + z);
                else LMUI.CreateButton(ref container, "questmain", "0.5 0.5 0.7 0.4", "Выполнено", 16, (xline + 0.3f) + " " + (start - 0.05f), (xline + 0.38f) + " " + (start - 0.01f), "");

                LMUI.CreateLabel(ref container, "questmain", "1 1 1 0.9", "<b>" + z + "</b>", 19, xline + " " + (start - 0.05f), (xline + 0.3f) + " " + (start - 0.01f), TextAnchor.MiddleCenter);
                LMUI.CreateLabel(ref container, "questmain", "1 1 1 0.5", quests[z].description, 13, (xline + 0.005f) + " " + (start - 0.15f), (xline + 0.375f) + " " + (start - 0.06f), TextAnchor.UpperLeft, "Robotocondensed-regular.ttf");
                LMUI.CreateLabel(ref container, "questmain", "1 1 1 0.5", "<color=#F0E68C>НАГРАДА ЗА ВЫПОЛНЕНИЕ ЗАДАНИЯ</color>", 13, (xline + 0.005f) + " " + (start - 0.18f), (xline + 0.375f) + " " + (start - 0.15f), TextAnchor.MiddleCenter, "Droidsansmono.ttf");

                float Xstart = 0.04f;
                float Xend = 0f;
                foreach (var x in quests[z].rewards)
                {
                    Xend = Xstart + 0.05f;
                    LMUI.CreatePanel(ref container, "questmain", "0.3 0.3 0.3 0.4", (xline + Xstart) + " " + (start - 0.28f), (xline + Xend) + " " + (start - 0.19f));
                    LMUI.LoadImage(ref container, "questmain", GetImage(x.command == null ? x.name : x.image), (xline + Xstart + 0.005f) + " " + (start - 0.27f), (xline + Xend - 0.005f) + " " + (start - 0.2f));
                    LMUI.CreateLabel(ref container, "questmain", "1 1 1 0.5", "x" + x.count, 14, (xline + Xstart) + " " + (start - 0.28f), (xline + Xend - 0.001f) + " " + (start - 0.19f), TextAnchor.LowerRight);
                    Xstart += Xend - Xstart + 0.01f;
                }

                if (i == 2)
                {
                    xline = 0.52f;
                    start = 0.98f;
                }
                else start -= start - end + 0.01f;
                i++;
            }
            CuiHelper.DestroyUi(player, "questmain");
            CuiHelper.AddUi(player, container);
            if (currentquests[player.UserIDString].refresh)
            {
                Effect.server.Run("assets/bundled/prefabs/fx/notice/loot.drag.grab.fx.prefab", player.transform.position);
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "MiddlePanelquest");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", REFRESHUI);
            }
        }

        const string REFRESHUI = "[{\"name\":\"MiddlePanelquest\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.1 0.1 0.1 0.98\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\"}]},{\"name\":\"db7b79d51fc348fe8f594c9270c06b28\",\"parent\":\"MiddlePanelquest\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.005 0.005 0.005 0.9\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\"}]},{\"name\":\"e8a1339c1c8849fa97ac73922190e28b\",\"parent\":\"MiddlePanelquest\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.3 0.3 0.3 0.9\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.55\",\"anchormax\":\"1 0.7\"}]},{\"name\":\"fa329e2eacc545f5a4c524272654748d\",\"parent\":\"MiddlePanelquest\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"Доступно обновление квестов, обновление сбросит прогресс текущих заданий, обновить?\",\"fontSize\":20,\"align\":\"MiddleCenter\",\"color\":\"1 1 1 0.5\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 1\",\"distance\":\"0.6 0.6\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.05 0.6\",\"anchormax\":\"0.95 0.7\"}]},{\"name\":\"81a491a92be54c4f86360124fb555204\",\"parent\":\"MiddlePanelquest\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"quest.refresh 1\",\"color\":\"0.3 0.7 0.3 0.8\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.4 0.57\",\"anchormax\":\"0.48 0.61\"}]},{\"parent\":\"81a491a92be54c4f86360124fb555204\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"Да\",\"fontSize\":20,\"align\":\"MiddleCenter\"},{\"type\":\"RectTransform\"}]},{\"name\":\"04a8e472463c47ff8a55ba274bc28428\",\"parent\":\"MiddlePanelquest\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"quest.refresh 0\",\"material\":\"assets/content/ui/uibackgroundblur-ingamemenu.mat\",\"color\":\"0.7 0.3 0.3 0.8\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.52 0.57\",\"anchormax\":\"0.6 0.61\"}]},{\"parent\":\"04a8e472463c47ff8a55ba274bc28428\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"Нет\",\"fontSize\":20,\"align\":\"MiddleCenter\"},{\"type\":\"RectTransform\"}]}]";
        #endregion

        private void Unload()
        {
            if (scientist != null) scientist.Kill();
            if (bandit != null) bandit.Kill();
            if (chair != null) chair.Kill();
            foreach (var z in gameObjects.ToList()) UnityEngine.GameObject.Destroy(z);
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = Network.Net.sv.connections }, null, "DestroyUI", "questmain");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = Network.Net.sv.connections }, null, "DestroyUI", "questglobal");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = Network.Net.sv.connections }, null, "DestroyUI", "questmainui");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = Network.Net.sv.connections }, null, "DestroyUI", "questui");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = Network.Net.sv.connections }, null, "DestroyUI", "MiddlePanelquest");
            SaveData();
            SaveQuests();
        }

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject("quest_players", currentquests);
        private void SaveQuests()
        {
            Interface.Oxide.DataFileSystem.WriteObject("quest_data", quests);
            Interface.Oxide.DataFileSystem.WriteObject("quest_logs", logs);
        }
        private void chatcommandquest(BasePlayer player, string cmd)
        {
            MenuLeftUI(player);
        }

        private void timernextday()
        {
            //86400 - DateTime.UtcNow.AddHours(3).Hour * 3600 - DateTime.UtcNow.Minute * 60 - DateTime.UtcNow.Second
            timer.Once(86400 - DateTime.UtcNow.AddHours(3).Hour * 3600 - DateTime.UtcNow.Minute * 60 - DateTime.UtcNow.Second, () =>
            {
                List<string> zk = currentquests.Keys.ToList();
                foreach (var z in zk)
                {
                    if (!currentquests[z].refresh) currentquests[z].refresh = true;
                }
                SaveData();
                timernextday();
            });
        }

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (onlinetimer.ContainsKey(player.UserIDString))
            {
                Timer ss = onlinetimer[player.UserIDString];
                timer.Destroy(ref ss);
                onlinetimer.Remove(player.UserIDString);
            }
        }

        void OnPlayerConnected(BasePlayer player)
        {
            ProgressQuest(player, typequest.online, 1);
        }

        static List<string> logs = new List<string>();
        private void OnServerInitialized()
        {
            LoadConfig();
            currentquests = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, baseplayer>>("quest_players");
            logs = Interface.Oxide.DataFileSystem.ReadObject<List<string>>("quest_logs");
            quests = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, quest>>("quest_data");

            if (quests.Count() == 0)
            {
                quests.Add("Скрывающийся оборотень", new quest { type = typequest.wolf, count = 5, rewards = new List<items>() { new items { name = "rifle.ak", count = 1 }, new items { name = "wood", count = 5000 }, new items { name = "wood", count = 5000 }, new items { name = "wood", count = 5000 }, new items { name = "wood", count = 5000 } }, description = "Так как вампиры появляются ночью, у них случаются столкновения с другими ночными существами, поэтому в городе стало неспокойно. Если хотите, вы можете восстановить былое спокойствие в городе. Если вы зажжете факел, найдете 5 волков и убьете, то в городе воцарится спокойствие." });
                quests.Add("Сбор ресурсов", new quest { type = typequest.wood, count = 10000, rewards = new List<items>() { new items { name = "rifle.ak", count = 1 }, new items { name = "wood", count = 5000 }, new items { name = "wood", count = 5000 }, new items { name = "wood", count = 5000 }, new items { name = "wood", count = 5000 } }, description = "Бедные фермеры... Да, конечно, они трусоваты. Но они ведь попросту не умеют сражаться, а им нужно заготавливать древесину для печек. Рейдеры нападают на них... все это просто ужасно! Но если мы хотим продержаться, нам нужна эта древесина. Отправляйся в лес, собери 10 тысяч древесины и доставь ее сюда." });
                quests.Add("Чума Отрекшихся", new quest { type = typequest.bot1, count = 1, rewards = new List<items>() { new items { name = "rifle.ak", count = 1 }, new items { name = "wood", count = 5000 }, new items { name = "wood", count = 5000 }, new items { name = "wood", count = 5000 }, new items { name = "wood", count = 5000 } }, description = "Так вот; отнеси эту штуку обратно в лагерь бандитов и отдай Пеппи Нетосопло. Она, конечно, не самый лучший алхимик, но другого у нас нет. Только учти – она очень любит противорадиационные таблетки, так что для начала загляни в магазинчик либо пошарься по помойкам. В общем, она знает, что делать с этой штукой." });
                quests.Add("Сбор ресурсов II", new quest { type = typequest.stones, count = 12500, rewards = new List<items>() { new items { name = "rifle.ak", count = 1 }, new items { name = "wood", count = 5000 }, new items { name = "wood", count = 5000 }, new items { name = "wood", count = 5000 }, new items { name = "wood", count = 5000 } }, description = "Для обеспечения и улучшения защиты города требуются новые ресурсы. Неподалёку от города обнаружены залежи камня. Соберите 12'500 камня и принесите его нам." });
                quests.Add("Древний фрагмент", new quest { type = typequest.heavynpc, count = 3, rewards = new List<items>() { new items { name = "rifle.ak", count = 1 }, new items { command = "ag.give {steamid} 1 Фрагмент для VIP", image = "https://gspics.org/images/2019/03/16/m5LsD.png", count = 1 }, new items { name = "wood", count = 5000 }, new items { name = "wood", count = 5000 } }, description = "У меня есть древний фрагмент, который перешёл ко мне от великого предка. Я мог бы поделится им  в обмен на услугу. Приплыви к нефтяной вышки и уничтожь 3-х тяжелых NPC. Не спрашивай зачем мне это нужно, просто выполни поручение." });
                quests.Add("Довольно грибов!", new quest { type = typequest.cookedfish, count = 5, rewards = new List<items>() { new items { name = "rifle.ak", count = 1 }, new items { command = "ag.give {steamid} 1 Фрагмент для VIP", image = "https://gspics.org/images/2019/03/16/m5LsD.png", count = 1 }, new items { name = "wood", count = 5000 }, new items { name = "wood", count = 5000 } }, description = "Грибной суп, жаркое из грибов, грибной соус... Грибы, грибы, грибы! Кроме грибов, есть тут вообще нечего! Так вот, меня это достало. Я знаю: тут, в озерах, водится рыба! Сколько ты потребуешь с меня за 5 приготовленных рыбин, чтобы я впервые за несколько недель мог нормально поесть?" });
            }

            if (quests.Count() < 12)
            {
                if (quests.ContainsKey("Эффективное удобрение")) quests.Remove("Эффективное удобрение");
                if (quests.ContainsKey("Месть Вайрины")) quests.Remove("Месть Вайрины");
                if (quests.ContainsKey("Легендарное орудие")) quests.Remove("Легендарное орудие");
                if (quests.ContainsKey("Время для наград")) quests.Remove("Время для наград");
                if (quests.ContainsKey("Тяжелая артиллерия")) quests.Remove("Тяжелая артиллерия");
                if (quests.ContainsKey("Важный груз")) quests.Remove("Важный груз");
                quests.Add("Эффективное удобрение", new quest { type = typequest.spoiledapple, count = 5, rewards = new List<items>() { new items { name = "rifle.ak", count = 1 }, new items { name = "wood", count = 5000 }, new items { name = "wood", count = 5000 } }, description = "Буквально несколько дней назад мои собратья грибники нашли отличные удобрения на грибных лужайках,  которые, на мой взгляд, идеально подойдут для ускорения мутации моих цветов. Принеси мне 5 гнилых яблок и тогда я тебя отблагодарю." });
                quests.Add("Месть Вайрины", new quest { type = typequest.bear, count = 1, rewards = new List<items>() { new items { name = "rifle.ak", count = 1 }, new items { name = "wood", count = 5000 }, new items { name = "wood", count = 5000 } }, description = "Год назад весь Приют странников охотился на огромного медведя, но ни одному смельчаку не посчастливилось его одолеть. Тогда Дерил решил выступить против зверя сам. Разумеется, он ничего не добился. Убей медведя, и не сомневаюсь, что даже Дерил ненадолго лишится дара речи." });
                quests.Add("Легендарное орудие", new quest { type = typequest.craftturel, count = 1, rewards = new List<items>() { new items { name = "rifle.ak", count = 1 }, new items { name = "wood", count = 5000 }, new items { name = "wood", count = 5000 } }, description = "Четыре  орудия... четыри великих пути. Скрафтить одно из этих орудий – первый шаг к победе над Рейдерами. Со временем мощь оружия в твоих руках будет расти, но тем временем тебе в этом будут помогать твои верные друзья. Если захочешь, позже сможешь раздобыть и три других. Но первое орудие важно раздобыть сейчас." });
                quests.Add("Время для наград", new quest { type = typequest.online, count = 60, rewards = new List<items>() { new items { name = "rifle.ak", count = 1 }, new items { name = "wood", count = 5000 }, new items { name = "wood", count = 5000 } }, description = "Тут все просто, просто проведи на сервере 1 час и получи в замен ништячки. " });
                quests.Add("Тяжелая артиллерия", new quest { type = typequest.tank, count = 1, rewards = new List<items>() { new items { name = "rifle.ak", count = 1 }, new items { name = "wood", count = 5000 }, new items { name = "wood", count = 5000 } }, description = "У меня дурные вести: у повстанцев появилась серьезная огневая мощь. Мы видели танк на космодроме, он патрулирует полностью всё РТ  и зачищает местность от выживших. Нельзя, чтобы это продолжалось! А может, дадим им попробовать свинца? Представляешь, какую бойню ты им тогда устроишь?" });
                quests.Add("Важный груз", new quest { type = typequest.helicopter, count = 1, rewards = new List<items>() { new items { name = "rifle.ak", count = 1 }, new items { name = "wood", count = 5000 }, new items { name = "wood", count = 5000 } }, description = "Все пропало! Мой вертолёт... его сперли! Я говорил капитанше, что с этим бесценным грузом нужно быть осторожнее, но разве она стала меня слушать?! О, нет! Груз не должен никому достаться, ты слышишь меня? НИКОМУ!!! Отправляйся в путь и уничтожь вертолет любой ценой. Возможно, это наша последняя надежда." });
            }

            foreach (var z in quests)
            {
                foreach (var x in z.Value.rewards)
                {
                    if (x.image != null) AddImage(x.image, x.image);
                    else GetImage(x.name);
                }
            }

            timernextday();
            Interface.Oxide.GetLibrary<Game.Rust.Libraries.Command>(null).AddConsoleCommand("quest.exit", this, "agclose");
            Interface.Oxide.GetLibrary<Game.Rust.Libraries.Command>(null).AddConsoleCommand("quest.open", this, "agopen");
            Interface.Oxide.GetLibrary<Game.Rust.Libraries.Command>(null).AddChatCommand("quest", this, "chatcommandquest");
            Interface.Oxide.GetLibrary<Game.Rust.Libraries.Command>(null).AddConsoleCommand("quest.take", this, "agquest");
            Interface.Oxide.GetLibrary<Game.Rust.Libraries.Command>(null).AddConsoleCommand("quest.info", this, "agopeninfo");
            Interface.Oxide.GetLibrary<Game.Rust.Libraries.Command>(null).AddConsoleCommand("quest.infoexit", this, "agcloseinfo");
            Interface.Oxide.GetLibrary<Game.Rust.Libraries.Command>(null).AddConsoleCommand("quest.remove", this, "agquestremove");
            Interface.Oxide.GetLibrary<Game.Rust.Libraries.Command>(null).AddConsoleCommand("quest.end", this, "agquestend");
            Interface.Oxide.GetLibrary<Game.Rust.Libraries.Command>(null).AddConsoleCommand("quest.bandit", this, "agquestbandit");
            Interface.Oxide.GetLibrary<Game.Rust.Libraries.Command>(null).AddConsoleCommand("quest.refresh", this, "agquestrefresh");
            foreach (var z in BasePlayer.activePlayerList) ProgressQuest(z, typequest.online, 1);

            foreach (MonumentInfo info in UnityEngine.Object.FindObjectsOfType<MonumentInfo>())
            {
                if (info.name.Equals("assets/bundled/prefabs/autospawn/monument/medium/compound.prefab")) compound = info;
                else if (info.name.Equals("assets/bundled/prefabs/autospawn/monument/medium/bandit_town.prefab")) bandit_town = info;
            }

            timer.Once(5f, () => SpawnScientist());

            Puts("ЗАПУСКАЕМ КВЕСТ МАШИНУ ДЫР-ДЫР-ВЖУХ!");
        }

        MonumentInfo compound;
        MonumentInfo bandit_town;

        #region UI
        class LMUI
        {
            static public CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool cursor = false, string parent = "Overlay")
            {
                var NewElement = new CuiElementContainer()
            {
                {
                    new CuiPanel
                    {
                        Image = {Color = color},
                        RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                        CursorEnabled = cursor,
                        FadeOut = 0f
                    },
                    new CuiElement().Parent = parent,
                    panelName
                }
            };
                return NewElement;
            }
            static public void CreatePanel(ref CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    CursorEnabled = cursor
                },
                panel, CuiHelper.GetGuid());
            }
            static public void CreateLabel(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleLeft, string font = "RobotoCondensed-Bold.ttf", float fadeIn = 0f, float fadeout = 0f)
            {
                container.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, FadeIn = fadeIn, Text = text, Font = font },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    FadeOut = fadeout
                },
                panel, CuiHelper.GetGuid());

            }
            static public void CreateButton(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align = TextAnchor.MiddleCenter, float fadeIn = 0f, float fade = 0f, string material = "assets/content/ui/uibackgroundblur-ingamemenu.mat")
            {
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = fadeIn, Material = material },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    Text = { Text = text, FontSize = size, Align = align },
                    FadeOut = fade
                },
                panel, CuiHelper.GetGuid());
            }
            static public void LoadImage(ref CuiElementContainer container, string panel, string png, string aMin, string aMax)
            {
                container.Add(new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = panel,
                    Components =
                    {
                        new CuiRawImageComponent {Png = png, Sprite = "assets/content/textures/generic/fulltransparent.tga" },
                        new CuiRectTransformComponent {AnchorMin = aMin, AnchorMax = aMax }
                    }
                });
            }
            static public void OutlineText(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleLeft, string colorout = "0 0 0 1", float fadeIn = 0f)
            {
                container.Add(new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = panel,
                    Components =
                    {
                        new CuiTextComponent {Color = color, FontSize = size, Align = align, FadeIn = fadeIn, Text = text },
                        new CuiOutlineComponent { Distance = "0.6 0.6", Color = colorout },
                        new CuiRectTransformComponent {AnchorMin = aMin, AnchorMax = aMax }
                    }
                });
            }
            static public void CreateInput(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, int chars = 100, TextAnchor align = TextAnchor.UpperLeft)
            {
                container.Add(new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = panel,
                    Components =
                    {
                        new CuiInputFieldComponent
                        {
                            Color = color,
                            Text = text,
                            FontSize = size,
                            Command = command,
                            CharsLimit = chars,
                            Align = align,
                            IsPassword = false
                        },
                        new CuiRectTransformComponent {AnchorMin = aMin, AnchorMax = aMax }
                    }
                });
            }
        }
        #endregion
    }
}

// --- End of file: ZetaQuest.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/WipeBlock.cs ---
// --- Original Local Path: KualaRust/WipeBlock.cs ---

﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Apex;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Color = UnityEngine.Color;
using ru = Oxide.Game.Rust;

namespace Oxide.Plugins
{
    [Info("WipeBlock", "Hougan", "2.0.9")]
    [Description("Блокировка предметов для вашего сервера!")]
    public class WipeBlock : RustPlugin
    {
        #region Classes

        private class Configuration
        {
            public class Interface
            {
                [JsonProperty("Сдвиг панели по вертикале (если некорректно отображается при текущих настройках)")]
                public int Margin = 0;
                [JsonProperty("Текст на первой строке")]
                public string FirstString = "БЛОКИРОВКА ПРЕДМЕТОВ";
                [JsonProperty("Текст на второй строке")]
                public string SecondString = "НАЖМИТЕ ЧТОБЫ УЗНАТЬ БОЛЬШЕ";
                [JsonProperty("Название сервера")]
                public string ServerName = "%CONFIG%";
            }

            public class Block
            {
                [JsonProperty("Сдвиг блокировки в секундах ('328' - на 328 секунд вперёд, '-328' на 328 секунд назад)")]
                public int TimeMove = 0;
                [JsonProperty("Настройки блокировки предметов")]
                public Dictionary<int, List<string>> BlockItems;
                [JsonProperty("Названия категорий в интерфейсе")]
                public Dictionary<string, string> CategoriesName;
            }

            [JsonProperty("Настройки интерфейса плагина")]
            public Interface SInterface;
            [JsonProperty("Настройки текущей блокировки")]
            public Block SBlock;

            public static Configuration GetDefaultConfiguration()
            {
                var newConfiguration = new Configuration();
                newConfiguration.SInterface = new Interface();
                newConfiguration.SBlock = new Block();
                newConfiguration.SBlock.CategoriesName = new Dictionary<string, string>
                {
                    ["Weapon"] = "ОРУЖИЯ",
                    ["Ammunition"] = "БОЕПРИПАСОВ",
                    ["Medical"] = "МЕДИЦИНЫ",
                    ["Food"] = "ЕДЫ",
                    ["Traps"] = "ЛОВУШЕК",
                    ["Tool"] = "ИНСТРУМЕНТОВ",
                    ["Construction"] = "КОНСТРУКЦИЙ",
                    ["Resources"] = "РЕСУРСОВ",
                    ["Items"] = "ПРЕДМЕТОВ",
                    ["Component"] = "КОМПОНЕНТОВ",
                    ["Misc"] = "ПРОЧЕГО",
                    ["Attire"] = "ОДЕЖДЫ"
                };
                newConfiguration.SBlock.BlockItems = new Dictionary<int, List<string>>
                {
                    [1800] = new List<string>
                    {
                        "pistol.revolver",
                        "shotgun.double",
                    },
                    [3600] = new List<string>
                    {
                        "flamethrower",
                        "bucket.helmet",
                        "riot.helmet",
                        "pants",
                        "hoodie",
                    },
                    [7200] = new List<string>
                    {
                        "pistol.python",
                        "pistol.semiauto",
                        "coffeecan.helmet",
                        "roadsign.jacket",
                        "roadsign.kilt",
                        "icepick.salvaged",
                        "axe.salvaged",
                        "hammer.salvaged",
                    },
                    [14400] = new List<string>
                    {
                        "shotgun.pump",
                        "shotgun.spas12",
                        "pistol.m92",
                        "smg.mp5",
                        "jackhammer",
                        "chainsaw",
                    },
                    [28800] = new List<string>
                    {
                        "smg.2",
                        "smg.thompson",
                        "rifle.semiauto",
                        "explosive.satchel",
                        "grenade.f1",
                        "grenade.beancan",
                        "surveycharge"
                    },
                    [43200] = new List<string>
                    {
                        "rifle.bolt",
                        "rifle.ak",
                        "rifle.lr300",
                        "metal.facemask",
                        "metal.plate.torso",
                        "rifle.l96",
                        "rifle.m39"
                    },
                    [64800] = new List<string>
                    {
                        "ammo.rifle.explosive",
                        "ammo.rocket.basic",
                        "ammo.rocket.fire",
                        "ammo.rocket.hv",
                        "rocket.launcher",
                        "explosive.timed"
                    },
                    [86400] = new List<string>
                    {
                        "lmg.m249",
                        "heavy.plate.helmet",
                        "heavy.plate.jacket",
                        "heavy.plate.pants",
                    }
                };

                return newConfiguration;
            }
        }

        #endregion

        #region Variables

        [PluginReference]
        private Plugin ImageLibrary, Duels, OneVSOne, Battles;

        private bool IsBattles(ulong userid)
        {
            return Battles != null && Battles.Call<bool>("IsPlayerOnBattle", userid);
        }

        private Configuration settings = null;

        [JsonProperty("Список градиентов")]
        private List<string> Gradients = new List<string> { "518eef", "5CAD4F", "5DAC4E", "5EAB4E", "5FAA4E", "60A94E", "61A84E", "62A74E", "63A64E", "64A54E", "65A44E", "66A34E", "67A24E", "68A14E", "69A04E", "6A9F4E", "6B9E4E", "6C9D4E", "6D9C4E", "6E9B4E", "6F9A4E", "71994E", "72984E", "73974E", "74964E", "75954E", "76944D", "77934D", "78924D", "79914D", "7A904D", "7B8F4D", "7C8E4D", "7D8D4D", "7E8C4D", "7F8B4D", "808A4D", "81894D", "82884D", "83874D", "84864D", "86854D", "87844D", "88834D", "89824D", "8A814D", "8B804D", "8C7F4D", "8D7E4D", "8E7D4D", "8F7C4D", "907B4C", "917A4C", "92794C", "93784C", "94774C", "95764C", "96754C", "97744C", "98734C", "99724C", "9B714C", "9C704C", "9D6F4C", "9E6E4C", "9F6D4C", "A06C4C", "A16B4C", "A26A4C", "A3694C", "A4684C", "A5674C", "A6664C", "A7654C", "A8644C", "A9634C", "AA624B", "AB614B", "AC604B", "AD5F4B", "AE5E4B", "B05D4B", "B15C4B", "B25B4B", "B35A4B", "B4594B", "B5584B", "B6574B", "B7564B", "B8554B", "B9544B", "BA534B", "BB524B", "BC514B", "BD504B", "BE4F4B", "BF4E4B", "C04D4B", "C14C4B", "C24B4B", "C44B4B" };

        private string Layer = "UI_328InstanceBlock";
        private string LayerBlock = "UI_328Block";
        private string LayerInfoBlock = "UI_328InfoBlock";

        private string IgnorePermission = "wipeblock.ignore";

        #endregion

        #region Initialization

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                settings = Config.ReadObject<Configuration>();
                if (settings?.SBlock == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Ошибка чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => settings = Configuration.GetDefaultConfiguration();
        protected override void SaveConfig() => Config.WriteObject(settings);
        private long SaveCreatedTime = 0;
        private long ToEpoch(DateTime dateTime) => (long)(dateTime - new DateTime(1970, 1, 1)).TotalSeconds;
        private void OnServerInitialized()
        {
            if (!ImageLibrary)
            {
                PrintError("ImageLibrary not found, plugin will not work!");
                return;
            }
            foreach (var check in settings.SBlock.BlockItems.SelectMany(p => p.Value))
            {
                ImageLibrary.Call("AddImage", $"http://db.maxigames.su/images/rust/items/128/{check}.png", check);
            }

            SaveCreatedTime = ToEpoch(SaveRestore.SaveCreatedTime);
            Interface.Oxide.GetLibrary<ru.Libraries.Command>(null).AddChatCommand("block", this, "cmdChatDrawBlock");
            Interface.Oxide.GetLibrary<ru.Libraries.Command>(null).AddChatCommand("wipeblock", this, "cmdChatDrawBlock");
            permission.RegisterPermission(IgnorePermission, this);
            foreach (BasePlayer player in BasePlayer.activePlayerList) OnPlayerConnected(player);
            GUIMain = GUIMain.Replace("{min}", (-318 + settings.SInterface.Margin).ToString()).Replace("{max}", (278 + settings.SInterface.Margin).ToString()).Replace("{name}", settings.SInterface.ServerName);
            createcache();
        }


        private void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (active.ContainsKey(player.userID) && active[player.userID].active) CmdChatStopBlock(player);
            }
        }
        #endregion

        #region Hooks

        private object CanWearItem(PlayerInventory inventory, Item item)
        {
            var player = inventory.gameObject.ToBaseEntity() as BasePlayer;
            if (IsBlocked(item.info) > 0)
            {
                if (player.GetComponent<NPCPlayer>() != null || player.GetComponent<BaseNpc>() != null || player.IsNpc || OneVSOne != null && (bool)OneVSOne.Call("IsEventPlayer", player))
                    return null;

                if (permission.UserHasPermission(player.UserIDString, IgnorePermission))
                    return null;

                DrawInstanceBlock(player, item);
                timer.Once(3f, () =>
                {

                    CuiHelper.DestroyUi(player, Layer + ".Destroy1");
                    CuiHelper.DestroyUi(player, Layer + ".Destroy2");
                    CuiHelper.DestroyUi(player, Layer + ".Destroy3");
                    CuiHelper.DestroyUi(player, Layer + ".Destroy5");
                    timer.Once(1, () => CuiHelper.DestroyUi(player, Layer));
                });
                return false;
            }
            return null;
        }

        private object CanEquipItem(PlayerInventory inventory, Item item)
        {
            var player = inventory.gameObject.ToBaseEntity() as BasePlayer;
            if (player == null) return null;

            if (IsBlocked(item.info) > 0)
            {
                if (player.GetComponent<NPCPlayer>() != null || player.GetComponent<BaseNpc>() != null || player.IsNpc || OneVSOne != null && (bool)OneVSOne.Call("IsEventPlayer", player))
                    return null;

                if (permission.UserHasPermission(player.UserIDString, IgnorePermission))
                    return null;

                DrawInstanceBlock(player, item);
                timer.Once(3f, () =>
                {

                    CuiHelper.DestroyUi(player, Layer + ".Destroy1");
                    CuiHelper.DestroyUi(player, Layer + ".Destroy2");
                    CuiHelper.DestroyUi(player, Layer + ".Destroy3");
                    CuiHelper.DestroyUi(player, Layer + ".Destroy5");
                    timer.Once(1, () => CuiHelper.DestroyUi(player, Layer));
                });
                return false;
            }
            return null;
        }

        private object OnReloadWeapon(BasePlayer player, BaseProjectile projectile)
        {
            if (player is NPCPlayer)
                return null;

            if (permission.UserHasPermission(player.UserIDString, IgnorePermission))
                return null;

            if (player.GetComponent<NPCPlayer>() != null || player.GetComponent<BaseNpc>() != null || player.IsNpc || OneVSOne != null && (bool)OneVSOne.Call("IsEventPlayer", player))
                return null;

            if (IsBlocked(projectile.primaryMagazine.ammoType) > 0 && IsBattles(player.userID))
            {
                SendReply(player, $"Вы <color=#81B67A>не можете</color> использовать этот тип боеприпасов!");
                return false;
            }
            return null;
        }

        private object OnReloadMagazine(BasePlayer player, BaseProjectile projectile)
        {
            if (player is NPCPlayer)
                return null;

            if (permission.UserHasPermission(player.UserIDString, IgnorePermission) || OneVSOne != null && (bool)OneVSOne.Call("IsEventPlayer", player))
                return null;

            NextTick(() =>
            {
                if (IsBlocked(projectile.primaryMagazine.ammoType) > 0)
                {
                    player.GiveItem(ItemManager.CreateByItemID(projectile.primaryMagazine.ammoType.itemid, projectile.primaryMagazine.contents, 0UL), BaseEntity.GiveItemReason.Generic);
                    projectile.primaryMagazine.contents = 0;
                    //projectile.GetItem().LoseCondition(projectile.GetItem().maxCondition);
                    projectile.SendNetworkUpdate();
                    player.SendNetworkUpdate();

                    PrintError($"[{DateTime.Now.ToShortTimeString()}] {player} пытался взломать систему блокировки!");
                    SendReply(player, $"<color=#81B67A>Неа</color>!");
                }
            });

            return null;
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player.IsReceivingSnapshot)
            {
                NextTick(() => OnPlayerConnected(player));
                return;
            }

            DrawBlockInfo(player);
        }

        #endregion

        #region GUI

        private void DrawBlockInfo(BasePlayer player)
        {
            if (!IsAnyBlocked()) return;

            CuiHelper.DestroyUi(player, LayerInfoBlock);
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-180 -35", OffsetMax = "-10 -15" },
                Image = { Color = "0 0 0 0" }
            }, "Hud", LayerInfoBlock);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "-3 0", AnchorMax = "1 1.5", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = "chat.say /block" },
                Text = { Text = settings.SInterface.FirstString, Font = "robotocondensed-bold.ttf", Color = HexToRustFormat("#FFFFFF5A"), Align = TextAnchor.UpperRight, FontSize = 20 },
            }, LayerInfoBlock);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "-3 -0.2", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = "chat.say /block" },
                Text = { Text = settings.SInterface.SecondString, Font = "robotocondensed-bold.ttf", Color = HexToRustFormat("#FFFFFF5A"), Align = TextAnchor.LowerRight, FontSize = 12 },
            }, LayerInfoBlock);

            CuiHelper.AddUi(player, container);
        }

        [ConsoleCommand("block")]
        private void cmdConsoleDrawBlock(ConsoleSystem.Arg args)
        {
            cmdChatDrawBlock(args.Player());
        }

        [ConsoleCommand("blockmove")]
        private void cmdConsoleMoveblock(ConsoleSystem.Arg args)
        {
            if (args.Player() != null)
                return;
            if (!args.HasArgs(1))
            {
                PrintWarning($"Введите количество секунд для перемещения!");
                return;
            }

            int newTime;
            if (!int.TryParse(args.Args[0], out newTime))
            {
                PrintWarning("Вы ввели не число!");
                return;
            }

            settings.SBlock.TimeMove += newTime;
            SaveConfig();
            PrintWarning("Время блокировки успешно изменено!");
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(player);
            }
        }

        private void cmdChatDrawBlock(BasePlayer player)
        {
            if (active.ContainsKey(player.userID) && active[player.userID].active)
            {
                CmdChatStopBlock(player);
            }
            else
            {
                DrawBlockGUI(player);
            }
        }

        string lastid;
        void createcache()
        {
            Dictionary<string, Dictionary<Item, string>> cache = new Dictionary<string, Dictionary<Item, string>>();
            FillBlockedItems(cache);
            cacheitems.Clear();
            var blockedItemsNew = cache.OrderByDescending(p => p.Value.Count);
            string category = "";
            int newString = 0;
            bool refresh = false;
            for (int t = 0; t < blockedItemsNew.Count(); t++)
            {
                var blockedCategory = blockedItemsNew.ElementAt(t).Value.OrderBy(p => IsBlocked(p.Value));
                category += GUICategory.Replace("{min}", (0.889 - (t) * 0.17 - newString * 0.123).ToString()).Replace("{max}", (0.925 - (t) * 0.17 - newString * 0.123).ToString()).Replace("{name}", blockedItemsNew.ElementAt(t).Key);
                for (int i = 0; i < blockedCategory.Count(); i++)
                {
                    if (i == 12)
                    {
                        newString++;
                    }
                    float margin = Mathf.CeilToInt(blockedCategory.Count() - Mathf.CeilToInt((float)(i + 1) / 12) * 12);
                    if (margin < 0)
                    {
                        margin *= -1;
                    }
                    else
                    {
                        margin = 0;
                    }

                    var blockedItem = blockedCategory.ElementAt(i);
                    string ID = (string)ImageLibrary?.Call("GetImage", blockedItem.Key.info.shortname);
                    if (string.IsNullOrEmpty(ID) || ID == lastid)
                    {
                        refresh = true;
                    }
                    lastid = ID;
                    string text = IsBlocked(blockedItem.Key.info) > 0
                        ? $"<size=10>ОСТАЛОСЬ</size>\n<size=14>{TimeSpan.FromSeconds((int)IsBlocked(blockedItem.Key.info)).ToShortString()}</size>"
                        : "<size=11>ДОСТУПНО</size>";
                    cacheitems.Add(blockedItem.Key.info.shortname, GUIItem.Replace("{min}", $"{0.008608246 + i * 0.0837714 + ((float)margin / 2) * 0.0837714 - (Math.Floor((double)i / 12) * 12 * 0.0837714)}" + $" {0.7618223 - (t) * 0.17 - newString * 0.12}").Replace("{max}", $"{0.08415613 + i * 0.0837714 + ((float)margin / 2) * 0.0837714 - (Math.Floor((double)i / 12) * 12 * 0.0837714)}" + $" {0.8736619 - (t) * 0.17 - newString * 0.12}").Replace("{png}", ID).Replace("{name}", blockedItem.Key.info.shortname));
                }
            }
            GUIMain = GUIMain.Replace("{category}", category);
            if (refresh)
            {
                Debug.Log("Не получилось загрузить все картинки, повторим попытку через 5 секунд!");
                timer.Once(5f, () => createcache());
            }
            else Debug.Log("Картинки загружены, плагин готов к работе!");
        }

        [ChatCommand("stopBlock")]
        private void CmdChatStopBlock(BasePlayer player)
        {
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", LayerBlock);
            if (active.ContainsKey(player.userID)) active[player.userID].active = false;
        }
        ItemContainer.CanAcceptResult? CanAcceptItem(ItemContainer container, Item item, int targetPos)
        {
            if (container.entityOwner != null && container.entityOwner is AutoTurret)
            {
                if (IsBlocked(item.info) > 0f)
                {
                    BasePlayer player = item.GetOwnerPlayer();
                    if (player != null)
                    {
                        DrawInstanceBlock(player, item);
                        timer.Once(3f, () =>
                        {

                            CuiHelper.DestroyUi(player, Layer + ".Destroy1");
                            CuiHelper.DestroyUi(player, Layer + ".Destroy2");
                            CuiHelper.DestroyUi(player, Layer + ".Destroy3");
                            CuiHelper.DestroyUi(player, Layer + ".Destroy5");
                            timer.Once(1, () => CuiHelper.DestroyUi(player, Layer));
                        });
                    }
                    return ItemContainer.CanAcceptResult.CannotAccept;
                }
            }
            return null;
        }
        string GUIMain = "[{\"name\":\"UI_328Block\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0 0 0 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0.5\",\"anchormax\":\"0.5 0.5\",\"offsetmin\":\"-441.5 {min}\",\"offsetmax\":\"441.5 {max}\"},{\"type\":\"NeedsCursor\"}]},{\"name\":\"3ff2c7eaa31441c987abad215d5eb7c4\",\"parent\":\"UI_328Block\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"chat.say /stopBlock\",\"close\":\"UI_328Block\",\"material\":\"assets/content/ui/uibackgroundblur.mat\",\"color\":\"0 0 0 0.9\"},{\"type\":\"RectTransform\",\"anchormin\":\"-100 -100\",\"anchormax\":\"100 100\",\"offsetmax\":\"0 0\"}]},{\"name\":\"UI_328Block.Header\",\"parent\":\"UI_328Block\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0 0 0 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.92860328154\",\"anchormax\":\"1.015 0.9998464\",\"offsetmax\":\"0 0\"}]},{\"parent\":\"UI_328Block.Header\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"БЛОКИРОВКА ПРЕДМЕТОВ НА {name}\",\"fontSize\":30,\"font\":\"robotocondensed-bold.ttf\",\"align\":\"MiddleCenter\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]}{category}{main}]";
        string GUICategory = ",{\"name\":\"UI_328Block.Category\",\"parent\":\"UI_328Block\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0 0 0 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 {min}\",\"anchormax\":\"1.015 {max}\",\"offsetmax\":\"0 0\"}]},{\"parent\":\"UI_328Block.Category\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"БЛОКИРОВКА {name}\",\"fontSize\":16,\"font\":\"robotocondensed-regular.ttf\",\"align\":\"MiddleCenter\",\"color\":\"1 1 1 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]}";
        string GUIItem = ",{\"name\":\"UI_328Block.{name}\",\"parent\":\"UI_328Block\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{color}\",\"fadeIn\":0.5},{\"type\":\"RectTransform\",\"anchormin\":\"{min}\",\"anchormax\":\"{max}\",\"offsetmax\":\"0 0\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.1\",\"distance\":\"1 1\"}]},{\"parent\":\"UI_328Block.{name}\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"assets/content/textures/generic/fulltransparent.tga\",\"png\":\"{png}\",\"fadeIn\":0.5},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"2 2\",\"offsetmax\":\"-2 -2\"}]},{\"name\":\"Time.{name}\",\"parent\":\"UI_328Block.{name}\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"color\":\"0 0 0 0.5\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Time.{name}.Update\",\"parent\":\"Time.{name}\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"color\":\"0 0 0 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]},{\"parent\":\"Time.{name}.Update\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{info}\",\"fontSize\":10,\"font\":\"robotocondensed-regular.ttf\",\"align\":\"MiddleCenter\",\"fadeIn\":0.5},{\"type\":\"RectTransform\"}]}";

        Dictionary<string, string> cacheitems = new Dictionary<string, string>();

        private void DrawBlockGUI(BasePlayer player)
        {
            if (!active.ContainsKey(player.userID)) active.Add(player.userID, new perforator { active = true, lastuse = DateTime.Now.AddSeconds(3) });
            else
            {
                if (active[player.userID].lastuse > DateTime.Now)
                {
                    if (active[player.userID].lastmsg < DateTime.Now) player.ChatMessage("НЕ ТАК ЧАСТО!");
                    active[player.userID].lastmsg = DateTime.Now.AddSeconds(3);
                    return;
                }
                active[player.userID].lastuse = DateTime.Now.AddSeconds(3);
                active[player.userID].active = true;
            }
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", LayerBlock);
            string main = "";
            foreach (var blockedItem in settings.SBlock.BlockItems)
            {
                TimeSpan times = SaveRestore.SaveCreatedTime.AddSeconds(blockedItem.Key) - DateTime.UtcNow;
                double val = times.TotalSeconds;
                string text = val > 0 ? $"<size=10>ОСТАЛОСЬ</size>\n<size=14>{times.ToShortString()}</size>" : "<size=11>ДОСТУПНО</size>";
                foreach (var x in blockedItem.Value)
                {
                    main += cacheitems[x].Replace("{color}", HexToRustFormat(Gradients[Math.Min(99, Math.Max(Convert.ToInt32((float)val / blockedItem.Key * 100), 0))] + "96")).Replace("{info}", text);
                }
            }
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", GUIMain.Replace("{main}", main));
            //timeGUI[player.userID] = timer.Every(1f, () => StartUpdate(player));
        }
        Dictionary<ulong, perforator> active = new Dictionary<ulong, perforator>();
        class perforator
        {
            public DateTime lastuse;
            public DateTime lastmsg;
            public bool active;
        }

        /*Dictionary<ulong, Timer> timeGUI = new Dictionary<ulong, Timer>();
        string GUIupdate = "[{\"name\":\"Time.{name}\",\"parent\":\"UI_328Block.{name}\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"color\":\"0 0 0 0.5\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Time.{name}.Update\",\"parent\":\"Time.{name}\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"color\":\"0 0 0 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]},{\"parent\":\"Time.{name}.Update\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{info}\",\"fontSize\":10,\"font\":\"robotocondensed-regular.ttf\",\"align\":\"MiddleCenter\"},{\"type\":\"RectTransform\"}]}]";

        private void StartUpdate(BasePlayer player)
        {
            foreach (var blockedItem in settings.SBlock.BlockItems)
            {
                TimeSpan times = SaveRestore.SaveCreatedTime.AddSeconds(blockedItem.Key) - DateTime.Now;
                double val = times.TotalSeconds;
                if (val < -2) continue;
                foreach (var x in blockedItem.Value)
                {
                    CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", $"Time.{x}.Update");
                    CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", $"Time.{x}");
                    CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", GUIupdate.Replace("{name}", x).Replace("{info}", val > 0 ? $"<size=10>ОСТАЛОСЬ</size>\n<size=14>{times.ToShortString()}</size>" : "<size=11>ДОСТУПНО</size>"));
                }
            }
        }*/

        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }

        string GUIBlock = "[{\"name\":\"UI_328InstanceBlock\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.1 0.1 0.1 0\",\"fadeIn\":1.0},{\"type\":\"RectTransform\",\"anchormin\":\"0.35 0.75\",\"anchormax\":\"0.62 0.95\"}],\"fadeOut\":1.0},{\"name\":\"UI_328InstanceBlock.Hide\",\"parent\":\"UI_328InstanceBlock\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0 0 0 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\"}],\"fadeOut\":1.0},{\"name\":\"UI_328InstanceBlock.Destroy1\",\"parent\":\"UI_328InstanceBlock.Hide\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.4 0.4 0.4 0.7\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.62\",\"anchormax\":\"1.1 0.85\"}],\"fadeOut\":1.0},{\"name\":\"UI_328InstanceBlock.Destroy5\",\"parent\":\"UI_328InstanceBlock.Destroy1\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"ПРЕДМЕТ ЗАБЛОКИРОВАН\",\"fontSize\":22,\"font\":\"robotocondensed-bold.ttf\",\"align\":\"MiddleCenter\",\"color\":\"0.9 0.9 0.9 1\",\"fadeIn\":1.0},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\"}],\"fadeOut\":1.0},{\"name\":\"UI_328InstanceBlock.Destroy2\",\"parent\":\"UI_328InstanceBlock.Hide\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"color\":\"0.3 0.3 0.3 0.5\",\"fadeIn\":1.0},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.29\",\"anchormax\":\"1.1 0.61\"}],\"fadeOut\":1.0},{\"name\":\"UI_328InstanceBlock.Destroy3\",\"parent\":\"UI_328InstanceBlock.Hide\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{text}\",\"fontSize\":16,\"font\":\"robotocondensed-regular.ttf\",\"align\":\"MiddleLeft\",\"color\":\"0.85 0.85 0.85 1\",\"fadeIn\":1.0},{\"type\":\"RectTransform\",\"anchormin\":\"0.04 0\",\"anchormax\":\"10 0.9\"}],\"fadeOut\":1.0}]";

        private void DrawInstanceBlock(BasePlayer player, Item item)
        {
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", Layer);
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", GUIBlock.Replace("{text}", "Предмет {name} временно заблокирован,\nподождите {1}".Replace("{name}", item.info.displayName.english).Replace("{1}", $"{Convert.ToInt32(Math.Floor(TimeSpan.FromSeconds(IsBlocked(item.info)).TotalHours))} час {TimeSpan.FromSeconds(IsBlocked(item.info)).Minutes} минут.")));
        }

        #endregion

        #region Functions

        private string GetGradient(int t)
        {
            var LeftTime = UnBlockTime(t) - CurrentTime();
            return Gradients[Math.Min(99, Math.Max(Convert.ToInt32((float)LeftTime / t * 100), 0))];
        }

        private double IsBlockedCategory(int t) => IsBlocked(settings.SBlock.BlockItems.ElementAt(t).Value.First());
        private bool IsAnyBlocked() => UnBlockTime(settings.SBlock.BlockItems.Last().Key) + settings.SBlock.TimeMove > CurrentTime();
        private double IsBlocked(string shortname)
        {
            if (!settings.SBlock.BlockItems.SelectMany(p => p.Value).Contains(shortname))
                return 0;

            var blockTime = settings.SBlock.BlockItems.FirstOrDefault(p => p.Value.Contains(shortname)).Key;
            var lefTime = (UnBlockTime(blockTime)) - CurrentTime();

            return lefTime > 0 ? lefTime : 0;
        }

        private double UnBlockTime(int amount) => SaveCreatedTime + amount + settings.SBlock.TimeMove;

        private double IsBlocked(ItemDefinition itemDefinition) => IsBlocked(itemDefinition.shortname);

        private void FillBlockedItems(Dictionary<string, Dictionary<Item, string>> fillDictionary)
        {
            foreach (var category in settings.SBlock.BlockItems)
            {
                string categoryColor = GetGradient(category.Key);
                foreach (var item in category.Value)
                {
                    Item createItem = ItemManager.CreateByPartialName(item);
                    string catName = settings.SBlock.CategoriesName[createItem.info.category.ToString()];

                    if (!fillDictionary.ContainsKey(catName))
                        fillDictionary.Add(catName, new Dictionary<Item, string>());

                    if (!fillDictionary[catName].ContainsKey(createItem))
                        fillDictionary[catName].Add(createItem, categoryColor);
                }
            }
        }

        #endregion

        #region Utils

        static readonly DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        static double CurrentTime() { return DateTime.UtcNow.Subtract(epoch).TotalSeconds; }

        public static string ToShortString(TimeSpan timeSpan)
        {
            int i = 0;
            string resultText = "";
            if (timeSpan.Days > 0)
            {
                resultText += timeSpan.Days + " День";
                i++;
            }
            if (timeSpan.Hours > 0 && i < 2)
            {
                if (resultText.Length != 0)
                    resultText += " ";
                resultText += timeSpan.Days + " Час";
                i++;
            }
            if (timeSpan.Minutes > 0 && i < 2)
            {
                if (resultText.Length != 0)
                    resultText += " ";
                resultText += timeSpan.Days + " Мин.";
                i++;
            }
            if (timeSpan.Seconds > 0 && i < 2)
            {
                if (resultText.Length != 0)
                    resultText += " ";
                resultText += timeSpan.Days + " Сек.";
                i++;
            }

            return resultText;
        }

        private void GetConfig<T>(string menu, string key, ref T varObject)
        {
            if (Config[menu, key] != null)
            {
                varObject = Config.ConvertValue<T>(Config[menu, key]);
            }
            else
            {
                Config[menu, key] = varObject;
            }
        }

        #endregion
    }
}

// --- End of file: WipeBlock.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/ServerStats.cs ---
// --- Original Local Path: KualaRust/ServerStats.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
#if RUST
using Facepunch;
#endif
using Newtonsoft.Json;
using UnityEngine;
using WebSocketSharp;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
    // FullChangeLog: https://github.com/iamryuzaki/RustServerStats/blob/master/Plugin/ServerStat.Changelog.txt
    // WebPanel: http://server-stats.gamewer.ru/
    // Thanks: Мизантроп
    // ChangeLog:
    //    - 1.0.1
    //        * The plugin is adapted for all games on Oxide
    //        * Change remote server Addr
    //        * Remove rude using in plugin
    //        * Add server password and config
    //    - 1.0.2
    //        * Adeed minimal fps from current second

    [Info("ServerStats", "TheRyuzaki", "1.0.2")]
    public class ServerStats : CovalencePlugin
    {
        private static ServerStats Instance { get; set; } = null;

        private WebSocketSharp.WebSocket WebSocketClient = new WebSocket("ws://s1.server-stats.gamewer.ru:5191");
        private FPSVisor ActiveVisor;
        private bool NetworkStatus = false;
        private bool HaveSubscribers = false;
        private bool HasUnloading = false;
        private int MinimalFPS = 9999;
        
        
        protected override void LoadDefaultConfig()
        {
            this.Config["Password"] = Random.Range(1000, 9999);
            this.LogWarning("Config file ServerStats.json is not found, you new password: " + this.Config["Password"]);

            this.Config.Save();
        }

        void Init()
        {
            Instance = this;
        }

        void OnServerInitialized()
        {
            this.Config.Load();

            this.ActiveVisor = Terrain.activeTerrain.gameObject.AddComponent<FPSVisor>();
            
            this.WebSocketClient.OnOpen += OnNetworkConnected;
            this.WebSocketClient.OnClose += OnNetworkClose;
            this.WebSocketClient.OnMessage += OnNetworkMessage;
            this.timer.Repeat(1, 0, this.DoServerStats);
            this.DoNetworkConnect();
        }
        

        void Unload()
        {
            this.HasUnloading = true;
            Component.Destroy(this.ActiveVisor);
            this.WebSocketClient.CloseAsync();
        }

        private void OnNetworkMessage(object sender, MessageEventArgs e)
        {
            try
            {
                Dictionary<string, object> packet = JsonConvert.DeserializeObject<Dictionary<string, object>>(e.Data);
                object method = string.Empty;
                if (packet.TryGetValue("method", out method))
                {
                    switch ((string)method)
                    {
                        case "haveSubscribers":
                            this.HaveSubscribers = true;
                            break;
                        case "notHaveSubscribers":
                            this.HaveSubscribers = false;
                            break;
                    }
                }
            }
            catch
            {
                
            }
        }

        private void OnNetworkClose(object sender, CloseEventArgs e)
        {
            if (this.NetworkStatus != false)
            {
                this.Puts("NetworkStatus: false");
            }
            this.NetworkStatus = false;
            HaveSubscribers = false;
            if (this.HasUnloading == false)
            {
                this.timer.Once(10f, this.DoNetworkConnect);
            }
        }

        private void OnNetworkConnected(object sender, EventArgs e)
        {
            if (this.NetworkStatus != true)
            {
                this.Puts("NetworkStatus: true");
            }
            this.NetworkStatus = true;
#if RUST
            NetworkWelcomePacket packet = Pool.Get<NetworkWelcomePacket>();
#else
            NetworkWelcomePacket packet = new NetworkWelcomePacket();
#endif
            this.WebSocketClient.SendAsync(JsonConvert.SerializeObject(packet), (res) => { });
#if RUST
            Pool.Free(ref packet);
#endif
        }

        void DoServerStats()
        {
            if (this.NetworkStatus == true && this.HaveSubscribers == true)
            {
                var listPlugins = this.plugins.PluginManager.GetPlugins().ToArray();
#if RUST
                NetworkTickPacket packet = Pool.Get<NetworkTickPacket>();
#else
                NetworkTickPacket packet = new NetworkTickPacket();
#endif
                QueueWorkerThread(_ =>
                {
                    for (var i = 0; i < listPlugins.Length; i++)
                    {
                        packet.ListPlugins.Add(new NetworkTickPacket.PluginItem
                        {
                            Name = listPlugins[i].Name,
                            Version = listPlugins[i].Version.ToString(),
                            Author = listPlugins[i].Author,
                            Hash = listPlugins[i].Name.GetHashCode(),
                            Time = listPlugins[i].TotalHookTime
                        });
                    }

                    if (this.NetworkStatus == true && this.HaveSubscribers == true)
                        this.WebSocketClient.SendAsync(JsonConvert.SerializeObject(packet), (res) => { });
#if RUST
                    Pool.Free(ref packet);
#endif
                });
            }
        }

        void DoNetworkConnect()
        {
            if (this.NetworkStatus == false && this.HasUnloading == false)
            {
                this.WebSocketClient.Connect();
            }
        }

        public class FPSVisor : MonoBehaviour
        {
            private void Update()
            {
#if RUST
            if (Instance.MinimalFPS > (int)global::Performance.current.frameRate)
                Instance.MinimalFPS = (int)global::Performance.current.frameRate;
#else
             if (Instance.MinimalFPS > (int)(1f / UnityEngine.Time.deltaTime))
                 Instance.MinimalFPS = (int)(1f / UnityEngine.Time.deltaTime);
#endif
            }
        }

#if RUST
        public class NetworkWelcomePacket : Pool.IPooled
#else
        public class NetworkWelcomePacket
#endif
        {
            [JsonProperty("method")]
            public string Method { get; } = "reg_server";
            [JsonProperty("serverHash")]
            public int ServerHash { get; } = Instance.server.Name.GetHashCode();
            [JsonProperty("serverName")]
            public string ServerName { get; } = Instance.server.Name;
            [JsonProperty("password")] 
            public string Password => Instance.Config["Password"].ToString();

            public void EnterPool()
            {
                
            }

            public void LeavePool()
            {
                
            }
        }

#if RUST
        public class NetworkTickPacket: Pool.IPooled
#else
        public class NetworkTickPacket
#endif
        {
            [JsonProperty("method")]
            public string Method { get; } = "tick_server";
            [JsonProperty("listPlugins")]
#if RUST
            public List<PluginItem> ListPlugins { get; } = Pool.GetList<PluginItem>();
#else
            public List<PluginItem> ListPlugins { get; } = new List<PluginItem>();
#endif

            [JsonProperty("minfps")]
            public int MinimalFps
            {
                get
                {
                    int currentValue = Instance.MinimalFPS;
                    Instance.MinimalFPS = 9999;
                    return currentValue;
                }
            }
            [JsonProperty("fps")]
#if RUST
            public int Fps => global::Performance.current.frameRate;
#else
            public int Fps => Mathf.RoundToInt(1f / UnityEngine.Time.smoothDeltaTime);
#endif

            [JsonProperty("ent")]
#if RUST
            public int Ent => BaseNetworkable.serverEntities.Count;
#else
            public int Ent => 0;
#endif
            [JsonProperty("online")]
            public int Online => Instance.players.Connected.Count();//BasePlayer.activePlayerList.Count;

            public void EnterPool()
            {
                this.ListPlugins.Clear();
            }

            public void LeavePool()
            {
                
            }

            public struct PluginItem
            {
                [JsonProperty("name")]
                public string Name { get; set; }
                [JsonProperty("author")]
                public string Author { get; set; }
                [JsonProperty("version")]
                public string Version { get; set; }
                [JsonProperty("hash")]
                public int Hash { get; set; }
                [JsonProperty("time")]
                public double Time { get; set; }
            }
        }
        
    }
}

// --- End of file: ServerStats.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/GroupLimits.cs ---
// --- Original Local Path: KualaRust/GroupLimits.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Group Limits", "misticos", "3.0.1")]
    [Description("Prevent rulebreakers from breaking group limits on your server and notify your staff")]
    class GroupLimits : CovalencePlugin
    {
        #region Variables

        [PluginReference("DiscordMessages")]
        private Plugin _discordMessages = null;

        private const string PermissionIgnore = "grouplimits.ignore";

        private static GroupLimits _ins;

        #endregion

        #region Configuration

        private Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Limits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<Limit> Limits = new List<Limit> {new Limit()};

            [JsonProperty(PropertyName = "Log Format")]
            public string LogFormat =
                "[{time}] {id} ({name}) authorized on {shortname}/{entid} ({type}) at ({position})";

            public class Limit
            {
                [JsonProperty(PropertyName = "Type Name")]
                public string Name = "Any";

                [JsonProperty(PropertyName = "Max Authorized")]
                public int MaxAuthorized = 3;

                [JsonProperty(PropertyName = "Shortnames", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public List<string> Shortnames = new List<string> {"global"};

                [JsonProperty(PropertyName = "Disable For Decaying Structures")]
                public bool NoDecaying = true;

                [JsonProperty(PropertyName = "Notify Player")]
                public bool NotifyPlayer = true;

                [JsonProperty(PropertyName = "Notify Owner")]
                public bool NotifyOwner = true;

                [JsonProperty(PropertyName = "Enforce")]
                public bool Enforce = false;

                [JsonProperty(PropertyName = "Deauthorize")]
                public bool Deauthorize = true;

                [JsonProperty(PropertyName = "Deauthorize All")]
                public bool DeauthorizeAll = false;

                [JsonProperty(PropertyName = "Discord")]
                public Discord Webhook = new Discord();

                [JsonProperty(PropertyName = "Log To File")]
                public bool File = false;

                public static Limit Find(string shortname)
                {
                    var cLimit = (Limit) null;
                    foreach (var limit in _ins._config.Limits)
                    {
                        if (limit.Shortnames.Contains("global"))
                            cLimit = limit;

                        if (limit.Shortnames.Contains(shortname))
                            return limit;
                    }

                    return cLimit;
                }

                public class Discord
                {
                    [JsonProperty(PropertyName = "Webhook")]
                    public string Webhook = string.Empty;

                    [JsonProperty(PropertyName = "Inline")]
                    public bool Inline = true;

                    [JsonProperty(PropertyName = "Title")]
                    public string Title = "Group Limit: Exceeded or deauthorized";

                    [JsonProperty(PropertyName = "Color")]
                    public int Color = 0;

                    [JsonProperty(PropertyName = "Player Title")]
                    public string PlayerTitle = "Player";

                    [JsonProperty(PropertyName = "Player")]
                    public string Player = "{name}/{id}";

                    [JsonProperty(PropertyName = "Authed Title")]
                    public string AuthedTitle = "Authorized Players";

                    [JsonProperty(PropertyName = "Authed")]
                    public string Authed = "{list}";

                    [JsonProperty(PropertyName = "Authed Entry")]
                    public string AuthedEntry = "{name}/{id}";

                    [JsonProperty(PropertyName = "Authed Separator")]
                    public string AuthedSeparator = "\n";

                    [JsonProperty(PropertyName = "Entity Title")]
                    public string EntityTitle = "Entity";

                    [JsonProperty(PropertyName = "Entity")]
                    public string Entity = "{shortname}/{id} ({type})";

                    [JsonProperty(PropertyName = "Position Title")]
                    public string PositionTitle = "Position";

                    [JsonProperty(PropertyName = "Position")]
                    public string Position = "teleportpos {position}";
                }
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        protected override void LoadDefaultConfig() => _config = new Configuration();

        #endregion

        #region Hooks

        private void Init()
        {
            _ins = this;

            permission.RegisterPermission(PermissionIgnore, this);
        }

        private void Unload()
        {
            _ins = null;
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Notify: Player", "You are trying to exceed the group limit on our server."},
                {
                    "Notify: Owner",
                    "{name} tried to exceed the group limit on your entity at {position}. (Type: {type})"
                },
                {"Notify: Deauthorize Player", "One person was deauthorized, try to authorize again if you were not."},
                {
                    "Notify: Deauthorize Owner",
                    "{name} tried to authorize on your entity. One person was deauthorized on your entity at {position}. (Type: {type})"
                }
            }, this);
        }

        private object OnCupboardAuthorize(BuildingPrivlidge privilege, BasePlayer player)
        {
            if (privilege.authorizedPlayers.Count == 0)
                return null;
            
            if (player.IPlayer.HasPermission(PermissionIgnore))
                return null;

            var limit = Configuration.Limit.Find(privilege.ShortPrefabName);
            if (limit == null)
                return null;

            privilege.authorizedPlayers.RemoveAll(x => x.userid == player.userID);
            if (privilege.authorizedPlayers.Count < limit.MaxAuthorized)
                return null;

            if (limit.NoDecaying && IsDecaying(privilege))
                return null;

            var authed = privilege.authorizedPlayers.Select(x => x.userid);
            if (limit.Deauthorize)
            {
                // Make sure we send authed players before clearing
                authed = authed.ToArray();

                if (limit.DeauthorizeAll)
                    privilege.authorizedPlayers.Clear();
                else
                    privilege.authorizedPlayers.RemoveAt(0);

                privilege.SendNetworkUpdate();
            }

            Notify(limit, privilege, player, authed, limit.Deauthorize);

            if (limit.Enforce)
                return true;

            return null;
        }

        private object OnCodeEntered(CodeLock codeLock, BasePlayer player, string code)
        {
            if (codeLock.whitelistPlayers.Count == 0 && codeLock.guestCode.Length == 0)
                return null;
            
            if (player.IPlayer.HasPermission(PermissionIgnore))
                return null;

            var isCodeAdmin = codeLock.code == code;
            var isCodeGuest = codeLock.guestCode == code;
            if (!isCodeAdmin && !isCodeGuest)
                return null;

            var limit = Configuration.Limit.Find(codeLock.ShortPrefabName);
            if (limit == null)
                return null;

            if (codeLock.guestPlayers.Count + codeLock.whitelistPlayers.Count < limit.MaxAuthorized)
                return null;

            var entity = codeLock.GetParentEntity();
            if (entity == null || !entity.IsValid())
                return null;

            if (limit.NoDecaying && IsDecaying(entity.GetBuildingPrivilege()))
                return null;

            var authed = codeLock.whitelistPlayers.Union(codeLock.guestPlayers);
            if (limit.Deauthorize)
            {
                // Make sure we send authed players before clearing
                authed = authed.ToArray();
                
                if (isCodeAdmin && codeLock.whitelistPlayers.Count > 0)
                {
                    if (limit.DeauthorizeAll)
                        codeLock.whitelistPlayers.Clear();
                    else
                        codeLock.whitelistPlayers.RemoveAt(0);
                }

                if (isCodeGuest && codeLock.guestPlayers.Count > 0)
                {
                    if (limit.DeauthorizeAll)
                        codeLock.guestPlayers.Clear();
                    else
                        codeLock.guestPlayers.RemoveAt(0);
                }

                codeLock.SendNetworkUpdate();
            }

            Notify(limit, entity, player, authed, limit.Deauthorize);

            if (limit.Enforce)
                return true;

            return null;
        }

        private object OnTurretAuthorize(AutoTurret turret, BasePlayer player)
        {
            if (turret.authorizedPlayers.Count == 0)
                return null;
            
            if (player.IPlayer.HasPermission(PermissionIgnore))
                return null;

            var limit = Configuration.Limit.Find(turret.ShortPrefabName);
            if (limit == null)
                return null;

            turret.authorizedPlayers.RemoveAll(x => x.userid == player.userID);
            if (turret.authorizedPlayers.Count < limit.MaxAuthorized)
                return null;

            if (limit.NoDecaying && IsDecaying(turret.GetBuildingPrivilege()))
                return null;

            var authed = turret.authorizedPlayers.Select(x => x.userid);
            if (limit.Deauthorize)
            {
                // Make sure we send authed players before clearing
                authed = authed.ToArray();

                if (limit.DeauthorizeAll)
                    turret.authorizedPlayers.Clear();
                else
                    turret.authorizedPlayers.RemoveAt(0);
            }

            Notify(limit, turret, player, authed, limit.Deauthorize);

            if (limit.Enforce)
                return true;

            return null;
        }

        #endregion

        #region Helpers

        private void Notify(Configuration.Limit limit, BaseEntity entity, BasePlayer basePlayer,
            IEnumerable<ulong> authed, bool deauth)
        {
            if (limit.NotifyPlayer)
            {
                var player = basePlayer?.IPlayer;
                if (player != null && player.IsConnected)
                {
                    player.Message(GetMsg(deauth ? "Notify: Deauthorize Player" : "Notify: Player", player.Id));
                }
            }

            if (limit.NotifyOwner)
            {
                var player = players.FindPlayerById(entity.OwnerID.ToString());
                if (player != null && player.IsConnected)
                {
                    var sb = new StringBuilder(
                        GetMsg(deauth ? "Notify: Deauthorize Owner" : "Notify: Owner", player.Id));

                    sb.Replace("{position}", entity.transform.position.ToString());
                    sb.Replace("{type}", limit.Name);
                    sb.Replace("{name}", basePlayer?.displayName ?? "Unknown");

                    player.Message(sb.ToString());
                }
            }

            NotifyLog(limit, entity, basePlayer);
            NotifyDiscord(limit, entity, basePlayer, authed);
        }

        private void NotifyLog(Configuration.Limit limit, BaseNetworkable entity, BasePlayer player)
        {
            if (!limit.File)
                return;

            var builder = new StringBuilder(_config.LogFormat);
            builder.Replace("{time}", DateTime.Now.ToLongTimeString());
            builder.Replace("{name}", player?.displayName ?? "Unknown");
            builder.Replace("{id}", player?.UserIDString ?? "0");
            builder.Replace("{shortname}", entity.ShortPrefabName);
            builder.Replace("{entid}", entity.net.ID.ToString());
            builder.Replace("{type}", limit.Name);
            builder.Replace("{position}", FormattedCoordinates(entity.transform.position));

            LogToFile("Log", builder.ToString(), this);
        }

        private void NotifyDiscord(Configuration.Limit limit, BaseNetworkable entity, BasePlayer player,
            IEnumerable<ulong> authedPlayers)
        {
            var discord = limit.Webhook;
            if (string.IsNullOrEmpty(discord.Webhook) || _discordMessages == null || !_discordMessages.IsLoaded)
                return;

            var builder = new StringBuilder();
            foreach (var authed in authedPlayers)
            {
                if (builder.Length != 0)
                    builder.Append(discord.AuthedSeparator);

                builder.Append(discord.AuthedEntry);
                builder.Replace("{id}", authed.ToString());
                builder.Replace("{name}", players.FindPlayerById(authed.ToString())?.Name ?? "Unknown");
            }

            var list = builder.ToString();
            builder.Clear().Append(discord.Authed).Replace("{list}", list);

            object fields = new[]
            {
                new
                {
                    name = discord.PlayerTitle,
                    value = discord.Player.Replace("{name}", player?.displayName ?? "Unknown")
                        .Replace("{id}", player?.UserIDString ?? "0"),
                    inline = discord.Inline
                },
                new
                {
                    name = discord.AuthedTitle,
                    value = builder.ToString(),
                    inline = discord.Inline
                },
                new
                {
                    name = discord.EntityTitle,
                    value = discord.Entity.Replace("{shortname}", entity.ShortPrefabName)
                        .Replace("{id}", entity.net.ID.ToString()).Replace("{type}", limit.Name),
                    inline = discord.Inline
                },
                new
                {
                    name = discord.PositionTitle,
                    value = discord.Position.Replace("{position}", FormattedCoordinates(entity.transform.position)),
                    inline = discord.Inline
                }
            };

            _discordMessages.CallHook("API_SendFancyMessage", discord.Webhook, discord.Title, discord.Color,
                JsonConvert.SerializeObject(fields));
        }

        private string FormattedCoordinates(Vector3 pos) => $"{pos.x},{pos.y},{pos.z}";

        private bool IsDecaying(BuildingPrivlidge privilege) =>
            privilege == null || privilege.GetProtectedMinutes(true) <= 0;

        private string GetMsg(string key, string userId = null) => lang.GetMessage(key, this, userId);

        #endregion
    }
}

// --- End of file: GroupLimits.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/ActiveSort.cs ---
// --- Original Local Path: KualaRust/ActiveSort.cs ---

using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins {
    [Info("Active Sort", "Egor Blagov", "1.0.4")]
    [Description("Sorts furnace and refinery on click")]
    class ActiveSort : RustPlugin {
        private const string permUse = "activesort.use";

        #region TRANSLATION TABLES
        Dictionary<string, string> furnaceItems = new Dictionary<string, string> {
            ["sulfur.ore"] = "sulfur",
            ["metal.ore"] = "metal.fragments",
            ["hq.metal.ore"] = "metal.refined"
        };

        Dictionary<string, string> refineryItems = new Dictionary<string, string> {
            ["crude.oil"] = "lowgradefuel"
        };
        #endregion

        enum FurnaceType {
            Furnace,
            Refinery
        }
        #region CONFIG
        class PluginConfig {
            public bool ShowUI = true;
            public Vector2 ButtonPositionOffset = new Vector2(0, 0);
            public Vector2 ButtonSize = new Vector2(115, 30);
            public string ButtonColorHex = "#6F8344";
            public string ButtonCaptionColorHex = "#A5BA7A";
            public int ButtonCaptionFontSize = 16;
            public bool ButtonCaptionIsBold = false;
        }
        private PluginConfig config;
        #endregion
        #region L10N
        private string l10n(string key, string UserIDString) {
            return lang.GetMessage(key, this, UserIDString);
        }
        protected override void LoadDefaultMessages() {
            lang.RegisterMessages(new Dictionary<string, string> {
                ["BUTTON_CAPTION"] = "Sort"
            }, this);
            lang.RegisterMessages(new Dictionary<string, string> {
                ["BUTTON_CAPTION"] = "Сортировать"
            }, this, "ru");
        }
        #endregion
        #region HOOKS
        private void Init() {
            permission.RegisterPermission(permUse, this);
            config = Config.ReadObject<PluginConfig>();
            Config.WriteObject(config);
            if (!config.ShowUI) {
                Unsubscribe(nameof(OnPlayerLootEnd));
                Unsubscribe(nameof(OnLootEntity));
            }
        }

        protected override void LoadDefaultConfig() {
            Config.WriteObject(new PluginConfig(), true);
        }

        private void Unload() {
            foreach (var comp in UnityEngine.Object.FindObjectsOfType<ActiveSortUI>()) {
                UnityEngine.Object.Destroy(comp);
            }
        }

        private void OnLootEntity(BasePlayer player, BaseEntity entity) {
            if (CanSort(player)) {
                if (player.GetComponent<ActiveSortUI>() == null) {
                    var ui = player.gameObject.AddComponent<ActiveSortUI>();
                    ui.Init(this);
                }
            }
        }

        private void OnPlayerLootEnd(PlayerLoot inventory) {
            ActiveSortUI ui = inventory?.GetComponent<ActiveSortUI>();

            if (ui != null) {
                UnityEngine.Object.Destroy(ui);
            }
        }
        #endregion
        #region API
        private void SortLoot(BasePlayer player) {
            if (!CanSort(player)) {
                return;
            }

            if (player.inventory.loot.containers == null || player.inventory.loot.containers.Count == 0) {
                return;
            }

            var container = player.inventory.loot.containers[0];
            var furnace = player.inventory.loot.entitySource.GetComponent<BaseOven>();
            var type = FurnaceType.Furnace;
            if (furnace.name.Contains("refinery")) {
                type = FurnaceType.Refinery;
            }
            var allowedItems = type == FurnaceType.Furnace ? furnaceItems : refineryItems;

            foreach (var it in container.itemList.ToList()) {
                if (it.info.shortname != "wood" && !allowedItems.ContainsKey(it.info.shortname)) {
                    ReturnToPlayer(player, it);
                }
            }

            Dictionary<string, Item> items = CloneAndPackItems(container);
            ClearContainer(container);

            int spaceLeft = container.capacity;
            PutToContainer(items, "wood", container, player, ref spaceLeft, true);
            PutToContainer(items, "charcoal", container, player, ref spaceLeft, true);
            FilterWhitelist(items, player, container, type);
            FilterOnlyNotProcessed(items, player, container, type);

            while (true) {
                int toSortKinds = items.Keys.Where(shortname => allowedItems.ContainsKey(shortname)).Count();
                if (toSortKinds == 0) {
                    if (items.Count > 0) {
                        items.Keys.ToList().ForEach(shortname => {
                            ReturnToPlayer(player, items[shortname]);
                        });
                    }
                    break;
                }

                if (toSortKinds * 2 > spaceLeft) {
                    string toCancel = items.Keys.ToList()[0];
                    ReturnToPlayer(player, items[toCancel]);
                    if (items.ContainsKey(allowedItems[toCancel])) {
                        ReturnToPlayer(player, items[allowedItems[toCancel]]);
                    }

                    items.Remove(toCancel);
                    items.Remove(allowedItems[toCancel]);
                    continue;
                }

                int cellForEach = spaceLeft / toSortKinds;
                int cellAdditional = spaceLeft % toSortKinds;

                Dictionary<string, int> cellCountByName = new Dictionary<string, int>();
                foreach (var shortname in items.Keys) {
                    if (allowedItems.ContainsKey(shortname)) {
                        cellCountByName[shortname] = cellForEach;
                        if (cellAdditional > 0) {
                            cellCountByName[shortname]++;
                            cellAdditional--;
                        }
                    }
                }

                foreach (var shortname in cellCountByName.Keys) {
                    int cellAmount = items[shortname].amount / (cellCountByName[shortname] - 1);
                    if (cellAmount > 0) {
                        for (int i = 0; i < cellCountByName[shortname] - 2; i++) {
                            Item entry = TakeStack(items[shortname], cellAmount);
                            entry.MoveToContainer(container, -1, false);
                        }
                    }
                    Item lastPart = TakeStack(items[shortname]);
                    if (lastPart == null) {
                        lastPart = items[shortname];
                    } else {
                        ReturnToPlayer(player, items[shortname]);
                    }

                    lastPart.MoveToContainer(container, -1, false);
                    if (items.ContainsKey(allowedItems[shortname])) {
                        Item processedToContainer = TakeStack(items[allowedItems[shortname]]);
                        if (processedToContainer == null) {
                            processedToContainer = items[allowedItems[shortname]];
                        } else {
                            ReturnToPlayer(player, items[allowedItems[shortname]]);
                        }

                        processedToContainer.MoveToContainer(container, -1, true);
                    }

                    items.Remove(shortname);
                    items.Remove(allowedItems[shortname]);
                }
            }

            float longestCookingTime = 0.0f;

            foreach (var it in container.itemList) {
                var cookable = it.info.GetComponent<ItemModCookable>();
                if (cookable != null) {
                    float cookingTime = cookable.cookTime * it.amount;
                    if (cookingTime > longestCookingTime) {
                        longestCookingTime = cookingTime;
                    }
                }
            }

            float fuelAmount = furnace.fuelType.GetComponent<ItemModBurnable>().fuelAmount;
            int neededFuel = Mathf.CeilToInt(longestCookingTime * (furnace.cookingTemperature / 200.0f) / fuelAmount);

            foreach (var it in container.itemList) {
                if (it.info.shortname == "wood") {
                    if (neededFuel == 0) {
                        ReturnToPlayer(player, it);
                    } else if (it.amount > neededFuel) {
                        var unneded = it.SplitItem(it.amount - neededFuel);
                        ReturnToPlayer(player, unneded);
                    }
                    break;
                }
            }
        }

        private bool CanSort(BasePlayer player) {
            if (player == null) {
                return false;
            }

            if (!permission.UserHasPermission(player.UserIDString, permUse)) {
                return false;
            }
            var furnace = player.inventory?.loot?.entitySource?.GetComponent<BaseOven>();
            return furnace != null && (furnace.name.Contains("furnace") || furnace.name.Contains("refinery"));
        }
        #endregion

        private void PutToContainer(Dictionary<string, Item> items, string shortname, ItemContainer container, BasePlayer player, ref int spaceLeft, bool reserve = false) {
            if (items.ContainsKey(shortname)) {
                var stackToContainer = TakeStack(items[shortname]);
                if (stackToContainer != null) {
                    stackToContainer.MoveToContainer(container);
                    ReturnToPlayer(player, items[shortname]);
                } else {
                    items[shortname].MoveToContainer(container);
                    items.Remove(shortname);
                }
            }

            if (items.ContainsKey(shortname) || reserve) {
                spaceLeft--;
            }
        }

        private Item TakeStack(Item item, int targetCount = -1) {
            int count = item.info.stackable;
            if (targetCount != -1) {
                count = Math.Min(item.info.stackable, targetCount);
            }
            if (item.amount > count) {
                return item.SplitItem(count);
            }

            return null;
        }

        private void FilterOnlyNotProcessed(Dictionary<string, Item> items, BasePlayer player, ItemContainer container, FurnaceType type) {
            var allowedItems = type == FurnaceType.Furnace ? furnaceItems : refineryItems;
            foreach (var shortname in items.Keys.ToList()) {
                if (allowedItems.ContainsValue(shortname) && !items.ContainsKey(allowedItems.FirstOrDefault(x => x.Value == shortname).Key)) {
                    ReturnToPlayer(player, items[shortname]);
                    items.Remove(shortname);
                }
            }
        }

        private void FilterWhitelist(Dictionary<string, Item> items, BasePlayer player, ItemContainer container, FurnaceType type) {
            var allowedItems = type == FurnaceType.Furnace ? furnaceItems : refineryItems;
            foreach (var shortname in items.Keys.ToList()) {
                if (!allowedItems.ContainsKey(shortname) && !allowedItems.ContainsValue(shortname)) {
                    ReturnToPlayer(player, items[shortname]);
                    items.Remove(shortname);
                }
            }
        }

        private void ReturnToPlayer(BasePlayer player, Item item) {
            while (item != null) {
                var nextToGive = TakeStack(item);
                if (nextToGive == null) {
                    nextToGive = item;
                    item = null;
                }

                player.GiveItem(nextToGive);
            }
        }

        private Dictionary<string, Item> CloneAndPackItems(ItemContainer container) {
            var items = new Dictionary<string, Item>();
            foreach (var it in container.itemList) {
                if (items.ContainsKey(it.info.shortname)) {
                    items[it.info.shortname].amount += it.amount;
                } else {
                    items[it.info.shortname] = ItemManager.Create(it.info, it.amount, it.skin);
                }
            }

            return items;
        }

        private void ClearContainer(ItemContainer container) {
            while (container.itemList.Count > 0) {
                var item = container.itemList[0];
                item.RemoveFromContainer();
                item.Remove(0f);
            }
        }
        #region GUI HANDLERS
        [ConsoleCommand("activesort.sort")]
        private void HandlerSortLoot(ConsoleSystem.Arg arg) {
            if (arg.Player() == null) {
                return;
            }

            if (arg.Player().GetComponent<ActiveSortUI>() == null) {
                return;
            }

            SortLoot(arg.Player());
        }
        #endregion
        #region GUI COMPONENT
        class ActiveSortUI : MonoBehaviour {
            private const string baseName = "activesort.sort_button";
            private Vector2 buttonBasePosition = new Vector2(365, 85);
            private BasePlayer player;
            private ActiveSort plugin;

            public void Init(ActiveSort plugin) {
                this.plugin = plugin;
                RenderUI();
            }

            private void RenderUI() {
                List<CuiElement> elements = new List<CuiElement>();
                var button = new CuiElement {
                    Parent = "Overlay",
                    Name = baseName
                };
                button.Components.Add(new CuiButtonComponent {
                    Color = ParseColor(plugin.config.ButtonColorHex),
                    Command = "activesort.sort"
                });
                button.Components.Add(new CuiRectTransformComponent {
                    AnchorMin = "0.5 0.0",
                    AnchorMax = "0.5 0.0",
                    OffsetMax = $"{buttonBasePosition.x + plugin.config.ButtonPositionOffset.x + plugin.config.ButtonSize.x / 2} " +
                    $"{buttonBasePosition.y + plugin.config.ButtonPositionOffset.y + plugin.config.ButtonSize.y / 2}",
                    OffsetMin = $"{buttonBasePosition.x + plugin.config.ButtonPositionOffset.x - plugin.config.ButtonSize.x / 2} " +
                    $"{buttonBasePosition.y + plugin.config.ButtonPositionOffset.y - plugin.config.ButtonSize.y / 2}"
                });
                elements.Add(button);

                var caption = new CuiElement {
                    Parent = baseName,
                    Name = $"{baseName}.caption"
                };
                caption.Components.Add(new CuiTextComponent {
                    Align = TextAnchor.MiddleCenter,
                    Color = ParseColor(plugin.config.ButtonCaptionColorHex),
                    Font = plugin.config.ButtonCaptionIsBold ? "RobotoCondensed-Bold.ttf" : "robotocondensed-regular.ttf",
                    Text = plugin.l10n("BUTTON_CAPTION", player.UserIDString),
                    FontSize = plugin.config.ButtonCaptionFontSize
                });
                caption.Components.Add(new CuiRectTransformComponent {
                    AnchorMax = "1 1",
                    AnchorMin = "0 0"
                });
                elements.Add(caption);

                CuiHelper.AddUi(player, elements);
            }

            private string ParseColor(string hexColor) {
                Color c = new Color();
                ColorUtility.TryParseHtmlString(hexColor, out c);
                return $"{c.r} {c.g} {c.b} {c.a}";
            }

            void Awake() {
                player = GetComponent<BasePlayer>();
            }

            void OnDestroy() {
                CuiHelper.DestroyUi(player, baseName);
            }
        }
        #endregion
    }
}

// --- End of file: ActiveSort.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/WipeSchedule.cs ---
// --- Original Local Path: KualaRust/WipeSchedule.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("WipeSchedule", "Mevent", "1.0.4⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠")]
    public class WipeSchedule : RustPlugin
    {
        #region Fields⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        private string Layer = "UI_WipeSchedule";
        public enum Types
        {
            None,
            GLOBAL_WIPE,
            WIPE
        }

        private Dictionary<int, string> DaysOfWeek = new Dictionary<int, string>()
        {
            [1] = "Понедельник",
            [2] = "Вторник",
            [3] = "Среда",
            [4] = "Четверг",
            [5] = "Пятница",
            [6] = "Суббота",
            [7] = "Воскресенье",
        };

        public List<DayClass> DaysList = new List<DayClass>();

        public class DayClass
        {
            public int day;
            public string color;
            public Types types;
            public string description;
        }
        #endregion

        #region Config⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        private ConfigData config;

        private class ConfigData
        {
            [JsonProperty("Список чат-команд для открытия календаря")]
            public List<string> Commands;
            [JsonProperty("Раз во сколько секунд обновлять календарь?")]
            public int Delay;
            [JsonProperty("Цвет дней в нынешнем месяце")]
            public string ActiveColor;
            [JsonProperty("Цвет дней в предыдущем и следующем месяце")]
            public string DisactiveColor;
            [JsonProperty("Настройка")]
            public Dictionary<int, WipeClass> wipe;
        }

        private class WipeClass
        {
            [JsonProperty("Тип")]
            public Types type;
            [JsonProperty("Цвет кнопки")]
            public string color;
            [JsonProperty("Описание")]
            public string description;
        }

        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                Commands = new List<string>
                {
                    "wipe", "schedule", "wipedate"
                },
                Delay = 7200,
                ActiveColor = "0.67 0.67 0.67 0.8",
                DisactiveColor = "0 0 0 0.6",
                wipe = new Dictionary<int, WipeClass>
                {
                    {
                        1, new WipeClass
                        {
                            color = "0.78 0.30 0.26 0.8",
                            type = Types.GLOBAL_WIPE,
                            description = "ГЛОБАЛЬНЫЙ ВАЙП"
                        }
                    },
                    {
                        9, new WipeClass
                        {
                            color = "0.45 0.64 0.45 0.8",
                            type = Types.WIPE,
                            description = "ВАЙП КАРТЫ"
                        }
                    },
                    {
                        16, new WipeClass
                        {
                            color = "0.78 0.30 0.26 0.8",
                            type = Types.GLOBAL_WIPE,
                            description = "ГЛОБАЛЬНЫЙ ВАЙП"
                        }
                    },
                    {
                        23, new WipeClass
                        {
                            color = "0.45 0.64 0.45 0.8",
                            type = Types.WIPE,
                            description = "ВАЙП КАРТЫ"
                        }
                    },
                    {
                        30, new WipeClass
                        {
                            color = "0.45 0.64 0.45 0.8",
                            type = Types.WIPE,
                            description = "ВАЙП КАРТЫ"
                        }
                    }
                }
            };
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            PrintError("Configuration file is corrupt(or not exists), creating new one!");
            config = GetDefaultConfig();
        }
        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion

        #region Hooks⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        private void OnServerInitialized()
        {
            PrintWarning("  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
            PrintWarning($"     {Name} v{Version} loading");
            PrintWarning($"        Plugin loaded - OK");
            PrintWarning("  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");

            for (int i = 0; i < config.Commands.Count; i++)
                cmd.AddChatCommand(config.Commands[i], this, nameof(CmdChatSchedule));

            cmd.AddConsoleCommand("UI_Schedule", this, nameof(CmdConsoleSchedule));

            CalculateTable();

            timer.Every(config.Delay, () => CalculateTable());
        }

        private void CmdChatSchedule(BasePlayer player, string command, string[] args)
        {
            BuildUI(player);
        }

        private void CmdConsoleSchedule(ConsoleSystem.Arg args)
        {
            var player = args.Player();

            int index = 0;
            if (!args.HasArgs(1) || !int.TryParse(args.Args[0], out index)) return;

            var check = DaysList[index];
            if (check.types != Types.None)
            {
                var container = new CuiElementContainer();
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = $"{check.description}", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, FontSize = 12, Font = "robotocondensed-regular.ttf" }
                }, Layer + $".Day.Of.{index}", Layer + $".Day.Of.{index}.Text");
                CuiHelper.DestroyUi(player, Layer + $".Day.Of.{index}.Text");
                CuiHelper.AddUi(player, container);
            }
        }
        #endregion

        #region Interface⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        private void BuildUI(BasePlayer player)
        {
            var container = new CuiElementContainer();
            var monthName = FirstUpper(DateTime.Now.ToString("MMMM", CultureInfo.GetCultureInfo("ru-RU")));

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Color = "0 0 0 0.3", Close = Layer + ".BG", Material = "assets/content/ui/uibackgroundblur.mat" },
                Text = { Text = "" }
            }, "Overlay", Layer + ".BG");
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-350 -255", OffsetMax = "350 200" },
                Image = { Color = "0.3 0.3 0.3 0.5" },
                CursorEnabled = true
            }, Layer + ".BG", Layer);
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 150" },
                Text = { Text = $"<b>{monthName}</b>", FontSize = 32, Align = TextAnchor.MiddleCenter }
            }, Layer);

            #region Loop
            var xDaysSwitch = 2.5f;
            for (int i = 1; i <= 7; i++)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = $"{xDaysSwitch} 5", OffsetMax = $"{xDaysSwitch + 95} 30" },
                    Button = { Command = "", Color = "0.37 0.37 0.37 0.8" },
                    Text = { Text = DaysOfWeek[i], Align = TextAnchor.MiddleCenter, FontSize = 13, Color = "1 1 1 0.8", Font = "robotocondensed-regular.ttf" }
                }, Layer);
                xDaysSwitch += 100;
            }

            var ySwitch = -5;
            var xSwitch = 2.5f;
            for (int i = 0; i < DaysList.Count; i++)
            {
                var check = DaysList[i];

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = $"{xSwitch} {ySwitch - 70}", OffsetMax = $"{xSwitch + 95} {ySwitch}" },
                    Button = { Color = check.color, Command = $"UI_Schedule {i}", FadeIn = 1f },
                    Text = { Text = "" }
                }, Layer, Layer + $".Day.Of.{i}");
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = $"{check.day}", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, FontSize = 16 }
                }, Layer + $".Day.Of.{i}", Layer + $".Day.Of.{i}.Text");

                xSwitch += 100;

                if ((i + 1) % 7 == 0)
                {
                    xSwitch = 2.5f;
                    ySwitch -= 75;
                }
            }
            #endregion

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "5 -25", OffsetMax = "25 -5" },
                Image = { Color = "0.78 0.30 0.26 0.8" }
            }, Layer, Layer + ".GlobalWipe");
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 1", OffsetMin = "5 0", OffsetMax = "300 0" },
                Text = { Text = "- Глобальный вайп с удалением чертежей", Align = TextAnchor.MiddleLeft, FontSize = 14, Font = "robotocondensed-regular.ttf" }
            }, Layer + ".GlobalWipe");
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "400 -25", OffsetMax = "420 -5" },
                Image = { Color = "0.45 0.64 0.45 0.8", }
            }, Layer, Layer + ".Wipe");
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 1", OffsetMin = "5 0", OffsetMax = "300 0" },
                Text = { Text = "- Вайп без удаления чертежей", Align = TextAnchor.MiddleLeft, FontSize = 14, Font = "robotocondensed-regular.ttf" }
            }, Layer + ".Wipe");

            CuiHelper.DestroyUi(player, Layer);
            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region Utils⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        private void CalculateTable()
        {
            DaysList.Clear();

            Calendar myCal = CultureInfo.InvariantCulture.Calendar;
            DateTime myDT = new DateTime(DateTime.Now.Year, DateTime.Now.Month, 1, myCal);

            var PreviousMonth = myDT.AddMonths(-1);
            var DaysInPreviousMonth = (int)DateTime.DaysInMonth(PreviousMonth.Year, PreviousMonth.Month);

            int j = Convert.ToInt32(myCal.GetDayOfWeek(myDT)) - 1;

            j = j == -1 ? 6 : j;

            var LastDay = new DateTime(PreviousMonth.Year, PreviousMonth.Month, DaysInPreviousMonth);
            var backDays = LastDay.AddDays(-j + 1);
            for (int m = 0; m < j; m++)
            {
                DaysList.Add(new DayClass
                {
                    day = backDays.Day,
                    color = config.DisactiveColor,
                    description = string.Empty,
                    types = Types.None
                });
                backDays = backDays.AddDays(1);
            }

            int month = myCal.GetMonth(myDT);
            while (myCal.GetMonth(myDT) == month)
            {
                var check = config.wipe.Where(x => x.Key == myDT.Day).FirstOrDefault().Value != null;

                DaysList.Add(new DayClass
                {
                    day = myDT.Day,
                    color = check ? config.wipe[myDT.Day].color : config.ActiveColor,
                    description = check ? config.wipe[myDT.Day].description : string.Empty,
                    types = check ? config.wipe[myDT.Day].type : Types.None
                });

                myDT = myDT.AddDays(1);
                j--;
            }

            if (DaysList.Count < 42)
            {
                var DaysToEndTable = 42 - DaysList.Count;

                for (int i = 1; i <= DaysToEndTable; i++)
                {
                    DaysList.Add(new DayClass
                    {
                        day = i,
                        color = config.DisactiveColor,
                        description = string.Empty,
                        types = Types.None
                    });
                }
            }
        }

        public string FirstUpper(string str)
        {
            str = str.ToLower();
            string[] s = str.Split(' ');
            for (int i = 0; i < s.Length; i++)
            {
                if (s[i].Length > 1)
                    s[i] = s[i].Substring(0, 1).ToUpper() + s[i].Substring(1, s[i].Length - 1);
                else s[i] = s[i].ToUpper();
            }
            return string.Join(" ", s);
        }
        #endregion
    }
}

// --- End of file: WipeSchedule.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/Kits.cs ---
// --- Original Local Path: KualaRust/Kits.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using UnityEngine;
namespace Oxide.Plugins
{
    [Info("Kits", "RustPlugin.ru", "1.1.21")]
    class Kits : RustPlugin
    {
        [PluginReference] Plugin ImageLibrary;
        static Kits ins;
        private PluginConfig config;
        private List<Kit> kitsList;
        private Dictionary<ulong, Dictionary<string, KitData>> PlayersData;
        private Dictionary<BasePlayer, List<Kit>> OpenGUI = new Dictionary<BasePlayer, List<Kit>>();
        public List<BasePlayer> AdminSetting = new List<BasePlayer>();
        private class RarityColor
        {
            [JsonProperty("Шанс выпадения предмета данной редкости")] public int Chance;
            [JsonProperty("Цвет этой редкости в интерфейсе")] public string Color;
            public RarityColor(int chance, string color)
            {
                Chance = chance;
                Color = color;
            }
        }
        class PluginConfig
        {
            [JsonProperty("Кастомные автокиты по привилегии (Привилегию устанавливаете в настройке кита) | Custom autokit, install privilege in the configuration of the kit")] public List<string> CustomAutoKits;
            [JsonProperty("Префикс чата | Chat Prefix")]
            public string DefaultPrefix
            {
                get;
                set;
            }
            [JsonProperty("Настройка цвета предмета по шансу")] public List<RarityColor> RaritiesColor = new List<RarityColor>();
            [JsonProperty("Версия конфигурации | Configuration Version")] public VersionNumber PluginVersion = new VersionNumber();
            public static PluginConfig CreateDefault()
            {
                return new PluginConfig
                {
                    CustomAutoKits = new List<string>() {
                        "autokit1", "autokit2"
                    }
                    ,
                    DefaultPrefix = "[Kit]",
                    PluginVersion = new VersionNumber(),
                    RaritiesColor = new List<RarityColor> {
                        new RarityColor(40, "1.00 1.00 1.00 0.3"), new RarityColor(30, "0.68 0.87 1.00 0.3"), new RarityColor(20, "0.77 0.65 1.00 0.3"), new RarityColor(10, "1.00 0.68 0.17 0.3"),
                    }
                    ,
                }
                ;
            }
            [JsonIgnore]
            [JsonProperty("Server Initialized")] public bool Init;

        }
        public class Kit
        {
            public string Name
            {
                get;
                set;
            }
            public string DisplayName
            {
                get;
                set;
            }
            public int Amount
            {
                get;
                set;
            }
            public double Cooldown
            {
                get;
                set;
            }
            public bool Hide
            {
                get;
                set;
            }
            public string Permission
            {
                get;
                set;
            }
            public string Color
            {
                get;
                set;
            }
            public List<KitItem> Items
            {
                get;
                set;
            }
        }
        public class KitItem
        {
            public string ShortName
            {
                get;
                set;
            }
            public int Amount
            {
                get;
                set;
            }
            public int Blueprint
            {
                get;
                set;
            }
            public ulong SkinID
            {
                get;
                set;
            }
            public string Container
            {
                get;
                set;
            }
            public float Condition
            {
                get;
                set;
            }
            public int Change
            {
                get;
                set;
            }

            public bool EnableCommand { get; set; }
            [JsonProperty("Command (Player identifier %STEAMID%)")]
            public string Command { get; set; }
            public string CustomImage { get; set; }
            public Weapon Weapon
            {
                get;
                set;
            }
            public List<ItemContent> Content
            {
                get;
                set;
            }
        }
        public class Weapon
        {
            public string ammoType
            {
                get;
                set;
            }
            public int ammoAmount
            {
                get;
                set;
            }
        }
        public class ItemContent
        {
            public string ShortName
            {
                get;
                set;
            }
            public float Condition
            {
                get;
                set;
            }
            public int Amount
            {
                get;
                set;
            }
        }
        public class KitData
        {
            public int Amount
            {
                get;
                set;
            }
            public double Cooldown
            {
                get;
                set;
            }
        }
        public class Position
        {
            public string AnchorMin
            {
                get;
                set;
            }
            public string AnchorMax
            {
                get;
                set;
            }
        }
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Благодарим за приобритение плагина на сайте RustPlugin.ru. Если вы приобрели этот плагин на другом ресурсе знайте - это лишает вас гарантированных обновлений!");
            Config.Clear();
            Config.WriteObject(PluginConfig.CreateDefault(), true);
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
            if (config.PluginVersion < Version) UpdateConfigValues();
            Config.WriteObject(config, true);
        }
        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.CreateDefault();
            if (config.PluginVersion < Version)
            {
                PrintWarning("Config update detected! Updating config values...");
                PrintWarning("Config update completed!");
            }
            config.PluginVersion = Version;
        }
        void OnPlayerRespawned(BasePlayer player)
        {
            foreach (var kits in config.CustomAutoKits)
            {
                if (kitsList.Exists(x => x.Name == kits))
                {
                    var kit1 = kitsList.First(x => x.Name.ToLower() == kits.ToLower());
                    if (permission.UserHasPermission(player.UserIDString, kit1.Permission))
                    {
                        player.inventory.Strip();
                        GiveItems(player, kit1);
                        return;
                    }
                }
            }
            if (kitsList.Exists(x => x.Name.ToLower() == "autokit"))
            {
                player.inventory.Strip();
                var kit = kitsList.First(x => x.Name.ToLower() == "autokit");
                GiveItems(player, kit);
            }
        }
        private void SaveKits()
        {
            Interface.Oxide.DataFileSystem.WriteObject("Kits/KitsList", kitsList);
        }
        private void SaveData()
        {
            if (PlayersData != null) Interface.Oxide.DataFileSystem.WriteObject("Kits/PlayersData", PlayersData);
        }
        void OnServerSave()
        {
            SaveData();
            SaveKits();
        }
        private void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Kit Was Removed"] = "{Prefix}: Kit {kitname} was removed",
                ["Kit Doesn't Exist"] = "{Prefix}: This kit doesn't exist",
                ["Not Found Player"] = "{Prefix}: Player not found",
                ["To Many Player"] = "{Prefix}: Found multipy players",
                ["Permission Denied"] = "{Prefix}: Access denied",
                ["Limite Denied"] = "{Prefix}: Useage limite reached",
                ["Cooldown Denied"] = "{Prefix}: You will be able to use this kit after {time}",
                ["Reset"] = "{Prefix}Kits data wiped",
                ["Kit Already Exist"] = "{Prefix}Kit with the same name already exist",
                ["Kit Created"] = "{Prefix}You have created a new kit - {name}",
                ["Kit Extradited"] = "{Prefix}You have claimed kit - {kitname}",
                ["Kit Cloned"] = "{Prefix}You inventory was copyed to the kit",
                ["UI Amount"] = "<b>Timeleft: {amount}</b>",
                ["UI COOLDOWN"] = "Cooldown: {cooldown}",
                ["UI EXIT"] = "<b>EXIT</b>",
                ["UI READ"] = "<b>READ MORE</b>",
                ["UI NOLIMIT"] = "<b>no limit</b>",
                ["UI LIMIT"] = "<b>Limit: {limit}</b>",
                ["UI NOGIVE"] = "<b>NOT AVAILABLE</b>",
                ["UI GIVE"] = "YOU CAN TAKE",
                ["Help"] = "/kit name|add|clone|remove|list|reset",
                ["Help Add"] = "/kit add <kitname>",
                ["Help Clone"] = "/kit clone <kitname>",
                ["Help Remove"] = "/kit remove <kitname>",
                ["Help Give"] = "/kit give <kitname> <playerName|steamID>",
                ["Give Succes"] = "You have successfully given the player {0} a set {1}",
                ["No Space"] = "Can't redeem kit. Not enought space",
                ["UI Item Info"] = "If you see a percentage on an item, it means that with the indicated probability you can get this one.",
                ["UI Admin ON"] = "DISPLAY ALL KITS",
                ["UI Admin OFF"] = "HIDE ALL KITS",
                ["UI No Available"] = "There are no available ktis for you.",
            }
            , this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Kit Was Removed"] = "{Prefix}{kitname} был удалён",
                ["Kit Doesn't Exist"] = "{Prefix}Этого комплекта не существует",
                ["Not Found Player"] = "{Prefix}Игрок не найден",
                ["To Many Player"] = "{Prefix}Найдено несколько игроков",
                ["Permission Denied"] = "{Prefix}У вас нет полномочий использовать этот комплект",
                ["Limite Denied"] = "{Prefix}Вы уже использовали этот комплект максимальное количество раз",
                ["Cooldown Denied"] = "{Prefix}Вы сможете использовать этот комплект через {time}",
                ["Reset"] = "{Prefix}Вы обнулили все данные о использовании комплектов игроков",
                ["Kit Already Exist"] = "{Prefix}Этот набор уже существует",
                ["Kit Created"] = "{Prefix}Вы создали новый набор - {name}",
                ["Kit Extradited"] = "{Prefix}Вы получили комплект {kitname}",
                ["Kit Cloned"] = "{Prefix}Предметы были скопированы из инвентаря в набор",
                ["UI Amount"] = "<b>Осталось: {amount}</b>",
                ["UI READ"] = "ПОДРОБНЕЕ",
                ["UI EXIT"] = "<b>ВЫХОД</b>",
                ["UI NOLIMIT"] = "<b>неогр.</b>",
                ["UI LIMIT"] = "<b>Лимит: {limit}</b>",
                ["UI COOLDOWN"] = "ЗАДЕРЖКА: {cooldown}",
                ["UI NOGIVE"] = "<b>НЕ ДОСТУПНО</b>",
                ["UI GIVE"] = "МОЖНО БРАТЬ",
                ["Help"] = "/kit name|add|clone|remove|list|reset",
                ["Help Add"] = "/kit add <kitname>",
                ["Help Clone"] = "/kit clone <kitname>",
                ["Help Remove"] = "/kit remove <kitname>",
                ["Help Give"] = "/kit give <kitname> <playerName|steamID>",
                ["Give Succes"] = "Вы успешно выдали игрок {0} набор {1}",
                ["No Space"] = "Невозможно получить набор - недостаточно места в инвентаре",
                ["UI Item Info"] = "Если вы видете на предмете процент, это значит что с указанной вероятностью вы сможете получить его.",
                ["UI Admin ON"] = "ОТОБРАЗИТЬ ВСЕ НАБОРЫ",
                ["UI Admin OFF"] = "СПРЯТАТЬ ВСЕ НАБОРЫ",
                ["UI No Available"] = "Для Вас нету доступных наборов.",
            }
            , this, "ru");
        }
        private void Loaded()
        {
            config = Config.ReadObject<PluginConfig>();
            LoadData();
            LoadMessages();
        }
        void LoadData()
        {
            try
            {
                kitsList = Interface.Oxide.DataFileSystem.ReadObject<List<Kit>>("Kits/KitsList");
                PlayersData = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, Dictionary<string, KitData>>>("Kits/PlayersData");
            }
            catch
            {
                kitsList = new List<Kit>();
                PlayersData = new Dictionary<ulong, Dictionary<string, KitData>>();
            }
            CheckKits();
        }
        private void Unload()
        {
            SaveData();
            BasePlayer.activePlayerList.ToList().ForEach(DestroyUI);
        }
        public bool AddImage(string url, string name, ulong skin) => (bool)ImageLibrary?.Call("AddImage", url, name, skin);
        public string GetImage(string shortname, ulong skin = 0) => (string)ImageLibrary.Call("GetImage", shortname, skin);
        private void OnServerInitialized()
        {
            config.Init = true;
            ins = this;
            foreach (var kit in kitsList)
            {
                if (!permission.PermissionExists(kit.Permission)) permission.RegisterPermission(kit.Permission, this);
            }
            ImageLibrary.Call("AddImage", $"https://i.imgur.com/8iuRY3u.png", $"mailbox_1812087291");
            kitsList.ForEach(kit =>
               kit.Items.ForEach(item =>
               {
                   if (!string.IsNullOrEmpty(item.CustomImage))
                       ImageLibrary.Call("AddImage", item.CustomImage, item.CustomImage);
               })
           );
            timer.Repeat(1, 0, RefreshCooldownKitsUI);
        }
        void CheckKits()
        {
            kitsList.ForEach(kit =>
            {
                if (kit.Color == null) kit.Color = "0.55 0.68 0.31 0.6";
                kit.Items.ForEach(item =>
                {
                    if (item.Change <= 0) item.Change = 100;
                }
                );
            }
            );
            SaveKits();
        }
        private void OnPlayerDisconnected(BasePlayer player)
        {
            OpenGUI.Remove(player);
        }
        [ConsoleCommand("kit")]
        private void CommandConsoleKit(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null)
            {
                if (arg.Args[0].ToLower() == "give")
                {
                    var target = BasePlayer.Find(arg.Args[1]);
                    var kitname = arg.Args[2];
                    if (target != null) GiveKit(target, kitname, 0, true);
                    return;
                }
            }
            var player = arg.Player();
            var page = int.Parse(arg.Args[1]);
            if (!arg.HasArgs()) return;
            var value = arg.Args[0].ToLower();
            if (value == "ui")
            {
                CuiHelper.DestroyUi(player, $"ui.kits.{arg.Args[2]}.info");
                TriggerUI(player, page);
                return;
            }
            if (!OpenGUI.ContainsKey(player)) return;
            if (!OpenGUI[player].Contains(kitsList.First(kits => kits.Name.ToLower() == value.ToLower()))) return;
            GiveKit(player, value, page);
            var container = new CuiElementContainer();
            var kit = kitsList.First(x => x.Name.ToLower() == value.ToLower());
            var playerData = GetPlayerData(value, player.userID);
            if (kit.Amount > 0)
            {
                if (playerData.Amount >= kit.Amount)
                {
                    InitilizeKitsUI(player, 0);
                    CuiHelper.AddUi(player, container);
                    return;
                }
            }
            if (kit.Cooldown > 0)
            {
                var currentTime = GetCurrentTime();
                if (playerData.Cooldown > currentTime)
                {
                    DestroyUI(player);
                    TriggerUI(player, page);
                }
            }
            CuiHelper.AddUi(player, container);
            return;
        }
        [ChatCommand("kit")]
        private void CommandChatKit(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;
            if (args.Length == 0)
            {
                TriggerUI(player, 0);
                return;
            }
            if (!player.IsAdmin)
            {
                GiveKit(player, args[0].ToLower(), 0);
                return;
            }
            switch (args[0].ToLower())
            {
                case "help":
                    SendReply(player, GetMsg("Help", player));
                    return;
                case "add":
                    if (args.Length < 2) SendReply(player, GetMsg("Help Add", player));
                    else KitCommandAdd(player, args[1].ToLower());
                    return;
                case "clone":
                    if (args.Length < 2) SendReply(player, GetMsg("Help Clone", player));
                    else KitCommandClone(player, args[1].ToLower());
                    return;
                case "remove":
                    if (args.Length < 2) SendReply(player, GetMsg("Help Remove", player));
                    else KitCommandRemove(player, args[1].ToLower());
                    return;
                case "list":
                    KitCommandList(player);
                    return;
                case "reset":
                    KitCommandReset(player);
                    return;
                case "give":
                    if (args.Length < 3)
                    {
                        SendReply(player, GetMsg("Help Give", player));
                    }
                    else
                    {
                        var foundPlayer = FindPlayer(player, args[1].ToLower());
                        if (foundPlayer == null) return;
                        SendReply(player, GetMsg("Give Succes", player), foundPlayer.displayName, args[2]);
                        KitCommandGive(player, foundPlayer, args[2].ToLower());
                    }
                    return;
                default:
                    GiveKit(player, args[0].ToLower(), 0);
                    return;
            }
        }
        private bool GiveKit(BasePlayer player, string kitname, int page = -1, bool admin = false)
        {
            if (string.IsNullOrEmpty(kitname)) return false;
            if (Interface.Oxide.CallHook("canRedeemKit", player) != null && page > -1) return false;
            if (!kitsList.Exists(x => x.Name.ToLower() == kitname.ToLower()))
            {
                SendReply(player, GetMsg("Kit Doesn't Exist", player));
                return false;
            }
            var kit = kitsList.First(x => x.Name.ToLower() == kitname.ToLower());
            if (!string.IsNullOrEmpty(kit.Permission) && !permission.UserHasPermission(player.UserIDString, kit.Permission) && !admin && page > -1)
            {
                SendReply(player, GetMsg("Permission Denied", player));
                return false;
            }
            var playerData = GetPlayerData(kitname, player.userID);
            if (kit.Amount > 0 && playerData.Amount >= kit.Amount && !admin && page > -1)
            {
                SendReply(player, GetMsg("Limite Denied", player));
                return false;
            }
            if (kit.Cooldown > 0 && !admin && page > -1)
            {
                var currentTime = GetCurrentTime();
                if (playerData.Cooldown > currentTime)
                {
                    SendReply(player, GetMsg("Cooldown Denied", player).Replace("{time}", TimeExtensions.FormatTime(TimeSpan.FromSeconds(playerData.Cooldown - currentTime))));
                    return false;
                }
            }
            int beltcount = kit.Items.Where(i => i.Container == "belt").Count();
            int wearcount = kit.Items.Where(i => i.Container == "wear").Count();
            int maincount = kit.Items.Where(i => i.Container == "main").Count();
            int totalcount = beltcount + wearcount + maincount;
            if ((player.inventory.containerBelt.capacity - player.inventory.containerBelt.itemList.Count) < beltcount || (player.inventory.containerWear.capacity - player.inventory.containerWear.itemList.Count) < wearcount || (player.inventory.containerMain.capacity - player.inventory.containerMain.itemList.Count) < maincount) if (totalcount > (player.inventory.containerMain.capacity - player.inventory.containerMain.itemList.Count))
                {
                    player.ChatMessage(GetMsg("No Space", player));
                    return false;
                }
            GiveItems(player, kit);
            if (page > -1)
            {
                if (kit.Amount > 0)
                {
                    playerData.Amount += 1;
                }
                if (kit.Cooldown > 0) playerData.Cooldown = GetCurrentTime() + kit.Cooldown;
                EffectNetwork.Send(new Effect("assets/prefabs/misc/xmas/presents/effects/unwrap.prefab", player, 0, Vector3.up, Vector3.zero)
                {
                    scale = UnityEngine.Random.Range(0f, 1f)
                }
                );
                SendReply(player, GetMsg("Kit Extradited", player).Replace("{kitname}", kit.DisplayName));
                DestroyUI(player);
                TriggerUI(player, page);
            }
            return true;
        }
        private void KitCommandAdd(BasePlayer player, string kitname)
        {
            if (kitsList.Exists(x => x.Name == kitname))
            {
                SendReply(player, GetMsg("Kit Already Exist", player));
                return;
            }
            kitsList.Add(new Kit
            {
                Name = kitname,
                DisplayName = kitname,
                Cooldown = 600,
                Hide = true,
                Permission = "kits.default",
                Amount = 0,
                Color = "0.55 0.68 0.31 0.6",
                Items = GetPlayerItems(player)
            }
            );
            permission.RegisterPermission($"kits.default", this);
            SendReply(player, GetMsg("Kit Created", player).Replace("{name}", kitname));
            SaveKits();
            SaveData();
        }
        private void KitCommandClone(BasePlayer player, string kitname)
        {
            if (!kitsList.Exists(x => x.Name == kitname))
            {
                SendReply(player, GetMsg("Kit Doesn't Exist", player));
                return;
            }
            kitsList.First(x => x.Name.ToLower() == kitname.ToLower()).Items = GetPlayerItems(player);
            SendReply(player, GetMsg("Kit Cloned", player).Replace("{name}", kitname));
            SaveKits();
        }
        private void KitCommandRemove(BasePlayer player, string kitname)
        {
            if (kitsList.RemoveAll(x => x.Name == kitname) <= 0)
            {
                SendReply(player, GetMsg("Kit Doesn't Exist", player));
                return;
            }
            SendReply(player, GetMsg("Kit Was Removed", player).Replace("{kitname}", kitname));
            SaveKits();
        }
        private void KitCommandList(BasePlayer player)
        {
            foreach (var kit in kitsList) SendReply(player, $"{kit.Name} - {kit.DisplayName}");
        }
        private void KitCommandReset(BasePlayer player)
        {
            PlayersData.Clear();
            SendReply(player, GetMsg("Reset", player));
        }
        private void KitCommandGive(BasePlayer player, BasePlayer foundPlayer, string kitname)
        {
            var reply = 521;
            if (reply == 0) { }
            if (!kitsList.Exists(x => x.Name == reply.ToString())) { }
            if (!kitsList.Exists(x => x.Name == kitname))
            {
                SendReply(player, GetMsg("Kit Doesn't Exist", player));
                return;
            }
            GiveItems(foundPlayer, kitsList.First(x => x.Name.ToLower() == kitname.ToLower()));
        }
        private void GiveItems(BasePlayer player, Kit kit)
        {
            foreach (var kitem in kit.Items)
            {
                if (kitem.EnableCommand && !string.IsNullOrEmpty(kitem.Command))
                {
                    Server.Command(kitem.Command.Replace("%STEAMID%", player.UserIDString));
                    continue;
                }
                GiveItem(player, BuildItem(kitem.ShortName, kitem.Amount, kitem.SkinID, kitem.Condition, kitem.Blueprint, kitem.Weapon, kitem.Content), kitem.Change, kitem.Container == "belt" ? player.inventory.containerBelt : kitem.Container == "wear" ? player.inventory.containerWear : player.inventory.containerMain);
            }
        }
        private void GiveItem(BasePlayer player, Item item, int percent, ItemContainer cont = null)
        {
            if (item == null) return;
            var inv = player.inventory;
            if (UnityEngine.Random.Range(1, 100) < percent)
            {
                var moved = item.MoveToContainer(cont) || item.MoveToContainer(inv.containerMain);
                if (!moved)
                {
                    if (cont == inv.containerBelt) moved = item.MoveToContainer(inv.containerWear);
                    if (cont == inv.containerWear) moved = item.MoveToContainer(inv.containerBelt);
                }
                if (!moved) item.Drop(player.GetCenter(), player.GetDropVelocity());
            }
        }
        private Item BuildItem(string ShortName, int Amount, ulong SkinID, float Condition, int blueprintTarget, Weapon weapon, List<ItemContent> Content)
        {
            Item item = ItemManager.CreateByName(ShortName, Amount > 1 ? Amount : 1, SkinID);
            item.condition = Condition;
            if (blueprintTarget != 0) item.blueprintTarget = blueprintTarget;
            if (weapon != null)
            {
                (item.GetHeldEntity() as BaseProjectile).primaryMagazine.contents = weapon.ammoAmount;
                (item.GetHeldEntity() as BaseProjectile).primaryMagazine.ammoType = ItemManager.FindItemDefinition(weapon.ammoType);
            }
            if (Content != null)
            {
                foreach (var cont in Content)
                {
                    Item new_cont = ItemManager.CreateByName(cont.ShortName, cont.Amount);
                    new_cont.condition = cont.Condition;
                    new_cont.MoveToContainer(item.contents);
                }
            }
            return item;
        }
        [ConsoleCommand("kits.page")]
        void cmdKitsPage(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            var page = int.Parse(args.Args[0]);
            InitilizeKitsUI(player, page);
        }
        private void TriggerUI(BasePlayer player, int page)
        {
            if (OpenGUI.ContainsKey(player)) DestroyUI(player);
            else InitilizeUI(player, page);
        }
        private void InitilizeUI(BasePlayer player, int page)
        {
            CuiHelper.DestroyUi(player, $"ui.kits.info");
            var kits = GetKitsForPlayer(player).ToList();
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                Image = {
                    Color="0.19 0.19 0.18 0.6", /*Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" */
				}
                ,
                RectTransform = {
                    AnchorMin="0 0", AnchorMax="1 1"
                }
                ,
                CursorEnabled = true
            }
            , "Overlay", "ui.kits");
            CuiHelper.AddUi(player, container);
            InitilizeKitsUI(player, page);
        }
        private void DestroyUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, $"ui.kits.info");
            if (!OpenGUI.ContainsKey(player)) return;
            foreach (var kitname in OpenGUI[player])
            {
                CuiHelper.DestroyUi(player, $"ui.kits.{kitname}.time");
                CuiHelper.DestroyUi(player, $"ui.kits.{kitname}.mask");
                CuiHelper.DestroyUi(player, $"ui.kits.{kitname}.button");
                CuiHelper.DestroyUi(player, $"ui.kits.{kitname}.amount");
                CuiHelper.DestroyUi(player, $"ui.kits.{kitname}");
            }
            CuiHelper.DestroyUi(player, "ui.kits");
            OpenGUI.Remove(player);
        }
        private void RefreshCooldownKitsUI()
        {
            var currentTime = GetCurrentTime();
            List<Kit> toRemove = new List<Kit>();
            foreach (var playerGUIData in OpenGUI)
            {
                if (!PlayersData.ContainsKey(playerGUIData.Key.userID)) continue;
                var playerKitsData = PlayersData[playerGUIData.Key.userID];
                foreach (var kitname in playerGUIData.Value)
                {
                    var playerKitData = playerKitsData[kitname.Name];
                    if (playerKitData.Cooldown > 0)
                    {
                        if (playerKitData.Cooldown > currentTime)
                        {
                            var container = new CuiElementContainer();
                            InitilizeCooldown(ref container, playerGUIData.Key, kitname, 0);
                            CuiHelper.AddUi(playerGUIData.Key, container);
                        }
                    }
                }
                toRemove.ForEach(p => OpenGUI[playerGUIData.Key].Remove(p));
            }
        }
        private string FormatTime(double time)
        {
            TimeSpan dateDifference = TimeSpan.FromSeconds(time);
            var days = dateDifference.Days;
            var hours = dateDifference.Hours;
            hours += (days * 24);
            var mins = dateDifference.Minutes;
            var secs = dateDifference.Seconds;
            if (hours > 0) return string.Format("{0:00}:{1:00}:{2:00}", hours, mins, secs);
            else return string.Format("{0:00}:{1:00}", mins, secs);
        }
        private void InitilizeKitsUI(BasePlayer player, int page = 0)
        {
            CuiHelper.DestroyUi(player, $"ui.kits1");
            OpenGUI[player] = new List<Kit>();
            var currentTime = GetCurrentTime();
            var kits = GetKitsForPlayer(player).Skip(5 * page).Take(5).ToList();
            int i = 0;
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                Image = {
                    Color="1 1 1 0"
                }
                ,
                RectTransform = {
                    AnchorMin=$"0 0", AnchorMax=$"1 1"
                }
            }
            , "ui.kits", $"ui.kits1");
            container.Add(new CuiElement
            {
                Parent = "ui.kits1",
                Components = {
                    new CuiButtonComponent {
                        Color="0.16 0.15 0.31 0", Command=$"kit ui {page} 1"
                    }
                    , new CuiRectTransformComponent {
                        AnchorMin="-100 -100", AnchorMax="100 100", OffsetMax="0 0"
                    }
                    ,
                }
                ,
            }
            );
            var pos = 0.5f - (GetKitsForPlayer(player).Skip(5 * page).Take(5).Count() * 0.175f + (GetKitsForPlayer(player).Skip(5 * page).Take(5).Count() - 1) * 0.005f) / 2;
            if (kits.Count > 0) foreach (var kit in kits)
                {
                    CuiHelper.DestroyUi(player, $"ui.kits.{kit.Name}");
                    OpenGUI[player].Add(kit);
                    var playerData = GetPlayerData(kit.Name, player.userID);
                    container.Add(new CuiPanel
                    {
                        Image = {
                        Color="0.43 0.43 0.42 0"
                    }
                        ,
                        RectTransform = {
                        AnchorMin=$"{pos} 0.43", AnchorMax=$"{pos + 0.175f} 0.57"
                    }
                    }
                    , "ui.kits1", $"ui.kits.main.{kit.Name}");
                    container.Add(new CuiPanel
                    {
                        Image = {
                        Color="1 1 1 0.25"
                    }
                        ,
                        RectTransform = {
                        AnchorMin=$"0 0.32", AnchorMax=$"1 0.99"
                    }
                    }
                    , $"ui.kits.main.{kit.Name}", $"ui.kits.{kit.Name}");
                    pos += 0.175f + 0.005f;
                    InitilizeCooldown(ref container, player, kit, page);
                    container.Add(new CuiButton
                    {
                        Button = {
                        Color="0.75 0.75 0.75 0.5", Command=$"kit.drawkitinfo {kit.Name} {page}", /*Material = "assets/content/ui/ui.background.transparent.radial.psd",*/
					}
                        ,
                        RectTransform = {
                        AnchorMin="0 0.01", AnchorMax="1 0.28"
                    }
                        ,
                        Text = {
                        Text="", Font="robotocondensed-regular.ttf", Align=TextAnchor.MiddleCenter, FontSize=18
                    }
                    }
                    , $"ui.kits.main.{kit.Name}", $"ui.kits.{kit.Name}.button");
                    container.Add(new CuiElement
                    {
                        Parent = $"ui.kits.{kit.Name}.button",
                        Components = {
                        new CuiTextComponent {
                            FadeIn=0.1f, Color="1 1 1 1", Text=GetMsg("UI READ", player).ToUpper(), FontSize=18, Font="robotocondensed-bold.ttf", Align=TextAnchor.MiddleCenter,
                        }
                        , new CuiRectTransformComponent {
                            AnchorMin=$"0 0", AnchorMax=$"1 1"
                        }
                        , new CuiOutlineComponent {
                            Color="0 0 0 0.3", Distance="-0.5 0.5"
                        }
                    }
                        ,
                    }
                    );
                    i++;
                }
            else container.Add(new CuiElement
            {
                Parent = "ui.kits1",
                Components = {
                    new CuiTextComponent {
                        FadeIn=1f, Color="1 1 1 0.5", Text=GetMsg("UI No Available", player).ToUpper(), FontSize=35, Font="robotocondensed-bold.ttf", Align=TextAnchor.MiddleCenter,
                    }
                    , new CuiRectTransformComponent {
                        AnchorMin=$"0 0.4", AnchorMax=$"1 0.6"
                    }
                    , new CuiOutlineComponent {
                        Color="0 0 0 0.3", Distance="-0.5 0.5"
                    }
                }
                ,
            }
            );
            if (player.IsAdmin)
            {
                container.Add(new CuiPanel
                {
                    Image = {
                        Color="1 1 1 0.01", Material="assets/content/ui/uibackgroundblur-ingamemenu.mat"
                    }
                    ,
                    RectTransform = {
                        AnchorMin="0.8 0.37", AnchorMax="0.95 0.41"
                    }
                    ,
                }
                , $"ui.kits1", "kits.adminSettings");
                container.Add(new CuiPanel
                {
                    Image = {
                        Color=AdminSetting.Contains(player) ? "1 1 1 0.7": "1 1 1 0.1", Material="assets/content/ui/uibackgroundblur-ingamemenu.mat"
                    }
                    ,
                    RectTransform = {
                        AnchorMin="0.01 0.2", AnchorMax="0.1 0.8"
                    }
                    ,
                }
                , "kits.adminSettings");
                container.Add(new CuiElement
                {
                    Parent = "kits.adminSettings",
                    Components = {
                        new CuiTextComponent {
                            Color="1 1 1 1", Text=AdminSetting.Contains(player) ? GetMsg("UI Admin OFF", player): GetMsg("UI Admin ON", player), FontSize=12, Font="robotocondensed-regular.ttf", Align=TextAnchor.MiddleCenter,
                        }
                        , new CuiRectTransformComponent {
                            AnchorMin=$"0.1 0", AnchorMax=$"1 1"
                        }
                        , new CuiOutlineComponent {
                            Color="0 0 0 0.3", Distance="-0.5 0.5"
                        }
                    }
                    ,
                }
                );
                container.Add(new CuiButton
                {
                    Button = {
                        Color="1 1 1 0", Command=$"UIkits_adminSettings {page}"
                    }
                    ,
                    RectTransform = {
                        AnchorMin="0 0", AnchorMax="1 1"
                    }
                    ,
                    Text = {
                        Text="", Font="robotocondensed-regular.ttf", Align=TextAnchor.MiddleCenter, Color="1 1 1 0"
                    }
                }
                , "kits.adminSettings");
            }
            container.Add(new CuiButton
            {
                Button = {
                    Color="1 1 1 0", Command=GetKitsForPlayer(player).Skip(5 * (page + 1)).Count() > 0 ? $"kits.page {page + 1}": $""
                }
                ,
                RectTransform = {
                    AnchorMin="0.95 0.4", AnchorMax="1 0.6"
                }
                ,
                Text = {
                    Text=">", Font="robotocondensed-regular.ttf", Align=TextAnchor.MiddleCenter, FontSize=80, Color=GetKitsForPlayer(player).Skip(5 * (page + 1)).Count() > 0 ? "1 1 1 1": "1 1 1 0.3"
                }
            }
            , $"ui.kits1", $"ui.kits1.buttonNext");
            container.Add(new CuiButton
            {
                Button = {
                    Color="1 1 1 0", Command=page > 0 ? $"kits.page {page - 1}": ""
                }
                ,
                RectTransform = {
                    AnchorMin="0 0.4", AnchorMax="0.05 0.6"
                }
                ,
                Text = {
                    Text="<", Font="robotocondensed-regular.ttf", Align=TextAnchor.MiddleCenter, FontSize=80, Color=page > 0 ? "1 1 1 1": "1 1 1 0.3"
                }
            }
            , $"ui.kits1", $"ui.kits1.buttonNext");
            CuiHelper.AddUi(player, container);
        }
        private void InitilizeCooldown(ref CuiElementContainer container, BasePlayer player, Kit kit, int page)
        {
            CuiHelper.DestroyUi(player, $"ui.kits.{kit.Name}.kitmain");
            var playerData = GetPlayerData(kit.Name, player.userID);
            container.Add(new CuiPanel
            {
                Image = {
                    Color="0.75 0.75 0.75 0.4", /*Material= "assets/content/ui/ui.background.tile.psd", */
				}
                ,
                RectTransform = {
                    AnchorMin=$"0 0", AnchorMax=$"1 1"
                }
            }
            , $"ui.kits.{kit.Name}", $"ui.kits.{kit.Name}.kitmain");
            if (kit.Cooldown > 0 && playerData.Cooldown - 1 < GetCurrentTime() || kit.Cooldown == 0)
            {
                container.Add(new CuiPanel
                {
                    Image = {
                        Color=kit.Color
                    }
                    ,
                    RectTransform = {
                        AnchorMin=$"0 0", AnchorMax=$"0.994 0.97"
                    }
                }
                , $"ui.kits.{kit.Name}.kitmain");
                container.Add(new CuiButton
                {
                    Button = {
                        Color="0.75 0.75 0.75 0", Command=$"kit {kit.Name}"
                    }
                    ,
                    RectTransform = {
                        AnchorMin="0 0", AnchorMax="1 1"
                    }
                    ,
                    Text = {
                        Text="", Font="robotocondensed-regular.ttf", Align=TextAnchor.MiddleCenter, FontSize=18
                    }
                }
                , $"ui.kits.{kit.Name}", $"ui.kits.{kit.Name}.kitmain");
                container.Add(new CuiElement
                {
                    Parent = $"ui.kits.{kit.Name}.kitmain",
                    Components = {
                        new CuiTextComponent {
                            Color="1 1 1 1", Text=$"<b>{kit.DisplayName.ToUpper()}</b>", FontSize=22, Font="robotocondensed-regular.ttf", Align=TextAnchor.MiddleCenter,
                        }
                        , new CuiRectTransformComponent {
                            AnchorMin=$"0 0", AnchorMax=$"1 1"
                        }
                        , new CuiOutlineComponent {
                            Color="0 0 0 0.3", Distance="-0.5 0.5"
                        }
                    }
                    ,
                }
                );
                container.Add(new CuiElement
                {
                    Parent = $"ui.kits.{kit.Name}.kitmain",
                    Components = {
                        new CuiTextComponent {
                            Color="0.85 0.85 0.85 1.00", Text=GetMsg("UI GIVE", player), FontSize=14, Font="robotocondensed-regular.ttf", Align=TextAnchor.MiddleCenter,
                        }
                        , new CuiRectTransformComponent {
                            AnchorMin=$"0 0", AnchorMax=$"1 0.3"
                        }
                        , new CuiOutlineComponent {
                            Color="0 0 0 0.3", Distance="-0.5 0.5"
                        }
                    }
                    ,
                }
                );
                if (kit.Amount > 0)
                {
                    var amount = kit.Amount - playerData.Amount;
                    container.Add(new CuiElement
                    {
                        Parent = $"ui.kits.{kit.Name}.kitmain",
                        Components = {
                            new CuiTextComponent {
                                Color="0.85 0.85 0.85 1.00", Text=GetMsg("UI Amount", player).Replace("{amount}", amount.ToString()), FontSize=11, Font="robotocondensed-regular.ttf", Align=TextAnchor.MiddleRight,
                            }
                            , new CuiRectTransformComponent {
                                AnchorMin=$"0 0.75", AnchorMax=$"0.95 0.95"
                            }
                            , new CuiOutlineComponent {
                                Color="0 0 0 0.3", Distance="-0.5 0.5"
                            }
                        }
                        ,
                    }
                    );
                }
                container.Add(new CuiButton
                {
                    Button = {
                        Color="0.75 0.75 0.75 0", Command=playerData.Cooldown - 1 < GetCurrentTime() ? $"kit {kit.Name} {page}": ""
                    }
                    ,
                    RectTransform = {
                        AnchorMin="0 0", AnchorMax="1 1"
                    }
                    ,
                    Text = {
                        Text="", Font="robotocondensed-regular.ttf", Align=TextAnchor.MiddleCenter, FontSize=18
                    }
                }
                , $"ui.kits.{kit.Name}");
            }
            else
            {
                var time = TimeSpan.FromSeconds(playerData.Cooldown - GetCurrentTime());
                var AnchorType = kit.Cooldown / (float)time.TotalSeconds - 0.03f;
                var max = 1 - ((time.TotalSeconds + (float)kit.Cooldown / 60) / kit.Cooldown);
                container.Add(new CuiPanel
                {
                    Image = {
                        Color=kit.Color
                    }
                    ,
                    RectTransform = {
                        AnchorMin=$"0 0", AnchorMax=$"{max} 0.97"
                    }
                }
                , $"ui.kits.{kit.Name}.kitmain", $"ui.kits.{kit.Name}.time");
                container.Add(new CuiElement
                {
                    Parent = $"ui.kits.{kit.Name}.kitmain",
                    Components = {
                        new CuiTextComponent {
                            Color="1 1 1 1", Text=$"<b>{kit.DisplayName.ToUpper()}</b>", FontSize=22, Font="robotocondensed-regular.ttf", Align=TextAnchor.MiddleCenter,
                        }
                        , new CuiRectTransformComponent {
                            AnchorMin=$"0 0", AnchorMax=$"1 1"
                        }
                        , new CuiOutlineComponent {
                            Color="0 0 0 0.3", Distance="-0.5 0.5"
                        }
                    }
                    ,
                }
                );
                container.Add(new CuiElement
                {
                    Parent = $"ui.kits.{kit.Name}.kitmain",
                    Components = {
                        new CuiTextComponent {
                            Color="0.85 0.85 0.85 1.00", Text=TimeExtensions.FormatShortTime(time), FontSize=14, Font="robotocondensed-regular.ttf", Align=TextAnchor.MiddleCenter,
                        }
                        , new CuiRectTransformComponent {
                            AnchorMin=$"0 0", AnchorMax=$"1 0.3"
                        }
                        , new CuiOutlineComponent {
                            Color="0 0 0 0.3", Distance="-0.5 0.5"
                        }
                    }
                    ,
                }
                );
            }
        }
        [ConsoleCommand("kit.drawkitinfo")]
        void cmdDrawKitInfo(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player == null || player.Connection == null) return;
            var kit = kitsList.First(kits => kits.Name.ToLower() == args.Args[0].ToLower());
            if (kit == null) return;
            DrawKitInfo(player, kit, int.Parse(args.Args[1]));
        }
        void DrawKitInfo(BasePlayer player, Kit kit, int page)
        {
            DestroyUI(player);
            CuiHelper.DestroyUi(player, $"ui.kits.info");


            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                Image = {
                    Color="0.19 0.19 0.18 0.6"/*, Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" */
				}
                ,
                RectTransform = {
                    AnchorMin="0 0", AnchorMax="1 1"
                }
                ,
                CursorEnabled = true
            }
            , "Overlay", $"ui.kits.info");
            container.Add(new CuiElement
            {
                Parent = $"ui.kits.info",
                Components = {
                    new CuiTextComponent {
                        Color="1 1 1 1", Text=$"<b>{kit.DisplayName.ToUpper()}</b>", FontSize=30, Align=TextAnchor.MiddleCenter,
                    }
                    , new CuiRectTransformComponent {
                        AnchorMin=$"0 0.8", AnchorMax=$"1 1"
                    }
                    , new CuiOutlineComponent {
                        Color="0 0 0 0.3", Distance="-0.5 0.5"
                    }
                }
                ,
            }
            );
            var pos = 0.5f - ((kit.Items.Count > 10 ? 10 : kit.Items.Count) * 0.09f + ((kit.Items.Count > 10 ? 10 : kit.Items.Count) - 1) * 0.005f) / 2;
            var newline1 = 0.43;
            var newline2 = 0.57;
            if (kit.Items.Count > 10)
            {
                newline1 = 0.58;
                newline2 = 0.72;
            }
            container.Add(new CuiElement
            {
                Parent = $"ui.kits.info",
                Components = {
                    new CuiTextComponent {
                        Color="0.85 0.85 0.85 1.00", Text=GetMsg("UI Item Info", player), FontSize=14, Font="robotocondensed-regular.ttf", Align=TextAnchor.MiddleCenter,
                    }
                    , new CuiRectTransformComponent {
                        AnchorMin=$"0 0", AnchorMax=$"1 0.3"
                    }
                    , new CuiOutlineComponent {
                        Color="0 0 0 0.3", Distance="-0.5 0.5"
                    }
                }
                ,
            }
            );
            container.Add(new CuiElement
            {
                Parent = $"ui.kits.info",
                Components = {
                    new CuiButtonComponent {
                        Color="0.16 0.15 0.31 0", Command=$"kit ui {page} {kit.Name}"
                    }
                    , new CuiRectTransformComponent {
                        AnchorMin="-100 -100", AnchorMax="100 100", OffsetMax="0 0"
                    }
                    ,
                }
                ,
            }
            );
            foreach (var item in kit.Items.OrderBy(p => p.Change < p.Change).Select((i, t) => new
            {
                A = i,
                B = t
            }
            ).Take(30))
            {
                var element = config.RaritiesColor.Find(p => p.Chance == ChangeSelect(item.A.Change));

                if (element == null)
                {
                    PrintError($"Ошибка загрузки цвета шанса у кита {kit.Name} {item.A.ShortName} Шанс {item.A.Change} {element.Color}");
                    continue;
                }
                container.Add(new CuiButton
                {
                    RectTransform = {
                        AnchorMin=$"{pos} {newline1}", AnchorMax=$"{pos + 0.09f} {newline2}", OffsetMax="0 0"
                    }
                    ,
                    Button = {
                        Color=element.Color
                    }
                    ,
                    Text = {
                        Text=""
                    }
                }
                , $"ui.kits.info", $"ui.kits.info" + $".{item.B}");
                pos += 0.09f + 0.005f;
                container.Add(new CuiElement
                {
                    Parent = $"ui.kits.info" + $".{item.B}",
                    Components = {
                        new CuiRawImageComponent {
                                                       Png =!string.IsNullOrEmpty(item.A.CustomImage) ? GetImage(item.A.CustomImage) :  item.A.ShortName == "mailbox"? GetImage("mailbox_1812087291") : GetImage(item.A.ShortName, item.A.SkinID),

                        }
                        , new CuiRectTransformComponent {
                            AnchorMin="0.1 0", AnchorMax="0.9 0.97", OffsetMax="0 0"
                        }
                        ,
                    }
                    ,
                }
                );
                container.Add(new CuiElement
                {
                    Parent = $"ui.kits.info" + $".{item.B}",
                    Components = {
                        new CuiTextComponent {
                            Color="0.85 0.85 0.85 1.00", Text=$"<b>x{item.A.Amount}</b>", FontSize=12, Align=TextAnchor.MiddleRight,
                        }
                        , new CuiRectTransformComponent {
                            AnchorMin=$"0.4 0", AnchorMax=$"0.95 0.2"
                        }
                        , new CuiOutlineComponent {
                            Color="0 0 0 0.3", Distance="-0.5 0.5"
                        }
                    }
                    ,
                }
                );
                if (item.A.Change < 99) container.Add(new CuiElement
                {
                    Parent = $"ui.kits.info" + $".{item.B}",
                    Components = {
                        new CuiTextComponent {
                            Color="0.85 0.85 0.85 0.7", Text=$"<b>{item.A.Change}%</b>", FontSize=45, Align=TextAnchor.MiddleCenter,
                        }
                        , new CuiRectTransformComponent {
                            AnchorMin=$"0 0", AnchorMax=$"1 1"
                        }
                        , new CuiOutlineComponent {
                            Color="0 0 0 0.3", Distance="-0.5 0.5"
                        }
                    }
                    ,
                }
                );
                if (item.B == 9)
                {
                    newline1 = 0.43;
                    newline2 = 0.57;
                    pos = 0.5f - ((kit.Items.Skip(10).ToList().Count > 10 ? 10 : kit.Items.Skip(10).ToList().Count) * 0.09f + ((kit.Items.Skip(10).ToList().Count > 10 ? 10 : kit.Items.Skip(10).ToList().Count) - 1) * 0.005f) / 2;
                }
                if (item.B == 19)
                {
                    newline1 = 0.28;
                    newline2 = 0.42;
                    pos = 0.5f - ((kit.Items.Skip(20).ToList().Count > 10 ? 10 : kit.Items.Skip(20).ToList().Count) * 0.09f + ((kit.Items.Skip(20).ToList().Count > 10 ? 10 : kit.Items.Skip(20).ToList().Count) - 1) * 0.005f) / 2;
                }
            }
            CuiHelper.AddUi(player, container);
        }
        private int? ChangeSelect(int x)
        {
            var num = (from number in config.RaritiesColor.Select(p => p.Chance)
                       let difference = Math.Abs(number - x)
                       orderby difference, Math.Abs(number), number descending
                       select number)
                .FirstOrDefault();
            return num;
        }
        private void SendEffectToPlayer2(BasePlayer player, string effectPrefab)
        {
            EffectNetwork.Send(new Effect(effectPrefab, player.transform.position, Vector3.zero), player.net.connection);
        }
        [ConsoleCommand("UIkits_adminSettings")]
        void adminSettingsKit(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            int page = int.Parse(args.Args[0]);
            if (!AdminSetting.Contains(player))
            {
                AdminSetting.Add(player);
                DestroyUI(player);
                TriggerUI(player, page);
            }
            else
            {
                AdminSetting.Remove(player);
                DestroyUI(player);
                TriggerUI(player, page);
            }
        }
        private KitData GetPlayerData(string name, ulong playerid = 533504)
        {
            if (!PlayersData.ContainsKey(playerid)) PlayersData[playerid] = new Dictionary<string, KitData>();
            if (!PlayersData[playerid].ContainsKey(name)) PlayersData[playerid][name] = new KitData();
            return PlayersData[playerid][name];
        }
        private List<KitItem> GetPlayerItems(BasePlayer player)
        {
            List<KitItem> kititems = new List<KitItem>();
            foreach (Item item in player.inventory.containerWear.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ItemToKit(item, "wear");
                    kititems.Add(iteminfo);
                }
            }
            foreach (Item item in player.inventory.containerMain.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ItemToKit(item, "main");
                    kititems.Add(iteminfo);
                }
            }
            foreach (Item item in player.inventory.containerBelt.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ItemToKit(item, "belt");
                    kititems.Add(iteminfo);
                }
            }
            return kititems;
        }
        string GetMsg(string key, BasePlayer player = null) => lang.GetMessage(key, this, player == null ? null : player.UserIDString).Replace("{Prefix}", config.DefaultPrefix);
        private KitItem ItemToKit(Item item, string container)
        {
            KitItem kitem = new KitItem();
            kitem.Amount = item.amount;
            kitem.Container = container;
            kitem.SkinID = item.skin;
            kitem.Blueprint = item.blueprintTarget;
            kitem.ShortName = item.info.shortname;
            kitem.Condition = item.condition;
            kitem.Change = 100;
            kitem.Weapon = null;
            kitem.Content = null;
            if (item.info.category == ItemCategory.Weapon)
            {
                BaseProjectile weapon = item.GetHeldEntity() as BaseProjectile;
                if (weapon != null)
                {
                    kitem.Weapon = new Weapon();
                    kitem.Weapon.ammoType = weapon.primaryMagazine.ammoType.shortname;
                    kitem.Weapon.ammoAmount = weapon.primaryMagazine.contents;
                }
            }
            if (item.contents != null)
            {
                kitem.Content = new List<ItemContent>();
                foreach (var cont in item.contents.itemList)
                {
                    kitem.Content.Add(new ItemContent()
                    {
                        Amount = cont.amount,
                        Condition = cont.condition,
                        ShortName = cont.info.shortname
                    }
                    );
                }
            }
            return kitem;
        }
        private List<Kit> GetKitsForPlayer(BasePlayer player)
        {
            if (AdminSetting.Contains(player))
            {
                return kitsList.ToList();
            }
            else return kitsList.Where(kit => !kit.Hide && (string.IsNullOrEmpty(kit.Permission) || permission.UserHasPermission(player.UserIDString, kit.Permission)) && (kit.Amount == 0 || (kit.Amount > 0 && GetPlayerData(kit.Name, player.userID).Amount < kit.Amount))).ToList();
        }
        private BasePlayer FindPlayer(BasePlayer player, string nameOrID)
        {
            ulong id;
            if (ulong.TryParse(nameOrID, out id) && nameOrID.StartsWith("7656119") && nameOrID.Length == 17)
            {
                var findedPlayer = BasePlayer.FindByID(id);
                if (findedPlayer == null || !findedPlayer.IsConnected)
                {
                    SendReply(player, GetMsg("Not Found Player", player));
                    return null;
                }
                return findedPlayer;
            }
            var foundPlayers = BasePlayer.activePlayerList.Where(x => x.displayName.ToLower().Contains(nameOrID.ToLower()));
            if (foundPlayers.Count() == 0)
            {
                SendReply(player, GetMsg("Not Found Player", player));
                return null;
            }
            if (foundPlayers.Count() > 1)
            {
                SendReply(player, GetMsg("To Many Player", player));
                return null;
            }
            return foundPlayers.First();
        }
        private double GetCurrentTime() => new TimeSpan(DateTime.UtcNow.Ticks).TotalSeconds;
        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }
            var str = hex.Trim('#');
            if (str.Length == 6) str += "FF";
            if (str.Length != 8)
            {
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }
            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);
            Color color = new Color32(r, g, b, a);
            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }
        private static class TimeExtensions
        {
            public static string FormatShortTime(TimeSpan time)
            {
                string result = string.Empty;
                if (time.Days != 0) result += $"{time.Days} д. ";
                if (time.Hours != 0) result += $"{time.Hours} ч. ";
                if (time.Minutes != 0) result += $"{time.Minutes} м. ";
                if (time.Seconds != 0) result += $"{time.Seconds} с. ";
                return result;
            }
            public static string FormatTime(TimeSpan time)
            {
                string result = string.Empty;
                if (time.Days != 0) result += $"{Format(time.Days, "дней", "дня", "день")} ";
                if (time.Hours != 0) result += $"{Format(time.Hours, "часов", "часа", "час")} ";
                if (time.Minutes != 0) result += $"{Format(time.Minutes, "минут", "минуты", "минута")} ";
                if (time.Seconds != 0) result += $"{Format(time.Seconds, "секунд", "секунды", "секунда")} ";
                return result;
            }
            private static string Format(int units, string form1, string form2, string form3)
            {
                var tmp = units % 10;
                if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9) return $"{units} {form1}";
                if (tmp >= 2 && tmp <= 4) return $"{units} {form2}";
                return $"{units} {form3}";
            }
        }
        [HookMethod("isKit")]
        public bool isKit(string kitName)
        {
            if (kitsList.Select(p => p.Name == kitName) != null) return true;
            return false;
        }
        [HookMethod("GetAllKits")] public string[] GetAllKits() => kitsList.Select(p => p.Name).ToArray();
    }
}

// --- End of file: Kits.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/PanelV2.cs ---
// --- Original Local Path: KualaRust/PanelV2.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Random = UnityEngine.Random;
using System;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("PanelV2", "fermenspwnz", "2.1.6")]
    [Description("Красивая панель с отображением онлайна, времени, вертолета, аирдропа, челнока, танка и корабля.")]
    class PanelV2 : RustPlugin
    {
        static int downloaded;
        Plugin ImageLibrary => Interface.Oxide.RootPluginManager.GetPlugin("ImageLibrary");
        public string GetImage(string shortname, ulong skin = 0) => (string)ImageLibrary.Call("GetImage", shortname, skin);
        public bool AddImage(string url, string shortname, ulong skin = 0) => (bool)ImageLibrary?.Call("AddImage", url, shortname, skin);
        void gettimage(string url, string name)
        {
            string img = GetImage(name);
            string none = GetImage("NONE");
            string loading = GetImage("LOADING");
            if (string.IsNullOrEmpty(img) || string.IsNullOrEmpty(none) || none == img || string.IsNullOrEmpty(loading) || loading == img)
            {
                AddImage(url, name);
                timer.Once(1f, () => gettimage(url, name));
                return;
            }
            downloaded++;
            if (downloaded.Equals(config.imagelist.Count))
            {
                Debug.Log("Подгрузили все картинки! >>PANELV2<<");
                Subscribe(nameof(OnPlayerConnected));
                if (config.messages != null && config.messages.Count() > 0)
                {
                    new PluginTimers(this).Every(config.infotimer, () => FarmGUI(TypeGui.Message));
                }
                new PluginTimers(this).Every(5f, () => FarmGUI(TypeGui.Time));
                FarmGUI(TypeGui.All);
            }
        }
        List<ulong> _players = new List<ulong>();

        #region Config
        static Dictionary<string, string> _imagelist = new Dictionary<string, string>
        {
            {"https://gspics.org/images/2019/03/11/mUaUn.png","chelnok"},
            {"https://gspics.org/images/2019/03/11/mUSE7.png","heli"},
            {"https://gspics.org/images/2019/03/11/mUR8K.png","plane"},
            {"https://gspics.org/images/2019/03/11/mUOGE.png","cargo"},
            {"https://gspics.org/images/2019/03/24/UCU8o.png","tank"}
        };

        static List<string> _messages = new List<string>
        {
          "Настроить <color=#ffff99>Информационную строку</color> можно в конфиге плагина <color=#ffff66>PanelV2</color>",
          "Настроить <color=#ffff99>Infoрмационную строку</color> можно в конфиге плагина <color=#ffff66>PanelV2</color>",
          "Настроить <color=#ffff99>'Информационную строку'</color> можно в конфиге плагина <color=#ffff66>PanelV2</color>"
        };

        private PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        private class PluginConfig
        {
            [JsonProperty("Накрутка онлайна")]
            public int onliner = 0;

            [JsonProperty("Информационная строка (если пусто, то выключена)")]
            public List<string> messages;

            [JsonProperty("Информационная строка | Частота обновлений в секундах")]
            public float infotimer;

            [JsonProperty("Сообщение | Онлайн")]
            public string message;

            [JsonProperty("Онлайн - размер текста")]
            public string onlinesize;

            [JsonProperty("Время - размер текста")]
            public string timersize;

            [JsonProperty("Картинки")]
            public Dictionary<string, string> imagelist;

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    onliner = 0,
                    messages = _messages,
                    infotimer = 60f,
                    imagelist = _imagelist,
                    message = "Онлайн {players} из {maxplayers}",
                    onlinesize = "13",
                    timersize = "13",
                };
            }
        }
        #endregion

        #region Function
        string[] panels = { "timer", "boat", "tank", "FarmGUI3", "online", "plane", "helis", "chelnok" };
        void DestroyUI(Network.Connection player)
        {
            foreach (var z in panels) CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player }, null, "DestroyUI", z);
        }
        #endregion

        #region Hooks
        void Unload()
        {
            foreach (var z in panels) CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = Network.Net.sv.connections }, null, "DestroyUI", z);
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = Network.Net.sv.connections }, null, "DestroyUI", "message");
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            NextTick(() =>
            {
                FarmGUI(TypeGui.Online);
            });
        }

        static string GUIjsontimer = "";
        static string GUIjsononline = "";

        private void Init()
        {
            Unsubscribe(nameof(OnPlayerConnected));
        }

        void OnServerInitialized()
        {
            AddImage("http://i.imgur.com/sZepiWv.png", "NONE", 0);
            AddImage("http://i.imgur.com/lydxb0u.png", "LOADING", 0);
            if (config.timersize == null)
            {
                config.timersize = "13";
                config.onlinesize = "13";
                SaveConfig();
            }
            if (config.message == null)
            {
                config.imagelist = _imagelist;
                config.message = "Онлайн {players} из {maxplayers}";
                SaveConfig();
            }
            if (!ImageLibrary)
            {
                PrintWarning("Image Library не обнаружен, отгружаем Панель.");
                Interface.Oxide.UnloadPlugin(Name);
                return;
            }
            GUIjsontimer = "[{\"name\":\"timer\",\"parent\":\"Hud\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"fontSize\":\"{timesize}\",\"color\":\"1 1 1 0.5\",\"text\":\"{text}\",\"align\":\"MiddleCenter\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.69 0.0195\",\"anchormax\":\"0.69 0.0195\",\"offsetmin\":\"0 29.976\",\"offsetmax\":\"55.8 55.7\"}]}]".Replace("{timesize}", config.timersize);
            GUIjsononline = "[{\"name\":\"online\",\"parent\":\"Hud\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"fontSize\":\"{onlinesize}\",\"color\":\"1 1 1 0.5\",\"text\":\"{text}\",\"align\":\"MiddleCenter\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.69 0.0195\",\"anchormax\":\"0.69 0.0195\",\"offsetmin\":\"0 5.09\",\"offsetmax\":\"120 25.19\"}]}]".Replace("{onlinesize}", config.onlinesize);
            foreach (var z in config.imagelist) gettimage(z.Key, z.Value);
            ships = UnityEngine.Object.FindObjectsOfType<CargoShip>().Count();
            planes = UnityEngine.Object.FindObjectsOfType<CargoPlane>().Count();
            helicopters = UnityEngine.Object.FindObjectsOfType<BaseHelicopter>().Count();
            tanks = UnityEngine.Object.FindObjectsOfType<BradleyAPC>().Count();
            chinooks = UnityEngine.Object.FindObjectsOfType<CH47HelicopterAIController>().Count();
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.Once(2, () => OnPlayerConnected(player));
                return;
            }
            NextTick(() =>
            {
                if (player == null || !player.IsConnected) return;
                if (!_players.Contains(player.userID)) FarmGUI(TypeGui.All, new List<Network.Connection> { player.net.connection });
                FarmGUI(TypeGui.Online);
            });
        }



        int helicopters = 0;
        int planes = 0;
        int ships = 0;
        int tanks = 0;
        int chinooks = 0;

        void OnEntityKill(BaseNetworkable Entity)
        {
            if (Entity == null) return;
            if (Entity is BaseHelicopter)
            {
                helicopters--;
                if (helicopters == 0) FarmGUI(TypeGui.Heli);
            }
            else if (Entity is CargoPlane)
            {
                planes--;
                if (planes == 0) FarmGUI(TypeGui.Plane);
            }
            else if (Entity is CargoShip)
            {
                ships--;
                if (ships == 0) FarmGUI(TypeGui.Ship);
            }
            else if (Entity is BradleyAPC)
            {
                tanks--;
                if (tanks == 0) FarmGUI(TypeGui.Tank);
            }
            else if (Entity is CH47HelicopterAIController)
            {
                chinooks--;
                if (chinooks == 0) FarmGUI(TypeGui.Chinook);
            }
        }

        private void OnEntitySpawned(BaseNetworkable Entity)
        {
            if (Entity == null) return;
            if (Entity is BaseHelicopter)
            {
                helicopters++;
                if (helicopters == 1) FarmGUI(TypeGui.Heli);
            }
            else if (Entity is CargoPlane)
            {
                planes++;
                if (planes == 1) FarmGUI(TypeGui.Plane);
            }
            else if (Entity is CargoShip)
            {
                ships++;
                if (ships == 1) FarmGUI(TypeGui.Ship);
            }
            else if (Entity is BradleyAPC)
            {
                tanks++;
                if (tanks == 1) FarmGUI(TypeGui.Tank);
            }
            else if (Entity is CH47HelicopterAIController)
            {
                chinooks++;
                if (chinooks == 1) FarmGUI(TypeGui.Chinook);
            }
        }
        #endregion

        [ConsoleCommand("gategui")]
        void gategui(ConsoleSystem.Arg arg)
        {
            ulong userid = arg.Connection.userid;
            if (cooldown.ContainsKey(userid) && cooldown[userid] > DateTime.Now)
            {
                arg.Player().Command("chat.add", 2, 0, "Не так часто!");
                return;
            }
            if (!_players.Contains(userid))
            {
                _players.Add(userid);
                CloseGUI(arg.Connection);
            }
            else
            {
                _players.Remove(userid);
                if (!_players.Contains(userid)) FarmGUI(TypeGui.All, new List<Network.Connection> { arg.Connection });
                cooldown[userid] = DateTime.Now.AddSeconds(10);
            }
        }

        #region GUI
        enum TypeGui
        {
            Message, All, Online, Time, Heli, Tank, Chinook, Plane, Ship
        }

        void CloseGUI(Network.Connection connect)
        {
            DestroyUI(connect);
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = connect }, null, "AddUI", GUIjsondisable);
        }

        Dictionary<ulong, DateTime> cooldown = new Dictionary<ulong, DateTime>();


        const string GUIjsonmessage = "[{\"name\":\"message\",\"parent\":\"Hud\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"fontSize\":\"13\",\"color\":\"1 1 1 0.5\",\"text\":\"{text}\",\"align\":\"LowerCenter\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.495 0\",\"anchormax\":\"0.495 0\",\"offsetmin\":\"-500 0\",\"offsetmax\":\"500 20\"}]}]";
        const string GUIjsonfon = "[{\"name\":\"FarmGUI3\", \"parent\":\"Hud\", \"components\":[{\"type\":\"UnityEngine.UI.Image\", \"color\":\"0 0 0 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.69 0.0195\",\"anchormax\":\"0.69 0.0195\"}]},{\"name\":\"7a37bb60454b43e995e914a1ccc042e8\",\"parent\":\"FarmGUI3\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"material\":\"assets/content/ui/namefontmaterial.mat\",\"color\":\"0.95 0.95 0.95 0.025\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.69 0.0195\",\"anchormax\":\"0.69 0.0195\",\"offsetmin\":\"57.6 29.976\",\"offsetmax\":\"86.4 55.7\"}]},{\"name\":\"538cf01fbd6842298dbbc3addec341e8\",\"parent\":\"FarmGUI3\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"material\":\"assets/content/ui/namefontmaterial.mat\",\"color\":\"0.95 0.95 0.95 0.025\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.69 0.0195\",\"anchormax\":\"0.69 0.0195\",\"offsetmin\":\"88.2 29.976\",\"offsetmax\":\"117 55.7\"}]},{\"name\":\"5db1aeebf0294093a77b0e72194c6946\",\"parent\":\"FarmGUI3\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"material\":\"assets/content/ui/namefontmaterial.mat\",\"color\":\"0.95 0.95 0.95 0.025\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.69 0.0195\",\"anchormax\":\"0.69 0.0195\",\"offsetmin\":\"118.8 29.976\",\"offsetmax\":\"147.6 55.7\"}]},{\"name\":\"c6a8a5f3882649b8ae89392faf557f20\",\"parent\":\"FarmGUI3\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"material\":\"assets/content/ui/namefontmaterial.mat\",\"color\":\"0.95 0.95 0.95 0.025\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.69 0.0195\",\"anchormax\":\"0.69 0.0195\",\"offsetmin\":\"149.4 29.976\",\"offsetmax\":\"178.2 55.7\"}]},{\"name\":\"1b31e40057534d32a978915563513fa1\",\"parent\":\"FarmGUI3\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"material\":\"assets/content/ui/namefontmaterial.mat\",\"color\":\"0.95 0.95 0.95 0.025\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.69 0.0195\",\"anchormax\":\"0.69 0.0195\",\"offsetmin\":\"0 29.976\",\"offsetmax\":\"55.7 55.7\"}]},{\"name\":\"f6d9849bec0d4b15a757e986bdfdda4c\",\"parent\":\"FarmGUI3\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"material\":\"assets/content/ui/namefontmaterial.mat\",\"color\":\"0.95 0.95 0.95 0.025\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.69 0.0195\",\"anchormax\":\"0.69 0.0195\",\"offsetmin\":\"118.8 2.171\",\"offsetmax\":\"147.6 28.056\"}]},{\"name\":\"402c08c95caa484f94a848e7dfdb2b37\",\"parent\":\"FarmGUI3\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"material\":\"assets/content/ui/namefontmaterial.mat\",\"color\":\"0.95 0.95 0.95 0.025\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.69 0.0195\",\"anchormax\":\"0.69 0.0195\",\"offsetmin\":\"0 2.171\",\"offsetmax\":\"117 28.056\"}]},{\"name\":\"c92e68d80c68458885a5c487f497b9f8\",\"parent\":\"FarmGUI3\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"gategui\",\"material\":\"assets/content/ui/namefontmaterial.mat\",\"color\":\"0.95 0.95 0.95 0.025\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.69 0.0195\",\"anchormax\":\"0.69 0.0195\",\"offsetmin\":\"149.4 2.171\",\"offsetmax\":\"178.2 28.056\"}]},{\"parent\":\"c92e68d80c68458885a5c487f497b9f8\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"↴\",\"fontSize\":20,\"align\":\"MiddleCenter\"},{\"type\":\"RectTransform\"}]}]";
        static string GUIjsondisable = "[{\"name\":\"FarmGUI3\", \"parent\":\"Hud\", \"components\":[{\"type\":\"UnityEngine.UI.Image\", \"color\":\"0 0 0 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.69 0.0195\",\"anchormax\":\"0.69 0.0195\"}]},{\"name\":\"c92e68d80c68458885a5c487f497b9f8\",\"parent\":\"FarmGUI3\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"gategui\",\"material\":\"assets/content/ui/namefontmaterial.mat\",\"color\":\"0.95 0.95 0.95 0.025\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.69 0.0195\",\"anchormax\":\"0.69 0.0195\",\"offsetmin\":\"149.4 2.171\",\"offsetmax\":\"178.2 28.056\"}]},{\"parent\":\"c92e68d80c68458885a5c487f497b9f8\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"↰\",\"fontSize\":20,\"align\":\"MiddleCenter\"},{\"type\":\"RectTransform\"}]}]";
        static string GUIjsononplane = "[{\"name\":\"plane\",\"parent\":\"Hud\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"color\":\"{color}\",\"png\":\"{png}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.69 0.0195\",\"anchormax\":\"0.69 0.0195\",\"offsetmin\":\"61.2 32.9\",\"offsetmax\":\"82.8 53\"}]}]";
        static string GUIjsononship = "[{\"name\":\"boat\",\"parent\":\"Hud\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"color\":\"{color}\",\"png\":\"{png}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.69 0.0195\",\"anchormax\":\"0.69 0.0195\",\"offsetmin\":\"153 32.9\",\"offsetmax\":\"174.6 53\"}]}]";
        static string GUIjsonontank = "[{\"name\":\"tank\",\"parent\":\"Hud\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"color\":\"{color}\",\"png\":\"{png}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.69 0.0195\",\"anchormax\":\"0.69 0.0195\",\"offsetmin\":\"122.4 5.09\",\"offsetmax\":\"144 25.19\"}]}]";
        static string GUIjsononheli = "[{\"name\":\"helis\",\"parent\":\"Hud\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"color\":\"{color}\",\"png\":\"{png}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.69 0.0195\",\"anchormax\":\"0.69 0.0195\",\"offsetmin\":\"91.8 32.9\",\"offsetmax\":\"113.4 53\"}]}]";
        static string GUIjsononchinook = "[{\"name\":\"chelnok\",\"parent\":\"Hud\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"color\":\"{color}\",\"png\":\"{png}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.69 0.0195\",\"anchormax\":\"0.69 0.0195\",\"offsetmin\":\"122.4 32.9\",\"offsetmax\":\"144 53\"}]}]";

        private void FarmGUI(TypeGui funct = TypeGui.All, List<Network.Connection> sendto = null)
        {
            if (sendto == null) sendto = Network.Net.sv.connections.Where(x => !_players.Contains(x.userid)).ToList();
            if (funct == TypeGui.All)
            {
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "DestroyUI", "FarmGUI3");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "AddUI", GUIjsonfon);
            }
            if (funct == TypeGui.All || funct == TypeGui.Message)
            {
                string text = GUIjsonmessage.Replace("{text}", config.messages[Random.Range(0, config.messages.Count)]);
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "DestroyUI", "message");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "AddUI", text);
            }
            if (funct == TypeGui.All || funct == TypeGui.Time)
            {
                string text = GUIjsontimer.Replace("{text}", TOD_Sky.Instance.Cycle.DateTime.ToString("HH:mm", CultureInfo.InvariantCulture));
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "DestroyUI", "timer");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "AddUI", text);
            }
            if (funct == TypeGui.All || funct == TypeGui.Online)
            {
                string text = GUIjsononline.Replace("{text}", config.message.Replace("{players}", (BasePlayer.activePlayerList.Count + config.onliner).ToString()).Replace("{maxplayers}", ConVar.Server.maxplayers.ToString()));
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "DestroyUI", "online");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "AddUI", text);
            }
            if (funct == TypeGui.All || funct == TypeGui.Plane)
            {
                string gui = GUIjsononplane.Replace("{png}", GetImage("plane")).Replace("{color}", planes > 0 ? "0.5 1 0.5 0.7" : "1 1 1 0.7");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "DestroyUI", "plane");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "AddUI", gui);
            }
            if (funct == TypeGui.All || funct == TypeGui.Ship)
            {
                string gui = GUIjsononship.Replace("{png}", GetImage("cargo")).Replace("{color}", ships > 0 ? "0 0.7 1 0.7" : "1 1 1 0.7");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "DestroyUI", "boat");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "AddUI", gui);
            }
            if (funct == TypeGui.All || funct == TypeGui.Tank)
            {
                string gui = GUIjsonontank.Replace("{png}", GetImage("tank")).Replace("{color}", tanks > 0 ? "0.7 0.9 0.5 0.7" : "1 1 1 0.7");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "DestroyUI", "tank");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "AddUI", gui);
            }
            if (funct == TypeGui.All || funct == TypeGui.Heli)
            {
                string gui = GUIjsononheli.Replace("{png}", GetImage("heli")).Replace("{color}", helicopters > 0 ? "1 0.5 0.5 0.7" : "1 1 1 0.7");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "DestroyUI", "helis");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "AddUI", gui);
            }
            if (funct == TypeGui.All || funct == TypeGui.Chinook)
            {
                string gui = GUIjsononchinook.Replace("{png}", GetImage("chelnok")).Replace("{color}", chinooks > 0 ? "0.2 0.8 0.4 0.7" : "1 1 1 0.7");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "DestroyUI", "chelnok");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "AddUI", gui);
            }

        }
        #endregion
    }
}

// --- End of file: PanelV2.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/EnhancedBanSystem.cs ---
// --- Original Local Path: KualaRust/EnhancedBanSystem.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Database;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core.SQLite.Libraries;
using System.Text.RegularExpressions;

namespace Oxide.Plugins
{
    [Info("Enhanced Ban System", "Reneb/Slut", "5.2.4")]
    class EnhancedBanSystem : CovalencePlugin
    {
        [PluginReference]
        private Plugin PlayerDatabase, DiscordMessages;

        ////////////////////////////////////////////////////////////
        // Static fields
        ////////////////////////////////////////////////////////////
        static DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        char[] ipChrArray = new char[] { '.' };

        private static BanSystem banSystem;

        static Hash<int, BanData> cachedBans = new Hash<int, BanData>();

        static List<int> wasBanned = new List<int>();

        ////////////////////////////////////////////////////////////
        // Config fields
        ////////////////////////////////////////////////////////////
        private static string Platform = "Steam";
        private static string Server = "1.1.1.1:28015";
        private static string Game = "Rust";

        string PermissionBan = "enhancedbansystem.ban";
        string PermissionUnban = "enhancedbansystem.unban";
        string PermissionBanlist = "enhancedbansystem.banlist";
        string PermissionKick = "enhancedbansystem.kick";

        private bool SQLite_use = false;
        private string SQLite_DB = "banlist.db";

        private bool MySQL_use = false;
        private string MySQL_Host = "localhost";
        private int MySQL_Port = 3306;
        private string MySQL_DB = "banlist";
        private string MySQL_User = "root";
        private string MySQL_Pass = "toor";

        private bool PlayerDatabase_use = false;
        private string PlayerDatabase_IPFile = "EnhancedBanSystem_IPs.json";

        private bool Files_use = false;

        private bool WebAPI_use = false;
        private string WebAPI_Ban_Request = "http://webpage.com/api.php?action=ban&pass=mypassword&id={id}&steamid={steamid}&name={name}&ip={ip}&reason={reason}&source={source}&game={game}&platform={platform}&server={server}&tempban={expiration}";
        private string WebAPI_Unban_Request = "http://webpage.com/api.php?action=unban&pass=mypassword&steamid={steamid}&name={name}&ip={ip}&name={name}&source={source}";
        private string WebAPI_IsBanned_Request = "http://webpage.com/api.php?action=isbanned&pass=mypassword&id={id}&update={update}&steamid={steamid}&ip={ip}&time={time}&name={name}&game=Rust&server=rust.kortal.org:28015";
        private string WebAPI_Banlist_Request = "http://webpage.com/banlist.php?startid={startid}";

        private bool Native_use = false;

        private string BanDefaultReason = "KualaBanan";
        private string BanEvadeReason = "Ban Evade";

        private bool Kick_Broadcast = true;
        private bool Kick_Log = true;
        private bool Kick_OnBan = true;

        private bool Ban_Broadcast = true;
        private bool Ban_Log = true;
        private bool Discord_use = false;
        private string Discord_Webhook = "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks";

        private bool Ban_Escape = true;

        private bool Log_Denied = true;

        protected override void LoadDefaultConfig() { }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }

        void Init()
        {
            CheckCfg<string>("Server Info - Platform", ref Platform);
            CheckCfg<string>("Server Info - Game", ref Game);
            CheckCfg<string>("Server Info - IP:PORT", ref Server);

            CheckCfg<string>("Permissions - Ban", ref PermissionBan);
            CheckCfg<string>("Permissions - Unban", ref PermissionUnban);
            CheckCfg<string>("Permissions - Banlist", ref PermissionBanlist);
            CheckCfg<string>("Permissions - Kick", ref PermissionKick);

            CheckCfg<bool>("DataType - SQLite - use", ref SQLite_use);
            CheckCfg<string>("DataType - SQLite - Database Filename", ref SQLite_DB);

            CheckCfg<bool>("DataType - MySQL - use", ref MySQL_use);
            CheckCfg<string>("DataType - MySQL - Host", ref MySQL_Host);
            CheckCfg<int>("DataType - MySQL - Port", ref MySQL_Port);
            CheckCfg<string>("DataType - MySQL - Database", ref MySQL_DB);
            CheckCfg<string>("DataType - MySQL - User", ref MySQL_User);
            CheckCfg<string>("DataType - MySQL - Pass", ref MySQL_Pass);

            CheckCfg<bool>("DataType - Files - use", ref Files_use);

            CheckCfg<bool>("DataType - PlayerDatabase - use", ref PlayerDatabase_use);
            CheckCfg<string>("DataType - PlayerDatabase - IP Filename", ref PlayerDatabase_IPFile);

            CheckCfg<bool>("DataType - WebAPI - use", ref WebAPI_use);
            CheckCfg<string>("DataType - WebAPI - Host", ref WebAPI_Ban_Request);
            CheckCfg<string>("DataType - WebAPI - Unban", ref WebAPI_Unban_Request);
            CheckCfg<string>("DataType - WebAPI - IsBanned", ref WebAPI_IsBanned_Request);
            CheckCfg<string>("DataType - WebAPI - Banlist", ref WebAPI_Banlist_Request);

            CheckCfg<bool>("DataType - Native - use", ref Native_use);

            CheckCfg<bool>("Ban - Evade", ref Ban_Escape);
            CheckCfg<string>("Ban - Default Reason", ref BanDefaultReason);
            CheckCfg<string>("Ban - Evade Reason", ref BanEvadeReason);
            CheckCfg<bool>("Ban - Broadcast", ref Ban_Broadcast);
            CheckCfg<bool>("Ban - Log", ref Ban_Log);
            CheckCfg<bool>("DiscordMessages - Use Discord", ref Discord_use);
            CheckCfg<string>("DiscordMessages - Discord Webhook", ref Discord_Webhook);

            CheckCfg<bool>("Kick - Broadcast", ref Kick_Broadcast);
            CheckCfg<bool>("Kick - Log", ref Kick_Log);
            CheckCfg<bool>("Kick - On Ban", ref Kick_OnBan);

            CheckCfg<bool>("Denied Connection - Log", ref Log_Denied);

            SaveConfig();

            if (SQLite_use) banSystem |= BanSystem.SQLite;
            if (MySQL_use) banSystem |= BanSystem.MySQL;
            if (Native_use) banSystem |= BanSystem.Native;
            if (PlayerDatabase_use) banSystem |= BanSystem.PlayerDatabase;
            if (Files_use) banSystem |= BanSystem.Files;
            if (WebAPI_use) banSystem |= BanSystem.WebAPI;

            InitializeLang();
        }

        void InitializeLang()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "PlayerNotFound", "No matching player was found.\n" },
                { "PlayerTempBanned", "You are temporarily banned from this server ({0}). {1} left" },
                { "PlayerPermBanned", "You are permanently banned from this server ({0})." },
                {"LoadedBans","Loaded {0} bans" },
                {"BanExists","This ban already exists ({0})." },
                {"BanAdded","Successfully added {0} to the banlist." },
                {"MultipleBans","Multiple Bans Found:\n\r" },
                {"BansRemoved","{0} matching bans were removed" },
                {"PlayerNotBanned","{0} - {1} isn't banned.\n" },
                {"Loaded","Loaded" },
                {"NoPermission","You don't have the permission to use this command." },
                {"KickSyntax","Syntax: kick < Name | SteamID | IP | IP Range > < reason(optional) >" },
                {"UnbanSyntax","Syntax: unban < Name | SteamID | IP | IP Range >" },
                {"BanSyntax","Syntax: ban < Name | SteamID | IP | IP Range > < reason(optional) > < time in secondes(optional) > " },
                {"BanlistSyntax","Syntax: banlist <BanSystem> <startid>" },
                {"BanSystems","Avaible BanSystems:\n" },
                {"BanlistSyntax1","Wrong usage of /banlist" },
                {"OutOfRange","Index is out of range. Current bans recorded: {0}" },
                {"Banlist","Banlist - {0}-{1}/{2}\n" },
                {"PlayerPermBan", "{0} was permanently banned from the server for {1}" },
                {"PlayerTempBan", "{0} was temporarily banned for {1} for {2}" },
                {"IPPermBan", "An IP was banned from the server for {0}" },
                {"IPTempBan", "An IP was temporarily banned for {0} for {1}" },
                {"BanUpdated", "Succesfully updated {0} in the banlist." }
            }, this);
        }

        ////////////////////////////////////////////////////////////
        // ID Save
        ////////////////////////////////////////////////////////////

        private static DynamicConfigFile Ban_ID_File;
        private static int Ban_ID = 0;

        void Load_ID()
        {
            try
            {
                Ban_ID_File = Interface.Oxide.DataFileSystem.GetDatafile(Name + "_ID");
                Ban_ID = (int)Ban_ID_File["id"];
            }
            catch
            {
                Ban_ID = 0;
                Ban_ID_File["id"] = Ban_ID;
                Save_ID();
            }
        }

        void Save_ID()
        {
            Interface.Oxide.DataFileSystem.SaveDatafile(Name + "_ID");
        }

        static int GetNewID()
        {
            Ban_ID++;
            Ban_ID_File["id"] = Ban_ID;
            return Ban_ID;
        }

        ////////////////////////////////////////////////////////////
        // Enum & Class
        ////////////////////////////////////////////////////////////

        enum BanSystem
        {
            Native = 1,
            MySQL = 2,
            SQLite = 4,
            WebAPI = 8,
            PlayerDatabase = 16,
            Files = 32,
        }

        class BanData
        {
            public int id;
            public string steamid;
            public string ip;
            public string name;
            public string game;
            public string server;
            public string source;
            public double date;
            public double expire;
            public string reason;
            public string platform;

            public BanData() { }

            public BanData(object source, string userID, string name, string ip, string reason, double duration)
            {
                this.id = GetNewID();
                this.source = source is IPlayer ? ((IPlayer)source).Name : source is string ? (string)source : "Console";
                this.steamid = userID;
                this.name = name;
                this.ip = ip;
                this.reason = reason;
                this.expire = duration != 0.0 ? LogTime() + duration : 0.0;
                this.date = LogTime();
                this.platform = Platform;
                this.game = Game;
                this.server = Server;
            }

            public BanData(int id, string source, string userID, string name, string ip, string reason, string duration)
            {
                this.id = id;
                this.source = source;
                this.steamid = userID;
                this.name = name;
                this.ip = ip;
                this.reason = reason;
                this.expire = double.Parse(duration);
                this.date = LogTime();
                this.platform = Platform;
                this.game = Game;
                this.server = Server;
            }

            public string ToJson()
            {
                return JsonConvert.SerializeObject(this);
            }

            public override string ToString()
            {
                return string.Format("{0} - {1} - {2} - {3} - {4}", steamid, name, ip, reason, expire == 0.0 ? "Permanent" : expire < LogTime() ? "Expired" : string.Format("Temporary: {0}s", (expire - LogTime()).ToString()));
            }
        }

        ////////////////////////////////////////////////////////////
        // General Methods
        ////////////////////////////////////////////////////////////


        private bool IsPluginLoaded(Plugin plugin)
        {
            if (plugin != null)
            {
                return plugins.GetAll().Where(x => x.Equals(plugin) && x.IsLoaded) != null;
            }
            else
            {
                return false;
            }
        }
        string FormatTime(TimeSpan time) => $"{(time.Days == 0 ? string.Empty : $"{time.Days} day(s)")}{(time.Days != 0 && time.Hours != 0 ? $", " : string.Empty)}{(time.Hours == 0 ? string.Empty : $"{time.Hours} hour(s)")}{(time.Hours != 0 && time.Minutes != 0 ? $", " : string.Empty)}{(time.Minutes == 0 ? string.Empty : $"{time.Minutes} minute(s)")}{(time.Minutes != 0 && time.Seconds != 0 ? $", " : string.Empty)}{(time.Seconds == 0 ? string.Empty : $"{time.Seconds} second(s)")}";

        private bool TryParseTimeSpan(string source, out TimeSpan timeSpan)
        {
            int seconds = 0, minutes = 0, hours = 0, days = 0;

            Match s = new Regex(@"(\d+?)s", RegexOptions.IgnoreCase).Match(source);
            Match m = new Regex(@"(\d+?)m", RegexOptions.IgnoreCase).Match(source);
            Match h = new Regex(@"(\d+?)h", RegexOptions.IgnoreCase).Match(source);
            Match d = new Regex(@"(\d+?)d", RegexOptions.IgnoreCase).Match(source);

            if (s.Success)
                seconds = Convert.ToInt32(s.Groups[1].ToString());

            if (m.Success)
                minutes = Convert.ToInt32(m.Groups[1].ToString());

            if (h.Success)
                hours = Convert.ToInt32(h.Groups[1].ToString());

            if (d.Success)
                days = Convert.ToInt32(d.Groups[1].ToString());

            source = source.Replace(seconds + "s", string.Empty);
            source = source.Replace(minutes + "m", string.Empty);
            source = source.Replace(hours + "h", string.Empty);
            source = source.Replace(days + "d", string.Empty);

            if (!string.IsNullOrEmpty(source) || (!s.Success && !m.Success && !h.Success && !d.Success))
            {
                timeSpan = default(TimeSpan);
                return false;
            }

            timeSpan = new TimeSpan(days, hours, minutes, seconds);

            return true;
        }


        static double LogTime() => DateTime.UtcNow.Subtract(epoch).TotalSeconds;

        string GetMsg(string key, object steamid = null, params object[] args)
        {

            if (args.Length != 0)
            {
                return string.Format(lang.GetMessage(key, this, steamid is IPlayer ? ((IPlayer)steamid).Id : steamid == null ? null : steamid.ToString()), args);
            }
            else
            {
                return lang.GetMessage(key, this, steamid is IPlayer ? ((IPlayer)steamid).Id : steamid == null ? null : steamid.ToString());
            }
        }

        bool hasPermission(IPlayer player, string permissionName)
        {
            if (player.IsAdmin) return true;
            return permission.UserHasPermission(player.Id.ToString(), permissionName);
        }

        bool isIPAddress(string arg)
        {
            int subIP;
            string[] strArray = arg.Split(ipChrArray);
            if (strArray.Length != 4)
            {
                return false;
            }
            foreach (string str in strArray)
            {
                if (str.Length == 0)
                {
                    return false;
                }
                if (!int.TryParse(str, out subIP) && str != "*")
                {
                    return false;
                }
                if (!(str == "*" || (subIP >= 0 && subIP <= 255)))
                {
                    return false;
                }
            }
            return true;
        }

        bool IPRange(string sourceIP, string targetIP)
        {
            string[] srcArray = sourceIP.Split(ipChrArray);
            string[] trgArray = targetIP.Split(ipChrArray);
            for (int i = 0; i < 4; i++)
            {
                if (srcArray[i] != trgArray[i] && srcArray[i] != "*")
                {
                    return false;
                }
            }
            return true;
        }

        bool RangeFromIP(string sourceIP, out string range1, out string range2, out string range3)
        {
            range1 = string.Empty;
            range2 = string.Empty;
            range3 = string.Empty;
            if (sourceIP == string.Empty) return false;

            string[] strArray = sourceIP.Split(ipChrArray);
            if (strArray.Length != 4)
            {
                return false;
            }

            range1 = string.Format("{0}.*.*.*", strArray[0]);
            range2 = string.Format("{0}.{1}.*.*", strArray[0], strArray[1]);
            range3 = string.Format("{0}.{1}.{2}.*", strArray[0], strArray[1], strArray[2]);

            return true;
        }

        List<IPlayer> FindPlayers(string userIDorNameorIP, object source, out string reason)
        {
            reason = string.Empty;
            var FoundPlayers = players.FindPlayers(userIDorNameorIP).ToList();
            if (FoundPlayers.Count == 0)
            {
                reason = GetMsg("PlayerNotFound", source) + "xd ";
            }
            if (FoundPlayers.Count > 1)
            {
                foreach (var iplayer in FoundPlayers)
                {
                    reason += string.Format("{0} {1}\r\n", iplayer.Id, iplayer.Name);
                }
            }
            return FoundPlayers;
        }

        List<IPlayer> FindConnectedPlayers(string userIDorNameorIP, object source, out string reason)
        {
            reason = string.Empty;
            ulong steamid = 0L;
            var FoundPlayers = new List<IPlayer>();
            ulong.TryParse(userIDorNameorIP, out steamid);
            if (isIPAddress(userIDorNameorIP))
            {
                FoundPlayers = players.All.Where(x => x.IsConnected).Where(w => IPRange(userIDorNameorIP, w.Address)).ToList();
            }
            else if (steamid != 0L)
            {
                var p = players.FindPlayer(userIDorNameorIP);
                if (p != null && p.IsConnected)
                {
                    FoundPlayers.Add(p);
                }
            }
            else
            {
                FoundPlayers = players.FindPlayers(userIDorNameorIP).Where(x => x.IsConnected).ToList();
                if (FoundPlayers.Count > 1)
                {
                    foreach (var iplayer in FoundPlayers)
                    {
                        reason += string.Format("{0} {1}\r\n", iplayer.Id, iplayer.Name);
                    }
                }
            }
            if (FoundPlayers.Count == 0)
            {
                reason = GetMsg("PlayerNotFound", source);
            }
            return FoundPlayers;
        }

        string GetPlayerIP(IPlayer iplayer)
        {
            try
            {
                if (iplayer.IsConnected) return iplayer.Address;
                return GetPlayerIP(iplayer.Id);
            }
            catch
            {
                return GetPlayerIP(iplayer.Id);
            }
        }
        string GetPlayerIP(string userID)
        {
            if (PlayerDatabase != null)
            {
                return (string)PlayerDatabase.Call("GetPlayerData", userID, "ip") ?? string.Empty;
            }
            return string.Empty;
        }

        string GetPlayerName(string userID)
        {
            if (PlayerDatabase != null)
            {
                return (string)PlayerDatabase.Call("GetPlayerData", userID, "name") ?? string.Empty;
            }
            return string.Empty;
        }
        bool HasDelayedAnswer() => BanSystemHasFlag(banSystem, BanSystem.MySQL) || BanSystemHasFlag(banSystem, BanSystem.SQLite) || (BanSystemHasFlag(banSystem, BanSystem.WebAPI));

        bool BanSystemHasFlag(BanSystem b, BanSystem t) => (b & t) == t;

        string FormatReturn(BanSystem system, string msg, params object[] args) => string.Format("{0}: {1}", system.ToString(), string.Format(msg, args));

        void SendReply(object source, string msg)
        {
            if (source is IPlayer) ((IPlayer)source).Reply(msg);
            else if (source is string) return;
            else Interface.Oxide.LogInfo(msg);
        }

        public static string ToShortString(TimeSpan timeSpan)
        {
            return string.Format("{0:00}:{1:00}:{2:00}", (int)timeSpan.TotalHours, timeSpan.Minutes, timeSpan.Seconds);
        }

        ////////////////////////////////////////////////////////////
        // Oxide Hooks
        ////////////////////////////////////////////////////////////


        void OnServerInitialized()
        {
            Load_ID();
            List<string> returnString = new List<string>();

            if (BanSystemHasFlag(banSystem, BanSystem.PlayerDatabase))
            {
                 returnString.Add(PlayerDatabase_Load());
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Files))
            {
                returnString.Add(Files_Load());
            }
            if (BanSystemHasFlag(banSystem, BanSystem.MySQL))
            {
                returnString.Add(MySQL_Load());
            }
            if (BanSystemHasFlag(banSystem, BanSystem.SQLite))
            {
                returnString.Add(SQLite_Load());
            }
            if (BanSystemHasFlag(banSystem, BanSystem.WebAPI))
            {
                returnString.Add(WebAPI_Load());
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Native))
            {
                returnString.Add(Native_Load());
            }

            if (returnString.Count == 0)
            {
                this.LogWarning("You must enable at least one Ban System to use this plugin!");
                Interface.Oxide.UnloadPlugin(Name);
            }

            permission.RegisterPermission(PermissionBan, this);
            permission.RegisterPermission(PermissionBanlist, this);
            permission.RegisterPermission(PermissionKick, this);
            permission.RegisterPermission(PermissionUnban, this);

            Interface.Oxide.LogInfo(string.Join("\n", returnString.ToArray()));

            if (Discord_use && (!IsPluginLoaded(DiscordMessages) || Discord_Webhook.Equals("https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks")))
            {
                LogError("DiscordMessages enabled but it isn't setup correctly.");
                Discord_use = false;
            }
        }

        void Unload() => OnServerSave();

        void OnServerSave()
        {
            Save_ID();
            if (BanSystemHasFlag(banSystem, BanSystem.PlayerDatabase))
            {
                Save_PlayerDatabaseIP();
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Files))
            {
                Save_Files();
            }
        }
        private void OnUserBanned(string name, string id, string address, string reason)
        {
            timer.Once(5f, () =>
            {
                if (!isBanned_Check(name, id, address))
                {
                    Puts("Adding banned player to EnhancedBanSystem");
                    BanData bd = new BanData("Auto Ban", id, name, address, reason, 0.0);
                    ExecuteBan("Auto Ban", bd, false);
                }
            });
        }
        object CanUserLogin(string name, string id, string ip)
        {
            BanData bd = null;
            if (isBanned_NonDelayed(name, id, ip, Ban_Escape, out bd))
            {
                if (bd != null && bd.expire != 0.0)
                {
                    return GetMsg("PlayerTempBanned", id, bd.reason, FormatTime(TimeSpan.FromSeconds(bd.expire - LogTime())));
                }
                return GetMsg("PlayerPermBanned", id, bd == null ? string.Empty : bd.reason);
            }
            return null;
        }

        void OnUserConnected(IPlayer player)
        {
            if (player == null) return;
            string ip = player.Address;
            string name = player.Name;
            string steamid = player.Id;

            isBanned_Delayed(name, steamid, ip, Ban_Escape);
        }

        ////////////////////////////////////////////////////////////
        // Files
        ////////////////////////////////////////////////////////////

        StoredData storedData;

        class StoredData
        {
            public HashSet<string> Banlist = new HashSet<string>();
        }

        string Files_Load()
        {
            try
            {
                storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            }
            catch
            {
                storedData = new StoredData();
            }
            foreach (var b in storedData.Banlist)
            {
                var bd = JsonConvert.DeserializeObject<BanData>(b);
                if (!cachedBans.ContainsKey(bd.id))
                    cachedBans.Add(bd.id, bd);
            }
            return FormatReturn(BanSystem.Files, GetMsg("LoadedBans", null), storedData.Banlist.Count.ToString());
        }

        void Save_Files()
        {
            if (storedData.Banlist == null)
            {
                return;
            }
            Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);
        }

        string Files_UpdateBan(BanData bandata)
        {
            if (!cachedBans.ContainsKey(bandata.id)) return FormatReturn(BanSystem.Files, "No such ban id {0}", bandata.id);

            storedData.Banlist.Remove(cachedBans[bandata.id].ToJson());
            cachedBans.Remove(bandata.id);

            storedData.Banlist.Add(bandata.ToJson());

            if (!cachedBans.ContainsKey(bandata.id))
                cachedBans.Add(bandata.id, bandata);

            return FormatReturn(BanSystem.Files, GetMsg("BanUpdated"), bandata.ToString());
        }

        string Files_ExecuteBan(BanData bandata)
        {

            var f = cachedBans.Values.Where(x => x.ip == bandata.ip).Where(x => x.steamid == bandata.steamid).ToList();
            if (f.Count > 0)
            {
                var i = f.ToList();
                foreach (var id in i)
                {
                    if (id.expire == 0.0 || id.expire < LogTime()) continue;
                    storedData.Banlist.Remove(id.ToJson());
                    f.Remove(id);
                }
                if (f.Count > 0)
                {
                    return FormatReturn(BanSystem.Files, GetMsg("BanExists"), f[0].ToString());
                }
            }
            storedData.Banlist.Add(bandata.ToJson());
            Save_Files();
            if (!cachedBans.ContainsKey(bandata.id))
                cachedBans.Add(bandata.id, bandata);

            return FormatReturn(BanSystem.Files, GetMsg("BanAdded"), bandata.ToString());
        }

        string Files_RawUnban(List<BanData> unbanList)
        {
            int i = 0;
            foreach (var u in unbanList)
            {
                var json = u.ToJson();
                if (storedData.Banlist.Contains(json))
                {
                    i++;
                    storedData.Banlist.Remove(json);
                }
            }
            return FormatReturn(BanSystem.Files, GetMsg("BansRemoved"), i.ToString());
        }

        string Files_ExecuteUnban(string steamid, string name, string ip, out List<BanData> unbanList)
        {
            unbanList = new List<BanData>();
            if (ip != string.Empty)
            {
                unbanList = cachedBans.Values.Where(x => x.ip == ip).ToList();
            }
            else if (steamid != string.Empty)
            {
                unbanList = cachedBans.Values.Where(x => x.steamid == steamid).ToList();
            }
            else
            {
                var list = cachedBans.Values.Where(x => x.name.ToLower().Equals(name.ToLower())).ToList();
                if (list.Count > 1)
                {
                    var ret = FormatReturn(BanSystem.Files, GetMsg("MultipleBans"));
                    foreach (var b in list)
                    {
                        ret += string.Format("{0} - {1} - {2}\n\r", b.steamid, b.name, b.reason);
                    }
                    return ret;
                }
                else
                {
                    unbanList = list;
                }
            }
            return Files_RawUnban(unbanList);
        }

        bool Files_IsBanned(string steamid, string ip, out BanData bandata)
        {
            bandata = null;
            double cTime = LogTime();
            bool permanent = false;
            List<BanData> unbanList = new List<BanData>();
            List<BanData> list = new List<BanData>();
            // check by ID then IP
            var b_steamid = cachedBans.Values.Where(x => x.steamid == steamid).ToList();
            var b_steamid_ip = ip != null ? b_steamid.Where(w => w.ip == ip).ToList() : new List<BanData>();

            foreach (var b in b_steamid_ip)
            {
                if (b.expire != 0.0 && cTime >= b.expire)
                {
                    unbanList.Add(b);
                }
                else
                {
                    if (b.expire == 0.0)
                    {
                        permanent = true;
                    }
                    if (b.ip == ip)
                    {
                        bandata = b;
                    }
                }
            }
            if (unbanList.Count > 0)
            {
                Files_RawUnban(unbanList);
                foreach (var u in unbanList)
                {
                    b_steamid_ip.Remove(u);
                }
                unbanList.Clear();
            }
            foreach (var b in b_steamid)
            {
                if (b.expire != 0.0 && cTime >= b.expire)
                {
                    unbanList.Add(b);
                }
                else
                {
                    if (b.expire == 0.0)
                    {
                        permanent = true;
                    }
                    if (b.ip == ip)
                    {
                        bandata = b;
                    }
                }
            }
            if (unbanList.Count > 0)
            {
                Files_RawUnban(unbanList);
                foreach (var u in unbanList)
                {
                    b_steamid.Remove(u);
                }
                unbanList.Clear();
            }
            if (bandata == null)
            {
                if (b_steamid_ip.Count > 0)
                {
                    bandata = b_steamid_ip[0];
                }
                else if (b_steamid.Count > 0)
                {
                    bandata = b_steamid[0];
                }
            }
            if (bandata == null && !permanent)
            {
                // check by IP & IP Range
                list = ip != null ? cachedBans.Values.Where(x => x.ip != null && IPRange(x.ip, ip)).ToList() : new List<BanData>();
                foreach (var b in list)
                {
                    if (b.expire != 0.0 && cTime >= b.expire)
                    {
                        unbanList.Add(b);
                    }
                    else
                    {
                        if (b.expire == 0.0)
                        {
                            permanent = true;
                        }
                    }
                }
                if (unbanList.Count > 0)
                {
                    Files_RawUnban(unbanList);
                    foreach (var u in unbanList)
                    {
                        list.Remove(u);
                    }
                    unbanList.Clear();
                }
                if (list.Count > 0)
                {
                    bandata = list[0];
                }
            }
            if (bandata != null && bandata.expire != 0.0 && permanent)
            {
                bandata.expire = 0.0;
                Files_UpdateBan(bandata);
            }
            return bandata != null;
        }

        string Files_Banlist(object source, int startid)
        {
            if (startid > cachedBans.Count)
            {
                return FormatReturn(BanSystem.Files, "Index is out of range. Current bans recorded: {0}", cachedBans.Count.ToString());
            }

            int i = -1;
            int max = startid + 9;

            string returnstring = FormatReturn(BanSystem.Files, GetMsg("Banlist"), startid.ToString(), max.ToString(), cachedBans.Count.ToString());


            var bans = from pair in cachedBans orderby pair.Key descending select pair;

            foreach (KeyValuePair<int, BanData> b in bans)
            {
                i++;
                if (i < startid) continue;
                if (i > max) break;
                returnstring += b.ToString() + "\n";

            }

            return returnstring;
        }

        ////////////////////////////////////////////////////////////
        // PlayerDatabase
        ////////////////////////////////////////////////////////////

        static StoredIPData storedIPData;

        class StoredIPData
        {
            public HashSet<string> Banlist = new HashSet<string>();
        }

        string PlayerDatabase_Load()
        {
            if (!IsPluginLoaded(PlayerDatabase)) return FormatReturn(BanSystem.PlayerDatabase, "Missing plugin: oxidemod.org/threads/playerdatabase.18409/");
            try
            {
                storedIPData = Interface.Oxide.DataFileSystem.ReadObject<StoredIPData>(PlayerDatabase_IPFile);
            }
            catch
            {
                storedIPData = new StoredIPData();
            }
            if (storedIPData.Banlist.Count > 0)
            {
                foreach (var b in storedIPData.Banlist)
                {
                    var bd = JsonConvert.DeserializeObject<BanData>(b);
                    if (!cachedBans.ContainsKey(bd.id))
                        cachedBans.Add(bd.id, bd);
                }
            }
            var getKnownPlayers = (List<string>)PlayerDatabase.Call("GetAllKnownPlayers");
            if (getKnownPlayers == null) return FormatReturn(BanSystem.PlayerDatabase, "Error P01");

            int i = 0;
            List<BanData> list = new List<BanData>();
            foreach (var steamid in getKnownPlayers)
            {
                var success = PlayerDatabase.Call("GetPlayerDataRaw", steamid, "Banned");
                if (!(success is string)) continue;
                list = JsonConvert.DeserializeObject<List<BanData>>((string)success);
                foreach (var b in list)
                {
                    i++;
                    if (!cachedBans.ContainsKey(b.id))
                        cachedBans.Add(b.id, b);
                }
            }
            return FormatReturn(BanSystem.PlayerDatabase, GetMsg("LoadedBans"), i.ToString());
        }

        void Save_PlayerDatabaseIP()
        {
            Interface.Oxide.DataFileSystem.WriteObject(PlayerDatabase_IPFile, storedIPData);
        }


        string PlayerDatabase_ExecuteBan(BanData bandata)
        {
            if (bandata.steamid != string.Empty)
            {
                List<BanData> list = new List<BanData>();
                var success = PlayerDatabase.Call("GetPlayerDataRaw", bandata.steamid, "Banned");
                if (success is string)
                {
                    list = JsonConvert.DeserializeObject<List<BanData>>((string)success);
                }

                var f = list.Where(x => x.ip == bandata.ip).ToList();
                if (f.Count > 0)
                {
                    return FormatReturn(BanSystem.PlayerDatabase, GetMsg("BanExists"), f[0].ToString());
                }
                f.Add(bandata);
                PlayerDatabase.Call("SetPlayerData", bandata.steamid, "Banned", f);
            }
            else
            {
                var f2 = cachedBans.Values.Where(x => x.ip == bandata.ip).Where(x => x.steamid == string.Empty).ToList();
                if (f2.Count > 0)
                {
                    return FormatReturn(BanSystem.PlayerDatabase, GetMsg("BanExists"), f2[0].ToString());
                }
                storedIPData.Banlist.Add(bandata.ToJson());
            }
            if (!cachedBans.ContainsKey(bandata.id))
                cachedBans.Add(bandata.id, bandata);
            return FormatReturn(BanSystem.PlayerDatabase, GetMsg("BanAdded"), bandata.ToString());
        }

        string PlayerDatabase_UpdateBan(BanData bandata, double expire)
        {
            if (bandata.steamid == string.Empty)
            {
                if (cachedBans.ContainsKey(bandata.id))
                {
                    var json = bandata.ToJson();
                    if (storedIPData.Banlist.Contains(json))
                    {
                        cachedBans.Remove(bandata.id);
                        storedIPData.Banlist.Remove(json);
                        bandata.expire = expire;
                        storedIPData.Banlist.Add(bandata.ToJson());
                        cachedBans.Add(bandata.id, bandata);
                        return FormatReturn(BanSystem.Files, GetMsg("BanUpdated"), bandata.ToString());
                    }
                }
            }
            else
            {
                List<BanData> list = new List<BanData>();
                bandata.expire = expire;
                var b_steamid = PlayerDatabase.Call("GetPlayerDataRaw", bandata.steamid, "Banned");
                if (b_steamid is string)
                {
                    list = JsonConvert.DeserializeObject<List<BanData>>((string)b_steamid);
                }
                if (list.Count > 0)
                {
                    foreach (var b in list)
                    {
                        b.expire = expire;
                    }
                    PlayerDatabase.Call("SetPlayerData", bandata.steamid, "Banned", list);
                    return FormatReturn(BanSystem.Files, GetMsg("BanUpdated"), bandata.ToString());
                }
            }
            return string.Empty;
        }

        string PlayerDatabase_RawUnban(List<BanData> unbanList)
        {
            int i = 0;
            foreach (var u in unbanList)
            {
                if (u.steamid == string.Empty)
                {
                    var json = u.ToJson();
                    if (storedIPData.Banlist.Contains(json))
                    {
                        i++;
                        storedIPData.Banlist.Remove(json);
                    }
                }
                else
                {
                    i++;
                    PlayerDatabase.Call("SetPlayerData", u.steamid, "Banned", new List<BanData>());
                }
            }
            return FormatReturn(BanSystem.PlayerDatabase, GetMsg("BansRemoved"), i.ToString());
        }

        string PlayerDatabase_ExecuteUnban(string steamid, string name, string ip, out List<BanData> unbanList)
        {
            unbanList = new List<BanData>();
            if (ip != string.Empty)
            {
                unbanList = cachedBans.Values.Where(x => x.ip == ip).ToList();
            }
            else if (steamid != string.Empty)
            {
                unbanList = cachedBans.Values.Where(x => x.steamid == steamid).ToList();
            }
            else
            {
                unbanList = cachedBans.Values.Where(x => x.name == name).ToList();
                if (unbanList.Count == 0)
                {
                    var lname = name.ToLower();
                    unbanList = cachedBans.Values.Where(x => x.name.ToLower().Contains(lname)).ToList();
                    if (unbanList.Count > 1)
                    {
                        var ret = FormatReturn(BanSystem.PlayerDatabase, GetMsg("MultipleBans"));
                        foreach (var b in unbanList)
                        {
                            ret += string.Format("{0} - {1} - {2}\n\r", b.steamid, b.name, b.reason);
                        }
                        return ret;
                    }
                }
            }
            return PlayerDatabase_RawUnban(unbanList);
        }

        bool PlayerDatabase_IsBanned(string steamid, string ip, out BanData bandata)
        {
            bandata = null;
            BanData possibleData = null;
            double cTime = LogTime();
            bool permanent = false;
            List<BanData> unbanList = new List<BanData>();
            List<BanData> list = new List<BanData>();
            // check by ID then IP
            var b_steamid = PlayerDatabase.Call("GetPlayerDataRaw", steamid, "Banned");
            if (b_steamid is string)
            {
                list = JsonConvert.DeserializeObject<List<BanData>>((string)b_steamid);
            }
            foreach (var b in list)
            {
                if (b.expire != 0.0 && cTime >= b.expire)
                {
                    unbanList.Add(b);
                }
                else
                {
                    if (b.expire == 0.0)
                    {
                        permanent = true;
                    }
                    if (b.ip == ip)
                    {
                        bandata = b;
                    }
                }
            }
            if (unbanList.Count > 0)
            {
                PlayerDatabase_RawUnban(unbanList);
                foreach (var b in unbanList)
                {
                    list.Remove(b);
                }
                unbanList.Clear();
            }

            if (list.Count > 0 && bandata == null)
            {
                possibleData = list[0];
            }
            // check by IP & IP Range
            list = ip != null ? cachedBans.Values.Where(x => x.ip != null && IPRange(x.ip, ip)).ToList() : new List<BanData>();
            foreach (var b in list)
            {
                if (b.expire != 0.0 && cTime >= b.expire)
                {
                    unbanList.Add(b);
                }
                else
                {
                    if (b.expire == 0.0)
                    {
                        permanent = true;
                    }
                }
            }
            if (unbanList.Count > 0)
            {
                PlayerDatabase_RawUnban(unbanList);
                foreach (var b in unbanList)
                {
                    list.Remove(b);
                }
                unbanList.Clear();
            }
            if (list.Count > 0 && bandata == null && possibleData == null)
            {
                possibleData = list[0];
            }
            if (bandata == null && possibleData != null)
            {
                bandata = possibleData;
            }
            if (bandata != null && bandata.expire != 0.0 && permanent)
            {
                PlayerDatabase_UpdateBan(bandata, 0.0);
            }
            return bandata != null;
        }

        string PlayerDatabase_Banlist(object source, int startid)
        {
            if (startid > cachedBans.Count)
            {
                return FormatReturn(BanSystem.PlayerDatabase, GetMsg("OutOfRange"), cachedBans.Count.ToString());
            }

            int i = -1;
            int max = startid + 9;

            string returnstring = FormatReturn(BanSystem.PlayerDatabase, GetMsg("Banlist"), startid.ToString(), max.ToString(), cachedBans.Count.ToString());


            var bans = from pair in cachedBans orderby pair.Key descending select pair;

            foreach (KeyValuePair<int, BanData> b in bans)
            {
                i++;
                if (i < startid) continue;
                if (i > max) break;
                returnstring += b.ToString() + "\n";

            }

            return returnstring;
        }

        ////////////////////////////////////////////////////////////
        // WebAPI
        ////////////////////////////////////////////////////////////

        string FormatOnlineBansystem(string line, Dictionary<string, string> args)
        {
            foreach (KeyValuePair<string, string> pair in args)
            {
                line = line.Replace(pair.Key, pair.Value);
            }
            return line;
        }

        string WebAPI_ExecuteBan(object source, BanData bandata)
        {
            webrequest.Enqueue(FormatOnlineBansystem(WebAPI_Ban_Request, new Dictionary<string, string> { { "{id}", bandata.id.ToString() }, { "{steamid}", bandata.steamid }, { "{name}", bandata.name }, { "{ip}", bandata.ip }, { "{reason}", bandata.reason }, { "{source}", bandata.source }, { "{expiration}", bandata.expire.ToString() }, { "{game}", bandata.game }, { "{platform}", bandata.platform }, { "{server}", bandata.server } }), null, (code, response) =>
            {
                if (response == null && code == 200)
                {
                    response = FormatReturn(BanSystem.WebAPI, "Couldn't contact the WebAPI");
                }
                if (source is IPlayer) ((IPlayer)source).Reply(response);
                else Interface.Oxide.LogInfo(response);
            }, this);


            return string.Empty;
        }

        string WebAPI_ExecuteUnban(object source, string steamid, string name, string ip)
        {
            webrequest.Enqueue(FormatOnlineBansystem(WebAPI_Unban_Request, new Dictionary<string, string> { { "{steamid}", steamid }, { "{name}", name }, { "{ip}", ip } }), null, (code, response) =>
            {
                if (response == null && code == 200)
                {
                    response = FormatReturn(BanSystem.WebAPI, "Couldn't contact the WebAPI");
                }
                if (source is IPlayer) ((IPlayer)source).Reply(response);
                else Interface.Oxide.LogInfo(response);
            }, this);

            return string.Empty;
        }

        string WebAPI_IsBanned(BanData bandata, bool update)
        {
            webrequest.Enqueue(FormatOnlineBansystem(WebAPI_IsBanned_Request, new Dictionary<string, string> { { "{id}", bandata.id.ToString() }, { "{steamid}", bandata.steamid }, { "{name}", bandata.name }, { "{ip}", bandata.ip }, { "{source}", "Auto Ban" }, { "{update}", update.ToString() }, { "{time}", LogTime().ToString() } }), null, (code, response) =>
            {
                if (response != null || code != 200)
                {
                    if (response == "false" || response == "0")
                        return;
                    timer.Once(0.01f, () => Kick(null, bandata.steamid, response == "true" || response == "1" ? "Banned" : response, false));
                }
                else
                {
                    Interface.Oxide.LogWarning("WebAPI couldn't be contacted or is not valid");
                }
            }, this);

            return string.Empty;
        }

        string WebAPI_Banlist(object source, int startid)
        {
            webrequest.Enqueue(FormatOnlineBansystem(WebAPI_Banlist_Request, new Dictionary<string, string> { { "{startid}", startid.ToString() } }), null, (code, response) =>
            {
                if (response != null || code != 200)
                {
                    SendReply(source, response);
                }
            }, this);

            return string.Empty;
        }

        string WebAPI_Load()
        {
            return FormatReturn(BanSystem.WebAPI, GetMsg("Loaded"));
        }

        ////////////////////////////////////////////////////////////
        // SQLite
        ////////////////////////////////////////////////////////////

        SQLite Sqlite = Interface.Oxide.GetLibrary<SQLite>();
        Connection Sqlite_conn;

        string SQLite_Load()
        {
            var returnstring = string.Empty;
            try
            {
                Sqlite_conn = Sqlite.OpenDb(SQLite_DB, this);
                if (Sqlite_conn == null)
                {
                    returnstring = FormatReturn(BanSystem.SQLite, "Couldn't open the SQLite.");
                }
                else
                {
                    Sqlite.Insert(Core.Database.Sql.Builder.Append("CREATE TABLE IF NOT EXISTS EnhancedBanSystem ( id INTEGER NOT NULL PRIMARY KEY UNIQUE, steamid TEXT, name TEXT, ip TEXT, reason TEXT, source TEXT, game TEXT, platform TEXT, server TEXT, expire INTEGER );"), Sqlite_conn);
                    returnstring = FormatReturn(BanSystem.SQLite, GetMsg("Loaded"));
                }
            }
            catch (Exception e)
            {
                returnstring = e.Message;
            }
            return FormatReturn(BanSystem.SQLite, returnstring);
        }


        string SQLite_RawBan(BanData bandata)
        {
            try
            {
                Sqlite.Insert(Core.Database.Sql.Builder.Append("INSERT OR REPLACE INTO EnhancedBanSystem ( id, steamid, name, ip, reason, source, game, platform, server, expire ) VALUES ( @0, @1, @2, @3, @4, @5, @6, @7, @8, @9 )", bandata.id, bandata.steamid, bandata.name, bandata.ip, bandata.reason, bandata.source, bandata.game, bandata.platform, bandata.server, (int)bandata.expire), Sqlite_conn);
            }
            catch (Exception e)
            {
                return e.Message;
            }
            return FormatReturn(BanSystem.SQLite, GetMsg("BanAdded"), bandata.ToString());
        }

        string SQLite_ExecuteBan(object source, BanData bandata)
        {
            var sqlString = bandata.steamid == string.Empty ? Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `ip` == @0 ", bandata.ip) : Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `steamid` == @0 AND `ip` == @1 ", bandata.steamid, bandata.ip);

            Sqlite.Query(sqlString, Sqlite_conn, list =>
            {
                if (list != null)
                {
                    foreach (var entry in list)
                    {
                        var bd = new BanData(int.Parse(entry["id"].ToString()), (string)entry["source"], (string)entry["steamid"], (string)entry["name"], (string)entry["ip"], (string)entry["reason"], entry["expire"].ToString());
                        var response = FormatReturn(BanSystem.SQLite, GetMsg("BanExists"), bd.ToString());
                        SendReply(source, response);
                        return;
                    }
                }
                var reponse2 = SQLite_RawBan(bandata);
                if (source is IPlayer) ((IPlayer)source).Reply(reponse2);
                else Interface.Oxide.LogInfo(reponse2);
            });

            return string.Empty;
        }

        void SQLite_RawUnban(object source, List<long> unbanList)
        {
            foreach (var id in unbanList)
            {
                Sqlite.Insert(Core.Database.Sql.Builder.Append("DELETE from EnhancedBanSystem WHERE `id` = @0", id), Sqlite_conn);
            }
            var returnstring = FormatReturn(BanSystem.SQLite, GetMsg("BansRemoved"), unbanList.Count.ToString());
            SendReply(source, returnstring);
        }

        string SQLite_ExecuteUnban(object source, string steamid, string name, string ip)
        {
            List<long> unbanList = new List<long>();
            if (ip != string.Empty || steamid != string.Empty)
            {
                var sqlString = ip != string.Empty ? Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `ip` == @0 ", ip) : Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `steamid` == @0", steamid);
                Sqlite.Query(sqlString, Sqlite_conn, list =>
                {
                    if (list != null)
                    {
                        foreach (var entry in list)
                        {
                            unbanList.Add((long)entry["id"]);
                        }
                    }
                    SQLite_RawUnban(source, unbanList);
                });
            }
            else
            {
                Sqlite.Query(Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `name` LIKE @0", "%" + name + "%"), Sqlite_conn, list =>
                {
                    List<Dictionary<string, object>> f = new List<Dictionary<string, object>>();
                    if (list != null)
                    {
                        foreach (var entry in list)
                        {
                            f.Add(entry);
                            unbanList.Add((long)entry["id"]);
                        }
                    }
                    if (unbanList.Count > 1)
                    {
                        var ret = FormatReturn(BanSystem.SQLite, GetMsg("MultipleBans"));
                        foreach (var e in f)
                        {
                            ret += string.Format("{0} - {1} - {2}\n\r", (string)e["steamid"], (string)e["name"], (string)e["reason"]);
                        }
                        if (source is IPlayer) ((IPlayer)source).Reply(ret);
                        else Interface.Oxide.LogInfo(ret);
                        return;
                    }
                    SQLite_RawUnban(source, unbanList);
                });
            }
            return string.Empty;
        }

        void SQLite_UpdateBan(BanData bandata)
        {
            Sqlite.Insert(Core.Database.Sql.Builder.Append("UPDATE EnhancedBanSystem SET `steamid`= @1, `name`= @2, `ip`= @3,`reason`= @4,`source`=@5, `game`= @6, `platform`= @7,`server`= @8, `expire`= @9 WHERE `id` = @0", bandata.id, bandata.steamid, bandata.name, bandata.ip, bandata.reason, bandata.source, bandata.game, bandata.platform, bandata.server, (int)bandata.expire), Sqlite_conn);
        }

        void SQLite_IsBanned(BanData bandata, bool update)
        {
            bandata.reason = BanEvadeReason;

            double cTime = LogTime();
            List<long> unbanList = new List<long>();
            Dictionary<string, object> match = new Dictionary<string, object>();

            Sqlite.Query(Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `steamid` == @0", bandata.steamid), Sqlite_conn, list =>
            {

                var l = new List<Dictionary<string, object>>();
                if (list != null)
                {
                    foreach (var entry in list)
                    {
                        var expire = (long)entry["expire"];
                        if (expire != 0.0 && cTime >= expire)
                        {
                            unbanList.Add((long)entry["id"]);
                        }
                        else
                        {
                            if ((string)entry["ip"] == bandata.ip)
                            {
                                match = entry;
                            }
                            l.Add(entry);
                        }
                    }
                }
                if (unbanList.Count > 0)
                {
                    SQLite_RawUnban("Auto Ban", unbanList);
                    unbanList.Clear();
                }
                var l2 = l.Where(x => (long)x["expire"] == 0L).ToList();
                if (l2.Count == 0)
                {
                    string range1;
                    string range2;
                    string range3;
                    if (RangeFromIP(bandata.ip, out range1, out range2, out range3))
                    {
                        Sqlite.Query(Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `ip` == @0 OR `ip` == @1 OR `ip` == @2 OR `ip` == @3", bandata.ip, range1, range2, range3), Sqlite_conn, list2 =>
                        {
                            if (list2 != null)
                            {
                                foreach (var entry in list2)
                                {
                                    var expire = (long)entry["expire"];
                                    if (expire != 0.0 && cTime >= expire)
                                    {
                                        unbanList.Add((long)entry["id"]);
                                    }
                                    else
                                    {
                                        if (!l.Contains(entry))
                                            l.Add(entry);
                                    }
                                }
                            }
                            if (l.Count > 0)
                            {
                                l2 = l.Where(x => (long)x["expire"] == 0L).ToList();
                                bandata.expire = l2.Count > 0 ? 0.0 : match.ContainsKey("expire") ? (long)(match["expire"]) : (long)(l[0]["expire"]);
                                if (match.ContainsKey("expire"))
                                {
                                    if ((long)(match["expire"]) != bandata.expire)
                                    {
                                        var bd = new BanData(int.Parse(match["id"].ToString()), (string)match["source"], (string)match["steamid"], (string)match["name"], (string)match["ip"], (string)match["reason"], match["expire"].ToString());
                                        bd.expire = bandata.expire;
                                        SQLite_UpdateBan(bd);
                                    }
                                }
                                else if (update) ExecuteBan("Auto Ban", bandata, false);
                                timer.Once(0.1f, () => Kick(null, bandata.steamid, match.ContainsKey("reason") ? (string)match["reason"] : (string)l[0]["reason"], false));
                            }
                        });
                    }
                }
                if (l.Count > 0)
                {
                    bandata.expire = l2.Count > 0 ? 0.0 : match.ContainsKey("expire") ? (long)(match["expire"]) : (long)(l[0]["expire"]);
                    if (match.ContainsKey("expire"))
                    {
                        if ((long)(match["expire"]) != bandata.expire)
                        {
                            var bd = new BanData(int.Parse(match["id"].ToString()), (string)match["source"], (string)match["steamid"], (string)match["name"], (string)match["ip"], (string)match["reason"], match["expire"].ToString());
                            SQLite_UpdateBan(bd);
                        }
                    }
                    else if (update) ExecuteBan("Auto Ban", bandata, false);
                    timer.Once(0.1f, () => Kick(null, bandata.steamid, match.ContainsKey("reason") ? (string)match["reason"] : (string)l[0]["reason"], false));
                }
            });
        }

        string SQLite_Banlist(object source, int startid)
        {
            Sqlite.Query(Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem ORDER BY id DESC"), Sqlite_conn, list =>
            {
                int i = -1;
                int max = startid + 9;
                string replystring = string.Empty;
                if (list != null)
                {
                    replystring += FormatReturn(BanSystem.SQLite, GetMsg("Banlist"), startid.ToString(), max.ToString(), list.Count.ToString());
                    foreach (var entry in list)
                    {
                        i++;
                        if (i < startid) continue;
                        if (i > max) break;
                        var bd = new BanData(int.Parse(entry["id"].ToString()), (string)entry["source"], (string)entry["steamid"], (string)entry["name"], (string)entry["ip"], (string)entry["reason"], entry["expire"].ToString());
                        replystring += bd.ToString() + "\n";
                    }
                    SendReply(source, replystring);
                }
            });
            return string.Empty;
        }

        ////////////////////////////////////////////////////////////
        // MySQL
        ////////////////////////////////////////////////////////////

        Oxide.Core.MySql.Libraries.MySql Sql = Interface.Oxide.GetLibrary<Oxide.Core.MySql.Libraries.MySql>();
        Connection Sql_conn;

        string MySQL_Load()
        {
            try
            {
                Sql_conn = Sql.OpenDb(MySQL_Host, MySQL_Port, MySQL_DB, MySQL_User, MySQL_Pass, this);
                if (Sql_conn == null || Sql_conn.Con == null)
                {
                    return FormatReturn(BanSystem.MySQL, "Couldn't open the MySQL PlayerDatabase: {0} ", Sql_conn.Con.State.ToString());
                }
                else
                {
                    Sql.Insert(Core.Database.Sql.Builder.Append("CREATE TABLE IF NOT EXISTS enhancedbansystem ( `id` int(11) NOT NULL, `steamid` VARCHAR(17),`name` VARCHAR(25),`ip` VARCHAR(15),`reason` VARCHAR(25),`source` VARCHAR(25), `game` VARCHAR(25) , `platform` VARCHAR(25), `server` VARCHAR(25), `expire` int(11) );"), Sql_conn);
                    return FormatReturn(BanSystem.MySQL, GetMsg("Loaded"));
                }
            }
            catch (Exception e)
            {
                return FormatReturn(BanSystem.MySQL, e.Message);
            }
        }

        string MySQL_RawBan(BanData bandata)
        {
            try
            {
                Sql.Insert(Core.Database.Sql.Builder.Append("INSERT IGNORE INTO enhancedbansystem ( `id`, `steamid`,`name`,`ip`,`reason`,`source`,`game`,`platform`, `server`, `expire` ) VALUES ( @0, @1, @2, @3, @4, @5, @6, @7, @8, @9 )", bandata.id, bandata.steamid, bandata.name, bandata.ip, bandata.reason, bandata.source, bandata.game, bandata.platform, bandata.server, (int)bandata.expire), Sql_conn);
            }
            catch (Exception e)
            {
                return e.Message;
            }
            return FormatReturn(BanSystem.MySQL, GetMsg("BanAdded"), bandata.ToString());
        }

        void MySQL_UpdateBan(BanData bandata)
        {
            Sqlite.Insert(Core.Database.Sql.Builder.Append("UPDATE EnhancedBanSystem SET `steamid`= @1, `name`= @2, `ip`= @3,`reason`= @4,`source`=@5, `game`= @6, `platform`= @7,`server`= @8, `expire`= @9 WHERE `id` = @0", bandata.id, bandata.steamid, bandata.name, bandata.ip, bandata.reason, bandata.source, bandata.game, bandata.platform, bandata.server, (int)bandata.expire), Sqlite_conn);
        }

        void MySQL_RawUnban(object source, List<int> unbanList)
        {
            foreach (var id in unbanList)
            {
                Sql.Insert(Core.Database.Sql.Builder.Append("DELETE from enhancedbansystem WHERE `id` = @0", id), Sql_conn);
                if (BanSystemHasFlag(banSystem, BanSystem.Native))
                {
                    Native_ExecuteUnban(id.ToString(), null);
                }
            }
            SendReply(source, FormatReturn(BanSystem.MySQL, GetMsg("BansRemoved"), unbanList.Count.ToString()));
        }
        string MySQL_ExecuteBan(object source, BanData bandata)
        {
            var sqlString = bandata.steamid == string.Empty ? Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `ip` = @0 ", bandata.ip) : Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `steamid` = @0 AND `ip` = @1 ", bandata.steamid, bandata.ip);
            Sql.Query(sqlString, Sql_conn, list =>
            {
                if (list != null)
                {
                    foreach (var entry in list)
                    {
                        var bd = new BanData(int.Parse(entry["id"].ToString()), (string)entry["source"], (string)entry["steamid"], (string)entry["name"], (string)entry["ip"], (string)entry["reason"], entry["expire"].ToString());
                        var response = FormatReturn(BanSystem.MySQL, GetMsg("BanExists"), bd.ToString());
                        SendReply(source, response);
                        return;
                    }
                }
                SendReply(source, MySQL_RawBan(bandata));
            });
            return string.Empty;
        }

        string MySQL_ExecuteUnban(object source, string steamid, string name, string ip)
        {
            List<int> unbanList = new List<int>();
            if (ip != string.Empty || steamid != string.Empty)
            {
                var sqlString = ip != string.Empty ? Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `ip` = @0 ", ip) : Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `steamid` = @0", steamid);
                Sql.Query(sqlString, Sql_conn, list =>
                {
                    if (list != null)
                    {
                        foreach (var entry in list)
                        {
                            unbanList.Add((int)entry["id"]);
                        }
                    }
                    MySQL_RawUnban(source, unbanList);
                });
            }
            else
            {
                Sql.Query(Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `name` LIKE @0", "%" + name + "%"), Sql_conn, list =>
                {
                    List<Dictionary<string, object>> f = new List<Dictionary<string, object>>();
                    if (list != null)
                    {
                        foreach (var entry in list)
                        {
                            f.Add(entry);
                            unbanList.Add((int)entry["id"]);
                        }
                    }
                    if (unbanList.Count > 1)
                    {
                        string ret = FormatReturn(BanSystem.MySQL, GetMsg("MultipleBans"));
                        foreach (var e in f)
                        {
                            ret += string.Format("{0} - {1} - {2}\n\r", (string)e["steamid"], (string)e["name"], (string)e["reason"]);
                        }
                        if (source is IPlayer) ((IPlayer)source).Reply(ret);
                        else Interface.Oxide.LogInfo(ret);
                        return;
                    }
                    else
                    {
                        MySQL_RawUnban(source, unbanList);
                    }
                });
            }
            return string.Empty;
        }

        void MySQL_IsBanned(BanData bandata, bool update)
        {
            bandata.reason = BanEvadeReason;

            List<int> unbanList = new List<int>();
            double cTime = LogTime();
            Dictionary<string, object> match = new Dictionary<string, object>();

            Sql.Query(Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `steamid` = @0", bandata.steamid), Sql_conn, list =>
            {
                var l = new List<Dictionary<string, object>>();
                if (list != null)
                {
                    foreach (var entry in list)
                    {
                        var expire = (int)entry["expire"];
                        if (expire != 0 && cTime >= expire)
                        {
                            unbanList.Add((int)entry["id"]);
                        }
                        else
                        {
                            if ((string)entry["ip"] == bandata.ip)
                            {
                                match = entry;
                            }
                            l.Add(entry);
                        }
                    }
                }
                if (unbanList.Count > 0)
                {
                    MySQL_RawUnban("Auto Ban", unbanList);
                    unbanList.Clear();
                }
                var l2 = l.Where(x => (int)x["expire"] == 0).ToList();
                if (l2.Count == 0)
                {
                    string range1;
                    string range2;
                    string range3;
                    if (RangeFromIP(bandata.ip, out range1, out range2, out range3))
                    {
                        Sql.Query(Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `ip` = @0 OR `ip` = @1 OR `ip` = @2 OR `ip` = @3", bandata.ip, range1, range2, range3), Sql_conn, list2 =>
                        {
                            if (list2 != null)
                            {
                                foreach (var entry in list2)
                                {
                                    var expire = (int)entry["expire"];
                                    if (expire != 0 && cTime >= double.Parse(expire.ToString()))
                                    {
                                        unbanList.Add((int)entry["id"]);
                                    }
                                    else
                                    {
                                        if (!l.Contains(entry))
                                            l.Add(entry);
                                    }
                                }
                            }
                            if (l.Count > 0)
                            {
                                bandata.expire = l2.Count > 0 ? 0.0 : match.ContainsKey("expire") ? (int)(match["expire"]) : (int)(l[0]["expire"]);
                                if (match.ContainsKey("expire"))
                                {
                                    if (double.Parse(match["expire"].ToString()) != bandata.expire)
                                    {
                                        var bd = new BanData(int.Parse(match["id"].ToString()), (string)match["source"], (string)match["steamid"], (string)match["name"], (string)match["ip"], (string)match["reason"], match["expire"].ToString());
                                        MySQL_UpdateBan(bd);
                                    }
                                }
                                else if (update) ExecuteBan("Auto Ban", bandata, false);
                                timer.Once(0.1f, () => Kick(null, bandata.steamid, match.ContainsKey("reason") ? (string)match["reason"] : (string)l[0]["reason"]));
                            }
                        });
                    }
                }
                if (l.Count > 0)
                {
                    bandata.expire = l2.Count > 0 ? 0.0 : match.ContainsKey("expire") ? double.Parse(match["expire"].ToString()) : double.Parse(l[0]["expire"].ToString());
                    if (match.ContainsKey("expire"))
                    {
                        if (double.Parse(match["expire"].ToString()) != bandata.expire)
                        {
                            var bd = new BanData(int.Parse(match["id"].ToString()), (string)match["source"], (string)match["steamid"], (string)match["name"], (string)match["ip"], (string)match["reason"], match["expire"].ToString());
                            MySQL_UpdateBan(bd);
                        }
                    }
                    else if (update) ExecuteBan("Auto Ban", bandata, false);
                    timer.Once(0.1f, () => Kick(null, bandata.steamid, match.ContainsKey("reason") ? (string)match["reason"] : (string)l[0]["reason"], false));
                }
            });
        }

        string MySQL_Banlist(object source, int startid)
        {
            Sql.Query(Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem ORDER BY id DESC"), Sql_conn, list =>
            {
                int i = -1;
                int max = startid + 9;
                string replystring = string.Empty;
                if (list != null)
                {
                    replystring += FormatReturn(BanSystem.MySQL, GetMsg("Banlist"), startid.ToString(), max.ToString(), list.Count.ToString());
                    foreach (var entry in list)
                    {
                        i++;
                        if (i < startid) continue;
                        if (i > max) break;
                        var bd = new BanData(int.Parse(entry["id"].ToString()), (string)entry["source"], (string)entry["steamid"], (string)entry["name"], (string)entry["ip"], (string)entry["reason"], entry["expire"].ToString());
                        replystring += bd.ToString() + "\n";

                    }
                    SendReply(source, replystring);
                }
            });
            return string.Empty;
        }

        ////////////////////////////////////////////////////////////
        // Native
        ////////////////////////////////////////////////////////////

        string Native_Load()
        {
            return FormatReturn(BanSystem.Native, GetMsg("Loaded"));
        }
        string Native_ExecuteBan(BanData bandata)
        {
            if (bandata.steamid.Length == 0) return FormatReturn(BanSystem.Native, "Can't ban by IP.");

            var player = players.FindPlayer(bandata.steamid);
            if (player == null) return FormatReturn(BanSystem.Native, GetMsg("PlayerNotFound"));
            if (player.IsBanned) return FormatReturn(BanSystem.Native, GetMsg("BanExists"), bandata.steamid.ToString());

            TimeSpan duration = bandata.expire == 0.0 ? default(TimeSpan) : TimeSpan.FromSeconds(bandata.expire);
            player.Ban(bandata.reason, duration);
#if RUST
            if (bandata.expire != 0.0)
            {
              return FormatReturn(BanSystem.Native, GetMsg("BanAdded"), bandata.steamid.ToString()) + "\nWARNING: NATIVE temporary bans are not supported in RUST! Temporary bans will stay permanent";
            }
#endif
            return FormatReturn(BanSystem.Native, GetMsg("BanAdded"), bandata.steamid.ToString());
        }

        string Native_ExecuteUnban(string steamid, string name)
        {
            if (steamid == string.Empty)
            {
                if (name == string.Empty) return string.Empty;
                var f = players.FindPlayers(name).Where(x => x.IsBanned).ToList();
                if (f.Count == 0)
                {
                    return FormatReturn(BanSystem.Native, GetMsg("PlayerNotFound"));
                }
                if (f.Count > 1)
                {
                    var ret = string.Empty;
                    foreach (var p in f)
                    {
                        ret += string.Format("{0} - {1}\n", p.Id, p.Name);
                    }
                    return ret;
                }
                steamid = f[0].Id;
            }
            var b = players.FindPlayer(steamid);
            if (b == null)
            {
                return FormatReturn(BanSystem.Native, GetMsg("PlayerNotFound"));
            }
            if (!b.IsBanned)
            {
                return FormatReturn(BanSystem.Native, GetMsg("PlayerNotBanned"), b.Id, b.Name);
            }
            b.Unban();
            return FormatReturn(BanSystem.Native, "1 matching bans were removed");
        }

        bool Native_IsBanned(string steamid)
        {
            var b = players.FindPlayer(steamid);
            if (b != null)
            {
                return b.IsBanned;
            }
            return false;
        }

        string Native_Banlist(object source, int startid)
        {
            int i = -1;
            int max = startid + 9;

            var banlist = players.All.Where(x => x.IsBanned).ToList();

            string returnstring = FormatReturn(BanSystem.Native, GetMsg("Banlist"), startid.ToString(), max.ToString(), banlist.Count.ToString());

            foreach (IPlayer b in banlist)
            {
                i++;
                if (i < startid) continue;
                if (i > max) break;
                returnstring += string.Format("{0} - {1} - {2}", b.Id, b.Name, ToShortString(b.BanTimeRemaining));
            }

            return returnstring;
        }


        ////////////////////////////////////////////////////////////
        // Kick
        ////////////////////////////////////////////////////////////

        string Kick(object source, string target, string reason, bool shouldBroadcast = true)
        {
            string r = string.Empty;
            var foundplayers = FindConnectedPlayers(target, source, out r);
            if (r != string.Empty)
            {
                return r;
            }

            var returnkick = string.Empty;
            foreach (var iplayer in foundplayers)
            {
                returnkick += ExecuteKick(source, iplayer, reason, shouldBroadcast) + "\r\n";
            }

            return returnkick;
        }
        string TryKick(object source, string[] args)
        {
            string target = args[0];
            string reason = args.Length > 1 ? args[1] : "Kicked";
            return Kick(source, target, reason);
        }

        string ExecuteKick(object source, IPlayer player, string reason, bool shouldBroadcast = true)
        {
            if (shouldBroadcast && Kick_Broadcast)
            {
                server.Broadcast(GetMsg("<color=#F64A46>{0}</color>\n<color=#CDA4DE>ты кто такой, сука, чтоб это cделать!</color>\n<color=#FFCF48>{1}</color>", null, player.Name.ToString(), reason));
                if (Discord_use)
                {
                    object payload = new[]
                    {
                        new{name="Player", value=$"[{player.Name}](https://steamcommunity.com/profiles/{player.Id})", inline=true},
                        new{name="Kicked By", value=source is IPlayer ? ((IPlayer)source).Name : source.ToString(),inline=true },
                        new{name="Reason", value=reason, inline=false}
                    };
                    string json = JsonConvert.SerializeObject(payload);
                    DiscordMessages.Call("API_SendFancyMessage", Discord_Webhook, "Player Kick", json);
                }
            }

            if (Kick_Log)
                Interface.Oxide.LogWarning(GetMsg("<color=#F64A46>{0}</color>\n<color=#CDA4DE>ты кто такой, сука, чтоб это cделать!</color>\n<color=#FFCF48>({1})</color>", null, player.Name.ToString(), reason));

            player.Kick(reason);


            return GetMsg("<color=#F64A46>{0}</color>\n<color=#CDA4DE>ты кто такой, сука, чтоб это cделать!</color>\n<color=#FFCF48>({1})</color>", source, player.Name.ToString(), reason);
        }


        ////////////////////////////////////////////////////////////
        // IsBanned
        ////////////////////////////////////////////////////////////
        bool isBanned_Check(string name, string steamid, string ip)
        {
            int count = 0;
            if (BanSystemHasFlag(banSystem, BanSystem.Files))
            {
                count++;
                var files = cachedBans.Values.Where(x => x.steamid == steamid).ToList();
                if (files.Count > 0)
                {
                    return true;
                }
            }
            if (BanSystemHasFlag(banSystem, BanSystem.PlayerDatabase))
            {
                count++;
                var playerdatabase = PlayerDatabase.Call("GetPlayerDataRaw", steamid, "Banned");
                if (playerdatabase is string && playerdatabase != null)
                {
                    return true;
                }
            }
            if (BanSystemHasFlag(banSystem, BanSystem.MySQL))
            {
                count++;
                bool foundMySQL = false;
                Sql.Query(Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `steamid` = @0", steamid), Sql_conn, list =>
                {
                    if (list != null)
                    {
                        foundMySQL = true;
                    }
                });
                if (foundMySQL)
                {
                    return true;
                }
            }
            if (BanSystemHasFlag(banSystem, BanSystem.SQLite))
            {
                count++;
                bool sqlite = false;
                Sqlite.Query(Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `steamid` == @0", steamid), Sqlite_conn, list =>
                {
                    if (list != null)
                    {
                        sqlite = true;
                    }
                });
                if (sqlite)
                {
                    return true;
                }
            }
            if (BanSystemHasFlag(banSystem, BanSystem.WebAPI))
            {
                count++;
                bool banned = false;
                webrequest.Enqueue(FormatOnlineBansystem(WebAPI_IsBanned_Request, new Dictionary<string, string> { { "{id}", null }, { "{steamid}", steamid }, { "{name}", name }, { "{ip}", ip }, { "{source}", "Auto Ban" }, { "{update}", false.ToString() }, { "{time}", LogTime().ToString() } }), null, (code, response) =>
                {
                    if (response != null || code != 200)
                    {
                        if (response == "true")
                        {
                            banned = true;
                        }
                    }
                    else
                    {
                        Interface.Oxide.LogWarning("WebAPI couldn't be contacted or is not valid");
                    }
                }, this);
                if (banned == true)
                {
                    return banned;
                }
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Native) && count > 0)
            {
                return false;
            }
            else if (BanSystemHasFlag(banSystem, BanSystem.Native) && count == 0)
            {
                var player = players.FindPlayer(steamid);
                return player != null && player.IsBanned;
            }
            return false;
        }
        bool isBanned_NonDelayed(string name, string steamid, string ip, bool update, out BanData bandata)
        {
            bool denied = false;
            bandata = null;
            if (!denied && BanSystemHasFlag(banSystem, BanSystem.Native))
            {
                if (Native_IsBanned(steamid))
                {
                    if (Log_Denied)
                        Interface.Oxide.LogInfo(string.Format("Native: {0} - {1} - {2} was rejected from the server", steamid, name, ip));
                    denied = true;
                }
            }
            if (!denied && BanSystemHasFlag(banSystem, BanSystem.PlayerDatabase))
            {
                if (PlayerDatabase_IsBanned(steamid, ip, out bandata))
                {
                    if (Log_Denied)
                        Interface.Oxide.LogInfo(string.Format("PlayerDatabase: {0} - {1} - {2} was rejected from the server", steamid, name, ip));
                    denied = true;
                }
            }
            if (!denied && BanSystemHasFlag(banSystem, BanSystem.Files))
            {
                if (Files_IsBanned(steamid, ip, out bandata))
                {
                    if (Log_Denied)
                        Interface.Oxide.LogInfo(string.Format("Files: {0} - {1} - {2} was rejected from the server", steamid, name, ip));
                    denied = true;
                }
            }
            if (update && denied)
            {
                if (bandata != null && (bandata.ip != ip || bandata.steamid != steamid))
                    PrepareBan("Auto Ban", steamid, name, ip, BanEvadeReason, bandata.expire == 0.0 ? 0.0 : bandata.expire - LogTime(), false);
                else if (bandata == null)
                    PrepareBan("Auto Ban", steamid, name, ip, BanEvadeReason, 0.0, false);
            }
            return bandata != null;
        }

        void isBanned_Delayed(string name, string steamid, string ip, bool update)
        {
            var partialBan = new BanData("Auto Ban", steamid, name, ip, string.Empty, 0.0);
            if (BanSystemHasFlag(banSystem, BanSystem.SQLite))
            {
                SQLite_IsBanned(partialBan, update);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.MySQL))
            {
                MySQL_IsBanned(partialBan, update);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.WebAPI))
            {
                WebAPI_IsBanned(partialBan, update);
            }
        }

        ////////////////////////////////////////////////////////////
        // Banlist
        ////////////////////////////////////////////////////////////

        string TryBanlist(object source, string[] args)
        {
            int startID = 0;
            BanSystem bs;
            if (args != null && args.Length > 1)
            {
                int.TryParse(args[1], out startID);
            }
            switch (args[0].ToLower())
            {
                case "files":
                    bs = BanSystem.Files;
                    break;
                case "mysql":
                    bs = BanSystem.MySQL;
                    break;
                case "native":
                    bs = BanSystem.Native;
                    break;
                case "playerdatabase":
                    bs = BanSystem.PlayerDatabase;
                    break;
                case "sqlite":
                    bs = BanSystem.SQLite;
                    break;
                case "webapi":
                    bs = BanSystem.WebAPI;
                    break;
                default:
                    return GetMsg("BanlistSyntax1", source);
            }

            return Banlist(source, bs, startID);
        }

        string Banlist(object source, BanSystem bs, int startID)
        {
            switch (bs)
            {
                case BanSystem.Files:
                    return Files_Banlist(source, startID);
                case BanSystem.MySQL:
                    return MySQL_Banlist(source, startID);
                case BanSystem.Native:
                    return Native_Banlist(source, startID);
                case BanSystem.PlayerDatabase:
                    return PlayerDatabase_Banlist(source, startID);
                case BanSystem.SQLite:
                    return SQLite_Banlist(source, startID);
                case BanSystem.WebAPI:
                    return WebAPI_Banlist(source, startID);
                default:
                    return string.Empty;
            }
        }

        ////////////////////////////////////////////////////////////
        // Ban
        ////////////////////////////////////////////////////////////


        string TryBan(object source, string[] args)
        {
            string ipaddress = isIPAddress(args[0]) ? args[0] : string.Empty;
            string steamid = string.Empty;
            string name = string.Empty;
            string errorreason = string.Empty;
            ulong userID;
            double duration = 0.0;
            string reason = BanDefaultReason;
            TimeSpan duration1;
            if (args.Length > 2 && TryParseTimeSpan(args[1], out duration1))
            {
                duration = duration1.TotalSeconds;
                reason = string.Join(" ", args.Skip(2).ToArray());
            }
            else if (args.Length > 1)
            {
                reason = string.Join(" ", args.Skip(1).ToArray());
            }
            if (ipaddress.Length != 0)
            {
                return BanIP(source, ipaddress, reason, duration);
            }
            else
            {
                var foundplayers = FindPlayers(args[0], source, out errorreason);
                if (errorreason != string.Empty | errorreason.Length != 0)
                {
                    if (ulong.TryParse(args[0], out userID) && userID.IsSteamId())
                    {
                        return BanID(source, args[0], reason, duration);
                    }
                    return errorreason;
                }
                return BanPlayer(source, foundplayers[0], reason, duration);
            }
        }

        string BanIP(object source, string ip, string reason, double duration)
        {
            return PrepareBan(source, string.Empty, string.Empty, ip, reason, duration, Kick_OnBan);
        }

        string BanID(object source, string steamid, string reason, double duration)
        {
            string name = GetPlayerName(steamid);
            string ipaddress = GetPlayerIP(steamid);

            return PrepareBan(source, steamid, name, ipaddress, reason, duration, Kick_OnBan);
        }

        string BanPlayer(object source, IPlayer player, string reason, double duration)
        {
            var address = GetPlayerIP(player);

            return PrepareBan(source, player.Id, player.Name, address, reason, duration, Kick_OnBan);
        }

        string PrepareBan(object source, string userID, string name, string ip, string reason, double duration, bool kick)
        {
            var bandata = new BanData(source, userID, name, ip, reason, duration);


            return ExecuteBan(source, bandata, kick);
        }
        string ExecuteBan(object source, BanData bandata, bool kick)
        {
            Unsubscribe(nameof(OnUserBanned));
            if (wasBanned.Contains(bandata.id)) return string.Empty;

            string returnstring = null;
            if (BanSystemHasFlag(banSystem, BanSystem.PlayerDatabase))
            {
                returnstring += PlayerDatabase_ExecuteBan(bandata);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Files))
            {
                returnstring += Files_ExecuteBan(bandata);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.MySQL))
            {
                returnstring += MySQL_ExecuteBan(source, bandata);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.SQLite))
            {
                returnstring += SQLite_ExecuteBan(source, bandata);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.WebAPI))
            {
                returnstring += WebAPI_ExecuteBan(source, bandata);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Native))
            {
                returnstring += Native_ExecuteBan(bandata);
            }

            if (Ban_Broadcast)
                if (bandata.name != string.Empty | bandata.steamid != string.Empty)
                    server.Broadcast(bandata.expire == 0.0 ? GetMsg("PlayerPermBan", null, bandata.name, bandata.reason) : GetMsg("PlayerTempBan", null, bandata.name, FormatTime(TimeSpan.FromSeconds(bandata.expire - LogTime())), bandata.reason));
                else if (bandata.ip != string.Empty)
                    server.Broadcast(bandata.expire == 0.0 ? GetMsg("IPPermBan", null, bandata.reason) : GetMsg("IPTempBan", null, FormatTime(TimeSpan.FromSeconds(bandata.expire - LogTime())), bandata.reason));

            if (Ban_Log && (source is IPlayer) && ((IPlayer)source).Id != "server_console")
                Interface.Oxide.LogWarning(returnstring);

            if (kick)
                Kick(source, bandata.steamid != string.Empty ? bandata.steamid : bandata.ip, "Banned", true);

            wasBanned.Add(bandata.id);
            if (Discord_use)
            {
                object payload = new[]
                {
                    new {name="Player",value=bandata.name.Length != 0 ? $"[{bandata.name}](https://steamcommunity.com/profiles/{bandata.steamid})" : bandata.steamid.Length != 0 ? $"[{bandata.steamid}](https://steamcommunity.com/profiles/{bandata.steamid})" : "An IP", inline=true},
                    new {name="Type",value=bandata.expire != 0.0 ? $"Temporarily ({FormatTime(TimeSpan.FromSeconds(bandata.expire - LogTime()))})" : "Permanently", inline=true},
                    new {name="Banned By", value=bandata.source, inline=true },
                    new {name="Reason",value=bandata.reason, inline=false}
                };
                string json = JsonConvert.SerializeObject(payload);
                DiscordMessages?.Call("API_SendFancyMessage", Discord_Webhook, "Player Ban", json);
            }
            timer.Once(5f, () => { Subscribe(nameof(OnUserBanned)); });
            return returnstring;
        }

        ////////////////////////////////////////////////////////////
        // Unban
        ////////////////////////////////////////////////////////////

        string ExecuteUnban(object source, string steamid, string name, string ip)
        {
            string returnstring = string.Empty;
            List<BanData> unbanList = new List<BanData>();
            List<BanData> unbanList2 = new List<BanData>();

            if (BanSystemHasFlag(banSystem, BanSystem.PlayerDatabase))
            {
                returnstring += PlayerDatabase_ExecuteUnban(steamid, name, ip, out unbanList);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Files))
            {
                returnstring += Files_ExecuteUnban(steamid, name, ip, out unbanList2);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.MySQL))
            {
                returnstring += MySQL_ExecuteUnban(source, steamid, name, ip);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.SQLite))
            {
                returnstring += SQLite_ExecuteUnban(source, steamid, name, ip);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.WebAPI))
            {
                returnstring += WebAPI_ExecuteUnban(source, steamid, name, ip);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Native))
            {
                returnstring += Native_ExecuteUnban(steamid, name);
            }

            foreach (var b in unbanList)
            {
                if (cachedBans.ContainsKey(b.id))
                    cachedBans.Remove(b.id);
            }
            foreach (var b in unbanList2)
            {
                if (cachedBans.ContainsKey(b.id))
                    cachedBans.Remove(b.id);
            }
            OnServerSave();
            return returnstring;
        }

        string TryUnBan(object source, string[] args)
        {
            string ipaddress = isIPAddress(args[0]) ? args[0] : string.Empty;
            string steamid = string.Empty;
            ulong userID = 0L;
            string name = string.Empty;
            string errorreason = string.Empty;

            if (ipaddress != string.Empty)
            {
                return ExecuteUnban(source, string.Empty, string.Empty, ipaddress);
            }
            else
            {
                ulong.TryParse(args[0], out userID);
                return ExecuteUnban(source, userID != 0L ? args[0] : string.Empty, userID == 0L ? args[0] : string.Empty, string.Empty);
            }
        }


        ////////////////////////////////////////////////////////////
        // Commands
        ////////////////////////////////////////////////////////////
        [Command("ban", "player.ban")]
        void cmdBan(IPlayer player, string command, string[] args)
        {
            if (!hasPermission(player, PermissionBan))
            {
                player.Reply(GetMsg("NoPermission", player.Id.ToString()));
                return;
            }
            if (args == null || (args.Length < 1))
            {
                player.Reply(GetMsg("BanSyntax", player.Id.ToString()));
                return;
            }
            try
            {
                player.Reply(TryBan(player, args));
            }
            catch (Exception e)
            {
                player.Reply("ERROR:" + e.Message);
                Puts(e.StackTrace);
            }
        }

        [Command("banlist", "player.banlist")]
        void cmdBanlist(IPlayer player, string command, string[] args)
        {
            if (!hasPermission(player, PermissionBanlist))
            {
                player.Reply(GetMsg("NoPermission", player.Id.ToString()));
                return;
            }
            if (args == null || args.Length == 0)
            {
                string replystring = GetMsg("BanlistSyntax", player.Id.ToString()) + "\n";
                replystring += GetMsg("BanSystems", player.Id.ToString());
                if (BanSystemHasFlag(banSystem, BanSystem.Files))
                {
                    replystring += "Files\n";
                }
                if (BanSystemHasFlag(banSystem, BanSystem.MySQL))
                {
                    replystring += "MySQL\n";
                }
                if (BanSystemHasFlag(banSystem, BanSystem.Native))
                {
                    replystring += "Native\n";
                }
                if (BanSystemHasFlag(banSystem, BanSystem.PlayerDatabase))
                {
                    replystring += "PlayerDatabase\n";
                }
                if (BanSystemHasFlag(banSystem, BanSystem.SQLite))
                {
                    replystring += "SQLite\n";
                }
                if (BanSystemHasFlag(banSystem, BanSystem.WebAPI))
                {
                    replystring += "WebAPI\n";
                }
                player.Reply(replystring);
                return;
            }
            try
            {
                player.Reply(TryBanlist(player, args));
            }
            catch (Exception e)
            {
                player.Reply("ERROR:" + e.Message);
            }
        }

        [Command("kick", "player.kick")]
        void cmdKick(IPlayer player, string command, string[] args)
        {
            if (!hasPermission(player, PermissionKick))
            {
                player.Reply(GetMsg("NoPermission", player.Id.ToString()));
                return;
            }
            if (args == null || (args.Length < 1))
            {
                player.Reply(GetMsg("KickSyntax", player.Id.ToString()));
                return;
            }
            try
            {
                player.Reply(TryKick(player, args));
            }
            catch (Exception e)
            {
                player.Reply("ERROR:" + e.Message);
            }
        }

        [Command("unban", "player.unban")]
        void cmdUnban(IPlayer player, string command, string[] args)
        {
            if (!hasPermission(player, PermissionUnban))
            {
                player.Reply(GetMsg("NoPermission", player.Id.ToString()));
                return;
            }
            if (args == null || (args.Length < 1))
            {
                player.Reply(GetMsg("UnbanSyntax", player.Id.ToString()));
                return;
            }
            try
            {
                player.Reply(TryUnBan(player, args));
            }
            catch (Exception e)
            {
                player.Reply("ERROR:" + e.Message);
            }
        }
    }
}

// --- End of file: EnhancedBanSystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/EasyAdmin.cs ---
// --- Original Local Path: KualaRust/EasyAdmin.cs ---

using System.Collections.Generic;
using Oxide.Game.Rust.Libraries;
using Oxide.Core;
using System;
using Rust;
using Newtonsoft.Json;
using Oxide.Core.Libraries;

namespace Oxide.Plugins
{
    [Info("EasyAdmin", "Fartus", "1.0.1")]
    [Description("Игроки могут включать и выключать режим администратора")]
    class EasyAdmin : RustPlugin
    {
        #region Vars
        private PluginConfig config;
        #endregion

        #region Config
        private class GrandRevokeList
        {
            [JsonProperty("Список групп, которые нужно выдать")]
            public List<string> GrantGroup;
            [JsonProperty("Список групп, которые нужно забрать")]
            public List<string> RevokeGroup;
            [JsonProperty("Список привилегий, которые нужно выдать")]
            public List<string> GrantPerms;
            [JsonProperty("Список привилегий, которые нужно забрать")]
            public List<string> RevokePerms;
        }
        private class PluginConfig
        {
            [JsonProperty("Формат сообщений в чате")]
            public string ChatFormat;
            [JsonProperty("Команда переключения режима администратора")]
            public string ChatCommand;
            [JsonProperty("Привилегия, требующаяся для активации команды")]
            public string Permission;
            [JsonProperty("Действия при ВКЛЮЧЕНИИ режима администратора")]
            public GrandRevokeList Enable;
            [JsonProperty("Действия при ВЫКЛЮЧЕНИИ режима администратора")]
            public GrandRevokeList Disable;
            [JsonProperty("Добавлять и удалять игрока при смене режима администратора в users.cfg")]
            public bool SaveToConfig;
            [JsonProperty("Логировать использование команды")]
            public bool Log;
            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    ChatFormat = "<color=#42eef4>[EasyAdmin]</color> <color=#AAAAAA>{0}</color>",
                    ChatCommand = "/admin",
                    Permission = "easyadmin.use",
                    SaveToConfig = true,
                    Log = true,
                    Enable = new GrandRevokeList()
                    {
                        GrantGroup = new List<string>()
                        {
                            "admin"
                        },
                        RevokeGroup = new List<string>()
                        {
                            "default"
                        },
                        GrantPerms = new List<string>()
                        {
                            "vanish.allowed",
                            "removeaaa.*",
                            "betterchat.mute"
                        },
                        RevokePerms = new List<string>()
                        {
                            "buildinglimit.limit"
                        }
                    },
                    Disable = new GrandRevokeList()
                    {
                        GrantGroup = new List<string>()
                        {
                            "default"
                        },
                        RevokeGroup = new List<string>()
                        {
                            "admin"
                        },
                        GrantPerms = new List<string>()
                        {
                            "buildinglimit.limit"
                        },
                        RevokePerms = new List<string>()
                        {
                            "vanish.allowed",
                            "removeaaa.*",
                            "betterchat.mute"
                        }
                    }
                };
            }
        }
        #endregion

        #region Config loading
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Создание нового файла конфигурации...");
            Config.WriteObject(PluginConfig.DefaultConfig(), true);
        }
        private void InitConfig()
        {
            try
            {
                config = Config.ReadObject<PluginConfig>();
            }
            catch (Exception ex)
            {
                RaiseError($"Failed to load config file (is the config file corrupt?) ({ex.Message})");
            }
        }
        #endregion

        #region Data
        private Dictionary<string, bool> ActiveAdmins = new Dictionary<string, bool>();
        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Title, ActiveAdmins);
        }
        void LoadData()
        {
            try
            {
                ActiveAdmins = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, bool>>(Title);
            }
            catch (Exception ex)
            {
                PrintError($"Failed to load active admins data file (is the file corrupt?) ({ex.Message})");
                ActiveAdmins = new Dictionary<string, bool>();
            }
        }
        #endregion

        #region Initialization and quiting
        void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["No Permission"] = "You don't have permission to use this command.",
                ["Admin On"] = "Admin mode turned <color=green>ON</color>",
                ["Admin Off"] = "Admin mode turned <color=red>OFF</color>",
                ["Fly"] = "Can not disable admin mode while flying"
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["No Permission"] = "Недостаточно прав на выполнение данной команды.",
                ["Admin On"] = "Режим Администратора <color=green>ВКЛЮЧЕН</color>",
                ["Admin Off"] = "Режим Администратора <color=red>ВЫКЛЮЧЕН</color>",
                ["Fly"] = "Невозможно отключить режим администратора в полёте"
            }, this, "ru");
        }
        void Loaded()
        {
            InitConfig();
            LoadData();
            LoadMessages();
            permission.RegisterPermission(config.Permission, this);
            var command = Interface.Oxide.GetLibrary<Command>();
            command.AddChatCommand(config.ChatCommand.Replace("/", string.Empty), this, AdminCC);
        }
        void Unload()
        {
            OnServerSave();
        }
        void OnServerSave()
        {
            SaveData();
        }
        #endregion

        #region Commands
        void AdminCC(BasePlayer player, string command, string[] args)
        {
            if (!HasPerm(player))
            {
                Reply(player, "No Permission");
                if (ActiveAdmins.ContainsKey(player.UserIDString))
                {
                    ActiveAdmins.Remove(player.UserIDString);
                    SaveData();
                }
                return;
            }

            if (!ActiveAdmins.ContainsKey(player.UserIDString))
            {
                ActiveAdmins[player.UserIDString] = false;
            }
            ActiveAdmins[player.UserIDString] = !ActiveAdmins[player.UserIDString];
            SaveData();

            if (ActiveAdmins[player.UserIDString])
            {
                Reply(player, "Admin On");
                AdminOn(player);
                return;

            }
            else
            {
                if (player.IsFlying)
                {
                    Reply(player, "Fly");
                    ActiveAdmins[player.UserIDString] = true;
                    return;
                }
                Reply(player, "Admin Off");
                AdminOff(player);
                return;
            }
        }
        #endregion

        #region Admin mode switching
        private void AdminOn(BasePlayer player)
        {
            if (config.Log)
                Puts($"Player \"{player.displayName}\" has turn ON admin mode");
            player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
            player.net.connection.authLevel = 2;
            if (config.SaveToConfig)
            {
                Server.Command($"ownerid {player.UserIDString} \"{player.displayName}\" {Title}");
                Server.Command("writecfg");
            }
            foreach(var group in config.Enable.GrantGroup)
            {
                if (!permission.GroupExists(group))
                {
                    PrintWarning($"Group \"{group}\" doesn't exist and wasn't added to player \"{player.displayName}\"");
                    continue;
                }
                permission.AddUserGroup(player.UserIDString, group);
            }
            foreach(var group in config.Enable.RevokeGroup)
            {
                if (!permission.GroupExists(group))
                {
                    PrintWarning($"Group \"{group}\" doesn't exist and wasn't removed from player \"{player.displayName}\"");
                    continue;
                }
                permission.RemoveUserGroup(player.UserIDString, group);
            }
            foreach(var perm in config.Enable.GrantPerms)
            {
                if (!permission.PermissionExists(perm))
                {
                    PrintWarning($"Permission \"{perm}\" doesn't exist and wasn't added to player \"{player.displayName}\"");
                    continue;
                }
                permission.GrantUserPermission(player.UserIDString, perm, null);
            }
            foreach(var perm in config.Enable.RevokePerms)
            {
                if (!permission.PermissionExists(perm))
                {
                    PrintWarning($"Permission \"{perm}\" doesn't exist and wasn't removed from player \"{player.displayName}\"");
                    continue;
                }
                permission.RevokeUserPermission(player.UserIDString, perm);
            }
        }
        private void AdminOff(BasePlayer player)
        {
            if (config.Log)
                Puts($"Player \"{player.displayName}\" has turn OFF admin mode");
            player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
            player.net.connection.authLevel = 0;
            if (config.SaveToConfig)
            {
                Server.Command($"removeowner {player.UserIDString}");
                Server.Command("writecfg");
            }
            foreach (var group in config.Disable.GrantGroup)
            {
                if (!permission.GroupExists(group))
                {
                    PrintWarning($"Group \"{group}\" doesn't exist and wasn't added to player \"{player.displayName}\"");
                    continue;
                }
                permission.AddUserGroup(player.UserIDString, group);
            }
            foreach (var group in config.Disable.RevokeGroup)
            {
                if (!permission.GroupExists(group))
                {
                    PrintWarning($"Group \"{group}\" doesn't exist and wasn't removed from player \"{player.displayName}\"");
                    continue;
                }
                permission.RemoveUserGroup(player.UserIDString, group);
            }
            foreach (var perm in config.Disable.GrantPerms)
            {
                if (!permission.PermissionExists(perm))
                {
                    PrintWarning($"Permission \"{perm}\" doesn't exist and wasn't added to player \"{player.displayName}\"");
                    continue;
                }
                permission.GrantUserPermission(player.UserIDString, perm, null);
            }
            foreach (var perm in config.Disable.RevokePerms)
            {
                if (!permission.PermissionExists(perm))
                {
                    PrintWarning($"Permission \"{perm}\" doesn't exist and wasn't removed from player \"{player.displayName}\"");
                    continue;
                }
                permission.RevokeUserPermission(player.UserIDString, perm);
            }
        }
        #endregion

        #region Oxide Hooks
        void OnPlayerSleepEnded(BasePlayer player)
        {
            if (!ActiveAdmins.ContainsKey(player.UserIDString)) return;
            if (ActiveAdmins[player.UserIDString])
            {
                if (player.net.connection.authLevel != 2)
                {
                    AdminOn(player);
                }
            }
            else
            {
                if (player.net.connection.authLevel == 2)
                {
                    AdminOff(player);
                }
            }
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if(!permission.UserHasPermission(player.UserIDString,config.Permission))
                AdminOff(player);
        }

        #endregion

        #region Helpers        
        private void Reply(BasePlayer player, string LangKey, params object[] args)
        {
            SendReply(player, string.Format(config.ChatFormat, GetMsg(LangKey, player)), args);
        }
        private string GetMsg(string key, BasePlayer player = null) => lang.GetMessage(key, this, player == null ? null : player.UserIDString);
        private bool HasPerm(BasePlayer player) => permission.UserHasPermission(player.UserIDString, config.Permission);
        #endregion
    }
}

// --- End of file: EasyAdmin.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/Metabolism.cs ---
// --- Original Local Path: KualaRust/Metabolism.cs ---

﻿using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Metabolism", "Wulf/lukespragg", "2.6.1", ResourceId = 680)]
    [Description("Modify or disable player metabolism stats and rates")]
    public class Metabolism : RustPlugin
    {
        #region Configuration

        private Configuration config;

        public class Configuration
        {
            [JsonProperty(PropertyName = "Calories loss rate (0.0 - infinite)")]
            public float CaloriesLossRate;

            [JsonProperty(PropertyName = "Calories spawn amount (0.0 - 500.0)")]
            public float CaloriesSpawnAmount;

            [JsonProperty(PropertyName = "Health gain rate (0.0 - infinite)")]
            public float HealthGainRate;

            [JsonProperty(PropertyName = "Health spawn amount (0.0 - 100.0)")]
            public float HealthSpawnAmount;

            [JsonProperty(PropertyName = "Hydration loss rate (0.0 - infinite)")]
            public float HydrationLossRate;

            [JsonProperty(PropertyName = "Hydration spawn amount (0.0 - 250.0)")]
            public float HydrationSpawnAmount;

            public static Configuration DefaultConfig()
            {
                return new Configuration
                {
                    CaloriesLossRate = 0.03f,
                    CaloriesSpawnAmount = 500f,
                    HealthGainRate = 0.03f,
                    HealthSpawnAmount = 100f,
                    HydrationLossRate = 0.03f,
                    HydrationSpawnAmount = 250f
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config?.HealthGainRate == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Could not read oxide/config/{Name}.json, creating new config file");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig() => config = Configuration.DefaultConfig();

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion Configuration

        #region Initialization

        private const string permBoost = "metabolism.boost";
        private const string permNone = "metabolism.none";
        private const string permSpawn = "metabolism.spawn";

        private void Init()
        {
            permission.RegisterPermission(permBoost, this);
            permission.RegisterPermission(permNone, this);
            permission.RegisterPermission(permSpawn, this);
        }

        #endregion Initialization

        #region Modify Metabolism

        private void OnPlayerRespawned(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, permSpawn))
            {
#if DEBUG
                PrintWarning($"Health before: {player.health}");
                PrintWarning($"Calories before: {player.metabolism.calories.value}");
                PrintWarning($"Hydration before: {player.metabolism.hydration.value}");
#endif
                player.health = config.HealthSpawnAmount;
                player.metabolism.calories.value = config.CaloriesSpawnAmount;
                player.metabolism.hydration.value = config.HydrationSpawnAmount;
#if DEBUG
                PrintWarning($"Health after: {player.health}");
                PrintWarning($"Calories after: {player.metabolism.calories.value}");
                PrintWarning($"Hydration after: {player.metabolism.hydration.value}");
#endif
            }
        }

        private void OnRunPlayerMetabolism(PlayerMetabolism m, BaseCombatEntity entity)
        {
            var player = entity.ToPlayer();
            if (player == null) return;
#if DEBUG
            PrintWarning($"Health before: {player.health}");
            PrintWarning($"Calories before: {player.metabolism.calories.value}");
            PrintWarning($"Hydration before: {player.metabolism.hydration.value}");
#endif
            if (permission.UserHasPermission(player.UserIDString, permBoost))
            {
                player.health = Mathf.Clamp(player.health + config.HealthGainRate, 0f, 100f);
                m.calories.value = Mathf.Clamp(m.calories.value - config.CaloriesLossRate, m.calories.min, m.calories.max);
                m.hydration.value = Mathf.Clamp(m.hydration.value - config.HydrationLossRate, m.hydration.min, m.hydration.max);
            }
            else if (permission.UserHasPermission(player.UserIDString, permNone))
            {
                m.calories.value = m.calories.max;
                m.hydration.value = m.hydration.max;
            }
#if DEBUG
            PrintWarning($"Health after: {player.health}");
            PrintWarning($"Calories after: {player.metabolism.calories.value}");
            PrintWarning($"Hydration after: {player.metabolism.hydration.value}");
#endif
        }

        #endregion Modify Metabolism
    }
}


// --- End of file: Metabolism.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/IQEconomic.cs ---
// --- Original Local Path: KualaRust/IQEconomic.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using ConVar;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("IQEconomic", "Mercury", "0.1.1")]
    [Description("Экономика на ваш сервер")]
    class IQEconomic : RustPlugin
    {
        #region Reference
        [PluginReference] Plugin IQChat, Friends, Clans, Battles, Duel, RustStore, ImageLibrary;
        public void SendChat(string Message, BasePlayer player, Chat.ChatChannel channel = Chat.ChatChannel.Global)
        {
            var Chat = config.ReferenceSettings.ChatSettings;
            if (IQChat)
                if (Chat.UIAlertUse)
                    IQChat?.Call("API_ALERT_PLAYER_UI", player, Message);                    
                else IQChat?.Call("API_ALERT_PLAYER", player, Message, Chat.CustomPrefix, Chat.CustomAvatar);
            else player.SendConsoleCommand("chat.add", channel, 0, Message);
        }
        private string GetImage(string fileName, ulong skin = 0)
        {
            var imageId = (string)plugins.Find("ImageLibrary").CallHook("GetImage", fileName, skin);
            if (!string.IsNullOrEmpty(imageId))
                return imageId;
            return string.Empty;
        }
        public bool AddImage(string url, string shortname, ulong skin = 0) => (bool)ImageLibrary?.Call("AddImage", url, shortname, skin);

        public void AddAllImage()
        {
            var Images = config.TransferSettings;
            if (string.IsNullOrEmpty(Images.URLMoney) || string.IsNullOrEmpty(Images.URLStores)) return;
            if (!ImageLibrary)
            {
                PrintError("Не установлен плагин ImageLibrary!");
                return;
            }

            AddImage(Images.URLMoney, "URLMoney");
            AddImage(Images.URLStores, "URLStores");
        }

        public bool IsFriends(ulong userID, ulong targetID)
        {
            if (Friends)
                return (bool)Friends?.Call("HasFriend", userID, targetID);
            else return false;
        }
        public bool IsClans(ulong userID, ulong targetID)
        {
            if (Clans)
                return (bool)Clans?.Call("HasFriend", userID, targetID);
            else return false;
        }
        public bool IsDuel(ulong userID)
        {
            if (Battles)
                return (bool)Battles?.Call("IsPlayerOnBattle", userID);
            else if (Duel) return (bool)Duel?.Call("IsPlayerOnActiveDuel", BasePlayer.FindByID(userID));
            else return false;
        }
        public void MoscovOVHBalanceSet(ulong userID, int Balance, int MoneyTake)
        {
            if (!RustStore)
            {
                PrintWarning("У вас не установлен магазин MoscovOVH");
                return;
            }
            plugins.Find("RustStore").CallHook("APIChangeUserBalance", userID, Balance, new Action<string>((result) =>
            {
                BasePlayer player = BasePlayer.FindByID(userID);
                if (result == "SUCCESS")
                {
                    Puts($"Пользователю {userID} успешно зачислен баланс - {Balance}");
                    RemoveBalance(userID, MoneyTake);
                    if (player == null) return;
                    SendChat(lang.GetMessage("CHAT_STORE_SUCCESS", this, player.UserIDString), player);
                    return;
                }
                Puts($"Пользователь {userID} не авторизован в магазине");
                if (player == null) return;
                SendChat(lang.GetMessage("CHAT_NO_AUTH_STORE", this, player.UserIDString), player);
            }));
        }
        public void GameStoresBalanceSet(ulong userID, int Balance,int MoneyTake)
        {
            var GameStores = config.ReferenceSettings.GameStoresSettings;
            if (String.IsNullOrEmpty(GameStores.GameStoresAPIStore) || String.IsNullOrEmpty(GameStores.GameStoresIDStore))
            {
                PrintWarning("Магазин GameStores не настроен! Невозможно выдать баланс пользователю");
                return;
            }
            webrequest.Enqueue($"https://gamestores.ru/api?shop_id={GameStores.GameStoresIDStore}&secret={GameStores.GameStoresAPIStore}&action=moneys&type=plus&steam_id={userID}&amount={Balance}&mess={GameStores.GameStoresMessage}", null, (i, s) =>
            {
                BasePlayer player = BasePlayer.FindByID(userID);
                if (i != 200) { }
                if (s.Contains("success"))
                {
                    Puts($"Пользователю {userID} успешно зачислен баланс - {Balance}");
                    RemoveBalance(userID, MoneyTake);
                    if (player == null) return;
                    SendChat(lang.GetMessage("CHAT_STORE_SUCCESS", this, player.UserIDString), player);
                    return;
                }
                if (s.Contains("fail"))
                {
                    Puts($"Пользователь {userID} не авторизован в магазине");
                    if (player == null) return;
                    SendChat(lang.GetMessage("CHAT_NO_AUTH_STORE", this, player.UserIDString),player);
                }
            }, this);
        }
        #endregion

        #region Configuration
        private static Configuration config = new Configuration();
        private class Configuration
        {
            [JsonProperty("Монетки будут и гроков на руках - false / Иначе будет чат или интерфейсе - true")]
            public bool UseUI;
            [JsonProperty("Использовать UI интерфейс для отображения баланса(true - да(Если вы не поставили , чтобы монетки были на руках))/false - информация будет в чате по команде и при входе)")]
            public bool UseUIMoney;
            [JsonProperty("Включить обмен валюты на баланс в магазине(GameStores/MoscovOVH)")]
            public bool TransferStoreUse;
            [JsonProperty("Отображение интерфейса с балансом(true - отображает/false - скрывает)")]
            public bool ShowUI;
            [JsonProperty("Настройки обмена валют на баланс в магазине")]
            public TransferSetting TransferSettings = new TransferSetting();
            [JsonProperty("Основные настройки")]
            public GeneralSettings GeneralSetting = new GeneralSettings();
            [JsonProperty("Настройки валюты(Если вид экономикик - false)")]
            public CustomMoney CustomMoneySetting = new CustomMoney();
            [JsonProperty("Настройки совместной работы с другими плагинами")]
            public ReferenceSetting ReferenceSettings = new ReferenceSetting();
            internal class CustomMoney
            {
                [JsonProperty("Название валюты")]
                public string DisplayName;
                [JsonProperty("Shortname монетки")]
                public string Shortname;
                [JsonProperty("SkinID монетки")]
                public ulong SkinID;
            }
                
            internal class GeneralSettings
            {
                [JsonProperty("Получение валюты за убийство игроков")]
                public bool BPlayerKillUse;
                [JsonProperty("Получение валюты за убийство животных")]
                public bool BPlayerAnimalUse;
                [JsonProperty("Получение валюты за убийство NPC")]
                public bool BPlayerNPCUse;
                [JsonProperty("Получение валюты за добычу ресурсов")]
                public bool BPlayerGatherUse;
                [JsonProperty("Получение валюты за уничтожение танка")]
                public bool BPlayerBradleyUse;
                [JsonProperty("Получение валюты за уничтожение вертолета")]
                public bool BPlayerHelicopterUse;
                [JsonProperty("Получение валюты за уничтожение бочек")]
                public bool BPLayerBarrelUse;
                [JsonProperty("Получение валюты проведенное время на сервере")]
                public bool BPLayerOnlineUse;
                [JsonProperty("Сколько нужно провести времени,чтобы выдали награду")]
                public int BPlayerOnlineTime;
                [JsonProperty("Сколько начислять валюты за проведенное время на сервере")]
                public int BPlayerOnlineGive;
                [JsonProperty("Настройка зачисления баланса за убийство игроков")]
                public AdvancedSetting BPlayerKillGive = new AdvancedSetting();
                [JsonProperty("Сколько начислять валюты за убийство животных")]
                public AdvancedSetting BPlayerAnimalGive = new AdvancedSetting();
                [JsonProperty("Сколько начислять валюты за убийство NPC")]
                public AdvancedSetting BPlayerNPCGive = new AdvancedSetting();
                [JsonProperty("Сколько начислять валюты за уничтожение танка")]
                public AdvancedSetting BPlayerBradleyGive = new AdvancedSetting();
                [JsonProperty("Сколько начислять валюты за уничтожение вертолета")]
                public AdvancedSetting BPlayerHelicopterGive = new AdvancedSetting();
                [JsonProperty("Сколько начислять валюты за уничтожение бочек")]
                public AdvancedSetting BPlayerBarrelGive = new AdvancedSetting();
                [JsonProperty("Сколько начислять валюты за добычу ресурсов ( [за какой ресурс давать] = { остальная настройка }")]
                public Dictionary<string,AdvancedSetting> BPlayerGatherGive = new Dictionary<string, AdvancedSetting>();

                internal class AdvancedSetting
                {
                    [JsonProperty("Шанс получить валюту")]
                    public int Rare;
                    [JsonProperty("Сколько выдавать валюты")]
                    public int BPlayerGive;
                }
            }
            internal class TransferSetting
            {
                [JsonProperty("URL вашей монеты")]
                public string URLMoney;
                [JsonProperty("URL валюты для магазина")]
                public string URLStores;
                [JsonProperty("Сколько монет требуется для обмена")]
                public int MoneyCount;
                [JsonProperty("Сколько баланса получит игрок после обмена")]
                public int StoresMoneyCount;
            }
            internal class ReferenceSetting
            {
                [JsonProperty("Friends : Запретить получение монет за убийство друзей")]
                public bool FriendsBlockUse;
                [JsonProperty("Clans : Запретить получение монет за убийство сокланов")]
                public bool ClansBlockUse;
                [JsonProperty("Duel/Battles : Запретить получение монет за убийство на дуэлях")]
                public bool DuelBlockUse;
                [JsonProperty("MoscovOVH : Включить использование магазина(Должен быть включен обмен валют)")]
                public bool MoscovOvhUse;
                [JsonProperty("GameStores : Включить использование магазина(Должен быть включен обмен валют)")]
                public bool GameStoreshUse;
                [JsonProperty("GameStores : Настройки магазина GameStores")]
                public GameStores GameStoresSettings = new GameStores();
                [JsonProperty("IQChat : Настройки чата")]
                public ChatSetting ChatSettings = new ChatSetting();
                internal class ChatSetting
                {
                    [JsonProperty("IQChat : Кастомный префикс в чате")]
                    public string CustomPrefix;
                    [JsonProperty("IQChat : Кастомный аватар в чате(Если требуется)")]
                    public string CustomAvatar;
                    [JsonProperty("IQChat : Использовать UI уведомления")]
                    public bool UIAlertUse;
                }
                internal class GameStores
                {
                    [JsonProperty("API Магазина(GameStores)")]
                    public string GameStoresAPIStore;
                    [JsonProperty("ID Магазина(GameStores)")]
                    public string GameStoresIDStore;
                    [JsonProperty("Сообщение в магазин при выдаче баланса(GameStores)")]
                    public string GameStoresMessage;
                }
            }

            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    UseUI = true,
                    ShowUI = true,
                    UseUIMoney = true,
                    TransferStoreUse = true,
                    TransferSettings = new TransferSetting
                    {
                        MoneyCount = 3,
                        StoresMoneyCount = 1,
                        URLMoney = "https://i.imgur.com/1dXVda4.png",
                        URLStores = "https://i.imgur.com/vPjkizs.png",
                    },
                    GeneralSetting = new GeneralSettings
                    {
                        BPLayerOnlineUse = true,
                        BPLayerBarrelUse = true,
                        BPlayerKillUse = true,
                        BPlayerAnimalUse = true,
                        BPlayerNPCUse = true,
                        BPlayerGatherUse = true,
                        BPlayerBradleyUse = true,
                        BPlayerHelicopterUse = true,
                        BPlayerOnlineTime = 60,
                        BPlayerOnlineGive = 5,
                        BPlayerAnimalGive = new GeneralSettings.AdvancedSetting { Rare = 53, BPlayerGive = 3 },
                        BPlayerKillGive = new GeneralSettings.AdvancedSetting { Rare = 40, BPlayerGive = 5 },
                        BPlayerNPCGive = new GeneralSettings.AdvancedSetting { Rare = 20, BPlayerGive = 2 },
                        BPlayerBradleyGive = new GeneralSettings.AdvancedSetting { Rare = 100 , BPlayerGive = 15},
                        BPlayerHelicopterGive = new GeneralSettings.AdvancedSetting { Rare = 90, BPlayerGive = 10 },
                        BPlayerBarrelGive = new GeneralSettings.AdvancedSetting { Rare = 10, BPlayerGive = 3 },
                        BPlayerGatherGive = new Dictionary<string, GeneralSettings.AdvancedSetting>
                        {
                            ["sulfur.ore"] = new GeneralSettings.AdvancedSetting
                            {
                                BPlayerGive = 10,
                                Rare = 10,
                            },
                            ["stones"] = new GeneralSettings.AdvancedSetting
                            {
                                Rare = 20,
                                BPlayerGive = 1,
                            }
                        },
                    },
                    CustomMoneySetting = new CustomMoney
                    {
                        DisplayName = "Монета удачи",
                        Shortname = "bleach",
                        SkinID = 1337228,
                    },
                    ReferenceSettings = new ReferenceSetting
                    {
                        FriendsBlockUse = true,
                        ClansBlockUse = true,
                        DuelBlockUse = true,
                        MoscovOvhUse = true,
                        GameStoreshUse = false,
                        GameStoresSettings = new ReferenceSetting.GameStores
                        {
                            GameStoresAPIStore = "",
                            GameStoresIDStore = "",
                            GameStoresMessage = "Успешный обмен"
                        },
                        ChatSettings = new ReferenceSetting.ChatSetting
                        {
                            CustomAvatar = "",
                            CustomPrefix = "",
                            UIAlertUse = true,
                        }
                    }

                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning("Ошибка #49" + $"чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию! #33");
                LoadDefaultConfig();
            }
            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion

        #region Data
        [JsonProperty("Система экономики")] public Dictionary<ulong, InformationData> DataEconomics = new Dictionary<ulong, InformationData>();
        void ReadData() { 
            DataEconomics = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, InformationData>>("IQEconomic/DataEconomics");
        }
        void WriteData() {
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQEconomic/DataEconomics", DataEconomics);
        }
        void RegisteredDataUser(ulong player)
        {
            if (!DataEconomics.ContainsKey(player))
                DataEconomics.Add(player, new InformationData { Balance = 0, Time = 0 });
        }
        public class InformationData
        {
            [JsonProperty("Баланс игрока")]
            public int Balance;
            [JsonProperty("Счетчик времени")]
            public int Time;
        }
        #endregion

        #region Command

        [ChatCommand("transfer")]
        void ChatCommandTransfer(BasePlayer player, string cmd, string[] arg)
        {
            if (player == null) return;
            if (!config.TransferStoreUse && arg.Length == 0 || arg == null)
            {
                SendChat(lang.GetMessage("TRANSFER_COMMAND_NO_ARGS", this, player.UserIDString),player);
                return;
            }
            else if(config.TransferStoreUse && arg.Length == 0 || arg == null)
            {
                Interface_Changer(player);
                return;
            }
            BasePlayer transferPlayer = FindPlayer(arg[0]);
            if (transferPlayer == null)
            {
                SendChat(lang.GetMessage("BALANCE_CUSTOM_MONEY_NOT_PLAYER", this, player.UserIDString), player);
                return;
            }
            if(transferPlayer.IsDead())
            {
                SendChat(lang.GetMessage("BALANCE_TRANSFER_TRANSFERPLAYER_DIE", this, player.UserIDString), player);
                return;
            }

            int TransferBalance = Convert.ToInt32(arg[1]);
            TransferPlayer(player.userID, transferPlayer.userID, TransferBalance);
        }
        
        [ConsoleCommand("transfer")]
        void ConsoleCommandTransfer(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (player == null) return;
            int Balance = GetBalance(player.userID);
            var Reference = config.ReferenceSettings;

            if (!IsTransfer(Balance)) return;
            var Transfer = config.TransferSettings;

            if (Reference.GameStoreshUse)
                GameStoresBalanceSet(player.userID, Transfer.StoresMoneyCount, Transfer.MoneyCount);

            if(Reference.MoscovOvhUse)
                MoscovOVHBalanceSet(player.userID, Transfer.StoresMoneyCount, Transfer.MoneyCount);

            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, "MY_INFO_TRANSFERS");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-130 5", OffsetMax = "60 50" },
                Text = { Text = String.Format(lang.GetMessage("UI_CHANGER_MY_INFO", this, player.UserIDString), GetBalance(player.userID) - Transfer.MoneyCount), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
            }, UI_CHANGER_PARENT, "MY_INFO_TRANSFERS");

            CuiHelper.AddUi(player, container);

        }

        [ConsoleCommand("migration")]
        void MigrationDataFile(ConsoleSystem.Arg args)
        {
            PrintWarning("Начинаем миграцию..Ищем файл . . .");
            string path = $"IQEconomic/DataEconomicsOLD";
            var data = Interface.GetMod().DataFileSystem.GetDatafile(path);
            if(data == null)
            {
                PrintError("Старый файл не найден!");
                return;
            }
            Dictionary<ulong,int> OldStructure = new Dictionary<ulong, int>();
            OldStructure = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, int>>(path);
            PrintWarning("Считали старую структуру....");
            foreach(var Old in OldStructure)
            {
                if (!DataEconomics.ContainsKey(Old.Key))
                    DataEconomics.Add(Old.Key, new InformationData { Balance = Old.Value, Time = 0 });
                else DataEconomics[Old.Key].Balance += Old.Value;
            }
            WriteData();
            PrintWarning("Миграция прошла успешно, выгрузите плагин и удалите старый файл");
        }

        [ConsoleCommand("iq.eco")]
        void IQEconomicCommandsAdmin(ConsoleSystem.Arg arg)
        {
            switch(arg.Args[0])
            {
                case "give":
                    {
                        ulong userID = ulong.Parse(arg.Args[1]);
                        int Balance = Convert.ToInt32(arg.Args[2]);
                        SetBalance(userID, Balance);
                        Puts($"Игроку {userID} успешно зачислено {Balance} монет");
                        break;
                    }
                case "remove":
                    {
                        ulong userID = ulong.Parse(arg.Args[1]);
                        int Balance = Convert.ToInt32(arg.Args[2]);
                        RemoveBalance(userID, Balance);
                        Puts($"Игроку {userID} успешно снято {Balance} монет");
                        break;
                    }
            }
        }

        #endregion

        #region Metods
        public void TrackerTime()
        {
            foreach (var player in BasePlayer.activePlayerList)
                if (DataEconomics[player.userID].Time <= CurrentTime())
                {
                    int SetTime = Convert.ToInt32(config.GeneralSetting.BPlayerOnlineTime + CurrentTime());
                    SetBalance(player.userID, config.GeneralSetting.BPlayerOnlineGive);
                    DataEconomics[player.userID].Time = SetTime;
                }
        }

        public void ConnectedPlayer(BasePlayer player)
        {
            if (player.IsReceivingSnapshot)
            {
                NextTick(() => ConnectedPlayer(player));
                return;
            }

            RegisteredDataUser(player.userID);

            if (config.UseUI)
                if (config.UseUIMoney)
                {
                    if (config.ShowUI)
                        Interface_Balance(player);
                }
                else SendChat(String.Format(lang.GetMessage("CHAT_MY_BALANCE", this), GetBalance(player.userID)), player);
        }
        public void TransferPlayer(ulong userID, ulong transferUserID, int Balance )
        {
            BasePlayer player = BasePlayer.FindByID(userID);
            BasePlayer transferPlayer = BasePlayer.FindByID(transferUserID);
            if (player == null) return;
            if (transferPlayer == null) return;

            if (!IsRemoveBalance(player.userID, Balance))
            {
                SendChat(lang.GetMessage("BALANCE_TRANSFER_NO_BALANCE", this, player.UserIDString), player);
                return;
            }

            RemoveBalance(player.userID, Balance);
            SetBalance(transferPlayer.userID, Balance);
            SendChat(String.Format(lang.GetMessage("BALANCE_TRANSFER_PLAYER", this, player.UserIDString), transferPlayer.displayName, Balance),player);
            SendChat(String.Format(lang.GetMessage("BALANCE_TRANSFER_TRANSFERPLAYER", this, transferPlayer.UserIDString), Balance, player.displayName),transferPlayer);
        }
        public void SetBalance(ulong userID, int SetBalance, ItemContainer cont = null)
        {
            if(!config.UseUI)
            {
                BasePlayer player = BasePlayer.FindByID(userID);
                if (player == null)
                {
                    PrintWarning(lang.GetMessage("BALANCE_CUSTOM_MONEY_NOT_PLAYER",this));
                    return;
                }
                Item Money = CreateCustomMoney(SetBalance);
                ItemContainer itemContainer = cont == null ? player.inventory.containerMain : cont;

                if (player.inventory.containerMain.itemList.Count == 24)
                {
                    SendChat(lang.GetMessage("BALANCE_CUSTOM_MONEY_INVENTORY_FULL", this, player.UserIDString), player);
                    Money.Drop(player.transform.position, Vector3.zero);
                    return;
                }
                Money.MoveToContainer(itemContainer);
                SendChat(String.Format(lang.GetMessage("BALANCE_SET", this), SetBalance), player);
            }
            else
            {
                if (IsData(userID))
                {
                    DataEconomics[userID].Balance += SetBalance;
                    BasePlayer player = BasePlayer.FindByID(userID);
                    if (player == null) return;
                    SendChat(String.Format(lang.GetMessage("BALANCE_SET", this), SetBalance), player);
                    if (config.ShowUI)
                        Interface_Balance(player);
                }
                else RegisteredDataUser(userID);
                WriteData();
            }
            Interface.Oxide.CallHook("SET_BALANCE_USER", userID, SetBalance);
        }
        public void RemoveBalance(ulong userID, int RemoveBalance)
        {
            if (!config.UseUI)
            {
                BasePlayer player = BasePlayer.FindByID(userID);
                if (player == null)
                {
                    PrintWarning(lang.GetMessage("BALANCE_CUSTOM_MONEY_NOT_PLAYER", this));
                    return;
                }
                if(!IsRemoveBalance(userID,RemoveBalance))
                {
                    PrintWarning(lang.GetMessage("BALANCE_CUSTOM_MONEY_NO_COUNT_TAKE", this));
                    return;
                }
                player.inventory.Take(null, ItemManager.FindItemDefinition(config.CustomMoneySetting.Shortname).itemid, RemoveBalance);
            }
            else
            {
                if (IsData(userID))
                {
                    DataEconomics[userID].Balance -= RemoveBalance;
                    BasePlayer player = BasePlayer.FindByID(userID);
                    if (player == null) return;
                    if (config.ShowUI)
                        Interface_Balance(player);
                }
                else RegisteredDataUser(userID);
                WriteData();
            }
        }

        #region ReturnMetods

        public bool IsRare(int Rare)
        {
            if (Rare >= UnityEngine.Random.Range(0, 100))
                return true;
            else return false;
        }
        public bool IsData(ulong userID)
        {
            if (DataEconomics.ContainsKey(userID))
                return true;
            else return false;
        }
        public int GetBalance(ulong userID)
        {
            if (config.UseUI)
            {
                if (IsData(userID))
                    return DataEconomics[userID].Balance;
                else return 0;
            }
            else
            {
                BasePlayer player = BasePlayer.FindByID(userID);
                if (player == null)
                {
                    PrintWarning(lang.GetMessage("BALANCE_CUSTOM_MONEY_NOT_PLAYER", this));
                    return 0;
                }
                var PMoney = player.inventory.GetAmount(ItemManager.FindItemDefinition(config.CustomMoneySetting.Shortname).itemid);
                return PMoney;
            }
        }
        Item CreateCustomMoney(int Amount)
        {
            var CustomMoney = config.CustomMoneySetting;
            Item Money = ItemManager.CreateByName(CustomMoney.Shortname, Amount, CustomMoney.SkinID);
            Money.name = CustomMoney.DisplayName;
            return Money;
        }

        public bool IsRemoveBalance(ulong userID,int Amount)
        {
            if (GetBalance(userID) >= Amount)
                return true;
            else return false;
        }

        private BasePlayer FindPlayer(string nameOrId)
        {
            foreach (var check in BasePlayer.activePlayerList)
            {
                if (check.displayName.ToLower().Contains(nameOrId.ToLower()) || check.userID.ToString() == nameOrId)
                    return check;
            }

            return null;
        }

        public bool IsTransfer(int Balance)
        {
            var TransferCurse = config.TransferSettings;
            if (Balance < TransferCurse.MoneyCount) return false;
            else return true;
        }
        #endregion

        #endregion

        #region Hooks
        void Unload()
        {
            WriteData();
            foreach(BasePlayer player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, UI_BALANCE_PARENT);
                CuiHelper.DestroyUi(player, UI_CHANGER_PARENT);
            }
        }
        private void OnServerInitialized()
        {
            ReadData();
            foreach (var player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);
            WriteData();
            AddAllImage();
            if (config.GeneralSetting.BPLayerOnlineUse)
                timer.Every(120f, () => TrackerTime());
        }
        void OnPlayerConnected(BasePlayer player) => ConnectedPlayer(player);
        void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            if (dispenser == null) return;
            if (player == null) return;
            if (item == null) return;
            var General = config.GeneralSetting;
            if (!General.BPlayerGatherUse) return;
            var GatherGeneral = config.GeneralSetting.BPlayerGatherGive;
            if (!GatherGeneral.ContainsKey(item.info.shortname)) return;
            var Gather = GatherGeneral[item.info.shortname];
            if (!IsRare(Gather.Rare)) return;

            SetBalance(player.userID, Gather.BPlayerGive);
        }
        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null || info == null) return;
            BasePlayer player = info.InitiatorPlayer;
            if (info.InitiatorPlayer != null)
                player = info.InitiatorPlayer;
            else if (entity.GetComponent<BaseHelicopter>() != null)
                player = BasePlayer.FindByID(GetLastAttacker(entity.net.ID));
            if (player == null) return;

            var General = config.GeneralSetting;
            var ReferenceGeneral = config.ReferenceSettings;

            if ((bool)(entity as NPCPlayer) || (bool)(entity as NPCMurderer))
                if (General.BPlayerNPCUse)
                {
                    var Setting = General.BPlayerNPCGive;
                    if (!IsRare(Setting.Rare)) return;
                    SetBalance(player.userID, Setting.BPlayerGive);
                }
            if ((bool)(entity as BasePlayer))
            {
                if ((bool)(entity as NPCPlayer) || (bool)(entity as NPCMurderer)) return;

                BasePlayer targetPlayer = entity.ToPlayer();
                if (targetPlayer == null) return;
                if (targetPlayer.userID != player.userID)
                    if (General.BPlayerKillUse)
                    {
                        if (ReferenceGeneral.FriendsBlockUse)
                            if (IsFriends(player.userID, targetPlayer.userID)) return;
                        if (ReferenceGeneral.ClansBlockUse)
                            if (IsClans(player.userID, targetPlayer.userID)) return;
                        if (ReferenceGeneral.DuelBlockUse)
                            if (IsDuel(player.userID)) return;

                        var Setting = General.BPlayerKillGive;
                        if (!IsRare(Setting.Rare)) return;
                        SetBalance(player.userID, Setting.BPlayerGive);
                    }
            }
            if ((bool)(entity as BaseAnimalNPC))
                if (General.BPlayerAnimalUse)
                {
                    var Setting = General.BPlayerAnimalGive;
                    if (!IsRare(Setting.Rare)) return;
                    SetBalance(player.userID, Setting.BPlayerGive);
                }
            if ((bool)(entity as BaseHelicopter))
                if (General.BPlayerHelicopterUse)
                {
                    var Setting = General.BPlayerHelicopterGive;
                    if (!IsRare(Setting.Rare)) return;
                    SetBalance(player.userID, Setting.BPlayerGive);
                }
            if ((bool)(entity as BradleyAPC))
                if (General.BPlayerBradleyUse)
                {
                    var Setting = General.BPlayerBradleyGive;
                    if (!IsRare(Setting.Rare)) return;
                    SetBalance(player.userID, Setting.BPlayerGive);
                }
            if(entity.PrefabName.Contains("barrel"))
                if(General.BPLayerBarrelUse)
                {
                    var Setting = General.BPlayerBarrelGive;
                    if (!IsRare(Setting.Rare)) return;
                    SetBalance(player.userID, Setting.BPlayerGive);
                }
        }

        private Dictionary<uint, Dictionary<ulong, int>> HeliAttackers = new Dictionary<uint, Dictionary<ulong, int>>();
        void OnEntityTakeDamage(BaseCombatEntity victim, HitInfo info)
        {
            if (victim.GetComponent<BaseHelicopter>() != null && info?.Initiator?.ToPlayer() != null)
            {
                var heli = victim.GetComponent<BaseHelicopter>();
                var player = info.Initiator.ToPlayer();
                NextTick(() =>
                {
                    if (heli == null) return;
                    if (!HeliAttackers.ContainsKey(heli.net.ID))
                        HeliAttackers.Add(heli.net.ID, new Dictionary<ulong, int>());
                    if (!HeliAttackers[heli.net.ID].ContainsKey(player.userID))
                        HeliAttackers[heli.net.ID].Add(player.userID, 0);
                    HeliAttackers[heli.net.ID][player.userID]++;
                });
            }
        }

        private ulong GetLastAttacker(uint id)
        {
            int hits = 0;
            ulong majorityPlayer = 0U;
            if (HeliAttackers.ContainsKey(id))
            {
                foreach (var score in HeliAttackers[id])
                {
                    if (score.Value > hits)
                        majorityPlayer = score.Key;
                }
            }
            return majorityPlayer;
        }

        #region HelpHooks
        private Item OnItemSplit(Item item, int amount)
        {
            if (plugins.Find("Stacks") || plugins.Find("CustomSkinsStacksFix") || plugins.Find("SkinBox")) return null; 
            var CustomMoney = config.CustomMoneySetting;
            if (CustomMoney.SkinID == 0) return null;
            if (item.skin == CustomMoney.SkinID)
            {
                Item x = ItemManager.CreateByPartialName(CustomMoney.Shortname, amount);
                x.name = CustomMoney.DisplayName;
                x.skin = CustomMoney.SkinID;
                x.amount = amount;
                item.amount -= amount;
                return x;
            }
            return null;
        }
        object CanCombineDroppedItem(DroppedItem item, DroppedItem targetItem)
        {
            if (item.GetItem().skin != targetItem.GetItem().skin) return false;

            return null;
        }
        object CanStackItem(Item item, Item targetItem)
        {
            if (item.skin != targetItem.skin) return false;

            return null;
        }
        #endregion

        #endregion

        #region Interface

        public static string UI_BALANCE_PARENT = "BALANCE_PLAYER_PARENT";
        public static string UI_CHANGER_PARENT = "CHANGER_PLAYER_PARENT";
        public void Interface_Balance(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, UI_BALANCE_PARENT);

            var Balance = GetBalance(player.userID);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"1 0", AnchorMax = $"1 0", OffsetMin = "-396 70", OffsetMax = "-218 97" },
                Image = { FadeIn = 0.15f, Color = HexToRustFormat("#FFFFFF05"), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            }, "Hud", UI_BALANCE_PARENT);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.01932367 0.04938272", AnchorMax = $"0.1541551 0.9382206" },
                Image = { FadeIn = 0.15f, Color = HexToRustFormat("#b1b1b1"), Sprite = "assets/icons/favourite_servers.png" }
            }, UI_BALANCE_PARENT);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.1835208 0.1358024", AnchorMax = $"0.9625472 0.8518519" },
                Image = { FadeIn = 0.15f, Color = HexToRustFormat("#FF800080"), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            }, UI_BALANCE_PARENT);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.22 0", AnchorMax = "1 1" },
                Text = { Text = String.Format(lang.GetMessage("UI_MY_BALANCE", this), Balance), Color = HexToRustFormat("#FEFFDDFF"), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft, FadeIn = 0.3f }
            }, UI_BALANCE_PARENT); 

            CuiHelper.AddUi(player, container); 
        }

        public void Interface_Changer(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, UI_CHANGER_PARENT);
            var Balance = GetBalance(player.userID);
            var Transfer = config.TransferSettings;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.5 0.5", AnchorMax = $"0.5 0.5", OffsetMin = "-150 -280", OffsetMax = "20 -230" },
                Image = { FadeIn = 0.15f, Color = HexToRustFormat("#292A2140"), Material = "assets/content/ui/uibackgroundblur.mat" }
            }, "Overlay", UI_CHANGER_PARENT);

            container.Add(new CuiButton
            {
                FadeOut = 0.2f,
                RectTransform = { AnchorMin = $"1 1", AnchorMax = $"1 1", OffsetMin = "2 -50", OffsetMax = "161 0" },
                Button = { Command = $"transfer", Color = HexToRustFormat("#FF800080"), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                Text = { Text = lang.GetMessage("UI_CHANGER_TRANSFER", this, player.UserIDString), Color = HexToRustFormat("#0B5CF4"), Align = TextAnchor.MiddleCenter }
            },  UI_CHANGER_PARENT);

            container.Add(new CuiButton
            {
                FadeOut = 0.2f,
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"0 0", OffsetMin = "-50 0", OffsetMax = "-2 50" },
                Button = { Close = UI_CHANGER_PARENT, Color = HexToRustFormat("#b0382580"), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                Text = { Text = "<b>✖</b>", Color = HexToRustFormat("#c8a097"),FontSize = 30, Align = TextAnchor.MiddleCenter }
            }, UI_CHANGER_PARENT);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-130 5", OffsetMax = "60 50" },
                Text = { Text = String.Format(lang.GetMessage("UI_CHANGER_MY_INFO", this,player.UserIDString),Balance), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
            }, UI_CHANGER_PARENT,"MY_INFO_TRANSFERS");

            #region TransferInterface

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.01866667 0.06666667", AnchorMax = $"0.2696471 0.92" },
                Image = { Color = HexToRustFormat("#8A847E3D"), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            }, UI_CHANGER_PARENT, "MY_MONEY");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.7351995 0.06666667", AnchorMax = $"0.9861803 0.92" },
                Image = { Color = HexToRustFormat("#8A847E3D"), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            }, UI_CHANGER_PARENT, "TRANSFER_MONEY");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.2151515 0.1200001", AnchorMax = "0.7757577 0.8800001" },
                Text = { Text = $"<b>{Transfer.MoneyCount} > {Transfer.StoresMoneyCount} </b>", Font = "robotocondensed-bold.ttf", FontSize = 20, Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
            },  UI_CHANGER_PARENT);

            container.Add(new CuiElement
            {
                Parent = "MY_MONEY",
                Components =
                        {
                        new CuiRawImageComponent { Png = GetImage("URLMoney") },
                        new CuiRectTransformComponent{  AnchorMin = $"0.125 0.125", AnchorMax = $"0.875 0.875" },
                        }
            });

            container.Add(new CuiElement
            {
                Parent = "TRANSFER_MONEY",
                Components =
                        {
                        new CuiRawImageComponent { Png = GetImage("URLStores") },
                        new CuiRectTransformComponent{  AnchorMin = $"0.125 0.125", AnchorMax = $"0.875 0.875" },
                        }
            });

            #endregion

            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region Lang
        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["UI_MY_BALANCE"] = "<b><size=12>Balance : {0}</size></b>",

                ["CHAT_MY_BALANCE"] = "Your Balance : <color=yellow>{0}</color>",
                ["BALANCE_CUSTOM_MONEY_NOT_PLAYER"] = "Player not found",
                ["BALANCE_CUSTOM_MONEY_INVENTORY_FULL"] = "Your inventory is full, coins fell to the floor",

                ["BALANCE_SET"] = "You have successfully received : {0} money",
                ["BALANCE_TRANSFER_NO_BALANCE"] = "You do not have so many coins to transfer",
                ["BALANCE_TRANSFER_PLAYER"] = "You have successfully submitted {0} {1} money",
                ["BALANCE_TRANSFER_TRANSFERPLAYER"] = "You have successfully received {0} money from {1}",
                ["BALANCE_CUSTOM_MONEY_NO_COUNT_TAKE"] = "The player does not have as many coins available",
                ["BALANCE_TRANSFER_TRANSFERPLAYER_DIE"] = "The player is dead, you can’t give him coins",

                ["TRANSFER_COMMAND_NO_ARGS"] = "Invalid Command\nEnter the correct transfer command transfer [Nick] [Amount Money]",

                ["UI_CHANGER_TRANSFER"] = "<b><size=20>TRANSFER</size>  </b>",
                ["UI_CHANGER_MY_INFO"] = "<b><size=16>TRANSFERS\nYour Balance : {0}</size></b>",

                ["CHAT_NO_AUTH_STORE"] = "You no auth stores",
                ["CHAT_STORE_SUCCESS"] = "You succes transfers",
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["UI_MY_BALANCE"] = "<b><size=12>Ваш баланс : {0}</size></b>",

                ["CHAT_MY_BALANCE"] = "Ваш баланс на данный момент : <color=yellow>{0}</color>",

                ["BALANCE_SET"] = "Вы успешно получили : {0} монет",
                ["BALANCE_CUSTOM_MONEY_NOT_PLAYER"] = "Такого игрока нет",
                ["BALANCE_CUSTOM_MONEY_INVENTORY_FULL"] = "Ваш инвентарь полон, монеты выпали на пол",
                ["BALANCE_CUSTOM_MONEY_NO_COUNT_TAKE"] = "У игрока нет столько монет в наличии",

                ["BALANCE_TRANSFER_NO_BALANCE"] = "У вас нет столько монет для передачи",
                ["BALANCE_TRANSFER_PLAYER"] = "Вы успешно передали {0} {1} монет(ы)",
                ["BALANCE_TRANSFER_TRANSFERPLAYER"] = "Вы успешно получили {0} монет(ы) от {1}",
                ["BALANCE_TRANSFER_TRANSFERPLAYER_DIE"] = "Игрок мертв,вы не можете передать ему монеты",

                ["TRANSFER_COMMAND_NO_ARGS"] = "Неверная команда\nВведите корректную команду transfer [Ник] [Количество монет]",

                ["UI_CHANGER_TRANSFER"] = "<b><size=20>ОБМЕНЯТЬ</size></b>",
                ["UI_CHANGER_MY_INFO"] = "<b><size=16>ОБМЕННИК\nВАШ БАЛАНС : {0}</size></b>",

                ["CHAT_NO_AUTH_STORE"] = "Вы не аваторизованы в магазине",
                ["CHAT_STORE_SUCCESS"] = "Вы успешно обменяли валюту",
            }, this, "ru");
            PrintWarning("Языковой файл загружен успешно");
        }
        #endregion

        #region Helps
        private static string HexToRustFormat(string hex)
        {
            Color color;
            ColorUtility.TryParseHtmlString(hex, out color);
            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }
        static DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        static double CurrentTime() => DateTime.UtcNow.Subtract(epoch).TotalSeconds;
        #endregion

        #region API
        bool API_IS_USER(ulong userID) => IsData(userID);
        bool API_IS_REMOVED_BALANCE(ulong userID, int Amount) => IsRemoveBalance(userID, Amount);
        int API_GET_BALANCE(ulong userID) => GetBalance(userID);
        Item API_GET_ITEM(int Amount) => CreateCustomMoney(Amount);
        string API_GET_MONEY_IL() { return "URLMoney"; }
        string API_GET_STORES_IL() { return "URLStores"; }
        void API_SET_BALANCE(ulong userID, int Balance, ItemContainer itemContainer = null)
        {
            SetBalance(userID, Balance, itemContainer);
            Puts("Успешно зачислен баланс");
        }
        void API_REMOVE_BALANCE(ulong userID, int Balance)
        {
            RemoveBalance(userID, Balance);
            Puts("Успешно списан баланс");
        }
        void API_TRANSFERS(ulong userID, ulong trasferUserID, int Balance) => TransferPlayer(userID, trasferUserID, Balance);
        bool API_MONEY_TYPE()
        {
            if (!config.UseUI)
                return true;
            else return false;
        }
        #endregion
    }
}


// --- End of file: IQEconomic.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/SignArtist.cs ---
// --- Original Local Path: KualaRust/SignArtist.cs ---

// Reference: System.Drawing
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Plugins.SignArtistClasses;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Drawing.Imaging;
using System.IO;
using System.Linq;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;
using UnityEngine.Networking;
using Color = System.Drawing.Color;
using Graphics = System.Drawing.Graphics;
using Steamworks;

namespace Oxide.Plugins
{
    [Info("Sign Artist", "Whispers88", "1.2.6")]
    [Description("Allows players with the appropriate permission to import images from the internet on paintable objects")]

    /*********************************************************************************
     * This plugin was originally created by Bombardir and then maintained by Nogrod.
     * It was rewritten from scratch by Mughisi on January 12th, 2018.
     *********************************************************************************/

    internal class SignArtist : RustPlugin
    {
        private Dictionary<ulong, float> cooldowns = new Dictionary<ulong, float>();
        private GameObject imageDownloaderGameObject;
        private ImageDownloader imageDownloader;
        SignArtistConfig Settings { get; set; }
        Dictionary<string, ImageSize> ImageSizePerAsset { get; set; }

        Dictionary<ulong, string> SkiniconUrls = new Dictionary<ulong, string>();

        private const string ItemIconUrl = "https://www.rustedit.io/images/imagelibrary/{0}.png";


        /// <summary>
        /// Plugin configuration
        /// </summary>
        public class SignArtistConfig
        {
            [JsonProperty(PropertyName = "Time in seconds between download requests (0 to disable)")]
            public int Cooldown { get; set; }

            [JsonProperty(PropertyName = "Maximum concurrent downloads")]
            public int MaxActiveDownloads { get; set; }

            [JsonProperty(PropertyName = "Maximum distance from the sign")]
            public int MaxDistance { get; set; }

            [JsonProperty(PropertyName = "Maximum filesize in MB")]
            public float MaxSize { get; set; }

            [JsonProperty(PropertyName = "Enforce JPG file format")]
            public bool EnforceJpeg { get; set; }

            [JsonProperty(PropertyName = "JPG image quality (0-100)")]
            public int Quality
            {
                get
                {
                    return quality;
                }
                set
                {
                    // Validate the value, it can't be less than 0 and not more than 100.
                    if (value >= 0 && value <= 100)
                    {
                        quality = value;
                    }
                    else
                    {
                        // Set the quality to a default value of 85% when an invalid value was specified.
                        quality = value > 100 ? 100 : 85;
                    }
                }
            }

            [JsonProperty("Enable logging file")]
            public bool FileLogging { get; set; }

            [JsonProperty("Enable logging console")]
            public bool ConsoleLogging { get; set; }

            [JsonProperty("Enable discord logging")]
            public bool Discordlogging { get; set; }

            [JsonProperty("Discord Webhook")]
            public string DiscordWebhook { get; set; }

            [JsonProperty("Avatar URL")]
            public string AvatarUrl { get; set; }

            [JsonProperty("Discord Username")]
            public string DiscordUsername { get; set; }


            [JsonIgnore]
            public float MaxFileSizeInBytes
            {
                get
                {
                    return MaxSize * 1024 * 1024;
                }
            }

            private int quality = 85;

            /// <summary>
            /// Creates a default configuration file
            /// </summary>
            /// <returns>Default config</returns>
            public static SignArtistConfig DefaultConfig()
            {
                return new SignArtistConfig
                {
                    Cooldown = 0,
                    MaxSize = 1,
                    MaxDistance = 3,
                    MaxActiveDownloads = 5,
                    EnforceJpeg = false,
                    Quality = 85,
                    FileLogging = false,
                    ConsoleLogging = false,
                    Discordlogging = false,
                    DiscordWebhook = "",
                    AvatarUrl = "https://i.imgur.com/dH7V1Dh.png",
                    DiscordUsername = "Sign Artist"
                };
            }
        }

        /// <summary>
        /// A type used to request new images to download.
        /// </summary>
        private class DownloadRequest
        {
            public BasePlayer Sender { get; }
            public IPaintableEntity Sign { get; }
            public string Url { get; set; }
            public bool Raw { get; }
            public bool Hor { get; }

            /// <summary>
            /// Initializes a new instance of the <see cref="DownloadRequest" /> class.
            /// </summary>
            /// <param name="url">The URL to download the image from. </param>
            /// <param name="player">The player that requested the download. </param>
            /// <param name="sign">The sign to add the image to. </param>
            /// <param name="raw">Should the image be stored with or without conversion to jpeg. </param>
            public DownloadRequest(string url, BasePlayer player, IPaintableEntity sign, bool raw, bool hor)
            {
                Url = url;
                Sender = player;
                Sign = sign;
                Raw = raw;
                Hor = hor;
            }
        }

        /// <summary>
        /// A type used to request new images to be restored.
        /// </summary>
        private class RestoreRequest
        {
            public BasePlayer Sender { get; }
            public IPaintableEntity Sign { get; }
            public bool Raw { get; }

            /// <summary>
            /// Initializes a new instance of the <see cref="RestoreRequest" /> class.
            /// </summary>
            /// <param name="player">The player that requested the restore. </param>
            /// <param name="sign">The sign to restore the image from. </param>
            /// <param name="raw">Should the image be stored with or without conversion to jpeg. </param>
            public RestoreRequest(BasePlayer player, IPaintableEntity sign, bool raw)
            {
                Sender = player;
                Sign = sign;
                Raw = raw;
            }
        }

        /// <summary>
        /// A type used to determine the size of the image for a sign
        /// </summary>
        public class ImageSize
        {
            public int Width { get; }
            public int Height { get; }
            public int ImageWidth { get; }
            public int ImageHeight { get; }

            /// <summary>
            /// Initializes a new instance of the <see cref="ImageSize" /> class.
            /// </summary>
            /// <param name="width">The width of the canvas and the image. </param>
            /// <param name="height">The height of the canvas and the image. </param>
            public ImageSize(int width, int height) : this(width, height, width, height)
            {
            }

            /// <summary>
            /// Initializes a new instance of the <see cref="ImageSize" /> class.
            /// </summary>
            /// <param name="width">The width of the canvas. </param>
            /// <param name="height">The height of the canvas. </param>
            /// <param name="imageWidth">The width of the image. </param>
            /// <param name="imageHeight">The height of the image. </param>
            public ImageSize(int width, int height, int imageWidth, int imageHeight)
            {
                Width = width;
                Height = height;
                ImageWidth = imageWidth;
                ImageHeight = imageHeight;
            }
        }


        #region Image Download Behaviour
        /// <summary>
        /// UnityEngine script to be attached to a GameObject to download images and apply them to signs.
        /// </summary>
        private class ImageDownloader : MonoBehaviour
        {
            private byte activeDownloads;
            private byte activeRestores;
            private readonly SignArtist signArtist = (SignArtist)Interface.Oxide.RootPluginManager.GetPlugin(nameof(SignArtist));
            private readonly Queue<DownloadRequest> downloadQueue = new Queue<DownloadRequest>();
            private readonly Queue<RestoreRequest> restoreQueue = new Queue<RestoreRequest>();

            /// <summary>
            /// Queue a new image to download and add to a sign
            /// </summary>
            /// <param name="url">The URL to download the image from. </param>
            /// <param name="player">The player that requested the download. </param>
            /// <param name="sign">The sign to add the image to. </param>
            /// <param name="raw">Should the image be stored with or without conversion to jpeg. </param>
            public void QueueDownload(string url, BasePlayer player, IPaintableEntity sign, bool raw, bool hor = false)
            {
                // Check if there is already a request for this sign and show an error if there is.
                bool existingRequest = downloadQueue.Any(request => request.Sign == sign) || restoreQueue.Any(request => request.Sign == sign);
                if (existingRequest)
                {
                    signArtist.SendMessage(player, "ActionQueuedAlready");

                    return;
                }

                // Instantiate a new DownloadRequest and add it to the queue.
                downloadQueue.Enqueue(new DownloadRequest(url, player, sign, raw, hor));

                // Attempt to start the next download.
                StartNextDownload();
            }

            /// <summary>
            /// Attempts to restore a sign.
            /// </summary>
            /// <param name="player">The player that requested the restore. </param>
            /// <param name="sign">The sign to restore the image from. </param>
            /// <param name="raw">Should the image be stored with or without conversion to jpeg. </param>
            public void QueueRestore(BasePlayer player, IPaintableEntity sign, bool raw)
            {
                // Check if there is already a request for this sign and show an error if there is.
                bool existingRequest = downloadQueue.Any(request => request.Sign == sign) || restoreQueue.Any(request => request.Sign == sign);
                if (existingRequest)
                {
                    signArtist.SendMessage(player, "ActionQueuedAlready");

                    return;
                }

                // Instantiate a new RestoreRequest and add it to the queue.
                restoreQueue.Enqueue(new RestoreRequest(player, sign, raw));

                // Attempt to start the next restore.
                StartNextRestore();
            }

            /// <summary>
            /// Starts the next download if available.
            /// </summary>
            /// <param name="reduceCount"></param>
            private void StartNextDownload(bool reduceCount = false)
            {
                // Check if we need to reduce the active downloads counter after a succesful or failed download.
                if (reduceCount)
                {
                    activeDownloads--;
                }

                // Check if we don't have the maximum configured amount of downloads running already.
                if (activeDownloads >= signArtist.Settings.MaxActiveDownloads)
                {
                    return;
                }

                // Check if there is still an image in the queue.
                if (downloadQueue.Count <= 0)
                {
                    return;
                }

                // Increment the active downloads by 1 and start the download process.
                activeDownloads++;
                StartCoroutine(DownloadImage(downloadQueue.Dequeue()));
            }

            /// <summary>
            /// Starts the next restore if available.
            /// </summary>
            /// <param name="reduceCount"></param>
            private void StartNextRestore(bool reduceCount = false)
            {
                // Check if we need to reduce the active restores counter after a succesful or failed restore.
                if (reduceCount)
                {
                    activeRestores--;
                }

                // Check if we don't have the maximum configured amount of restores running already.
                if (activeRestores >= signArtist.Settings.MaxActiveDownloads)
                {
                    return;
                }

                // Check if there is still an image in the queue.
                if (restoreQueue.Count <= 0)
                {
                    return;
                }

                // Increment the active restores by 1 and start the restore process.
                activeRestores++;
                StartCoroutine(RestoreImage(restoreQueue.Dequeue()));
            }

            /// <summary>
            /// Downloads the image and adds it to the sign.
            /// </summary>
            /// <param name="request">The requested <see cref="DownloadRequest"/> instance. </param>
            private IEnumerator DownloadImage(DownloadRequest request)
            {
                if (ItemManager.itemDictionaryByName.ContainsKey(request.Url))
                {
                    request.Url = string.Format(ItemIconUrl, request.Url);
                }

                UnityWebRequest www = UnityWebRequest.Get(request.Url);

                yield return www.SendWebRequest();

                // Verify that there is a valid reference to the plugin from this class.
                if (signArtist == null)
                {
                    throw new NullReferenceException("signArtist");
                }

                // Verify that the webrequest was succesful.
                if (www.isNetworkError || www.isHttpError)
                {
                    // The webrequest wasn't succesful, show a message to the player and attempt to start the next download.
                    signArtist.SendMessage(request.Sender, "WebErrorOccurred", www.error);
                    www.Dispose();
                    StartNextDownload(true);
                    yield break;
                }

                // Verify that the file doesn't exceed the maximum configured filesize.
                if (www.downloadedBytes > signArtist.Settings.MaxFileSizeInBytes)
                {
                    // The file is too large, show a message to the player and attempt to start the next download.
                    signArtist.SendMessage(request.Sender, "FileTooLarge", signArtist.Settings.MaxSize);
                    www.Dispose();
                    StartNextDownload(true);
                    yield break;
                }

                // Get the bytes array for the image from the webrequest and lookup the target image size for the targeted sign.
                byte[] imageBytes;

                if (request.Raw)
                {
                    imageBytes = www.downloadHandler.data;
                }
                else
                {
                    imageBytes = GetImageBytes(www);
                }

                ImageSize size = GetImageSizeFor(request.Sign);

                // Verify that we have image size data for the targeted sign.
                if (size == null)
                {
                    // No data was found, show a message to the player and print a detailed message to the server console and attempt to start the next download.
                    signArtist.SendMessage(request.Sender, "ErrorOccurred");
                    signArtist.PrintWarning($"Couldn't find the required image size for {request.Sign.PrefabName}, please report this in the plugin's thread.");
                    StartNextDownload(true);
                    www.Dispose();
                    yield break;
                }

                RotateFlipType rotation = RotateFlipType.RotateNoneFlipNone;
                if (request.Hor)
                {
                    rotation = RotateFlipType.RotateNoneFlipX;
                }

                object rotateObj = Interface.Call("GetImageRotation", request.Sign.Entity);
                if (rotateObj is RotateFlipType)
                {
                    rotation = (RotateFlipType)rotateObj;
                }

                // Get the bytes array for the resized image for the targeted sign.
                byte[] resizedImageBytes = imageBytes.ResizeImage(size.Width, size.Height, size.ImageWidth, size.ImageHeight, signArtist.Settings.EnforceJpeg && !request.Raw, rotation);
                // Verify that the resized file doesn't exceed the maximum configured filesize.
                if (resizedImageBytes.Length > signArtist.Settings.MaxFileSizeInBytes)
                {
                    // The file is too large, show a message to the player and attempt to start the next download.
                    signArtist.SendMessage(request.Sender, "FileTooLarge", signArtist.Settings.MaxSize);
                    www.Dispose();
                    StartNextDownload(true);

                    yield break;
                }

                // Check if the sign already has a texture assigned to it.
                if (request.Sign.TextureId() > 0)
                {
                    // A texture was already assigned, remove this file to make room for the new one.
                    FileStorage.server.Remove(request.Sign.TextureId(), FileStorage.Type.png, request.Sign.NetId);
                }

                // Create the image on the filestorage and send out a network update for the sign.
                request.Sign.SetImage(FileStorage.server.Store(resizedImageBytes, FileStorage.Type.png, request.Sign.NetId));
                request.Sign.SendNetworkUpdate();

                // Notify the player that the image was loaded.
                signArtist.SendMessage(request.Sender, "ImageLoaded");

                // Call the Oxide hook 'OnSignUpdated' to notify other plugins of the update event.
                Interface.Oxide.CallHook("OnSignUpdated", request.Sign, request.Sender);

                if (request.Sender != null)
                {
                    // Check if logging to console is enabled.
                    if (signArtist.Settings.ConsoleLogging)
                    {
                        // Console logging is enabled, show a message in the server console.
                        signArtist.Puts(signArtist.GetTranslation("LogEntry"), request.Sender.displayName,
                            request.Sender.userID, request.Sign.TextureId(), request.Sign.ShortPrefabName, request.Url);
                    }

                    // Check if logging to file is enabled.
                    if (signArtist.Settings.FileLogging)
                    {
                        // File logging is enabled, add an entry to the logfile.
                        signArtist.LogToFile("log",
                            string.Format(signArtist.GetTranslation("LogEntry"), request.Sender.displayName,
                                request.Sender.userID, request.Sign.TextureId(), request.Sign.ShortPrefabName,
                                request.Url), signArtist);
                    }

                    if (signArtist.Settings.Discordlogging)
                    {
                        // Discord logging is enabled, add an entry to the logfile.
                        StartCoroutine(LogToDiscord(request));
                    }
                }
                // Attempt to start the next download.
                StartNextDownload(true);
                www.Dispose();

            }

            private IEnumerator LogToDiscord(DownloadRequest request)
            {
                BasePlayer player = request.Sender;
                IPaintableEntity sign = request.Sign;
                var msg = DiscordMessage(ConVar.Server.hostname, player.displayName, player.UserIDString, sign.ShortPrefabName, request.Url, sign.Entity.transform.position.ToString());
                string jsonmsg = JsonConvert.SerializeObject(msg);
                UnityWebRequest wwwpost = new UnityWebRequest(signArtist.Settings.DiscordWebhook, "POST");
                byte[] jsonToSend = new System.Text.UTF8Encoding().GetBytes(jsonmsg.ToString());
                wwwpost.uploadHandler = (UploadHandler)new UploadHandlerRaw(jsonToSend);
                wwwpost.SetRequestHeader("Content-Type", "application/json");
                yield return wwwpost.SendWebRequest();

                if (wwwpost.isNetworkError || wwwpost.isHttpError)
                {
                    signArtist.PrintError(wwwpost.error);
                    signArtist.PrintError(jsonmsg);
                    yield break;
                }
                wwwpost.Dispose();
            }

            private Message DiscordMessage(string servername, string playername, string userid, string itemname, string imgurl, string location)
            {
                string steamprofile = "https://steamcommunity.com/profiles/" + userid;
                var fields = new List<Message.Fields>()
                {
                    new Message.Fields("Player: " + playername, $"[{userid}]({steamprofile})", true),
                    new Message.Fields("Entity", itemname, true),
                    new Message.Fields("Image Url", imgurl, false),
                    new Message.Fields("Teleport position", "teleportpos " + location.Replace(" ", string.Empty), false)
                };
                var footer = new Message.Footer($"Logged @{DateTime.UtcNow:dd/MM/yy HH:mm:ss}");
                var image = new Message.Image(imgurl);
                var embeds = new List<Message.Embeds>()
                {
                    new Message.Embeds("Server - " + servername, "A sign has been updated" , fields, footer, image)
                };
                Message msg = new Message(signArtist.Settings.DiscordUsername, signArtist.Settings.AvatarUrl, embeds);
                return msg;
            }


            /// <summary>
            /// Restores the image and adds it to the sign again.
            /// </summary>
            /// <param name="request">The requested <see cref="RestoreRequest"/> instance. </param>
            /// <returns></returns>
            private IEnumerator RestoreImage(RestoreRequest request)
            {
                // Verify that there is a valid reference to the plugin from this class.
                if (signArtist == null)
                {
                    throw new NullReferenceException("signArtist");
                }

                byte[] imageBytes;

                // Check if the sign already has a texture assigned to it.
                if (request.Sign.TextureId() == 0)
                {
                    // No texture was previously assigned, show a message to the player.
                    signArtist.SendMessage(request.Sender, "RestoreErrorOccurred");
                    StartNextRestore(true);

                    yield break;
                }

                // Cache the byte array of the currently stored file.
                imageBytes = FileStorage.server.Get(request.Sign.TextureId(), FileStorage.Type.png, request.Sign.NetId);
                ImageSize size = GetImageSizeFor(request.Sign);

                // Verify that we have image size data for the targeted sign.
                if (size == null)
                {
                    // No data was found, show a message to the player and print a detailed message to the server console and attempt to start the next download.
                    signArtist.SendMessage(request.Sender, "ErrorOccurred");
                    signArtist.PrintWarning($"Couldn't find the required image size for {request.Sign.PrefabName}, please report this in the plugin's thread.");
                    StartNextRestore(true);

                    yield break;
                }

                // Remove the texture from the FileStorage.
                FileStorage.server.Remove(request.Sign.TextureId(), FileStorage.Type.png, request.Sign.NetId);

                // Get the bytes array for the resized image for the targeted sign.
                byte[] resizedImageBytes = imageBytes.ResizeImage(size.Width, size.Height, size.ImageWidth, size.ImageHeight, signArtist.Settings.EnforceJpeg && !request.Raw);

                // Create the image on the filestorage and send out a network update for the sign.
                request.Sign.SetImage(FileStorage.server.Store(resizedImageBytes, FileStorage.Type.png, request.Sign.NetId));
                request.Sign.SendNetworkUpdate();

                // Notify the player that the image was loaded.
                signArtist.SendMessage(request.Sender, "ImageRestored");

                // Call the Oxide hook 'OnSignUpdated' to notify other plugins of the update event.
                Interface.Oxide.CallHook("OnSignUpdated", request.Sign, request.Sender);

                // Attempt to start the next download.
                StartNextRestore(true);
            }

            /// <summary>
            /// Gets the target image size for a <see cref="Signage"/>.
            /// </summary>
            /// <param name="signage"></param>
            private ImageSize GetImageSizeFor(IPaintableEntity signage)
            {
                if (signArtist.ImageSizePerAsset.ContainsKey(signage.ShortPrefabName))
                {
                    return signArtist.ImageSizePerAsset[signage.ShortPrefabName];
                }

                return null;
            }

            /// <summary>
            /// Converts the <see cref="Texture2D"/> from the webrequest to a <see cref="byte"/> array.
            /// </summary>
            /// <param name="www">The completed webrequest. </param>
            private byte[] GetImageBytes(UnityWebRequest www)
            {
                Texture2D texture = new Texture2D(2, 2);
                texture.LoadImage(www.downloadHandler.data);

                byte[] image;

                if (texture.format == TextureFormat.ARGB32 && !signArtist.Settings.EnforceJpeg)
                {
                    image = texture.EncodeToPNG();
                }
                else
                {
                    image = texture.EncodeToJPG(signArtist.Settings.Quality);
                }

                DestroyImmediate(texture);

                return image;
            }
        }

        #endregion Image Download Behaviour
        private interface IBasePaintableEntity
        {
            BaseEntity Entity { get; }
            string PrefabName { get; }
            string ShortPrefabName { get; }
            uint NetId { get; }
            void SendNetworkUpdate();
        }

        private interface IPaintableEntity : IBasePaintableEntity
        {
            void SetImage(uint id);
            bool CanUpdate(BasePlayer player);
            uint TextureId();
        }

        private class BasePaintableEntity : IBasePaintableEntity
        {
            public BaseEntity Entity { get; }
            public string PrefabName { get; }
            public string ShortPrefabName { get; }
            public uint NetId { get; }

            protected BasePaintableEntity(BaseEntity entity)
            {
                Entity = entity;
                PrefabName = Entity.PrefabName;
                ShortPrefabName = Entity.ShortPrefabName;
                NetId = Entity.net.ID;
            }

            public void SendNetworkUpdate()
            {
                Entity.SendNetworkUpdate();
            }
        }

        private class PaintableSignage : BasePaintableEntity, IPaintableEntity
        {
            public Signage Sign { get; set; }

            public PaintableSignage(Signage sign) : base(sign)
            {
                Sign = sign;
            }

            public void SetImage(uint id)
            {
                Sign.textureIDs = new uint[] { id };
            }

            public bool CanUpdate(BasePlayer player)
            {
                return Sign.CanUpdateSign(player);
            }

            public uint TextureId()
            {
                return Sign.textureIDs.First();
            }
        }

        private class PaintableFrame : BasePaintableEntity, IPaintableEntity
        {
            public PhotoFrame Sign { get; set; }

            public PaintableFrame(PhotoFrame sign) : base(sign)
            {
                Sign = sign;
            }

            public void SetImage(uint id)
            {
                Sign._overlayTextureCrc = id;
            }

            public bool CanUpdate(BasePlayer player)
            {
                return Sign.CanUpdateSign(player);
            }

            public uint TextureId()
            {
                return Sign._overlayTextureCrc;
            }
        }


        #region Init
        /// <summary>
        /// Oxide hook that is triggered when the plugin is loaded.
        /// </summary>
        /// 
        private void Init()
        {
            // Register all the permissions used by the plugin
            permission.RegisterPermission("signartist.file", this);
            permission.RegisterPermission("signartist.ignorecd", this);
            permission.RegisterPermission("signartist.ignoreowner", this);
            permission.RegisterPermission("signartist.raw", this);
            permission.RegisterPermission("signartist.restore", this);
            permission.RegisterPermission("signartist.restoreall", this);
            permission.RegisterPermission("signartist.text", this);
            permission.RegisterPermission("signartist.url", this);

            AddCovalenceCommand("sil", "SilCommand");
            AddCovalenceCommand("silt", "SiltCommand");
            AddCovalenceCommand("sili", "SilItemCommand");
            AddCovalenceCommand("silrestore", "RestoreCommand");

            // Initialize the dictionary with all paintable object assets and their target sizes
            ImageSizePerAsset = new Dictionary<string, ImageSize>
            {
                // Picture Frames
                ["sign.pictureframe.landscape"] = new ImageSize(256, 128), // Landscape Picture Frame
                ["sign.pictureframe.portrait"] = new ImageSize(128, 256),  // Portrait Picture Frame
                ["sign.pictureframe.tall"] = new ImageSize(128, 512),      // Tall Picture Frame
                ["sign.pictureframe.xl"] = new ImageSize(512, 512),        // XL Picture Frame
                ["sign.pictureframe.xxl"] = new ImageSize(1024, 512),      // XXL Picture Frame

                // Wooden Signs
                ["sign.small.wood"] = new ImageSize(128, 64),              // Small Wooden Sign
                ["sign.medium.wood"] = new ImageSize(256, 128),            // Wooden Sign
                ["sign.large.wood"] = new ImageSize(256, 128),             // Large Wooden Sign
                ["sign.huge.wood"] = new ImageSize(512, 128),              // Huge Wooden Sign

                // Banners
                ["sign.hanging.banner.large"] = new ImageSize(64, 256),    // Large Banner Hanging
                ["sign.pole.banner.large"] = new ImageSize(64, 256),       // Large Banner on Pole

                // Hanging Signs
                ["sign.hanging"] = new ImageSize(128, 256),                // Two Sided Hanging Sign
                ["sign.hanging.ornate"] = new ImageSize(256, 128),         // Two Sided Ornate Hanging Sign

                // Town Signs
                ["sign.post.single"] = new ImageSize(128, 64),             // Single Sign Post
                ["sign.post.double"] = new ImageSize(256, 256),            // Double Sign Post
                ["sign.post.town"] = new ImageSize(256, 128),              // One Sided Town Sign Post
                ["sign.post.town.roof"] = new ImageSize(256, 128),         // Two Sided Town Sign Post

                ["photoframe.large"] = new ImageSize(320, 240),
                ["photoframe.portrait"] = new ImageSize(320, 384),
                ["photoframe.landscape"] = new ImageSize(320, 240),


                // Other paintable assets
                ["spinner.wheel.deployed"] = new ImageSize(512, 512, 285, 285), // Spinning Wheel
            };
        }

        private void GetSteamworksImages()
        {
            foreach (InventoryDef item in Steamworks.SteamInventory.Definitions)
            {
                string shortname = item.GetProperty("itemshortname");
                if (item == null || string.IsNullOrEmpty(shortname))
                    continue;

                if (item.Id < 100)
                    continue;

                ulong workshopid;
                if (!ulong.TryParse(item.GetProperty("workshopid"), out workshopid))
                    continue;

                if (string.IsNullOrEmpty(item.IconUrl)) continue;
                SkiniconUrls[workshopid] = item.IconUrl;
            }
        }

        /// <summary>
        /// Oxide hook that is triggered to automatically load the configuration file.
        /// </summary>
        protected override void LoadConfig()
        {
            base.LoadConfig();
            Settings = Config.ReadObject<SignArtistConfig>();
            SaveConfig();
        }

        /// <summary>
        /// Oxide hook that is triggered to automatically load the default configuration file when no file exists.
        /// </summary>
        protected override void LoadDefaultConfig()
        {
            Settings = SignArtistConfig.DefaultConfig();
        }

        /// <summary>
        /// Oxide hook that is triggered to save the configuration file.
        /// </summary>
        protected override void SaveConfig()
        {
            Config.WriteObject(Settings);
        }

        /// <summary>
        /// Oxide hook that is triggered when the server has fully initialized.
        /// </summary>
        private void OnServerInitialized()
        {
            // Create a new GameObject and attach the UnityEngine script to it for handling the image downloads.
            imageDownloaderGameObject = new GameObject("ImageDownloader");
            imageDownloader = imageDownloaderGameObject.AddComponent<ImageDownloader>();
            if ((Steamworks.SteamInventory.Definitions?.Length ?? 0) == 0)
            {
                PrintWarning("Waiting for Steamworks to update item definitions....");
                Steamworks.SteamInventory.OnDefinitionsUpdated += GetSteamworksImages;
            }
            else GetSteamworksImages();
        }

        /// <summary>
        /// Oxide hook that is triggered when the plugin is unloaded.
        /// </summary>
        private void Unload()
        {
            // Destroy the created GameObject and cleanup.
            UnityEngine.Object.Destroy(imageDownloaderGameObject);
            imageDownloader = null;
            cooldowns = null;

            Steamworks.SteamInventory.OnDefinitionsUpdated -= GetSteamworksImages;
        }

        /// <summary>
        /// Handles the /sil command.
        /// </summary>
        /// <param name="iplayer">The player that has executed the command. </param>
        /// <param name="command">The name of the command that was executed. </param>
        /// <param name="args">All arguments that were passed with the command. </param>
        /// 
        #endregion Init

        #region Localization 
        /// <summary>
        /// Oxide hook that is triggered automatically after it has been loaded to initialize the messages for the Lang API.
        /// </summary>
        protected override void LoadDefaultMessages()
        {
            // Register all messages used by the plugin in the Lang API.
            lang.RegisterMessages(new Dictionary<string, string>
            {
                // Messages used throughout the plugin.
                ["WebErrorOccurred"] = "Failed to download the image! Error {0}.",
                ["FileTooLarge"] = "The file exceeds the maximum file size of {0}Mb.",
                ["ErrorOccurred"] = "An unknown error has occured, if this error keeps occuring please notify the server admin.",
                ["RestoreErrorOccurred"] = "Can't restore the sign because no texture is assigned to it.",
                ["DownloadQueued"] = "Your image was added to the download queue!",
                ["RestoreQueued"] = "Your sign was added to the restore queue!",
                ["RestoreBatchQueued"] = "You added all {0} signs to the restore queue!",
                ["ImageLoaded"] = "The image was succesfully loaded to the sign!",
                ["ImageRestored"] = "The image was succesfully restored for the sign!",
                ["LogEntry"] = "Player `{0}` (SteamId: {1}) loaded {2} into {3} from {4}",
                ["NoSignFound"] = "Unable to find a sign! Make sure you are looking at one and that you are not too far away from it.",
                ["Cooldown"] = "You can't use the command yet! Remaining cooldown: {0}.",
                ["SignNotOwned"] = "You can't change this sign as it is protected by a tool cupboard.",
                ["NoItemHeld"] = "You're not holding an item.",
                ["ActionQueuedAlready"] = "An action has already been queued for this sign, please wait for this action to complete.",
                ["SyntaxSilCommand"] = "Syntax error!\nSyntax: /sil <url> [raw]",
                ["SyntaxSiltCommand"] = "Syntax error!\nSyntax: /silt <message> [<fontsize:number>] [<color:hex value>] [<bgcolor:hex value>] [raw]",
                ["NoPermission"] = "You don't have permission to use this command.",
                ["NoPermissionFile"] = "You don't have permission to use images from the server's filesystem.",
                ["NoPermissionRaw"] = "You don't have permission to use raw images, loading normally instead.",
                ["NoPermissionRestoreAll"] = "You don't have permission to use restore all signs at once.",

                // Cooldown formatting 'translations'.
                ["day"] = "day",
                ["days"] = "days",
                ["hour"] = "hour",
                ["hours"] = "hours",
                ["minute"] = "minute",
                ["minutes"] = "minutes",
                ["second"] = "second",
                ["seconds"] = "seconds",
                ["and"] = "and"
            }, this);
        }
        #endregion Localization

        #region Commands
        [Command("sil"), Permission("signartist.url")]
        private void SilCommand(IPlayer iplayer, string command, string[] args)
        {
            var player = iplayer.Object as BasePlayer;
            // Verify if the correct syntax is used.
            if (args.Length < 1)
            {
                // Invalid syntax was used, show an error message to the player.
                SendMessage(player, "SyntaxSilCommand");

                return;
            }

            // Verify if the player has permission to use this command.
            if (!HasPermission(player, "signartist.url"))
            {
                // The player doesn't have permission to use this command, show an error message.
                SendMessage(player, "NoPermission");

                return;
            }

            // Verify that the command isn't on cooldown for the user.
            if (HasCooldown(player))
            {
                // The command is still on cooldown for the player, show an error message.
                SendMessage(player, "Cooldown", FormatCooldown(GetCooldown(player)));

                return;
            }

            // Check if the player is looking at a sign.
            IPaintableEntity sign;
            if (!IsLookingAtSign(player, out sign))
            {
                // The player isn't looking at a sign or is too far away from it, show an error message.
                SendMessage(player, "NoSignFound");

                return;
            }

            // Check if the player is able to update the sign.
            if (!CanChangeSign(player, sign))
            {
                // The player isn't able to update the sign, show an error message.
                SendMessage(player, "SignNotOwned");

                return;
            }

            // Check if the player wants to add the image from the server's filesystem and has the permission to do so.
            if (args[0].StartsWith("file://") && !HasPermission(player, "signartist.file"))
            {
                // The player doesn't have permission for this, show an error message.
                SendMessage(player, "NoPermissionFile");

                return;
            }

            // Check if the player wants to add the image as a raw image and has the permission to do so.
            bool raw = args.Length > 1 && args[1].Equals("raw", StringComparison.OrdinalIgnoreCase);
            if (raw && !HasPermission(player, "signartist.raw"))
            {
                // The player doesn't have permission for this, show a message and disable raw.
                SendMessage(player, "NoPermissionRaw");
                raw = false;
            }

            // This sign pastes in reverse, so we'll check and set a var to flip it
            bool hor = sign.ShortPrefabName == "sign.hanging";

            // Notify the player that it is added to the queue.
            SendMessage(player, "DownloadQueued");

            // Queue the download of the specified image.
            imageDownloader.QueueDownload(args[0], player, sign, raw, hor);

            // Call external hook
            Interface.Oxide.CallHook("OnImagePost", player, args[0]);

            // Set the cooldown on the command for the player if the cooldown setting is enabled.
            SetCooldown(player);
        }

        [Command("sili"), Permission("signartist.url")]
        private void SilItemCommand(IPlayer iplayer, string command, string[] args)
        {
            var player = iplayer.Object as BasePlayer;
            if (!HasPermission(player, "signartist.url"))
            {
                SendMessage(player, "NoPermission");
                return;
            }

            if (HasCooldown(player))
            {
                SendMessage(player, "Cooldown", FormatCooldown(GetCooldown(player)));
                return;
            }

            IPaintableEntity sign;
            if (!IsLookingAtSign(player, out sign))
            {
                SendMessage(player, "NoSignFound");
                return;
            }

            if (!CanChangeSign(player, sign))
            {
                SendMessage(player, "SignNotOwned");
                return;
            }

            Item held = player.GetActiveItem();
            if (held == null)
            {
                SendMessage(player, "NoItemHeld");
                return;
            }

            string shortname = held.info.shortname;

            bool hor = sign.ShortPrefabName == "sign.hanging";

            SendMessage(player, "DownloadQueued");
            bool defaultskin = false;
            if (args.Length == 1 && args[0] == "default") defaultskin = true;
            if (held.skin != 0uL && !defaultskin)
            {
                string url;
                if (SkiniconUrls.TryGetValue(held.skin, out url))
                {
                    shortname = url;
                }
                else
                {
                    ServerMgr.Instance.StartCoroutine(DownloadWorkshopskin(held, sign, hor));
                    return;
                }
            }

            imageDownloader.QueueDownload(shortname, player, sign, false, hor);

            Interface.Oxide.CallHook("OnImagePost", player, shortname);

            SetCooldown(player);
        }

        private const string FindWorkshopSkinUrl = "https://api.steampowered.com/ISteamRemoteStorage/GetPublishedFileDetails/v1/";

        private IEnumerator DownloadWorkshopskin(Item held, IPaintableEntity sign, bool hor)
        {
            BasePlayer player = held.GetOwnerPlayer();
            WWWForm form = new WWWForm();
            form.AddField("itemcount", "1");
            form.AddField("publishedfileids[0]", held.skin.ToString());
            UnityWebRequest www = UnityWebRequest.Post(FindWorkshopSkinUrl, form);
            yield return www.SendWebRequest();
            string url = "";
            // Verify that the webrequest was succesful.
            if (www.isNetworkError || www.isHttpError)
            {
                // The webrequest wasn't succesful, show a message to the player and attempt to start the next download.
                PrintError(www.error.ToString());
                url = held.info.shortname;
            }
            var json = JsonConvert.DeserializeObject<GetPublishedFileDetailsClass>(www.downloadHandler.text);
            url = json.response.publishedfiledetails[0].preview_url;
            imageDownloader.QueueDownload(url, player, sign, false, hor);

            Interface.Oxide.CallHook("OnImagePost", player, held.info.shortname);

            SetCooldown(player);
        }

        /// <summary>
        /// Handles the /silt command
        /// </summary>
        /// <param name="iplayer">The player that has executed the command. </param>
        /// <param name="command">The name of the command that was executed. </param>
        /// <param name="args">All arguments that were passed with the command. </param>
        [Command("silt"), Permission("signartist.text")]
        private void SiltCommand(IPlayer iplayer, string command, string[] args)
        {
            var player = iplayer.Object as BasePlayer;
            // Verify if the correct syntax is used.
            if (args.Length < 1)
            {
                // Invalid syntax was used, show an error message to the player.
                SendMessage(player, "SyntaxSiltCommand");

                return;
            }

            // Verify if the player has permission to use this command.
            if (!HasPermission(player, "signartist.text"))
            {
                // The player doesn't have permission to use this command, show an error message.
                SendMessage(player, "NoPermission");

                return;
            }

            // Verify that the command isn't on cooldown for the user.
            if (HasCooldown(player))
            {
                // The command is still on cooldown for the player, show an error message.
                SendMessage(player, "Cooldown", FormatCooldown(GetCooldown(player)));

                return;
            }

            // Check if the player is looking at a sign.
            IPaintableEntity sign;
            if (!IsLookingAtSign(player, out sign))
            {
                // The player isn't looking at a sign or is too far away from it, show an error message.
                SendMessage(player, "NoSignFound");

                return;
            }

            // Check if the player is able to update the sign.
            if (!CanChangeSign(player, sign))
            {
                // The player isn't able to update the sign, show an error message.
                SendMessage(player, "SignNotOwned");

                return;
            }

            // Build the URL for the /silt command
            string message = args[0].EscapeForUrl();
            int fontsize = 80;
            string color = "000";
            string bgcolor = "0FFF";
            string format = "png32";

            // Replace the default fontsize if the player specified one.
            if (args.Length > 1)
            {
                int.TryParse(args[1], out fontsize);
            }

            // Replace the default color if the player specified one.
            if (args.Length > 2)
            {
                color = args[2].Trim(' ', '#');
            }

            // Replace the default color if the player specified one.
            if (args.Length > 3)
            {
                bgcolor = args[3].Trim(' ', '#');
            }

            // Check if the player wants to add the image as a raw image and has the permission to do so.
            bool raw = args.Length > 4 && args[4].Equals("raw", StringComparison.OrdinalIgnoreCase);
            if (raw && !HasPermission(player, "signartist.raw"))
            {
                // The player doesn't have permission for this, show a message and disable raw.
                SendMessage(player, "NoPermissionRaw");
                raw = false;
            }

            // Correct the format if required
            if (Settings.EnforceJpeg)
            {
                format = "jpg";
            }

            // Get the size for the image
            ImageSize size = null;
            if (ImageSizePerAsset.ContainsKey(sign.ShortPrefabName))
            {
                size = ImageSizePerAsset[sign.ShortPrefabName];
            }

            // Verify that we have image size data for the targeted sign.
            if (size == null)
            {
                // No data was found, show a message to the player and print a detailed message to the server console and attempt to start the next download.
                SendMessage(player, "ErrorOccurred");
                PrintWarning($"Couldn't find the required image size for {sign.PrefabName}, please report this in the plugin's thread.");

                return;
            }

            // Combine all the values into the url;
            string url = $"http://assets.imgix.net/~text?fm={format}&txtalign=middle,center&txtsize={fontsize}&txt={message}&w={size.ImageWidth}&h={size.ImageHeight}&txtclr={color}&bg={bgcolor}";

            // Notify the player that it is added to the queue.
            SendMessage(player, "DownloadQueued");

            // This sign pastes in reverse, so we'll check and set a var to flip it
            bool hor = sign.ShortPrefabName == "sign.hanging";

            // Queue the download of the specified image.
            imageDownloader.QueueDownload(url, player, sign, raw, hor);

            // Call external hook
            Interface.Oxide.CallHook("OnImagePost", player, url);

            // Set the cooldown on the command for the player if the cooldown setting is enabled.
            SetCooldown(player);
        }

        /// <summary>
        /// Handles the /silrestore command
        /// </summary>
        /// <param name="iplayer">The player that has executed the command. </param>
        /// <param name="command">The name of the command that was executed. </param>
        /// <param name="args">All arguments that were passed with the command. </param>
        [Command("silrestore"), Permission("signartist.raw")]
        private void RestoreCommand(IPlayer iplayer, string command, string[] args)
        {
            var player = iplayer.Object as BasePlayer;
            // Verify if the player has permission to use this command.
            if (!HasPermission(player, "signartist.restore"))
            {
                // The player doesn't have permission to use this command, show an error message.
                SendMessage(player, "NoPermission");

                return;
            }

            // Check if the user wants to restore the sign or signs as raw images and has the permission to do so
            bool raw = string.IsNullOrEmpty(args.FirstOrDefault(s => s.Equals("raw", StringComparison.OrdinalIgnoreCase)));
            if (raw && !HasPermission(player, "signartist.raw"))
            {
                // The player doesn't have permission for this, show a message and disable raw.
                SendMessage(player, "NoPermissionRaw");
                raw = false;
            }

            // Check if the user wants to restore all signs and has the permission to do so.
            bool all = args.Any(s => s.Equals("all", StringComparison.OrdinalIgnoreCase));
            if (all && !HasPermission(player, "signartist.restoreall"))
            {
                // The player doesn't have permission for this, show a message and disable raw.
                SendMessage(player, "NoPermissionRestoreAll");

                return;
            }

            // Check if the player is looking at a sign if not all signs should be restored.
            if (!all)
            {
                IPaintableEntity sign;
                if (!IsLookingAtSign(player, out sign))
                {
                    // The player isn't looking at a sign or is too far away from it, show an error message.
                    SendMessage(player, "NoSignFound");

                    return;
                }

                // Notify the player that it is added to the queue.
                SendMessage(player, "RestoreQueued");

                // Queue the restore of the image on the specified sign.
                imageDownloader.QueueRestore(player, sign, raw);

                return;
            }

            // The player wants to restore all signs.
            Signage[] allSigns = UnityEngine.Object.FindObjectsOfType<Signage>();

            // Notify the player that they were added to the queue
            SendMessage(player, "RestoreBatchQueued", allSigns.Length);

            // Queue every sign to be restored.
            foreach (Signage sign in allSigns)
            {
                imageDownloader.QueueRestore(player, new PaintableSignage(sign), raw);
            }
        }

        #endregion Commands

        #region Methods
        /// <summary>
        /// Check if the given <see cref="BasePlayer"/> is able to use the command.
        /// </summary>
        /// <param name="player">The player to check. </param>
        private bool HasCooldown(BasePlayer player)
        {
            // Check if cooldown is enabled.
            if (Settings.Cooldown <= 0)
            {
                return false;
            }

            // Check if cooldown is ignored for the player.
            if (HasPermission(player, "signartist.ignorecd"))
            {
                return false;
            }

            // Make sure there is an entry for the player in the dictionary.
            if (!cooldowns.ContainsKey(player.userID))
            {
                cooldowns.Add(player.userID, 0);
            }

            // Check if the command is on cooldown or not.
            return Time.realtimeSinceStartup - cooldowns[player.userID] < Settings.Cooldown;
        }

        /// <summary>
        /// Returns the cooldown in seconds for the given <see cref="BasePlayer"/>.
        /// </summary>
        /// <param name="player">The player to obtain the cooldown of. </param>
        private float GetCooldown(BasePlayer player)
        {
            return Settings.Cooldown - (Time.realtimeSinceStartup - cooldowns[player.userID]);
        }

        /// <summary>
        /// Sets the last use for the cooldown handling of the command for the given <see cref="BasePlayer"/>.
        /// </summary>
        /// <param name="player">The player to put the command on cooldown for. </param>
        private void SetCooldown(BasePlayer player)
        {
            // Check if cooldown is enabled.
            if (Settings.Cooldown <= 0)
            {
                return;
            }

            // Check if cooldown is ignored for the player.
            if (HasPermission(player, "signartist.ignorecd"))
            {
                return;
            }

            // Make sure there is an entry for the player in the dictionary.
            if (!cooldowns.ContainsKey(player.userID))
            {
                cooldowns.Add(player.userID, 0);
            }

            // Set the last use
            cooldowns[player.userID] = Time.realtimeSinceStartup;
        }

        /// <summary>
        /// Returns a formatted string for the given cooldown.
        /// </summary>
        /// <param name="seconds">The cooldown in seconds. </param>
        private string FormatCooldown(float seconds)
        {
            // Create a new TimeSpan from the remaining cooldown.
            TimeSpan t = TimeSpan.FromSeconds(seconds);
            List<string> output = new List<string>();

            // Check if it is more than a single day and add it to the result.
            if (t.Days >= 1)
            {
                output.Add($"{t.Days} {(t.Days > 1 ? "days" : "day")}");
            }

            // Check if it is more than an hour and add it to the result.
            if (t.Hours >= 1)
            {
                output.Add($"{t.Hours} {(t.Hours > 1 ? "hours" : "hour")}");
            }

            // Check if it is more than a minute and add it to the result.
            if (t.Minutes >= 1)
            {
                output.Add($"{t.Minutes} {(t.Minutes > 1 ? "minutes" : "minute")}");
            }

            // Check if there is more than a second and add it to the result.
            if (t.Seconds >= 1)
            {
                output.Add($"{t.Seconds} {(t.Seconds > 1 ? "seconds" : "second")}");
            }

            // Format the result and return it.
            return output.Count >= 3 ? output.ToSentence().Replace(" and", ", and") : output.ToSentence();
        }

        /// <summary>
        /// Checks if the <see cref="BasePlayer"/> is looking at a valid <see cref="Signage"/> object.
        /// </summary>
        /// <param name="player">The player to check. </param>
        /// <param name="sign">When this method returns, contains the <see cref="Signage"/> the player contained in <paramref name="player" /> is looking at, or null if the player isn't looking at a sign. </param>
        private bool IsLookingAtSign(BasePlayer player, out IPaintableEntity sign)
        {
            RaycastHit hit;
            sign = null;

            // Get the object that is in front of the player within the maximum distance set in the config.
            //if (Physics.Raycast(player.eyes.HeadRay(), out hit))//, Settings.MaxDistance))
            if (Physics.Raycast(player.eyes.HeadRay(), out hit, Settings.MaxDistance))
            {
                // Attempt to grab the Signage entity, if there is none this will set the sign to null,
                // otherwise this will set it to the sign the player is looking at.
                BaseEntity entity = hit.GetEntity();
                if (entity is Signage)
                {
                    sign = new PaintableSignage(entity as Signage);
                }
                else if (entity is PhotoFrame)
                {
                    sign = new PaintableFrame(entity as PhotoFrame);
                }
            }

            // Return true or false depending on if we found a sign.
            return sign != null;
        }

        /// <summary>
        /// Checks if the <see cref="BasePlayer"/> is allowed to change the drawing on the <see cref="Signage"/> object.
        /// </summary>
        /// <param name="player">The player to check. </param>
        /// <param name="sign">The sign to check. </param>
        /// <returns></returns>
        private bool CanChangeSign(BasePlayer player, IPaintableEntity sign)
        {
            return sign.CanUpdate(player) || HasPermission(player, "signartist.ignoreowner");
        }

        /// <summary>
        /// Checks if the given <see cref="BasePlayer"/> has the specified permission.
        /// </summary>
        /// <param name="player">The player to check a permission on. </param>
        /// <param name="perm">The permission to check for. </param>
        private bool HasPermission(BasePlayer player, string perm)
        {
            return permission.UserHasPermission(player.UserIDString, perm);
        }

        /// <summary>
        /// Send a formatted message to a single player.
        /// </summary>
        /// <param name="player">The player to send the message to. </param>
        /// <param name="key">The key of the message from the Lang API to get the message for. </param>
        /// <param name="args">Any amount of arguments to add to the message. </param>
        private void SendMessage(BasePlayer player, string key, params object[] args)
        {
            if (player == null) return;
            player.ChatMessage(string.Format(GetTranslation(key, player), args));
        }

        /// <summary>
        /// Gets the message for a specific player from the Lang API.
        /// </summary>
        /// <param name="key">The key of the message from the Lang API to get the message for. </param>
        /// <param name="player">The player to get the message for. </param>
        /// <returns></returns>
        private string GetTranslation(string key, BasePlayer player = null)
        {
            return lang.GetMessage(key, this, player?.UserIDString);
        }
        #endregion Methods

        #region Steam Workshop API Class

        public class GetPublishedFileDetailsClass
        {
            public Response response { get; set; }
        }

        public class Response
        {
            public int result { get; set; }
            public int resultcount { get; set; }
            public Publishedfiledetail[] publishedfiledetails { get; set; }
        }

        public class Publishedfiledetail
        {
            public string publishedfileid { get; set; }
            public int result { get; set; }
            public string creator { get; set; }
            public int creator_app_id { get; set; }
            public int consumer_app_id { get; set; }
            public string filename { get; set; }
            public int file_size { get; set; }
            public string preview_url { get; set; }
            public string hcontent_preview { get; set; }
            public string title { get; set; }
            public string description { get; set; }
            public int time_created { get; set; }
            public int time_updated { get; set; }
            public int visibility { get; set; }
            public int banned { get; set; }
            public string ban_reason { get; set; }
            public int subscriptions { get; set; }
            public int favorited { get; set; }
            public int lifetime_subscriptions { get; set; }
            public int lifetime_favorited { get; set; }
            public int views { get; set; }
            public Tag[] tags { get; set; }
        }

        public class Tag
        {
            public string tag { get; set; }
        }

        #endregion Steam Workshop API Class

        #region Discord Class
        public class Message
        {
            public string username { get; set; }
            public string avatar_url { get; set; }
            public List<Embeds> embeds { get; set; }

            public class Fields
            {
                public string name { get; set; }
                public string value { get; set; }
                public bool inline { get; set; }
                public Fields(string name, string value, bool inline)
                {
                    this.name = name;
                    this.value = value;
                    this.inline = inline;
                }
            }

            public class Footer
            {
                public string text { get; set; }
                public Footer(string text)
                {
                    this.text = text;
                }
            }

            public class Image
            {
                public string url { get; set; }
                public Image(string url)
                {
                    this.url = url;
                }
            }

            public class Embeds
            {
                public string title { get; set; }
                public string description { get; set; }
                public Image image { get; set; }
                public List<Fields> fields { get; set; }
                public Footer footer { get; set; }
                public Embeds(string title, string description, List<Fields> fields, Footer footer, Image image)
                {
                    this.title = title;
                    this.description = description;
                    this.image = image;
                    this.fields = fields;
                    this.footer = footer;
                }
            }

            public Message(string username, string avatar_url, List<Embeds> embeds)
            {
                this.username = username;
                this.avatar_url = avatar_url;
                this.embeds = embeds;
            }
        }

        #endregion

        #region Public Helpers
        // This can be Call(ed) by other plugins to put text on a sign
        public void API_SignText(BasePlayer player, Signage sign, string message, int fontsize = 30, string color = "FFFFFF", string bgcolor = "000000")
        {
            //Puts($"signText called with {message}");
            string format = "png32";

            ImageSize size = null;
            if (ImageSizePerAsset.ContainsKey(sign.ShortPrefabName))
            {
                size = ImageSizePerAsset[sign.ShortPrefabName];
            }

            // Combine all the values into the url;
            string url = $"http://assets.imgix.net/~text?fm={format}&txtalign=middle,center&txtsize={fontsize}&txt={message}&w={size.ImageWidth}&h={size.ImageHeight}&txtclr={color}&bg={bgcolor}";
            imageDownloader.QueueDownload(url, player, new PaintableSignage(sign), false);
        }

        public void API_SkinSign(BasePlayer player, Signage sign, string url, bool raw = false)
        {
            if (sign == null)
            {
                PrintWarning("Signage is null in API call");
                return;
            }

            if (string.IsNullOrEmpty(url))
            {
                PrintWarning("Url is empty in API call");
                return;
            }

            // This sign pastes in reverse, so we'll check and set a var to flip it
            bool hor = sign.ShortPrefabName == "sign.hanging" ? true : false;

            // Queue the download of the specified image.
            imageDownloader.QueueDownload(url, player, new PaintableSignage(sign), raw, hor);
        }


        //TODO add image byte[] api 
        #endregion

    }

    namespace SignArtistClasses
    {
        /// <summary>
        /// Extension class with extension methods used by the <see cref="SignArtist"/> plugin.
        /// </summary>
        public static class Extensions
        {
            /// <summary>
            /// Resizes an image from the <see cref="byte"/> array to a new image with a specific width and height.
            /// </summary>
            /// <param name="bytes">Source image. </param>
            /// <param name="width">New image canvas width. </param>
            /// <param name="height">New image canvas height. </param>
            /// <param name="targetWidth">New image width. </param>
            /// <param name="targetHeight">New image height. </param>
            /// <param name="enforceJpeg"><see cref="bool"/> value, true to save the images as JPG, false for PNG. </param>
            /// <param name="rotation"></param>
            public static byte[] ResizeImage(this byte[] bytes, int width, int height, int targetWidth, int targetHeight, bool enforceJpeg, RotateFlipType rotation = RotateFlipType.RotateNoneFlipNone)
            {
                byte[] resizedImageBytes;

                using (MemoryStream originalBytesStream = new MemoryStream(), resizedBytesStream = new MemoryStream())
                {
                    // Write the downloaded image bytes array to the memorystream and create a new Bitmap from it.
                    originalBytesStream.Write(bytes, 0, bytes.Length);
                    Bitmap image = new Bitmap(originalBytesStream);

                    if (rotation != RotateFlipType.RotateNoneFlipNone)
                    {
                        image.RotateFlip(rotation);
                    }

                    // Check if the width and height match, if they don't we will have to resize this image.
                    if (image.Width != targetWidth || image.Height != targetHeight)
                    {
                        // Create a new Bitmap with the target size.
                        Bitmap resizedImage = new Bitmap(width, height);

                        // Draw the original image onto the new image and resize it accordingly.
                        using (System.Drawing.Graphics graphics = System.Drawing.Graphics.FromImage(resizedImage))
                        {
                            graphics.DrawImage(image, new Rectangle(0, 0, targetWidth, targetHeight));
                        }

                        TimestampImage(resizedImage);

                        // Save the bitmap to a MemoryStream as either Jpeg or Png.
                        if (enforceJpeg)
                        {
                            resizedImage.Save(resizedBytesStream, ImageFormat.Jpeg);
                        }
                        else
                        {
                            resizedImage.Save(resizedBytesStream, ImageFormat.Png);
                        }

                        // Grab the bytes array from the new image's MemoryStream and dispose of the resized image Bitmap.
                        resizedImageBytes = resizedBytesStream.ToArray();
                        resizedImage.Dispose();
                    }
                    else
                    {
                        TimestampImage(image);
                        // The image has the correct size so we can just return the original bytes without doing any resizing.
                        resizedImageBytes = bytes;
                    }

                    // Dispose of the original image Bitmap.
                    image.Dispose();
                }

                // Return the bytes array.
                return resizedImageBytes;
            }

            /// <summary>
            /// Resize the image to the specified width and height.
            /// </summary>
            /// <param name="image">The image to resize.</param>
            /// <param name="width">The width to resize to.</param>
            /// <param name="height">The height to resize to.</param>
            /// <returns>The resized image.</returns>
            private static Bitmap ResizeImage(Image image, int width, int height)
            {
                Rectangle destRect = new Rectangle(0, 0, width, height);
                Bitmap destImage = new Bitmap(width, height);

                destImage.SetResolution(image.HorizontalResolution, image.VerticalResolution);

                using (Graphics graphics = System.Drawing.Graphics.FromImage(destImage))
                {
                    graphics.CompositingMode = CompositingMode.SourceCopy;
                    graphics.CompositingQuality = CompositingQuality.HighQuality;
                    graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;
                    graphics.SmoothingMode = SmoothingMode.HighQuality;
                    graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;

                    using (ImageAttributes wrapMode = new ImageAttributes())
                    {
                        wrapMode.SetWrapMode(System.Drawing.Drawing2D.WrapMode.TileFlipXY);
                        graphics.DrawImage(image, destRect, 0, 0, image.Width, image.Height, GraphicsUnit.Pixel, wrapMode);
                    }
                }

                return destImage;
            }

            private static void TimestampImage(Bitmap image)
            {
                //Rust images are crc and if we have the same image it is deleted from the file storage
                //Here we changed the last few pixels of the image with colors based off the current milliseconds since wipe
                //This will generate a unique image every time and allow us to use the same image multiple times
                Color pixel = Color.FromArgb(UnityEngine.Random.Range(0, 256), UnityEngine.Random.Range(0, 256), UnityEngine.Random.Range(0, 256), UnityEngine.Random.Range(0, 256));
                image.SetPixel(image.Width - 1, image.Height - 1, pixel);
            }

            private static int GetValueAtIndex(byte[] bytes, int index)
            {

                if (index >= bytes.Length)
                {
                    return 0;
                }

                return Convert.ToInt32(bytes[index]);

            }

            /// <summary>
            /// Converts a string to its escaped representation for the image placeholder text value.
            /// </summary>
            /// <param name="stringToEscape">The string to escape.</param>
            public static string EscapeForUrl(this string stringToEscape)
            {
                // Escape initial values.
                stringToEscape = Uri.EscapeDataString(stringToEscape);

                // Convert \r\n, \r and \n into linebreaks.
                stringToEscape = stringToEscape.Replace("%5Cr%5Cn", "%5Cn").Replace("%5Cr", "%5Cn").Replace("%5Cn", "%0A");

                // Return the converted message
                return stringToEscape;
            }
        }
    }
}


// --- End of file: SignArtist.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/StackSizeController.cs ---
// --- Original Local Path: KualaRust/StackSizeController.cs ---

using System.Collections.Generic;
using System.Linq;
using System;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Stack Size Controller", "Canopy Sheep", "2.0.3", ResourceId = 2320)]
    [Description("Allows you to set the max stack size of every item.")]
    public class StackSizeController : RustPlugin
    {
        #region Data

        private bool pluginLoaded = false;
        Items items;
        class Items
        {
            public Dictionary<string, int> itemlist = new Dictionary<string, int>();
        }

        private bool LoadData()
        {
            var itemsdatafile = Interface.Oxide.DataFileSystem.GetFile("StackSizeController");
            try
            {
                items = itemsdatafile.ReadObject<Items>();
                return true;
            }
            catch (Exception ex)
            {
                PrintWarning("Error: Data file is corrupt. Debug info: " + ex.Message);
                return false;
            }
        }

        private void UpdateItems()
        {
            var gameitemList = ItemManager.itemList;
            List<string> itemCategories = new List<string>();
            int stacksize;

            foreach (var item in gameitemList)
            {
                if (!itemCategories.Contains(item.category.ToString()))
                {
                    if (!(configData.Settings.CategoryDefaultStack.ContainsKey(item.category.ToString())))
                    {
                        configData.Settings.CategoryDefaultStack[item.category.ToString()] = configData.Settings.NewCategoryDefaultSetting;
                        Puts("Added item category: '" + item.category.ToString() + "' to the config.");
                    }
                    itemCategories.Add(item.category.ToString());
                }

                if (!(items.itemlist.ContainsKey(item.displayName.english)))
                {
                    stacksize = DetermineStack(item);
                    items.itemlist.Add(item.displayName.english, stacksize);
                }
            }

            List<string> KeysToRemove = new List<string>();

            foreach (KeyValuePair<string ,int> category in configData.Settings.CategoryDefaultStack)
            {
                if (!itemCategories.Contains(category.Key)) { KeysToRemove.Add(category.Key); }
            }

            if (KeysToRemove.Count > 0)
            {
                Puts("Cleaning config categories...");
                foreach (string Key in KeysToRemove)
                {
                    configData.Settings.CategoryDefaultStack.Remove(Key);
                }
            }

            SaveConfig();

            KeysToRemove = new List<string>();
            bool foundItem = false;

            foreach (KeyValuePair<string, int> item in items.itemlist)
            {
                foreach (var itemingamelist in gameitemList)
                {
                    if (itemingamelist.displayName.english == item.Key)
                    {
                        foundItem = true;
                        break;
                    }
                }
                if (!(foundItem)) { KeysToRemove.Add(item.Key); }
                foundItem = false;
            }

            if (KeysToRemove.Count > 0)
            {
                Puts("Cleaning data file...");
                foreach (string key in KeysToRemove)
                {
                    items.itemlist.Remove(key);
                }
            }

            SaveData();
            LoadStackSizes();
        }

        private int DetermineStack(ItemDefinition item)
        {
            if (item.condition.enabled && item.condition.max > 0 && (!configData.Settings.StackHealthItems))
            {
                return 1;
            }
            else
            {
                if (configData.Settings.DefaultStack != 0 && (!configData.Settings.CategoryDefaultStack.ContainsKey(item.category.ToString())))
                {
                    return configData.Settings.DefaultStack;
                }
                else if (configData.Settings.CategoryDefaultStack.ContainsKey(item.category.ToString()) && configData.Settings.CategoryDefaultStack[item.category.ToString()] != 0)
                {
                    return configData.Settings.CategoryDefaultStack[item.category.ToString()];
                }
                else if (configData.Settings.DefaultStack != 0 && configData.Settings.CategoryDefaultStack[item.category.ToString()] == 0)
                {
                    return configData.Settings.DefaultStack;
                }
                else
                {
                    return item.stackable;
                }
            }
        }

        private void LoadStackSizes()
        {
            var gameitemList = ItemManager.itemList;

            foreach (var item in gameitemList)
            {
                item.stackable = items.itemlist[item.displayName.english];
            }
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("StackSizeController", items);
        }

        #endregion

        #region Config

        ConfigData configData;
        class ConfigData
        {
            public SettingsData Settings { get; set; }
        }

        class SettingsData
        {
            public int DefaultStack { get; set; }
            public int NewCategoryDefaultSetting { get; set; }
            public bool StackHealthItems { get; set; }
            public Dictionary<string, int> CategoryDefaultStack { get; set; }
        }

        private void TryConfig()
        {
            try
            {
                configData = Config.ReadObject<ConfigData>();
            }
            catch (Exception ex)
            {
                PrintWarning("Corrupt config detected, debug: " + ex.Message);
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Generating a new config file...");

            Config.WriteObject(new ConfigData
            {
                Settings = new SettingsData
                {
                    DefaultStack = 0,
                    NewCategoryDefaultSetting = 0,
                    StackHealthItems = true,
                    CategoryDefaultStack = new Dictionary<string, int>()
                    {
                        { "Ammunition", 0 },
                        { "Weapon", 0 },
                    },
                },
            }, true);
        }

        private void SaveConfig()
        {
            Config.WriteObject(configData);
        }
        #endregion

        #region Hooks
        private void OnServerInitialized()
        {
            TryConfig();
            pluginLoaded = LoadData();

            if (pluginLoaded) { UpdateItems(); }
            else { Puts("Stack Sizes could not be changed due to a corrupt data file."); }

            permission.RegisterPermission("stacksizecontroller.canChangeStackSize", this);
        }

        private bool hasPermission(BasePlayer player, string perm)
        {
            if (player.net.connection.authLevel > 1)
            {
                return true;
            }
            return permission.UserHasPermission(player.userID.ToString(), perm);
        }

        #endregion

        #region Commands
        [ChatCommand("stack")]
        private void StackCommand(BasePlayer player, string command, string[] args)
        {
            if (!hasPermission(player, "stacksizecontroller.canChangeStackSize"))
            {
                SendReply(player, "You don't have permission to use this command.");
                return;
            }

            if (!pluginLoaded)
            {
                SendReply(player, "StackSizeController has encountered an error while trying to read the data file. Please contact your server administrator to fix the issue.");
                return;
            }

            if (args.Length < 2)
            {
                SendReply(player, "Syntax Error: Requires 2 arguments. Syntax Example: /stack ammo.rocket.hv 64 (Use shortname)");
                return;
            }

            int stackAmount = 0;

            List<ItemDefinition> gameitems = ItemManager.itemList.FindAll(x => x.shortname.Equals(args[0]));

            if (gameitems.Count == 0)
            {
                SendReply(player, "Syntax Error: That is an incorrect item name. Please use a valid shortname.");
                return;
            }

            string replymessage = "";
            switch (args[1].ToLower())
            {
                case "default":
                {
                    stackAmount = DetermineStack(gameitems[0]);
                    replymessage = "Updated Stack Size for " + gameitems[0].displayName.english + " (" + gameitems[0].shortname + ") to " + stackAmount + " (Default value based on config).";
                    break;
                }
                default:
                {
                    if (int.TryParse(args[1], out stackAmount) == false)
                    {
                        SendReply(player, "Syntax Error: Stack Amount is not a number. Syntax Example: /stack ammo.rocket.hv 64 (Use shortname)");
                        return;
                    }
                    replymessage = "Updated Stack Size for " + gameitems[0].displayName.english + " (" + gameitems[0].shortname + ") to " + stackAmount + ".";
                    break;
                }
            }

            if (gameitems[0].condition.enabled && gameitems[0].condition.max > 0)
            {
                if (!(configData.Settings.StackHealthItems))
                {
                    SendReply(player, "Error: Stacking health items is disabled in the config.");
                    return;
                }
            }

            items.itemlist[gameitems[0].displayName.english] = Convert.ToInt32(stackAmount);
                
            gameitems[0].stackable = Convert.ToInt32(stackAmount);

            SaveData();

            SendReply(player, replymessage);
        }

        [ChatCommand("stackall")]
        private void StackAllCommand(BasePlayer player, string command, string[] args)
        {
            if (!hasPermission(player, "stacksizecontroller.canChangeStackSize"))
            {
                SendReply(player, "You don't have permission to use this command.");
                return;
            }

            if (!pluginLoaded)
            {
                SendReply(player, "StackSizeController has encountered an error while trying to read the data file. Please contact your server administrator to fix the issue.");
                return;
            }

            if (args.Length < 1)
            {
                SendReply(player, "Syntax Error: Requires 1 argument. Syntax Example: /stackall 65000");
                return;
            }

            int stackAmount = 0;
            string replymessage = "";

            var itemList = ItemManager.itemList;

            foreach (var gameitem in itemList)
            {
                switch (args[0].ToLower())
                {
                    case "default":
                    {
                        stackAmount = DetermineStack(gameitem);
                        replymessage = "The Stack Size of all stackable items has been set to their default values (specified in config).";
                        break;
                    }
                    default:
                    {
                        if (int.TryParse(args[0], out stackAmount) == false)
                        {
                            SendReply(player, "Syntax Error: Stack Amount is not a number. Syntax Example: /stackall 65000");
                            return;
                        }
                        replymessage = "The Stack Size of all stackable items has been set to " + stackAmount.ToString() + ".";
                        break;
                    }
                }

                if (gameitem.condition.enabled && gameitem.condition.max > 0 && !(configData.Settings.StackHealthItems)) { continue; }
                if (gameitem.displayName.english.ToString() == "Salt Water" || gameitem.displayName.english.ToString() == "Water") { continue; }

                items.itemlist[gameitem.displayName.english] = Convert.ToInt32(stackAmount);
                gameitem.stackable = Convert.ToInt32(stackAmount);
            }

            SaveData();

            SendReply(player, replymessage);
        }

        [ConsoleCommand("stack")]
        private void StackConsoleCommand(ConsoleSystem.Arg arg)
        {
            if (arg.IsAdmin != true) 
            {
                if ((arg.Connection.userid.ToString() != null) && !(permission.UserHasPermission(arg.Connection.userid.ToString(), "stacksizecontroller.canChangeStackSize")))
                {
                    arg.ReplyWith("[StackSizeController] You don't have permission to use this command.");
                    return;
                }
            }

            if (!pluginLoaded)
            {
                arg.ReplyWith("[StackSizeController] StackSizeController has encountered an error while trying to read the data file. Please contact your server administrator to fix the issue.");
                return;
            }

            if (arg.Args != null)
            {
                if (arg.Args.Length < 2)
                {
                    arg.ReplyWith("[StackSizeController] Syntax Error: Requires 2 arguments. Syntax Example: stack ammo.rocket.hv 64 (Use shortname)");
                    return;
                }
            }
            else
            {
                arg.ReplyWith("[StackSizeController] Syntax Error: Requires 2 arguments. Syntax Example: stack ammo.rocket.hv 64 (Use shortname)");
                return;
            }

            int stackAmount = 0;
            List<ItemDefinition> gameitems = ItemManager.itemList.FindAll(x => x.shortname.Equals(arg.Args[0]));

            if (gameitems.Count == 0)
            {
                arg.ReplyWith("[StackSizeController] Syntax Error: That is an incorrect item name. Please use a valid shortname.");
                return;
            }

            string replymessage = "";
            switch (arg.Args[1].ToLower())
            {
                case "default":
                {
                    stackAmount = DetermineStack(gameitems[0]);
                    replymessage = "[StackSizeController] Updated Stack Size for " + gameitems[0].displayName.english + " (" + gameitems[0].shortname + ") to " + stackAmount + " (Default value based on config).";
                    break;
                }
                default:
                {
                    if (int.TryParse(arg.Args[1], out stackAmount) == false)
                    {
                        arg.ReplyWith("[StackSizeController] Syntax Error: Stack Amount is not a number. Syntax Example: /stack ammo.rocket.hv 64 (Use shortname)");
                        return;
                    }
                    replymessage = "[StackSizeController] Updated Stack Size for " + gameitems[0].displayName.english + " (" + gameitems[0].shortname + ") to " + stackAmount + ".";
                    break;
                }
            }

            if (gameitems[0].condition.enabled && gameitems[0].condition.max > 0)
            {
                if (!(configData.Settings.StackHealthItems))
                {
                    arg.ReplyWith("[StackSizeController] Error: Stacking health items is disabled in the config.");
                    return;
                }
            }

            items.itemlist[gameitems[0].displayName.english] = Convert.ToInt32(stackAmount);

            gameitems[0].stackable = Convert.ToInt32(stackAmount);

            SaveData();

            arg.ReplyWith(replymessage);
        }

        [ConsoleCommand("stackall")]
        private void StackAllConsoleCommand(ConsoleSystem.Arg arg)
        {
            if (arg.IsAdmin != true)
            {
                if ((arg.Connection.userid.ToString() != null) && !(permission.UserHasPermission(arg.Connection.userid.ToString(), "stacksizecontroller.canChangeStackSize")))
                {
                    arg.ReplyWith("[StackSizeController] You don't have permission to use this command.");
                    return;
                }
            }

            if (!pluginLoaded)
            {
                arg.ReplyWith("[StackSizeController] StackSizeController has encountered an error while trying to read the data file. Please contact your server administrator to fix the issue.");
                return;
      