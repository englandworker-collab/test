      }

            if (arg.Args != null)
            {
                if (arg.Args.Length < 1)
                {
                    arg.ReplyWith("[StackSizeController] Syntax Error: Requires 1 argument. Syntax Example: stackall 65000");
                    return;
                }
            }
            else
            {
                arg.ReplyWith("[StackSizeController] Syntax Error: Requires 1 argument. Syntax Example: stackall 65000");
                return;
            }

            int stackAmount = 0;
            string replymessage = "";

            var itemList = ItemManager.itemList;

            foreach (var gameitem in itemList)
            {
                if (gameitem.condition.enabled && gameitem.condition.max > 0 && (!(configData.Settings.StackHealthItems))) { continue; }
                if (gameitem.displayName.english.ToString() == "Salt Water" ||
                gameitem.displayName.english.ToString() == "Water") { continue; }

                switch (arg.Args[0].ToLower())
                {
                    case "default":
                    {
                        stackAmount = DetermineStack(gameitem);
                        replymessage = "[StackSizeController] The Stack Size of all stackable items has been set to their default values (specified in config).";
                        break;
                    }
                    default:
                    {
                        if (int.TryParse(arg.Args[0], out stackAmount) == false)
                        {
                            arg.ReplyWith("[StackSizeController] Syntax Error: Stack Amount is not a number. Syntax Example: /stackall 65000");
                            return;
                        }
                        replymessage = "[StackSizeController] The Stack Size of all stackable items has been set to " + stackAmount.ToString() + ".";
                        break;
                    }
                }

                items.itemlist[gameitem.displayName.english] = Convert.ToInt32(stackAmount);
                gameitem.stackable = Convert.ToInt32(stackAmount);
            }

            SaveData();

            arg.ReplyWith(replymessage);
        }
        #endregion
    }
}

// --- End of file: StackSizeController.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/StashBlocker.cs ---
// --- Original Local Path: KualaRust/StashBlocker.cs ---

﻿using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Stash Blocker", "Orange", "1.0.0")]
    [Description("Controls stashes placement")]
    public class StashBlocker : RustPlugin
    {
        #region Oxide Hooks

        private void Init()
        {
            lang.RegisterMessages(EN, this);
        }

        private object CanBuild(Planner planner, Construction prefab, Construction.Target target)
        {
            return CheckBuild(planner, prefab, target);
        }

        #endregion

        #region Configuration

        private static ConfigData config;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "1. Block placing stashes (globally)")]
            public bool global;

            [JsonProperty(PropertyName = "2. Radius of allowed distance between stashes and any entities (set to 0 to disable)")]
            public float entities;
        }

        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                global = false,
                entities = 5f
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();
            }
            catch
            {
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintError("Configuration file is corrupt(or not exists), creating new one!");
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion

        #region Language

        private Dictionary<string, string> EN = new Dictionary<string, string>
        {
            {"Global", "Stashes placing is blocked!"},
            {"Near Stashes", "You can't place entities near stashes!"},
            {"Near Entities", "You can't place stashes near buildings!"}
        };

        private void message(BasePlayer player, string key, params object[] args)
        {
            var message = string.Format(lang.GetMessage(key, this, player.UserIDString), args);
            player.ChatMessage(message);
        }

        #endregion

        #region Core

        private object CheckBuild(Planner planner, Construction prefab, Construction.Target target)
        {
            var player = planner.GetOwnerPlayer();
            if (player == null)
            {
                return null;
            }

            var name = prefab.fullName;
            var position = target.entity?.transform.position ?? target.position;
            var check = config.entities > 0.001f;
            
            if (IsStash(name))
            {
                if (config.global)
                {
                    message(player, "Global");
                    return false;
                }
                
                if (check && HasBuildingsNearby(position))
                {
                    message(player, "Near Entities");
                    return false;
                }
            }
            
            if (check && HasStashesNearby(position))
            {
                message(player, "Near Stashes");
                return false;
            }

            return null;
        }

        private bool IsStash(string name)
        {
            return name.ToLower().Contains("stash");
        }

        private bool HasStashesNearby(Vector3 position)
        {
            var list = new List<StashContainer>();
            Vis.Entities(position, config.entities, list);
            return list.Count > 0;
        }

        private bool HasBuildingsNearby(Vector3 position)
        {
            var list = new List<BuildingBlock>();
            Vis.Entities(position, 5f, list);
            return list.Count > 0;
        }

        #endregion
    }
}

// --- End of file: StashBlocker.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/ZetaDeathAnoncer.cs ---
// --- Original Local Path: KualaRust/ZetaDeathAnoncer.cs ---

﻿using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using UnityEngine;
using Random = UnityEngine.Random;
using System.Text.RegularExpressions;
using System;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("ZetaDeathAnoncer", "fermens", "0.1.71")]
    [Description("ОТОБРАЖЕНИЕ УБИЙСТВ СПРАВА СВЕРХУ, КОПИЯ С МАГИК РАСТ")]
    public class ZetaDeathAnoncer : RustPlugin
    {
        #region Grid
        Dictionary<string, Vector3> Grids = new Dictionary<string, Vector3>();
        const float calgon = 0.0066666666666667f;
        void CreateSpawnGrid()
        {
            var worldSize = (ConVar.Server.worldsize);
            float offset = worldSize / 2;
            var gridWidth = (calgon * worldSize);
            float step = worldSize / gridWidth;

            string start = "";

            char letter = 'A';
            int number = 0;

            for (float zz = offset; zz > -offset; zz -= step)
            {
                for (float xx = -offset; xx < offset; xx += step)
                {
                    Grids.Add($"{start}{letter}{number}", new Vector3(xx - 55f, 0, zz));
                    if (letter.ToString().ToUpper() == "Z")
                    {
                        start = "A";
                        letter = 'A';
                    }
                    else
                    {
                        letter = (char)(((int)letter) + 1);
                    }


                }
                number++;
                start = "";
                letter = 'A';
            }
        }

        private string GetNameGrid(Vector3 pos)
        {
            return Grids.Where(x => x.Value.x < pos.x && x.Value.x + 150f > pos.x && x.Value.z > pos.z && x.Value.z - 150f < pos.z).FirstOrDefault().Key;
        }
        #endregion

        #region Oxide Hooks

        private void Unload()
        {
            foreach (var z in killsList) CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = Network.Net.sv.connections }, null, "DestroyUI", z.guid);
        }

        void OnServerInitialized()
        {
            if (!config.truename) SaveConfig();
            if (config.animal == null || config.animal.translatekill == null)
            {
                config.mes[TA.Animal] = "убил";
                config.mes[TA.AnimalKill] = "убил";
                config.animal = new animal
                {
                    animalkillplayers = true,
                    killanimals = false,
                    translatekill = new Dictionary<string, string>
                        {
                            { "wolf", "Волк" },
                            { "bear", "Медведь" },
                            { "boar", "Кабан" },
                            { "chicken", "Курица" },
                            { "horse", "Лошадь" },
                            { "stag", "Олень" },
                            { "testridablehorse", "Лошадь" }
                        },
                    translatedeath = new Dictionary<string, string>
                        {
                            { "wolf", "Волка" },
                            { "bear", "Медведя" },
                            { "boar", "Кабана" },
                            { "chicken", "Курицу" },
                            { "horse", "Лошадь" },
                            { "stag", "Оленя" },
                            { "testridablehorse", "Лошадь" }
                        }
                };
                SaveConfig();
            }
            if (config.wound)
            {
                Unsubscribe("OnPlayerRecover");
                Unsubscribe("OnPlayerRecovered");
                Unsubscribe("CanBeWounded");
            }
            if (config.names == null)
            {
                config.names = new Dictionary<TA, string>
                    {
                        { TA.Death, "Ученый [NPC]" },
                        { TA.HeliKill, "Вертолет [NPC]" },
                        { TA.TankKill, "Танк [NPC]" },
                        { TA.Heli, "Вертолет [NPC]" },
                        { TA.Tank, "Танк [NPC]" }
                    };
                config.mes.Add(TA.Heli, "подбил");
                config.mes.Add(TA.Tank, "взорвал");
                config.mes.Add(TA.HeliKill, "убил");
                config.mes.Add(TA.TankKill, "поджарил");
                config.format4 = "<color=COL2>{0}</color> {1} <color=COL1>{2}</color> (квадрат {3})";
                config.format5 = "<color=COL2>{0}</color> {1} <color=COL1>{2}</color>";
                SaveConfig();
            }
            CreateSpawnGrid();
            Guijson = "[{\"name\":\"{guid}\",\"parent\":\"Hud\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{text}\",\"fontSize\":\"{size}\",\"fadeIn\":\"{fade}\",\"align\":\"UpperRight\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.7\",\"distance\":\"0.6 0.6\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 1\",\"anchormax\":\"1 1\",\"offsetmin\":\"-400 {min}\",\"offsetmax\":\"-5 {max}\"}],\"fadeOut\":\"0.1\"}]".Replace("{size}", config.textSize.ToString());
        }
        string Guijson = "";
        [PluginReference] Plugin Battles, HaxBot;
        private bool IsNPC(BasePlayer player)
        {
            if (player is NPCPlayer) return true;
            if (!(player.userID >= 76560000000000000L || player.userID <= 0L)) return true;
            return false;
        }

        Dictionary<uint, ulong> helilast = new Dictionary<uint, ulong>();
        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null || info == null) return;
            if (entity is BaseHelicopter && info.Initiator is BasePlayer)
            {
                BasePlayer player = info.InitiatorPlayer;
                if (player == null) return;
                helilast[entity.net.ID] = player.userID;
            }
        }

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null || info == null) return;
            if (entity is BaseHelicopter)
            {
                uint id = entity.net.ID;
                if (!helilast.ContainsKey(id)) return;
                BasePlayer player = BasePlayer.FindByID(helilast[id]);
                if (player == null) return;
                add(entity, TA.Heli, player, GetNameGrid(entity.transform.position));
                helilast.Remove(id);
            }
            else if (info.Initiator is BasePlayer)
            {
                if (entity is BradleyAPC) add(entity, TA.Tank, info.InitiatorPlayer, GetNameGrid(entity.transform.position));
                else if (config.animal.killanimals && (entity is BaseAnimalNPC || entity is RidableHorse))
                {
                    add(entity, TA.Animal, info.InitiatorPlayer, info.WeaponPrefab?.ShortPrefabName ?? info.damageTypes.GetMajorityDamageType().ToString(), (int)Vector3.Distance(info.InitiatorPlayer.transform.position, entity.transform.position));
                }
            }
        }

        private void OnPlayerDeath(BasePlayer victim, HitInfo info)
        {
            if (victim == null || info == null || Battles != null && (bool)Battles.Call("IsPlayerOnBattle", victim.userID)) return;
            if (info.Initiator is BasePlayer)
            {
                var attacker = info.InitiatorPlayer;
                if (attacker == null) return;
                if (!config.npc && (IsNPC(victim) || IsNPC(attacker))) return;
                if (attacker == victim && info.damageTypes.GetMajorityDamageType() == Rust.DamageType.Suicide)
                {
                    if (config.suicide) add(victim, TA.Suicide);
                    return;
                }
                add(victim, victim.IsSleeping() ? TA.Sleep : TA.Death, attacker, info.WeaponPrefab?.ShortPrefabName ?? info.damageTypes.GetMajorityDamageType().ToString(), (int)Vector3.Distance(attacker.transform.position, victim.transform.position));
            }
            else if (info.Initiator is BaseHelicopter)
            {
                add(victim, TA.HeliKill, (BaseHelicopter)info.Initiator);
            }
            else if (info.Initiator is BradleyAPC)
            {
                add(victim, TA.TankKill, (BradleyAPC)info.Initiator);
            }
            else if (config.animal.animalkillplayers && (info.Initiator is BaseAnimalNPC || info.Initiator is RidableHorse))
            {
                add(victim, TA.AnimalKill, (BaseCombatEntity)info.Initiator);
            }
        }

        object OnPlayerRecover(BasePlayer player)
        {
            if (IsNPC(player) || Battles != null && (bool)Battles.Call("IsPlayerOnBattle", player.userID)) return null;
            add(player, TA.Up);
            return null;
        }

        void OnPlayerRecovered(BasePlayer player)
        {
            if (IsNPC(player) || Battles != null && (bool)Battles.Call("IsPlayerOnBattle", player.userID)) return;
            add(player, TA.Up);
        }

        void CanBeWounded(BasePlayer victim, HitInfo info)
        {
            if (victim == null) return;
            var attacker = info?.InitiatorPlayer;
            if (attacker == null) return;
            if (!config.npc && (IsNPC(victim) || IsNPC(attacker))) return;
            NextTick(() =>
            {
                if (!victim.IsWounded() || Battles != null && (bool)Battles.Call("IsPlayerOnBattle", victim.userID)) return;
                add(victim, TA.Wound, attacker, info.WeaponPrefab?.ShortPrefabName ?? info.damageTypes.GetMajorityDamageType().ToString(), (int)Vector3.Distance(attacker.transform.position, victim.transform.position));
            });
        }

        #endregion

        #region Config
        private PluginConfig config;
        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        class animal
        {
            [JsonProperty(PropertyName = "Отображать убийства животных?")]
            public bool killanimals;

            [JsonProperty(PropertyName = "Отображать смерти игроков от животных?")]
            public bool animalkillplayers;

            [JsonProperty(PropertyName = "Перевод - для смерти")]
            public Dictionary<string, string> translatedeath;

            [JsonProperty(PropertyName = "Перевод - для убийства")]
            public Dictionary<string, string> translatekill;
        }

        private class PluginConfig
        {
            [JsonProperty(PropertyName = "Животные")]
            public animal animal;

            [JsonProperty(PropertyName = "Длительность показа убийства")]
            public float timeout;

            [JsonProperty(PropertyName = "Максимальное отображаемое кол-во убийств")]
            public int kills;

            [JsonProperty(PropertyName = "Отступ")]
            public int nim;

            [JsonProperty(PropertyName = "Формат - с оружием и расстоянием")]
            public string format1;

            [JsonProperty(PropertyName = "Формат - с оружием, когда расстояние меньше 1 м.")]
            public string format2;

            [JsonProperty(PropertyName = "Формат - для суицидов и др.")]
            public string format3;

            [JsonProperty(PropertyName = "Формат - для сбитого вертолета и танка.")]
            public string format4;

            [JsonProperty(PropertyName = "Формат - для вертолета и танка.")]
            public string format5;

            [JsonProperty(PropertyName = "Размер текста")]
            public int textSize;

            [JsonProperty(PropertyName = "Не отображать когда нокнули и когда поднялся")]
            public bool wound;

            [JsonProperty(PropertyName = "Отображать суициды")]
            public bool suicide;

            [JsonProperty(PropertyName = "Максимальная длина ника")]
            public int maxNameChars;

            [JsonProperty(PropertyName = "Верхняя точка по оси Y (от 0 до минус бесконечность)")]
            public int start;

            [JsonProperty(PropertyName = "Отображать убийства/смерти от NPC")]
            public bool npc;

            [JsonProperty(PropertyName = "Цвет себя")]
            public string color1;

            [JsonProperty(PropertyName = "Цвет друга")]
            public string color2;

            [JsonProperty(PropertyName = "Отображать настоящие ники ботов")]
            public bool truename;

            [JsonProperty(PropertyName = "Цвет других")]
            public string color3;

            [JsonProperty(PropertyName = "Вырезки")]
            public Dictionary<TA, string> mes;

            [JsonProperty(PropertyName = "Названия")]
            public Dictionary<TA, string> names;

            [JsonProperty(PropertyName = "Перевод")]
            public Dictionary<string, string> custom;

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    animal = new animal
                    {
                        animalkillplayers = true,
                        killanimals = false,
                        translatekill = new Dictionary<string, string>
                        {
                            { "wolf", "Волк" },
                            { "bear", "Медведь" },
                            { "boar", "Кабан" },
                            { "chicken", "Курица" },
                            { "horse", "Лошадь" },
                            { "stag", "Олень" },
                            { "testridablehorse", "Лошадь" }
                        },
                        translatedeath = new Dictionary<string, string>
                        {
                            { "wolf", "Волка" },
                            { "bear", "Медведя" },
                            { "boar", "Кабана" },
                            { "chicken", "Курицу" },
                            { "horse", "Лошадь" },
                            { "stag", "Оленя" },
                            { "testridablehorse", "Лошадь" }
                        }
                    },
                    timeout = 7f,
                    kills = 7,
                    npc = true,
                    textSize = 14,
                    maxNameChars = 14,
                    start = -10,
                    nim = 20,
                    format1 = "<color=COL2>{0}</color> {1} <color=COL1>{2}</color> ({3}, {4} м.)",
                    format2 = "<color=COL2>{0}</color> {1} <color=COL1>{2}</color> ({3})",
                    format3 = "<color=COL1>{0}</color> {1}",
                    format4 = "<color=COL2>{0}</color> {1} <color=COL1>{2}</color> (квадрат {3})",
                    format5 = "<color=COL2>{0}</color> {1} <color=COL1>{2}</color>",
                    color1 = "#ffd479",
                    color3 = "#3399ff",
                    color2 = "#ccff99",
                    custom = new Dictionary<string, string>
                    {
                        { "40mm_grenade_he", "Гранатомёт" },
                        {"mp5.entity", "MP5A4" },
                        { "crossbow.entity", "Арбалет" },
                        { "bolt_rifle.entity", "Болт" },
                        { "compound_bow.entity", "Блочный лук" },
                        { "nailgun.entity", "Гвоздомёт" },
                        { "pitchfork.entity", "Вилы" },
                        { "shotgun_pump.entity", "Помповый дробовик" },
                        { "pistol_semiauto.entity", "P250" },
                        { "semi_auto_rifle.entity", "Берданка" },
                        { "m39.entity", "Винтовка M39" },
                        { "l96.entity", "Винтовка L96" },
                        { "thompson.entity", "Томсон" },
                        { "knife.combat.entity", "Боевой нож" },
                        { "grenade.beancan.deployed", "Бобовка" },
                        { "spas12.entity", "Дробовик Spas-12" },
                        { "grenade.f1.deployed", "Граната F1" },
                        { "longsword.entity", "Длинный меч" },
                        { "double_shotgun.entity", "Двухствольный дробовик" },
                        { "mace.entity", "Булава" },
                        { "spear_wooden.entity", "Деревянное копье" },
                        { "rock.entity", "Камень" },
                        { "torch.entity", "Факел" },
                        { "knife_bone.entity", "Костяная дубинка" },
                        { "bone_club.entity", "Костяной нож" },
                        { "candy_cane.entity", "Леденец-дубинка" },
                        { "flamethrower.entity", "Огнемёт" },
                        { "m249.entity", "Пулемёт M249" },
                        { "bow_hunting.entity", "Охотничий лук" },
                        { "ak47u.entity", "AK-47" },
                        { "salvaged_cleaver.entity", "Самодельный тесак" },
                        { "snowball.entity", "Снежок" },
                        { "pistol_revolver.entity", "Револьвер" },
                        { "python.entity", "Питон" },
                        { "rocket_basic", "Ракетница" },
                        { "pistol_eoka.entity", "Самодельный пистолет" },
                        { "salvaged_sword.entity", "Самодельный меч" },
                        { "shotgun_waterpipe.entity", "Самодельный дробовик" },
                        { "spear_stone.entity", "Каменное копье" },
                        { "lr300.entity", "LR-300" },
                        { "butcherknife.entity", "Нож мясника" },
                        { "machete.weapon", "Мачете" },
                        { "explosive.timed.deployed", "С4" },
                        { "stone_pickaxe.entity", "Каменная кирка" },
                        { "stonehatchet.entity", "Каменный топор" },
                        { "pickaxe.entity", "Кирка" },
                        { "m92.entity", "Беретта" },
                        { "survey_charge.deployed", "Геологический заряд" },
                        { "chainsaw.entity", "Бензопила" },
                        { "jackhammer.entity", "Отбойный молоток" },
                        { "icepick_salvaged.entity", "Самодельный ледоруб" },
                        { "hammer_salvaged.entity", "Самодельный молот" },
                        { "hatchet.entity", "Топор" },
                        { "axe_salvaged.entity", "Самодельный топор" },
                        { "flashlight.entity", "Фонарик" },
                        { "cake.entity", "Торт" },
                        { "explosive.satchel.deployed", "Сумка с зарядом" },
                        { "smg.entity", "SMG" }
                    },
                    mes = new Dictionary<TA, string>
                    {
                        { TA.Death, "убил" },
                        { TA.Animal, "убил" },
                        { TA.AnimalKill, "убил" },
                        { TA.Wound, "нокнул" },
                        { TA.Up, "каким то чудом сам поднялся" },
                        { TA.Suicide, "совершил самоубийство" },
                        { TA.Sleep, "убил спящего" },
                        { TA.Heli, "подбил" },
                        { TA.Tank, "взорвал" },
                        { TA.HeliKill, "убил" },
                        { TA.TankKill, "поджарил" },
                    },
                    names = new Dictionary<TA, string>
                    {
                        { TA.Death, "Ученый [NPC]" },
                        { TA.HeliKill, "Вертолет [NPC]" },
                        { TA.TankKill, "Танк [NPC]" },
                        { TA.Heli, "Вертолет [NPC]" },
                        { TA.Tank, "Танк [NPC]" }
                    },
                    suicide = true
                };
            }
        }
        #endregion

        Dictionary<ulong, Anoncer> ttt = new Dictionary<ulong, Anoncer>();
        class Anoncer
        {
            public bool wound;
            public Timer ttimer;
            public float pos;
        }

        enum TA
        {
            Death, Wound, Sleep, Suicide, Up, Heli, Tank, HeliKill, TankKill, Animal, AnimalKill
        }
        class infoA
        {
            public bool npcA;
            public string guid;
            public TA what;
            public string message;
            public ulong victim;
            public ulong attacker;
            public List<ulong> friendsV = new List<ulong>();
            public List<ulong> friendsA = new List<ulong>();
        }
        private List<infoA> killsList = new List<infoA>();
        #region Core
        private void add(BaseCombatEntity victim, TA what, BaseCombatEntity attacker = null, string weapon = null, int distance = 0)
        {
            string startfade = "0.5", victimname = "";
            infoA newinfoA = new infoA();
            newinfoA.guid = Random.Range(0, 99999).ToString();
            newinfoA.what = what;

            if (victim is BasePlayer)
            {
                BasePlayer VICTIM = (BasePlayer)victim;
                if (IsNPC(VICTIM))
                {
                    if (!config.truename) victimname = config.names[TA.Death];
                    else victimname = VICTIM.displayName /*+ " (бот)"*/;
                }
                else
                {
                    if (VICTIM.Team != null && VICTIM.Team.members.Count > 1) newinfoA.friendsV.AddRange(VICTIM.Team.members.Where(x => x != VICTIM.userID));
                    victimname = VICTIM.displayName;
                    if (victimname.Length > config.maxNameChars) victimname = victimname.Substring(0, config.maxNameChars);
                }
                newinfoA.victim = VICTIM.userID;
            }
            else if (what == TA.Tank)
            {
                victimname = config.names[TA.Tank];
                newinfoA.victim = victim.net.ID;
            }
            else if (what == TA.Heli)
            {
                victimname = config.names[TA.Heli];
                newinfoA.victim = victim.net.ID;
            }
            else if (what == TA.Animal)
            {
                string animal;
                if (!config.animal.translatedeath.TryGetValue(victim.ShortPrefabName, out animal))
                {
                    Debug.Log($"Добавьте перевод для животного - {victim.ShortPrefabName}");
                    animal = victim.ShortPrefabName;
                }
                victimname = animal;
                newinfoA.victim = victim.net.ID;
            }
            else return;

            if (attacker != null)
            {
                string attackername = "";
                if (attacker is BasePlayer)
                {
                    BasePlayer ATTACKER = (BasePlayer)attacker;
                    if (IsNPC(ATTACKER))
                    {
                        if (!config.truename) attackername = config.names[TA.Death];
                        else attackername = ATTACKER.displayName/* + " (бот)"*/;
                    }
                    else
                    {
                        if (ATTACKER.Team != null && ATTACKER.Team.members.Count > 1) newinfoA.friendsA.AddRange(ATTACKER.Team.members.Where(x => x != ATTACKER.userID));
                        attackername = ATTACKER.displayName;
                        if (attackername.Length > config.maxNameChars) attackername = attackername.Substring(0, config.maxNameChars);
                    }
                    newinfoA.attacker = ATTACKER.userID;
                }
                else if (what == TA.TankKill)
                {
                    attackername = config.names[TA.TankKill];
                    newinfoA.attacker = attacker.net.ID;
                }
                else if (what == TA.HeliKill)
                {
                    attackername = config.names[TA.HeliKill];
                    newinfoA.attacker = attacker.net.ID;
                }
                else if (what == TA.AnimalKill)
                {
                    string animal;
                    if (!config.animal.translatekill.TryGetValue(attacker.ShortPrefabName, out animal))
                    {
                        Debug.Log($"Добавьте перевод для животного - {attacker.ShortPrefabName}");
                        animal = attacker.ShortPrefabName;
                    }
                    attackername = animal;
                    newinfoA.attacker = attacker.net.ID;
                }
                else return;
                //what.Equals(TA.Animal)
                if (what.Equals(TA.Tank) || what.Equals(TA.Heli)) newinfoA.message = string.Format(config.format4, attackername, config.mes[what], victimname, weapon);
                else if (what.Equals(TA.TankKill) || what.Equals(TA.HeliKill) || what.Equals(TA.AnimalKill)) newinfoA.message = string.Format(config.format5, attackername, config.mes[what], victimname);
                else if (distance > 1) newinfoA.message = string.Format(config.format1, attackername, config.mes[what], victimname, GetName(weapon), distance);
                else newinfoA.message = string.Format(config.format2, attackername, config.mes[what], victimname, GetName(weapon));
            }
            else newinfoA.message = string.Format(config.format3, victimname, config.mes[what]);
            HaxBot?.Call("SENDTODISCORD", $"[{DateTime.Now.ToShortTimeString()}] {STRIP(newinfoA.message)}", 1);
            killsList.Add(newinfoA);
            if (killsList.Count >= config.kills) destroying(killsList[0]);
            if (what.Equals(TA.Death))
            {
                infoA woun = killsList.Where(x => x.victim.Equals(newinfoA.victim) && x.what.Equals(TA.Wound)).FirstOrDefault();
                if (woun != null)
                {
                    destroying(woun);
                    startfade = "0";
                }
            }

            string falde = startfade;
            int start = config.start;
            foreach (var log in killsList.AsEnumerable().Reverse())
            {
                string send = Guijson.Replace("{guid}", log.guid).Replace("{fade}", falde).Replace("{max}", start.ToString()).Replace("{min}", (start - config.nim).ToString());
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = Network.Net.sv.connections }, null, "DestroyUI", log.guid);
                List<Network.Connection> sendto = new List<Network.Connection>(Network.Net.sv.connections);
                foreach (var z in Network.Net.sv.connections)
                {
                    if (log.victim.Equals(z.userid))
                    {
                        CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = z }, null, "AddUI", send.Replace("{text}", log.message.Replace("COL1", config.color1).Replace("COL2", log.friendsV.Contains(z.userid) ? config.color2 : config.color3)));
                        sendto.Remove(z);
                    }
                    else if (log.attacker.Equals(z.userid))
                    {
                        CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = z }, null, "AddUI", send.Replace("{text}", log.message.Replace("COL1", log.friendsA.Contains(z.userid) ? config.color2 : config.color3).Replace("COL2", config.color1)));
                        sendto.Remove(z);
                    }
                    else if (log.friendsA.Contains(z.userid))
                    {
                        CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = z }, null, "AddUI", send.Replace("{text}", log.message.Replace("COL1", log.friendsA.Contains(log.victim) ? config.color2 : config.color3).Replace("COL2", config.color2)));
                        sendto.Remove(z);
                    }
                    else if (log.friendsV.Contains(z.userid))
                    {
                        CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = z }, null, "AddUI", send.Replace("{text}", log.message.Replace("COL1", config.color2).Replace("COL2", log.friendsV.Contains(log.attacker) ? config.color2 : config.color3)));
                        sendto.Remove(z);
                    }
                }
                if (sendto.Count > 0)
                {
                    send = send.Replace("{text}", log.message.Replace("COL1", config.color3).Replace("COL2", config.color3));
                    CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "AddUI", send);
                }
                falde = "0";
                start -= config.nim;
            }
            timerYA.Add(newinfoA.guid, timer.Once(config.timeout, () => destroying(newinfoA)));
        }

        void destroying(infoA newinfoA)
        {
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = Network.Net.sv.connections }, null, "DestroyUI", newinfoA.guid);
            killsList.Remove(newinfoA);
            timerYA[newinfoA.guid]?.Destroy();
            timerYA.Remove(newinfoA.guid);
        }
        Dictionary<string, Timer> timerYA = new Dictionary<string, Timer>();
        private string GetName(string name)
        {
            if (config.custom.ContainsKey(name)) return config.custom[name];
            config.custom.Add(name, name);
            SaveConfig();
            return name;
        }

        #endregion

        private readonly List<string> _tags = new List<string>
        {
            "</color>",
            "`",
            "</size>",
            "<i>",
            "</i>",
            "<b>",
            "</b>"
        };

        private readonly List<Regex> _regexTags = new List<Regex>
        {
            new Regex("<color=.+?>", RegexOptions.Compiled),
            new Regex("<size=.+?>", RegexOptions.Compiled)
        };

        private string STRIP(string original)
        {
            if (string.IsNullOrEmpty(original))
            {
                return string.Empty;
            }

            foreach (string tag in _tags)
            {
                original = original.Replace(tag, "");
            }

            foreach (Regex regexTag in _regexTags)
            {
                original = regexTag.Replace(original, "");
            }

            return original;
        }
    }
}

// --- End of file: ZetaDeathAnoncer.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/SkinCases.cs ---
// --- Original Local Path: KualaRust/SkinCases.cs ---

﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using WebSocketSharp;

namespace Oxide.Plugins
{
    [Info("SkinCases", "https://topplugin.ru/", "0.0.82")]
    public class SkinCases : RustPlugin
    { 
        #region Classes
        
        private class Rarity 
        {
            [JsonProperty("Шанс выпадения предмета данной редкости")]
            public int Chance;
            [JsonProperty("Цвет этой редкости в интерфейсе")]
            public string Color;

            public Rarity(int chance, string color)
            {
                Chance = chance;
                Color  = color;
            }
        }

        private class Configuration
        {
            public class Cases
            {
                [JsonProperty("Список доступных для открытия кейсов")]
                public List<Case> CaseLits = new List<Case>();
            }

            public class Chances
            {
                [JsonProperty("Настройка реального шанса выпадения")]
                public List<Rarity> Rarities = new List<Rarity>();
                [JsonProperty("Настройка визуального шанса выпадения")]
                public List<Rarity> FakeRarities = new List<Rarity>();
            }

            public class Drops
            {
                public class Drop
                {
                    [JsonProperty("Список выпадающих кейсов (название -> кол-во)")]
                    public Dictionary<string, int> DropCases = new Dictionary<string, int>(); 
                    [JsonProperty("Интервал получения выбранных кейсов в секундах реального времени")]
                    public int Interval;

                    [JsonProperty("Название привилегии, игроки с которой будут получать наборы")]
                    public string Permission;

                    [JsonProperty("Лимит кол-ва не открытых кейсов этого типа для выдачи бесплатного")]
                    public int MaxCaseAmount;
                    [JsonProperty("Время следующего выпадения (не меняйте, и следите чтобы не было равно 0)")]
                    public double NextDropTime; 
                }

                [JsonProperty("Список выпадающих предметов")] 
                public List<Drop> DropList = new List<Drop>();
            }

            public class Others
            {
                [JsonProperty("Разрешить открывать несколько кейсов сразу (если да, визуальное наслаивание интерфейсов, но не критично)")]
                public bool AllowOpenFewCase = false;
            }

            [JsonProperty("Настройки кейсов")] 
            public Cases CaseSettings;
            [JsonProperty("Настройки шансов выпадения предметов")]
            public Chances ChancesSettings;
            [JsonProperty("Настройки автоматической выдачи кейсов")]
            public Drops DropSettrings;
            [JsonProperty("Остальные настройки плагина")]
            public Others OtherSettings;
            

            public static Configuration Generate()
            {
                return new Configuration
                {
                    CaseSettings = new Cases
                    {
                        CaseLits = new List<Case>
                        {
                            new Case("Бесплатный кейс", new List<CaseItem>
                            {
                                new CaseItem("wood",            2000, 4000, 0),
                                new CaseItem("stones",          2000, 4000, 0),
                                new CaseItem("leather",         500,  1000, 0),
                                new CaseItem("cloth",           500,  1000, 0),
                                new CaseItem("lowgradefuel",    150,  500,  1),
                                new CaseItem("metal.fragments", 1000, 2000, 1),
                                new CaseItem("metal.refined",   50,   150,  1),
                                new CaseItem("sulfur",          500,  2000, 2),
                                new CaseItem("gunpowder",       500,  1000, 2),
                                new CaseItem("explosive.timed", 2,    4,    3),
                            }, "https://i.imgur.com/ZMHNQEd.png"),
                            new Case("Компонентный кейс", new List<CaseItem>
                            {
                                new CaseItem("metalblade",  30, 40, 0),
                                new CaseItem("sewingkit",   20, 30, 0),
                                new CaseItem("roadsigns",   10, 15, 0),
                                new CaseItem("metalpipe",   10, 20, 0),
                                new CaseItem("gears",       15, 25, 1),
                                new CaseItem("smgbody",     2,  8,  1),
                                new CaseItem("metalspring", 15, 25, 1),
                                new CaseItem("semibody",    1,  6,  2),
                                new CaseItem("techparts",   10, 15, 2),
                                new CaseItem("riflebody",   10, 15, 3),
                            }, "https://i.imgur.com/2jfUOa8.png"),
                            new Case("Ресурсный кейс", new List<CaseItem>
                            {
                                new CaseItem("wood",            10000, 20000, 0),
                                new CaseItem("stones",          10000, 20000, 0),
                                new CaseItem("leather",         1000,  1500,  0),
                                new CaseItem("cloth",           500,   1000,  0),
                                new CaseItem("lowgradefuel",    450,   900,   1),
                                new CaseItem("metal.fragments", 10000, 15000, 1),
                                new CaseItem("metal.refined",   400,   800,   1),
                                new CaseItem("sulfur",          3000,  6000,  2),
                                new CaseItem("gunpowder",       1500,  3000,  2),
                                new CaseItem("explosive.timed", 5,     10,    3),
                            }, "https://i.imgur.com/S2el4AY.png"),
                            new Case("Оружейный кейс", new List<CaseItem>
                            {
                                new CaseItem("pistol.semiauto", 1, 1, 0),
                                new CaseItem("pistol.python",   1, 1, 0),
                                new CaseItem("pistol.m92",      1, 1, 1),
                                new CaseItem("smg.2",           1, 1, 1),
                                new CaseItem("rifle.m39",       1, 1, 1),
                                new CaseItem("smg.thompson",    1, 1, 2),
                                new CaseItem("rifle.semiauto",  1, 1, 2),
                                new CaseItem("rifle.lr300",     1, 1, 2),
                                new CaseItem("rifle.bolt",      1, 1, 3),
                                new CaseItem("rifle.ak",        1, 1, 3),
                            }, "https://i.imgur.com/Eobztbd.png"),
                            new Case("Пуся кейс", new List<CaseItem>
                            {
                                new CaseItem("explosive.timed",      2,    10,   3),
                                new CaseItem("ammo.rocket.basic",    4,    12,   3),
                                new CaseItem("lmg.m249",             1,    1,    3),
                                new CaseItem("gunpowder",            2000, 8000, 3),
                                new CaseItem("rifle.l96",            1,    1,    3),
                                new CaseItem("supply.signal",        3,    6,    3),
                                new CaseItem("explosive.satchel",    10,   25,   3),
                                new CaseItem("ammo.rifle.explosive", 100,  500,  3),
                                new CaseItem("grenade.f1",           2,    5,    3, 1630356878),
                                new CaseItem("fuse",                 1,    1,    3, 1627796062),
                            }, "https://i.imgur.com/48tLKlE.png"),
                            new Case("Взрывной кейс", new List<CaseItem>
                            {
                                new CaseItem("grenade.beancan",      1,    1,    0),
                                new CaseItem("explosive.timed",      4,    10,   3),
                                new CaseItem("ammo.rocket.basic",    2,    12,   3),
                                new CaseItem("lmg.m249",             1,    1,    1),
                                new CaseItem("gunpowder",            2000, 8000, 2),
                                new CaseItem("rifle.l96",            1,    1,    1),
                                new CaseItem("supply.signal",        3,    6,    1),
                                new CaseItem("explosive.satchel",    10,   25,   2),
                                new CaseItem("ammo.rifle.explosive", 300,  1000, 3),
                                new CaseItem("grenade.f1",           2,    8,    3, 1630356878),
                            }, "https://i.imgur.com/Dhmb1Ss.png"),
                        }
                    },
                    ChancesSettings = new Chances
                    {
                        Rarities = new List<Rarity>
                        {
                            new Rarity(35, "#FFFFFF0F"),
                            new Rarity(30, "#ADDFFF0F"),
                            new Rarity(25, "#C4A6FF0F"), 
                            new Rarity(5,  "#FFAE2B0F"),
                        },
                        FakeRarities = new List<Rarity>
                        {
                            new Rarity(15, "#FFFFFF0F"),
                            new Rarity(30, "#ADDFFF0F"),
                            new Rarity(30, "#C4A6FF0F"),
                            new Rarity(10, "#FFAE2B0F"),
                        }
                    },
                    DropSettrings = new Drops
                    {
                        DropList = new List<Drops.Drop>
                        {
                            new Drops.Drop
                            {
                                Permission = "skincases.default",
                                DropCases = new Dictionary<string, int>
                                {
                                    ["Бесплатный кейс"] = 3
                                },
                                Interval = 30,
                                MaxCaseAmount = 30
                            },
                            new Drops.Drop
                            {
                                Permission = "skincases.vip",
                                DropCases = new Dictionary<string, int>
                                {
                                    ["Взрывной кейс"] = 1
                                },
                                Interval      = 50,
                                MaxCaseAmount = 30
                            },
                        }
                    },
                    OtherSettings = new Others()
                };
            }
        }
        
        private class Case
        {
            [JsonProperty("Отображаемое название кейса")]
            public string DisplayName;
            [JsonProperty("Ссылка на изображение кейса")]
            public string ImageURL;
            
            [JsonProperty("Предметы получаемые при выпадении")]
            public List<CaseItem> Items = new List<CaseItem>();

            public Case(string displayName, List<CaseItem> caseItems, string url)
            {
                DisplayName = displayName;
                ImageURL = url;

                Items = caseItems;
            }

            public CaseItem GetFinishItem(bool fake = false)
            { 
                var usedInRowRarities = CaseHandler.ChancesSettings.FakeRarities.Select((i, t) => new {A = i, B = t}).Where(c => Items.Any(i => c.B == i.RarityType)).ToList();
                if (!fake)
                    usedInRowRarities = CaseHandler.ChancesSettings.Rarities.Select((i, t) => new {A = i, B = t}).Where(c => Items.Any(i => c.B == i.RarityType)).ToList();


                int totalRes = usedInRowRarities.Sum(p => p.A.Chance);
                int currentRes = Core.Random.Range(0, totalRes);

                int currentTry = 0;
                foreach (var check in usedInRowRarities.OrderBy(p => p.A.Chance))
                {
                    if (check.A.Chance + currentTry >= currentRes)
                    {
                        var item = Items.Where(p => p.RarityType == check.B).ToList().GetRandom();
                        return item;
                    }
                
                    currentTry += check.A.Chance;
                }

                return null;
            }

            public List<CaseItem> GetRandomLine()
            {
                List<CaseItem> skinLine = new List<CaseItem>();
                for (int i = 0; i < Oxide.Core.Random.Range(107, 108); i++)
                {
                    skinLine.Add(GetFinishItem(true));
                }

                var really = GetFinishItem(); 
                skinLine.Add(really);
                for (int i = 0; i < 3; i++)
                {
                    skinLine.Add(GetFinishItem(true));
                }

                return skinLine;
            }
        }
        
        private class InventoryItem
        {
            [JsonProperty("Короткое название предмета")]
            public string ShortName;
            [JsonProperty("ID скина для предмета")]
            public ulong SkinID;
            [JsonProperty("Количество предметов")]
            public int Amount;
            
            [JsonProperty("Дополнительная команда")]
            public string Command;
            [JsonProperty("Ссылка на изображение")]
            public string PictureURL;

            public Item CreateItem(BasePlayer player)
            {
                if (!string.IsNullOrEmpty(Command)) _.Server.Command(Command.Replace("%STEAMID%", player.UserIDString));
                if (!string.IsNullOrEmpty(ShortName))
                {
                    Item item = ItemManager.CreateByPartialName(ShortName, Amount);
                    item.skin = SkinID;

                    return item;
                }

                return null;
            }

            public static InventoryItem Generate(CaseItem caseItem)
            {
                return new InventoryItem
                {
                    ShortName  = caseItem.ShortName,
                    SkinID     = caseItem.SkinID,
                    Amount     = caseItem.GetRandomAmount(),
                    Command    = caseItem.Command,
                    PictureURL = caseItem.PictureURL
                };
            }
        }
        
        private class CaseItem : InventoryItem
        {
            [JsonProperty("Тип редкости для предмета")]
            public int RarityType = 0;
            
            [JsonProperty("Минимальное количество при выпадени")]
            public int MinimalAmount = 0;
            [JsonProperty("Максимальное количество при выпадении")]
            public int MaximumAmount = 0;
            
            public int GetRandomAmount() => Core.Random.Range(MinimalAmount, MaximumAmount);

            public CaseItem(string shortname, int minAmount, int maxAmount, int rarityType, ulong skinId = 0, string url = "", string command = "")
            {
                ShortName     = shortname;
                SkinID        = skinId;
                MinimalAmount = minAmount;
                MaximumAmount = maxAmount;
                RarityType    = rarityType;
                PictureURL    = url == "" ? null : url;
                Command       = command;
            }
        }    
        
        private class PlayerInventory
        {
            [JsonProperty("Доступные кейсы для открытия")]
            public Dictionary<string, int> Cases = new Dictionary<string, int>();
            [JsonProperty("Полученные вещи из кейсов")]
            public List<InventoryItem> Inventory = new List<InventoryItem>();

            [JsonProperty("История действия с кейсами")]
            public List<string> LogHistory = new List<string>();
            [JsonProperty("История ошибочных действий с кейсами")]
            public List<string> ErrorHistory = new List<string>();
        }
        
        #endregion
        
        #region Variables

        private static SkinCases _;
        private static Configuration CaseHandler = Configuration.Generate();
        private Hash<ulong, PlayerInventory> PlayerInventories = new Hash<ulong, PlayerInventory>();
        
        #endregion

        #region Initialization
        
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                CaseHandler = Config.ReadObject<Configuration>();
                if (CaseHandler.OtherSettings == null) CaseHandler.OtherSettings = new Configuration.Others();
                if (CaseHandler.ChancesSettings == null) CaseHandler.ChancesSettings = new Configuration.Chances();
                if (CaseHandler.CaseSettings == null) CaseHandler.CaseSettings = new Configuration.Cases();
                if (CaseHandler.DropSettrings == null) CaseHandler.DropSettrings = new Configuration.Drops();   
            }
            catch
            {
                PrintWarning($"Failed to read configuration [oxide/configs/{Name}]!");
                PrintWarning($"Check it with JSON Validator!");
                //LoadDefaultConfig();
                return;
            }
            
            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => CaseHandler = Configuration.Generate();
        protected override void SaveConfig()        => Config.WriteObject(CaseHandler);

        private void OnServerInitialized()
        { 
            try { webrequest.Enqueue($"http://api.hougan.space/grab/{Name}/{Version}/{141}", "", (i, s) => {}, this); } catch (NullReferenceException) { }
            
            _ = this; 
            BasePlayer.activePlayerList.ToList().ForEach(OnPlayerConnected);

            CaseHandler.DropSettrings.DropList.ForEach(p => { permission.RegisterPermission(p.Permission, this); });
            ServerMgr.Instance.StartCoroutine(GiveCases()); 
                
            CaseHandler.CaseSettings.CaseLits.ForEach(c =>
            {
                ImageLibrary.Call("AddImage", c.ImageURL, GetNameFromURI(c.ImageURL));
                c.Items.ForEach(i =>
                {
                    if (!i.ShortName.IsNullOrEmpty())
                    {
                        ImageLibrary.Call("AddImage", $"http://api.hougan.space/rust/item/getImage/{i.ShortName}/128", i.ShortName + 128, i.SkinID);
                    } 
                    if (i.SkinID != 0)
                    {
                        ImageLibrary.Call("AddImage", $"http://api.hougan.space/rust/skin/getImage/{i.SkinID}.png", i.ShortName, i.SkinID);
                    }

                    if (!i.PictureURL.IsNullOrEmpty())
                    {
                        ImageLibrary.Call("AddImage", i.PictureURL, GetNameFromURI(i.PictureURL)); 
                    }
                });
            });
            
            timer.Every(60, () => { BasePlayer.activePlayerList.ToList().ForEach(GiveAutoCases); }).Callback();
            timer.Every(60, () => { BasePlayer.activePlayerList.ToList().ForEach(SaveData); }).Callback();
        }
        
        private void OnPlayerConnected(BasePlayer player)
        {
            LoadData(player);
        }
        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            SaveData(player);
        }
        
        private void Unload()
        {
            ServerMgr.Instance.StopAllCoroutines();
            foreach (var check in PlayerInventories)
            {
                SaveData(check.Key);
            }
        }

        #endregion

        #region Interface

        [ConsoleCommand("UI_SkinCases")]
        private void CmdChatHandler(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            ValidatePlayer(player);
            
            if (player != null && args.HasArgs(1))
            {
                if (args.Args[0] == "open")
                {
                    int caseId = -1;
                    if (!int.TryParse(args.Args[1], out caseId))
                    {
                        ErrorHistory(player, $"Попытка открытия кейса с неправильным ID: '{args.Args[1]}'");
                        return;
                    }
                    
                    var cCase = CaseHandler.CaseSettings.CaseLits.ElementAt(caseId);
                    if (cCase != null) 
                    {
                        if (!HasCase(player, cCase))
                        {
                            ErrorHistory(player, $"Попытка открытия кейса '{cCase.DisplayName}', которого нету в инвентаре у игрока");
                            return;
                        }
                        
                        LogHistory(player, $"Начало открытие кейса '{cCase.DisplayName}'!");
                        RemoveCase(player, cCase);
                        
                        CuiHelper.DestroyUi(player, Layer + ".Btn");
                        CuiHelper.DestroyUi(player, Layer + ".Btn1");
                        CuiElementContainer container = new CuiElementContainer();
                        
                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = "0.5 0.52", AnchorMax = "0.5 0.52", OffsetMin = "-150 -20", OffsetMax = "150 20" },
                            Button = { Color = "1 1 1 0.03" },
                            Text = { Text = $"ПОДОЖДИТЕ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 20 }
                        }, Layer, Layer + ".Btn");

                        if (!CaseHandler.OtherSettings.AllowOpenFewCase)
                        {
                            container.Add(new CuiPanel
                            {
                                RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0"},
                                Image         = {Color     = "0 0 0 0"}
                            }, "Overlay", Layer + ".Overlay");
                        }
                        
                        ServerMgr.Instance.StartCoroutine(DrawLine(player, cCase.GetRandomLine(), cCase, true));
                        CuiHelper.AddUi(player, container);
                    }
                    else
                    {
                        ErrorHistory(player, $"Попытка открытия несуществующего кейса: '{caseId}'");
                    }
                }

                if (args.Args[0] == "shop")
                {
                    LogHistory(player, "Игрок открывает список своих кейсов");
                    UI_DrawCaseInventory(player);
                }

                if (args.Args[0] == "shoppage")
                {
                    LogHistory(player, "Игрок открывает список своих кейсов");
                    UI_DrawCaseInventory(player, args.HasArgs(2) ? int.Parse(args.Args[1]) : 0);
                }

                if (args.Args[0] == "show")
                {
                    int caseId = -1;
                    if (!int.TryParse(args.Args[1], out caseId))
                    {
                        ErrorHistory(player, $"Попытка просмотра кейса с неправильным ID: '{args.Args[1]}'");
                        return;
                    }
                    
                    var cCase = CaseHandler.CaseSettings.CaseLits.ElementAt(caseId);
                    if (cCase != null)
                    {
                        LogHistory(player, $"Игрок просматривает кейс '{cCase.DisplayName}'");
                        if (!HasCase(player, cCase))
                            ErrorHistory(player, $"У игрока отсутствует просматриваемый кейс");
                        
                        UI_DrawCase(player, cCase);
                    }
                }

                if (args.Args[0] == "invpage")
                {
                    LogHistory(player, "Игрок открывает список своих предметов");
                    UI_DrawInventory(player, args.HasArgs(2) ? int.Parse(args.Args[1]) : 0);
                }

                if (args.Args[0] == "inv")
                {
                    LogHistory(player, $"---------------------");
                    LogHistory(player, "Игрок просматривает свои полученные предметы:");
                    foreach (var check in PlayerInventories[player.userID].Inventory)
                    {
                        LogHistory(player, $" - {check.ShortName} -> {check.Amount}x");
                    }
                    LogHistory(player, $"---------------------");
                    
                    UI_DrawInventory(player);
                }
                if (args.Args[0] == "take")
                {
                    int itemId = -1;
                    if (!int.TryParse(args.Args[1], out itemId))
                    {
                        ErrorHistory(player, $"Попытка взять предмет с неправильным порядковым номером: '{args.Args[1]}'");
                        return;
                    }
                    
                    var item = PlayerInventories[player.userID].Inventory.ElementAt(itemId);
                    if (item != null)
                    {
                        if (item.ShortName != "")
                        {
                            if (player.inventory.containerMain.itemList.Count >= 24)
                            {
                                ErrorHistory(player, $"Попытка забрать предмет {item.ShortName} x{item.Amount}, у игрока нету места!");
                                player.ChatMessage($"У вас <color=#4286f4>недостаточно</color> места в основном инвентаре!");
                                return;
                            }
                         
                            LogHistory(player, $"Игрок забрал предмет: {item.ShortName} x{item.Amount}");
                        }
                        
                        if (item.ShortName != "")
                            player.ChatMessage($"Вы <color=#4286f4>успешно</color> забрали {ItemManager.FindItemDefinition(item.ShortName).displayName.english} x{item.Amount}");
                        else
                            player.ChatMessage($"Вы <color=#4286f4>успешно</color> забрали предмет!");
                        
                        item.CreateItem(player)?.MoveToContainer(player.inventory.containerMain);
                        PlayerInventories[player.userID].Inventory.Remove(item);
                        
                        UI_DrawInventory(player);
                    }
                    else
                    {
                        ErrorHistory(player, $"Попытка забрать предмет под несуществующем номером: '{itemId}'");
                    }
                }
            }
               
        }

        private IEnumerator DrawLine(BasePlayer player, List<CaseItem> skinList, Case cCase, bool really = false)
        {
            List<CaseItem> localList = new List<CaseItem>();
            
            for (int z = 0; z < skinList.Count - 5; z++)
            {
                localList = skinList.Skip(z).Take(5).ToList();
                
                CuiElementContainer container = new CuiElementContainer();
                foreach (var check in localList.Select((i, t) => new {A = i, B = t}))
                {
                    try
                    {
                        CuiHelper.DestroyUi(player, Layer + $".Prize.{check.B}.Img");
                        CuiHelper.DestroyUi(player, Layer + $".Prize.{check.B}");

                        var kitMargin = 0.08f;
                        container.Add(new CuiButton
                        {
                            RectTransform =
                            {
                                AnchorMin = $"{0.3375914184 + check.B * kitMargin} 0.7",
                                AnchorMax = $"{0.3375914184 + check.B * kitMargin} 0.7",
                                OffsetMin = "-50 -50", OffsetMax = "50 50",
                            },
                            Button = {Color = HexToRustFormat(CaseHandler.ChancesSettings.Rarities.ElementAtOrDefault(check.A.RarityType).Color.Remove(6, 2) + 23)},
                            Text = {Text = ""}
                        }, Layer, Layer + $".Prize.{check.B}");

                        string img = !check.A.PictureURL.IsNullOrEmpty() ? GetNameFromURI(check.A.PictureURL) : check.A.ShortName;
                        string imageName = check.A.SkinID == 0 && check.A.PictureURL.IsNullOrEmpty() ? check.A.ShortName + 128 : img; 
                        
                        container.Add(new CuiElement 
                        {
                            Parent = Layer + $".Prize.{check.B}",
                            Name = Layer + $".Prize.{check.B}.Img",
                            Components =
                            { 
                                new CuiRawImageComponent {Png = (string) ImageLibrary.Call("GetImage", imageName, check.A.SkinID), Color = "1 1 1 1"},
                                new CuiRectTransformComponent
                                    {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5"}
                            }
                        });
                    }
                    catch (NullReferenceException e)
                    {
                        PrintWarning(e.StackTrace);
                    }
                } 
                CuiHelper.AddUi(player, container);
                container.Clear();
                
                Effect x = new Effect("assets/bundled/prefabs/fx/notice/stack.world.fx.prefab", player, 0, new Vector3(), new Vector3());
                EffectNetwork.Send(x, player.Connection);

                float delay = (float) (((float) Math.Pow(1.3, z - 50) / 502500) + (float) z * 0.001);
                yield return new WaitForSeconds(delay); 
            }
            
            CuiHelper.DestroyUi(player, Layer + ".Btn");
            CuiElementContainer newCont = new CuiElementContainer();
            int caseIndex = CaseHandler.CaseSettings.CaseLits.IndexOf(cCase);

            if (!really)
            {
                string openCase = HasCase(player, cCase) ? "ОТКРЫТЬ КЕЙС" : "У ВАС НЕТУ КЕЙСА";
                
                newCont.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.5 0.52", AnchorMax = "0.5 0.52", OffsetMin = "-150 -20", OffsetMax = "150 20" },
                    Button = { Color = "1 1 1 0.03", Command = HasCase(player, cCase) ? $"UI_SkinCases open {caseIndex}" : ""},
                    Text = { Text = openCase, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 20 }
                }, Layer, Layer + ".Btn");
            }
            else
            {
                CuiHelper.DestroyUi(player, Layer + ".Overlay");
                Effect x = new Effect("assets/prefabs/deployable/vendingmachine/effects/vending-machine-purchase-human.prefab", player, 0, new Vector3(), new Vector3());
                EffectNetwork.Send(x, player.Connection);
                
                string openCase = HasCase(player, cCase) ? "ОТКРЫТЬ КЕЙС" : "ВЫБЕРИТЕ КЕЙС";
                
                newCont.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.5 0.52", AnchorMax = "0.5 0.52", OffsetMin = "-200 -20", OffsetMax = "-5 20" },
                    Button = { Color = "1 1 1 0.03", Command = $"UI_SkinCases show {caseIndex}" },
                    Text = { Text = "ПРИНЯТЬ НАГРАДУ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 20 }
                }, Layer, Layer + ".Btn");
                newCont.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.5 0.52", AnchorMax = "0.5 0.52", OffsetMin = "5 -20", OffsetMax = "200 20" },
                    Button = { Color = "1 1 1 0.03", Command = HasCase(player, cCase) ? $"UI_SkinCases open {caseIndex}" : "UI_SkinCases shop"},
                    Text = { Text = openCase, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 20 }
                }, Layer, Layer + ".Btn1");
 
                var caseItem = localList.ElementAt(2);
                var addedItem = AddItem(player, caseItem);
                if (caseItem.RarityType == 3 && localList.ElementAt(1).RarityType != 3)
                {
                    Server.Broadcast($"Игрок <color=#4286f4>{player.displayName}</color> получил <color=#f4c242>легендарный</color> предмет!\n" +
                                     $"Испытай удачу: <color=#4286f4>/case</color>");
                }
                
				if (!string.IsNullOrEmpty(addedItem.ShortName))
					LogHistory(player, $"Получен предмет {addedItem.ShortName} [{addedItem.Amount}x] из кейса {cCase.DisplayName}");
                else if (!string.IsNullOrEmpty(addedItem.Command))
				    LogHistory(player, $"Получен предмет {addedItem.Command} из кейса {cCase.DisplayName}");
            }

            CuiHelper.AddUi(player, newCont);
        }

        private void UI_DrawCaseInventory(BasePlayer player, int page = 0)
        {
            CuiHelper.DestroyUi(player, Layer);
            CuiElementContainer container = new CuiElementContainer();
            
            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.8", }
            }, "Overlay", Layer);
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Close = Layer },
                Text = { Text = "" }
            }, Layer);
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = "-100 -80", OffsetMax = "100 -30" },
                Button = { Color = "1 1 1 0", Command = $"UI_SkinCases inv" },
                Text = { Text = $"->  ОТКРЫТЬ ИНВЕНТАРЬ СОБРАННЫХ ПРЕДМЕТОВ  <-", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 24 }
            }, Layer, Layer + ".Inventory");

            container.Add(new CuiLabel
            {
                RectTransform = {AnchorMin = "0 -1", AnchorMax                                        = "1 0", OffsetMax             = "0 5"},
                Text          = {Text      = "Там хранятся все полученные предметы из кейсов, вы сможете забрать их в любое удобное вам время!\n" +
                        "Внимание, производится очистка кейса каждый глобальный WIPE!", Align = TextAnchor.UpperCenter, Font = "robotocondensed-regular.ttf", Color = "1 1 1 0.7"}
            }, Layer + ".Inventory");


            var availableCases = CaseHandler.CaseSettings.CaseLits.OrderByDescending(p => PlayerInventories[player.userID].Cases[p.DisplayName] > 0).ToList();
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "-100 -50", OffsetMax = "0 50" },
                Button = { Color = "1 1 1 0", Command = $"UI_SkinCases shoppage {page + 1}" },
                Text = { Text = $">", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 80, Color = availableCases.Count > (page + 1) * 10 ? "1 1 1 1" : "1 1 1 0.2" }
            }, Layer);
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "0 -50", OffsetMax = "100 50" },
                Button        = { Color     = "1 1 1 0", Command = $"UI_SkinCases shoppage {page - 1}" },
                Text          = { Text      = $"<", Align        = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 80, Color = page > 0 ? "1 1 1 1" : "1 1 1 0.2" }
            }, Layer);

            var list = availableCases.Skip(page * 10).Take(10);
            float currentX = -525;
            float currentY = Mathf.CeilToInt((list.Count() / 5f) - 0.01f) / 2f * 230;
            
            var playerInfo = new PlayerInventory();
            if (!PlayerInventories.TryGetValue(player.userID, out playerInfo)) return;
            
            foreach (var check in list.Select((i,t) => new { A = i, B = t })) 
            {
                int indexOfCase = CaseHandler.CaseSettings.CaseLits.IndexOf(check.A);
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0.5 0.5", AnchorMax = $"0.5 0.5", OffsetMin = $"{currentX} {currentY - 200 - 20}", OffsetMax = $"{currentX + 200} {currentY - 20}" },
                    Button = { Color = "1 1 1 0", Command = $"UI_SkinCases show {indexOfCase}"},
                    Text = { Text = "" }
                }, Layer, Layer + $".{check.B}"); 
                
                container.Add(new CuiElement
                {
                    Parent = Layer + $".{check.B}",
                    Components =
                    {
                        new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", GetNameFromURI(check.A.ImageURL)), Color = playerInfo.Cases[check.A.DisplayName] > 0 ? "1 1 1 1" : "1 1 1 0.3" },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0"}
                    }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 -15", OffsetMax = "15 0" },
                    Button = { Color = "1 1 1 0", Command = $"UI_SkinCases show {indexOfCase}" },
                    Text = { Text = $"x{playerInfo.Cases[check.A.DisplayName]}", Align = TextAnchor.LowerRight, Font = "robotocondensed-regular.ttf", FontSize = 30, Color = playerInfo.Cases[check.A.DisplayName] > 0 ? "1 1 1 0.8" : "1 1 1 0.2" }
                }, Layer + $".{check.B}"); 

                currentX += 210;
                if (currentX > 500)
                {
                    currentX = -525;
                    currentY -= 230;
                }
            }

            container.Add(new CuiLabel
            {
                RectTransform = {AnchorMin = "0 0.08", AnchorMax = "1 0.08", OffsetMax = "0 50"},
                Text = {Text = "Вы получаете <b>простой кейс</b>, каждые 24 часа, просто играя на сервере!\n" +
                        "Если хотите больше кейсов, они ждут вас на сайте kuala store", Align = TextAnchor.UpperCenter, Font = "robotocondensed-regular.ttf", Color = "1 1 1 0.7"}
            }, Layer); 

            CuiHelper.AddUi(player, container);
        }
        
        private void UI_DrawInventory(BasePlayer player, int page = 0)
        {
            CuiHelper.DestroyUi(player, Layer);
            CuiElementContainer container = new CuiElementContainer();
            
            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.8" }
            }, "Overlay", Layer);
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Close = Layer },
                Text = { Text = "" }
            }, Layer);
            
            container.Add(new CuiElement
            {
                Parent = Layer,
                Name = Layer + ".SkinsHandler",
                Components =
                {
                    new CuiImageComponent { Color = "1 1 1 0" },
                    new CuiRectTransformComponent { AnchorMin = $"0.5 0.5", AnchorMax = $"0.5 0.5", OffsetMin = "-600 -220", OffsetMax = "600 220" }
                }
            });

                
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5 0.9", AnchorMax = "0.5 0.9", OffsetMin = "-100 -20", OffsetMax = "100 20" },
                Button = { Color = "1 1 1 0.03", Command = $"UI_SkinCases shop" },
                Text = { Text = $"МОИ КЕЙСЫ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 20 }
            }, Layer, Layer + ".Inventory");
            
            if (PlayerInventories[player.userID].Inventory.Count == 0)
            {

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0" },
                    Text = { Text = $"У ВАС НЕТУ ПРЕДМЕТОВ\n" +
                                    $"<size=24>ВЫ ПОЛУЧИТЕ ИХ ИЗ КЕЙСА</size>\n\n" +
                                    $"<size=16>ЗАХОДИТЕ НА САЙТЕ kuala store И НАЙДЁТЕ ТАМ БОЛЬШЕ КЕЙСОВ</size>", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 34 }
                }, Layer + ".SkinsHandler");
                
                CuiHelper.AddUi(player, container);
                return;
            }
            
            
            if (page > 0)
            {
                container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0.5 0.9", AnchorMax = "0.5 0.9", OffsetMin = "-175 -20", OffsetMax = "-110 20" },
                        Button = { Color = "1 1 1 0.03", Command = $"UI_SkinCases invpage {page - 1}" },
                        Text = { Text = $"<<<", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 20 }
                    }, Layer, Layer + ".Nazad");
            }

            if ((float) PlayerInventories[player.userID].Inventory.Count > (page + 1) * 44)
            {
                container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0.5 0.9", AnchorMax = "0.5 0.9", OffsetMin = "110 -20", OffsetMax = "175 20" },
                        Button = { Color = "1 1 1 0.03", Command = $"UI_SkinCases invpage {page + 1}" },
                        Text = { Text = $">>>", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 20 }
                    }, Layer, Layer + ".Vpered");
            }

            var   list     = PlayerInventories[player.userID].Inventory.Skip(page * 44).Take(44);
            float currentX = -600;
            float currentY = Mathf.CeilToInt((list.Count() / 11f) - 0.010141f) / 2f * 106f;
            
            var playerInfo = new PlayerInventory();
            if (!PlayerInventories.TryGetValue(player.userID, out playerInfo)) return;
            foreach (var check in list.Select((i,t) => new { A = i, B = t }))
            { 
                string currentColor = "FFFFFF03";
                container.Add(new CuiButton 
                {
                    RectTransform = { AnchorMin = $"0.5 0.5", AnchorMax = $"0.5 0.5", OffsetMin = $"{15 +currentX} {currentY - 100 - 1}", OffsetMax = $"{15 + currentX + 100} {currentY - 1}" },
                    Button = { Color = "1 1 1 0.03", Command = $"UI_SkinCases take {check.B + page * 44}"}, 
                    Text = { Text = "" }
                }, Layer + ".SkinsHandler", Layer + $".{check.B}");
                
                string img = !check.A.PictureURL.IsNullOrEmpty() ? GetNameFromURI(check.A.PictureURL) : check.A.ShortName;
                string imageName = check.A.SkinID == 0 && check.A.PictureURL.IsNullOrEmpty() ? check.A.ShortName + 128 : img; 
                
                container.Add(new CuiElement
                {
                    Parent = Layer + $".{check.B}",
                    Components =
                    {
                        new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", imageName, check.A.SkinID) },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-50 -50", OffsetMax = "50 50" }
                    }
                });
            
                /*container.Add(new CuiElement
                {
                    Parent = Layer + $".{check.B}",
                    Components =
                    {
                        new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", check.A., check.A.Id) },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" }
                    }
                });*/

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "-5 10", OffsetMin = "0 3"},
                    Button = { Color = "1 1 1 0", Command = $"UI_SkinCases take {check.B + page * 44}" },
                    Text = { Text = check.A.Amount > 1 ? ("x" + check.A.Amount) : "", Align = TextAnchor.LowerRight, Font = "robotocondensed-regular.ttf", Color = "1 1 1 0.4"}
                }, Layer + $".{check.B}");

                currentX += 107; 
                if (currentX > 550)
                {
                    currentX =  -600;
                    currentY -= 107;
                }
            }

            CuiHelper.AddUi(player, container);
        }

        [PluginReference] private Plugin ImageLibrary;
        private const string Layer = "UI_SkinCases";
        private void UI_DrawCase(BasePlayer player, Case currentCase)
        {
            CuiHelper.DestroyUi(player, Layer); 
            CuiElementContainer container = new CuiElementContainer();
            
            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.8" }
            }, "Overlay", Layer); 
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Close = Layer },
                Text = { Text = "" }
            }, Layer);
            
            container.Add(new CuiElement
            {
                Parent = Layer,
                Name = Layer + ".SkinsHandler",
                Components =
                {
                    new CuiImageComponent { Color = "1 1 1 0.03" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.25", AnchorMax = "0.5 0.25", OffsetMin = "-330 -130", OffsetMax = "330 130" }
                }
            });
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.3375914184 0.7", AnchorMax = "0.65759839281414 0.7", OffsetMin = "-50 0", OffsetMax = "50 60" },
                Button = { Color = "1 1 1 0.03" },
                Text = { Text = "" }
            }, Layer);
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.3375914184 0.7", AnchorMax = "0.65759839141284 0.7", OffsetMin = "-50 -60", OffsetMax = "50 0" },
                Button = { Color = "1 1 1 0.03" },
                Text = { Text = "" }
            }, Layer);
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5 0.52", AnchorMax = "0.5 0.52", OffsetMin = "-150 -20", OffsetMax = "150 20" },
                Button = { Color = "1 1 1 0.03", Command = $"UI_SkinCases open {CaseHandler.CaseSettings.CaseLits.IndexOf(currentCase)}" },
                Text = { Text = $"ОТКРЫТЬ ЗА {15} BET", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 20 }
            }, Layer, Layer + ".Btn");
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5 0.9", AnchorMax = "0.5 0.9", OffsetMin = "-205 -20", OffsetMax = "-5 20" },
                Button = { Color = "1 1 1 0.03141", Command = $"UI_SkinCases inv" },
                Text = { Text = $"ИНВЕНТАРЬ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 20 }
            }, Layer, Layer + ".Inventory");
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5 0.9", AnchorMax = "0.5 0.9", OffsetMin = "5 -20", OffsetMax = "205 20" },
                Button = { Color = "1 1 1 0.03", Command = $"UI_SkinCases shop 0" },
                Text = { Text = $"МОИ КЕЙСЫ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 20 }
            }, Layer, Layer + ".Shop");
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.5 0.7", AnchorMax = $"0.5 0.7", OffsetMin = "-5 -80", OffsetMax = "5 -60" },
                Button = { Color = "1 1 1 0.03" },
                Text = { Text = "" }
            }, Layer, Layer + ".Delimiter");
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.5 0.7", AnchorMax = $"0.5 0.7", OffsetMin = "-5 60", OffsetMax = "5 80" },
                Button = { Color = "1 1 1 0.03141" },
                Text = { Text = "" }
            }, Layer, Layer + ".Delimiter");
            

            var kitMargin = 0.197f;
            foreach (var check in currentCase.Items.OrderBy(p => p.RarityType).Select((i,t) => new { A = i, B = t }))
            {
                string currentColor = CaseHandler.ChancesSettings.Rarities[check.A.RarityType].Color;
                container.Add(new CuiButton
                {
                    RectTransform =
                    {
                        AnchorMin = $"{0.01200886 + check.B * kitMargin - Math.Floor((double) check.B / 5) * 5 * kitMargin} {0.5106891 - Math.Floor((double) check.B / 5) * 0.48f}", 
                        AnchorMax = $"{0.1975984 + check.B * kitMargin - Math.Floor((double) check.B / 5) * 5 * kitMargin} {0.9652275 - Math.Floor((double) check.B / 5) * 0.48f}", 
                        OffsetMax = "0 0"
                    },
                    Button = { Color = HexToRustFormat(CaseHandler.ChancesSettings.Rarities.ElementAtOrDefault(check.A.RarityType).Color) },
                    Text = { Text = "" }
                }, Layer + ".SkinsHandler", Layer + $".{check.B}");

                string img = check.A.PictureURL != null ? GetNameFromURI(check.A.PictureURL) : check.A.ShortName;
                container.Add(new CuiElement
                {
                    Parent = Layer + $".{check.B}",
                    Components =
                    {
                        new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", img, check.A.SkinID) },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" }
                    }
                });

                string niceName = $"{check.A.MinimalAmount} шт. - {check.A.MaximumAmount} шт.";
                
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.2", OffsetMax = "0 0" },
                    Button = { Color = HexToRustFormat(CaseHandler.ChancesSettings.Rarities.ElementAtOrDefault(check.A.RarityType).Color.Remove(6, 2) + 23) },
                    Text = { Text = niceName, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf" }
                }, Layer + $".{check.B}");
            }

            CuiHelper.AddUi(player, container);
            
            List<CaseItem> newLine = new List<CaseItem>();
            for (int i = 0; i < 6; i++)
            {
                newLine.Add(currentCase.GetFinishItem());
            } 
            ServerMgr.Instance.StartCoroutine(DrawLine(player, newLine, currentCase));
        }

        #endregion

        #region Functions

        private IEnumerator GiveCases()
        {
            while (true)
            {
                PrintWarning($"Start giving free cases to users:");
                Stopwatch x = new Stopwatch();
                int affected = 0;
                x.Start();
                
                CaseHandler.DropSettrings.DropList.ForEach(p =>
                {
                    if (CurrentTime() > p.NextDropTime)
                    {
                        try
                        {
                            p.NextDropTime = CurrentTime() + p.Interval;

                            foreach (var group in permission.GetPermissionGroups(p.Permission))
                            {
                                foreach (var users in permission.GetUsersInGroup(group))
                                {
                                    foreach (var cases in p.DropCases)
                                    {
                                        var id = ulong.Parse(users.Split('(')[0].Replace(" ", ""));

                                        if (p.MaxCaseAmount > 0)
                                        {
                                            if (!PlayerInventories.ContainsKey(id)) continue;
                                            if (!PlayerInventories[id].Cases.ContainsKey(cases.Key)) continue;
                                            if (PlayerInventories[id].Cases[cases.Key] >= p.MaxCaseAmount) continue;
                                        }

                                        AddCase(id.ToString(), cases.Key, cases.Value);
                                        affected++;
                                    }
                                }
                            }
                        }
                        catch (FormatException)
                        {
                            PrintError($"Failed to give free cases!");
                        }
                        
                    }
                });

                x.Stop();
                PrintError($"Giving free cases finish. Elapsed time: {x.Elapsed.ToShortString()}:{x.Elapsed.Milliseconds}. Affected: {affected}");
                SaveConfig();
                yield return new WaitForSeconds(180);
            }
        }
        
        private InventoryItem AddItem(BasePlayer player, CaseItem caseItem)
        {
            var item = InventoryItem.Generate(caseItem);
            PlayerInventories[player.userID].Inventory.Add(item);
            
            return item;
        }

        private bool HasCase(BasePlayer player, Case cCase)
        {
            if (!PlayerInventories[player.userID].Cases.ContainsKey(cCase.DisplayName)) return false; 

            return PlayerInventories[player.userID].Cases[cCase.DisplayName] > 0;
        }

        private void RemoveCase(BasePlayer player, Case cCase) => PlayerInventories[player.userID].Cases[cCase.DisplayName] = Math.Max(PlayerInventories[player.userID].Cases[cCase.DisplayName] - 1, 0);
        private void AddCase(BasePlayer player, Case cCase, int amount = 1)
        {
            if (player != null && player.IsConnected)
            {
                player?.ChatMessage($"Вы получили кейс: \"<color=#f4c242>{cCase.DisplayName}</color>\"!\n" +
                    $"Испытайте свою удачу: <color=#4286f4>/case</color>");
            }
            
            ValidatePlayer(player);
            if (!PlayerInventories[player.userID].Cases.ContainsKey(cCase.DisplayName))
                PlayerInventories[player.userID].Cases.Add(cCase.DisplayName, 0);  
            
            for (int i = 0; i < amount; i++)
                PlayerInventories[player.userID].Cases[cCase.DisplayName]++;
        }
        private void AddCase(BasePlayer player, string cCase, int amount = 1)
        {
            var findCase = CaseHandler.CaseSettings.CaseLits.FirstOrDefault(p => p.DisplayName == cCase);
            if (findCase == null)
            {
                ErrorHistory(player, $"Попытка добавление несуществующего кейса: '{cCase}' для игрока '{player}'");
                return;
            }
            
            AddCase(player, findCase, amount);
        }

        private void  AddCase(string playerId, string cCase, int amount = 1)
        {
            BasePlayer target = BasePlayer.Find(playerId);
            if (target == null) target = new BasePlayer {userID = ulong.Parse(playerId), displayName = "UNKOWN"};
            
            var findCase = CaseHandler.CaseSettings.CaseLits.FirstOrDefault(p => p.DisplayName == cCase);
            if (findCase == null) 
            {
                ErrorHistory(target, $"Попытка добавление несуществующего кейса: '{cCase}' для игрока '{playerId}'");
                return;
            }
            
            AddCase(target, findCase, amount); 
        }
        
        private void LogHistory(BasePlayer player, string text)
        {
            PlayerInventories[player.userID].LogHistory.Add($"[{DateTime.Now.ToShortTimeString()}] {text}");
        }

        private void ErrorHistory(BasePlayer player, string text)
        {
            LogToFile($"Errors", $"------------------------\n" +
                                 $"Игрок: {player}\n" +
                                 $"{text}\n" +
                                 $"------------------------", this);
            PlayerInventories[player.userID].ErrorHistory.Add($"[{DateTime.Now.ToShortTimeString()}] {text}");
        }

        private void ValidatePlayer(BasePlayer player)
        {
            if (PlayerInventories.ContainsKey(player.userID)) return;
            LoadData(player);
        }

        #endregion
 
        #region Data

        private void GiveAutoCases(BasePlayer player)
        {
            
        }

        private void LoadData(BasePlayer player)
        {
            var possibleData = Interface.Oxide.DataFileSystem.ReadObject<PlayerInventory>($"SkinCases/{player.userID}");
            
            if (!PlayerInventories.ContainsKey(player.userID))
                PlayerInventories.Add(player.userID, new PlayerInventory());
             
            PlayerInventories[player.userID] = possibleData ?? new PlayerInventory();

            foreach (var check in CaseHandler.CaseSettings.CaseLits)
            {
                if (!PlayerInventories[player.userID].Cases.ContainsKey(check.DisplayName))
                    PlayerInventories[player.userID].Cases.Add(check.DisplayName, 0); 
            }

            GiveAutoCases(player);
        }

        private void SaveData(BasePlayer player) => SaveData(player.userID);
        private void SaveData(ulong userId)
        {
            Interface.Oxide.DataFileSystem.WriteObject($"SkinCases/{userId}", PlayerInventories[userId]);
        }

        #endregion

        #region Commands

        [ConsoleCommand("caseinfo")]
        private void cmdInfo(ConsoleSystem.Arg args)
        {
            args.ReplyWithObject($"Не открыто кейсов у активных игроков: {PlayerInventories.Sum(p => p.Value.Cases.Count)} шт.");
        }
        
        [ConsoleCommand("allcase")]
        private void cmdGiveAllCase(ConsoleSystem.Arg args)
        {
            if (args.Player() != null && !args.Player().IsAdmin) return;
             
            CaseHandler.CaseSettings.CaseLits.ForEach(p => 
            { 
                AddCase(BasePlayer.Find(args.Args[0]), p, int.Parse(args.Args[1]));  
            });
        }
         
        [ConsoleCommand("case")]
        private void cmdGiveCase(ConsoleSystem.Arg args)
        {
            if (args.Player() != null && !args.Player().IsAdmin) return;
            
            AddCase(args.Args[0], args.Args[1], int.Parse(args.Args[2]));
        }
 
        [ConsoleCommand("caseall")]
        private void cmdGiveCaseAll(ConsoleSystem.Arg args)
        {
            if (args.Player() != null && !args.Player().IsAdmin) return;
            
            BasePlayer.activePlayerList.ToList().ForEach(p =>
            {
                AddCase(p, args.Args[0], int.Parse(args.Args[1]));
            });
        }
        
        [ChatCommand("case")]
        private void CmdChatCase(BasePlayer player)
        {
			if (Interface.Oxide.CallHook("CanUseCase", player) != null) return;
            UI_DrawCaseInventory(player);
        }

        #endregion
        
        #region Utils

        private static string GetNameFromURI(string uri)
        {
            return uri.Split('/')[uri.Split('/').Length - 1].Split('.')[0];
        } 
        private static readonly DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        private static double CurrentTime() { return DateTime.UtcNow.Subtract(epoch).TotalSeconds; }
        
        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }

        #endregion
    }
}

// --- End of file: SkinCases.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/IQChat.cs ---
// --- Original Local Path: KualaRust/IQChat.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using CompanionServer;
using ConVar;
using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("IQChat", "Mercury", "0.3.4")]
    [Description("Самый приятный чат для вашего сервера из ветки IQ")]
    class IQChat : RustPlugin
    {
        /// <summary>
        /// Обновление 0.3.4
        /// - Добавлена поддержка IQRankSystem
        /// - Добавлен дополнительный префикс - Ранг совместно с плагином IQRankSystem
        /// - Добавлено отображение времени отыгранного на сервере - совместно с плагином IQRankSystem
        /// - Добавлен пункт в меню чата "Ранг" с поддержкой IQRankSystem
        /// - Добавлена сортировка по доступным рангам IQRankSystem
        /// - Добавлен пункт Включения/Отключения случайных сообщений при подключении игрока
        /// - Добавлен список случайных сообщений при подключении игрока, так-же с поддержкой его страны
        /// - Добавлен пункт Включения/Отключения случайных сообщений при отключении игрока
        /// - Добавлен список случайных сообщений при отключении игрока, так-же с поддержкой его причины 
        /// - Значительно оптимизировал форматирование сообщений
        /// </summary>


        #region Reference
        [PluginReference] Plugin IQPersonal, IQFakeActive, XDNotifications, IQRankSystem;

        #region IQPersonal
        public void SetMute(BasePlayer player) => IQPersonal?.CallHook("API_SET_MUTE", player.userID);
        public void BadWords(BasePlayer player) => IQPersonal?.CallHook("API_DETECTED_BAD_WORDS", player.userID);
        #endregion

        #region XDNotifications
        private void AddNotify(BasePlayer player, string title, string description, string command = "", string cmdyes = "", string cmdno = "")
        {
            if (!XDNotifications) return;
            var Setting = config.ReferenceSetting.XDNotificationsSettings;
            Interface.Oxide.CallHook("AddNotify", player, title, description, Setting.Color, Setting.AlertDelete, Setting.SoundEffect, command, cmdyes, cmdno);
        }
        #endregion

        #region IQFakeActive
        public bool IsFake(string DisplayName) => (bool)IQFakeActive?.Call("IsFake", DisplayName);
        void SyncReservedFinish()
        {
            if (!config.ReferenceSetting.IQFakeActiveSettings.UseIQFakeActive) return;
            PrintWarning("IQChat - успешно синхронизирована с IQFakeActive");
            PrintWarning("=============SYNC==================");
        }
        #endregion

        #region IQRankSystem
        string IQRankGetRank(ulong userID) => (string)(IQRankSystem?.Call("API_GET_RANK_NAME", userID));
        string IQRankGetTimeGame(ulong userID) => (string)(IQRankSystem?.Call("API_GET_TIME_GAME", userID));
        List<string> IQRankListKey(ulong userID) => (List<string>)(IQRankSystem?.Call("API_RANK_USER_KEYS", userID));
        string IQRankGetNameRankKey(string Key) => (string)(IQRankSystem?.Call("API_GET_RANK_NAME", Key));
        void IQRankSetRank(ulong userID, string RankKey) => IQRankSystem?.Call("API_SET_ACTIVE_RANK", userID, RankKey);
        bool IQRankUserAcces(ulong userID, string RankKey) => (bool)IQRankSystem?.Call("API_GET_RANK_ACCESS", userID, RankKey);

        #endregion

        #endregion

        #region Vars
        public Dictionary<BasePlayer, BasePlayer> PMHistory = new Dictionary<BasePlayer, BasePlayer>();

        public string PermMuteMenu = "iqchat.muteuse";
        class Response
        {
            [JsonProperty("country")]
            public string Country { get; set; }
        }
        public static StringBuilder sb = new StringBuilder();
        public string GetLang(string LangKey, string userID = null, params object[] args)
        {
            sb.Clear();
            if (args != null)
            {
                sb.AppendFormat(lang.GetMessage(LangKey, this, userID), args);
                return sb.ToString();
            }
            return lang.GetMessage(LangKey, this, userID);
        }
        #endregion

        #region Configuration

        private static Configuration config = new Configuration();
        private class Configuration
        {
            [JsonProperty("Права для смены ника")]
            public string RenamePermission;
            [JsonProperty("Настройка префиксов")]
            public List<AdvancedFuncion> PrefixList = new List<AdvancedFuncion>();
            [JsonProperty("Настройка цветов для ников")]
            public List<AdvancedFuncion> NickColorList = new List<AdvancedFuncion>();
            [JsonProperty("Настройка цветов для сообщений")]
            public List<AdvancedFuncion> MessageColorList = new List<AdvancedFuncion>();
            [JsonProperty("Настройка сообщений в чате")]
            public MessageSettings MessageSetting;
            [JsonProperty("Настройка причин блокировок чата")]
            public List<ReasonMuteChat> ReasonListChat = new List<ReasonMuteChat>();
            [JsonProperty("Настройка интерфейса")]
            public InterfaceSettings InterfaceSetting;
            [JsonProperty("Настройка оповещения")]
            public AlertSetting AlertSettings;         
            [JsonProperty("Настройка привилегий")]
            public AutoSetups AutoSetupSetting;
            [JsonProperty("Настройка Rust+")]
            public RustPlus RustPlusSettings;
            [JsonProperty("Дополнительная настройка")]
            public OtherSettings OtherSetting;
            [JsonProperty("Настройка автоответчика")]
            public AnswerMessage AnswerMessages = new AnswerMessage();

            [JsonProperty("Настройка плагинов поддержки")]
            public ReferenceSettings ReferenceSetting = new ReferenceSettings();
            internal class AdvancedFuncion
            {
                [JsonProperty("Права")]
                public string Permissions;
                [JsonProperty("Значение")]
                public string Argument;
            }
            internal class AnswerMessage
            {
                [JsonProperty("Включить автоответчик?(true - да/false - нет)")]
                public bool UseAnswer;
                [JsonProperty("Настройка сообщений [Ключевое слово] = Ответ")]
                public Dictionary<string, string> AnswerMessageList = new Dictionary<string, string>();
            }
            internal class RustPlus
            {
                [JsonProperty("Использовать Rust+")]
                public bool UseRustPlus;
                [JsonProperty("Название для уведомления Rust+")]
                public string DisplayNameAlert;
            }
            internal class ReasonMuteChat
            {
                [JsonProperty("Причина мута")]
                public string Reason;
                [JsonProperty("Время мута")]
                public int TimeMute;
            }
            internal class ReferenceSettings
            {
                [JsonProperty("Настройка XDNotifications")]
                public XDNotifications XDNotificationsSettings = new XDNotifications();
                [JsonProperty("Настройка IQFakeActive")]
                public IQFakeActive IQFakeActiveSettings = new IQFakeActive();
                [JsonProperty("Настройка IQRankSystem")]
                public IQRankSystem IQRankSystems = new IQRankSystem();
                internal class XDNotifications
                {
                    [JsonProperty("Включить поддержку XDNotifications(UI уведомления будут заменены на уведомление с XDNotifications)")]
                    public bool UseXDNotifications;
                    [JsonProperty("Цвет заднего фона уведомления(HEX)")]
                    public string Color;
                    [JsonProperty("Через сколько удалиться уведомление")]
                    public int AlertDelete;
                    [JsonProperty("Звуковой эффект")]
                    public string SoundEffect;
                }
                internal class IQRankSystem
                {
                    [JsonProperty("Использовать поддержку рангов")]
                    public bool UseRankSystem;
                    [JsonProperty("Отображать игрокам их отыгранное время рядом с рангом")]
                    public bool UseTimeStandart;
                }
                internal class IQFakeActive
                {
                    [JsonProperty("Использовать поддержку IQFakeActive")]
                    public bool UseIQFakeActive;
                }
            }
            internal class AutoSetups
            {
                [JsonProperty("Настройки сброса привилегий")]
                public ReturnDefault ReturnDefaultSetting = new ReturnDefault();
                [JsonProperty("Автоматической установки префиксов/цвета ника/цвета чата")]
                public SetupAuto SetupAutoSetting = new SetupAuto();
                internal class ReturnDefault
                {
                    [JsonProperty("Сбрасывать автоматически префикс при окончании его прав")]
                    public bool UseDropPrefix;
                    [JsonProperty("Сбрасывать автоматически цвет ника при окончании его прав")]
                    public bool UseDropColorNick;
                    [JsonProperty("Сбрасывать автоматически цвет чата при окончании его прав")]
                    public bool UseDropColorChat;

                    [JsonProperty("При окончании префикса, установится данный префикс")]
                    public string PrefixDefault;
                    [JsonProperty("При окончании цвета ника, установится данный цвет")]
                    public string NickDefault;
                    [JsonProperty("При окончании цвета сообщения, установится данный цвета")]
                    public string MessageDefault;
                }
                internal class SetupAuto
                {
                    [JsonProperty("Устанавливать автоматически префикс при получении его прав")]
                    public bool UseSetupAutoPrefix;
                    [JsonProperty("Устанавливать автоматически цвет ника при получении его прав")]
                    public bool UseSetupAutoColorNick;
                    [JsonProperty("Устанавливать автоматически цвет чата при получении его прав")]
                    public bool UseSetupAutoColorChat;

                }
            }
            internal class MessageSettings
            {
                [JsonProperty("Включить форматирование сообщений")]
                public bool FormatingMessage;
                [JsonProperty("Включить личные сообщения")]
                public bool PMActivate;
                [JsonProperty("Включить игнор ЛС игрокам(/ignore nick)")]
                public bool IgnoreUsePM;
                [JsonProperty("Включить Анти-Спам")]
                public bool AntiSpamActivate;
                [JsonProperty("Скрыть из чата выдачу предметов Админу")]
                public bool HideAdminGave;
                [JsonProperty("Использовать список запрещенных слов?")]
                public bool UseBadWords;
                [JsonProperty("Включить возможность использовать несколько префиксов сразу")]
                public bool MultiPrefix;
                [JsonProperty("Переносить мут в командный чат(В случае мута,игрок не сможет писать даже в командный чат)")]
                public bool MuteTeamChat;
                [JsonProperty("Пермишенс для иммунитета к антиспаму")]
                public string PermAdminImmunitetAntispam;
                [JsonProperty("Наименование оповещения в чат")]
                public string BroadcastTitle;
                [JsonProperty("Цвет сообщения оповещения в чат")]
                public string BroadcastColor;
                [JsonProperty("На какое сообщение заменять плохие слова")]
                public string ReplaceBadWord;
                [JsonProperty("Звук при при получении личного сообщения")]
                public string SoundPM;            
                [JsonProperty("Время,через которое удалится сообщение с UI от администратора")]
                public int TimeDeleteAlertUI;
                [JsonProperty("Steam64ID для аватарки в чате")]
                public ulong Steam64IDAvatar;
                [JsonProperty("Время через которое игрок может отправлять сообщение (АнтиСпам)")]
                public int FloodTime;
                [JsonProperty("Список плохих слов")]
                public List<string> BadWords = new List<string>();
            }
            internal class InterfaceSettings
            {
                [JsonProperty("Значения для плавного появления")]
                public float FadeIn;
                [JsonProperty("Основной цвет UI")]
                public string MainColor;
                [JsonProperty("Дополнительный цвет UI")]
                public string TwoMainColor;
                [JsonProperty("Цвет кнопок")]
                public string ButtonColor;
                [JsonProperty("Цвет текста")]
                public string LabelColor;
                [JsonProperty("Цвет UI уведомления")]
                public string AlertColor;
                [JsonProperty("Настройка расположения UI уведомления")]
                public AlertInterfaceSettings AlertInterfaceSetting;

                internal class AlertInterfaceSettings
                {
                    [JsonProperty("AnchorMin")]
                    public string AnchorMin;
                    [JsonProperty("AnchorMax")]
                    public string AnchorMax;
                    [JsonProperty("OffsetMin")]
                    public string OffsetMin;
                    [JsonProperty("OffsetMax")]
                    public string OffsetMax;
                }
            }
            internal class AlertSetting
            {
                [JsonProperty("Включить случайное сообщение зашедшему игроку")]
                public bool WelcomeMessageUse;
                [JsonProperty("Список сообщений игроку при входе")]
                public List<string> WelcomeMessage = new List<string>();
                [JsonProperty("Уведомлять о входе игрока в чат")]
                public bool ConnectedAlert;
                [JsonProperty("Включить случайные уведомления о входе игрока из списка")]
                public bool ConnectionAlertRandom;
                [JsonProperty("Случайные уведомления о входе игрока({0} - ник игрока, {1} - страна(если включено отображение страны)")]
                public List<string> RandomConnectionAlert = new List<string>();
                [JsonProperty("Отображать страну зашедшего игрока")]
                public bool ConnectedWorld;
                [JsonProperty("Уведомлять о выходе игрока в чат из списка")]
                public bool DisconnectedAlert;
                [JsonProperty("Включить случайные уведомления о входе игрока")]
                public bool DisconnectedAlertRandom;
                [JsonProperty("Случайные уведомления о входе игрока({0} - ник игрока, {1} - причина выхода(если включена причина)")]
                public List<string> RandomDisconnectedAlert = new List<string>();
                [JsonProperty("Отображать причину выхода игрока")]
                public bool DisconnectedReason;
                [JsonProperty("При уведомлении о входе/выходе игрока отображать его аватар напротив ника")]
                public bool ConnectedAvatarUse;
                [JsonProperty("Включить автоматические сообщения в чат")]
                public bool AlertMessage;
                [JsonProperty("Настройка отправки автоматических сообщений в чат")]
                public List<string> MessageList;
                [JsonProperty("Интервал отправки сообщений в чат(Броадкастер)")]
                public int MessageListTimer;
            }
            internal class OtherSettings
            {
                [JsonProperty("Использовать дискорд")]
                public bool UseDiscord;
                [JsonProperty("Вебхук для логирования чата в дискорд")]
                public string WebhooksChatLog;
                [JsonProperty("Вебхук для логирования информации о мутах в дискорде")]
                public string WebhooksMuteInfo;
            }

            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    PrefixList = new List<AdvancedFuncion>
                    {
                        new AdvancedFuncion
                        {
                            Permissions = "iqchat.default",
                            Argument = "<color=yellow><b>[+]</b></color>",
                        },
                        new AdvancedFuncion
                        {
                            Permissions = "iqchat.default",
                            Argument = "<color=yellow><b>[ИГРОК]</b></color>",
                        },
                        new AdvancedFuncion
                        {
                            Permissions = "iqchat.vip",
                            Argument = "<color=yellow><b>[VIP]</b></color>",
                        },
                    },
                    NickColorList = new List<AdvancedFuncion>
                    {
                        new AdvancedFuncion
                        {
                            Permissions = "iqchat.default",
                            Argument = "#DBEAEC",
                        },
                        new AdvancedFuncion
                        {
                            Permissions = "iqchat.default",
                            Argument = "#FFC428",
                        },
                        new AdvancedFuncion
                        {
                            Permissions = "iqchat.vip",
                            Argument = "#45AAB4",
                        },
                    },
                    MessageColorList = new List<AdvancedFuncion>
                    {
                        new AdvancedFuncion
                        {
                            Permissions = "iqchat.default",
                            Argument = "#DBEAEC",
                        },
                        new AdvancedFuncion
                        {
                            Permissions = "iqchat.default",
                            Argument = "#FFC428",
                        },
                        new AdvancedFuncion
                        {
                            Permissions = "iqchat.vip",
                            Argument = "#45AAB4",
                        },
                    },
                    AutoSetupSetting = new AutoSetups
                    {
                        ReturnDefaultSetting = new AutoSetups.ReturnDefault
                        {
                            UseDropColorChat = true,
                            UseDropColorNick = true,
                            UseDropPrefix = true,

                            PrefixDefault = "",
                            NickDefault = "",
                            MessageDefault = "",
                        },
                        SetupAutoSetting = new AutoSetups.SetupAuto
                        {
                            UseSetupAutoColorChat = true,
                            UseSetupAutoColorNick = true,
                            UseSetupAutoPrefix = true,
                        }
                    },
                    RustPlusSettings = new RustPlus
                    {
                        UseRustPlus = true,
                        DisplayNameAlert = "СУПЕР СЕРВЕР",
                    },
                    MessageSetting = new MessageSettings
                    {
                        UseBadWords = true,
                        HideAdminGave = true,
                        IgnoreUsePM = true,
                        MuteTeamChat = true,
                        PermAdminImmunitetAntispam = "iqchat.adminspam",
                        BroadcastTitle = "<color=#007FFF><b>[ОПОВЕЩЕНИЕ]</b></color>",
                        BroadcastColor = "#74ade1",
                        ReplaceBadWord = "Ругаюсь матом",
                        Steam64IDAvatar = 0,
                        TimeDeleteAlertUI = 5,
                        PMActivate = true,
                        SoundPM = "assets/bundled/prefabs/fx/notice/stack.world.fx.prefab",
                        AntiSpamActivate = true,
                        FloodTime = 5,
                        FormatingMessage = true,
                        MultiPrefix = true,
                        BadWords = new List<string> { "хуй", "гей", "говно", "бля", "тварь" }
                    },
                    ReasonListChat = new List<ReasonMuteChat>
                    {
                        new ReasonMuteChat
                        {
                            Reason = "Оскорбление родителей",
                            TimeMute = 1200,
                        },
                        new ReasonMuteChat
                        {
                            Reason = "Оскорбление игроков",
                            TimeMute = 100
                        }
                    },
                    RenamePermission = "iqchat.renameuse",                  
                    AlertSettings = new AlertSetting
                    {
                        MessageListTimer = 60,
                        WelcomeMessageUse = true,
                        ConnectionAlertRandom = false,
                        DisconnectedAlertRandom = false,
                        RandomConnectionAlert = new List<string>
                        {
                            "{0} влетел как дурачок из {1}",
                            "{0} залетел на сервер из {1}, соболезнуем",
                            "{0} прыгнул на сервачок"
                        },
                        RandomDisconnectedAlert = new List<string>
                        {
                            "{0} ушел в мир иной",
                            "{0} вылетел с сервера с причиной {1}",
                            "{0} пошел на другой сервачок"
                        },
                        ConnectedAlert = true,
                        ConnectedWorld = true,
                        DisconnectedAlert = true,
                        DisconnectedReason = true,
                        AlertMessage = true,
                        ConnectedAvatarUse = true,
                        MessageList = new List<string>
                        {
                        "Автоматическое сообщение #1",
                        "Автоматическое сообщение #2",
                        "Автоматическое сообщение #3",
                        "Автоматическое сообщение #4",
                        "Автоматическое сообщение #5",
                        "Автоматическое сообщение #6",
                        },
                        WelcomeMessage = new List<string>
                        {
                            "Добро пожаловать на сервер SUPERSERVER\nРады,что выбрал именно нас!",
                            "С возвращением на сервер!\nЖелаем тебе удачи",
                            "Добро пожаловать на сервер\nУ нас самые лучшие плагины",
                        },

                    },
                    InterfaceSetting = new InterfaceSettings
                    {
                        FadeIn = 0.2f,
                        MainColor = "#000000C0",
                        TwoMainColor = "#762424FF",
                        ButtonColor = "#802A2AFF",
                        LabelColor = "#D1C7BEFF",
                        AlertColor = "#802A2AFF",
                        AlertInterfaceSetting = new InterfaceSettings.AlertInterfaceSettings
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "0 -90",
                            OffsetMax = "320 -20"
                        }
                    }, 
                    OtherSetting = new OtherSettings
                    {
                        UseDiscord = false,
                        WebhooksChatLog = "",
                        WebhooksMuteInfo = "",
                    },
                    AnswerMessages = new AnswerMessage
                    {
                        UseAnswer = true,
                        AnswerMessageList = new Dictionary<string, string>
                        {
                            ["вайп"] = "Вайп будет 27.06",
                            ["wipe"] = "Вайп будет 27.06",
                            ["читер"] = "Нашли читера?Напиши /report и отправь жалобу"
                        }
                    },
                    ReferenceSetting = new ReferenceSettings
                    {
                        XDNotificationsSettings = new ReferenceSettings.XDNotifications
                        {                         
                            UseXDNotifications = false,
                            AlertDelete = 5,
                            Color = "#762424FF",
                            SoundEffect = "",
                        },
                        IQFakeActiveSettings = new ReferenceSettings.IQFakeActive
                        {
                            UseIQFakeActive = true,
                        },
                        IQRankSystems = new ReferenceSettings.IQRankSystem
                        {
                            UseRankSystem = false,
                            UseTimeStandart = true
                        }
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning("Ошибка #132" + $"чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }
            NextTick(SaveConfig);
        }

        void RegisteredPermissions()
        {
            for (int MsgColor = 0; MsgColor < config.MessageColorList.Count; MsgColor++)
                if (!permission.PermissionExists(config.MessageColorList[MsgColor].Permissions, this))
                    permission.RegisterPermission(config.MessageColorList[MsgColor].Permissions, this);

            for (int NickColorList = 0; NickColorList < config.NickColorList.Count; NickColorList++)
                if (!permission.PermissionExists(config.NickColorList[NickColorList].Permissions, this))
                    permission.RegisterPermission(config.NickColorList[NickColorList].Permissions, this);

            for (int PrefixList = 0; PrefixList < config.PrefixList.Count; PrefixList++)
                if (!permission.PermissionExists(config.PrefixList[PrefixList].Permissions, this))
                    permission.RegisterPermission(config.PrefixList[PrefixList].Permissions, this);

            permission.RegisterPermission(config.RenamePermission, this);
            permission.RegisterPermission(PermMuteMenu, this);
            permission.RegisterPermission(config.MessageSetting.PermAdminImmunitetAntispam,this);
            PrintWarning("Permissions - completed");
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region Data
        [JsonProperty("Дата с настройкой чата игрока")]
         public Dictionary<ulong, SettingUser> ChatSettingUser = new Dictionary<ulong, SettingUser>();
        [JsonProperty("Дата с Административной настройкой")] public AdminSettings AdminSetting = new AdminSettings();
        public class SettingUser
        {
            public string ChatPrefix;
            public List<string> MultiPrefix = new List<string>();
            public string NickColor;
            public string MessageColor;
            public double MuteChatTime;
            public double MuteVoiceTime;
            public List<ulong> IgnoredUsers = new List<ulong>();
        }

        public class AdminSettings
        {
            public bool MuteChatAll;
            public bool MuteVoiceAll;
            public Dictionary<ulong, string> RenameList = new Dictionary<ulong, string>()
;        }
        void ReadData()
        {
            ChatSettingUser = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, SettingUser>>("IQChat/IQUser");
            AdminSetting = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<AdminSettings>("IQChat/AdminSetting");
        }
        void WriteData()
        {
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQChat/IQUser", ChatSettingUser);
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQChat/AdminSetting", AdminSetting);
        }

        void RegisteredDataUser(BasePlayer player)
        {
            if (!ChatSettingUser.ContainsKey(player.userID))
                ChatSettingUser.Add(player.userID, new SettingUser
                {
                    ChatPrefix = config.AutoSetupSetting.ReturnDefaultSetting.PrefixDefault,
                    NickColor = config.AutoSetupSetting.ReturnDefaultSetting.NickDefault,
                    MessageColor = config.AutoSetupSetting.ReturnDefaultSetting.MessageDefault,
                    MuteChatTime = 0,
                    MuteVoiceTime = 0,
                    MultiPrefix = new List<string> { },
                    IgnoredUsers = new List<ulong> { },
                    
                });
        }

        #endregion

        #region Hooks     
        private bool OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel)
        {
            if (Interface.Oxide.CallHook("CanChatMessage", player, message) != null) return false;
            SeparatorChat(channel, player, message);
            return false;
        }
        private object OnServerMessage(string message, string name)
        {
            if (config.MessageSetting.HideAdminGave)
                if (message.Contains("gave") && name == "SERVER")
                    return true;
            return null;
        }
        void OnUserPermissionGranted(string id, string permName) => AutoSetupData(id, permName);
        private void OnUserGroupAdded(string id, string groupName)
        {
            var PermissionsGroup = permission.GetGroupPermissions(groupName);
            if (PermissionsGroup == null) return;
            foreach (var permName in PermissionsGroup)
                AutoSetupData(id, permName); 
        }
        void OnUserPermissionRevoked(string id, string permName) => AutoReturnDefaultData(id, permName);
        void OnUserGroupRemoved(string id, string groupName)
        {
            var PermissionsGroup = permission.GetGroupPermissions(groupName);
            if (PermissionsGroup == null) return;
            foreach (var permName in PermissionsGroup)
                AutoReturnDefaultData(id, permName);
        }
        object OnPlayerVoice(BasePlayer player, Byte[] data)
        {
            var DataPlayer = ChatSettingUser[player.userID];
            bool IsMuted = DataPlayer.MuteVoiceTime > CurrentTime() ? true : false;
            if (IsMuted)
                return false;
            return null;
        }

        private void OnServerInitialized()
        {
            ReadData();
            foreach (var p in BasePlayer.activePlayerList)
                RegisteredDataUser(p);

            RegisteredPermissions();
            WriteData();
            BroadcastAuto();
        }
        void OnPlayerConnected(BasePlayer player)
        {
            RegisteredDataUser(player);
            var Alert = config.AlertSettings;
            if (Alert.ConnectedAlert)
            {
                string Avatar = Alert.ConnectedAvatarUse ? player.UserIDString : "";
                string Message = string.Empty;
                if (config.AlertSettings.ConnectedWorld)
                {
                    webrequest.Enqueue("http://ip-api.com/json/" + player.net.connection.ipaddress.Split(':')[0], null, (code, response) =>
                    {
                        if (code != 200 || response == null)
                            return;

                        string country = JsonConvert.DeserializeObject<Response>(response).Country;

                        if (Alert.ConnectionAlertRandom)
                        {
                            sb.Clear();
                            int RandomIndex = UnityEngine.Random.Range(0, Alert.RandomConnectionAlert.Count);
                            Message = sb.AppendFormat(Alert.RandomConnectionAlert[RandomIndex], player.displayName, country).ToString();
                        }
                        else Message = GetLang("WELCOME_PLAYER_WORLD", player.UserIDString, player.displayName, country);
                        ReplyBroadcast(Message, "", Avatar);
                    }, this);
                }
                else
                {
                    if (Alert.ConnectionAlertRandom)
                    {
                        sb.Clear();
                        int RandomIndex = UnityEngine.Random.Range(0, Alert.RandomConnectionAlert.Count);
                        Message = sb.AppendFormat(Alert.RandomConnectionAlert[RandomIndex], player.displayName).ToString();
                    }
                    else Message = GetLang("WELCOME_PLAYER", player.UserIDString, player.displayName);
                    ReplyBroadcast(Message);
                }
            }
            if (Alert.WelcomeMessageUse)
            {
                int RandomMessage = UnityEngine.Random.Range(0, Alert.WelcomeMessage.Count);
                string WelcomeMessage = Alert.WelcomeMessage[RandomMessage];
                ReplySystem(Chat.ChatChannel.Global, player, WelcomeMessage);
            }
        }      
        void Unload() => WriteData();

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            var Alert = config.AlertSettings;
            if (Alert.DisconnectedAlert)
            {
                string Avatar = Alert.ConnectedAvatarUse ? player.UserIDString : "";
                string Message = string.Empty;
                if (Alert.DisconnectedAlertRandom)
                {
                    sb.Clear();
                    int RandomIndex = UnityEngine.Random.Range(0, Alert.RandomDisconnectedAlert.Count);
                    Message = sb.AppendFormat(Alert.RandomDisconnectedAlert[RandomIndex], player.displayName, reason).ToString();
                }
                else Message = config.AlertSettings.DisconnectedReason ? GetLang("LEAVE_PLAYER_REASON", player.UserIDString, player.displayName, reason) : GetLang("LEAVE_PLAYER", player.UserIDString, player.displayName);
                ReplyBroadcast(Message, "", Avatar);
            }
        }
        #endregion

        #region DiscordFunc

        #region FancyDiscord
        public class FancyMessage
        {
            public string content { get; set; }
            public bool tts { get; set; }
            public Embeds[] embeds { get; set; }

            public class Embeds
            {
                public string title { get; set; }
                public int color { get; set; }
                public List<Fields> fields { get; set; }
                public Footer footer { get; set; }
                public Authors author { get; set; }

                public Embeds(string title, int color, List<Fields> fields, Authors author, Footer footer)
                {
                    this.title = title;
                    this.color = color;
                    this.fields = fields;
                    this.author = author;
                    this.footer = footer;

                }
            }

            public FancyMessage(string content, bool tts, Embeds[] embeds)
            {
                this.content = content;
                this.tts = tts;
                this.embeds = embeds;
            }

            public string toJSON() => JsonConvert.SerializeObject(this);
        }

        public class Footer
        {
            public string text { get; set; }
            public string icon_url { get; set; }
            public string proxy_icon_url { get; set; }
            public Footer(string text, string icon_url, string proxy_icon_url)
            {
                this.text = text;
                this.icon_url = icon_url;
                this.proxy_icon_url = proxy_icon_url;
            }
        }

        public class Authors
        {
            public string name { get; set; }
            public string url { get; set; }
            public string icon_url { get; set; }
            public string proxy_icon_url { get; set; }
            public Authors(string name, string url, string icon_url, string proxy_icon_url)
            {
                this.name = name;
                this.url = url;
                this.icon_url = icon_url;
                this.proxy_icon_url = proxy_icon_url;
            }
        }

        public class Fields
        {
            public string name { get; set; }
            public string value { get; set; }
            public bool inline { get; set; }
            public Fields(string name, string value, bool inline)
            {
                this.name = name;
                this.value = value;
                this.inline = inline;
            }
        }

        private void Request(string url, string payload, Action<int> callback = null)
        {
            Dictionary<string, string> header = new Dictionary<string, string>();
            header.Add("Content-Type", "application/json");
            webrequest.Enqueue(url, payload, (code, response) =>
            {
                if (code != 200 && code != 204)
                {
                    if (response != null)
                    {
                        try
                        {
                            JObject json = JObject.Parse(response);
                            if (code == 429)
                            {
                                float seconds = float.Parse(Math.Ceiling((double)(int)json["retry_after"] / 1000).ToString());
                            }
                            else
                            {
                                PrintWarning($" Discord rejected that payload! Responded with \"{json["message"].ToString()}\" Code: {code}");
                            }
                        }
                        catch
                        {
                            PrintWarning($"Failed to get a valid response from discord! Error: \"{response}\" Code: {code}");
                        }
                    }
                    else
                    {
                        PrintWarning($"Discord didn't respond (down?) Code: {code}");
                    }
                }
                try
                {
                    callback?.Invoke(code);
                }
                catch (Exception ex) { }

            }, this, RequestMethod.POST, header);
        }
        #endregion

        void DiscordSendMessage(string key, string WebHooks, ulong userID = 0, params object[] args)
        {
            if (!config.OtherSetting.UseDiscord) return;
            if (String.IsNullOrWhiteSpace(WebHooks)) return;

            List<Fields> fields = new List<Fields>
                {
                    new Fields("IQChat", key, true),
                };

            FancyMessage newMessage = new FancyMessage(null, false, new FancyMessage.Embeds[1] { new FancyMessage.Embeds(null, 635133, fields, new Authors("IQChat", "https://vk.com/mir_inc", "https://i.imgur.com/ILk3uJc.png", null), new Footer("Author: Mercury[vk.com/mir_inc]", "https://i.imgur.com/ILk3uJc.png", null)) });
            Request($"{WebHooks}", newMessage.toJSON());
        }
        #endregion

        #region Func
        public bool IsMutedUser(ulong userID)
        {
            var DataPlayer = ChatSettingUser[userID];
            return DataPlayer.MuteChatTime > CurrentTime() ? true : false;
        }
        private void SeparatorChat(Chat.ChatChannel channel, BasePlayer player, string Message)
        {
            var DataPlayer = ChatSettingUser[player.userID];

            if (IsMutedUser(player.userID))
            {
                ReplySystem(Chat.ChatChannel.Global, player, GetLang("FUNC_MESSAGE_ISMUTED_TRUE", player.UserIDString, FormatTime(TimeSpan.FromSeconds(DataPlayer.MuteChatTime - CurrentTime()))));
                return;
            }

            var RankSettings = config.ReferenceSetting.IQRankSystems;
            var MessageSettings = config.MessageSetting;
            string OutMessage = Message;
            string PrefxiPlayer = "";
            string MessageSeparator = "";
            string ColorNickPlayer = DataPlayer.NickColor;
            string ColorMessagePlayer = DataPlayer.MessageColor;
            string DisplayName = AdminSetting.RenameList.ContainsKey(player.userID) ? AdminSetting.RenameList[player.userID] : player.displayName;

            if (MessageSettings.FormatingMessage)
                OutMessage = $"{Message.ToLower().Substring(0, 1).ToUpper()}{Message.Remove(0, 1).ToLower()}";

            if (MessageSettings.UseBadWords)
                foreach (var DetectedMessage in OutMessage.Split(' '))
                    if (MessageSettings.BadWords.Contains(DetectedMessage.ToLower()))
                    {
                        OutMessage = OutMessage.Replace(DetectedMessage, MessageSettings.ReplaceBadWord);
                        BadWords(player);
                    }

            if (MessageSettings.MultiPrefix)
            {
                if (DataPlayer.MultiPrefix != null)

                    for (int i = 0; i < DataPlayer.MultiPrefix.Count; i++)
                        PrefxiPlayer += DataPlayer.MultiPrefix[i];
            }
            else PrefxiPlayer = DataPlayer.ChatPrefix;

            string ModifiedNick = string.IsNullOrWhiteSpace(ColorNickPlayer) ? player.IsAdmin ? $"<color=#a8fc55>{DisplayName}</color>" : $"<color=#54aafe>{DisplayName}</color>" : $"<color={ColorNickPlayer}>{DisplayName}</color>";
            string ModifiedMessage = string.IsNullOrWhiteSpace(ColorMessagePlayer) ? OutMessage : $"<color={ColorMessagePlayer}>{OutMessage}</color>";
            string ModifiedChannel = channel == Chat.ChatChannel.Team ? "<color=#a5e664>[Team]</color>" : "";

            string Rank = string.Empty;
            string RankTime = string.Empty;
            if (IQRankSystem)
                if (RankSettings.UseRankSystem)
                {
                    if (RankSettings.UseTimeStandart)
                        RankTime = $"{IQRankGetTimeGame(player.userID)}";
                    Rank = $"{IQRankGetRank(player.userID)}";
                }
            MessageSeparator = !String.IsNullOrWhiteSpace(Rank) && !String.IsNullOrWhiteSpace(RankTime) ? $"{ModifiedChannel} [{RankTime}] [{Rank}] {PrefxiPlayer} {ModifiedNick}: {ModifiedMessage}" : !String.IsNullOrWhiteSpace(RankTime) ? $"{ModifiedChannel} [{RankTime}] {PrefxiPlayer} {ModifiedNick}: {ModifiedMessage}" : !String.IsNullOrWhiteSpace(Rank) ? $"{ModifiedChannel} [{Rank}] {PrefxiPlayer} {ModifiedNick}: {ModifiedMessage}" : $"{ModifiedChannel} {PrefxiPlayer} {ModifiedNick}: {ModifiedMessage}";


            if (config.RustPlusSettings.UseRustPlus)
                if (channel == Chat.ChatChannel.Team)
                {
                    RelationshipManager.PlayerTeam Team = RelationshipManager.Instance.FindTeam(player.currentTeam);
                    if (Team == null) return;
                    Util.BroadcastTeamChat(player.Team, player.userID, player.displayName, OutMessage, DataPlayer.MessageColor);
                }

            ReplyChat(channel, player, MessageSeparator);
            AnwserMessage(player, MessageSeparator.ToLower());
            Puts($"{player}: {OutMessage}");
            Log($"СООБЩЕНИЕ В ЧАТ : {player}: {ModifiedChannel} {OutMessage}");
            DiscordSendMessage(GetLang("DISCORD_SEND_LOG_CHAT", player.UserIDString, player.displayName, player.UserIDString, OutMessage, Message), config.OtherSetting.WebhooksChatLog, player.userID);

            RCon.Broadcast(RCon.LogType.Chat, new Chat.ChatEntry
            {
                Message = $"{player.displayName} : {OutMessage}",
                UserId = player.UserIDString,
                Username = player.displayName,
                Channel = channel,
                Time = (DateTime.UtcNow.Hour * 3600) + (DateTime.UtcNow.Minute * 60),
            });
        }

        public void AutoSetupData(string id, string perm)
        {
            var AutoSetup = config.AutoSetupSetting.SetupAutoSetting;
            if (String.IsNullOrWhiteSpace(id)) return;
            if (String.IsNullOrWhiteSpace(perm)) return;
            ulong userID;
            if (!ulong.TryParse(id, out userID)) return;

            if (!ChatSettingUser.ContainsKey(userID)) return;
            var DataPlayer = ChatSettingUser[userID];

            var Prefix = config.PrefixList.FirstOrDefault(x => x.Permissions == perm);
            var ColorChat = config.MessageColorList.FirstOrDefault(x => x.Permissions == perm);
            var ColorNick = config.NickColorList.FirstOrDefault(x => x.Permissions == perm);
            if (AutoSetup.UseSetupAutoPrefix)
                if (Prefix != null)
                {
                    if (!config.MessageSetting.MultiPrefix)
                        DataPlayer.ChatPrefix = Prefix.Argument;
                    else DataPlayer.MultiPrefix.Add(Prefix.Argument);

                    BasePlayer player = BasePlayer.FindByID(userID);
                    if (player != null)
                        ReplySystem(Chat.ChatChannel.Global, player, GetLang("PREFIX_SETUP", player.UserIDString, Prefix.Argument));
                }
            if (AutoSetup.UseSetupAutoColorChat)
                if (ColorChat != null)
                {
                    DataPlayer.MessageColor = ColorChat.Argument;

                    BasePlayer player = BasePlayer.FindByID(userID);
                    if (player != null)
                        ReplySystem(Chat.ChatChannel.Global, player, GetLang("COLOR_CHAT_SETUP", player.UserIDString, ColorChat.Argument));

                }
            if (AutoSetup.UseSetupAutoColorNick)
                if (ColorNick != null)
                {
                    DataPlayer.NickColor = ColorNick.Argument;

                    BasePlayer player = BasePlayer.FindByID(userID);
                    if (player != null)
                        ReplySystem(Chat.ChatChannel.Global, player, GetLang("COLOR_NICK_SETUP", player.UserIDString, ColorNick.Argument));
                }
        }
        public void AutoReturnDefaultData(string id, string perm)
        {
            var AutoReturn = config.AutoSetupSetting.ReturnDefaultSetting;
            if (String.IsNullOrWhiteSpace(id)) return;
            if (String.IsNullOrWhiteSpace(perm)) return;
            ulong userID;
            if (!ulong.TryParse(id, out userID)) return;
            if (!userID.IsSteamId()) return;
            if (!ChatSettingUser.ContainsKey(userID)) return;

            var DataPlayer = ChatSettingUser[userID];

            var Prefix = config.PrefixList.FirstOrDefault(x => x.Permissions == perm);
            var ColorChat = config.MessageColorList.FirstOrDefault(x => x.Permissions == perm);
            var ColorNick = config.NickColorList.FirstOrDefault(x => x.Permissions == perm);

            if (AutoReturn.UseDropPrefix)
                if (Prefix != null)
                {
                    if (config.MessageSetting.MultiPrefix)
                    {
                        if (DataPlayer.MultiPrefix.Contains(Prefix.Argument))
                        {
                            DataPlayer.MultiPrefix.Remove(Prefix.Argument);

                            BasePlayer player = BasePlayer.FindByID(userID);
                            if (player != null)
                                ReplySystem(Chat.ChatChannel.Global, player, GetLang("PREFIX_RETURNRED", player.UserIDString, Prefix.Argument));
                        }
                    }
                    else if (DataPlayer.ChatPrefix == Prefix.Argument)
                    {
                        DataPlayer.ChatPrefix = AutoReturn.PrefixDefault;

                        BasePlayer player = BasePlayer.FindByID(userID);
                        if (player != null)
                            ReplySystem(Chat.ChatChannel.Global, player, GetLang("PREFIX_RETURNRED", player.UserIDString, Prefix.Argument));
                    }
                }
            if (AutoReturn.UseDropColorChat)
                if (ColorChat != null)
                    if (DataPlayer.MessageColor == ColorChat.Argument)
                    {
                        DataPlayer.MessageColor = AutoReturn.MessageDefault;

                        BasePlayer player = BasePlayer.FindByID(userID);
                        if (player != null)
                        ReplySystem(Chat.ChatChannel.Global, player, GetLang("COLOR_CHAT_RETURNRED", player.UserIDString, ColorChat.Argument));

                    }
            if (AutoReturn.UseDropColorNick)
                if (ColorNick != null)
                    if (DataPlayer.NickColor == ColorNick.Argument)
                    {
                        DataPlayer.NickColor = AutoReturn.NickDefault;

                        BasePlayer player = BasePlayer.FindByID(userID);
                        if (player != null)
                            ReplySystem(Chat.ChatChannel.Global, player, GetLang("COLOR_NICK_RETURNRED", player.UserIDString, ColorNick.Argument));
                    }
        }   
        public void AnwserMessage(BasePlayer player, string Message)
        {
            var Anwser = config.AnswerMessages;
            if (!Anwser.UseAnswer) return;

            foreach (var Anwsers in Anwser.AnswerMessageList)
                if (Message.Contains(Anwsers.Key.ToLower()))
                    ReplySystem(Chat.ChatChannel.Global, player, Anwsers.Value);
        }

        public void BroadcastAuto()
        {
            var Alert = config.AlertSettings;
            if (Alert.AlertMessage)
            {
                timer.Every(Alert.MessageListTimer, () =>
                 {
                     var RandomMsg = Alert.MessageList[UnityEngine.Random.Range(0, Alert.MessageList.Count)];
                     ReplyBroadcast(RandomMsg);
                 });
            }
        }
        public void MutePlayer(BasePlayer player, string Format, int ReasonIndex, string ResonCustom = "",string TimeCustom = "", BasePlayer Initiator = null)
        {
            var cfg = config.ReasonListChat[ReasonIndex];
            string Reason = string.IsNullOrEmpty(ResonCustom) ? cfg.Reason : ResonCustom;
            float TimeMute = string.IsNullOrEmpty(TimeCustom) ? cfg.TimeMute : Convert.ToInt32(TimeCustom);
            string DisplayInititator = Initiator == null ? "Администратор" : Initiator.displayName;
            ulong UserIdInitiator = Initiator == null ? 0 : Initiator.userID;
            switch (Format)
            {
                case "mutechat":
                    {
                        ChatSettingUser[player.userID].MuteChatTime = TimeMute + CurrentTime();
                        ReplyBroadcast(GetLang("FUNC_MESSAGE_MUTE_CHAT", player.UserIDString, DisplayInititator, player.displayName, FormatTime(TimeSpan.FromSeconds(TimeMute)), Reason));
                        if (Initiator != null)
                            SetMute(Initiator);
                        DiscordSendMessage(GetLang("DISCORD_SEND_LOG_MUTE", player.UserIDString, DisplayInititator, UserIdInitiator, player.displayName, player.userID, Reason), config.OtherSetting.WebhooksMuteInfo);
                        break;
                    }
                case "unmutechat":
                    {
                        ChatSettingUser[player.userID].MuteChatTime = 0;
                        ReplyBroadcast(GetLang("FUNC_MESSAGE_UNMUTE_CHAT",player.UserIDString), DisplayInititator);
                        break;
                    }
                case "mutevoice":
                    {
                        ChatSettingUser[player.userID].MuteVoiceTime = TimeMute + CurrentTime();
                        ReplyBroadcast(GetLang("FUNC_MESSAGE_MUTE_VOICE", player.UserIDString, DisplayInititator, player.displayName, FormatTime(TimeSpan.FromSeconds(TimeMute)), Reason)); 
                        break;
                    }
            }
        }       
        public void MuteAllChatPlayer(BasePlayer player,float TimeMute = 86400) => ChatSettingUser[player.userID].MuteChatTime = TimeMute + CurrentTime();
        public void RenameFunc(BasePlayer player,string NewName)
        {
            if (permission.UserHasPermission(player.UserIDString, config.RenamePermission))
            {
                if (!AdminSetting.RenameList.ContainsKey(player.userID))
                    AdminSetting.RenameList.Add(player.userID, NewName);
                else AdminSetting.RenameList[player.userID] = NewName;
                ReplySystem(Chat.ChatChannel.Global, player, GetLang("COMMAND_RENAME_SUCCES", player.UserIDString, NewName));
            }
            else ReplySystem(Chat.ChatChannel.Global, player, GetLang("COMMAND_NOT_PERMISSION",player.UserIDString)); 
        }
        void AlertUI(BasePlayer player, string[] arg)
        {
            if (player != null)
                if (!player.IsAdmin) return;

            if (arg.Length == 0 || arg == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, GetLang("FUNC_MESSAGE_NO_ARG_BROADCAST", player.UserIDString));
                return;
            }
            string Message = "";
            foreach (var msg in arg)
                Message += " " + msg;

            foreach (BasePlayer p in BasePlayer.activePlayerList)
                UIAlert(p, Message);
        }
        void Alert(BasePlayer player, string[] arg)
        {
            if (player != null)
                if (!player.IsAdmin) return;

            if (arg.Length == 0 || arg == null)
            {
                if(player != null)
                ReplySystem(Chat.ChatChannel.Global, player, GetLang("FUNC_MESSAGE_NO_ARG_BROADCAST", player.UserIDString));
                return;
            }
            string Message = "";
            foreach (var msg in arg)
                Message += " " + msg;

            ReplyBroadcast(Message);
            if (config.RustPlusSettings.UseRustPlus)
                foreach(var playerList in BasePlayer.activePlayerList)
                    NotificationList.SendNotificationTo(playerList.userID, NotificationChannel.SmartAlarm, config.RustPlusSettings.DisplayNameAlert, Message, Util.GetServerPairingData());
        }

        #endregion

        #region Interface
        static string MAIN_PARENT = "MAIN_PARENT_UI";
        static string MUTE_MENU_PARENT = "MUTE_MENU_UI";
        static string ELEMENT_SETTINGS = "NEW_ELEMENT_SETTINGS";
        static string MAIN_ALERT_UI = "ALERT_UI_PLAYER";
        static string PANEL_ACTION = "PANEL_ACTION";
        static string PANEL_ACTION_HELPER = "PANEL_ACTION_HELPER";

        #region MainMenu

        public void UI_MainMenu(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, MAIN_PARENT);
            var Interface = config.InterfaceSetting;
            float FadeInGlobal = Interface.FadeIn;

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { FadeIn = FadeInGlobal, Color = "0 0 0 0"}
            }, "Overlay", MAIN_PARENT);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.81875 0.468519", AnchorMax = "1 1" },   
                Image = { FadeIn = FadeInGlobal, Color = HexToRustFormat(Interface.TwoMainColor), Material = "assets/content/ui/uibackgroundblur.mat" }
            },  MAIN_PARENT, PANEL_ACTION);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.93", AnchorMax = "1 1" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("TITLE_TWO", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, PANEL_ACTION);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "0 -45", OffsetMax = "231 -5" },
                Button = { FadeIn = FadeInGlobal, Close = MAIN_PARENT, Color = HexToRustFormat(Interface.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_CLOSE_BTN", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Align = TextAnchor.MiddleCenter }
            }, PANEL_ACTION);

            #region ACTION BUTTON

            #region SettingPrefix

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.0 0.8383705", AnchorMax = "1 0.9179095" },
                Button = { FadeIn = FadeInGlobal, Command = "iq_chat setting prefix", Color = HexToRustFormat(Interface.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat"},
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_TEXT_PREFIX", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Align = TextAnchor.MiddleCenter }
            }, PANEL_ACTION, "PREFIX_SETTING");

            container.Add(new CuiElement
            {
                Parent = "PREFIX_SETTING",
                Components =
                    {
                        new CuiImageComponent { FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = "assets/icons/sign.png" },
                        new CuiRectTransformComponent { AnchorMin = "0.04236809 0.1937432", AnchorMax = "0.1696546 0.7884976" }
                    }
            });

            #endregion

            #region SettingColorNick

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.0 0.7371891", AnchorMax = "1 0.8167281" },
                Button = { FadeIn = FadeInGlobal, Command = "iq_chat setting nick", Color = HexToRustFormat(Interface.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_TEXT_COLOR_NICK", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Align = TextAnchor.MiddleCenter }
            }, PANEL_ACTION, "COLOR_NICK_SETTING");

            container.Add(new CuiElement
            {
                Parent = "COLOR_NICK_SETTING",
                Components =
                    {
                        new CuiImageComponent {FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = "assets/icons/sign.png"  },
                        new CuiRectTransformComponent { AnchorMin = "0.04236809 0.1937432", AnchorMax = "0.1696546 0.7884976" }
                    }
            });

            #endregion

            #region SettingText

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.0 0.6346937", AnchorMax = "1 0.7142327" },
                Button = { FadeIn = FadeInGlobal, Command = "iq_chat setting chat", Color = HexToRustFormat(Interface.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_TEXT_COLOR_MSG", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Align = TextAnchor.MiddleCenter }
            }, PANEL_ACTION, "TEXT_SETTING");

            container.Add(new CuiElement
            {
                Parent = "TEXT_SETTING",
                Components =
                    {
                        new CuiImageComponent { FadeIn = FadeInGlobal, Color = HexToRustFormat(Interface.LabelColor), Sprite = "assets/icons/sign.png" },
                        new CuiRectTransformComponent { AnchorMin = "0.04236809 0.1937432", AnchorMax = "0.1696546 0.7884976" }
                    }
            });

            #endregion

            #region SettingRank

            if (IQRankSystem)
                if (config.ReferenceSetting.IQRankSystems.UseRankSystem)
                {
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0.1243169 0.5282561", AnchorMax = "1 0.6077951" },
                        Button = { FadeIn = FadeInGlobal, Command = "iq_chat setting rank", Color = HexToRustFormat(Interface.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat" },
                        Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_TEXT_RANK", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Align = TextAnchor.MiddleCenter }
                    }, PANEL_ACTION, "RANK_SYSTEM");

                    container.Add(new CuiElement
                    {
                        Parent = "RANK_SYSTEM",
                        Components =
                    {
                        new CuiImageComponent {FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = "assets/icons/sign.png"  },
                        new CuiRectTransformComponent { AnchorMin = "0.04236809 0.1937432", AnchorMax = "0.1696546 0.7884976" }
                    }
                    });
                }
            #endregion

            #endregion

            #region ADMIN

            #region HELPERS
            if (permission.UserHasPermission(player.UserIDString, PermMuteMenu))
            {
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0.4323258", AnchorMax = "1 0.5171261" },
                    Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_TEXT_MODER_PANEL", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                }, PANEL_ACTION);

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.0 0.3298316", AnchorMax = "1 0.4093724" },
                    Button = { FadeIn = FadeInGlobal, Command = $"iq_chat mute menu", Color = HexToRustFormat(Interface.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat" },
                    Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_TEXT_MUTE_MENU_BTN", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Align = TextAnchor.MiddleCenter }
                }, PANEL_ACTION, "CHAT_SETTING_USER");

                container.Add(new CuiElement
                {
                    Parent = "CHAT_SETTING_USER",
                    Components =
                    {
                        new CuiImageComponent {FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = "assets/icons/subtract.png" },
                        new CuiRectTransformComponent { AnchorMin = "0.04236809 0.1937432", AnchorMax = "0.1696546 0.7884976" }
                    }
                });
            }
            #endregion

            #region OWNER
            if (player.IsAdmin)
            {
                string CommandChat = "iq_chat admin_chat";
                string TextMuteChatButton = AdminSetting.MuteChatAll ? "UI_TEXT_ADMIN_PANEL_UNMUTE_CHAT_ALL" : "UI_TEXT_ADMIN_PANEL_MUTE_CHAT_ALL";
                string CommandMuteChatButton = AdminSetting.MuteChatAll ? "unmutechat" : "mutechat";
                string CommandVoice = "iq_chat admin_voice";
                string TextMuteVoiceButton = AdminSetting.MuteVoiceAll ? "UI_TEXT_ADMIN_PANEL_UNMUTE_VOICE_ALL" : "UI_TEXT_ADMIN_PANEL_MUTE_VOICE_ALL";
                string CommandMuteVoiceButton = AdminSetting.MuteVoiceAll ? "unmutevoice" : "mutevoice";

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0.224706", AnchorMax = "1 0.3042471" },
                    Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_TEXT_ADMIN_PANEL", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                },  PANEL_ACTION);

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.0 0.1208954", AnchorMax = "1 0.200437" },
                    Button = { FadeIn = FadeInGlobal, Close = MAIN_PARENT, Command = $"{CommandChat} {CommandMuteChatButton}", Color = HexToRustFormat(Interface.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat"},
                    Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage(TextMuteChatButton, this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Align = TextAnchor.MiddleCenter }
                },  PANEL_ACTION, "CHAT_SETTING_ADMIN");

                container.Add(new CuiElement
                {
                    Parent = "CHAT_SETTING_ADMIN",
                    Components =
                    {
                        new CuiImageComponent {FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = "assets/icons/subtract.png" },
                        new CuiRectTransformComponent { AnchorMin = "0.04236809 0.1937432", AnchorMax = "0.1696546 0.7884976" }
                    }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.1243169 0.02496903", AnchorMax = "1 0.1045107" },
                    Button = { FadeIn = FadeInGlobal, Close = MAIN_PARENT, Command = $"{CommandVoice} {CommandMuteVoiceButton}", Color = HexToRustFormat(Interface.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat" },
                    Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage(TextMuteVoiceButton, this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Align = TextAnchor.MiddleCenter }
                },  PANEL_ACTION, "VOICE_SETTING_ADMIN");
            }
            container.Add(new CuiElement
            {
                Parent = "VOICE_SETTING_ADMIN",
                Components =
                    {
                        new CuiImageComponent { FadeIn = FadeInGlobal, Color = HexToRustFormat(Interface.LabelColor), Sprite = "assets/icons/subtract.png" },
                        new CuiRectTransformComponent { AnchorMin = "0.04236809 0.1937432", AnchorMax = "0.1696546 0.7884976" }
                    }
            });

            #endregion
            
            #endregion

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region PrefixSetting
        public void UI_PrefixSetting(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, ELEMENT_SETTINGS);
            CuiHelper.DestroyUi(player, MUTE_MENU_PARENT);
            CuiHelper.DestroyUi(player, PANEL_ACTION_HELPER);

            var Interface = config.InterfaceSetting;
            float FadeInGlobal = Interface.FadeIn;

            string Prefix = "";
            if (config.MessageSetting.MultiPrefix)
            {
                if (ChatSettingUser[player.userID].MultiPrefix != null)
                    for (int g = 0; g < ChatSettingUser[player.userID].MultiPrefix.Count; g++)
                        Prefix += ChatSettingUser[player.userID].MultiPrefix[g];
                else Prefix = ChatSettingUser[player.userID].ChatPrefix;
            }
            var PrefixList = config.PrefixList;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.4020834 0.3148148", AnchorMax = "0.8150954 1" },
                Image = { FadeIn = FadeInGlobal, Color = HexToRustFormat(Interface.TwoMainColor), Material = "assets/content/ui/uibackgroundblur.mat" }
            }, MAIN_PARENT, ELEMENT_SETTINGS);

            int x = 0, y = 0, i = 0;
            foreach (var ElementPrefix in PrefixList)
            {
                if (!permission.UserHasPermission(player.UserIDString, ElementPrefix.Permissions)) continue;
                string LockStatus = "assets/icons/unlock.png";

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{0 + (x * 0.525)} {0.8514473 - (y * 0.1)}", AnchorMax = $"{0.4708602 + (x * 0.525)} {0.9245502 - (y * 0.1)}" },
                    Button = { FadeIn = FadeInGlobal, Command = $"iq_chat action prefix {ElementPrefix.Argument} {ElementPrefix.Permissions}", Color = HexToRustFormat(config.InterfaceSetting.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat"},
                    Text = { FadeIn = FadeInGlobal, Text = ElementPrefix.Argument, FontSize = 17, Color = HexToRustFormat(Interface.LabelColor), Align = TextAnchor.MiddleCenter }
                }, ELEMENT_SETTINGS, $"BUTTON_{i}");

                container.Add(new CuiElement
                {
                    Parent = $"BUTTON_{i}",
                    Components =
                    {
                        new CuiImageComponent { FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = LockStatus },
                        new CuiRectTransformComponent { AnchorMin = "0.03887215 0.1982514", AnchorMax = "0.1660901 0.7930056" }
                    }
                });

                x++;
                if (x == 2)
                {
                    y++;
                    x = 0;
                }
                i++;
            }

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.93", AnchorMax = "1 1" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_TITLE_NEW_PREFIX_ELEMENT", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, ELEMENT_SETTINGS);

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region NickSetting
        public void UI_NickSetting(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, ELEMENT_SETTINGS);
            CuiHelper.DestroyUi(player, MUTE_MENU_PARENT);
            CuiHelper.DestroyUi(player, PANEL_ACTION_HELPER);

            var Interface = config.InterfaceSetting;
            var ColorList = config.NickColorList;
            float FadeInGlobal = Interface.FadeIn;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.4020834 0.3148148", AnchorMax = "0.8150954 1" },
                Image = { FadeIn = FadeInGlobal, Color = HexToRustFormat(Interface.TwoMainColor), Material = "assets/content/ui/uibackgroundblur.mat" }
            }, MAIN_PARENT, ELEMENT_SETTINGS);

            int x = 0, y = 0, i = 0;
            foreach (var ElementColor in ColorList)
            {
                if (!permission.UserHasPermission(player.UserIDString, ElementColor.Permissions)) continue;
                string LockStatus = "assets/icons/unlock.png";

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{0 + (x * 0.525)} {0.8514473 - (y * 0.1)}", AnchorMax = $"{0.4708602 + (x * 0.525)} {0.9245502 - (y * 0.1)}" },
                    Button = { FadeIn = FadeInGlobal, Command = $"iq_chat action nick {ElementColor.Argument} {ElementColor.Permissions}", Color = HexToRustFormat(config.InterfaceSetting.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat"},
                    Text = { FadeIn = FadeInGlobal, Text = $"<color={ElementColor.Argument}>{player.displayName}</color>", FontSize = 17, Color = HexToRustFormat(Interface.LabelColor), Align = TextAnchor.MiddleCenter }
                }, ELEMENT_SETTINGS, $"BUTTON_{i}");

                container.Add(new CuiElement
                {
                    Parent = $"BUTTON_{i}",
                    Components =
                    {
                        new CuiImageComponent { FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = LockStatus },
                        new CuiRectTransformComponent { AnchorMin = "0.03887215 0.1982514", AnchorMax = "0.1660901 0.7930056" }
                    }
                });

                x++;
                if (x == 2)
                {
                    y++;
                    x = 0;
                }
                i++;
            }

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.93", AnchorMax = "1 1" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_TITLE_NEW_NICK_COLOR_ELEMENT", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter}
            }, ELEMENT_SETTINGS);

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region ColorSetting
        public void UI_TextSetting(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, ELEMENT_SETTINGS);
            CuiHelper.DestroyUi(player, MUTE_MENU_PARENT);
            CuiHelper.DestroyUi(player, PANEL_ACTION_HELPER);

            var Interface = config.InterfaceSetting;
            var ColorList = config.MessageColorList;
            float FadeInGlobal = Interface.FadeIn;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.4020834 0.3148148", AnchorMax = "0.8150954 1" },
                Image = { FadeIn = FadeInGlobal, Color = HexToRustFormat(Interface.TwoMainColor), Material = "assets/content/ui/uibackgroundblur.mat" }
            }, MAIN_PARENT, ELEMENT_SETTINGS);

            int x = 0, y = 0, i = 0;
            foreach (var ElementColor in ColorList)
            {
                if (!permission.UserHasPermission(player.UserIDString, ElementColor.Permissions)) continue;
                string LockStatus = "assets/icons/unlock.png";

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{0 + (x * 0.525)} {0.8514473 - (y * 0.1)}", AnchorMax = $"{0.4708602 + (x * 0.525)} {0.9245502 - (y * 0.1)}" },
                    Button = { FadeIn = FadeInGlobal, Command = $"iq_chat action chat {ElementColor.Argument} {ElementColor.Permissions}", Color = HexToRustFormat(config.InterfaceSetting.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat" },
                    Text = { FadeIn = FadeInGlobal, Text = $"<color={ElementColor.Argument}>Сообщение</color>", Align = TextAnchor.MiddleCenter }
                }, ELEMENT_SETTINGS, $"BUTTON_{i}");

                container.Add(new CuiElement
                {
                    Parent = $"BUTTON_{i}",
                    Components =
                    {
                        new CuiImageComponent { FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = LockStatus },
                        new CuiRectTransformComponent { AnchorMin = "0.03887215 0.1982514", AnchorMax = "0.1660901 0.7930056" }
                    }
                });
                x++;
                if (x == 2)
                {
                    y++;
                    x = 0;
                }
            }

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.93", AnchorMax = "1 1" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_TITLE_NEW_MESSAGE_COLOR_ELEMENT", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter}
            }, ELEMENT_SETTINGS);

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region RankSetting
        public void UI_RankSettings(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, ELEMENT_SETTINGS);
            CuiHelper.DestroyUi(player, MUTE_MENU_PARENT);
            CuiHelper.DestroyUi(player, PANEL_ACTION_HELPER);

            var Interface = config.InterfaceSetting;
            List<string> RankKeys = IQRankListKey(player.userID);
            float FadeInGlobal = Interface.FadeIn;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5020834 0.1148148", AnchorMax = "0.8150954 0.8814815" },
                Image = { FadeIn = FadeInGlobal, Color = HexToRustFormat(Interface.TwoMainColor), Material = "assets/content/ui/uibackgroundblur.mat" }
            }, MAIN_PARENT, ELEMENT_SETTINGS);

            int x = 0, y = 0, i = 0;
            foreach (var ElementRank in RankKeys.Where(r => IQRankUserAcces(player.userID, r)))
            {
                string LockStatus = "assets/icons/unlock.png";
                string RankName = IQRankGetNameRankKey(ElementRank);
                if (String.IsNullOrWhiteSpace(RankName)) continue;

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{0 + (x * 0.525)} {0.8514473 - (y * 0.1)}", AnchorMax = $"{0.4708602 + (x * 0.525)} {0.9245502 - (y * 0.1)}" },
                    Button = { FadeIn = FadeInGlobal, Command = $"iq_chat action rank {ElementRank}", Color = HexToRustFormat(config.InterfaceSetting.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat" },
                    Text = { FadeIn = FadeInGlobal, Text = $"{RankName}", Align = TextAnchor.MiddleCenter }
                }, ELEMENT_SETTINGS, $"BUTTON_{i}");

                container.Add(new CuiElement
                {
                    Parent = $"BUTTON_{i}",
                    Components =
                    {
                        new CuiImageComponent { FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = LockStatus },
                        new CuiRectTransformComponent { AnchorMin = "0.03887215 0.1982514", AnchorMax = "0.1660901 0.7930056" }
                    }
                });
                x++;
                if (x == 2)
                {
                    y++;
                    x = 0;
                }
            }

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.93", AnchorMax = "1 1" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_TITLE_NEW_MESSAGE_RANK_ELEMENT", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, ELEMENT_SETTINGS);

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region MuteMenu
        public void UI_MuteMenu(BasePlayer player, string TargetName = "")
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, MUTE_MENU_PARENT);
            CuiHelper.DestroyUi(player, ELEMENT_SETTINGS);
            CuiHelper.DestroyUi(player, PANEL_ACTION_HELPER);

            var Interface = config.InterfaceSetting;
            float FadeInGlobal = Interface.FadeIn;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.1546875 0.1148148", AnchorMax = "0.8150954 0.8814815" },
                Image = { FadeIn = FadeInGlobal, Color = HexToRustFormat(Interface.TwoMainColor) }
            }, MAIN_PARENT, MUTE_MENU_PARENT);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.9227053", AnchorMax = "1 1" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_MUTE_PANEL_TITLE", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            },  MUTE_MENU_PARENT);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.898551", AnchorMax = "1 0.9456524" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_MUTE_PANEL_TITLE_ACTION", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, MUTE_MENU_PARENT);

            string SearchName = "";
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.8417874", AnchorMax = "1 0.8961352" },
                Image = { FadeIn = FadeInGlobal, Color = HexToRustFormat(Interface.ButtonColor) }
            }, MUTE_MENU_PARENT, MUTE_MENU_PARENT + ".Input");

            container.Add(new CuiElement
            {
                Parent = MUTE_MENU_PARENT + ".Input",
                Name = MUTE_MENU_PARENT + ".Input.Current",
                Components =
                {
                    new CuiInputFieldComponent { Text = SearchName, FontSize = 14,Command = $"mute_search {SearchName}", Align = TextAnchor.MiddleCenter, Color = HexToRustFormat("#ffffffFF"), CharsLimit = 15},
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                }
            });

            int x = 0; int y = 0;
            foreach (var pList in BasePlayer.activePlayerList.Where(i => i.displayName.ToLower().Contains(TargetName.ToLower())))
            {
                string LockStatus = ChatSettingUser[pList.userID].MuteChatTime > CurrentTime() ? "assets/icons/lock.png" :
                                    ChatSettingUser[pList.userID].MuteVoiceTime > CurrentTime() ? "assets/icons/lock.png" : "assets/icons/unlock.png";
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{0.006797731 + (x * 0.165)} {0.7838164 - (y * 0.057)}", AnchorMax = $"{0.1661653 + (x * 0.165)} {0.8309178 - (y * 0.057)}" },
                    Button = { FadeIn = FadeInGlobal, Command = $"iq_chat mute actionmenu {pList.userID}", Color = HexToRustFormat(Interface.ButtonColor) },
                    Text = { FadeIn = FadeInGlobal, Text = "", Align = TextAnchor.MiddleCenter }
                }, MUTE_MENU_PARENT, $"BUTTON{player.userID}");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.1611373 0", AnchorMax = "1 1" },
                    Text = { FadeIn = FadeInGlobal, Text = pList.displayName.Replace(" ", ""), FontSize = 12, Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
                }, $"BUTTON{player.userID}");

                container.Add(new CuiElement
                {
                    Parent = $"BUTTON{player.userID}",
                    Components =
                    {
                        new CuiImageComponent { FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = LockStatus },
                        new CuiRectTransformComponent { AnchorMin = "0.02369668 0.2051285", AnchorMax = "0.1374408 0.820514" }
                    }
                });

                x++;
                if (y == 12 && x == 6) break;

                if (x == 6)
                {
                    y++;
                    x = 0;
                }

            };

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.02870133 0.05434785", AnchorMax = "0.3300647 0.08333336" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_MUTE_PANEL_TITLE_HELPS_LOCK",this, player.UserIDString), FontSize = 10, Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            },  MUTE_MENU_PARENT);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.02870133 0.01570053", AnchorMax = "0.3300647 0.04468608" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_MUTE_PANEL_TITLE_HELPS_UNLOCK", this, player.UserIDString), FontSize = 10, Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, MUTE_MENU_PARENT);

            container.Add(new CuiElement
            {
                Parent = MUTE_MENU_PARENT,
                Components =
                    {
                        new CuiImageComponent {FadeIn = FadeInGlobal,   Color = HexToRustFormat(Interface.LabelColor), Sprite = "assets/icons/lock.png" },
                        new CuiRectTransformComponent { AnchorMin = "0.006797716 0.05434785", AnchorMax = "0.02492483 0.08333336" }
                    }
            });

            container.Add(new CuiElement
            {
                Parent = MUTE_MENU_PARENT,
                Components =
                    {
                        new CuiImageComponent { FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = "assets/icons/unlock.png" },
                        new CuiRectTransformComponent { AnchorMin = "0.006797716 0.01449281", AnchorMax = "0.02492483 0.04347835" }
                    }
            });

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region MuteAction
        
        public void UI_MuteTakeAction(BasePlayer player,ulong userID)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, PANEL_ACTION_HELPER);
            var Interface = config.InterfaceSetting;
            float FadeInGlobal = Interface.FadeIn;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.01197916 0.1148148", AnchorMax = "0.1505208 0.8814149" },  
                Image = { FadeIn = FadeInGlobal, Color = HexToRustFormat(Interface.TwoMainColor), Material = "assets/content/ui/uibackgroundblur.mat" }
            },  MAIN_PARENT, PANEL_ACTION_HELPER);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.919082", AnchorMax = "1 1" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_MUTE_TAKE_ACTION_PANEL", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            },  PANEL_ACTION_HELPER);

            string LockStatus = ChatSettingUser[userID].MuteChatTime > CurrentTime() ? "assets/icons/unlock.png" :
                    ChatSettingUser[userID].MuteVoiceTime > CurrentTime() ? "assets/icons/unlock.png" : "assets/icons/lock.png";

            string ButtonChat = ChatSettingUser[userID].MuteChatTime > CurrentTime() ?  "UI_MUTE_TAKE_ACTION_CHAT_UNMUTE" : "UI_MUTE_TAKE_ACTION_CHAT";
            string ButtonVoice = ChatSettingUser[userID].MuteVoiceTime > CurrentTime() ? "UI_MUTE_TAKE_ACTION_VOICE_UNMUTE" : "UI_MUTE_TAKE_ACTION_VOICE";
            string ButtonCommandChat = ChatSettingUser[userID].MuteChatTime > CurrentTime() ? $"iq_chat mute action {userID} unmutechat" : $"iq_chat mute action {userID} mute mutechat";
            string ButtonCommandVoice = ChatSettingUser[userID].MuteVoiceTime > CurrentTime() ? $"iq_chat mute action {userID} unmutevoice" : $"iq_chat mute action {userID} mute mutevoice";

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0.8357491", AnchorMax = "0.903084 0.8961352" },
                Button = { FadeIn = FadeInGlobal, Command = ButtonCommandChat, Color = HexToRustFormat(Interface.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat"},
                Text = { FadeIn = FadeInGlobal, Text = "",  Align = TextAnchor.MiddleCenter }
            },  PANEL_ACTION_HELPER, "CHAT");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.1790024 0", AnchorMax = "1 1" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage(ButtonChat, this, player.UserIDString), FontSize = 10, Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, $"CHAT");

            container.Add(new CuiElement
            {
                Parent = $"CHAT",
                Components =
                    {
                        new CuiImageComponent { FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = LockStatus },
                        new CuiRectTransformComponent { AnchorMin = "0.02369668 0.2051285", AnchorMax = "0.1374408 0.820514" }
                    }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0.7620788", AnchorMax = "0.903084 0.8224649" },
                Button = { FadeIn = FadeInGlobal, Command = ButtonCommandVoice, Color = HexToRustFormat(Interface.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat"},
                Text = { FadeIn = FadeInGlobal, Text = "", Align = TextAnchor.MiddleCenter }
            },  PANEL_ACTION_HELPER, "VOICE");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.1790024 0", AnchorMax = "1 1" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage(ButtonVoice, this, player.UserIDString), FontSize = 10, Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, $"VOICE");

            container.Add(new CuiElement
            {
                Parent = $"VOICE",
                Components =
                    {
                        new CuiImageComponent { FadeIn = FadeInGlobal, Color = HexToRustFormat(Interface.LabelColor), Sprite = LockStatus },
                        new CuiRectTransformComponent { AnchorMin = "0.02369668 0.2051285", AnchorMax = "0.1374408 0.820514" }
                    }
            });

            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region ReasonMute
        void UI_ReasonMute(BasePlayer player,ulong userID, string MuteFormat)
        {
            CuiElementContainer container = new CuiElementContainer();
            var Interface = config.InterfaceSetting;
            float FadeInGlobal = Interface.FadeIn;

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.6702939", AnchorMax = "1 0.7512119" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_MUTE_TAKE_REASON_TITLE", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            },  PANEL_ACTION_HELPER);

            int i = 0;
            foreach(var Reason in config.ReasonListChat)
            {           
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0 {0.5942072 - (i * 0.07)}", AnchorMax = $"0.903084 {0.6545933 - (i * 0.07)}" },
                    Button = { FadeIn = FadeInGlobal, Command = $"iq_chat mute action {userID} mute_reason {MuteFormat} {i}", Color = HexToRustFormat(Interface.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat" },
                    Text = { FadeIn = FadeInGlobal, Text = "", Align = TextAnchor.MiddleCenter }
                },  PANEL_ACTION_HELPER, $"BUTTON{i}");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.1790024 0", AnchorMax = "1 1" },
                    Text = { FadeIn = FadeInGlobal, Text = Reason.Reason, FontSize = 10, Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
                },  $"BUTTON{i}");

                container.Add(new CuiElement
                {
                    Parent = $"BUTTON{i}",
                    Components =
                    {
                        new CuiImageComponent { FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = "assets/icons/favourite_servers.png" },
                        new CuiRectTransformComponent { AnchorMin = "0.02369668 0.2051285", AnchorMax = "0.1374408 0.820514" }
                    }
                });
                i++;
            }

            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region UpdateLabel
        public void UpdateLabel(BasePlayer player, SettingUser DataPlayer, string Rank = "")
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, "UPDATE_LABEL");

            string Prefix = "";
            if (config.MessageSetting.MultiPrefix)
            {
                if (DataPlayer.MultiPrefix != null)
                    for (int i = 0; i < DataPlayer.MultiPrefix.Count; i++)
                        Prefix += DataPlayer.MultiPrefix[i];
            }
            else Prefix = DataPlayer.ChatPrefix;
            string ResultNick = !String.IsNullOrEmpty(Rank) ? $"<b>[{Rank}] {Prefix}<color={DataPlayer.NickColor}>{player.displayName}</color> : <color={DataPlayer.MessageColor}> я лучший</color></b>" : $"<b>{Prefix}<color={DataPlayer.NickColor}>{player.displayName}</color> : <color={DataPlayer.MessageColor}> я лучший</color></b>";

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.07367153" },
                Text = { FadeIn = config.InterfaceSetting.FadeIn, Text = $"{ResultNick}", FontSize = 14, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf"}
            },  ELEMENT_SETTINGS, "UPDATE_LABEL");

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region UIAlert
        void UIAlert(BasePlayer player, string Message)
        {
            if (XDNotifications && config.ReferenceSetting.XDNotificationsSettings.UseXDNotifications)
            {
                AddNotify(player, lang.GetMessage("UI_ALERT_TITLE", this, player.UserIDString), Message);
                return;
            }
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, MAIN_ALERT_UI);
            var Interface = config.InterfaceSetting;
            var Transform = Interface.AlertInterfaceSetting;
            float FadeInGlobal = Interface.FadeIn;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = Transform.AnchorMin, AnchorMax = Transform.AnchorMax, OffsetMin = Transform.OffsetMin, OffsetMax = Transform.OffsetMax },
                Image = { FadeIn = FadeInGlobal, Color = HexToRustFormat(config.InterfaceSetting.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat" }
            }, "Overlay", MAIN_ALERT_UI);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.025 0.5523812", AnchorMax = "0.1 0.8952149" },  //
                Image = { FadeIn = FadeInGlobal, Color = HexToRustFormat(Interface.MainColor), Sprite = "assets/icons/upgrade.png" }
            }, MAIN_ALERT_UI);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.1125001 0.5037036", AnchorMax = "1 1" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_ALERT_TITLE", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, MAIN_ALERT_UI);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.5259256" },
                Text = { FadeIn = FadeInGlobal, Text = $"{Message}", FontSize = 12, Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, MAIN_ALERT_UI);

            CuiHelper.AddUi(player, container);

            timer.Once(config.MessageSetting.TimeDeleteAlertUI, () =>
            {
                CuiHelper.DestroyUi(player, MAIN_ALERT_UI);
            });
        }
        #endregion

        #endregion

        #region Command

        #region UsingCommand
        [ConsoleCommand("mute")]
        void MuteCustomAdmin(ConsoleSystem.Arg arg)
        {
            if (arg == null || arg.Args == null || arg.Args.Length != 3 || arg.Args.Length > 3)
            {
                PrintWarning("Неверный синтаксис,используйте : mute Steam64ID Причина Время(секунды)");
                return;
            }
            ulong userID = ulong.Parse(arg.Args[0]);
            if (!userID.IsSteamId())
            {
                PrintWarning("Неверный Steam64ID");
                return;
            }
            string Reason = arg.Args[1];
            string TimeMute = arg.Args[2];
            BasePlayer target = BasePlayer.FindByID(userID);
            if (target == null)
            {
                PrintWarning("Такого игрока нет на сервере");
                return;
            }
            MutePlayer(target, "mutechat", 0, Reason, TimeMute);
            Puts("Успешно");
        }
        [ConsoleCommand("unmute")]
        void UnMuteCustomAdmin(ConsoleSystem.Arg arg)
        {
            if (arg == null || arg.Args == null || arg.Args.Length != 1 || arg.Args.Length > 1)
            {
                PrintWarning("Неверный синтаксис,используйте : unmute Steam64ID");
                return;
            }
            ulong userID = ulong.Parse(arg.Args[0]);
            if (!userID.IsSteamId())
            {
                PrintWarning("Неверный Steam64ID");
                return;
            }
            BasePlayer target = BasePlayer.FindByID(userID);
            if (target == null)
            {
                PrintWarning("Такого игрока нет на сервере");
                return;
            }
            ChatSettingUser[target.userID].MuteChatTime = 0;
            ReplyBroadcast(GetLang("FUNC_MESSAGE_UNMUTE_CHAT",target.UserIDString, "Администратор", target.displayName));
            Puts("Успешно");
        }
        [ChatCommand("chat")]
        void ChatCommandMenu(BasePlayer player) => UI_MainMenu(player);

        [ChatCommand("alert")]
        void ChatAlertPlayers(BasePlayer player, string cmd, string[] arg) => Alert(player, arg);

        [ChatCommand("alertui")]
        void ChatAlertPlayersUI(BasePlayer player, string cmd, string[] arg) => AlertUI(player, arg);

        [ChatCommand("rename")]
        void RenameMetods(BasePlayer player, string cmd, string[] arg)
        {
            if (arg.Length == 0 || arg == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("COMMAND_RENAME_NOTARG", this, player.UserIDString));
                return;
            }
            string NewName = "";
            foreach (var name in arg)
                NewName += " " + name;
            RenameFunc(player, NewName);
        }

        #region PM

        [ChatCommand("pm")]
        void PmChat(BasePlayer player, string cmd, string[] arg)
        {
            if (!config.MessageSetting.PMActivate) return;
            if (arg.Length == 0 || arg == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("COMMAND_PM_NOTARG", this, player.UserIDString));
                return;
            }
            string NameUser = arg[0];
            if (config.ReferenceSetting.IQFakeActiveSettings.UseIQFakeActive)
                if (IQFakeActive)
                    if (IsFake(NameUser))
                    {
                        ReplySystem(Chat.ChatChannel.Global, player, GetLang("COMMAND_PM_SUCCESS", player.UserIDString, string.Join(" ", arg.ToArray().ToArray()).Replace(NameUser, "")));
                        return;
                    }
            BasePlayer TargetUser = FindPlayer(NameUser);
            if (TargetUser == null || NameUser == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("COMMAND_PM_NOT_USER", this, player.UserIDString));
                return;
            }
            if (config.MessageSetting.IgnoreUsePM)
            {
                if (ChatSettingUser[TargetUser.userID].IgnoredUsers.Contains(player.userID))
                {
                    ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("IGNORE_NO_PM", this, player.UserIDString));
                    return;
                }
                if (ChatSettingUser[player.userID].IgnoredUsers.Contains(TargetUser.userID))
                {
                    ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("IGNORE_NO_PM_ME", this, player.UserIDString));
                    return;
                }
            }
            var argList = arg.ToArray();
            string Message = string.Join(" ", argList.ToArray()).Replace(NameUser, "");
            if (Message.Length > 125) return;
            if (Message.Length <= 0 || Message == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("COMMAND_PM_NOT_NULL_MSG", this, player.UserIDString));
                return;
            }

            PMHistory[TargetUser] = player;
            PMHistory[player] = TargetUser;
            var DisplayNick = AdminSetting.RenameList.ContainsKey(player.userID) ? AdminSetting.RenameList[player.userID] : player.displayName;

            ReplySystem(Chat.ChatChannel.Global, TargetUser, GetLang("COMMAND_PM_SEND_MSG", player.UserIDString, DisplayNick, Message));
            ReplySystem(Chat.ChatChannel.Global, player, GetLang("COMMAND_PM_SUCCESS", player.UserIDString, Message));
            Effect.server.Run(config.MessageSetting.SoundPM, TargetUser.GetNetworkPosition());
            Log($"ЛИЧНЫЕ СООБЩЕНИЯ : {player.userID}({DisplayNick}) отправил сообщение игроку - {TargetUser.displayName}\nСООБЩЕНИЕ : {Message}");

            RCon.Broadcast(RCon.LogType.Chat, new Chat.ChatEntry
            {
                Message = $"ЛИЧНЫЕ СООБЩЕНИЯ : {DisplayNick}({player.userID}) -> {TargetUser.displayName} : СООБЩЕНИЕ : {Message}",
                UserId = player.UserIDString,
                Username = player.displayName,
                Channel = Chat.ChatChannel.Global,
                Time = (DateTime.UtcNow.Hour * 3600) + (DateTime.UtcNow.Minute * 60),
                Color = "#3f4bb8",
            });
            PrintWarning($"ЛИЧНЫЕ СООБЩЕНИЯ : {DisplayNick}({player.userID}) -> {TargetUser.displayName} : СООБЩЕНИЕ : {Message}");
        }

        [ChatCommand("r")]
        void RChat(BasePlayer player, string cmd, string[] arg)
        {
            if (!config.MessageSetting.PMActivate) return;
            if (arg.Length == 0 || arg == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("COMMAND_R_NOTARG", this, player.UserIDString));
                return;
            }
            if (!PMHistory.ContainsKey(player))
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("COMMAND_R_NOTMSG", this, player.UserIDString));
                return;
            }
            BasePlayer RetargetUser = PMHistory[player];
            if (RetargetUser == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("COMMAND_PM_NOT_USER", this, player.UserIDString));
                return;
            }
            if (config.MessageSetting.IgnoreUsePM)
            {
                if (ChatSettingUser[RetargetUser.userID].IgnoredUsers.Contains(player.userID))
                {
                    ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("IGNORE_NO_PM", this, player.UserIDString));
                    return;
                }
                if (ChatSettingUser[player.userID].IgnoredUsers.Contains(RetargetUser.userID))
                {
                    ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("IGNORE_NO_PM_ME", this, player.UserIDString));
                    return;
                }
            }
            string Message = string.Join(" ", arg.ToArray());
            if (Message.Length > 125) return;
            if (Message.Length <= 0 || Message == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("COMMAND_PM_NOT_NULL_MSG", this, player.UserIDString));
                return;
            }
            PMHistory[RetargetUser] = player;
            var DisplayNick = AdminSetting.RenameList.ContainsKey(player.userID) ? AdminSetting.RenameList[player.userID] : player.displayName;

            ReplySystem(Chat.ChatChannel.Global, RetargetUser, GetLang("COMMAND_PM_SEND_MSG", player.UserIDString, DisplayNick, Message));
            ReplySystem(Chat.ChatChannel.Global, player, GetLang("COMMAND_PM_SUCCESS", player.UserIDString, Message));

            Effect.server.Run(config.MessageSetting.SoundPM, RetargetUser.GetNetworkPosition());
            Log($"ЛИЧНЫЕ СООБЩЕНИЯ : {player.displayName} отправил сообщение игроку - {RetargetUser.displayName}\nСООБЩЕНИЕ : {Message}");

            RCon.Broadcast(RCon.LogType.Chat, new Chat.ChatEntry
            {
                Message = $"ЛИЧНЫЕ СООБЩЕНИЯ : {DisplayNick}({player.userID}) -> {RetargetUser.displayName} : СООБЩЕНИЕ : {Message}",
                UserId = player.UserIDString,
                Username = player.displayName,
                Channel = Chat.ChatChannel.Global,
                Time = (DateTime.UtcNow.Hour * 3600) + (DateTime.UtcNow.Minute * 60),
                Color = "#3f4bb8",
            });
            PrintWarning($"ЛИЧНЫЕ СООБЩЕНИЯ : {DisplayNick}({player.userID}) -> {RetargetUser.displayName} : СООБЩЕНИЕ : {Message}");
        }

        [ChatCommand("ignore")]
        void IgnorePlayerPM(BasePlayer player, string cmd, string[] arg)
        {
            if (!config.MessageSetting.IgnoreUsePM) return;
            var ChatUser = ChatSettingUser[player.userID];
            if (arg.Length == 0 || arg == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("INGORE_NOTARG", this, player.UserIDString));
                return;
            }
            string NameUser = arg[0];
            BasePlayer TargetUser = FindPlayer(NameUser);
            if (TargetUser == null || NameUser == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("COMMAND_PM_NOT_USER", this, player.UserIDString));
                return;
            }

            string Lang = !ChatUser.IgnoredUsers.Contains(TargetUser.userID) ? GetLang("IGNORE_ON_PLAYER", player.UserIDString, TargetUser.displayName) : GetLang("IGNORE_OFF_PLAYER", player.UserIDString, TargetUser.displayName);
            ReplySystem(Chat.ChatChannel.Global, player, Lang);
            if (!ChatUser.IgnoredUsers.Contains(TargetUser.userID))
                ChatUser.IgnoredUsers.Add(TargetUser.userID);
            else ChatUser.IgnoredUsers.Remove(TargetUser.userID);
        }

        #endregion

        [ConsoleCommand("alert")]
        void ChatAlertPlayersCMD(ConsoleSystem.Arg arg) => Alert(arg.Player(), arg.Args);

        [ConsoleCommand("alertui")]
        void ChatAlertPlayersUICMD(ConsoleSystem.Arg arg) => AlertUI(arg.Player(), arg.Args);

        [ConsoleCommand("alertuip")]
        void CmodAlertOnlyUser(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length < 2)
            {
                PrintWarning("Используйте правильно ситаксис : alertuip Steam64ID Сообщение");
                return;
            }
            ulong SteamID = ulong.Parse(arg.Args[0]);
            var argList = arg.Args.ToArray();
            string Message = string.Join(" ", argList.ToArray().Skip(1));
            if (Message.Length > 125) return;
            if (Message.Length <= 0 || Message == null)
            {
                PrintWarning("Вы не указали сообщение игроку");
                return;
            }
            BasePlayer player = BasePlayer.FindByID(SteamID);
            if (player == null)
            {
                PrintWarning("Игрока нет в сети");
                return;
            }
            UIAlert(player, Message);
        }

        [ConsoleCommand("saybro")]
        void ChatAlertPlayerInPM(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length < 2)
            {
                PrintWarning("Используйте правильно ситаксис : saybro Steam64ID Сообщение");
                return;
            }
            ulong SteamID = ulong.Parse(arg.Args[0]);
            var argList = arg.Args.ToArray();
            string Message = string.Join(" ", argList.ToArray());
            if (Message.Length > 125) return;
            if (Message.Length <= 0 || Message == null)
            {
                PrintWarning("Вы не указали сообщение игроку");
                return;
            }
            BasePlayer player = BasePlayer.FindByID(SteamID);
            if(player == null)
            {
                PrintWarning("Игрока нет в сети");
                return;
            }
            ReplySystem(Chat.ChatChannel.Global, player, Message.Replace(SteamID.ToString(), ""));
        }

        [ConsoleCommand("set")]
        private void ConsolesCommandPrefixSet(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length != 3)
            {
                PrintWarning("Используйте правильно ситаксис : set [Steam64ID] [prefix/chat/nick/custom] [Argument]");
                return;
            }
            ulong Steam64ID = 0;
            BasePlayer player = null;
            if (ulong.TryParse(arg.Args[0], out Steam64ID))
                player = BasePlayer.FindByID(Steam64ID);
            if (player == null)
            {
                PrintWarning("Неверно указан SteamID игрока или ошибка в синтаксисе\nИспользуйте правильно ситаксис : set [Steam64ID] [prefix/chat/nick/custom] [Argument]");
                return;
            }
            var DataPlayer = ChatSettingUser[player.userID];

            switch (arg.Args[1].ToLower())
            {
                case "prefix":
                    {
                        string KeyPrefix = arg.Args[2];
                        foreach (var Prefix in config.PrefixList.Where(x => x.Permissions == KeyPrefix))
                            if (config.PrefixList.Contains(Prefix))
                            {
                                DataPlayer.ChatPrefix = Prefix.Argument;
                                Puts($"Префикс успешно установлен на - {Prefix.Argument}");
                            }
                            else Puts("Неверно указан Permissions от префикса");
                        break;
                    }
                case "chat":
                    {
                        string KeyChatColor = arg.Args[2];
                        foreach (var ColorChat in config.PrefixList.Where(x => x.Permissions == KeyChatColor))
                            if (config.MessageColorList.Contains(ColorChat))
                            {
                                DataPlayer.MessageColor = ColorChat.Argument;
                                Puts($"Цвет сообщения успешно установлен на - {ColorChat.Argument}");
                            }
                            else Puts("Неверно указан Permissions от префикса");
                        break;
                    }
                case "nick":
                    {
                        string KeyNickColor = arg.Args[2];
                        foreach (var ColorChat in config.NickColorList.Where(x => x.Permissions == KeyNickColor))
                            if (config.NickColorList.Contains(ColorChat))
                            {
                                DataPlayer.NickColor = ColorChat.Argument;
                                Puts($"Цвет ника успешно установлен на - {ColorChat.Argument}");
                            }
                            else Puts("Неверно указан Permissions от префикса");
                        break;
                    }
                case "custom":
                    {
                        string CustomPrefix = arg.Args[2];
                        DataPlayer.ChatPrefix = CustomPrefix;
                        Puts($"Кастомный префикс успешно установлен на - {CustomPrefix}");
                        break;
                    }
                default:
                    {
                        PrintWarning("Используйте правильно ситаксис : set [Steam64ID] [prefix/chat/nick/custom] [Argument]");
                        break;
                    }
            }

        }

        #endregion

        #region FuncCommand

        [ConsoleCommand("mute_search")]
        void ConsoleSearchMute(ConsoleSystem.Arg arg)
        {
            BasePlayer moder = arg.Player();
            if (arg.Args == null || arg.Args.Length == 0) return;
            string Searcher = arg.Args[0].ToLower();
            if (string.IsNullOrEmpty(Searcher) || Searcher.Length == 0 || Searcher.Length < 1) return;
            UI_MuteMenu(moder, Searcher);
        }                              
        
        [ConsoleCommand("iq_chat")]
        private void ConsoleCommandIQChat(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            var DataPlayer = ChatSettingUser[player.userID];

            switch (arg.Args[0])
            {
                #region Setting
                case "setting": 
                    {
                        switch(arg.Args[1])
                        {
                            case "prefix":
                                {
                                    UI_PrefixSetting(player);
                                    break;
                                }
                            case "nick":
                                {
                                    UI_NickSetting(player);
                                    break;
                                }
                            case "chat":
                                {
                                    UI_TextSetting(player);
                                    break;
                                }
                            case "rank":
                                {
                                    UI_RankSettings(player);
                                    break;
                                }
                        }
                        break;
                    }
                #endregion

                #region Action
                case "action": 
                    {
                        switch(arg.Args[1])
                        {
                            case "prefix":
                                {
                                    var Selected = arg.Args[2];
                                    var Permission = arg.Args[3];
                                    if (!permission.UserHasPermission(player.UserIDString, Permission)) return;

                                    if (config.MessageSetting.MultiPrefix)
                                    {
                                        if (!DataPlayer.MultiPrefix.Contains(Selected))
                                            DataPlayer.MultiPrefix.Add(Selected);
                                        else DataPlayer.MultiPrefix.Remove(Selected);
                                    }
                                    if (DataPlayer.ChatPrefix != Selected)
                                        DataPlayer.ChatPrefix = Selected;
                                    else DataPlayer.ChatPrefix = config.AutoSetupSetting.ReturnDefaultSetting.PrefixDefault;
                                    UpdateLabel(player, DataPlayer);
                                    break;
                                }
                            case "nick":
                                {
                                    var Selected = arg.Args[2];
                                    var Permission = arg.Args[3];
                                    if (!permission.UserHasPermission(player.UserIDString, Permission)) return;

                                    if (DataPlayer.NickColor != Selected)
                                        DataPlayer.NickColor = Selected;
                                    else DataPlayer.NickColor = config.AutoSetupSetting.ReturnDefaultSetting.NickDefault;
                                    UpdateLabel(player, DataPlayer);
                                    break;
                                }
                            case "chat":
                                {
                                    var Selected = arg.Args[2];
                                    var Permission = arg.Args[3];
                                    if (!permission.UserHasPermission(player.UserIDString, Permission)) return;

                                    if (DataPlayer.MessageColor != Selected)
                                        DataPlayer.MessageColor = Selected;
                                    else DataPlayer.MessageColor = config.AutoSetupSetting.ReturnDefaultSetting.MessageDefault;
                                    UpdateLabel(player, DataPlayer);
                                    break;
                                }
                            case "rank":
                                {
                                    string RankKey = arg.Args[2];
                                    IQRankSetRank(player.userID, RankKey);
                                    UpdateLabel(player, DataPlayer, IQRankGetNameRankKey(RankKey));
                                    break;
                                }
                        }
                        break;
                    }
                #endregion
                
                #region Mute
                case "mute":
                    {
                        string Action = arg.Args[1];
                        switch (Action)
                        {
                            case "menu":
                                {
                                    if (permission.UserHasPermission(player.UserIDString, PermMuteMenu))
                                        UI_MuteMenu(player);
                                    break;
                                }
                            case "actionmenu":
                                {
                                    BasePlayer target = BasePlayer.FindByID(ulong.Parse(arg.Args[2]));
                                    UI_MuteTakeAction(player, target.userID);
                                    break;
                                }
                            case "action": 
                                {
                                    BasePlayer target = BasePlayer.FindByID(ulong.Parse(arg.Args[2]));
                                    string MuteAction = arg.Args[3];
                                    switch (MuteAction)
                                    {
                                        case "mute":
                                            {
                                                string MuteFormat = arg.Args[4];
                                                UI_ReasonMute(player, target.userID, MuteFormat);
                                                break;
                                            }
                                        case "mute_reason":
                                            {
                                                CuiHelper.DestroyUi(player, MAIN_PARENT);
                                                string MuteFormat = arg.Args[4];
                                                int Index = Convert.ToInt32(arg.Args[5]);
                                                MutePlayer(target, MuteFormat, Index, "", "", player);
                                                break;
                                            }
                                        case "unmutechat":
                                            {
                                                CuiHelper.DestroyUi(player, MAIN_PARENT);
                                                ChatSettingUser[target.userID].MuteChatTime = 0;
                                                ReplyBroadcast(GetLang("FUNC_MESSAGE_UNMUTE_CHAT", player.UserIDString, player.displayName, target.displayName));
                                                break;
                                            }
                                        case "unmutevoice":
                                            {
                                                CuiHelper.DestroyUi(player, MAIN_PARENT);
                                                ChatSettingUser[target.userID].MuteVoiceTime = 0;
                                                ReplyBroadcast(GetLang("FUNC_MESSAGE_UNMUTE_VOICE", player.UserIDString, player.displayName, target.displayName));
                                                break;
                                            }
                                    }
                                    break;
                                }
                        }
                        break;
                    }              
                #endregion

                #region ADMIN
                case "admin_voice":
                    {
                        var Command = arg.Args[1];
                        switch(Command)
                        {
                            case "mutevoice":
                                {
                                    AdminSetting.MuteVoiceAll = true;
                                    foreach (var p in BasePlayer.activePlayerList)
                                        ChatSettingUser[p.userID].MuteVoiceTime = CurrentTime() + 86400;
                                    ReplyBroadcast(lang.GetMessage("FUNC_MESSAGE_MUTE_ALL_VOICE", this, player.UserIDString));
                                    break;
                                }
                            case "unmutevoice":
                                {
                                    AdminSetting.MuteVoiceAll = false;
                                    foreach (var p in BasePlayer.activePlayerList)
                                        ChatSettingUser[p.userID].MuteVoiceTime = 0;
                                    ReplyBroadcast(lang.GetMessage("FUNC_MESSAGE_UNMUTE_ALL_VOICE", this, player.UserIDString));
                                    break;
                                }
                        }
                        foreach (var p in BasePlayer.activePlayerList)
                            rust.RunServerCommand(Command, p.userID);
                        break;
                    }
                case "admin_chat":
                    {
                        var Command = arg.Args[1];
                        switch(Command)
                        {
                            case "mutechat":
                                {
                                    AdminSetting.MuteChatAll = true;
                                    foreach (var p in BasePlayer.activePlayerList)
                                        MuteAllChatPlayer(p);
                                    ReplyBroadcast(lang.GetMessage("FUNC_MESSAGE_MUTE_ALL_CHAT", this, player.UserIDString));
                                    break;
                                }
                            case "unmutechat":
                                {
                                    AdminSetting.MuteChatAll = false;
                                    foreach (var p in BasePlayer.activePlayerList)
                                        ChatSettingUser[p.userID].MuteChatTime = 0;
                                    ReplyBroadcast(lang.GetMessage("FUNC_MESSAGE_UNMUTE_ALL_CHAT", this, player.UserIDString));
                                    break;
                                }
                        }
                        break;
                    }
                    #endregion
            }
        }

        #endregion

        #endregion

        #region Lang
        private new void LoadDefaultMessages()
        {
            PrintWarning("Языковой файл загружается...");
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["TITLE_ONE"] = "<size=30><b>Chat SETTINGS</b></size>",
                ["TITLE_TWO"] = "<size=16><b>SELECT</b></size>",
                ["UI_CLOSE_BTN"] = "<size=20>CLOSE</size>",

                ["UI_TEXT_PREFIX"] = "<size=14>TAG</size>",
                ["UI_TEXT_COLOR_NICK"] = "<size=14>NICKNAME COLOR</size>",
                ["UI_TEXT_COLOR_MSG"] = "<size=14>TEXT COLOR</size>",
                ["UI_TEXT_RANK"] = "<size=23>RANKS</size>",
                ["UI_TEXT_VOTE_MENU"] = "<size=19>VOTED</size>",
                ["UI_TEXT_MUTE_MENU_BTN"] = "<size=14>MUTED PLAYERS</size>",

                ["UI_TEXT_ADMIN_PANEL"] = "<size=14><b>ADMIN PANEL</b></size>",
                ["UI_TEXT_MODER_PANEL"] = "<size=14><b>MOD PANEL</b></size>",
                ["UI_TEXT_ADMIN_PANEL_MUTE_CHAT_ALL"] = "<size=14>DISABLE CHAT</size>",
                ["UI_TEXT_ADMIN_PANEL_UNMUTE_CHAT_ALL"] = "<size=14>ENABLE CHAT</size>",
                ["UI_TEXT_ADMIN_PANEL_MUTE_VOICE_ALL"] = "<size=14>DISABLE VOICE</size>",
                ["UI_TEXT_ADMIN_PANEL_UNMUTE_VOICE_ALL"] = "<size=14>ENABLE VOICE</size>",

                ["UI_ALERT_TITLE"] = "<size=18><b>ATTENTION PLEASE</b></size>",

                ["UI_TITLE_NEW_PREFIX_ELEMENT"] = "<size=16><b>CHANGE TAG</b></size>",
                ["UI_TITLE_NEW_NICK_COLOR_ELEMENT"] = "<size=16><b>CHANGE NICKNAME COLOR</b></size>",
                ["UI_TITLE_NEW_MESSAGE_COLOR_ELEMENT"] = "<size=16><b>CHANGE TEXT COLOR</b></size>",
                ["UI_TITLE_NEW_MESSAGE_RANK_ELEMENT"] = "<size=16><b>CHANGER RANK</b></size>",

                ["FUNC_MESSAGE_MUTE_CHAT"] = "{0} muted {1} for {2}\nReason : {3}",
                ["FUNC_MESSAGE_UNMUTE_CHAT"] = "{0} unmuted {1}",
                ["FUNC_MESSAGE_MUTE_VOICE"] = "{0} muted voice to {1} for {2}\nReason : {3}",
                ["FUNC_MESSAGE_UNMUTE_VOICE"] = "{0} unmuted voice to {1}",
                ["FUNC_MESSAGE_MUTE_ALL_CHAT"] = "Chat disabled",
                ["FUNC_MESSAGE_UNMUTE_ALL_CHAT"] = "Chat enabled",
                ["FUNC_MESSAGE_MUTE_ALL_VOICE"] = "Voice chat disabled",
                ["FUNC_MESSAGE_UNMUTE_ALL_VOICE"] = "Voice chat enabled",

                ["FUNC_MESSAGE_ISMUTED_TRUE"] = "You can not send the messages {0}\nYou are muted",
                ["FUNC_MESSAGE_NO_ARG_BROADCAST"] = "You can not send an empty broadcast message!",

                ["UI_MUTE_PANEL_TITLE"] = "<size=20><b>MUTE PANEL</b></size>",
                ["UI_MUTE_PANEL_TITLE_ACTION"] = "<size=15>CHOOSE PLAYER OR SEARCH BY NICKNAME</size>",
                ["UI_MUTE_PANEL_TITLE_HELPS_LOCK"] = "<size=13><b>- PLAYER HAS DISABLED CHAT OR VOICECHAT</b></size>",
                ["UI_MUTE_PANEL_TITLE_HELPS_UNLOCK"] = "<size=13><b>- PLAYER HAS ENABLED CHAT OR VOICECHAT</b></size>",

                ["UI_MUTE_TAKE_ACTION_PANEL"] = "<size=18><b>SELECT\nACTION</b></size>",
                ["UI_MUTE_TAKE_ACTION_CHAT"] = "<size=12>MUTE\nCHAT</size>",
                ["UI_MUTE_TAKE_ACTION_CHAT_UNMUTE"] = "<size=12>UNMUTE\nCHAT</size>",
                ["UI_MUTE_TAKE_ACTION_VOICE"] = "<size=12>MUTE\nVOICE</size>",
                ["UI_MUTE_TAKE_ACTION_VOICE_UNMUTE"] = "<size=12>UNMUTE\nVOICE</size>",

                ["UI_MUTE_TAKE_REASON_TITLE"] = "<size=18><b>CHOOSE\nREASON</b></size>",

                ["COMMAND_NOT_PERMISSION"] = "You dont have permissions to use this command",
                ["COMMAND_RENAME_NOTARG"] = "For rename use : /rename New nickname",
                ["COMMAND_RENAME_SUCCES"] = "You have successful changed your name to {0}",

                ["COMMAND_PM_NOTARG"] = "To send pm use : /pm Nickname Message",
                ["COMMAND_PM_NOT_NULL_MSG"] = "Message is empty!",
                ["COMMAND_PM_NOT_USER"] = "User not found or offline",
                ["COMMAND_PM_SUCCESS"] = "Your private message sent successful\nMessage : {0}",
                ["COMMAND_PM_SEND_MSG"] = "Message from {0}\n{1}",

                ["COMMAND_R_NOTARG"] = "For reply use : /r Message",
                ["COMMAND_R_NOTMSG"] = "You dont have any private conversations yet!",

                ["FLOODERS_MESSAGE"] = "You're typing too fast! Please Wait {0} seconds",

                ["PREFIX_SETUP"] = "You have successfully removed the prefix {0}, it is already activated and installed",
                ["COLOR_CHAT_SETUP"] = "You have successfully picked up the <color={0}>chat color</color>, it is already activated and installed",
                ["COLOR_NICK_SETUP"] = "You have successfully taken the <color={0}>nickname color</color>, it is already activated and installed",

                ["PREFIX_RETURNRED"] = "Your prefix {0} expired, it was reset automatically",
                ["COLOR_CHAT_RETURNRED"] = "Action of your <color={0}>color chat</color> over, it is reset automatically",
                ["COLOR_NICK_RETURNRED"] = "Action of your <color={0}>color nick</color> over, it is reset automatically",

                ["WELCOME_PLAYER"] = "{0} came online",
                ["LEAVE_PLAYER"] = "{0} left",
                ["WELCOME_PLAYER_WORLD"] = "{0} came online. Country: {1}",
                ["LEAVE_PLAYER_REASON"] = "{0} left. Reason: {1}",

                ["IGNORE_ON_PLAYER"] = "You added {0} in black list",
                ["IGNORE_OFF_PLAYER"] = "You removed {0} from black list",
                ["IGNORE_NO_PM"] = "This player added you in black list. Your message has not been delivered.",
                ["IGNORE_NO_PM_ME"] = "You added this player in black list. Your message has not been delivered.",
                ["INGORE_NOTARG"] = "To ignore a player use : /ignore nickname",

                ["DISCORD_SEND_LOG_CHAT"] = "Player : {0}({1})\nFiltred message : {2}\nMessage : {3}",
                ["DISCORD_SEND_LOG_MUTE"] = "{0}({1}) give mute chat\nSuspect : {2}({3})\nReason : {4}",
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["TITLE_ONE"] = "<size=30><b>НАСТРОЙКА ЧАТА</b></size>",
                ["TITLE_TWO"] = "<size=16><b>ВЫБЕРИТЕ ДЕЙСТВИЕ</b></size>",
                ["UI_CLOSE_BTN"] = "<size=20>ЗАКРЫТЬ</size>",

                ["UI_TEXT_PREFIX"] = "<size=23>ПРЕФИКС</size>",
                ["UI_TEXT_COLOR_NICK"] = "<size=23>НИК</size>",
                ["UI_TEXT_COLOR_MSG"] = "<size=23>ТЕКСТ</size>",
                ["UI_TEXT_RANK"] = "<size=23>РАНГ</size>",
                ["UI_TEXT_MUTE_MENU_BTN"] = "<size=23>МУТЫ</size>",

                ["UI_TEXT_ADMIN_PANEL"] = "<size=17><b>ПАНЕЛЬ\nАДМИНИСТРАТОРА</b></size>",
                ["UI_TEXT_MODER_PANEL"] = "<size=17><b>ПАНЕЛЬ\nМОДЕРАТОРА</b></size>",
                ["UI_TEXT_ADMIN_PANEL_MUTE_CHAT_ALL"] = "<size=14>ВЫКЛЮЧИТЬ ЧАТ</size>",
                ["UI_TEXT_ADMIN_PANEL_UNMUTE_CHAT_ALL"] = "<size=14>ВКЛЮЧИТЬ ЧАТ</size>",
                ["UI_TEXT_ADMIN_PANEL_MUTE_VOICE_ALL"] = "<size=14>ВЫКЛЮЧИТЬ ГОЛОС</size>",
                ["UI_TEXT_ADMIN_PANEL_UNMUTE_VOICE_ALL"] = "<size=14>ВКЛЮЧИТЬ ГОЛОС</size>",

                ["UI_ALERT_TITLE"] = "<size=18><b>МИНУТОЧКУ ВНИМАНИЯ</b></size>",

                ["UI_TITLE_NEW_PREFIX_ELEMENT"] = "<size=16><b>ВЫБЕРИТЕ ПРЕФИКС</b></size>",
                ["UI_TITLE_NEW_NICK_COLOR_ELEMENT"] = "<size=16><b>ВЫБЕРИТЕ ЦВЕТ НИКА</b></size>",
                ["UI_TITLE_NEW_MESSAGE_COLOR_ELEMENT"] = "<size=16><b>ВЫБЕРИТЕ ЦВЕТ ТЕКСТА</b></size>",
                ["UI_TITLE_NEW_MESSAGE_RANK_ELEMENT"] = "<size=16><b>ВЫБЕРИТЕ СЕБЕ РАНГ</b></size>",

                ["FUNC_MESSAGE_MUTE_CHAT"] = "{0} заблокировал чат игроку {1} на {2}\nПричина : {3}",
                ["FUNC_MESSAGE_UNMUTE_CHAT"] = "{0} разблокировал чат игроку {1}",
                ["FUNC_MESSAGE_MUTE_VOICE"] = "{0} заблокировал голос игроку {1} на {2}\nПричина : {3}",
                ["FUNC_MESSAGE_UNMUTE_VOICE"] = "{0} разблокировал голос игроку {1}",
                ["FUNC_MESSAGE_MUTE_ALL_CHAT"] = "Всем игрокам был заблокирован чат",
                ["FUNC_MESSAGE_UNMUTE_ALL_CHAT"] = "Всем игрокам был разблокирован чат",
                ["FUNC_MESSAGE_MUTE_ALL_VOICE"] = "Всем игрокам был заблокирован голос",
                ["FUNC_MESSAGE_UNMUTE_ALL_VOICE"] = "Всем игрокам был разблокирован голос",

                ["FUNC_MESSAGE_ISMUTED_TRUE"] = "Вы не можете отправлять сообщения еще {0}\nВаш чат заблокирован",
                ["FUNC_MESSAGE_NO_ARG_BROADCAST"] = "Вы не можете отправлять пустое сообщение в оповещение!",

                ["UI_MUTE_PANEL_TITLE"] = "<size=20><b>ПАНЕЛЬ УПРАВЛЕНИЯ БЛОКИРОВКАМИ ЧАТА</b></size>",
                ["UI_MUTE_PANEL_TITLE_ACTION"] = "<size=15>ВЫБЕРИТЕ ИГРОКА ИЛИ ВВЕДИТЕ НИК В ПОИСКЕ</size>",
                ["UI_MUTE_PANEL_TITLE_HELPS_LOCK"] = "<size=13><b>- У ИГРОКА ЗАБЛОКИРОВАН ЧАТ ИЛИ ГОЛОС</b></size>",
                ["UI_MUTE_PANEL_TITLE_HELPS_UNLOCK"] = "<size=13><b>- У ИГРОКА РАЗБЛОКИРОВАН ЧАТ ИЛИ ГОЛОС</b></size>",

                ["UI_MUTE_TAKE_ACTION_PANEL"] = "<size=18><b>ВЫБЕРИТЕ\nДЕЙСТВИЕ</b></size>",
                ["UI_MUTE_TAKE_ACTION_CHAT"] = "<size=12>ЗАБЛОКИРОВАТЬ\nЧАТ</size>",
                ["UI_MUTE_TAKE_ACTION_CHAT_UNMUTE"] = "<size=12>РАЗБЛОКИРОВАТЬ\nЧАТ</size>",
                ["UI_MUTE_TAKE_ACTION_VOICE"] = "<size=12>ЗАБЛОКИРОВАТЬ\nГОЛОС</size>",
                ["UI_MUTE_TAKE_ACTION_VOICE_UNMUTE"] = "<size=12>РАЗБЛОКИРОВАТЬ\nГОЛОС</size>",

                ["UI_MUTE_TAKE_REASON_TITLE"] = "<size=18><b>ВЫБЕРИТЕ\nПРИЧИНУ</b></size>",

                ["COMMAND_NOT_PERMISSION"] = "У вас недостаточно прав для данной команды",
                ["COMMAND_RENAME_NOTARG"] = "Используйте команду так : /rename Новый Ник",
                ["COMMAND_RENAME_SUCCES"] = "Вы успешно изменили ник на {0}",

                ["COMMAND_PM_NOTARG"] = "Используйте команду так : /pm Ник Игрока Сообщение",
                ["COMMAND_PM_NOT_NULL_MSG"] = "Вы не можете отправлять пустое сообщение",
                ["COMMAND_PM_NOT_USER"] = "Игрок не найден или не в сети",
                ["COMMAND_PM_SUCCESS"] = "Ваше сообщение успешно доставлено\nСообщение : {0}",
                ["COMMAND_PM_SEND_MSG"] = "Сообщение от {0}\n{1}",

                ["COMMAND_R_NOTARG"] = "Используйте команду так : /r Сообщение",
                ["COMMAND_R_NOTMSG"] = "Вам или вы ещё не писали игроку в личные сообщения!",

                ["FLOODERS_MESSAGE"] = "Вы пишите слишком быстро! Подождите {0} секунд",

                ["PREFIX_SETUP"] = "Вы успешно забрали префикс {0}, он уже активирован и установлен",
                ["COLOR_CHAT_SETUP"] = "Вы успешно забрали <color={0}>цвет чата</color>, он уже активирован и установлен",
                ["COLOR_NICK_SETUP"] = "Вы успешно забрали <color={0}>цвет ника</color>, он уже активирован и установлен",

                ["PREFIX_RETURNRED"] = "Действие вашего префикса {0} окончено, он сброшен автоматически",
                ["COLOR_CHAT_RETURNRED"] = "Действие вашего <color={0}>цвета чата</color> окончено, он сброшен автоматически",
                ["COLOR_NICK_RETURNRED"] = "Действие вашего префикса <color={0}>цвет чата</color> окончено, он сброшен автоматически",

                ["WELCOME_PLAYER"] = "{0} зашел на сервер",
                ["LEAVE_PLAYER"] = "{0} вышел с сервера",
                ["WELCOME_PLAYER_WORLD"] = "{0} зашел на сервер.Из {1}",
                ["LEAVE_PLAYER_REASON"] = "{0} вышел с сервера.Причина {1}",

                ["IGNORE_ON_PLAYER"] = "Вы добавили игрока {0} в черный список",
                ["IGNORE_OFF_PLAYER"] = "Вы убрали игрока {0} из черного списка",
                ["IGNORE_NO_PM"] = "Данный игрок добавил вас в ЧС,ваше сообщение не будет доставлено",
                ["IGNORE_NO_PM_ME"] = "Вы добавили данного игрока в ЧС,ваше сообщение не будет доставлено",
                ["INGORE_NOTARG"] = "Используйте команду так : /ignore Ник Игрока",

                ["DISCORD_SEND_LOG_CHAT"] = "Игрок : {0}({1})\nФильтрованное сообщение : {2}\nИзначальное сообщение : {3}",
                ["DISCORD_SEND_LOG_MUTE"] = "{0}({1}) выдал блокировку чата\nИгрок : {2}({3})\nПричина : {4}",
            }, this, "ru");
           
            PrintWarning("Языковой файл загружен успешно");
        }
        #endregion

        #region Helpers
        public void Log(string LoggedMessage) => LogToFile("IQChatLogs", LoggedMessage, this);
        public static string FormatTime(TimeSpan time)
        {
            string result = string.Empty;
            if (time.Days != 0)
                result += $"{Format(time.Days, "дней", "дня", "день")} ";

            if (time.Hours != 0)
                result += $"{Format(time.Hours, "часов", "часа", "час")} ";

            if (time.Minutes != 0)
                result += $"{Format(time.Minutes, "минут", "минуты", "минута")} ";

            if (time.Seconds != 0)
                result += $"{Format(time.Seconds, "секунд", "секунды", "секунда")} ";

            return result;
        }
        private static string Format(int units, string form1, string form2, string form3)
        {
            var tmp = units % 10;

            if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                return $"{units} {form1}";

            if (tmp >= 2 && tmp <= 4)
                return $"{units} {form2}";

            return $"{units} {form3}";
        }
        private BasePlayer FindPlayer(string nameOrId)
        {
            foreach (var check in BasePlayer.activePlayerList.Where(x => x.displayName.ToLower().Contains(nameOrId.ToLower()) || x.UserIDString == nameOrId))
                return check;
            return null;
        }
        private static string HexToRustFormat(string hex)
        {
            Color color;
            ColorUtility.TryParseHtmlString(hex, out color);
            sb.Clear();
            return sb.AppendFormat("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a).ToString();
        }
        #endregion

        #region ChatFunc

        public Dictionary<ulong, double> Flooders = new Dictionary<ulong, double>();
        void ReplyChat(Chat.ChatChannel channel, BasePlayer player, string OutMessage)
        {
            var MessageSetting = config.MessageSetting;
            if (MessageSetting.AntiSpamActivate)
                if (!permission.UserHasPermission(player.UserIDString, MessageSetting.PermAdminImmunitetAntispam))
                {
                    if (!Flooders.ContainsKey(player.userID))
                        Flooders.Add(player.userID, CurrentTime() + MessageSetting.FloodTime);
                    else
                        if (Flooders[player.userID] > CurrentTime())
                        {
                            ReplySystem(Chat.ChatChannel.Global, player, GetLang("FLOODERS_MESSAGE", player.UserIDString, Convert.ToInt32(Flooders[player.userID] - CurrentTime())));
                            return;
                        }

                    Flooders[player.userID] = MessageSetting.FloodTime + CurrentTime();
                }

            if (channel == Chat.ChatChannel.Global)
            {
                foreach (BasePlayer p in BasePlayer.activePlayerList)
                {
                    p.SendConsoleCommand("chat.add", new object[] { (int)channel, player.userID, OutMessage });
                }
                PrintToConsole(OutMessage);
            }
            if (channel == Chat.ChatChannel.Team)
            {
                RelationshipManager.PlayerTeam Team = RelationshipManager.Instance.FindTeam(player.currentTeam);
                if (Team == null) return;
                foreach (var FindPlayers in Team.members)
                {
                    BasePlayer TeamPlayer = BasePlayer.FindByID(FindPlayers);
                    if (TeamPlayer == null) continue;

                    TeamPlayer.SendConsoleCommand("chat.add", channel, player.userID, OutMessage);
                }
            }
        }

        void ReplySystem(Chat.ChatChannel channel, BasePlayer player, string Message,string CustomPrefix = "", string CustomAvatar = "", string CustomHex = "")
        {
            string Prefix = string.IsNullOrEmpty(CustomPrefix) ? config.MessageSetting.BroadcastTitle : CustomPrefix;
            ulong Avatar = string.IsNullOrEmpty(CustomAvatar) ? config.MessageSetting.Steam64IDAvatar : ulong.Parse(CustomAvatar);
            string Hex = string.IsNullOrEmpty(CustomHex) ? config.MessageSetting.BroadcastColor : CustomHex;

            string FormatMessage = $"{Prefix}<color={Hex}>{Message}</color>";
            if (channel == Chat.ChatChannel.Global)
                player.SendConsoleCommand("chat.add", channel, Avatar, FormatMessage);         
        }

        void ReplyBroadcast(string Message, string CustomPrefix = "", string CustomAvatar = "")
        {
            foreach(var p in BasePlayer.activePlayerList)
                ReplySystem(Chat.ChatChannel.Global, p, Message, CustomPrefix, CustomAvatar);
        }

        static DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        static double CurrentTime() => DateTime.UtcNow.Subtract(epoch).TotalSeconds;

        #endregion

        #region API

        void API_SEND_PLAYER(BasePlayer player,string PlayerFormat, string Message, string Avatar, Chat.ChatChannel channel = Chat.ChatChannel.Global)
        {
            var MessageSettings = config.MessageSetting;
            string OutMessage = Message;

            if (MessageSettings.FormatingMessage)
                OutMessage = $"{Message.ToLower().Substring(0, 1).ToUpper()}{Message.Remove(0, 1).ToLower()}";

            if (MessageSettings.UseBadWords)
                foreach (var DetectedMessage in OutMessage.Split(' '))
                    if (MessageSettings.BadWords.Contains(DetectedMessage.ToLower()))
                        OutMessage = OutMessage.Replace(DetectedMessage, MessageSettings.ReplaceBadWord);

            player.SendConsoleCommand("chat.add", channel, ulong.Parse(Avatar), $"{PlayerFormat}: {OutMessage}");
        }
        void API_SEND_PLAYER_PM(BasePlayer player, string DisplayName, string Message)
        {
            ReplySystem(Chat.ChatChannel.Global, player, GetLang("COMMAND_PM_SEND_MSG", player.UserIDString, DisplayName, Message));
            Effect.server.Run(config.MessageSetting.SoundPM, player.GetNetworkPosition());
        }
        void API_SEND_PLAYER_CONNECTED(BasePlayer player, string DisplayName, string country, string userID)
        {
            var Alert = config.AlertSettings;
            if (Alert.ConnectedAlert)
            {
                string Avatar = Alert.ConnectedAvatarUse ? userID : "";
                if (config.AlertSettings.ConnectedWorld)
                     ReplyBroadcast(GetLang("WELCOME_PLAYER_WORLD", player.UserIDString, DisplayName, country), "", Avatar);   
                else ReplyBroadcast(GetLang("WELCOME_PLAYER", player.UserIDString, DisplayName), "", Avatar);
            }
        }
        void API_SEND_PLAYER_DISCONNECTED(BasePlayer player, string DisplayName, string reason, string userID)
        {
            var Alert = config.AlertSettings;
            if (Alert.DisconnectedAlert)
            {
                string Avatar = Alert.ConnectedAvatarUse ? userID : "";
                string LangLeave = config.AlertSettings.DisconnectedReason ? GetLang("LEAVE_PLAYER_REASON",player.UserIDString, DisplayName, reason) : GetLang("LEAVE_PLAYER", player.UserIDString, DisplayName);
                ReplyBroadcast(LangLeave, "", Avatar);
            }
        }
        void API_ALERT(string Message, Chat.ChatChannel channel = Chat.ChatChannel.Global, string CustomPrefix = "", string CustomAvatar = "", string CustomHex = "")
        {
            foreach (var p in BasePlayer.activePlayerList)
                ReplySystem(channel, p, Message, CustomPrefix, CustomAvatar, CustomHex);
        }
        void API_ALERT_PLAYER(BasePlayer player,string Message, string CustomPrefix = "", string CustomAvatar = "", string CustomHex = "") => ReplySystem(Chat.ChatChannel.Global, player, Message, CustomPrefix, CustomAvatar, CustomHex);
        void API_ALERT_PLAYER_UI(BasePlayer player, string Message) => UIAlert(player, Message);
        bool API_CHECK_MUTE_CHAT(ulong ID)
        {
            var DataPlayer = ChatSettingUser[ID];
            if (DataPlayer.MuteChatTime > CurrentTime())
                return true;
            else return false;
        }
        bool API_CHECK_VOICE_CHAT(ulong ID)
        {
            var DataPlayer = ChatSettingUser[ID];
            if (DataPlayer.MuteVoiceTime > CurrentTime())
                return true;
            else return false;
        }
        string API_GET_PREFIX(ulong ID)
        {
            var DataPlayer = ChatSettingUser[ID];
            return DataPlayer.ChatPrefix;
        }
        string API_GET_CHAT_COLOR(ulong ID)
        {
            var DataPlayer = ChatSettingUser[ID];
            return DataPlayer.MessageColor;
        }
        string API_GET_NICK_COLOR(ulong ID)
        {
            var DataPlayer = ChatSettingUser[ID];
            return DataPlayer.NickColor;
        }
        string API_GET_DEFUALT_PRFIX() => (string)config.AutoSetupSetting.ReturnDefaultSetting.PrefixDefault;
        string API_GET_DEFUALT_COLOR_NICK() => (string)config.AutoSetupSetting.ReturnDefaultSetting.NickDefault;
        string API_GET_DEFUALT_COLOR_CHAT() => (string)config.AutoSetupSetting.ReturnDefaultSetting.MessageDefault;
        #endregion
    }
}


// --- End of file: IQChat.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/InstantCraft.cs ---
// --- Original Local Path: KualaRust/InstantCraft.cs ---

﻿using Newtonsoft.Json;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Instant Craft", "Orange / fork", "2.1.5")]
    [Description("Allows players to instantly craft items with features")]
    public class InstantCraft : RustPlugin
    {
		[PluginReference] Plugin SkinMenu;

        #region Vars

        private const string permUse = "instantcraft.use";

        #endregion
        
        #region Oxide Hooks

        private void Init()
        {
            permission.RegisterPermission(permUse, this);
        }
        
        private object OnItemCraft(ItemCraftTask item)
        {
            return OnCraft(item);
        }

        #endregion

        #region Core

        private object OnCraft(ItemCraftTask task)
        {
            if (task.cancelled == true)
            {
                return null;
            }
            
            var player = task.owner;
            var target = task.blueprint.targetItem;
            var name = target.shortname;
            
            if (permission.UserHasPermission(player.UserIDString, permUse) == false)
            {
                return null;
            }

            if (IsBlocked(name))
            {
                task.cancelled = true;
                Message(player, "Blocked");
                GiveRefund(player, task.takenItems);
                return null;
            }

            var stacks = GetStacks(target, task.amount * task.blueprint.amountToCreate);
            var slots = FreeSlots(player);

            if (HasPlace(slots, stacks) == false)
            {
                task.cancelled = true;
                Message(player, "Slots", stacks.Count, slots);
                GiveRefund(player, task.takenItems);
                return null;
            }
            
            if (IsNormalItem(name))
            {
                Message(player, "Normal");
                return null;
            }
            
            GiveItem(player, task, target, stacks, task.skinID);
            task.cancelled = true;
            return null;
        }

        private void GiveItem(BasePlayer player, ItemCraftTask task, ItemDefinition def, List<int> stacks, int taskSkinID)
        {
            var skin = ItemDefinition.FindSkin(def.itemid, taskSkinID);
            if (skin == 0UL) skin = (ulong)SkinMenu.Call("APISKIN", player, def.shortname);
            if (config.split == false)
            {
                var final = 0;

                foreach (var stack in stacks)
                {
                    final += stack;
                }

                var item = ItemManager.Create(def, final, skin);

                if (task.instanceData != null)
                    item.instanceData = task.instanceData;

                player.GiveItem(item);
                Interface.CallHook("OnItemCraftFinished", task, item);
            }
            else
            {
                foreach (var stack in stacks)
                {
                    var item = ItemManager.Create(def, stack, skin);

                    if (task.instanceData != null)
                        item.instanceData = task.instanceData;

                    player.GiveItem(item);
                    Interface.CallHook("OnItemCraftFinished", task, item);
                }
            }
        }

        private int FreeSlots(BasePlayer player)
        {
            var slots = player.inventory.containerMain.capacity + player.inventory.containerBelt.capacity;
            var taken = player.inventory.containerMain.itemList.Count + player.inventory.containerBelt.itemList.Count;
            return slots - taken;
        }

        private void GiveRefund(BasePlayer player, List<Item> items)
        {
            foreach (var item in items)
            {
                player.GiveItem(item);
            }
        }

        private List<int> GetStacks(ItemDefinition item, int amount) 
        {
            var list = new List<int>();
            var maxStack = item.stackable;

            if (maxStack == 0)
            {
                maxStack = 1;
            }

            while (amount > maxStack)
            {
                amount -= maxStack;
                list.Add(maxStack);
            }
            
            list.Add(amount);
            
            return list; 
        }

        private bool IsNormalItem(string name)
        {
            return config.normal?.Contains(name) ?? false;
        }

        private bool IsBlocked(string name)
        {
            return config.blocked?.Contains(name) ?? false;
        }

        private bool HasPlace(int slots, List<int> stacks)
        {
            if (config.checkPlace == false)
            {
                return true;
            }

            if (config.split && slots - stacks.Count < 0)
            {
                return false;
            }

            return slots > 0;
        }

        #endregion

        #region Localization 1.1.1
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Blocked", "Crafting of that item is blocked!"},
                {"Slots", "You don't have enough place to craft! Need {0}, have {1}!"},
                {"Normal", "Item will be crafted with normal speed."}
            }, this);
        }

        private void Message(BasePlayer player, string messageKey, params object[] args)
        {
            if (player == null)
            {
                return;
            }

            var message = GetMessage(messageKey, player.UserIDString, args);
            player.ChatMessage(message);
            //player.SendConsoleCommand("chat.add", (object) 0, (object) message);
        }

        private string GetMessage(string messageKey, string playerID, params object[] args)
        {
            return string.Format(lang.GetMessage(messageKey, this, playerID), args);
        }

        #endregion
        
        #region Configuration 1.1.0

        private static ConfigData config;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Check for free place")]
            public bool checkPlace;
            
            [JsonProperty(PropertyName = "Normal Speed")]
            public List<string> normal;

            [JsonProperty(PropertyName = "Blacklist")]
            public List<string> blocked;
            
            [JsonProperty(PropertyName = "Split crafted stacks")]
            public bool split;
        }

        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                normal = new List<string>
                {
                    "hammer",
                    "put item shortname here"
                },
                blocked = new List<string>
                {
                    "rock",
                    "put item shortname here"
                },
                checkPlace = false,
                split = false
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();

                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                PrintError("Configuration file is corrupt! Unloading plugin...");
                Interface.Oxide.RootPluginManager.RemovePlugin(this);
                return;
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
    }
}

// --- End of file: InstantCraft.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/CTF.cs ---
// --- Original Local Path: KualaRust/CTF.cs ---

﻿using System;
using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System.Collections;
using System.Drawing;
using System.IO;
using System.Drawing.Imaging;
using Newtonsoft.Json.Converters;
using Facepunch;
using VLB;

using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Rust;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("CTF", "Sempai#3239", "1.1.2")]
    class CTF : RustPlugin
    {
        static CTF ins;
        PluginConfig config;

        public class PluginConfig
        {
            [JsonProperty("Изображение на флаг (url)")]
            public string FlagImage;

            [JsonProperty("Минимальное количество игроков для запуска ивента")]
            public int MininamOnline;
            [JsonProperty("Время через которое запускается ивент после старта сервера (в минутах)")]
            public float AwakeTime;
            [JsonProperty("Время через которое запускается ивент после окончания предыдущего ивента (в минутах)")]
            public float NextTime;
            [JsonProperty("Длительность ивента (в минутах)")]
            public float EventTime;
            [JsonProperty("Приостанавливать время ивента, если игрок удерживает флаг?")]
            public bool FreezTime;

            [JsonProperty("Защита игрока с флагом в % от нормальной (0 - стандартная, Значения больше нуля увеличат защиту))")]
            public float AdditionalProtection;
            [JsonProperty("Сколько минут игрок должен удерживать флаг?")]
            public float FlagHoldingTime;
            [JsonProperty("Если игрок потерял флаг, сбрасывать время удержания? (false - будет учитывать суммарное время с нескольких удержаний)")]
            public bool ResetSumTime;

            [JsonProperty("Если закончилось время ивента, выбирать игрока с наибольшим временем удержания?")]
            public bool CanMaxTimeWin;

            [JsonProperty("Скорость захвата флага")]
            public float CapturingSpeed;

            [JsonProperty("Разрешить игроку несущему флаг строить?")]
            public bool CanBuild;
            [JsonProperty("Разрешить игроку несущему флаг открывать двери?")]
            public bool CanOpenDoor;
            [JsonProperty("Разрешить игроку несущему флаг использовать транспорт?")]
            public bool CanUseVehicle;
            [JsonProperty("Разрешить игроку несущему флаг дропнуть флаг?")]
            public bool CanDrop;
            [JsonProperty("Разрешить игроку заносить флаг в зону строительства?")]
            public bool CanEnterToBP;
            [JsonProperty("Радиус в котором запрещено строить рядом с флагом")]
            public float CanBuildRadius;

            [JsonProperty("Призы за победу на ивенте")]
            public List<CustomItem> customItems;

            [JsonProperty("Команды запрещённые  к использованию игроком несущим флаг")]
            public List<string> BlockedComamnds;
        }

        public class CustomItem
        {
            [JsonProperty("Шортнейм предмета")]
            public string ShortName;
            [JsonProperty("Исполняемая команда (%STEAMID% - ключ для вставки SteamID игрока)")]
            public string Command;
            [JsonProperty("Кастомное имя предмета")]
            public string CustomName;
            [JsonProperty("Количество предмета")]
            public int Amount;
            [JsonProperty("SkinID предмета")]
            public ulong SkinID;
            [JsonProperty("Описания приза для оповещения {amount} - количество если необходимо")]
            public string Description;
        }

        protected override void LoadDefaultConfig()
        {
            config = new PluginConfig
            {
                FlagImage = "",
                MininamOnline = 5,
                AwakeTime = 1,
                NextTime = 60,
                EventTime = 30,
                FreezTime = true,
                AdditionalProtection = 0,
                FlagHoldingTime = 5,
                ResetSumTime = false,
                CanMaxTimeWin = true,
                CanBuild = false,
                CanOpenDoor = false,
                CanUseVehicle = false,
                CanDrop = true,
                CanEnterToBP = false,
                CanBuildRadius = 10f,
                CapturingSpeed = 60,
                customItems = new List<CustomItem>()
                {
                    new CustomItem
                    {
                        ShortName = "scrap",
                        Amount = 1000,
                        SkinID = 0,
                        Command = "",
                        CustomName = "",
                        Description = "Металлолом {amount}",
                    },

                    new CustomItem
                    {
                        ShortName = "",
                        Amount = 0,
                        SkinID = 0,
                        Command = "addgroup %STEAMID% premium 7d",
                        CustomName = "",
                        Description = "Премиум на 7 дней",
                    },
                },
                BlockedComamnds = new List<string>()
                {
                    "/trade",
                    "/kit",
                    "/bp",
                    "/storage",
                    "/pass",
                    "/tp",
                    "/tpa",
                    "kit",
                    "backpack.open",
                }
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        private void OnServerInitialized()
        {
            ins = this;
            LoadMessages();

            Unsubscribe("OnPlayerInput");
            Unsubscribe("OnEntityTakeDamage");

            if (!string.IsNullOrEmpty(config.FlagImage))
                ImageLibrary?.Call("AddImage", config.FlagImage, "flagImage");

            if (config.AwakeTime > 0)
                timer.In(config.AwakeTime * 60f, StartEvent);

            timer.Every(1f, RedrawTopPlayers);
        }

        void Unload()
        {
            if (ctfEvent != null)
            {
                UnityEngine.Object.Destroy(ctfEvent);
            }

            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, "TopPanel.BG");
                CuiHelper.DestroyUi(player, "CapruteBG");
            }
        }

        void OnServerShutdown()
        {
            if (ctfEvent != null)
            {
                UnityEngine.Object.Destroy(ctfEvent);
            }
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (player.IsReceivingSnapshot)
            {
                timer.In(1f, () => OnPlayerConnected(player));
                return;
            }

            if (ctfEvent != null)
            {
                CTFMarker.marker.UpdateMarker();
                ctfTime[player] = 0;
                DrawTopPanel(player);
            }
        }

        void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (player.GetComponentInChildren<CTFEvent>() && input.WasJustPressed(BUTTON.USE))
            {
                player.GetComponentInChildren<CTFEvent>().StartDrop();
            }
            if (player.GetComponentInChildren<CTFEvent>() && input.WasDown(BUTTON.USE))
            {
                player.GetComponentInChildren<CTFEvent>().DropProcess();
            }
            if (player.GetComponentInChildren<CTFEvent>() && input.WasJustReleased(BUTTON.USE))
            {
                player.GetComponentInChildren<CTFEvent>().StopDrop();
            }
        }

        object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null || info == null) return null;

            if (ctfEvent != null && ctfEvent.GetFlagEntity() == entity)
                return false;

            var victumPlayer = entity.ToPlayer();
            if (victumPlayer == null) return null;
            if (!victumPlayer.userID.IsSteamId()) return null;

            if (ctfEvent != null && victumPlayer.GetComponentInChildren<CTFEvent>() && config.AdditionalProtection != 0)
            {
                info.damageTypes.ScaleAll(1f - (config.AdditionalProtection / 100f));
            }
            return null;
        }

        private object OnUserCommand(IPlayer ipl, string command, string[] args)
        {
            if (ipl == null || !ipl.IsConnected) return null;
            var player = ipl.Object as BasePlayer;
            if (player == null) return null;
            command = command.Insert(0, "/");
            if (config.BlockedComamnds.Contains(command.ToLower()) && ctfEvent != null && player.GetComponentInChildren<CTFEvent>())
            {
                SendReply(player, GetMsg("commandbanned", player));
                return false;
            }
            return null;
        }

        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            var connection = arg.Connection;
            if (connection == null || string.IsNullOrEmpty(arg.cmd?.FullName)) return null;
            var player = arg.Player();
            if (player == null) return null;
            if ((config.BlockedComamnds.Contains(arg.cmd.Name.ToLower()) || config.BlockedComamnds.Contains(arg.cmd.FullName.ToLower())) && ctfEvent != null && player.GetComponentInChildren<CTFEvent>())
            {
                SendReply(player, GetMsg("commandbanned", player));
                return false;
            }
            return null;
        }
        Vector3 GetEventPosition()
        {
            var eventPos = Vector3.zero;
            int maxRetries = 100;
            var monuments = TerrainMeta.Path.Monuments.Select(monument => monument.transform.position).ToList();
            while (eventPos == Vector3.zero && maxRetries > 0)
            {
                var reply = 0;

                eventPos = GetSafeDropPosition(RandomDropPosition());

                eventPos.y = GetGroundPosition(eventPos);

                if (reply == 0) { }

                foreach (var monument in monuments)
                {
                    if (Vector3.Distance(eventPos, monument) < 150f)
                    {
                        eventPos = Vector3.zero;
                        break;
                    }
                }
            }

            return eventPos;
        }

        Vector3 GetSafeDropPosition(Vector3 position)
        {
            RaycastHit hit;
            position.y += 200f;
            int blockedMask = LayerMask.GetMask(new[] { "Player (Server)", "Trigger", "Prevent Building" });
            var BlockedLayers = new List<int> { (int)Layer.Water, (int)Layer.Construction, (int)Layer.Trigger, (int)Layer.Prevent_Building, (int)Layer.Deployed, (int)Layer.Tree };
            if (Physics.Raycast(position, Vector3.down, out hit))
            {
                if (hit.collider?.gameObject == null) return Vector3.zero;
                string ColName = hit.collider.name;
                if (!BlockedLayers.Contains(hit.collider.gameObject.layer) && ColName != "MeshColliderBatch" && ColName != "iceberg_3" && ColName != "iceberg_2" && !ColName.Contains("rock_cliff"))
                {
                    position.y = Mathf.Max(hit.point.y, TerrainMeta.HeightMap.GetHeight(position));
                    var colliders = Pool.GetList<Collider>();
                    Vis.Colliders(position, 1, colliders, blockedMask, QueryTriggerInteraction.Collide);
                    bool blocked = colliders.Count > 0;
                    Pool.FreeList<Collider>(ref colliders);
                    if (!blocked) return position;
                }
            }

            return Vector3.zero;
        }

        Vector3 RandomDropPosition()
        {
            var vector = Vector3.zero;
            var filter = new SpawnFilter();
            float num = 1000f, x = TerrainMeta.Size.x / 3;
            do
            {
                vector = Vector3Ex.Range(-x, x);
            }
            while (filter.GetFactor(vector) == 0f && (num -= 1f) > 0f);
            float max = TerrainMeta.Size.x / 2;
            float height = TerrainMeta.HeightMap.GetHeight(vector);
            vector.y = height;
            return vector;
        }

        [ConsoleCommand("ctf")]
        void CTFManualcmd(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin) return;

            if (ctfEvent == null)
            {
                ctfEvent = new GameObject().AddComponent<CTFEvent>();
                ctfEvent.CrateEvent();
                NextTick(DrawPlayerTop);

                foreach (var pl in BasePlayer.activePlayerList)
                    SendReply(pl, GetMsg("manualstart", pl).Replace("{time}", config.FlagHoldingTime.ToString()));

                PrintWarning($"Manual Event Started");
            }
            else
            {
                UnityEngine.Object.Destroy(ctfEvent);
                ctfEvent = new GameObject().AddComponent<CTFEvent>();
                ctfEvent.CrateEvent();
                NextTick(DrawPlayerTop);

                foreach (var pl in BasePlayer.activePlayerList)
                    SendReply(pl, GetMsg("manualrestart", pl).Replace("{time}", config.FlagHoldingTime.ToString()));
                PrintWarning($"Manual Event Started");
            }
        }

        [ChatCommand("ctf")]
        void CTFManual(BasePlayer player)
        {
            if (!player.IsAdmin) return;

            if (ctfEvent == null)
            {
                ctfEvent = new GameObject().AddComponent<CTFEvent>();
                ctfEvent.CrateEvent(player.transform.position);
                NextTick(DrawPlayerTop);

                foreach (var pl in BasePlayer.activePlayerList)
                    SendReply(pl, GetMsg("manualstart", pl).Replace("{time}", config.FlagHoldingTime.ToString()));
            }
            else
            {
                UnityEngine.Object.Destroy(ctfEvent);
                ctfEvent = new GameObject().AddComponent<CTFEvent>();
                ctfEvent.CrateEvent(player.transform.position);
                NextTick(DrawPlayerTop);

                foreach (var pl in BasePlayer.activePlayerList)
                    SendReply(pl, GetMsg("manualrestart", pl).Replace("{time}", config.FlagHoldingTime.ToString()));
            }
        }

        void StartEvent()
        {
            if (ctfEvent != null)
            {
                return;
            }

            if (config.MininamOnline > BasePlayer.activePlayerList.Count)
            {
                StartNextEvent();
                return;
            }

            PrintWarning("CTF Event STARTED");
            ctfEvent = new GameObject().AddComponent<CTFEvent>();
            ctfEvent.CrateEvent();
            NextTick(DrawPlayerTop);

            foreach (var player in BasePlayer.activePlayerList)
                SendReply(player, GetMsg("autostart", player).Replace("{time}", config.FlagHoldingTime.ToString()));
        }

        void StartNextEvent()
        {
            timer.In(config.NextTime * 60f, StartEvent);
        }

        void OnDoorClosed(Door door, BasePlayer player)
        {
            if (ctfEvent != null && player.GetComponentInChildren<CTFEvent>() && !config.CanOpenDoor)
            {
                if (!door.IsOpen())
                    door.SetOpen(true);

                SendReply(player, GetMsg("canclosedoor", player));
            }
        }

        void OnDoorOpened(Door door, BasePlayer player)
        {
            if (ctfEvent != null && player.GetComponentInChildren<CTFEvent>() && !config.CanOpenDoor)
            {
                if (door.IsOpen())
                    door.CloseRequest();

                SendReply(player, GetMsg("canopendoor", player));
            }
        }

        object CanMountEntity(BasePlayer player, BaseMountable entity)
        {
            if (ctfEvent != null && player.GetComponentInChildren<CTFEvent>() && !config.CanUseVehicle)
            {
                SendReply(player, GetMsg("canvehicle", player));
                return false;
            }

            return null;
        }

        object CanBuild(Planner planner, Construction prefab, Construction.Target target)
        {
            if (planner == null || prefab == null || target.GetWorldPosition() == null || planner.GetOwnerPlayer()?.GetActiveItem() == null) return null;
            var player = planner.GetOwnerPlayer();

            if (ctfEvent != null)
            {
                if (player.GetComponentInChildren<CTFEvent>() && !config.CanBuild)
                {
                    SendReply(player, GetMsg("canbuild", player));
                    return false;
                }
                if (config.CanBuildRadius > 0)
                {
                    if (Vector3.Distance(target.position, ctfEvent.GetPos()) <= config.CanBuildRadius)
                    {
                        SendReply(player, GetMsg("closeBiuld", player));
                        return false;
                    }
                }
            }

            return null;
        }

        object OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            if (player.GetComponentInChildren<CTFEvent>())
            {
                if (config.ResetSumTime)
                    ctfTime[player] = 0;

                var pos = player.transform.position;
                pos.y = GetGroundPosition(pos);
                ctfEvent.UnParrentPlayer(pos);
                CuiHelper.DestroyUi(player, "CaptureInfo");

                foreach (var pl in BasePlayer.activePlayerList)
                    SendReply(pl, GetMsg("flagloss", pl).Replace("{displayName}", player.displayName));
            }

            return null;
        }

        void DrawPlayerTop()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                ctfTime[player] = 0;
                DrawTopPanel(player);
            }
        }
        Dictionary<BasePlayer, float> ctfTime = new Dictionary<BasePlayer, float>();
        void DrawTopPanel(BasePlayer player)
        {
            var container = new CuiElementContainer();
            container.Add(new CuiElement()
            {
                Parent = "Hud",
                Name = "TopPanel.BG",
                Components =
                {
                    new CuiImageComponent{Color = "1 1 1 0.1", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat"},
                    new CuiRectTransformComponent{AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-240 -250", OffsetMax = "-10 -50"}
                }
            });
            container.Add(new CuiElement()
            {
                Parent = "TopPanel.BG",
                Name = "Header",
                Components =
                {
                    new CuiTextComponent{Text = "CTF TOP", Align = TextAnchor.MiddleCenter, Color = "1 1 1 0.65", FontSize = 22, Font = "permanentmarker.ttf"},
                    new CuiRectTransformComponent { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-120 -35", OffsetMax = "120 0"}
                }
            });

            CuiHelper.DestroyUi(player, "TopPanel.BG");
            CuiHelper.AddUi(player, container);
        }

        void RedrawTopPlayers()
        {
            if (ctfEvent == null) return;
            var container = new CuiElementContainer();
            var gaph = 0;
            int pos = 1;
            container.Add(new CuiElement()
            {
                Parent = "TopPanel.BG",
                Name = "TopPanel",
                Components =
                    {
                        new CuiImageComponent{Color = "1 1 1 0.0"},
                        new CuiRectTransformComponent{AnchorMin = "0 0", AnchorMax = "1 1"}
                    }
            });
            foreach (var ctf in ctfTime.OrderByDescending(x => x.Value).Take(5))
            {
                container.Add(new CuiElement()
                {
                    Parent = "TopPanel",
                    Name = "TopPlayer",
                    Components =
                        {
                            new CuiTextComponent{Text = $"{pos}. {string.Join("",ctf.Key.displayName.Take(10))} : {(ctf.Value > 0 ? TimeSpan.FromSeconds(ctf.Value).ToShortString() : "00:00:00")}", Align = TextAnchor.MiddleLeft, Color = "1 1 1 0.65", FontSize = 17, Font = "permanentmarker.ttf"},
                            new CuiOutlineComponent{Color = "0 0 0 1", Distance = "0.1 0.1"},
                            new CuiRectTransformComponent { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = $"-110 -{65 + gaph}", OffsetMax = $"115 -{35 + gaph}"}
                        }
                });
                pos++;
                gaph += 30;

                container.Add(new CuiElement()
                {
                    Parent = "TopPanel",
                    Name = "EventTime",
                    Components =
                    {
                        new CuiTextComponent{Text = ctfEvent.GetEventTime(), Align = TextAnchor.MiddleCenter, Color = "1 1 1 0.65", FontSize = 22},
                        new CuiOutlineComponent{Color = "0 0 0 1", Distance = "0.5 0.5"},
                        new CuiRectTransformComponent{AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-100 -35", OffsetMax = "100 -5"}
                    }
                });
            }
            foreach (var player in BasePlayer.activePlayerList.ToArray())
            {
                CuiHelper.DestroyUi(player, "TopPanel");
                CuiHelper.AddUi(player, container);
            }
        }
        private float GetGroundPosition(Vector3 pos)
        {
            float y = TerrainMeta.HeightMap.GetHeight(pos);
            RaycastHit hit;
            if (Physics.Raycast(new Vector3(pos.x, pos.y + 200f, pos.z), Vector3.down, out hit, Mathf.Infinity,
                LayerMask.GetMask(new[] { "Terrain", "World", "Default", "Construction", "Deployed" })) && !hit.collider.name.Contains("rock_cliff")) return Mathf.Max(hit.point.y, y);
            return y;
        }

        void HookUnsubscribe(string method)
        {
            Unsubscribe(method);
        }

        void HookSubscribe(string method)
        {
            Subscribe(method);
        }

        void OnEntityEnter(TriggerBase trigger, BaseEntity entity)
        {
            var player = entity.ToPlayer();
            if (trigger.name == "SafeZone" && player != null)
            {
                if (ctfEvent != null)
                {
                    if (player.GetComponentInChildren<CTFEvent>())
                    {
                        var pos = trigger.transform.position - player.transform.position;
                        var targetPos = player.transform.position + (pos / pos.magnitude) * (Vector3.Distance(player.GetComponentInChildren<CTFEvent>().transform.position, player.transform.position) - 5f);
                        targetPos.y = ins.GetGroundPosition(targetPos);
                        player.GetComponentInChildren<CTFEvent>().Drop(targetPos);
                        Puts($"Targetpos: {targetPos} : Center {trigger.transform.position}");
                    }
                }
            }
        }

        class CTFMarker : FacepunchBehaviour
        {
            MapMarkerGenericRadius mapMarker;
            VendingMachineMapMarker MarkerT;
            public static CTFMarker marker;


            public void UpdateMarker()
            {
                mapMarker.SendUpdate();
            }

            void Awake()
            {
                marker = this;
                mapMarker = (MapMarkerGenericRadius)GameManager.server.CreateEntity("assets/prefabs/tools/map/genericradiusmarker.prefab");
                mapMarker.enableSaving = false;
                mapMarker.globalBroadcast = true;
                mapMarker.Spawn();
                mapMarker.radius = 0.2f;
                mapMarker.alpha = 1f;
                UnityEngine.Color color = new UnityEngine.Color(0.58f, 0.18f, 0.11f, 1.00f);
                UnityEngine.Color color2 = new UnityEngine.Color(0, 0, 0, 0);
                mapMarker.color1 = color;
                mapMarker.color2 = color2;
                mapMarker.SendUpdate();

                MarkerT = GameManager.server.CreateEntity("assets/prefabs/deployable/vendingmachine/vending_mapmarker.prefab") as VendingMachineMapMarker;
                MarkerT.markerShopName = "CTF";
                MarkerT.enableSaving = false;
                MarkerT.globalBroadcast = true;
                MarkerT.Spawn();
            }

            void FixedUpdate()
            {
                if (mapMarker == null || MarkerT == null) return;

                mapMarker.transform.position = gameObject.transform.position;
                MarkerT.transform.position = gameObject.transform.position;

                mapMarker.SendNetworkUpdate();
                MarkerT.SendNetworkUpdate();
            }

            void OnDestroy()
            {
                if (MarkerT?.IsDestroyed == false)
                    MarkerT?.Kill();

                if (mapMarker?.IsDestroyed == false)
                    mapMarker?.Kill();

                Destroy(this);
            }
        }
        [PluginReference]
        Plugin ImageLibrary;

        CTFEvent ctfEvent;
        class CTFEvent : FacepunchBehaviour
        {
            BaseEntity flag;
            BasePlayer capturePlayer;
            SphereCollider captureZone;
            CTFMarker markers;

            public BaseEntity GetFlagEntity() => flag;

            void CheckBuildingPrivlidge()
            {
                if (capturePlayer == null) return;

                var bp = capturePlayer.GetBuildingPrivilege();
                if (bp == null) return;

                var pos = bp.transform.position - capturePlayer.transform.position;
                var targetPos = capturePlayer.transform.position + (pos / pos.magnitude) * (Vector3.Distance(transform.position, capturePlayer.transform.position) - 5f);
                targetPos.y = ins.GetGroundPosition(targetPos);
                Drop(targetPos);
            }

            public void StopDrop()
            {
                processLenght = 2f;
                CuiHelper.DestroyUi(capturePlayer, "CapruteBG");
            }

            public void StartDrop()
            {
                processLenght = 2f;
                DrawDropUI();
            }

            public void DropProcess()
            {
                processLenght += Time.fixedDeltaTime * 120;
                DrawProcessLine();
                if (processLenght >= 298)
                    Drop();
            }

            public void Drop(Vector3 pos = new Vector3())
            {
                foreach (var pl in BasePlayer.activePlayerList)
                    ins.SendReply(pl, ins.GetMsg("flagdroped", pl).Replace("{displayName}", capturePlayer.displayName));

                CuiHelper.DestroyUi(capturePlayer, "CapruteBG");
                CuiHelper.DestroyUi(capturePlayer, "CaptureInfo");
                processLenght = 2;

                if (pos == new Vector3())
                    pos = capturePlayer.transform.position;

                var posY = ins.GetGroundPosition(capturePlayer.transform.position);
                pos.y = posY;
                capturePlayer = null;
                isGrap = false;
                capruting = false;
                gameObject.transform.SetParent(null, true);
                flag.SetParent(null, true, true);

                gameObject.transform.position = pos;
                flag.transform.position = pos + Vector3.up * 10;
                ins.HookUnsubscribe(nameof(OnPlayerInput));
            }

            public void UnParrentPlayer(Vector3 pos)
            {
                processLenght = 2;
                capturePlayer = null;
                isGrap = false;
                capruting = false;
                gameObject.transform.SetParent(null, true);
                flag.SetParent(null, true, true);

                gameObject.transform.position = pos;
                flag.transform.position = pos + Vector3.up * 10;
                ins.HookUnsubscribe(nameof(OnPlayerInput));
            }

            float eventTime = 0;

            void DrawCatureHelp()
            {
                if (!ins.config.CanDrop) return;

                var container = new CuiElementContainer();
                container.Add(new CuiElement()
                {
                    Parent = "TopPanel.BG",
                    Name = "CaptureInfo",
                    Components =
                    {
                        new CuiTextComponent{Color = "1 1 1 0.65", Text= "Hold <color=red>E</color> to drop the Flag", Align= TextAnchor.MiddleCenter, FontSize = 12},
                        new CuiOutlineComponent{Color = "0 0 0 1", Distance = "0.5 0.5"},
                        new CuiRectTransformComponent{AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-100 -85", OffsetMax = "100 -55"}
                    }
                });

                CuiHelper.DestroyUi(capturePlayer, "CaptureInfo");

                CuiHelper.AddUi(capturePlayer, container);
            }

            public void CrateEvent(Vector3 pos = new Vector3())
            {
                ins.HookSubscribe(nameof(OnEntityTakeDamage));

                eventTime = ins.config.EventTime * 60f;
                var posEvent = pos == new Vector3() ? ins.GetEventPosition() : pos;
                gameObject.transform.position = posEvent;
                flag = GameManager.server.CreateEntity("assets/prefabs/deployable/signs/sign.hanging.banner.large.prefab", posEvent + Vector3.up * 10);
                flag.globalBroadcast = true;
                flag.Spawn();

                flag.EnableGlobalBroadcast(true);
                Destroy(flag.GetComponent<DestroyOnGroundMissing>());
                Destroy(flag.GetComponent<GroundWatch>());
                var banner = flag.GetComponent<Signage>();
                banner.EnsureInitialized();
                if (!string.IsNullOrEmpty(ins.config.FlagImage))
                    banner.textureIDs[0] = ins.ImageLibrary.Call<uint>("GetImage", "flagImage");
                banner.SendNetworkUpdate();
                flag.SetFlag(BaseEntity.Flags.Locked, true);

                captureZone = gameObject.AddComponent<SphereCollider>();
                captureZone.gameObject.layer = (int)Layer.Reserved1;
                captureZone.isTrigger = true;
                captureZone.radius = 3f;

                markers = new GameObject().AddComponent<CTFMarker>();
                markers.transform.position = flag.transform.position;
            }

            void DrawCaptureUI()
            {
                var container = new CuiElementContainer();
                container.Add(new CuiElement()
                {
                    Parent = "Hud.Menu",
                    Name = "CapruteBG",
                    Components =
                    {
                        new CuiImageComponent{Color = "1 1 1 0.3", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat"},
                        new CuiRectTransformComponent{AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-150 150", OffsetMax = "150 170"}
                    }
                });
                container.Add(new CuiElement()
                {
                    Parent = "CapruteBG",
                    Name = "Title",
                    Components =
                    {
                        new CuiTextComponent{Text = ins.GetMsg("captyring", capturePlayer), Color = "1 1 1 00.65", Align = TextAnchor.MiddleCenter, FontSize = 28, Font = "robotocondensed-regular.ttf"},
                        new CuiRectTransformComponent{AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-150 5", OffsetMax = "150 45"}
                    }
                });

                container.Add(new CuiElement()
                {
                    Parent = "CapruteBG",
                    Name = "Img",
                    Components =
                    {
                        new CuiImageComponent{Sprite = "assets/icons/stopwatch.png"},
                        new CuiRectTransformComponent{AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "-35 -15", OffsetMax = "-5 15"}
                    }
                });
                CuiHelper.DestroyUi(capturePlayer, "CapruteBG");

                CuiHelper.AddUi(capturePlayer, container);
                DrawProcessLine();
            }
            void DrawDropUI()
            {
                var container = new CuiElementContainer();
                container.Add(new CuiElement()
                {
                    Parent = "Hud.Menu",
                    Name = "CapruteBG",
                    Components =
                    {
                        new CuiImageComponent{Color = "1 1 1 0.3", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat"},
                        new CuiRectTransformComponent{AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-150 150", OffsetMax = "150 170"}
                    }
                });
                container.Add(new CuiElement()
                {
                    Parent = "CapruteBG",
                    Name = "Title",
                    Components =
                    {
                        new CuiTextComponent{Text = ins.GetMsg("dropping", capturePlayer), Color = "1 1 1 00.65", Align = TextAnchor.MiddleCenter, FontSize = 28, Font = "robotocondensed-regular.ttf"},
                        new CuiRectTransformComponent{AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-150 5", OffsetMax = "150 45"}
                    }
                });

                container.Add(new CuiElement()
                {
                    Parent = "CapruteBG",
                    Name = "Img",
                    Components =
                    {
                        new CuiImageComponent{Sprite = "assets/icons/stopwatch.png"},
                        new CuiRectTransformComponent{AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "-35 -15", OffsetMax = "-5 15"}
                    }
                });
                CuiHelper.DestroyUi(capturePlayer, "CapruteBG");

                CuiHelper.AddUi(capturePlayer, container);
                DrawProcessLine();
            }
            float processLenght = 2;
            void DrawProcessLine()
            {
                var container = new CuiElementContainer();
                container.Add(new CuiElement()
                {
                    Parent = "CapruteBG",
                    Name = "ProcessLine",
                    Components =
                    {
                        new CuiImageComponent{Color = "0 1 0 0.3", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat"},
                        new CuiRectTransformComponent{AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "2 -8", OffsetMax = $"{processLenght} 8"}
                    }
                });
                CuiHelper.DestroyUi(capturePlayer, "ProcessLine");
                CuiHelper.AddUi(capturePlayer, container);
            }
            bool capruting = false;
            bool isGrap = false;

            public string GetEventTime()
            {
                string time = TimeSpan.FromSeconds(eventTime).ToShortString();

                if (isGrap && ins.config.FreezTime)
                {
                    time = $"<color=#9F0000FF>{TimeSpan.FromSeconds(eventTime).ToShortString()}</color>";
                }

                return time;

            }

            void Update()
            {
                if (flag == null) return;

                markers.transform.position = flag.transform.position;

                if (!isGrap || !ins.config.FreezTime)
                    eventTime -= Time.deltaTime;

                if (flag.IsDestroyed)
                {
                    Destroy(this);
                    return;
                }

                flag.transform.RotateAround(gameObject.transform.position, Vector3.up, Time.deltaTime * 60);
                flag.SendNetworkUpdateImmediate();

                if (eventTime <= 0)
                {
                    EndEvent();
                    return;
                }

                if (capturePlayer == null) return;
                CheckBuildingPrivlidge();
                if (capruting)
                {
                    if (capturePlayer.IsDead() || !capturePlayer.IsConnected || capturePlayer.isMounted)
                    {
                        processLenght = 2;
                        CuiHelper.DestroyUi(capturePlayer, "CapruteBG");
                        capturePlayer = null;
                        isGrap = false;
                        capruting = false;
                        gameObject.transform.SetParent(null, true);
                        flag.SetParent(null, true, true);
                        ins.HookUnsubscribe(nameof(OnPlayerInput));
                        return;
                    }

                    processLenght += Time.deltaTime * UnityEngine.Random.value * ins.config.CapturingSpeed;
                    DrawProcessLine();
                    if (processLenght >= 298)
                    {
                        capruting = false;

                        foreach (var player in BasePlayer.activePlayerList)
                            ins.SendReply(player, ins.GetMsg("capturplayer", player).Replace("{displayName}", capturePlayer.displayName));

                        CuiHelper.DestroyUi(capturePlayer, "CapruteBG");

                        gameObject.transform.SetParent(capturePlayer.transform);
                        gameObject.transform.position = capturePlayer.transform.position;
                        gameObject.transform.localPosition = new Vector3();

                        flag.gameObject.Identity();
                        flag.SetParent(capturePlayer, "spine_END", false);
                        flag.transform.localPosition = Vector3.up * 10;
                        flag.transform.localRotation = new Quaternion();

                        isGrap = true;

                        if (ins.config.CanDrop)
                            ins.HookSubscribe(nameof(OnPlayerInput));

                        DrawCatureHelp();
                    }
                }
                if (isGrap)
                {
                    if (capturePlayer.IsDead() || !capturePlayer.IsConnected)
                    {
                        processLenght = 2;
                        CuiHelper.DestroyUi(capturePlayer, "CapruteBG");
                        CuiHelper.DestroyUi(capturePlayer, "CaptureInfo");
                        capturePlayer = null;
                        isGrap = false;
                        capruting = false;
                        gameObject.transform.SetParent(null, true);
                        flag.SetParent(null, true, true);

                        ins.HookUnsubscribe(nameof(OnPlayerInput));
                        return;
                    }

                    ins.ctfTime[capturePlayer] += Time.deltaTime;
                    if (ins.ctfTime[capturePlayer] >= ins.config.FlagHoldingTime * 60f)
                    {
                        GetWinner();
                    }
                }
            }

            void GetWinner(ulong playerid = 0)
            {
                foreach (var player in BasePlayer.activePlayerList)
                    ins.SendReply(player, ins.GetMsg("winnerplayer", player).Replace("{displayName}", capturePlayer.displayName));

                string msg = "‌﻿‌​‍‍";
                msg = $"{ins.GetMsg("winprizeinfo", capturePlayer)}\n";
                foreach (var it in ins.config.customItems)
                {
                    if (!string.IsNullOrEmpty(it.Command))
                    {
                        string cmd = "";
                        cmd = it.Command.Replace("%STEAMID%", capturePlayer.UserIDString);
                        ins.rust.RunServerCommand(cmd);
                        if (!string.IsNullOrEmpty(it.Description))
                            msg += $"{it.Description}\n";
                    }
                    else if (!string.IsNullOrEmpty(it.ShortName))
                    {
                        Item item = ItemManager.CreateByName(it.ShortName, it.Amount, it.SkinID);
                        if (string.IsNullOrEmpty(it.CustomName))
                            item.name = it.CustomName;
                        capturePlayer.GiveItem(item);
                        if (!string.IsNullOrEmpty(it.Description))
                            msg += $"{it.Description.Replace("{amount}", item.amount.ToString())}\n";
                    }
                }
                ins.SendReply(capturePlayer, msg);
                ins.HookUnsubscribe(nameof(OnEntityTakeDamage));
                ins.HookUnsubscribe(nameof(OnPlayerInput));
                ins.StartNextEvent();
                OnDestroy();
            }

            void EndEvent()
            {
                if (ins.config.CanMaxTimeWin)
                {
                    var winner = ins.ctfTime.OrderByDescending(x => x.Value).FirstOrDefault(x => x.Key.IsConnected && x.Value > 0).Key;

                    if (winner != null)
                    {
                        foreach (var player in BasePlayer.activePlayerList)
                            ins.SendReply(player, ins.GetMsg("winnerplayer", player).Replace("{displayName}", capturePlayer.displayName));

                        string msg = $"{ins.GetMsg("winprizeinfo", capturePlayer)}\n";
                        foreach (var it in ins.config.customItems)
                        {
                            if (!string.IsNullOrEmpty(it.Command))
                            {
                                string cmd = "";
                                cmd = it.Command.Replace("%STEAMID%", winner.UserIDString);
                                ins.rust.RunServerCommand(cmd);
                                if (!string.IsNullOrEmpty(it.Description))
                                    msg += $"{it.Description}\n";
                            }
                            else if (!string.IsNullOrEmpty(it.ShortName))
                            {
                                Item item = ItemManager.CreateByName(it.ShortName, it.Amount, it.SkinID);
                                if (string.IsNullOrEmpty(it.CustomName))
                                    item.name = it.CustomName;
                                winner.GiveItem(item);
                                if (!string.IsNullOrEmpty(it.Description))
                                    msg += $"{it.Description.Replace("{amount}", item.amount.ToString())}\n";
                            }
                        }
                        ins.SendReply(winner, msg);
                    }
                    else
                        foreach (var player in BasePlayer.activePlayerList)
                            ins.SendReply(player, ins.GetMsg("endnowinner", player));
                }
                else
                    foreach (var player in BasePlayer.activePlayerList)
                        ins.SendReply(player, ins.GetMsg("endnowinner", player));


                ins.HookUnsubscribe(nameof(OnEntityTakeDamage));
                ins.HookUnsubscribe(nameof(OnPlayerInput));
                ins.StartNextEvent();
                OnDestroy();
            }

            public Vector3 GetPos() => flag.transform.position;

            void OnTriggerEnter(Collider col)
            {
                if (col.name.Contains("npc")) return;
                BasePlayer player = col?.GetComponentInParent<BasePlayer>();
                if (player != null && player.userID.IsSteamId() && !player.isMounted)
                {
                    if (capturePlayer == null)
                    {
                        processLenght = 2;
                        capturePlayer = player;
                        DrawCaptureUI();
                        isGrap = false;
                        capruting = true;
                    }
                }
            }

            void OnTriggerStay(Collider col)
            {
                BasePlayer player = col?.GetComponentInParent<BasePlayer>();
                if (player == null || player.IsNpc || player.IsDead()) return;
                OnTriggerEnter(col);
            }

            void OnTriggerExit(Collider col)
            {
                if (col.name.Contains("npc")) return;
                BasePlayer player = col?.GetComponentInParent<BasePlayer>();
                if (player != null)
                {
                    if (capturePlayer == player)
                    {
                        //capturePlayer.EnableGlobalBroadcast(false);
                        capturePlayer = null;
                        CuiHelper.DestroyUi(player, "CapruteBG");
                        isGrap = false;
                        capruting = false;
                        ins.HookUnsubscribe(nameof(OnPlayerInput));
                    }
                }
            }

            void OnDestroy()
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    CuiHelper.DestroyUi(player, "TopPanel.BG");
                    CuiHelper.DestroyUi(player, "CapruteBG");
                }

                Destroy(markers);

                if (flag?.IsDestroyed == false)
                {
                    flag?.Kill();
                }

                Destroy(captureZone);
                Destroy(this);
            }

        }

        string GetMsg(string key, BasePlayer player = null)
        {
            return lang.GetMessage(key, this, player == null ? null : player.UserIDString);
        }

        void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["endnowinner"] = "The event is over. The winners have not been determined",
                ["commandbanned"] = "You can not use commands when a flag is in your hands.",
                ["winprizeinfo"] = "For winning the event, you received:",
                ["winnerplayer"] = "Player {displayName} won the Capture the Flag event",
                ["capturplayer"] = "The flag was captured by the player {displayName}",
                ["captyring"] = "CAPTURE",
                ["dropping"] = "Dropping the Flag",
                ["flagloss"] = "Player {displayName} loss the Flag.",
                ["canbuild"] = "Your hands are busy with the flag, you can not build!",
                ["closeBiuld"] = "You can not build close to the flag!",
                ["canvehicle"] = "You can't get into a transport with a flag",
                ["canopendoor"] = "You can't open the doors, your hands are busy with the flag",
                ["canclosedoor"] = "You can't close the doors, your hands are busy with the flag",
                ["autostart"] = "The CAPTURE THE FLAG event has been STARTED!\nThe location is marked on the map!\nHold the flag for {time} min. and get a reward",
                ["manualstart"] = "The Flag Capture event was launched by the Administrator!\nThe location is marked on the map!\nHold the flag for {time} min. and get a reward",
                ["manualrestart"] = "Event Capture Flag has been restarted by the Administrator!\nThe location is marked on the map!\nHold the flag for {time} min. and get a reward",
                ["flagdroped"] = "Player {displayName} drop the Flag."

            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["endnowinner"] = "Ивент закончен.\nПобедители не определены.",
                ["commandbanned"] = "Нельзя использовать команды когда в руках находится флаг. ",
                ["winprizeinfo"] = "За победу на ивенте Вы получили:",
                ["winnerplayer"] = "Игрок {displayName} победил в ивенте Захват Флага",
                ["capturplayer"] = "Флаг захвачен игроком {displayName}",
                ["captyring"] = "ЗАХВАТ",
                ["dropping"] = "Сброс флага",
                ["flagloss"] = "Игрок {displayName} потерял флаг.",
                ["canbuild"] = "Ваши руки заняты флагом, строить нельзя!",
                ["closeBiuld"] = "Нельзя строить рядом с флагом!",
                ["canvehicle"] = "С флагом нельзя садиться в транспорт",
                ["canopendoor"] = "Нельзя открыть двери, руки заняты флагом",
                ["canclosedoor"] = "Нельзя закрыть двери, руки заняты флагом",
                ["autostart"] = "Запущен ивента ЗАХВАТ ФЛАГА!\nМестоположение отмечено на карте!\nУдержите флаг в течении {time} мин. и получите награду",
                ["manualstart"] = "Ивента Захват Флага запущен Администратором!\nМестоположение отмечено на карте!\nУдержите флаг в течении {time} мин. и получите награду",
                ["manualrestart"] = "Ивента Захват Флага перезапущен Администратором!\nМестоположение отмечено на карте!\nУдержите флаг в течении {time} мин. и получите награду",
                ["flagdroped"] = "Игрок {displayName} бросил флаг."

            }, this, "ru");
        }
    }
}


// --- End of file: CTF.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/RemoveAAA.cs ---
// --- Original Local Path: KualaRust/RemoveAAA.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;
using System.Collections;
using System;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("RemoveAAA", "Tuntenfisch", "0.4.6", ResourceId = 1645)]
    [Description("Removes admin abuse announcements!")]
    class RemoveAAA : RustPlugin
    {
        #region Fields
        List<string> itemBlackList;
        #endregion

        #region Hooks
        /// <summary>
        /// Effectively, the entry point for this plugin.
        /// </summary>
        void OnServerInitialized()
        {
            LoadConfig();

            lang.RegisterMessages(new Dictionary<string, string>()
            {
                { "missing permission", "You are missing the necessary permission to do that!" },
                { "invalid item", "Invalid item!" },
                { "couldn't give item", "Couldn't give item!" },
                { "black listed item", "Item is black listed!" },
                { "couldn't find player", "Couldn't find player!" }
            }, this);

            RegisterPermissions("give", "giveall", "givearm", "givebp", "givebpall", "giveid", "giveto");
        }

        /// <summary>
        /// Overrides the command handling system if a command has been entered that would issue an admin abuse announcement.
        /// </summary>
        /// <param name="arg"> The console argument containing information about the command.</param>
        /// <returns> An object that determines whether the command handling system should be overriden or not.</returns>
        object OnServerCommand(ConsoleSystem.Arg arg)
        {
            if (arg == null || arg.cmd == null) return null;

            string command = arg.cmd.Name;

            // give
            if (command.Equals("give"))
            {
                if (!HasPermission(arg, "give"))
                {
                    if (arg.Player())
                    {
                        arg.Player().ChatMessage(lang.GetMessage("missing permission", this));
                    }
                    return true;
                }
                BasePlayer player = arg.Player();
                if (!player) return true;

                Item item = ItemManager.CreateByPartialName(arg.GetString(0), 1);
                if (item == null)
                {
                    if (arg.Player())
                    {
                        arg.Player().ChatMessage(lang.GetMessage("invalid item", this));
                    }
                    return true;
                }
                if (itemBlackList.Contains(item.info.shortname))
                {
                    if (arg.Player())
                    {
                        arg.Player().ChatMessage(lang.GetMessage("black listed item", this));
                    }
                    return true;
                }
                item.amount = arg.GetInt(1, 1);
                if (!player.inventory.GiveItem(item, null))
                {
                    item.Remove(0f);
                    if (arg.Player())
                    {
                        arg.Player().ChatMessage(lang.GetMessage("couldn't give item", this));
                    }
                    return true;
                }
                player.Command("note.inv", new object[] { item.info.itemid, item.amount });
                Debug.Log(string.Concat(new object[] { "[admin] giving ", player.displayName, " ", item.amount, " x ", item.info.displayName.english }));
                return true;
            }

            // giveall
            else if (command.Equals("giveall"))
            {
                if (!HasPermission(arg, "giveall"))
                {
                    if (arg.Player())
                    {
                        arg.Player().ChatMessage(lang.GetMessage("missing permission", this));
                    }
                    return true;
                }
                foreach (BasePlayer player in BasePlayer.activePlayerList)
                {
                    Item item = ItemManager.CreateByPartialName(arg.GetString(0), 1);
                    if (item != null)
                    {
                        if (!itemBlackList.Contains(item.info.shortname))
                        {
                            item.amount = arg.GetInt(1, 1);
                            if (player.inventory.GiveItem(item, null))
                            {
                                player.Command("note.inv", new object[] { item.info.itemid, item.amount });
                                Debug.Log(string.Concat(new object[] { "[admin] giving ", player.displayName, " ", item.amount, " x ", item.info.displayName.english }));
                                return true;
                            }
                            else
                            {
                                item.Remove(0f);
                                if (arg.Player())
                                {
                                    arg.Player().ChatMessage(lang.GetMessage("couldn't give item", this));
                                }
                                return true;
                            }
                        }
                        else
                        {
                            if (arg.Player())
                            {
                                arg.Player().ChatMessage(lang.GetMessage("black listed item", this));
                            }
                            return true;
                        }
                    }
                    else
                    {
                        if (arg.Player())
                        {
                            arg.Player().ChatMessage(lang.GetMessage("invalid item", this));
                        }
                        return true;
                    }
                }
            }

            // givearm
            else if (command.Equals("givearm"))
            {
                if (!HasPermission(arg, "givearm"))
                {
                    if (arg.Player())
                    {
                        arg.Player().ChatMessage(lang.GetMessage("missing permission", this));
                    }
                    return true;
                }
                BasePlayer player = arg.Player();
                if (!player) return true;

                Item item = ItemManager.CreateByItemID(arg.GetInt(0), 1, 0);
                if (item == null)
                {
                    if (arg.Player())
                    {
                        arg.Player().ChatMessage(lang.GetMessage("invalid item", this));
                    }
                    return true;
                }
                if (itemBlackList.Contains(item.info.shortname))
                {
                    if (arg.Player())
                    {
                        arg.Player().ChatMessage(lang.GetMessage("black listed item", this));
                    }
                    return true;
                }
                item.amount = arg.GetInt(1, 1);

                if (!player.inventory.GiveItem(item, player.inventory.containerBelt))
                {
                    item.Remove(0f);
                    if (arg.Player())
                    {
                        arg.Player().ChatMessage(lang.GetMessage("couldn't give item", this));
                    }
                    return true;
                }
                player.Command("note.inv", new object[] { item.info.itemid, item.amount });
                Debug.Log(string.Concat(new object[] { "[admin] giving ", player.displayName, " ", item.amount, " x ", item.info.displayName.english }));
                return true;
            }

            // givebp
            else if (command.Equals("givebp"))
            {
                if (!HasPermission(arg, "givebp"))
                {
                    if (arg.Player())
                    {
                        arg.Player().ChatMessage(lang.GetMessage("missing permission", this));
                    }
                    return true;
                }
                BasePlayer player = arg.Player();
                if (!player) return true;

                ItemDefinition definition = ItemManager.FindItemDefinition(arg.GetInt(0, 0));
                if (definition == null)
                {
                    if (arg.Player())
                    {
                        arg.Player().ChatMessage(lang.GetMessage("invalid item", this));
                    }
                    return true;
                }
                if (itemBlackList.Contains(definition.shortname))
                {
                    if (arg.Player())
                    {
                        arg.Player().ChatMessage(lang.GetMessage("black listed item", this));
                    }
                    return true;
                }
                player.blueprints.Unlock(definition);
                Debug.Log(string.Concat(new object[] { "[admin] ", player.displayName, " learning blueprint ", definition.displayName.english }));
                return true;
            }

            // givebpall
            else if (command.Equals("givebpall"))
            {
                if (!HasPermission(arg, "givebpall"))
                {
                    if (arg.Player())
                    {
                        arg.Player().ChatMessage(lang.GetMessage("missing permission", this));
                    }
                    return true;
                }
                ItemDefinition definition = ItemManager.FindItemDefinition(arg.GetString(0));
                if (definition == null)
                {
                    if (arg.Player())
                    {
                        arg.Player().ChatMessage(lang.GetMessage("invalid item", this));
                    }
                    return true;
                }
                if (itemBlackList.Contains(definition.shortname))
                {
                    if (arg.Player())
                    {
                        arg.Player().ChatMessage(lang.GetMessage("black listed item", this));
                    }
                    return true;
                }
                foreach (BasePlayer player in BasePlayer.activePlayerList)
                {
                    player.blueprints.Unlock(definition);
                    Debug.Log(string.Concat(new string[] { "[admin] teaching ", player.displayName, " ", definition.displayName.english, " blueprint" }));
                }
                return true;
            }

            // giveid
            else if (command.Equals("giveid"))
            {
                if (!HasPermission(arg, "giveid"))
                {
                    if (arg.Player())
                    {
                        arg.Player().ChatMessage(lang.GetMessage("missing permission", this));
                    }
                    return true;
                }
                BasePlayer player = arg.Player();
                if (!player) return true;

                Item item = ItemManager.CreateByItemID(arg.GetInt(0), 1, 0);
                if (item == null)
                {
                    if (arg.Player())
                    {
                        arg.Player().ChatMessage(lang.GetMessage("invalid item", this));
                    }
                    return true;
                }
                if (itemBlackList.Contains(item.info.shortname))
                {
                    if (arg.Player())
                    {
                        arg.Player().ChatMessage(lang.GetMessage("black listed item", this));
                    }
                    return true;
                }
                item.amount = arg.GetInt(1, 1);

                if (!player.inventory.GiveItem(item, null))
                {
                    item.Remove(0f);
                    if (arg.Player())
                    {
                        arg.Player().ChatMessage(lang.GetMessage("couldn't give item", this));
                    }
                    return true;
                }
                player.Command("note.inv", new object[] { item.info.itemid, item.amount });
                Debug.Log(string.Concat(new object[] { "[admin] giving ", player.displayName, " ", item.amount, " x ", item.info.displayName.english }));
                return true;
            }

            // giveto
            else if (command.Equals("giveto"))
            {
                if (!HasPermission(arg, "giveto"))
                {
                    if (arg.Player())
                    {
                        arg.Player().ChatMessage(lang.GetMessage("missing permission", this));
                    }
                    return true;
                }
                BasePlayer player = BasePlayer.Find(arg.GetString(0));
                if (player == null)
                {
                    if (arg.Player())
                    {
                        arg.Player().ChatMessage(lang.GetMessage("couldn't find player", this));
                    }
                    return true;
                }

                Item item = ItemManager.CreateByPartialName(arg.GetString(1), 1);
                if (item == null)
                {
                    if (arg.Player())
                    {
                        arg.Player().ChatMessage(lang.GetMessage("invalid item", this));
                    }
                    return true;
                }
                if (itemBlackList.Contains(item.info.shortname))
                {
                    if (arg.Player())
                    {
                        arg.Player().ChatMessage(lang.GetMessage("black listed item", this));
                    }
                    return true;
                }
                item.amount = arg.GetInt(2, 1);

                if (!player.inventory.GiveItem(item, null))
                {
                    item.Remove(0f);
                    if (arg.Player())
                    {
                        arg.Player().ChatMessage(lang.GetMessage("couldn't give item", this));
                    }
                    return true;
                }
                player.Command("note.inv", new object[] { item.info.itemid, item.amount });
                Debug.Log(string.Concat(new object[] { "[admin] giving ", player.displayName, " ", item.amount, " x ", item.info.displayName.english }));
                return true;
            }
            return null;
        }
        #endregion

        #region Config
        /// <summary>
        /// Provides the default values for each configuration file value for easy access.
        /// </summary>
        static class DefaultConfig
        {
            public static readonly Dictionary<string, ConfigValue> values = new Dictionary<string, ConfigValue>()
            {
                { "ItemBlackList",              new ConfigValue(GetItemBlackList(),                                                         "1. Data", "1.1 Item Black List") },
            };

            private static List<string> GetItemBlackList()
            {
                List<string> items = new List<string>()
                {
                    "flare",
                    "generator.wind.scrap"
                };
                return items;
            }
        }

        /// <summary>
        /// Wrapper for a config value.
        /// </summary>
        /// <remarks>
        /// Contains both, the config value and the corresponding path.
        /// </remarks>
        class ConfigValue
        {
            public object value { private set; get; }
            public string[] path { private set; get; }

            public ConfigValue(object value, params string[] path)
            {
                this.value = value;
                this.path = path;
            }
        }

        /// <summary>
        /// Responsible for getting a value from the configuration file.
        /// </summary>
        /// <typeparam name="T"> The type that should be returned.</typeparam>
        /// <param name="saveConfig"> Indicates whether the configuration file should be saved.</param>
        /// <param name="defaultValue"> The defaultValue that will be returned if the actual value cannot be found.</param>
        /// <param name="keys"> The keys pointing to the value which should be returned.</param>
        /// <returns> Returns either the defaultValue or the value of the configuration file associated with the provided keys.</returns>
        T GetConfig<T>(ref bool saveConfig, T defaultValue, params string[] keys)
        {
            object value = Config.Get(keys);

            // get the value associated with the provided keys and check if the value is valid
            if (!IsValueValid(value, defaultValue))
            {
                object[] objArray = new object[keys.Length + 1];
                for (int i = 0; i < keys.Length; i++)
                {
                    objArray[i] = keys[i];
                }
                objArray[keys.Length] = defaultValue;

                Config.Set(objArray);

                saveConfig = true;
                return defaultValue;
            }
            return JsonConvert.DeserializeObject<T>(JsonConvert.SerializeObject(value));
        }

        /// <summary>
        /// Overload function for getting a value from the configuration file.
        /// </summary>
        /// <typeparam name="T"> The type that should be returned.</typeparam>
        /// <param name="saveConfig"> Indicates whether the configuration file should be saved.</param>
        /// <param name="configValue"> Holds information both about the actual config value and the corresponding path.</param>
        /// <returns> Returns either the defaultValue or the value of the configuration file associated with the provided keys.</returns>
        T GetConfig<T>(ref bool saveConfig, ConfigValue configValue)
        {
            string[] keys = configValue.path;
            object defaultValue = configValue.value;

            return GetConfig(ref saveConfig, (T)defaultValue, keys);
        }

        /// <summary>
        /// Checks if a value is valid by comparing the types of two objects and checking if both objects are of the same type or not.
        /// </summary>
        /// <param name="value"> The value that needs to be checked for validity.</param>
        /// <param name="defaultValue"> The defaultValue which is used for checking if the value is valid.</param>
        /// <returns> A bool indicating whether the value is valid.</returns>
        bool IsValueValid(object value, object defaultValue)
        {
            if (value == null) return false;

            Type type = value.GetType();
            Type defaultType = defaultValue.GetType();

            if (type != defaultType && type != typeof(double) && defaultType != typeof(float))
            {
                if (type.IsGenericType && defaultType.IsGenericType)
                {
                    if (type.GetGenericTypeDefinition() != defaultType.GetGenericTypeDefinition())
                    {
                        return false;
                    }
                }
                else
                {
                    return false;
                }
            }
            return true;
        }

        /// <summary>
        /// Checks whether the configuration file contains unused keys and removes them.
        /// </summary>
        void CleanupConfig()
        {
            List<string[]> paths = new List<string[]>();

            // iterate over the current configuration file to find all existing paths
            IEnumerator enumerator = Config.GetEnumerator();
            try
            {
                while (enumerator.MoveNext())
                {
                    KeyValuePair<string, object> pair = (KeyValuePair<string, object>)enumerator.Current;

                    if (pair.Value.GetType().IsGenericType && pair.Value.GetType().GetGenericTypeDefinition() == typeof(Dictionary<,>) && ((IDictionary)pair.Value).Count != 0)
                    {
                        Dictionary<string, object> dictionary = new Dictionary<string, object>();
                        foreach (DictionaryEntry entry in (IDictionary)pair.Value)
                        {
                            dictionary.Add((string)entry.Key, entry.Value);
                        }

                        foreach (KeyValuePair<string, object> pair2 in dictionary)
                        {
                            if (pair2.Value.GetType().IsGenericType && pair2.Value.GetType().GetGenericTypeDefinition() == typeof(Dictionary<,>) && ((IDictionary)pair.Value).Count != 0)
                            {
                                Dictionary<string, object> dictionary2 = new Dictionary<string, object>();
                                foreach (DictionaryEntry entry in (IDictionary)pair2.Value)
                                {
                                    dictionary2.Add((string)entry.Key, entry.Value);
                                }

                                foreach (KeyValuePair<string, object> pair3 in dictionary2)
                                {
                                    if (char.IsDigit(pair3.Key[0]) && pair3.Key[1].Equals('.') && char.IsDigit(pair3.Key[2]) && pair3.Key[3].Equals('.') && char.IsDigit(pair3.Key[4]))
                                    {
                                        paths.Add(new string[3] { pair.Key, pair2.Key, pair3.Key });
                                    }
                                    else
                                    {
                                        paths.Add(new string[2] { pair.Key, pair2.Key });
                                        break;
                                    }
                                }
                            }
                            else
                            {
                                paths.Add(new string[2] { pair.Key, pair2.Key });
                            }
                        }
                    }
                    else
                    {
                        paths.Add(new string[1] { pair.Key });
                    }
                }
            }
            finally
            {
                ((IDisposable)enumerator).Dispose();
            }

            // iterate over the found paths and determine whether they are part of the default configuration
            foreach (string[] path in paths)
            {
                int index = -1;

                foreach (ConfigValue value in DefaultConfig.values.Values)
                {
                    if (path.Length != value.path.Length) continue;

                    for (int j = 0; j < path.Length; j++)
                    {
                        if (path[j].Equals(value.path[j]))
                        {
                            index = j > index ? j : index;
                        }
                        else
                        {
                            break;
                        }
                    }
                }
                // if a path is not part of the default configuration remove it
                if (index < path.Length - 1)
                {
                    if (index == -1)
                    {
                        Config.Remove(path[index + 1]);
                    }
                    else
                    {
                        string[] strArray = new string[index + 1];
                        for (int j = 0; j < strArray.Length; j++)
                        {
                            strArray[j] = path[j];
                        }
                        ((Dictionary<string, object>)Config.Get(strArray)).Remove(path[index + 1]);
                    }
                }
            }
        }

        /// <summary>
        /// Responsible for creating a configuration file and populating it with the required default values.
        /// </summary>
        /// <remarks>
        /// This function is called automatically by oxide if no configuration file could be found.
        /// </remarks>
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating configuration file!");

            Config.Clear();

            foreach (ConfigValue value in DefaultConfig.values.Values)
            {
                object[] objArray = new object[value.path.Length + 1];
                for (int i = 0; i < value.path.Length; i++)
                {
                    objArray[i] = value.path[i];
                }
                objArray[value.path.Length] = value.value;

                Config.Set(objArray);
            }
            SaveConfig();
        }

        /// <summary>
        /// Responsible for loading the configuration file.
        /// </summary>
        /// <seealso cref="GetConfig{T}(T, string, string, string)"/>
        new void LoadConfig()
        {
            Puts("Loading configuration file!");

            bool saveConfig = false;

            itemBlackList = GetConfig<List<string>>(ref saveConfig, DefaultConfig.values["ItemBlackList"]);

            if (saveConfig)
            {
                CleanupConfig();

                PrintWarning("Updating configuration file!");

                SaveConfig();
            }
        }
        #endregion

        #region Permissions
        /// <summary>
        /// Responsible for registering multiple permissions at once.
        /// </summary>
        /// <param name="permissions"></param>
        void RegisterPermissions(params string[] permissions)
        {
            foreach (string permission in permissions)
            {
                this.permission.RegisterPermission(Title.ToLower() + "." + permission, this);
            }
        }

        /// <summary>
        /// Checks whether a user has a permission-
        /// </summary>
        /// <param name="arg"> The console argument that needs to be checked for permissions.</param>
        /// <param name="permission"> The permission that needs to be checked.</param>
        /// <returns> A bool specifying whether the user has the given permission or not.</returns>
        bool HasPermission(ConsoleSystem.Arg arg, string permission)
        {
            if (arg.cmd.ServerAdmin && arg.Connection == null) return true;
            if (arg.Connection != null) return this.permission.UserHasPermission(arg.Connection.userid.ToString(), Title.ToLower() + "." + permission);
            return false;
        }
        #endregion
    }
}

// --- End of file: RemoveAAA.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/SkinMenu.cs ---
// --- Original Local Path: KualaRust/SkinMenu.cs ---

﻿using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using UnityEngine;
using ConVar;
using Network;
using Random = UnityEngine.Random;
using System.Collections;

namespace Oxide.Plugins
{
    [Info("SkinMenu", "fermens", "0.0.7")]
    class SkinMenu : RustPlugin
    {
        #region Config
        private PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        enum elementbutton { weapon, construction, items, attire, tool };

        class BUTTON
        {
            [JsonProperty("Название")]
            public string name;

            [JsonProperty("Предметы")]
            public string[] items;
        }

        class settext
        {
            [JsonProperty("Текст")]
            public string text;

            [JsonProperty("Размер текста")]
            public string size;
        }

        class color
        {
            [JsonProperty("Цвет нажатой кнопки")]
            public string activecolor;

            [JsonProperty("Цвет кнопки")]
            public string buttoncolor;

            [JsonProperty("Цвет основного фона")]
            public string background;

            [JsonProperty("Цвет фона подменю")]
            public string backgroundmenu;

            [JsonProperty("Цвет фона скина")]
            public string backgroundskin;

            [JsonProperty("Цвет верхней панели")]
            public string backgroundup;

            [JsonProperty("Цвет нижней панели")]
            public string backgroundfoot;

            [JsonProperty("Цвет кнопок в ремонтном верстаке")]
            public string bench;
        }

        class text
        {
            [JsonProperty("Название вверху")]
            public settext title;

            [JsonProperty("Кнопка выхода")]
            public settext exit;

            [JsonProperty("Подсказка внизу")]
            public settext pint;

            [JsonProperty("Сообщение о успешной смене скина")]
            public settext done;

            [JsonProperty("Ремонтный верстак")]
            public bench bench;
        }

        class bench
        {
            [JsonProperty("Для выбора рандомного скина")]
            public settext random;

            [JsonProperty("Для выбора основного скина")]
            public settext main;

            [JsonProperty("Для открытия скин меню")]
            public settext menu;
        }

        class priv
        {
            [JsonProperty("Включить?")]
            public bool enable;

            [JsonProperty("Премишн")]
            public string permission;

            [JsonProperty("Сообщение")]
            public string message;
        }

        private class PluginConfig
        {
            [JsonProperty("1. STEAM APIKEY (https://steamcommunity.com/dev/apikey)")]
            public string APIKEY;

            [JsonProperty("2. Настройка текста")]
            public text text;

            [JsonProperty("3. Настройка цветов")]
            public color color;

            [JsonProperty("4. Категории")]
            public Dictionary<elementbutton, BUTTON> categorys;

            [JsonProperty("5. Список скинов")]
            public Dictionary<string, List<ulong>> skins;

            [JsonProperty("6. Доступ к скинам по привилегии")]
            public priv priv;

            [JsonProperty("7. Перекрашивать скин когда берут в руки?")]
            public bool paint;

            [JsonProperty("8. Возможность перекрашивать скин в ремонтном верстаке?")]
            public bool repairbench;

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    APIKEY = "",
                    text = new text
                    {
                        bench = new bench
                        {
                            main = new settext { text = "ОСНОВНОЙ", size = "18" },
                            random = new settext { text = "РАНДОМ", size = "18" },
                            menu = new settext { text = "СКИН МЕНЮ", size = "18" }
                        },
                        done = new settext { text = "УСПЕШНО СМЕНИЛИ СКИН!", size = "30" },
                        exit = new settext { text = "ЗАКРЫТЬ", size = "26" },
                        pint = new settext { text = "Выбранный скин накладывается при крафте и в ремонтном верстаке при выборе основного скина, а так же перекрашивает предметы в инвентаре при выборе.", size = "12" },
                        title = new settext { text = "СКИН МЕНЮ", size = "26" }
                    },
                    color = new color
                    {
                        activecolor = "0 0.8 1 0.2588235",
                        buttoncolor = "1 1 1 0.2588235",
                        background = "0 0 0 0.9961886",
                        backgroundup = "0.7490196 0.7490196 0.7490196 0.1647059",
                        backgroundfoot = "0.7490196 0.7490196 0.7490196 0.1647059",
                        bench = "1 1 1 0.1176471",
                        backgroundmenu = "1 1 1 0.09772462",
                        backgroundskin = "1 1 1 0.254902"
                    },
                    categorys = new Dictionary<elementbutton, BUTTON>
                    {
                        { elementbutton.weapon, new BUTTON {  name = "Оружие", items = new string[] { "rifle.ak", "rifle.bolt", "lmg.m249", "rifle.m39", "bow.hunting", "knife.bone", "bone.club", "crossbow", "shotgun.double", "pistol.eoka", "grenade.f1", "longsword", "smg.mp5", "shotgun.pump", "pistol.semiauto", "salvaged.sword", "smg.thompson", "pistol.revolver", "rocket.launcher", "rifle.semiauto", "shotgun.waterpipe", "smg.2", "pistol.python", "rifle.lr300", "knife.combat" } } },
                        { elementbutton.construction, new BUTTON {  name = "Cтроительство", items = new string[] { "wall.frame.garagedoor", "door.double.hinged.toptier", "door.double.hinged.metal", "door.double.hinged.wood", "door.hinged.toptier", "door.hinged.metal", "door.hinged.wood", "barricade.concrete", "barricade.sandbags"} } },
                        { elementbutton.items, new BUTTON {  name ="Предметы", items = new string[] { "rug", "rug.bear", "table", "chair", "fridge", "vending.machine", "box.wooden.large", "target.reactive", "sleepingbag", "water.purifier", "box.wooden", "fun.guitar", "locker", "furnace" } } },
                        { elementbutton.attire, new BUTTON {  name ="Одежда", items = new string[] { "mask.bandana", "mask.balaclava", "hat.beenie", "burlap.shoes", "burlap.shirt", "burlap.trousers", "burlap.headwrap", "bucket.helmet", "hat.beenie", "hat.cap", "shirt.collared", "coffeecan.helmet", "deer.skull.mask", "attire.hide.skirt", "attire.hide.vest", "attire.hide.pants", "attire.hide.boots", "attire.hide.helterneck", "hoodie", "attire.hide.poncho", "burlap.gloves", "tshirt.long", "metal.plate.torso", "metal.facemask", "hat.miner", "pants", "roadsign.jacket", "roadsign.kilt", "riot.helmet", "jacket.snow", "pants.shorts", "shirt.tanktop", "tshirt", "jacket", "shoes.boots" } } },
                        { elementbutton.tool, new BUTTON {  name ="Инструменты",  items = new string[] { "rock", "hammer.salvaged", "icepick.salvaged", "explosive.satchel", "stonehatchet", "stone.pickaxe", "hammer", "hatchet", "pickaxe" } } }
                    },
                    skins = new Dictionary<string, List<ulong>>
                    {
                        { "rifle.ak", new List<ulong> { 0, 849047662, 887494035, 1359893925, 1202410378, 1372945520, 859845460, 1259716979, 1826520371, 1750654242, 809212871, 809190373, 1435827815, 1112904406, 1385673487, 1679665505, 924020531, 1349512142, 937864743, 1196676446, 875130056, 1915393587, 1174389582, 1583542371, 1102750231, 840477492, 1306351416, 885146172, 1137915903, 1245563496, 1349324364, 1929819581, 1092674304, 920472848, 1804885723, 928950425, 1448221547, 939180121, 940035827, 903882218, 1476966011, 1588206436, 1167207039, 889710179, 1362212220, 1265322092, 1364985829, 1599157678, 1575397458, 1886272847, 925720043, 1272989639, 1434027951, 908297014, 1213092632, 1428980348, 1983066869, 1457951707, 10137, 1338305091, 1118706219, 1539318940, 1760078043, 1161844853, 1522034435, 1120500163, 1685375084, 1549426268, 1907342157, 1870705926, 911726740, 1252554814, 895307805, 1352844155, 1746886322, 1288866247, 654502185, 934891737, 1175238674, 1539409946, 1372566409, 1277707212, 1396630285, 1076214414, 1882821847, 1850236015, 1230963555, 1539007965, 1088459232, 1129886223, 1124932043, 1467269924, 1659781652, 1402320927, 1324932956, 1140366289, 1159593268, 1309470544 } },
                        { "rifle.bolt", new List<ulong> { 0, 1852284996, 818403150, 1795984246, 1535660827, 1517933342, 1581664321, 897023403, 933509449, 1587273896, 875259050, 943036098, 840105253, 819149392, 972020573, 1592946955, 947954942, 1119629516, 1161165984 } },
                        { "knife.bone", new List<ulong> { 0, 808955868, 1277364396, 909612594, 945031477, 933322251 } },
                        { "bow.hunting", new List<ulong> { 0, 1729629485, 1729920243, 1729683309, 1734427277, 1747542198, 1759967280, 1773297889, 1788414884, 1793915047, 1846220912, 1876857585, 1883523860, 1885852817, 1926862937, 1974088369, 1984690140, 1988012822 } },
                        { "bone.club", new List<ulong> { 0, 1557788243, 810156739, 791109245, 888839261, 945026868 } },
                        { "lmg.m249", new List<ulong> { 0, 1707973294, 1719536313, 1712378771, 1831294069, 1992981006 } },
                        { "rifle.m39", new List<ulong> { 0, 1707880195, 1708343082, 1720530850, 1708365495, 1736532811 } },
                        { "crossbow", new List<ulong> { 0, 915855989, 1565444858, 874268567, 1961541693, 1772979668, 1242702498, 1390284445, 883141682, 818070371, 1349337546, 1181976746, 1291686117, 809964230, 1466387739, 1699027694, 1428614422, 1365706569, 1127389810, 1115959202, 1865294019, 1421675342, 1184318659, 1739935284, 1097642159, 1269230939, 1089558546, 1206661880, 1328219905, 1701173429, 856029421, 1766369967, 1559298697, 1367933148, 1408631840, 1810999666, 1383105648 } },
                        { "shotgun.double", new List<ulong> { 0, 916790605, 865019380, 1448142776, 1660175523, 1119662164, 1680595474, 1213074188, 1378519774, 948113632, 854987948, 1260964187, 1522902588, 860153737, 1414878365, 1295701369, 1408050439, 1174675399, 858957151, 1910558629, 1465627520, 1341524782, 1127266590, 1441939951, 1870693079, 1282137884, 1590495543, 1229950256, 1277558450, 1225880743, 1247696065, 1616108563, 1569952704 } },
                        { "pistol.eoka", new List<ulong> { 0, 1171935313, 856053892, 857750032, 898387222, 926184643, 1174673119, 1413731110 } },
                        { "grenade.f1", new List<ulong> { 0, 836745325, 936182773, 1163186435, 815252048 } },
                        { "furnace", new List<ulong> { 0, 1231071505, 1230386524, 1230680321, 1230539924, 1230975843, 1239083962, 1241065527, 1230272984, 1247357204, 1261530424, 1260546874, 1277183788, 1282172459, 1260305347, 1277616284, 1305743950, 1305332196, 1320779999, 1335260783, 1335598661, 1349367380, 1354714819, 1356581838, 1354629493, 1373663659, 1367939983, 1377346304, 1384844042, 1408433814, 1391109786, 1427551950, 1421455358, 1467078851, 1448350353, 1458047080, 1457061230, 1529559770, 1387619038, 1539436979, 1539005624, 1575177513, 1588458946, 1587226587, 1587959070, 1632040649, 1636919294, 1640730462, 1652555216, 1630511618, 1645019295, 1559242743, 1583218948, 1701971555, 1723387671, 1772650961, 1775718906, 1805182793, 1810979800, 1865321291, 1892656766, 1936112920, 1935093227, 1949401987, 1975322284, 1992130386 } },
                        { "longsword", new List<ulong> { 0, 1222939471, 825169057, 796733487, 831965423, 855009078, 825008040 } },
                        { "smg.mp5", new List<ulong> { 0, 1137434899, 1693898215, 904404578, 796679172, 833639834, 1637174724, 796687275, 1865099372, 911612956, 1673754411, 808554348, 892100306, 853438134, 800974015, 914624163, 1654499223, 1413917236, 1084800708, 1087199678 } },
                        { "shotgun.pump", new List<ulong> { 0, 1115399868, 1553603344, 964345579, 1153922437, 1269617539, 1666328139, 1094741003, 813631833, 813628651, 1760154042, 921253888, 1191938171, 1476013941, 1132569603, 1292063367, 1672954158, 1652348929, 850130444, 849997025, 1706897835, 731119713 } },
                        { "pistol.semiauto", new List<ulong> { 0, 902487409, 1720501333, 919535259, 883156158, 924018875, 937863988, 876007573, 1428766159, 1183693235, 1158943049, 863443112, 953126981, 910681058, 1811814491, 1105853708, 1167255900, 904356033, 893118140, 1121906926, 805925675, 1630961792, 954520976, 1113544521, 830255284, 899942580, 853927198, 1571099329, 950037016, 972059802, 830606037, 804337360, 1328323548, 798375117, 868298519, 1446715780, 908722214, 827533196, 975102848, 938007886, 1118707296, 936623315, 829983759, 1553005167, 1092676141, 935205778 } },
                        { "salvaged.sword", new List<ulong> { 0, 1568609421, 1587541456, 1915832963, 950134503, 1652800384, 1455468520, 1852787012, 828885909, 1442148142, 1442017029, 893871715, 969725237, 1366123054, 1239660381, 1154175800, 1283812544, 1535765451, 1212723513, 930557072, 1313755167, 825240467, 1624719255 } },
                        { "smg.thompson", new List<ulong> { 0, 561462394, 839819171, 1345464512, 1720001936, 1772377862 } },
                        { "pistol.revolver", new List<ulong> { 0, 910665268, 1901240954, 1192708586, 1235107237, 1265936882, 1141054826, 815532676, 1517889157, 937338314, 970737094, 1536482422, 873242795, 809865395, 809822151, 933056389, 1448503557, 1349358875, 1580859157, 809897611, 1346870567, 911828654, 1235996786, 1428863076, 950956238, 1787802800, 1435664860, 1161550991, 1309517474, 1408242038, 1447877728, 1099177489, 973871108, 1217455695, 887846629 } },
                        { "rocket.launcher", new List<ulong> { 0, 812737524, 813795591, 853494512, 875930670, 879708939, 926279011, 894679426, 1137393412, 1162978825, 1162085821, 1815384807, 1839729563, 1905848285, 1926503780, 1936188783 } },
                        { "rifle.semiauto", new List<ulong> { 0, 818613234, 828616457, 839302795, 840023839, 875259741, 900921542, 899564368, 922119054, 942919370, 959955205, 1099992405, 1112906123, 1113987623, 1135415770, 1129722099, 1168002579, 1170719113, 1182015913, 1193105339, 1098038362, 1195821858, 1240340535, 1279791283, 1291766032, 1298949573, 1300137383, 1300239738, 1217394290, 1310522106, 1313600286, 1359059068, 1385736095, 1395475969, 1429032578, 1448088345, 1446861251, 1517644801, 1522185915, 1566048269, 1576671137, 1616628843, 1621472496, 1652791742, 1772028068, 1788152335, 1814170373, 1819195444, 1818125194, 1863834018, 1876226129, 1936035303, 1933250593, 1966875478 } },
                        { "shotgun.waterpipe", new List<ulong> { 0, 633754963, 819137470, 661319648, 832764933, 907070012, 1147084675, 1168524895, 1181616781, 1205464046, 1219492103, 1234721165, 1209128595, 1274179291, 1250809355, 1320685736, 1421462560, 1693498234, 1851214164 } },
                        { "smg.2", new List<ulong> { 0, 1329096680, 820350952, 820402694, 866745136, 1081305198, 1128840196, 931547202, 1185311263, 1185311263, 816728172, 1839296742, 1805101270, 897099822, 892212957, 904964438, 1597038037, 1446184061, 1961720552, 1685722307, 1198145190, 1753609137, 1114032911, 1107572641, 854914986, 1523699528, 822943156, 970682025 } },
                        { "pistol.python", new List<ulong> { 0, 1214609010, 1215390635, 1217395562, 1216163401, 1228154190, 1223105431, 1235690536, 1258109891, 1265214612, 1290876678, 1296687971, 1305704747, 1277518447, 1328632407, 1335582211, 1342464644, 1364964220, 1377347733, 1356665596, 1373936691, 1418647979, 1435858834, 1435364672, 1455062983, 1445908611, 1457537882, 1461918011, 1421351634, 1529514494, 1362224646, 1563667918, 1406640269, 1605379554, 1624620555, 1672707813, 1752928667, 1796388607, 1812135451, 1839518047, 1864788236, 1914959779, 1917523660 } },
                        { "rifle.lr300", new List<ulong> { 0, 1621894466, 1741459108, 1535995784, 1239079767, 1569062511, 1173523145, 1553359638, 1553359638, 1174458060, 1604879931, 1225499752, 1725240606, 1883559335, 1419392688, 1700177871, 1612152593, 1578816958, 1660691287, 1173459827, 1644715625, 1177273104, 1264358358, 1953108368, 1671985039, 1652362426, 1308037543, 1779949198, 1635559091, 1787012455, 1176479716, 1481478360, 1967805281, 1282171260, 1203322875 } },
                        { "knife.combat", new List<ulong> { 0, 1702530691, 1706788762, 1707332381, 1715608877, 1719795241, 1706692846, 1730634130, 1739818618, 1910941833, 1952506333 } },
                        { "door.hinged.toptier", new List<ulong> { 0,  801831553, 801937986, 801889927, 804286931, 807729959, 809638761, 839925176, 869475498, 885928673, 911652483, 930478674, 933057923, 948938468, 1092678229, 1114020299, 1135412861, 1176460121, 1206145767, 1228341388, 1376526519, 1402412287, 1477263064, 1557857999, 1605324677, 1395469801, 1414795168, 1999927543 } },
                        { "door.hinged.metal", new List<ulong> { 0, 827190175, 832957536, 835119969, 849614068, 859864870, 836815358, 883741993, 897274189, 901194793, 915684869, 921076360, 917719889, 922419554, 934924536, 914869833, 928503162, 942658960, 948930384, 959898495, 961909886, 962391797, 1083653685, 1066783524, 1109694864, 1117884427, 1120339199, 1119310953, 1124738987, 1141051963, 1176406578, 1175547229, 1170684837, 950560231, 1211678957, 1213613030, 1227441654, 1239808532, 1260208160, 1281626747, 1290467327, 1294718018, 1309566989, 1306412169, 1313458951, 1321264697, 1328395850, 1328566466, 1342459239,  1356364616, 1356332123, 1362729705, 1354718926, 1362595551, 1390896848, 1380022034, 1383063240, 1401769919, 1412186246, 1415394917, 1412241247, 1435254318, 1438420454, 1443957299, 1447958101, 1466554259, 1457845730, 1448354224, 1447671986, 1523940330, 1524017223, 1514174191, 1539115581, 1205721755, 1565096963, 1576050073, 1587119000, 1587777999, 1595324955, 1617363766, 1653322594, 1680572723, 1687047599, 1707455661, 1727356485, 1733664175, 1747674239, 1759765099, 1772296521, 1780241717, 1795304359, 1812049396, 1839905607, 1845208821, 1852469574, 1852769999, 1870735722, 1886472768, 1926577314, 1933669766, 1952448742, 1974769574, 1984902763, 1992539569, 1999996993, 2009712630 } },
                        { "door.hinged.wood", new List<ulong> { 0, 809253752,804854812,804991715,847902281,838700836,923763807,950184212,1100873539,1100886818,1108316628,1127631900,1132144523,1131650209,1176899114,962427350,1260913194,1313604647,1320929144,1328425419,1362500013,1386052491,1402178300,1415059257,1428632857,1415496136,1269783329,1539681696,1605229872,1666630991,1733982448,1886617093,1759874635,1932460590,1932737376 } },
                        { "barricade.concrete", new List<ulong> { 0, 791070521, 828182621, 846663258, 924112225, 939333522 } },
                        { "barricade.sandbags", new List<ulong> { 0, 809144507 } },
                        { "tshirt", new List<ulong> { 0, 499455600, 495902079, 492471488, 489878758, 492781593, 490236659, 490948132, 492096219, 489329801, 490217825, 489687236, 504919781, 851890495, 1412895302 } },
                        { "shirt.tanktop", new List<ulong> { 0, 784578916 } },
                        { "rug.bear", new List<ulong> { 0, 870446546 } },
                        { "rug", new List<ulong> { 0, 871072156, 870851438, 907327964, 1114718055, 1225299046, 1461385713, 1637950966, 1740724608 } },
                        { "locker", new List<ulong> { 0, 879533969, 879343335, 881997061, 881411749, 1138218408, 1328242213, 1901223959, 1935027646 } },
                        { "table", new List<ulong> { 0, 872346354, 875258582, 909129983 } },
                        { "chair", new List<ulong> { 0, 871271807, 871339422, 875258235, 897656037, 1154498476, 1147170604, 1260443731 } },
                        { "fridge", new List<ulong> { 0, 864918396, 869398873, 873612402, 886416273, 1759824768, 1927006810, 1968311805 } },
                        { "vending.machine", new List<ulong> { 0, 861548229, 860916780, 862291005, 861029759, 862137836, 869474635, 871927557, 1161727529, 1335113551, 1373851317, 1780228760, 1927092059 } },
                        { "fun.guitar", new List<ulong> { 0, 809938266, 809801196, 826914904, 844914652 } },
                        { "box.wooden", new List<ulong> { 0, 787716105, 885103417, 889212734, 930694436, 1127078435, 1212709764, 1316294242, 1455068496, 1529745641, 1644263172, 1679876778, 1818868472, 1865304630, 2000024196 } },
                        { "water.purifier", new List<ulong> { 0, 786826476, 886677071, 1796826334 } },
                        { "sleepingbag", new List<ulong> { 0, 493375502, 494249390, 514146546, 535099192, 539536110, 548925163, 558861217, 795398514, 809186722, 834487561, 909889024, 919353105, 944993672, 1127084512, 1132190812, 1137518723, 1140342335, 1152883867, 1102195403, 1165339422, 1174407153, 1186393080, 1228238024, 1269426600, 1283724154, 1296042340, 1362261702, 1396600730, 1402402700, 1466734204, 1447956760, 1565127136, 1586749954, 1711044880, 1709890051, 1773435398, 1804347166, 1818779860, 1839630957, 1858936313, 1865305668, 1886931973, 1906188254, 1934818691, 1986734890, 1991418530, 2011695446 } },
                        { "target.reactive", new List<ulong> { 0, 791177585, 824001540 } },
                        { "box.wooden.large", new List<ulong> { 0, 798455489, 797422750, 810383121, 576569265, 813269955, 842083350, 854002617, 854718942, 878850459, 881249489, 851053322, 882223700, 890915277, 892062620, 904962497, 809975811, 928502682, 932160919, 942917320, 942678679, 969292267, 978112601, 1067191615, 1102266445, 1116497962, 1119263507, 1135412156, 1159589238, 1169231428, 1192724938, 1199632980, 1206100969, 1209454231, 1212838382, 1251062707, 1261541803, 1269932286, 1277330503, 1204070852, 1285113124, 1282838099, 1306240898, 1315566388, 1320924107, 1342462175, 1353721544, 1356773002, 1362394666, 1382429236, 1394363785, 1443958473, 1447962258, 1456233168, 1466559128, 1517816237, 1524018833, 1535990243, 1196352289, 1547157690, 1557427113, 1565532295, 1575872461, 1582501552, 1617361106, 1630549771, 1627583152, 1651859603, 1673157060, 1680678559, 1686299197, 1727351952, 1740339091, 1753777701, 1766238308, 1795321839, 1825978701, 1840296976, 1853539864, 1877231477, 1882223552, 1886917011, 1900496901, 1911972056, 1915836108, 1926650593, 1936186181, 1973015940, 2012513964 } },
                        { "wall.frame.garagedoor", new List<ulong> { 0, 1180981036, 1180968592, 1183127702, 1186351868, 1209586977, 1238292260, 1309406283, 1306203844, 1334974046, 1358030533, 1380090862, 1398568170, 1428456080, 1415079530, 1415167317, 1461027316, 1465843732, 1523814360, 1529742943, 1539143998, 1575268855, 1617613419, 1645407409, 1649777840, 1529558717, 1680120997, 1733848365, 1747024635, 1759641728, 1772483395, 1788350229, 1804915784, 1805270622, 1819106723, 1826250647, 1839473397, 1846000839, 1856195647, 1871289078, 1886876765, 1926583818, 1935858699, 1968391406, 1973756459, 2006000003, 2010495833 } },
                        { "door.double.hinged.wood", new List<ulong> { 0, 1876817741, 1882487559 } },
                        { "door.double.hinged.toptier", new List<ulong> { 0, 1874611109, 1911994581, 1925748582 } },
                        { "door.double.hinged.metal", new List<ulong> { 0, 1874961152, 1876575703, 1883500337, 1885983859, 1882782756, 1895120296, 1900646657, 1904509199, 1914299009, 1918077744, 1911036760, 1926125252, 1926973479, 1936126874 } },
                        { "shoes.boots", new List<ulong> { 0, 493534620, 493064563, 507940691, 513629119, 613481881, 784559403, 809586899, 838205144, 869090082, 882570089, 899942107, 919261524, 826587881, 944997041, 961096730, 920390242, 1084392788, 962503020, 1100926907, 1106548545, 1111680681, 1406796292, 1432967312, 1441308562, 1395755190, 1839313604, 1864539854, 1915955573, 1915397286, 1196740980, 1960694026, 1995685684, 2009426933 } },
                        { "jacket", new List<ulong> { 0, 505424331, 834233801, 1317555901 } },
                        { "pants.shorts", new List<ulong> { 0, 799006291, 794678401, 793871235, 818068257, 1412875829, 1416779855 } },
                        { "jacket.snow", new List<ulong> { 0, 530154777, 530159711, 839466039, 913227043 } },
                        { "riot.helmet", new List<ulong> { 0, 801095823, 849872204, 869709888, 869125904, 887283623, 911015530, 920983864, 930923611, 930563894, 937863435, 950182163, 1109466231, 1414953014, 1784490572, 1993881492 } },
                        { "roadsign.kilt", new List<ulong> { 0, 784577443, 794291485, 801837047, 818612271, 828173323, 865679836, 879861153, 892414125, 934742835, 944586866, 953123363, 934937654, 947949717, 950176525, 953112839, 1084396407, 1102986622, 1103687152, 1121447954, 1130405286, 1130610212, 1106569231, 1159599284, 1154469089, 1151205503, 1202976443, 974345761, 1251419748, 1248433379, 1269612137, 1342123902, 1332333384, 1349158079, 1353722661, 1349943069, 1380028657, 1400837602, 1388416860, 1441848470, 1442167045, 1442346890, 1438090382, 1539652650, 1539570583, 1558579257, 1737733590, 1759482713, 1797483140, 1779983158, 1740068457, 1723851847, 1865210905, 1894376712, 1906531526, 1915398061, 1944165903, 1974809731, 1986050287 } },
                        { "roadsign.jacket", new List<ulong> { 0, 784581113, 801873550, 818611894, 828175620, 865659101, 879861502, 892402754, 934744263, 932778217, 944577714, 953124938, 934926427, 947950933, 950173158, 953104456, 1084394793, 1102966153, 1098029034, 1121456497, 1130406273, 1130599258, 1119760089, 1159597292, 1154446174, 1151219812, 1202977830, 974336556, 1251431494, 1248434418, 1269597852, 1234957719, 1342125487, 1332334593, 1349163491, 1349940035, 1380025789, 1400828574, 1388417448, 1441844877, 1442162947, 1442341176, 1438089648, 1539651543, 1539573170, 1558586741, 1743991748, 1759481001, 1797481354, 1779981832, 1740065674, 1865210028, 1894379005, 1906530247, 1944167671, 1974808139, 1986047563 } },
                        { "pants", new List<ulong> { 0, 494003754, 490773561, 504687841, 798690647, 823154911, 889714798, 888360095, 909888619, 930559188, 939586076, 955615160, 961084105, 969289969, 975498827, 960252273, 1100930207, 1106596145, 1111673876, 1125254090, 1150816693, 1150763210, 1170988006, 1229552157, 1234956405, 1274163146, 1287193745, 1296612316, 1305364315, 1317553480, 1328753424, 1356749671, 1368418893, 1356324187, 1371313777, 1406835139, 1432965178, 1441311938, 1448346336, 1385326314, 1552705077, 1581822078, 1587846022, 1623181884, 1292094174, 1638743634, 1660293384, 1700938224, 1703218418, 1740505052, 1740563572, 1766646393, 1768737448, 1787243248, 1810590744, 1784474755, 1196747617, 1858308973, 1883629284, 1894589800, 1911973450, 1927127023, 1936132863, 1950854989, 1968533197, 1993902344, 1987863036, 1997534121 } },
                        { "hat.miner", new List<ulong> { 0, 788260164, 886318490, 886968007 } },
                        { "metal.facemask", new List<ulong> { 0, 784316334, 794837198, 792827436, 792079554, 792649975, 792905158, 799044333, 803894027, 800980236, 807821375, 816530945, 812933296, 828888629, 824898622, 821441043, 832021670, 832934294, 841012325, 835026584, 831923884, 881687672, 896211631, 895067146, 899001394, 901668040, 900645045, 907176719, 915572534, 924019464, 915693648, 943128194, 903628875, 971433920, 939788004, 932233099, 1092671728, 962694769, 1084823878, 1113983678, 1083628316, 1130407273, 1135160079, 1137533438, 1172409741, 1121237616, 1203888714, 1270065112, 1313529548, 1335769610, 1349988105, 1353724450, 1421829383, 1522955755, 1547874663, 1575391468, 1587225942, 1586135331, 1581351961, 1680454451, 1693643930, 1711049678, 1753711761, 1771714129, 1777973800, 1787201365, 1845950558, 1886184322, 1886920683, 1894591519, 1900843064, 1805321162, 1932619423, 1934943101, 1969741836, 1993775723, 2001712636, 2005707226 } },
                        { "metal.plate.torso", new List<ulong> { 0, 794169855, 799657859, 796728308, 797410767, 817022417, 823132085, 828888000, 832233112, 842577956, 798736321, 819160334, 895066686, 900807753, 924019814, 934627208, 944835223, 970700662, 1113984430, 1094522474, 1135168998, 1270065959, 1335770974, 1349989767, 1353723648, 1421841596, 1522963149, 1575392727, 1587225313, 1586132318, 1581353262, 1578628782, 1680452167, 1693641239, 1711048020, 1753699785, 1771804406, 1777967326, 1787198707, 1845931269, 1886179838, 1886922099, 1900842357, 1805322456, 1932615190, 1934946028, 1969743263, 1993774875, 2001706617, 2005709642 } },
                        { "tshirt.long", new List<ulong> { 0, 500940007, 492923278, 494178127, 493015260, 493860728, 492980527, 512107102, 534635471, 564242686, 566893368, 801204141, 808300545, 1416787006 } },
                        { "burlap.gloves", new List<ulong> { 0, 565678598, 610098458, 661317919, 816473273, 874488180, 883476299, 904961862, 961103399, 938394833, 921030333, 949616124, 1084390180, 962495909, 1100928373, 1111677889, 1106600389, 1296614997, 1368419860, 1394040487, 1406800025, 1432966221, 1448347837, 1395757825, 1552705918, 1623175153, 1839312425, 1864540635, 1865178625, 1915956499, 1727356926, 1196737780, 1960696487, 1993913813, 2009427605 } },
                        { "attire.hide.poncho", new List<ulong> { 0, 788732722, 825459163, 837191793, 833524594, 1269162578 } },
                        { "hoodie", new List<ulong> { 0, 1357519971, 492800372, 519147220, 539943199, 612956053, 619935833, 626133126, 661319427, 797128321, 803249256, 677636990, 889718910, 835836079, 895065994, 897890977, 914621940, 919353761, 926162531, 939604165, 904963081, 941172099, 954392337, 954947279, 961066582, 971807764, 959900137, 975500312, 959641236, 1100931254, 1106582025, 1111669350, 1150818496, 1150760640, 1170989053, 1209453497, 1234693807, 1274163900, 1282111884, 1296608954, 1305321596, 1317554978, 1328751626, 1356748246, 1368417352, 1356328924, 1373714814, 1371314541, 1408832378, 1432964453, 1448343881, 1385322661, 1552703337, 1564974974, 1581817010, 1587744366, 1623185000, 1292091712, 1638742127, 1660290744, 1700935391, 1703216433, 1740503746, 1740562395, 1766644324, 1768733505, 1787216403, 1810592176, 1784482745, 1196751864, 1858310941, 1883624383, 1894585931, 1911980598, 1927124747, 1936131747, 1950853975, 1968538819, 1993891915, 2000507925, 1997532879 } },
                        { "attire.hide.helterneck", new List<ulong> { 0, 798669794, 845019310 } },
                        { "attire.hide.boots", new List<ulong> { 0, 785347695, 837175591, 1230633097 } },
                        { "attire.hide.pants", new List<ulong> { 0, 837179220, 1269154354 } },
                        { "attire.hide.vest", new List<ulong> { 0, 878319804, 1269172413 } },
                        { "attire.hide.skirt", new List<ulong> { 0, 793180528, 831920129 } },
                        { "deer.skull.mask", new List<ulong> { 0, 784259585, 837166252, 882204381, 1935631950 } },
                        { "coffeecan.helmet", new List<ulong> { 0, 784910461, 806212029, 814098474, 843676357, 848645884, 854460770, 809816871, 914060966, 919595880, 891592450, 938020581, 948491992, 970583835, 955675586, 1104118217, 1121458604, 1129809202, 1130589746, 1174375607, 1154453278, 1151227603, 1202978872, 974321420, 1251411840, 1248435433, 1269589560, 1342122459, 1332335200, 1349166206, 1349946203, 1380023142, 1400824309, 1388417865, 1441850738, 1442169133, 1445131741, 1438088592, 1539650632, 1539575334, 1743856800, 1759479029, 1797478191, 1804649832, 1740061403, 1865208631, 1894381558, 1906527802, 1944168755, 1974807032, 1986043465 } },
                        { "shirt.collared", new List<ulong> { 0, 797241160, 802078252, 802073199, 801955689, 809704306, 819818852, 885078753 } },
                        { "hat.cap", new List<ulong> { 0, 495026469, 494030776, 890772638, 893188334, 1137628492, 1565217605, 1760269295 } },
                        { "hat.beenie", new List<ulong> { 0, 501159601, 519469651, 594202145 } },
                        { "bucket.helmet", new List<ulong> { 0, 564826303, 570784227, 784438982, 867605376, 831798567, 885450077, 889767601, 926313433, 964461549, 949889936, 1073904216, 1197730661 } },
                        { "burlap.headwrap", new List<ulong> { 0, 785890135, 861551572, 868014709, 896506958, 942098139, 822358002, 1691834772, 1694253807 } },
                        { "burlap.trousers", new List<ulong> { 0, 809968188, 921250017, 1127409880, 1145780081, 1323664071, 1354675665, 1380047706, 1394040054, 1438049211, 1755140135 } },
                        { "burlap.shirt", new List<ulong> { 0, 585386820, 654502725, 809909900, 849866944, 882451685, 926478499, 899941622, 1127407306, 1145786859, 1229561297, 1294812700, 1294811936, 1323654151, 1354670586, 1380044819, 1394039696, 1438049725, 1755124648 } },
                        { "burlap.shoes", new List<ulong> { 0, 790679533, 906443871 } },
                        { "mask.balaclava", new List<ulong> { 0, 502924129, 503161493, 506771831, 519942815, 507590678, 539536877, 539562549, 535666265, 613057784, 807719156, 813561728, 843976918, 851779943, 858156568, 856403207, 884484239, 1175131736, 1174877663 } },
                        { "mask.bandana", new List<ulong> { 0, 521069222, 903595865, 1185794212, 1323640876, 1438048628, 820870847, 1685873480, 1710737837 } },
                        { "pickaxe", new List<ulong> { 0, 832799172, 863455081, 859743520, 828884658, 904296143, 1083591199, 949859819, 1121521173, 1150813747, 1143157014, 1283807232, 1298797381, 1320093416, 1325483813, 1362736707, 1377987815, 1407877776, 1435220253, 1444912645, 1466675896, 1414450451, 1428399027, 1553326380, 1572401500, 1616992357, 1780027581, 1557509001, 1845184191, 1872098938, 1901442609, 1911366896, 1962080594, 1987871430 } },
                        { "hatchet", new List<ulong> { 0, 814630559, 816715928, 826402867, 824552943, 814713259, 825033005, 892263562, 910196839, 915910717, 924242197, 928879549, 912857899, 944497252, 953186726, 962959509, 950020589, 1082302323, 1092131816, 1076337199, 1095577423, 1108554409, 967413298, 1121515438, 1137482995, 1143274085, 1150815053, 1152712210, 1145547996, 1107210636, 1171956705, 1193102490, 1220880032, 1242774466, 1252014044, 1258108678, 1247701169, 1291775183, 1320099240, 1325481133, 1359120832, 1362737705, 1379766114, 1407875352, 1378023158, 1435214632, 1448232793, 1466664834, 1414446668, 1422179740, 1553321287, 1572398539, 1620492374, 1546404025, 1617000027, 1772892883, 1838326907, 1870596204, 1900587737, 1911293067, 1962083351, 1987865546 } },
                        { "hammer", new List<ulong> { 0, 822539548, 833423263, 938806184, 961294045, 1095969830, 1116103194, 1125995819, 1128710439, 1120977731, 1208606722, 1249500235, 1457914371, 1539336419, 1586965130, 1652017472, 1720644451, 1858261101, 1876980303, 1884786335, 1916000340 } },
                        { "stone.pickaxe", new List<ulong> { 0, 840380436, 837149011, 886904592, 1100085862, 1127557296, 1196675392, 1269582427, 1290539482, 1306179593, 1342118597, 1395460858, 1428446680, 1428014003, 1594886582, 1788447750, 1852292345, 1906588860, 1988077270 } },
                        { "stonehatchet", new List<ulong> { 0, 797445687, 854688691, 878257758, 887663210, 912599650, 955692135, 947950887, 1058431260, 1092741003, 1114895505, 1117098080, 1151551275, 1184754750, 1196674526, 1235107175, 1269563695, 1290344811, 1306176753, 1340282993, 1356232241, 1342121150, 1395467841, 1428438688, 1438048408, 1428010053, 1559244155, 1594996565, 1788439811, 1852290423, 1906590340, 1988082179 } },
                        { "explosive.satchel", new List<ulong> { 0, 855084816, 855256664, 860156815, 856333895, 908893157, 855113878, 1586074827, 1710383765, 1906259594, 1934132095, 1961769080 } },
                        { "icepick.salvaged", new List<ulong> { 0, 820810719, 844666224, 843454856, 911446362, 1121804393, 1124734833, 933760454, 1276627079 } },
                        { "hammer.salvaged", new List<ulong> { 0, 1176274440, 873519952, 862959564, 797728217 } },
                        { "rock", new List<ulong> { 0, 804791902, 807372963, 824904841, 834287924, 864277659, 843429299, 858285362, 933809748, 971411353, 1084822722, 1126754320, 1209361016, 1205671322, 1378500484, 1368454662, 1435229543, 1458528823, 1467090959, 1530140666, 1539197932, 1595910049, 1617334269, 1636101879, 1693063715, 1739062735, 1838926976, 1953527967 } },
                    },
                    priv = new priv
                    {
                        enable = false,
                        message = "<color=yellow>У вас нет доступа к этой команде!</color>",
                        permission = "skinmenu.use"
                    }, paint = true,
                    repairbench = false
                };
            }
        }
        #endregion

        #region ЗАГРУЗКА КАРТИНОК
        [PluginReference] Plugin ImageLibrary;
        public string GetImage(string shortname, ulong skin = 0) => (string)ImageLibrary.Call("GetImage", shortname, skin);
        public bool AddImage(string url, string shortname, ulong skin = 0) => (bool)ImageLibrary?.Call("AddImage", url, shortname, skin);
        public bool HasImage(string imageName, ulong imageId) => (bool)ImageLibrary?.Call("HasImage", imageName, imageId);

        const int MAXLOAD = 20;
        Dictionary<ulong, int> COUNTAMAXSAD = new Dictionary<ulong, int>();
        public void ADDIMAGE(string shortname, ulong skinID = 0)
        {
            if (skinID == 0) GetImage(shortname);
            else if (!HasImage(shortname, skinID))
            {
                webrequest.Enqueue("https://api.steampowered.com/ISteamRemoteStorage/GetPublishedFileDetails/v1/", $"key={config.APIKEY}&itemcount=1&publishedfileids%5B0%5D={skinID}", (code, response) =>
                {
                    if (code != 200 || response == null)
                    {
                        if (COUNTAMAXSAD.ContainsKey(skinID)) COUNTAMAXSAD[skinID]++;
                        else COUNTAMAXSAD[skinID] = 0;
                        if (COUNTAMAXSAD[skinID] >= MAXLOAD) return;
                        timer.Once(10f, () => ADDIMAGE(shortname, skinID));
                        return;
                    }

                    SteampoweredResult sr = JsonConvert.DeserializeObject<SteampoweredResult>(response);
                    if (sr == null || !(sr is SteampoweredResult) || sr.response.result == 0 || sr.response.resultcount == 0)
                    {
                        PrintError($"Image failed to download! Error: Parse JSON response - Image Name: {shortname} - Image skinID: {skinID} - Response: {response}");
                        return;
                    }
                    SteampoweredResult.Response.PublishedFiled publishedfiled = sr.response.publishedfiledetails.FirstOrDefault();
                    AddImage(publishedfiled.preview_url, shortname, skinID);
                    if (COUNTAMAXSAD.ContainsKey(skinID)) COUNTAMAXSAD.Remove(skinID);

                }, this, RequestMethod.POST);
            }
        }
        #endregion

        #region КЕШ
        const float BUTTONADD = 0.198f;
        const float conststartx = 0.015f;
        const float conststarty = 0.955f;
        static string GUISkin = "";
        static string MAINGUI = "";
        const string ELEMENTBUTTONGUI = ",{\"name\":\"ELEMENTBUTTON.{num}\",\"parent\":\"SkinMenu\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"color\":\"{color}\",\"command\":\"{button}\"},{\"type\":\"RectTransform\",\"anchormin\":\"{min} 0.87\",\"anchormax\":\"{max} 0.93\",\"offsetmax\":\"0 0\"}]},{\"name\":\"ELEMENTBUTTONTEXT\",\"parent\":\"ELEMENTBUTTON.{num}\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{text}\",\"fontSize\":20,\"align\":\"MiddleCenter\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]}";
        const string ELEMENTGUI = ",{\"name\":\"ELEMENTPANEL\",\"parent\":\"SKINBACKHROUND\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"{button}\",\"color\":\"{backgroundskin}\"},{\"type\":\"RectTransform\",\"anchormin\":\"{minx} {miny}\",\"anchormax\":\"{maxx} {maxy}\",\"offsetmax\":\"0 0\"}]},{\"name\":\"ELEMENTBUTT\",\"parent\":\"ELEMENTPANEL\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"{button}\",\"color\":\"1 1 1 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]},{\"name\":\"ELEMENT\",\"parent\":\"ELEMENTPANEL\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"png\":\"{png}\",\"fadeIn\":0.5},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]}";
        const string BACKGROUNDGUI = "{\"name\":\"SKINBACKHROUND\",\"parent\":\"SkinMenu\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{backgroundmenu}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.01 0.07\",\"anchormax\":\"0.99 0.85\",\"offsetmax\":\"0 0\"}]},{\"name\":\"SKINBACKHROUNDHEADER\",\"parent\":\"SKINBACKHROUND\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{backfooter}\",\"fontSize\":{backfootersize},\"align\":\"MiddleCenter\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 0.05\",\"offsetmax\":\"0 0\"}]}";
        const string BUTTONGUI = ",{\"name\":\"BUTTONBACKS\",\"parent\":\"SKINBACKHROUND\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"{button}\",\"color\":\"{color}\"},{\"type\":\"RectTransform\",\"anchormin\":\"{min} 0.01\",\"anchormax\":\"{max} 0.06\",\"offsetmax\":\"0 0\"}]},{\"name\":\"BUTTONBACKSTEXT\",\"parent\":\"BUTTONBACKS\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{T}\",\"align\":\"MiddleCenter\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]}";

        class playerinfo
        {
            public Dictionary<string, ulong> skins;
            public elementbutton page;
        }

        static Dictionary<ulong, playerinfo> skinplayers = new Dictionary<ulong, playerinfo>();
        #endregion

        private void OnServerInitialized()
        {
            SaveConfig();

            if (string.IsNullOrEmpty(config.APIKEY))
            {
                Debug.LogError("УКАЖИТЕ APIKEY В КОНФИГЕ! [p.s. при создании можете указать любой домен]");
                return;
            }

            if (config.priv == null)
            {
                config.priv = new priv
                {
                    enable = false,
                    message = "<color=yellow>У вас нет доступа к этой команде!</color>",
                    permission = "skinmenu.use"
                };
            }

            if (!config.paint)
            {
                Unsubscribe(nameof(OnActiveItemChange));
            }
            else
            {
                Subscribe(nameof(OnActiveItemChange));
            }

            if (!config.repairbench)
            {
                Unsubscribe(nameof(OnLootEntity));
                Unsubscribe(nameof(OnItemRemovedFromContainer));
                Unsubscribe(nameof(CanAcceptItem));
                Unsubscribe(nameof(OnPlayerLootEnd));
            }
            else
            {
                Subscribe(nameof(OnLootEntity));
                Subscribe(nameof(OnItemRemovedFromContainer));
                Subscribe(nameof(CanAcceptItem));
                Subscribe(nameof(OnPlayerLootEnd));
            }

            permission.RegisterPermission(config.priv.permission, this);

            AddImage("http://i.imgur.com/sZepiWv.png", "NONE");
            AddImage("http://i.imgur.com/lydxb0u.png", "LOADING");

            foreach (var z in config.categorys)
            {
                if (z.Value.items == null || z.Value.items.Length == 0) continue;
                foreach (var x in z.Value.items) ADDIMAGE(x);
            }

            foreach (var z in config.skins)
            {
                if (z.Value == null || z.Value.Count == 0) continue;
                foreach (var x in z.Value) ADDIMAGE(z.Key, x);
            }

            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                InitPlayerSkin(player);
                INITPLAYER(player.userID);
            }

            MAINGUI = "[{\"name\":\"SkinMenu\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{background}\",\"fadeIn\":0.5},{\"type\":\"NeedsCursor\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]},{\"name\":\"SKINHEADER\",\"parent\":\"SkinMenu\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{backgroundup}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.95\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]},{\"name\":\"SKINHEADERTEXT\",\"parent\":\"SKINHEADER\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{header}\",\"fontSize\":{headersize},\"align\":\"MiddleCenter\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]},{\"name\":\"SKINCLOSE\",\"parent\":\"SkinMenu\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"skin.controll exit\",\"close\":\"SkinMenu\",\"color\":\"{backgroundfoot}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 0.05\",\"offsetmax\":\"0 0\"}]},{\"name\":\"CLOSETEXT\",\"parent\":\"SKINCLOSE\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{closetext}\",\"fontSize\":{closetextsize},\"align\":\"MiddleCenter\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]}{main}]".Replace("{backgroundup}", config.color.backgroundup).Replace("{backgroundfoot}", config.color.backgroundfoot).Replace("{closetext}", config.text.exit.text).Replace("{closetextsize}", config.text.exit.size).Replace("{background}", config.color.background).Replace("{header}", config.text.title.text).Replace("{headersize}", config.text.title.size);
            GUISkin = "[{\"name\":\"SKINPANELMAIN\",\"parent\":\"Hud.Menu\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"1 1 1 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0\",\"anchormax\":\"0.5 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"SKINPANEL\",\"parent\":\"SKINPANELMAIN\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"skin.controll main\",\"color\":\"{bench}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0\",\"anchormax\":\"0.5 0\",\"offsetmin\":\"303 72\",\"offsetmax\":\"410 98\"}]},{\"name\":\"SKINTEXT\",\"parent\":\"SKINPANEL\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{main}\",\"fontSize\":{mainsize},\"align\":\"MiddleCenter\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]},{\"name\":\"SKINPANEL\",\"parent\":\"SKINPANELMAIN\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"chat.say /skin\",\"color\":\"{bench}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0\",\"anchormax\":\"0.5 0\",\"offsetmin\":\"192 43\",\"offsetmax\":\"410 69\"}]},{\"name\":\"SKINTEXT\",\"parent\":\"SKINPANEL\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{menu}\",\"fontSize\":{menusize},\"align\":\"MiddleCenter\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]},{\"name\":\"SKINPANEL\",\"parent\":\"SKINPANELMAIN\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"skin.controll rand\",\"color\":\"{bench}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0\",\"anchormax\":\"0.5 0\",\"offsetmin\":\"192 72\",\"offsetmax\":\"301 98\"}]},{\"name\":\"SKINTEXT\",\"parent\":\"SKINPANEL\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{rand}\",\"fontSize\":{randsize},\"align\":\"MiddleCenter\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]}]".Replace("{menusize}", config.text.bench.menu.size).Replace("{menu}", config.text.bench.menu.text).Replace("{mainsize}", config.text.bench.main.size).Replace("{main}", config.text.bench.main.text).Replace("{randsize}", config.text.bench.random.size).Replace("{rand}", config.text.bench.random.text).Replace("{bench}", config.color.bench);
        }

        const string UIALERT = "[{\"name\":\"ALERT\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0 0 0 0.7485173\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.6\",\"anchormax\":\"1 0.7\",\"offsetmax\":\"0 0\"}]},{\"name\":\"TEXTALERT\",\"parent\":\"ALERT\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{text}\",\"fontSize\":{size},\"align\":\"MiddleCenter\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]},{\"name\":\"CuiElement\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"RectTransform\",\"anchormin\":\"0.05208334 0.09259259\",\"anchormax\":\"0.1041667 0.1851852\",\"offsetmax\":\"0 0\"}]},{\"name\":\"CuiElement\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"RectTransform\",\"anchormin\":\"0.05208334 0.09259259\",\"anchormax\":\"0.1041667 0.1851852\",\"offsetmax\":\"0 0\"}]}]";
        private void ALERTPLAYER(BasePlayer player, string text, string size)
        {
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "ALERT");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", UIALERT.Replace("{size}", size).Replace("{text}", text));
            timer.Once(2f, () => CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "ALERT"));
        }

        private void INITPLAYER(ulong userid)
        {
            if (!skinplayers.ContainsKey(userid)) skinplayers.Add(userid, new playerinfo { skins = new Dictionary<string, ulong>(), page = elementbutton.weapon });
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            InitPlayerSkin(player);
            INITPLAYER(player.userID);
        }

        #region SteampoweredAPI 
        private class SteampoweredResult
        {
            public Response response;
            public class Response
            {
                [JsonProperty("result")]
                public int result;

                [JsonProperty("resultcount")]
                public int resultcount;

                [JsonProperty("publishedfiledetails")]
                public List<PublishedFiled> publishedfiledetails;
                public class PublishedFiled
                {
                    [JsonProperty("publishedfileid")]
                    public ulong publishedfileid;

                    [JsonProperty("result")]
                    public int result;

                    [JsonProperty("creator")]
                    public string creator;

                    [JsonProperty("creator_app_id")]
                    public int creator_app_id;

                    [JsonProperty("consumer_app_id")]
                    public int consumer_app_id;

                    [JsonProperty("filename")]
                    public string filename;

                    [JsonProperty("file_size")]
                    public int file_size;

                    [JsonProperty("preview_url")]
                    public string preview_url;

                    [JsonProperty("hcontent_preview")]
                    public string hcontent_preview;

                    [JsonProperty("title")]
                    public string title;

                    [JsonProperty("description")]
                    public string description;

                    [JsonProperty("time_created")]
                    public int time_created;

                    [JsonProperty("time_updated")]
                    public int time_updated;

                    [JsonProperty("visibility")]
                    public int visibility;

                    [JsonProperty("banned")]
                    public int banned;

                    [JsonProperty("ban_reason")]
                    public string ban_reason;

                    [JsonProperty("subscriptions")]
                    public int subscriptions;

                    [JsonProperty("favorited")]
                    public int favorited;

                    [JsonProperty("lifetime_subscriptions")]
                    public int lifetime_subscriptions;

                    [JsonProperty("lifetime_favorited")]
                    public int lifetime_favorited;

                    [JsonProperty("views")]
                    public int views;

                    [JsonProperty("tags")]
                    public List<Tag> tags;
                    public class Tag
                    {
                        [JsonProperty("tag")]
                        public string tag;
                    }
                }
            }
        }
        #endregion


        const string GUICENTERBUT = ",{\"name\":\"PAGETEXT\",\"parent\":\"SKINBACKHROUND\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{text}\",\"fontSize\":16,\"align\":\"MiddleRight\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.4 0.01\",\"anchormax\":\"0.48 0.06\",\"offsetmax\":\"0 0\"}]}";
        static Dictionary<ulong, bool> opening = new Dictionary<ulong, bool>();
        const int MAXROW = 4;
        const int INROW = 10;

        bool HAVEACCES(string id)
        {
            if (!config.priv.enable) return true;
            if (permission.UserHasPermission(id, config.priv.permission)) return true;
            return false;
        }

        [ConsoleCommand("skin.add")]
        private void CONSOLECOMMANADD(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin) return;
            if (!arg.HasArgs() || arg.Args.Length < 2)
            {
                arg.ReplyWith("skin.add НАЗВАНИЕ_ПРЕДМЕТА ID_СКИНА [пример: skin.add rifle.ak 0]");
                return;
            }

            List<ulong> skins;
            string name = arg.Args[0];
            if(!config.skins.TryGetValue(name, out skins))
            {
                arg.ReplyWith($"Не нашли в конфиге предмет с названием {name}");
                return;
            }

            ulong skinid;
            if(!ulong.TryParse(arg.Args[1], out skinid))
            {
                arg.ReplyWith($"Это не ID скина {arg.Args[1]}!");
                return;
            }

            if (skins.Contains(skinid))
            {
                arg.ReplyWith($"Такой скин уже добавлен!");
                return;
            }

            skins.Add(skinid);
            ADDIMAGE(name, skinid);
            arg.ReplyWith($"Добавили скин {arg.Args[1]} для {name}. [сохранили конфиг]");
        }

        [ConsoleCommand("skin.remove")]
        private void CONSOLECOMMANREMOVE(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin) return;
            if (!arg.HasArgs() || arg.Args.Length < 2)
            {
                arg.ReplyWith("skin.remove НАЗВАНИЕ_ПРЕДМЕТА ID_СКИНА [пример: skin.remove rifle.ak 0]");
                return;
            }

            List<ulong> skins;
            string name = arg.Args[0];
            if (!config.skins.TryGetValue(name, out skins))
            {
                arg.ReplyWith($"Не нашли в конфиге предмет с названием {name}");
                return;
            }

            ulong skinid;
            if (!ulong.TryParse(arg.Args[1], out skinid))
            {
                arg.ReplyWith($"Это не ID скина {arg.Args[1]}!");
                return;
            }

            if (!skins.Contains(skinid))
            {
                arg.ReplyWith($"Нет такого скина в списке!");
                return;
            }

            skins.Remove(skinid);
            arg.ReplyWith($"Удалили скин {arg.Args[1]} у {name}. [сохранили конфиг]");
        }

        [ConsoleCommand("skin.list")]
        private void CONSOLECOMMANLIST(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin) return;
            if (!arg.HasArgs() || arg.Args.Length < 1)
            {
                arg.ReplyWith("skin.list НАЗВАНИЕ_ПРЕДМЕТА [пример: skin.list rifle.ak]");
                return;
            }

            List<ulong> skins;
            string name = arg.Args[0];
            if (!config.skins.TryGetValue(name, out skins))
            {
                arg.ReplyWith($"Не нашли в конфиге предмет с названием {name}");
                return;
            }

            if(skins.Count == 0)
            {
                arg.ReplyWith("Нет скинов.");
                return;
            }

            string skinlist = "";
            foreach(var z in skins)
            {
                if (z == 0) continue;
                string id = z.ToString();
                skinlist += $"{id} - https://steamcommunity.com/sharedfiles/filedetails/?id={id}\n";
            }

            arg.ReplyWith($"Список скинов для {name}\n{skinlist}");
        }

        [ConsoleCommand("skin.save")]
        private void CONSOLECOMMANSAVE(ConsoleSystem.Arg arg)
        {
            SaveConfig();
            Debug.Log("Конфиг успешно сохранен.");
        }

        private static IEnumerator PAINTING(global::Item[] items, string name, ulong skin)
        {
            foreach (Item item in items)
            {
                if (item.info.shortname == name)
                {
                    if (skin == item.skin) continue;
                    item.skin = skin;
                    item.MarkDirty();
                    BaseEntity heldEntity = item.GetHeldEntity();
                    if ((UnityEngine.Object)heldEntity != (UnityEngine.Object)null)
                    {
                        heldEntity.skinID = skin;
                        heldEntity.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                    }
                    yield return new WaitForEndOfFrame();
                }
            }
            yield break;
        }

        private void OnActiveItemChange(BasePlayer player, Item oldItem, Item newItem)
        {
            string shortname = newItem.info.shortname;
            if (newItem == null || !config.skins.ContainsKey(shortname) || !config.skins[shortname].Contains(newItem.skin)) return;
            ulong skin = APISKIN(player, shortname);
            if (skin == newItem.skin) return;
            newItem.skin = skin;
            newItem.MarkDirty();
            BaseEntity heldEntity = newItem.GetHeldEntity();
            if ((UnityEngine.Object)heldEntity != (UnityEngine.Object)null)
            {
                heldEntity.skinID = skin;
                heldEntity.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            }
        }

        [ConsoleCommand("skin.controll")]
        private void CONSOLECOMMANDSKINMENU(ConsoleSystem.Arg arg)
        {
            if (!arg.HasArgs()) return;
            BasePlayer player = arg.Player();
            if (player == null) return;
            if (!HAVEACCES(player.UserIDString))
            {
                player.ChatMessage(config.priv.message);
                return;
            }
            if (config.repairbench)
            {
                if (arg.Args[0] == "rand")
                {
                    ChangeSkin(player, true);
                    return;
                }
                else if (arg.Args[0] == "main")
                {
                    ChangeSkin(player, false);
                    return;
                }
            }
            if (!opening.ContainsKey(player.userID)) return;
            INITPLAYER(player.userID);
            if (arg.Args.Length == 3)
            {
                if (arg.Args[0] == "show")
                {
                    string ITEMNAME = arg.Args[1];
                    if (!config.skins.ContainsKey(ITEMNAME)) return;
                    int PAGE;
                    if (!int.TryParse(arg.Args[2], out PAGE)) return;
                    opening[player.userID] = false;
                    if (!skinplayers[player.userID].skins.ContainsKey(ITEMNAME)) skinplayers[player.userID].skins.Add(ITEMNAME, 0UL);
                    CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "SKINBACKHROUND");
                    string ISTRING = "[" + BACKGROUNDGUI.Replace("{backgroundmenu}", config.color.backgroundmenu).Replace("{backfootersize}", "0").Replace("{backfooter}", "");
                    int i = 1;
                    float startx = conststartx;
                    float starty = conststarty;
                    foreach (var x in config.skins[ITEMNAME].Skip(PAGE * MAXROW * INROW).Take(MAXROW * INROW))
                    {
                        ISTRING += ELEMENTGUI.Replace("{backgroundskin}", config.color.backgroundskin).Replace("{button}", $"skin.controll choose {ITEMNAME} {x}").Replace("{maxy}", starty.ToString()).Replace("{miny}", (starty - 0.2f).ToString()).Replace("{maxx}", (startx + 0.088f).ToString()).Replace("{minx}", startx.ToString()).Replace("{png}", GetImage(ITEMNAME, x));
                        if (i % INROW == 0)
                        {
                            startx = conststartx;
                            starty -= 0.22f;
                        }
                        else startx += 0.098f;
                        i++;
                    }
                    float start = 0.485f;
                    for (int c = 0; c <= Math.Floor(config.skins[ITEMNAME].Count() / (MAXROW * INROW * 1f)); c++)
                    {
                        ISTRING += BUTTONGUI.Replace("{button}", PAGE == c ? "" : $"skin.controll show {ITEMNAME} {c}").Replace("{color}", PAGE == c ? config.color.activecolor : config.color.buttoncolor).Replace("{max}", (start + 0.02f).ToString()).Replace("{min}", start.ToString()).Replace("{T}", (c + 1).ToString());
                        start += 0.025f;
                    }
                    ISTRING += GUICENTERBUT.Replace("{text}", "СТРАНИЦЫ:");
                    CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", ISTRING + "]");
                }
                else if (arg.Args[0] == "choose")
                {
                    string ITEMNAME = arg.Args[1];
                    if (!config.skins.ContainsKey(ITEMNAME)) return;
                    ulong SKIN;
                    if (!ulong.TryParse(arg.Args[2], out SKIN) || !config.skins[ITEMNAME].Contains(SKIN)) return;
                    // Debug.Log(arg.Args[2]);
                    if (!skinplayers[player.userID].skins.ContainsKey(ITEMNAME)) skinplayers[player.userID].skins.Add(ITEMNAME, SKIN);
                    else skinplayers[player.userID].skins[ITEMNAME] = SKIN;
                    player.SendConsoleCommand($"skin.controll page {(int)skinplayers[player.userID].page}");
                    NextTick(() => ALERTPLAYER(player, config.text.done.text, config.text.done.size));
                    ServerMgr.Instance.StartCoroutine(PAINTING(player.inventory.AllItems(), ITEMNAME, SKIN));
                    EffectNetwork.Send(new Effect("assets/bundled/prefabs/fx/notice/loot.drag.grab.fx.prefab", player, 0, Vector3.up, Vector3.zero) { scale = 1f }, player.net.connection);
                }
            }
            else if (arg.Args.Length == 2)
            {
                if (arg.Args[0] == "page")
                {
                    int INTPARSE;
                    if (!int.TryParse(arg.Args[1], out INTPARSE) || INTPARSE < 0 || INTPARSE >= config.categorys.Count) return;
                    elementbutton page = (elementbutton)INTPARSE;
                    elementbutton lpage = skinplayers[player.userID].page;
                    if (page == lpage && opening[player.userID]) return;
                    opening[player.userID] = true;
                    string lastpage = ((int)lpage).ToString();
                    string activepage = ((int)page).ToString();
                    CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "SKINBACKHROUND");
                    string ISTRING = "[" + BACKGROUNDGUI.Replace("{backgroundmenu}", config.color.backgroundmenu).Replace("{backfootersize}", config.text.pint.size).Replace("{backfooter}", config.text.pint.text);
                    int i = 1;
                    float startx = conststartx;
                    float starty = conststarty;
                    foreach (var x in config.categorys[page].items)
                    {
                        if (!skinplayers[player.userID].skins.ContainsKey(x)) skinplayers[player.userID].skins.Add(x, 0UL);
                        ISTRING += ELEMENTGUI.Replace("{backgroundskin}", config.color.backgroundskin).Replace("{maxy}", starty.ToString()).Replace("{miny}", (starty - 0.2f).ToString()).Replace("{button}", $"skin.controll show {x} 0").Replace("{maxx}", (startx + 0.088f).ToString()).Replace("{minx}", startx.ToString()).Replace("{png}", GetImage(x, skinplayers[player.userID].skins[x]));
                        if (i % 10 == 0)
                        {
                            startx = conststartx;
                            starty -= 0.22f;
                        }
                        else startx += 0.098f;
                        i++;
                    }
                    if (page != lpage)
                    {
                        CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", $"ELEMENTBUTTON.{lastpage}");
                        CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", $"ELEMENTBUTTON.{INTPARSE}");
                        float start = 0.01f;
                        foreach (var z in config.categorys)
                        {
                            if (z.Key == lpage) ISTRING += ELEMENTBUTTONGUI.Replace("{num}", lastpage).Replace("{button}", $"skin.controll page {lastpage}").Replace("{text}", z.Value.name).Replace("{color}", config.color.buttoncolor).Replace("{min}", start.ToString()).Replace("{max}", (start + 0.188f).ToString());
                            else if (z.Key == page) ISTRING += ELEMENTBUTTONGUI.Replace("{num}", activepage).Replace("{button}", $"skin.controll page {activepage}").Replace("{text}", z.Value.name).Replace("{color}", config.color.activecolor).Replace("{min}", start.ToString()).Replace("{max}", (start + 0.188f).ToString());
                            start += BUTTONADD;
                        }
                    }
                    CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", ISTRING + "]");
                    skinplayers[player.userID].page = page;
                }
            }
            else if (arg.Args[0] == "exit")
            {
                if (opening.ContainsKey(player.userID)) opening.Remove(player.userID);
            }
        }

        [ChatCommand("skinid")]
        private void TESTCHATCOMMANDSKINMENU(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin) return;
            Item item = player.GetActiveItem();
            if (item == null) return;
            string text = item.skin.ToString();
            player.ChatMessage(text);
        }

        [ChatCommand("skin")]
        private void CHATCOMMANDSKINMENU(BasePlayer player, string command, string[] args)
        {
            if (!HAVEACCES(player.UserIDString))
            {
                player.ChatMessage(config.priv.message);
                return;
            }
            if (opening.ContainsKey(player.userID))
            {
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "SkinMenu");
                opening.Remove(player.userID);
                return;
            }
            else opening.Add(player.userID, true);

            INITPLAYER(player.userID);
            elementbutton page = skinplayers[player.userID].page;
            string ISTRING = "," + BACKGROUNDGUI.Replace("{backgroundmenu}", config.color.backgroundmenu).Replace("{backfootersize}", config.text.pint.size).Replace("{backfooter}", config.text.pint.text);
            float start = 0.01f;
            foreach (var z in config.categorys)
            {
                if (z.Key == page)
                {
                    int i = 1;
                    float startx = conststartx;
                    float starty = conststarty;
                    foreach (var x in z.Value.items)
                    {
                        if (!skinplayers[player.userID].skins.ContainsKey(x)) skinplayers[player.userID].skins.Add(x, 0UL);
                        ISTRING += ELEMENTGUI.Replace("{backgroundskin}", config.color.backgroundskin).Replace("{maxy}", starty.ToString()).Replace("{button}", $"skin.controll show {x} 0").Replace("{miny}", (starty - 0.2f).ToString()).Replace("{maxx}", (startx + 0.088f).ToString()).Replace("{minx}", startx.ToString()).Replace("{png}", GetImage(x, skinplayers[player.userID].skins[x]));
                        if (i % 10 == 0)
                        {
                            startx = conststartx;
                            starty -= 0.22f;
                        }
                        else startx += 0.098f;
                        i++;
                    }
                }
                string KEY = ((int)z.Key).ToString();
                ISTRING += ELEMENTBUTTONGUI.Replace("{num}", KEY).Replace("{button}", $"skin.controll page {KEY}").Replace("{text}", z.Value.name).Replace("{color}", z.Key == page ? config.color.activecolor : config.color.buttoncolor).Replace("{min}", start.ToString()).Replace("{max}", (start + 0.188f).ToString());
                start += BUTTONADD;
            }
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", MAINGUI.Replace("{main}", ISTRING));
        }

        private ulong APISKIN(BasePlayer player, string ITEMNAME)
        {
            playerinfo playerinfo;
            if (!skinplayers.TryGetValue(player.userID, out playerinfo)) return 0UL;
            ulong SKIN;
            if (!playerinfo.skins.TryGetValue(ITEMNAME, out SKIN)) return 0UL;
            return SKIN;
        }
        
        Dictionary<RepairBench, List<ulong>> openrepair = new Dictionary<RepairBench, List<ulong>>();
        private void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            if (entity is RepairBench)
            {
                if (!HAVEACCES(player.UserIDString)) return;
                RepairBench repairBench = entity.GetComponent<RepairBench>();
                if (repairBench.inventory.IsFull())
                {
                    if (!openrepair.ContainsKey(repairBench)) openrepair.Add(repairBench, new List<ulong> { player.userID });
                    else if (!openrepair[repairBench].Contains(player.userID)) openrepair[repairBench].Add(player.userID);

                    CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "SKINPANELMAIN");
                    CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", GUISkin);
                }
            }
        }

        void OnItemRemovedFromContainer(ItemContainer container, Item item)
        {
            if (container.entityOwner == null) return;
            if (container.entityOwner is RepairBench)
            {
                RepairBench repairBench = (RepairBench)container.entityOwner;
                if (!openrepair.ContainsKey(repairBench)) return;
                foreach (var z in openrepair[repairBench])
                {
                    BasePlayer player = BasePlayer.FindByID(z);
                    if (player == null) continue;
                    CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "SKINPANELMAIN");
                }
                openrepair.Remove(repairBench);
            }
        }

        private void CanAcceptItem(ItemContainer container, Item item)
        {
            if (container == null || item == null) return;
            if (container.entityOwner != null && container.entityOwner is RepairBench || item.parent != null && item.parent.entityOwner != null && item.parent.entityOwner is RepairBench)
            {
                RepairBench repairBench = (RepairBench)container.entityOwner ?? (RepairBench)item.parent.entityOwner;
                BasePlayer player = item.GetOwnerPlayer() ?? container.GetOwnerPlayer();
                if (player != null)
                {
                    NextTick(() =>
                    {
                        if (container == null || item == null) return;
                        if (!openrepair.ContainsKey(repairBench)) openrepair.Add(repairBench, new List<ulong>());
                        Item slot = repairBench.inventory.GetSlot(0);
                        if (slot != null)
                        {
                            if (!openrepair[repairBench].Contains(player.userID))
                            {
                                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "SKINPANELMAIN");
                                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", GUISkin);
                                openrepair[repairBench].Add(player.userID);
                            }
                        }
                    });
                }
            }
        }

        void OnPlayerLootEnd(PlayerLoot looter)
        {
            if (looter?.entitySource == null) return;
            if (!(looter.entitySource is RepairBench)) return;
            RepairBench repairBench = (RepairBench)looter.entitySource;
            BasePlayer player = looter.GetComponent<BasePlayer>();
            if (player == null) return;
            if (!HAVEACCES(player.UserIDString)) return;
            if (!openrepair.ContainsKey(repairBench)) openrepair.Add(repairBench, new List<ulong>());
            if (openrepair[repairBench].Contains(player.userID)) openrepair[repairBench].Remove(player.userID);
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "SKINPANELMAIN");
        }

        Dictionary<BasePlayer, DateTime> nextskinchange = new Dictionary<BasePlayer, DateTime>();
        private void ChangeSkin(BasePlayer player, bool rand)
        {
            foreach (var z in openrepair.Where(x => x.Value.Contains(player.userID)))
            {
                if (z.Key == null || z.Key.IsDestroyed) continue;
                Item slot = z.Key.inventory.GetSlot(0);
                if (slot == null) return;
                INITPLAYER(player.userID);
                ulong nextskin = 0UL;
                if (rand)
                {
                    List<ulong> skinlist;
                    if (!config.skins.TryGetValue(slot.info.shortname, out skinlist)) return;
                    nextskin = skinlist[Random.Range(0, skinlist.Count())];
                }
                else nextskin = APISKIN(player, slot.info.shortname);
                if (nextskin == slot.skin) return;
                DateTime time;
                if (nextskinchange.TryGetValue(player, out time) && DateTime.Now < time) return;
                nextskinchange[player] = DateTime.Now.AddSeconds(1f);
                slot.skin = nextskin;
                slot.MarkDirty();
                BaseEntity heldEntity = slot.GetHeldEntity();
                if ((UnityEngine.Object)heldEntity != (UnityEngine.Object)null)
                {
                    heldEntity.skinID = nextskin;
                    heldEntity.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                }
                if (!z.Key.skinchangeEffect.isValid) return;
                Effect.server.Run(z.Key.skinchangeEffect.resourcePath, z.Key, 0U, new Vector3(0.0f, 1.5f, 0.0f), Vector3.zero, (Connection)null, false);

            }
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            Save(player);
            skinplayers.Remove(player.userID);
        }

        private void Save(BasePlayer player)
        {
            playerinfo playerinfo;
            if (!skinplayers.TryGetValue(player.userID, out playerinfo)) return;
            Interface.Oxide.DataFileSystem.WriteObject($"SKINS/{player.UserIDString}", playerinfo);
        }

        private void InitPlayerSkin(BasePlayer player)
        {
            if (!Interface.Oxide.DataFileSystem.ExistsDatafile($"SKINS/{player.UserIDString}")) return;
            playerinfo info = Interface.Oxide.DataFileSystem.ReadObject<playerinfo>($"SKINS/{player.UserIDString}");
            skinplayers[player.userID] = info;
        }

        private void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList) Save(player);
            skinplayers.Clear();
            openrepair.Clear();
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = Network.Net.sv.connections }, null, "DestroyUI", "SkinMenu");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = Network.Net.sv.connections }, null, "DestroyUI", "SKINPANELMAIN");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = Network.Net.sv.connections }, null, "DestroyUI", "ALERT");
            opening.Clear();
        }
    }
}

// --- End of file: SkinMenu.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/Arkan.cs ---
// --- Original Local Path: KualaRust/Arkan.cs ---

﻿using System;
using System.Collections.Generic;
using ProtoBuf;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using System.Globalization;
using Newtonsoft.Json;
using UnityEngine;
using System.Text.RegularExpressions;

namespace Oxide.Plugins
{
    [Info("Arkan", "Antidote", "1.0.18")]
    [Description("Player shot analysis tool for Admins")]
    class Arkan : RustPlugin
    {
        [PluginReference]
        private Plugin DiscordMessages;
		
        #region Fields
		
		private const string permName = "arkan.allowed";
		private const string permNRDrawViolation = "arkan.nr.draw";
		private const string permAIMDrawViolation = "arkan.aim.draw";
		private const string permIRDrawViolation = "arkan.ir.draw";
		private const string permNRReportChat = "arkan.nr.reportchat";
		private const string permNRReportConsole = "arkan.nr.reportconsole";
		private const string permAIMReportChat = "arkan.aim.reportchat";
		private const string permAIMReportConsole = "arkan.aim.reportconsole";
		private const string permIRReportChat = "arkan.ir.reportchat";
		private const string permIRReportConsole = "arkan.ir.reportconsole";
		private const string permNRWhitelist = "arkan.nrwhitelist";
		private const string permNRBlacklist = "arkan.nrblacklist";
		private const string permAIMWhitelist = "arkan.aimwhitelist";
		private const string permAIMBlacklist = "arkan.aimblacklist";
		private const string permIRWhitelist = "arkan.irwhitelist";
		private const string permIRBlacklist = "arkan.irblacklist";

        private Dictionary<ulong, PlayerFiredProjectlesData> PlayersFiredProjectlesData = new Dictionary<ulong, PlayerFiredProjectlesData>();

        private PlayersViolationsData PlayersViolations = new PlayersViolationsData();
        private PlayersViolationsData tmpPlayersViolations = new PlayersViolationsData();
        private string serverTimeStamp;
        private bool isAttackShow = false; //for development purposes only
		private AdminConfig RconLog = new AdminConfig();
		
		private readonly int world_defaultLayer = LayerMask.GetMask("World", "Default");
		private readonly int world_terrainLayer = LayerMask.GetMask("World", "Terrain");
		private readonly int terrainLayer = LayerMask.GetMask("Terrain");
		private readonly string stringNullValueWarning = "Error: value is null";

        private Dictionary<BasePlayer, AdminConfig> AdminsConfig = new Dictionary<BasePlayer, AdminConfig>();
		
		private static Configuration _config;
		
		private class Configuration
		{
            public float NRProcessTimer = 4f;
            public float EPSILON = 0.005f;
            public float projectileTrajectoryForgiveness = 0.3f;
            public float hitDistanceForgiveness = 0.25f;
            public float minDistanceAIMCheck = 10.0f;			
	 		public float inRockCheckDistance = 200f;
            public bool isDetectAIM = true;
            public bool isDetectNR = true;
	 		public bool isDetectIR = true;
            public bool debugMessages = true;
            public bool autoSave = true;
			public bool isCheckAIMOnTargetNPC = true;
            public float drawTime = 60f;
            public float NRViolationAngle = 0.3f;
            public float NRViolationScreenDistance = 5f;
            public float playerEyesPositionToProjectileInitialPositionDistanceForgiveness = 10f;
			
			[JsonProperty(PropertyName = "The maximum allowed value for the physics.steps parameter")]
			public float minPhysicsStepsAllowed = 40f;	
			
			[JsonProperty(PropertyName = "Check players only on the blacklist")]
	 		public bool checkBlacklist = false;
			
			[JsonProperty(PropertyName = "Notify when a player has a high value of the physics.steps parameter")]
	 		public bool notifyPhysicsStepsWarning = false;
			
			[JsonProperty(PropertyName = "Enable Discord No Recoil Notifications")]
	 		public bool DiscordNRReportEnabled = false;
			
			[JsonProperty(PropertyName = "Enable Discord AIMBOT Notifications")]
	 		public bool DiscordAIMReportEnabled = false;
			
			[JsonProperty(PropertyName = "Enable Discord In Rock Notifications")]
	 		public bool DiscordIRReportEnabled = false;
			
			[JsonProperty(PropertyName = "Discord No Recoil Webhook URL")]
	 		public string DiscordNRWebhookURL = "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks";
			
			[JsonProperty(PropertyName = "Discord AIMBOT Webhook URL")]
	 		public string DiscordAIMWebhookURL = "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks";
			
			[JsonProperty(PropertyName = "Discord In Rock Webhook URL")]
	 		public string DiscordIRWebhookURL = "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks";

			[JsonProperty(PropertyName = "AIMBodyParts", ObjectCreationHandling = ObjectCreationHandling.Replace)]		
			public List<string> AIMBodyParts = new List<string>()
			{
				"head",
				"chest"
			};

			[JsonProperty(PropertyName = "IRBodyParts", ObjectCreationHandling = ObjectCreationHandling.Replace)]
			public List<string> IRBodyParts = new List<string>()
            {
                "body",
				"pelvis",
				"left knee",
				"left foot",
				"left toe",
				"groin",
				"hip",
				"right knee",
				"right foot",
				"right toe",
				"lower spine",
				"stomach",
				"chest",
				"left shoulder",
				"left arm",
				"left forearm",
				"left hand",
				"left ring finger",
				"left thumb",
				"left wrist",
				"neck",
				"head",
				"jaw",
				"left eye",
				"right eye",
				"right shoulder",
				"right arm",
				"right forearm",
				"right hand",
				"right ring finger",
				"right thumb",
				"right wrist"
            };
    
			[JsonProperty(PropertyName = "weaponsConfig")]
            public Dictionary<string, WeaponConfig> weaponsConfig = new Dictionary<string, WeaponConfig>() {
                {"rifle.ak", new WeaponConfig() {NRDetectEnabled = true, AIMDetectEnabled = true, weaponMinTimeShotsInterval = 0.09375f, weaponMaxTimeShotsInterval = 0.15625f, NRMinShotsCountToCheck = 5, NRViolationProbability = 70f}},
                {"lmg.m249", new WeaponConfig() {NRDetectEnabled = true, AIMDetectEnabled = true, weaponMinTimeShotsInterval = 0.09375f, weaponMaxTimeShotsInterval = 0.15625f, NRMinShotsCountToCheck = 5, NRViolationProbability = 70f}},
                {"pistol.nailgun", new WeaponConfig() {NRDetectEnabled = true, AIMDetectEnabled = true, weaponMinTimeShotsInterval = 0.09375f, weaponMaxTimeShotsInterval = 0.15625f, NRMinShotsCountToCheck = 5, NRViolationProbability = 70f}},
                {"smg.2", new WeaponConfig() {NRDetectEnabled = true, AIMDetectEnabled = true, weaponMinTimeShotsInterval = 0.09375f, weaponMaxTimeShotsInterval = 0.125f, NRMinShotsCountToCheck = 5, NRViolationProbability = 70f}},
                {"smg.thompson", new WeaponConfig() {NRDetectEnabled = true, AIMDetectEnabled = true, weaponMinTimeShotsInterval = 0.09375f, weaponMaxTimeShotsInterval = 0.15625f, NRMinShotsCountToCheck = 5, NRViolationProbability = 70f}},
                {"smg.mp5", new WeaponConfig() {NRDetectEnabled = true, AIMDetectEnabled = true, weaponMinTimeShotsInterval = 0.0625f, weaponMaxTimeShotsInterval = 0.125f, NRMinShotsCountToCheck = 5, NRViolationProbability = 70f}},
                {"bow.hunting", new WeaponConfig() {NRDetectEnabled = false, AIMDetectEnabled = true}},
            //    {"bow.compound", new WeaponConfig() {NRDetectEnabled = false, AIMDetectEnabled = true}},
                {"crossbow", new WeaponConfig() {NRDetectEnabled = false, AIMDetectEnabled = true}},
                {"rifle.bolt", new WeaponConfig() {NRDetectEnabled = false, AIMDetectEnabled = true}},
                {"rifle.l96", new WeaponConfig() {NRDetectEnabled = false, AIMDetectEnabled = true}},
                {"rifle.m39", new WeaponConfig() {NRDetectEnabled = false, AIMDetectEnabled = true}},
                {"rifle.semiauto", new WeaponConfig() {NRDetectEnabled = false, AIMDetectEnabled = true}},
                {"pistol.m92", new WeaponConfig() {NRDetectEnabled = false, AIMDetectEnabled = true}},
                {"pistol.python", new WeaponConfig() {NRDetectEnabled = false, AIMDetectEnabled = true}},
                {"pistol.revolver", new WeaponConfig() {NRDetectEnabled = false, AIMDetectEnabled = true}},
                {"pistol.semiauto", new WeaponConfig() {NRDetectEnabled = false, AIMDetectEnabled = true}},
                {"rifle.lr300", new WeaponConfig() {NRDetectEnabled = true, AIMDetectEnabled = true, weaponMinTimeShotsInterval = 0.09375f, weaponMaxTimeShotsInterval = 0.15625f, NRMinShotsCountToCheck = 5, NRViolationProbability = 70f}}
            };
		}

        private class WeaponConfig
        {
            public bool NRDetectEnabled;
            public bool AIMDetectEnabled;
            public float weaponMinTimeShotsInterval;
            public float weaponMaxTimeShotsInterval;
            public int NRMinShotsCountToCheck;
            public float NRViolationProbability;
        }

        private class ViolationsLog
        {
            public ulong steamID;
            public int NoRecoilViolation;
            public int AIMViolation;
			public int InRockViolation;
        }

        private class AdminConfig
        {
            public ViolationsLog violationsLog = new ViolationsLog();
        }

        private class PlayersViolationsData
        {
            public int seed;
            public int mapSize;
            public string serverTimeStamp;
            public DateTime lastSaveTime;
            public DateTime lastChangeTime;
            public Dictionary<ulong, PlayerViolationsData> Players = new Dictionary<ulong, PlayerViolationsData>();
        }

        private class PlayerFiredProjectlesData
        {
            public ulong PlayerID;
            public string PlayerName;
            public float lastFiredTime;
			public float physicsSteps = 32f;
            public SortedDictionary<int, FiredProjectile> firedProjectiles = new SortedDictionary<int, FiredProjectile>();
            public SortedDictionary<uint, MeleeThrown> melees = new SortedDictionary<uint, MeleeThrown>();
            public bool isChecked;
        }

        private class PlayerViolationsData
        {
            public ulong PlayerID;
            public string PlayerName;
            public SortedDictionary<string, NoRecoilViolationData> noRecoilViolations = new SortedDictionary<string, NoRecoilViolationData>();
            public SortedDictionary<string, AIMViolationData> AIMViolations = new SortedDictionary<string, AIMViolationData>();
			public SortedDictionary<string, InRockViolationsData> inRockViolations = new SortedDictionary<string, InRockViolationsData>();
        }

        private class HitData
        {
            public ProjectileRicochet hitData;
            public Vector3 startProjectilePosition;
            public Vector3 startProjectileVelocity;
            public Vector3 hitPositionWorld;
            public Vector3 hitPointStart;
            public Vector3 hitPointEnd;
            public bool isHitPointNearProjectileTrajectoryLastSegmentEndPoint = true;
            public bool isHitPointOnProjectileTrajectory = true;
            public bool isProjectileStartPointAtEndReverseProjectileTrajectory = true;
            public bool isHitPointNearProjectilePlane = true;
            public bool isLastSegmentOnProjectileTrajectoryPlane = true;
            public float distanceFromHitPointToProjectilePlane = 0f;
            public int side;
			public Vector3 pointProjectedOnLastSegmentLine;
            public float travelDistance = 0f;
            public float delta = 1f;
            public Vector3 lastSegmentPointStart;
            public Vector3 lastSegmentPointEnd;
            public Vector3 reverseLastSegmentPointStart;
            public Vector3 reverseLastSegmentPointEnd;
        }

        private class AIMViolationData
        {
            public int projectileID;
            public int violationID;
			public DateTime firedTime;
            public Vector3 startProjectilePosition;
            public Vector3 startProjectileVelocity;
            public string hitInfoInitiatorPlayerName;
            public string hitInfoInitiatorPlayerUserID;
            public string hitInfoHitEntityPlayerName;
            public string hitInfoHitEntityPlayerUserID;
            public string hitInfoBoneName;
            public Vector3 hitInfoHitPositionWorld;
            public float hitInfoProjectileDistance;
            public Vector3 hitInfoPointStart;
            public Vector3 hitInfoPointEnd;
            public float hitInfoProjectilePrefabGravityModifier;
            public float hitInfoProjectilePrefabDrag;
            public string weaponShortName;
            public string ammoShortName;
            public string bodyPart;
            public float damage;
            public bool isEqualFiredProjectileData = true;
            public bool isPlayerPositionToProjectileStartPositionDistanceViolation = false;
            public float distanceDifferenceViolation = 0f;
            public float calculatedTravelDistance;
            public bool isAttackerMount = false;
            public bool isTargetMount = false;
            public string attackerMountParentName;
            public string targetMountParentName;
            public float firedProjectileFiredTime;
            public float firedProjectileTravelTime;
            public Vector3 firedProjectilePosition;
            public Vector3 firedProjectileVelocity;
            public Vector3 firedProjectileInitialPosition;
            public Vector3 firedProjectileInitialVelocity;
            public Vector3 playerEyesLookAt;
            public Vector3 playerEyesPosition;
            public bool hasFiredProjectile = false;
            public List<HitData> hitsData = new List<HitData>();
            public float gravityModifier;
            public float drag;
			public float forgivenessModifier = 1f;
			public float physicsSteps = 32f;
			public List<string> attachments = new List<string>();
        }

        private class NoRecoilViolationData
        {
            public int ShotsCnt;
            public int NRViolationsCnt;
            public float violationProbability;
            public bool isMounted;
            public Vector3 mountParentPosition;
			public Vector4 mountParentRotation;
            public List<string> attachments = new List<string>();
            public string ammoShortName;
            public string weaponShortName;

            public Dictionary<int, SuspiciousProjectileData> suspiciousNoRecoilShots = new Dictionary<int, SuspiciousProjectileData>();
        }
		
		private class InRockViolationsData
        {
			public DateTime dateTime;
			
			public Dictionary<int, InRockViolationData> inRockViolationsData = new Dictionary<int, InRockViolationData>();
        }

		private class InRockViolationData
        {
			public DateTime dateTime;
            public float physicsSteps;
			public float targetHitDistance;
			public string targetName;
			public string targetID;
			public float targetDamage;
			public string targetBodyPart;
			public Vector3 targetHitPosition;
			public Vector3 rockHitPosition;
			public FiredProjectile firedProjectile;
			public int projectileID;
            public float drag;
            public float gravityModifier;
        }

        private struct SuspiciousProjectileData
        {
            public DateTime timeStamp;
            public int projectile1ID;
            public int projectile2ID;
            public float timeInterval;
            public Vector3 projectile1Position;
            public Vector3 projectile2Position;
            public Vector3 projectile1Velocity;
            public Vector3 projectile2Velocity;
            public Vector3 closestPointLine1;
            public Vector3 closestPointLine2;
            public Vector3 prevIntersectionPoint;
            public float recoilAngle;
            public float recoilScreenDistance;
            public bool isNoRecoil;
            public bool isShootedInMotion;
        }

        private class FiredShotsData
        {
            public string ammoShortName;
            public string weaponShortName;
            public List<string> attachments = new List<string>();
            public SortedDictionary<int, FiredProjectile> firedShots = new SortedDictionary<int, FiredProjectile>();
        }

        private class FiredProjectile
        {
            public DateTime firedTime;
            public Vector3 projectileVelocity;
            public Vector3 projectilePosition;
            public Vector3 playerEyesLookAt;
            public Vector3 playerEyesPosition;
            public bool isChecked;
            public string ammoShortName;
            public string weaponShortName;
            public uint weaponUID;
            public bool isMounted;
            public string mountParentName;
            public Vector3 mountParentPosition;
			public Vector4 mountParentRotation;
            public List<ProjectileRicochet> hitsData = new List<ProjectileRicochet>();
            public List<string> attachments = new List<string>();
            public float NRProbabilityModifier = 1f;
        }

        private struct MeleeThrown
        {
            public DateTime firedTime;
            public Vector3 position;
            public Vector3 playerEyesLookAt;
            public Vector3 playerEyesPosition;
            public float projectileVelocity;
            public float drag;
            public float gravityModifier;
            public string meleeShortName;
            public uint meleeUID;
            public bool isMounted;
            public string mountParentName;
            public Vector3 mountParentPosition;
			public Vector4 mountParentRotation;
        }

        private struct ProjectileRicochet
        {
            public int projectileID;
            public Vector3 hitPosition;
            public Vector3 inVelocity;
            public Vector3 outVelocity;
        }
		
		private class TrajectorySegment
        {
			public Vector3 pointStart;
			public Vector3 pointEnd;
        }
		
		public class EmbedFieldList
        {
            public string name { get; set;}
            public string value { get; set; }
            public bool inline { get; set; }
        }

        #endregion Fields

        #region Localization		

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["PlayerAIMViolation"] = "<color=red><color=green>Arkan:</color> Player <color=yellow>{0}/{1}</color> has possibly AIMBOT violation <color=yellow>#{2}</color>. Target <color=yellow>{3}/{4}</color></color>",
				["PlayerAIMViolationCon"] = "Player {0}/{1} has possibly AIMBOT violation #{2}. Target {3}/{4}",
				["PlayerIRViolation"] = "<color=red><color=green>Arkan:</color> Player <color=yellow>{0}/{1}</color> has In Rock violation <color=yellow>#{2}</color>. Shots count <color=yellow>{3}</color></color>",
				["PlayerIRViolationCon"] = "<color=green>Arkan:</color> Player {0}/{1} has In Rock violation #{2}. Shots count <color=yellow>{3}</color></color>",
                ["InitPlgText1"] = "Arkan Init: map seed: {0}, map size: {1}, server timestamp: {2}",
                ["AIMText1"] = "AIMBOT probable violation\n",
                ["AIMText2"] = "HitPoint is located before line ProjectileTrajectoryLastSegment",
                ["AIMText3"] = "HitPoint is located behind line ProjectileTrajectoryLastSegment",
                ["AIMText4"] = "AIMBOT Violation: HitPoint is not located within line ProjectileTrajectoryLastSegment. \nBut HitPoint is located near the plane ProjectilePlane at a distance {0}. {1}, distance to {2} {3}",
                ["AIMText6"] = "AIMBOT Violation: ProjectileTrajectoryFirstSegments does not match calculated by FiredProjectile data: pointStart = {0} pointEnd = {1}, by HitInfo data: pointStart = {2} pointEnd = {3}\n",
                ["AIMText7"] = "AIMBOT Violation: HitPoint is not near the plane ProjectilePlane at a distance {0}\n",
                ["AIMText8"] = "AIMBOT Violation: ProjectileTrajectoryLastSegments does not match calculated by FiredProjectile data: pointStart = {0}, by HitInfo data: pointStart = {1} pointEnd = {2}\n",
				["ClearVD"] = "<color=red><color=green>Arkan:</color> Violations data cleared</color>",
                ["SaveVD1"] = "<color=red><color=green>Arkan:</color> Violation data saved in file <color=yellow>{0}</color></color>",
                ["LoadVD1"] = "<color=red><color=green>Arkan:</color> File <color=yellow>{0}</color> exist, saved data loaded</color>",
                ["LoadVD2"] = "Saved data map seed:{0} doesn't match map seed:{1}",
                ["LoadVD3"] = "Saved data map size:{0} doesn't match map size:{1}",
                ["LoadVD4"] = "<color=red><color=green>Arkan:</color> File <color=yellow>{0}</color> doesn't exist</color>",
				["LogText6"] = "     Distance difference {0}\n",
				["LogText7"] = "____Trajectory #{0} check data____",
				["LogText8"] = "____Trajectory #{0} data log end____",
				["VDataLog"] = "Violation data log",
				["ErrorText1"] = "Projectile data collect error: player {0}, missing projectileShoot data",
				["ErrorText2"] = "AIMBOT check error: attacker {0}, target {1}, missing ProjectileID: {2}",				
				["ShowLog1v1.0.13"] = "<size=14><color=orange><color=green>Arkan</color> by Antidote</color></size>\n" +
                    "Commands in chat:\n" +
                    "<color=orange>/arkan</color> - Show all No Recoil/AIMBOT/In Rock violations\n" +
                    "<color=orange>/arkannr</color> - Show all No Recoil violations\n" +
                    "<color=orange>/arkannr SteamID/NAME</color> - Teleport to player's first/next No Recoil violation position\n" +
                    "<color=orange>/arkannr SteamID/NAME 0/num</color> - Teleport to player's first/specific No Recoil violation position\n" +
                    "<color=orange>/arkanaim</color> - Show all AIMBOT violations\n" +
                    "<color=orange>/arkanaim SteamID/NAME</color> - Teleport to player's first/next AIMBOT violation position\n" +
                    "<color=orange>/arkanaim SteamID/NAME 0/num</color> - Teleport to player's first/specific AIMBOT violation position\n" +
					"<color=orange>/arkanir</color> - Show all In Rock violations\n" +
                    "<color=orange>/arkanir SteamID/NAME</color> - Teleport to player's first/next In Rock violation position\n" +
                    "<color=orange>/arkanir SteamID/NAME 0/num</color> - Teleport to player's first/specific In Rock violation position\n" +
                    "<color=orange>/arkansave, /arkansave filename</color> - Saves all violations to datafile\n" +
                    "<color=orange>/arkanload, /arkanload filename</color> - Loads violations from datafile\n\n",
                ["ShowLog2"] = "<size=14><color=orange>Players violations list:</color>\n<color=red>",
                ["ShowLog3"] = "<size=14><color=orange>Players violations list empty",
				["ShowInfo"] = "<size=14><color=orange><color=green>Arkan</color> by Antidote</color></size>\n" +
                    "Arkan commands info: <color=orange>/arkaninfo</color>\n\n",
                ["ShowNRLog2"] = "<size=14><color=orange>Players No Recoil violations list:</color>\n<color=red>",
                ["ShowNRLog3"] = "<size=14><color=orange>Players No Recoil violations list empty",
                ["ShowIRLog2"] = "<size=14><color=orange>Players In Rock violations list:</color>\n<color=red>",
                ["ShowIRLog3"] = "<size=14><color=orange>Players In Rock violations list empty",
				["ShowAIMLog2"] = "<size=14><color=orange>Players AIMBOT violations list:</color>\n<color=red>",	
                ["ShowAIMLog3"] = "<size=14><color=orange>Players AIMBOT violations list empty",
				["DrawIRVD1"] = "Player <color=yellow>{0}</color>\nIn Rock violation <color=gray>#{1}</color>\nEntity <color=gray>{2}</color>",
                ["DrawNRVD1"] = "Player <color=yellow>{0}</color>\nAmmo <color=gray>{1}</color>\nWeapon <color=gray>{2}</color>\nShots count <color=gray>{3}</color>\nViolation probability <color=gray>{4}</color>",
                ["DrawAIMVD3"] = "Target <color=yellow>{0}</color>\nBody part <color=gray>{1}</color>\nDamage <color=gray>{2}</color>",
                ["DrawAIMVD4"] = "Attacker <color=yellow>{0}</color>\nProjectileID <color=gray>{1}</color>\nAmmo <color=gray>{2}</color>\nWeapon <color=gray>{3}</color>\nDistance <color=gray>{4}</color>",
                ["DrawAIMVD5"] = "Attacker <color=yellow>{0}</color>, violation <color=gray>#{1}</color>\nPlayer position: <color=gray>{2}</color>\nProjectile start position: <color=gray>{3}</color>\nDistance: <color=gray>{4}</color>",
                ["ShowD1"] = "Clear current violation number",
                ["ShowD2"] = "Error. There is no such player in the logs",	
                ["ShowD3"] = "Player {0} has no more positive detections",
                ["NoMoreViolations"] = "<color=red>Player <color=yellow>{0}</color> has no more positive detections</color>",
                ["ShowNRD1"] = "Error. Player {0} has no No Recoil violation",
                ["ShowNRD2"] = "No Recoil violations count: <color=yellow>{0}</color>\n",
                ["ShowNRD3"] = "Current No Recoil violation number: <color=yellow>{0}</color>",
				["ShowIRD1"] = "Error. Player {0} has no In Rock violation",
                ["ShowIRD2"] = "In Rock violations count: <color=yellow>{0}</color>\n",
                ["ShowIRD3"] = "Current In Rock violation number: <color=yellow>{0}</color>",
                ["Player"] = "<color=green>Arkan:</color> <color=red>Player <color=yellow>{0}</color>\n",
                ["ShowAIMD1"] = "Error. Player {0} has no AIMBOT violation",
                ["ShowAIMD2"] = "AIMBOT violations count: <color=yellow>{0}</color>\n",
                ["ShowAIMD3"] = "Current AIMBOT violation number: <color=yellow>{0}</color></color>",
				["ClosestPoint"] = "Closest point 1: {0} Closest point 2: {1}, prev {2}",
				["StandingShooting"] = "Standing shooting position",
				["ShootingOnMove"] = "Shooting on the move",
				["FireTimeInterval"] = "Fire time interval {0}",
				["ProjectileID"] = "Projectile ID: {0}",
				["PlayerTxt"] = "Player",
				["Probability"] = "Probability",
				["ShotsCount"] = "Shots count",
				["AttachmentsCount"] = "Attachments count",
				["Attachment"] = "Attachment",
				["Weapon"] = "Weapon",
				["Ammo"] = "Ammo",
				["NoAttachments"] = "No attachments",
				["Attacker"] = "Attacker",
				["Target"] = "Target",
				["HitPart"] = "Hit part",
				["RecoilAngle"] = "Recoil angle: {0}",
				["Distance"] = "Distance",
				["Damage"] = "Damage",
				["NRDetection"] = "No Recoil probable violation",
				["IRDetection"] = "In Rock violation",
				["DistanceToFirstPoint"] = "Distance to first point: {0}",
				["ScreenCoords"] = "Screen coords point1: {0}, coords point2: {1}",
				["NRViolationNum"] = "NR violation #",
				["AIMViolationNum"] = "AIMBOT violation #",
				["IRViolationNum"] = "IR violation #",
				["AIMDetection"] = "AIMBOT probable violation",
				["DateTime"] = "Date/Time",
                ["MountedOn"] = "Attacker mounted on {0}",
				["RicochetsCount"] = "Ricochets count",
				["DistanceBetweenTwoPoints"] = "Distance between two points: {0}",
				["HighPhysicsStepsDetection"] = "Detected high value of the physics.steps parameter",
				["PhysicsStepsChangeWarning"] = "Player {0} probably changed the value of the physics.steps parameter to ~{1}({2}). The default value for physics.steps is 32.\nChanging the value of this parameter to a higher value allows the player to gain advantages over normal game play (allows jumping higher).",
				["Description"] = "Description",
				["DiscordWarning2"] = "Error: Discord reports enabled but plugin DiscordMessages not loaded!",
				["DiscordWarningNR"] = "Error: Discord No Recoil reports enabled but webhook for No Recoil violation is not configured!",
				["DiscordWarningAIM"] = "Error: Discord AIMBOT reports enabled but webhook for AIMBOT violation is not configured!",
				["DiscordWarningIR"] = "Error: Discord In Rock reports enabled but webhook for In Rock violation is not configured!",
                ["PlayerNRViolation"] = "<size=14><color=red><color=green>Arkan:</color> Player <color=yellow>{0}/{1}</color> has possibly No Recoil violation <color=yellow>#{2}</color>\ntotal shots cnt: <color=yellow>{3}</color> | shots with low recoil cnt: <color=yellow>{4}</color>\nprobability: <color=yellow>{5}%</color></color></size>",
				["PlayerNRViolationCon"] = "Arkan: Player {0}/{1} has possibly No Recoil violation #{2}\ntotal shots cnt: {3} | shots with low recoil cnt: {4}\nprobability: {5}",
            }, this, "en");
			
			lang.RegisterMessages(new Dictionary<string, string>
            {
                ["PlayerAIMViolation"] = "<color=red><color=green>Arkan:</color> У игрока <color=yellow>{0}/{1}</color> обнаружено возможное нарушение AIM <color=yellow>#{2}</color>. Жертва <color=yellow>{3}/{4}</color></color>",
				["PlayerAIMViolationCon"] = "У игрока {0}/{1} обнаружено возможное нарушение AIM #{2}. Жертва {3}/{4}",
				["PlayerIRViolation"] = "<color=red><color=green>Arkan:</color> У игрока <color=yellow>{0}/{1}</color> обнаружено нарушение In Rock <color=yellow>#{2}</color>. Количество выстрелов <color=yellow>{3}</color></color>",
				["PlayerIRViolationCon"] = "<color=green>Arkan:</color> У игрока {0}/{1} обнаружено нарушение In Rock #{2}. Количество выстрелов <color=yellow>{3}</color></color>",
                ["InitPlgText1"] = "Arkan Init: сид карты: {0}, размер карты: {1}, timestamp сервера: {2}",
                ["AIMText1"] = "Вероятное нарушение AIMBOT\n",
                ["AIMText2"] = "HitPoint расположен перед сегментом траектории ProjectileTrajectoryLastSegment",
                ["AIMText3"] = "HitPoint расположен за сегментом траектории ProjectileTrajectoryLastSegment",
                ["AIMText4"] = "AIMBOT Нарушение: HitPoint расположен вне сегмента траектории ProjectileTrajectoryLastSegment. \nНо HitPoint расположен недалеко от плоскости ProjectilePlane на расстоянии {0}. {1}, дистанция к {2} {3}",
                ["AIMText6"] = "AIMBOT Нарушение: ProjectileTrajectoryFirstSegments не соответствует рассчитанным данным FiredProjectile: pointStart = {0} pointEnd = {1}, по данным HitInfo: pointStart = {2} pointEnd = {3}\n",
                ["AIMText7"] = "AIMBOT Нарушение: HitPoint расположен слишком далеко от плоскости ProjectilePlane на расстоянии {0}\n",
                ["AIMText8"] = "AIMBOT Нарушение: ProjectileTrajectoryLastSegments не соответствует рассчитанным данным FiredProjectile: pointStart = {0}, по данным HitInfo: pointStart = {1} pointEnd = {2}\n",
				["ClearVD"] = "<color=red><color=green>Arkan:</color> Данные нарушений очищены</color>",
                ["SaveVD1"] = "<color=red><color=green>Arkan:</color> Данные нарушений сохранены в файл <color=yellow>{0}</color></color>",
                ["LoadVD1"] = "<color=red><color=green>Arkan:</color> Файл <color=yellow>{0}</color> существует, сохранненые в нем данные загружены</color>",
                ["LoadVD2"] = "В загружаемом лог-файле сид карты:{0} не соответствует сиду карты на сервере:{1}",
                ["LoadVD3"] = "В загружаемом лог-файле размер карты:{0} не соответствует размеру карты на сервере:{1}",
                ["LoadVD4"] = "<color=red><color=green>Arkan:</color> Файл <color=yellow>{0}</color> не существует</color>",
				["LogText6"] = "     Разница расстояния {0}\n",
				["LogText7"] = "____Данные проверки траектории #{0}____",
				["LogText8"] = "____Конец данных лога проверки траектории #{0}____",
				["VDataLog"] = "Лог данных нарушения",
				["ErrorText1"] = "Ошибка при сборе данных снаряда: игрок {0}, отсутствуют данные projectileShoot",
				["ErrorText2"] = "Ошибка при проверке AIMBOT: атакующий {0}, жертва {1}, пропущен ProjectileID: {2}",
                ["ShowLog1v1.0.13"] = "<size=14><color=orange><color=green>Arkan</color> by Antidote</color></size>\n" +
                    "Команды в чат:\n" +
                    "<color=orange>/arkan</color> - Показывает список всех No Recoil/AIMBOT/In Rock нарушений\n" +
                    "<color=orange>/arkannr</color> - Показывает список всех No Recoil нарушений\n" +
                    "<color=orange>/arkannr SteamID/NAME</color> - Телепортирует на первую/следующую позицию нарушения No Recoil игрока\n" +
                    "<color=orange>/arkannr SteamID/NAME 0/num</color> - Телепортирует на первую/определенную позицию нарушения No Recoil игрока\n" +
                    "<color=orange>/arkanaim</color> - Показывает список всех AIMBOT нарушений\n" +
                    "<color=orange>/arkanaim SteamID/NAME</color> - Телепортирует на первую/следующую позицию нарушения AIMBOT игрока\n" +
                    "<color=orange>/arkanaim SteamID/NAME 0/num</color> - Телепортирует на первую/определенную позицию нарушения AIMBOT игрока\n" +
					"<color=orange>/arkanir</color> - Показывает список всех In Rock нарушений\n" +
                    "<color=orange>/arkanir SteamID/NAME</color> - Телепортирует на первую/следующую позицию нарушения In Rock игрока\n" +
                    "<color=orange>/arkanir SteamID/NAME 0/num</color> - Телепортирует на первую/определенную позицию нарушения No Recoil игрока\n" +
                    "<color=orange>/arkansave, /arkansave filename</color> - Сохраняет все данные нарушений в файл\n" +
                    "<color=orange>/arkanload, /arkanload filename</color> - Загружает сохраненные данные нарушений из файла\n\n",
                ["ShowLog2"] = "<size=14><color=orange>Список нарушений игроков:</color>\n<color=red>",
                ["ShowLog3"] = "<size=14><color=orange>Список нарушений игрока пуст",
				["ShowInfo"] = "<size=14><color=orange><color=green>Arkan</color> by Antidote</color></size>\n" +
                    "Инфо по командам Arkan: <color=orange>/arkaninfo</color>\n\n",
                ["ShowNRLog2"] = "<size=14><color=orange>Список нарушений No Recoil игроков:</color>\n<color=red>",
                ["ShowNRLog3"] = "<size=14><color=orange>Список нарушений No Recoil игрока пуст",
                ["ShowIRLog2"] = "<size=14><color=orange>Список нарушений In Rock игроков:</color>\n<color=red>",
                ["ShowIRLog3"] = "<size=14><color=orange>Список нарушений In Rock игрока пуст",
				["ShowAIMLog2"] = "<size=14><color=orange>Список нарушений AIMBOT игроков:</color>\n<color=red>",
                ["ShowAIMLog3"] = "<size=14><color=orange>Список нарушений AIMBOT игрока пуст",
				["DrawIRVD1"] = "Игрок <color=yellow>{0}</color>\nIn Rock нарушение <color=gray>#{1}</color>\nОбъект <color=gray>{2}</color>",
                ["DrawNRVD1"] = "Игрок <color=yellow>{0}</color>\nАммо <color=gray>{1}</color>\nОружие <color=gray>{2}</color>\nКоличество выстрелов <color=gray>{3}</color>\nВероятность нарушения <color=gray>{4}</color>",
                ["DrawAIMVD3"] = "Жертва <color=yellow>{0}</color>\nЧасть тела <color=gray>{1}</color>\nПовреждение <color=gray>{2}</color>",
                ["DrawAIMVD4"] = "Атакующий <color=yellow>{0}</color>\nProjectileID <color=gray>{1}</color>\nАммо <color=gray>{2}</color>\nОружие <color=gray>{3}</color>\nРасстояние <color=gray>{4}</color>",
                ["DrawAIMVD5"] = "Атакующий <color=yellow>{0}</color>, нарушение <color=gray>#{1}</color>\nПозиция игрока: <color=gray>{2}</color>\nТочка старта снаряда: <color=gray>{3}</color>\nРасстояние: <color=gray>{4}</color>",
                ["ShowD1"] = "Номер текущего нарушения сброшен",
                ["ShowD2"] = "Ошибка. Такого игрока нет в логах",
                ["ShowD3"] = "У игрока {0} нет больше нарушений",
                ["NoMoreViolations"] = "<color=red>У игрока <color=yellow>{0}</color> нет больше нарушений</color>",
                ["ShowNRD1"] = "Ошибка. У игрока {0} нет нарушения No Recoil",
                ["ShowNRD2"] = "Количество нарушений No Recoil: <color=yellow>{0}</color>\n",
                ["ShowNRD3"] = "Номер текущего нарушения No Recoil: <color=yellow>{0}</color>",
				["ShowIRD1"] = "Ошибка. У игрока {0} нет нарушения In Rock",
                ["ShowIRD2"] = "Количество нарушений In Rock: <color=yellow>{0}</color>\n",
                ["ShowIRD3"] = "Номер текущего нарушения In Rock: <color=yellow>{0}</color>",
                ["Player"] = "<color=green>Arkan:</color> <color=red>Игрок <color=yellow>{0}</color>\n",
                ["ShowAIMD1"] = "Ошибка. У игрока {0} нет нарушения AIMBOT",
                ["ShowAIMD2"] = "Количество нарушений AIMBOT: <color=yellow>{0}</color>\n",
                ["ShowAIMD3"] = "Номер текущего нарушения AIMBOT: <color=yellow>{0}</color></color>",
				["ClosestPoint"] = "Ближайшая точка 1: {0} Ближайшая точка 2: {1}, Предыдущая ближайшая точка {2}",
				["StandingShooting"] = "Стрельба из положения стоя",
				["ShootingOnMove"] = "Стрельба в движении",
				["FireTimeInterval"] = "Интервал между выстрелами {0}",
				["ProjectileID"] = "ID снаряда: {0}",
				["PlayerTxt"] = "Игрок",
				["Probability"] = "Вероятность",
				["ShotsCount"] = "Количество выстрелов",
				["Weapon"] = "Оружие",
				["Ammo"] = "Боеприпас",
				["AttachmentsCount"] = "Количество навески",
				["Attachment"] = "Навеска",
				["NoAttachments"] = "Нет навески",
				["Attacker"] = "Атакующий",
				["Target"] = "Жертва",
				["HitPart"] = "Место попадания",
				["RecoilAngle"] = "Угол отдачи: {0}",
				["Distance"] = "Расстояние",
				["Damage"] = "Урон",
				["NRDetection"] = "Вероятное нарушение No Recoil",
				["IRDetection"] = "Нарушение In Rock",
				["DistanceToFirstPoint"] = "Расстояние до первой точки: {0}",
				["ScreenCoords"] = "Экранные координаты точки point1: {0}, экранные координаты точки point2: {1}",
				["NRViolationNum"] = "Нарушение NR #",
				["AIMViolationNum"] = "Нарушение AIMBOT #",
				["IRViolationNum"] = "Нарушение IR #",
				["AIMDetection"] = "Вероятное нарушение AIMBOT",
				["DateTime"] = "Дата/Время",
                ["MountedOn"] = "Атакующий состыкован с {0}",
				["RicochetsCount"] = "Количество рикошетов",
				["DistanceBetweenTwoPoints"] = "Расстояние между двумя точками: {0}",
				["HighPhysicsStepsDetection"] = "Обнаружено высокое значение параметра physics.steps",
				["PhysicsStepsChangeWarning"] = "Игрок {0} вероятно изменил значение параметра physics.steps на ~{1}({2}). Значение по умолчанию для physics.steps 32.\nИзменение значения этого параметра на более высокое значение позволяет игроку получить преимущества по сравнению с обычной игрой (позволяет прыгать выше).",
				["Description"] = "Описание",
				["DiscordWarning2"] = "Ошибка: Отправка отчетов в дискорд включена, только плагин DiscordMessages не загружен!",
				["DiscordWarningNR"] = "Ошибка: Отправка отчетов No Recoil в дискорд включена, только webhook дискорда для нарушения No Recoil не настроен!",
				["DiscordWarningAIM"] = "Ошибка: Отправка отчетов AIMBOT в дискорд включена, только webhook дискорда для нарушения AIMBOT не настроен!",
				["DiscordWarningIR"] = "Ошибка: Отправка отчетов In Rock в дискорд включена, только webhook дискорда для нарушения In Rock не настроен!",
                ["PlayerNRViolation"] = "<size=14><color=red><color=green>Arkan:</color> У игрока <color=yellow>{0}/{1}</color> обнаружено возможное нарушение No Recoil <color=yellow>#{2}</color>\nобщее количество выстрелов: <color=yellow>{3}</color> | количество выстрелов с низкой отдачей: <color=yellow>{4}</color>\nвероятность: <color=yellow>{5}%</color></color></size>",
				["PlayerNRViolationCon"] = "У игрока {0}/{1} обнаружено возможное нарушение No Recoil #{2}\nобщее количество выстрелов: {3} | количество выстрелов с низкой отдачей: {4}\nвероятность: {5}",
            }, this, "ru");			
        }

        #endregion Localization

        #region Initialization & Loading
		
        private void Init()
        {
            //LoadVariables();
			LoadConfig();
		
			Unsubscribe(nameof(OnPlayerAttack));
			Unsubscribe(nameof(OnMeleeThrown));
			Unsubscribe(nameof(OnProjectileRicochet));
			Unsubscribe(nameof(OnWeaponFired));
			Unsubscribe(nameof(OnEntityTakeDamage));
			Unsubscribe(nameof(OnItemPickup));
			
			if (_config.DiscordNRWebhookURL == "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks" && _config.DiscordNRReportEnabled)
            {
                PrintWarning(Lang("DiscordWarningNR", null));
                _config.DiscordNRReportEnabled = false;
            }			

			if (_config.DiscordAIMWebhookURL == "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks" && _config.DiscordAIMReportEnabled)
            {
                PrintWarning(Lang("DiscordWarningAIM", null));
                _config.DiscordAIMReportEnabled = false;
            }			

			if (_config.DiscordIRWebhookURL == "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks" && _config.DiscordIRReportEnabled)
            {
                PrintWarning(Lang("DiscordWarningIR", null));
                _config.DiscordIRReportEnabled = false;
            }						
        }

        private void OnServerInitialized()
        {
			if (_config.isDetectNR)
				Subscribe(nameof(OnWeaponFired));
			
			if (_config.isDetectAIM)
			{
				Subscribe(nameof(OnPlayerAttack));
				Subscribe(nameof(OnMeleeThrown));
				Subscribe(nameof(OnProjectileRicochet));
				Subscribe(nameof(OnWeaponFired));
				Subscribe(nameof(OnEntityTakeDamage));	
				Subscribe(nameof(OnItemPickup));				
			}
						
            DateTime currentDate = DateTime.Now.AddSeconds(-UnityEngine.Time.realtimeSinceStartup);
            serverTimeStamp = currentDate.Year + "." + currentDate.Month + "." + currentDate.Day + "." + currentDate.Hour + "." + currentDate.Minute;
            PlayersViolations.seed = ConVar.Server.seed;
            PlayersViolations.mapSize = ConVar.Server.worldsize;
            PlayersViolations.serverTimeStamp = serverTimeStamp;

            LoadViolationsData(null, null, null);
			
            Puts(Lang("InitPlgText1", null, PlayersViolations.seed, PlayersViolations.mapSize, PlayersViolations.serverTimeStamp));

            foreach (var _player in BasePlayer.activePlayerList.Where(x => x.IsAdmin && permission.UserHasPermission(x.UserIDString, permName)))
				AdminLogInit(_player);	

			if ((_config.DiscordNRReportEnabled || _config.DiscordAIMReportEnabled || _config.DiscordIRReportEnabled) && DiscordMessages == null)
				PrintWarning(Lang("DiscordWarning2", null));
        }

        void OnPlayerConnected(BasePlayer player)
        {
			if (player != null)
			{
				if (!player.IsAdmin && !permission.UserHasPermission(player.UserIDString, permName))
					return;
			
				AdminLogInit(player);
			}
        }

        #endregion Initialization & Loading

        #region Helpers
		
		private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
		
		public string RemoveFormatting(string source) => source.Contains(">") ? Regex.Replace(source, "<.*?>", string.Empty) : source;

        #endregion Helpers

        #region Oxide Hooks

        private void Unload()
        {
            if (PlayersViolations.lastChangeTime > PlayersViolations.lastSaveTime)
                SaveViolationsData(null, null, null);
			
			PlayersFiredProjectlesData.Clear();
			AdminsConfig.Clear();
			_config.weaponsConfig.Clear();
			_config.AIMBodyParts.Clear();
			_config.IRBodyParts.Clear();
			
			_config = null;
        }

        private void Loaded()
        {
			permission.RegisterPermission(permName, this);
			permission.RegisterPermission(permNRDrawViolation, this);
			permission.RegisterPermission(permAIMDrawViolation, this);
			permission.RegisterPermission(permIRDrawViolation, this);
			permission.RegisterPermission(permNRReportChat, this);
			permission.RegisterPermission(permNRReportConsole, this);
			permission.RegisterPermission(permAIMReportChat, this);
			permission.RegisterPermission(permAIMReportConsole, this);
			permission.RegisterPermission(permIRReportChat, this);
			permission.RegisterPermission(permIRReportConsole, this);
			permission.RegisterPermission(permNRWhitelist, this);
			permission.RegisterPermission(permNRBlacklist, this);
			permission.RegisterPermission(permAIMWhitelist, this);
			permission.RegisterPermission(permAIMBlacklist, this);
			permission.RegisterPermission(permIRWhitelist, this);
			permission.RegisterPermission(permIRBlacklist, this);

            LoadViolationsData(null, null, null);
        }

        private void OnServerSave()
        {
            if (_config.autoSave && PlayersViolations.lastChangeTime > PlayersViolations.lastSaveTime)
                SaveViolationsData(null, null, null);
        }

        private void OnPlayerAttack(BasePlayer attacker, HitInfo info)
        {
            if (attacker == null || info.Weapon == null)
                return;
				
			if (_config.checkBlacklist)
			{
				if (!(permission.UserHasPermission(attacker.UserIDString, permNRBlacklist) || permission.UserHasPermission(attacker.UserIDString, permAIMBlacklist)))
                    return;
			}
			else
				if (permission.UserHasPermission(attacker.UserIDString, permNRWhitelist) || permission.UserHasPermission(attacker.UserIDString, permAIMWhitelist))
                    return;

            if (PlayersFiredProjectlesData.ContainsKey(attacker.userID))
            {
                if (PlayersFiredProjectlesData[attacker.userID].firedProjectiles.ContainsKey(info.ProjectileID))
                {
                    PlayersFiredProjectlesData[attacker.userID].firedProjectiles[info.ProjectileID].hitsData.Add(new ProjectileRicochet());
                    ProjectileRicochet pr;
                    pr.projectileID = info.ProjectileID;
                    pr.hitPosition = info.HitPositionWorld;
                    pr.inVelocity = (info.PointEnd - info.PointStart) * PlayersFiredProjectlesData[attacker.userID].physicsSteps;
                    pr.outVelocity = info.ProjectileVelocity;
                    PlayersFiredProjectlesData[attacker.userID].firedProjectiles[info.ProjectileID].hitsData[PlayersFiredProjectlesData[attacker.userID].firedProjectiles[info.ProjectileID].hitsData.Count - 1] = pr;
                }
            }

            //for development purposes only
            if (isAttackShow)
            {
                BaseMelee component = info.Weapon.GetComponent<BaseMelee>();

                FiredProjectile fp;
				
                if (component == null)
                {
					foreach (var _player in BasePlayer.activePlayerList.Where(x => x.IsAdmin && permission.UserHasPermission(x.UserIDString, permName)))
                        foreach (KeyValuePair<ulong, PlayerFiredProjectlesData> list in PlayersFiredProjectlesData)
                            if (PlayersFiredProjectlesData[list.Key].firedProjectiles.TryGetValue(info.ProjectileID, out fp))
                                DrawProjectileTrajectory2(_player, _config.drawTime, fp, info, Color.blue, PlayersFiredProjectlesData[list.Key].physicsSteps);
                }
            }
        }

        private void OnMeleeThrown(BasePlayer player, Item item)
        {
            if (player == null || item == null)
                return;
			
			if (_config.checkBlacklist)
			{
				if (!(permission.UserHasPermission(player.UserIDString, permNRBlacklist) || permission.UserHasPermission(player.UserIDString, permAIMBlacklist)))
                    return;
			}
			else
				if (permission.UserHasPermission(player.UserIDString, permNRWhitelist) || permission.UserHasPermission(player.UserIDString, permAIMWhitelist))
                    return;

            ItemModProjectile component = item.info.GetComponent<ItemModProjectile>();

            if (component != null)
            {
                if (component.projectileObject != null)
                {
                    GameObject gameObject = component.projectileObject.Get();
                    if (gameObject != null)
                    {
                        Projectile component1 = gameObject.GetComponent<Projectile>();
                        if (component1 != null)
                        {
                            if (!PlayersFiredProjectlesData.ContainsKey(player.userID))
                            {
                                PlayersFiredProjectlesData.Add(player.userID, new PlayerFiredProjectlesData());
                                PlayersFiredProjectlesData[player.userID].PlayerID = player.userID;
                                PlayersFiredProjectlesData[player.userID].PlayerName = player.displayName;
                            }

                            MeleeThrown _melee = new MeleeThrown();

                            uint meleeID = item.uid;

							if (!PlayersFiredProjectlesData[player.userID].melees.ContainsKey(meleeID))
                                PlayersFiredProjectlesData[player.userID].melees.Add(meleeID, new MeleeThrown());
							else
							{
								Puts($"Error: OnMeleeThrown(), duplicate meleeID ({meleeID}), player ({player.displayName}/{player.userID})");
								return;
							}

                            _melee.firedTime = DateTime.Now;
                            _melee.projectileVelocity = component.projectileVelocity;
                            _melee.playerEyesLookAt = player.eyes.HeadForward();
                            _melee.playerEyesPosition = player.eyes.position;
							//	_melee.playerEyesPosition = player.eyes.position - player.eyes.HeadForward().normalized * (_config.playerEyesPositionToProjectileInitialPositionDistanceForgiveness * 2f); //uncomment this line to get AIMBOT false positives for testing purposes
                            _melee.drag = component1.drag;
                            _melee.gravityModifier = component1.gravityModifier;
                            _melee.position = player.eyes.position;
							_melee.meleeShortName = item.info.shortname;
                            _melee.meleeUID = item.uid;

                            if (player.GetParentEntity() != null)
                            {
                                _melee.isMounted = true;
                                BaseEntity parentEntity = player.GetParentEntity();
                                _melee.mountParentName = parentEntity._name;
                                _melee.mountParentPosition = parentEntity.ServerPosition;
								_melee.mountParentRotation.x = parentEntity.ServerRotation.x;
								_melee.mountParentRotation.y = parentEntity.ServerRotation.y;
								_melee.mountParentRotation.z = parentEntity.ServerRotation.z;
								_melee.mountParentRotation.w = parentEntity.ServerRotation.w;
                            }

                            PlayersFiredProjectlesData[player.userID].melees[meleeID] = _melee;

                            PlayersFiredProjectlesData[player.userID].lastFiredTime = UnityEngine.Time.realtimeSinceStartup;

                            timer.Once(9f, () => CleanupExpiredProjectiles(player));
                        }
                    }
                }
            }
        }
		
		private void OnItemPickup(Item item, BasePlayer player)
		{
			if (player == null || item == null)
                return;
			
			if (_config.checkBlacklist)
			{
				if (!(permission.UserHasPermission(player.UserIDString, permNRBlacklist) || permission.UserHasPermission(player.UserIDString, permAIMBlacklist)))
                    return;
			}
			else
				if (permission.UserHasPermission(player.UserIDString, permNRWhitelist) || permission.UserHasPermission(player.UserIDString, permAIMWhitelist))
                    return;
		
			if (PlayersFiredProjectlesData.ContainsKey(player.userID))
				if (PlayersFiredProjectlesData[player.userID].melees.ContainsKey(item.uid))
					PlayersFiredProjectlesData[player.userID].melees.Remove(item.uid);
		}

        private void OnProjectileRicochet(BasePlayer player, PlayerProjectileRicochet playerProjectileRicochet)
        {
            if (player == null || playerProjectileRicochet == null)
                return;
			
			if (_config.checkBlacklist)
			{
				if (!(permission.UserHasPermission(player.UserIDString, permNRBlacklist) || permission.UserHasPermission(player.UserIDString, permAIMBlacklist)))
                    return;
			}
			else
				if (permission.UserHasPermission(player.UserIDString, permNRWhitelist) || permission.UserHasPermission(player.UserIDString, permAIMWhitelist))
                    return;

            if (PlayersFiredProjectlesData.ContainsKey(player.userID))
            {
                if (PlayersFiredProjectlesData[player.userID].firedProjectiles.ContainsKey(playerProjectileRicochet.projectileID))
                {
                    PlayersFiredProjectlesData[player.userID].firedProjectiles[playerProjectileRicochet.projectileID].hitsData.Add(new ProjectileRicochet());
                    ProjectileRicochet pr;
                    pr.projectileID = playerProjectileRicochet.projectileID;
                    pr.hitPosition = playerProjectileRicochet.hitPosition;
                    pr.inVelocity = playerProjectileRicochet.inVelocity;
                    pr.outVelocity = playerProjectileRicochet.outVelocity;
                    PlayersFiredProjectlesData[player.userID].firedProjectiles[playerProjectileRicochet.projectileID].hitsData[PlayersFiredProjectlesData[player.userID].firedProjectiles[playerProjectileRicochet.projectileID].hitsData.Count - 1] = pr;
                }
            }
        }

        private void OnWeaponFired(BaseProjectile projectile, BasePlayer player, ItemModProjectile mod, ProjectileShoot projectileShoot)
        {
            if (player == null || projectile == null || mod == null || projectileShoot == null)
                return;
			
			if (_config.checkBlacklist)
			{
				if (!(permission.UserHasPermission(player.UserIDString, permNRBlacklist) || permission.UserHasPermission(player.UserIDString, permAIMBlacklist)))
                    return;
			}
			else
				if (permission.UserHasPermission(player.UserIDString, permNRWhitelist) || permission.UserHasPermission(player.UserIDString, permAIMWhitelist))
                    return;

            if (projectileShoot.projectiles[0] == null)
            {
                Puts(Lang("ErrorText1", player.UserIDString, player.displayName));
                return;
            }

            Item item = player.GetActiveItem();
			
			if (item == null)
                return;

            WeaponConfig _WeaponConfig;
		
            if (!_config.weaponsConfig.TryGetValue(item.info.shortname, out _WeaponConfig))
                return;

            if (!(_WeaponConfig.NRDetectEnabled || _WeaponConfig.AIMDetectEnabled))
                return;

            if (!PlayersFiredProjectlesData.ContainsKey(player.userID))
            {
                PlayersFiredProjectlesData.Add(player.userID, new PlayerFiredProjectlesData());
                PlayersFiredProjectlesData[player.userID].PlayerID = player.userID;
                PlayersFiredProjectlesData[player.userID].PlayerName = player.displayName;
            }

            float _velocity = mod.projectileVelocity;
            float NRProbabilityModifier = 1f;
            List<string> attachments = new List<string>();

            if (item.contents != null)
                foreach (Item attachment in item.contents.itemList)
                {
					if (attachment == null)
						return;
					
                    attachments.Add(attachment.info.shortname);
                    switch (attachment.info.shortname)
                    {
                        case "weapon.mod.muzzleboost":
                            _velocity -= (_velocity / 100f) * 10f;
                            break;
                        case "weapon.mod.muzzlebrake":
                            _velocity -= (_velocity / 100f) * 20f;
                            NRProbabilityModifier -= 0.1f;
                            break;
                        case "weapon.mod.silencer":
                            _velocity -= (_velocity / 100f) * 25f;
                            NRProbabilityModifier -= 0.05f;
                            break;
                    }
                }

            switch (item.info.shortname)
            {
                case "smg.2":
                    _velocity -= (_velocity / 100f) * 20f;
                    break;
                case "smg.mp5":
                    _velocity -= (_velocity / 100f) * 20f;
                    break;
                case "rifle.bolt":
                    _velocity += (_velocity / 100f) * 75f;
                    break;
                case "rifle.l96":
                    _velocity += (_velocity / 100f) * 200f;
                    break;
                case "rifle.m39":
                    _velocity += (_velocity / 100f) * 25f;
                    break;
                case "lmg.m249":
                    _velocity += (_velocity / 100f) * 30f;
                    break;
                case "crossbow":
                    _velocity += (_velocity / 100f) * 50f;
                    break;
                case "bow.compound":
                    Projectile.Modifier pm = projectile.GetProjectileModifier();
					//SendReply(player, $"bow.compound pm.distanceScale: {pm.distanceScale}, _velocity * pm.distanceScale: {_velocity * pm.distanceScale}, damageScale: {pm.damageScale}, damageOffset: {pm.damageOffset}, distanceOffset: {pm.distanceOffset}");
                    _velocity *= Mathf.Clamp(pm.distanceScale, 1f, 2f);
                    break;
            }

            if (player.modelState.aiming)
                NRProbabilityModifier -= 0.05f;

            if (player.IsDucked())
                NRProbabilityModifier -= 0.05f;

            FiredProjectile fp = new FiredProjectile();

            int projectileID = projectileShoot.projectiles[0].projectileID;

            if (!PlayersFiredProjectlesData[player.userID].firedProjectiles.ContainsKey(projectileID))
                PlayersFiredProjectlesData[player.userID].firedProjectiles.Add(projectileID, new FiredProjectile());
			else
			{
				Puts($"Error: OnWeaponFired(), duplicate projectileID ({projectileID}), player ({player.displayName}/{player.userID})");
				return;
			}	
			
			fp.firedTime = DateTime.Now;
            fp.projectileVelocity = projectileShoot.projectiles[0].startVel.normalized * _velocity;		
            fp.projectilePosition = projectileShoot.projectiles[0].startPos;
            fp.playerEyesLookAt = player.eyes.HeadForward();
            fp.playerEyesPosition = player.eyes.position;
            //	fp.playerEyesPosition = player.eyes.position - player.eyes.HeadForward().normalized * (_config.playerEyesPositionToProjectileInitialPositionDistanceForgiveness * 2f); //uncomment this line to get AIMBOT false positives for testing purposes
            fp.weaponShortName = item.info.shortname;
            fp.weaponUID = item.uid;
            fp.ammoShortName = projectile.primaryMagazine.ammoType.shortname;
            fp.NRProbabilityModifier = NRProbabilityModifier;
            fp.attachments = attachments;

            if (player.GetParentEntity() != null)
            {
                fp.isMounted = true;
                BaseEntity parentEntity = player.GetParentEntity();
                fp.mountParentName = parentEntity.ShortPrefabName;
                fp.mountParentPosition = parentEntity.ServerPosition;
				fp.mountParentRotation.x = parentEntity.ServerRotation.x;
				fp.mountParentRotation.y = parentEntity.ServerRotation.y;
				fp.mountParentRotation.z = parentEntity.ServerRotation.z;
				fp.mountParentRotation.w = parentEntity.ServerRotation.w;
            }
			else				
				if (player.isMounted)
				{
					BaseMountable parentMount = player.GetMounted(); 
					if (parentMount != null)
					{
						BaseEntity _parentEntity = parentMount.GetParentEntity();
						if (_parentEntity != null)
						{
							fp.isMounted = true;
                            fp.mountParentName = _parentEntity.ShortPrefabName;
                            fp.mountParentPosition = _parentEntity.ServerPosition;
							fp.mountParentRotation.x = _parentEntity.ServerRotation.x;
							fp.mountParentRotation.y = _parentEntity.ServerRotation.y;
							fp.mountParentRotation.z = _parentEntity.ServerRotation.z;
							fp.mountParentRotation.w = _parentEntity.ServerRotation.w;
						}
					}
				}
			
            PlayersFiredProjectlesData[player.userID].firedProjectiles[projectileID] = fp;

            PlayersFiredProjectlesData[player.userID].lastFiredTime = UnityEngine.Time.realtimeSinceStartup;
            PlayersFiredProjectlesData[player.userID].isChecked = false;

            if (_config.isDetectNR)
				if (_config.checkBlacklist)
				{
					if (permission.UserHasPermission(player.UserIDString, permNRBlacklist))
						timer.Once(_config.NRProcessTimer, () => ProcessShots(player));
				}
				else
					if (!permission.UserHasPermission(player.UserIDString, permNRWhitelist))
                        timer.Once(_config.NRProcessTimer, () => ProcessShots(player));

            timer.Once(9f, () => CleanupExpiredProjectiles(player));
        }

        private void OnEntityTakeDamage(BasePlayer entity, HitInfo info)
        {
            if (_config.isDetectAIM || _config.isDetectIR)
            {				
                if (entity == null) return;
				
                if (info == null) return;
				
                if (info.Initiator == null) return;
				
                if (!(info.Initiator is BasePlayer)) return;
				
                BasePlayer attacker = info.Initiator.ToPlayer();
				
                if (attacker == null) return;
				
                if (attacker is NPCPlayer) return;
				
                if (IsNPC(attacker)) return;

				if (_config.checkBlacklist)
				{
					if (!permission.UserHasPermission(attacker.UserIDString, permAIMBlacklist))
						return;
				}
				else
					if (permission.UserHasPermission(attacker.UserIDString, permAIMWhitelist))
                        return;

                if (!PlayersFiredProjectlesData.ContainsKey(attacker.userID))
                    return;

                if (info.HitBone == null) return;
				
                var _bodyPart = entity?.skeletonProperties?.FindBone(info.HitBone)?.name?.english ?? "";

                if (_bodyPart == null) return;
				
				bool isAIMBodyPart = _config.AIMBodyParts.Contains(_bodyPart);
				bool isIRBodyPart = _config.IRBodyParts.Contains(_bodyPart);
				
				if (isAIMBodyPart || isIRBodyPart)
                {
					if (info.HitEntity == null) return; 
					
                    BasePlayer target = info.HitEntity.ToPlayer();
					
                    if (target == null) return;
					
					if (!_config.isCheckAIMOnTargetNPC)
					{					
						if (target is NPCPlayer) return;
						if (IsNPC(target)) return;
					}
					
                    if (info.Weapon == null) return;

                    BaseMelee component = info.Weapon.GetComponent<BaseMelee>();
                    FiredProjectile fp = new FiredProjectile();
					bool isAttackerMount = false;
					bool isTargetMount = false;
					bool isMelee = false;
                    string attackerMountParentName = "";
					string targetMountParentName = "";

                    if (attacker.GetParentEntity() != null)
                    {
                        isAttackerMount = true;
                        BaseEntity attackerParentEntity = attacker.GetParentEntity();
                        attackerMountParentName = attackerParentEntity.ShortPrefabName;
                    }
					else				
						if (attacker.isMounted)
						{
							BaseMountable parentMount = attacker.GetMounted(); 
							if (parentMount != null)
							{
								BaseEntity _parentEntity = parentMount.GetParentEntity();
								if (_parentEntity != null)
								{
									isAttackerMount = true;
									attackerMountParentName = _parentEntity.ShortPrefabName;
								}
							}
						}

                    if (entity.GetParentEntity() != null)
                    {
                        isTargetMount = true;
                        BaseEntity targetParentEntity1 = entity.GetParentEntity();
                        targetMountParentName = targetParentEntity1.ShortPrefabName;
                    }
					else				
						if (entity.isMounted)
						{
							BaseMountable parentMount1 = entity.GetMounted(); 
							if (parentMount1 != null)
							{
								BaseEntity _parentEntity1 = parentMount1.GetParentEntity();
								if (_parentEntity1 != null)
								{
									isAttackerMount = true;
									attackerMountParentName = _parentEntity1.ShortPrefabName;
								}
							}
						}

					if (info.ProjectileID == 0)
					{
					//	Puts($"Error: info.ProjectileID = {info.ProjectileID} is zero. Attacker {attacker.UserIDString}/{attacker.userID} ");
					}
                    
					if (component != null)
                    {
						isMelee = true;

                        MeleeThrown _melee;

                        if (PlayersFiredProjectlesData[attacker.userID].melees.TryGetValue((info.Weapon.net.ID - 1), out _melee))
                        {
                            fp.firedTime = _melee.firedTime;
                            //	fp.projectileVelocity = Vector3.Normalize(_melee.playerEyesLookAt) * _melee.projectileVelocity;
                            fp.projectileVelocity = Vector3.Normalize(attacker.firedProjectiles[info.ProjectileID].initialVelocity) * _melee.projectileVelocity;
                            //	fp.projectilePosition = _melee.position;
                            fp.projectilePosition = attacker.firedProjectiles[info.ProjectileID].initialPosition;
                            fp.playerEyesPosition = _melee.playerEyesPosition;
                            fp.playerEyesLookAt = _melee.playerEyesLookAt;
                            fp.ammoShortName = _melee.meleeShortName;
                            fp.weaponShortName = _melee.meleeShortName;
                            fp.weaponUID = _melee.meleeUID;
                            fp.isMounted = _melee.isMounted;
                            fp.mountParentName = _melee.mountParentName;
                            fp.mountParentPosition = _melee.mountParentPosition;
                            fp.mountParentRotation = _melee.mountParentRotation;
                        }
                        else
						{
						//	Puts($"Error: Melee info.ProjectileID = {info.ProjectileID} not found. Attacker {attacker.UserIDString}/{attacker.userID} ");
                            return;
						}
                    }
                    else
                        if (!PlayersFiredProjectlesData[attacker.userID].firedProjectiles.TryGetValue(info.ProjectileID, out fp))
						{
						//	Puts($"Error: Projectile info.ProjectileID = {info.ProjectileID} not found. Attacker {attacker.UserIDString}/{attacker.userID} ");
							return;
						}
					
					if (_config.isDetectIR && isIRBodyPart)
						if (!isAttackerMount && fp.hitsData.Count <= 1)
							ShootingInRockCheck(attacker, fp, info, _bodyPart, PlayersFiredProjectlesData[attacker.userID].physicsSteps);	
						
					if (_config.isDetectAIM && isAIMBodyPart && info.Initiator.Distance(entity.transform.position) > _config.minDistanceAIMCheck)
					{
						if (fp.hitsData.Count > 1) return; // Temporary fix for 5th March update
						
						AIMViolationData aimvd = new AIMViolationData();
						bool AIMViolation = false;
						List<TrajectorySegment> trajectorySegments = new List<TrajectorySegment>();
						List<TrajectorySegment> trajectorySegmentsRev = new List<TrajectorySegment>();
						
						if (isMelee)
							aimvd.forgivenessModifier = 1.5f;

                        if (attacker.HasFiredProjectile(info.ProjectileID))
                        {
                            aimvd.firedProjectileFiredTime = attacker.firedProjectiles[info.ProjectileID].firedTime;
                            aimvd.firedProjectileTravelTime = attacker.firedProjectiles[info.ProjectileID].travelTime;
                            aimvd.firedProjectilePosition = attacker.firedProjectiles[info.ProjectileID].position;
                            aimvd.firedProjectileVelocity = attacker.firedProjectiles[info.ProjectileID].velocity;
                            aimvd.firedProjectileInitialPosition = attacker.firedProjectiles[info.ProjectileID].initialPosition;
                            aimvd.firedProjectileInitialVelocity = attacker.firedProjectiles[info.ProjectileID].initialVelocity;
                            aimvd.hasFiredProjectile = true;
                
                            if (fp.weaponShortName == "bow.compound")
                                if (attacker.firedProjectiles[info.ProjectileID].initialVelocity.magnitude - fp.projectileVelocity.magnitude < (attacker.firedProjectiles[info.ProjectileID].initialVelocity.magnitude / 100f) * 10f)
                                    fp.projectileVelocity = attacker.firedProjectiles[info.ProjectileID].initialVelocity;
                
                            if (!(attacker.firedProjectiles[info.ProjectileID].initialPosition == fp.projectilePosition) && !(attacker.firedProjectiles[info.ProjectileID].initialVelocity == fp.projectileVelocity))
                            {
                                aimvd.isEqualFiredProjectileData = false;
                                AIMViolation = true;
                            }
                        }
                        else
                        {
                            Puts(Lang("ErrorText2", null, attacker.displayName, target.displayName, info.ProjectileID));
                            return;
                        }
                
                        if (fp.hitsData.Count > 0 && fp.hitsData[fp.hitsData.Count - 1].hitPosition == info.HitPositionWorld)
                            fp.hitsData.RemoveAt(fp.hitsData.Count - 1);
                
                        HitData hitData = new HitData();
                        hitData.startProjectilePosition = fp.projectilePosition;
                        hitData.startProjectileVelocity = fp.projectileVelocity;
                        hitData.hitPositionWorld = info.HitPositionWorld;
                        hitData.hitPointStart = info.PointStart;
                        hitData.hitPointEnd = info.PointEnd;
                
                        aimvd.hitsData.Add(hitData);
                
                        if (fp.hitsData.Count > 0)
                            for (int i = 0; i < fp.hitsData.Count; i++)
                            {
                                hitData = new HitData();
                                hitData.hitData = fp.hitsData[i];
                
                                hitData.startProjectilePosition = fp.hitsData[i].hitPosition;
                                hitData.startProjectileVelocity = fp.hitsData[i].outVelocity;
                                hitData.hitPositionWorld = info.HitPositionWorld;
                                hitData.hitPointStart = info.PointStart;
                                hitData.hitPointEnd = info.PointEnd;
                                aimvd.hitsData.Add(hitData);
                                aimvd.hitsData[i].hitPositionWorld = fp.hitsData[i].hitPosition;
                                aimvd.hitsData[i].hitPointStart = fp.hitsData[i].hitPosition - (fp.hitsData[i].inVelocity / PlayersFiredProjectlesData[attacker.userID].physicsSteps);
                                aimvd.hitsData[i].hitPointEnd = fp.hitsData[i].hitPosition;
                            }
							
						if (fp.ammoShortName.Contains("arrow."))
							aimvd.forgivenessModifier = 1.5f;
						
						aimvd.physicsSteps = PlayersFiredProjectlesData[attacker.userID].physicsSteps;
						
                        AIMViolation = ProcessProjectileTrajectory(out aimvd, aimvd, out trajectorySegments, out trajectorySegmentsRev, info.ProjectilePrefab.gravityModifier, info.ProjectilePrefab.drag);
						
						if (AIMViolation && aimvd.hitsData.Count == 1 && trajectorySegments.Count > 0 && trajectorySegmentsRev.Count > 0)
						{
							float lengthLastSegmentProjectileTrajectory = Vector3.Distance(aimvd.hitsData[0].lastSegmentPointEnd, aimvd.hitsData[0].lastSegmentPointStart);
							float lengthLastSegmentReverseProjectileTrajectory = Vector3.Distance(aimvd.hitsData[0].hitPointEnd, aimvd.hitsData[0].hitPointStart);
							
							Vector3 pointStartProjectedOnLastSegment = ProjectPointOnLine(aimvd.hitsData[0].lastSegmentPointStart, (aimvd.hitsData[0].lastSegmentPointEnd - aimvd.hitsData[0].lastSegmentPointStart).normalized, aimvd.hitsData[0].hitPointStart);
							Vector3 pointEndProjectedOnLastSegment = ProjectPointOnLine(aimvd.hitsData[0].lastSegmentPointStart, (aimvd.hitsData[0].lastSegmentPointEnd - aimvd.hitsData[0].lastSegmentPointStart).normalized, aimvd.hitsData[0].hitPointEnd);
                
							if (Mathf.Abs(Vector3.Distance(pointStartProjectedOnLastSegment, aimvd.hitsData[0].hitPointStart) - Vector3.Distance(pointEndProjectedOnLastSegment, aimvd.hitsData[0].hitPointEnd)) > 0.05f)
							{
								HitData hitData1 = new HitData();
								HitData hitData2 = new HitData();
								if (IsRicochet(trajectorySegments, trajectorySegmentsRev, out hitData1, out hitData2, aimvd.physicsSteps))
								{
									hitData1.startProjectilePosition = aimvd.hitsData[0].startProjectilePosition;
									hitData1.startProjectileVelocity = aimvd.hitsData[0].startProjectileVelocity;
                        
									hitData2.hitPositionWorld = info.HitPositionWorld;
									hitData2.hitPointStart = info.PointStart;
									hitData2.hitPointEnd = info.PointEnd;	
														
									aimvd.hitsData.Clear();
							
									aimvd.hitsData.Add(hitData1);
									aimvd.hitsData.Add(hitData2);
                      
									AIMViolation = ProcessProjectileTrajectory(out aimvd, aimvd, out trajectorySegments, out trajectorySegmentsRev, info.ProjectilePrefab.gravityModifier, info.ProjectilePrefab.drag);
								}							
							}
						}
						
						if (!AIMViolation && Mathf.Abs(PlayersFiredProjectlesData[attacker.userID].physicsSteps - aimvd.physicsSteps) > PlayersFiredProjectlesData[attacker.userID].physicsSteps * 0.063f)
						{
							if (_config.notifyPhysicsStepsWarning)
							{
								if (aimvd.physicsSteps > _config.minPhysicsStepsAllowed)
								{
									if (_config.DiscordAIMReportEnabled)
										if (DiscordMessages == null)
											PrintWarning(Lang("DiscordWarning2", null));
										else
										{
											List<EmbedFieldList> fields = new List<EmbedFieldList>();
											
											string dmAttacker = $"[{attacker.displayName}\n{attacker.UserIDString}](https://steamcommunity.com/profiles/{attacker.UserIDString})";
											if (dmAttacker.Length == 0) dmAttacker = stringNullValueWarning;
											fields.Add(new EmbedFieldList()
											{
												name = Lang("PlayerTxt", null),
												inline = true,
												value = dmAttacker
											});
											
											string dmPhysicsSteps = $"{aimvd.physicsSteps}({Mathf.Round(aimvd.physicsSteps)})";
											if (dmPhysicsSteps.Length == 0) dmPhysicsSteps = stringNullValueWarning;
											fields.Add(new EmbedFieldList()
											{
												name = "physics.steps",
												inline = true,
												value = dmPhysicsSteps
											});	
                        
											string dmDescription = Lang("PhysicsStepsChangeWarning", null, attacker.displayName + "/" + attacker.UserIDString, aimvd.physicsSteps, Mathf.Round(aimvd.physicsSteps));
											if (dmDescription.Length == 0) dmDescription = stringNullValueWarning;
											fields.Add(new EmbedFieldList()
											{
												name = Lang("Description", null),
												inline = false,
												value = dmDescription
											});	
                        
											var fieldsObject = fields.Cast<object>().ToArray();
											
											string json = JsonConvert.SerializeObject(fieldsObject);

											DiscordMessages?.Call("API_SendFancyMessage", _config.DiscordAIMWebhookURL, "Arkan: " + Lang("HighPhysicsStepsDetection", null), 39423, json);
										}
										
									foreach (var _player in BasePlayer.activePlayerList.Where(x => permission.UserHasPermission(x.UserIDString, permName) && x.IsAdmin))
									{	
										if (permission.UserHasPermission(_player.UserIDString, permAIMReportChat))
											SendReply(_player, "<color=green>Arkan: </color>" + "<color=red>" + Lang("HighPhysicsStepsDetection", _player.UserIDString) + "\n" + Lang("PhysicsStepsChangeWarning", null, "<color=yellow>" + attacker.displayName + "/" + attacker.UserIDString + "</color>", $"<color=yellow>{aimvd.physicsSteps}</color>", $"<color=yellow>{Mathf.Round(aimvd.physicsSteps)}</color>") + "</color>");
										
										if (permission.UserHasPermission(_player.UserIDString, permAIMReportConsole))
											_player.ConsoleMessage("<color=green>Arkan: </color>" + "<color=red>" + Lang("HighPhysicsStepsDetection", _player.UserIDString) + "</color>\n" + Lang("PhysicsStepsChangeWarning", null, attacker.displayName + "/" + attacker.UserIDString, aimvd.physicsSteps, Mathf.Round(aimvd.physicsSteps)));
									}
								
									Puts(Lang("PhysicsStepsChangeWarning", null, attacker.displayName + "/" + attacker.UserIDString, aimvd.physicsSteps, Mathf.Round(aimvd.physicsSteps)));
								}
							}													
							PlayersFiredProjectlesData[attacker.userID].physicsSteps = aimvd.physicsSteps;
						}
						
                        if (Vector3.Distance(fp.playerEyesPosition, fp.projectilePosition) > _config.playerEyesPositionToProjectileInitialPositionDistanceForgiveness)// && !fp.isMounted)
                        {
                            AIMViolation = true;
                            aimvd.isPlayerPositionToProjectileStartPositionDistanceViolation = true;
                            aimvd.distanceDifferenceViolation = Vector3.Distance(fp.playerEyesPosition, fp.projectilePosition);
                        }
                
                        if (AIMViolation)
                        {
                            aimvd.projectileID = info.ProjectileID;
							aimvd.firedTime = fp.firedTime;
                            aimvd.startProjectilePosition = fp.projectilePosition;
                            aimvd.startProjectileVelocity = fp.projectileVelocity;
                            aimvd.weaponShortName = fp.weaponShortName;
                            aimvd.ammoShortName = fp.ammoShortName;
                            aimvd.hitInfoInitiatorPlayerName = info.Initiator.ToPlayer().displayName;
                            aimvd.hitInfoInitiatorPlayerUserID = info.Initiator.ToPlayer().userID.ToString();
                            aimvd.hitInfoHitEntityPlayerName = info.HitEntity.ToPlayer().displayName;
                            aimvd.hitInfoHitEntityPlayerUserID = info.HitEntity.ToPlayer().userID.ToString();
                            aimvd.hitInfoBoneName = info.boneName;
                            aimvd.hitInfoHitPositionWorld = info.HitPositionWorld;
                            aimvd.hitInfoProjectileDistance = info.ProjectileDistance;
                            aimvd.hitInfoPointStart = info.PointStart;
                            aimvd.hitInfoPointEnd = info.PointEnd;
                            aimvd.hitInfoProjectilePrefabGravityModifier = info.ProjectilePrefab.gravityModifier;
                            aimvd.hitInfoProjectilePrefabDrag = info.ProjectilePrefab.drag;
                            aimvd.isAttackerMount = isAttackerMount;
                            aimvd.isTargetMount = isTargetMount;
                            aimvd.attackerMountParentName = attackerMountParentName;
                            aimvd.targetMountParentName = targetMountParentName;
                            aimvd.bodyPart = _bodyPart;
                            aimvd.damage = info.damageTypes.Total();
                            aimvd.gravityModifier = info.ProjectilePrefab.gravityModifier;
                            aimvd.drag = info.ProjectilePrefab.drag;
                            aimvd.playerEyesLookAt = fp.playerEyesLookAt;
                            aimvd.playerEyesPosition = fp.playerEyesPosition;
							aimvd.attachments = fp.attachments;
							
                            if (PlayersViolations.Players.ContainsKey(attacker.userID))
                                aimvd.violationID = PlayersViolations.Players[attacker.userID].AIMViolations.Count + 1;
                            else
                                aimvd.violationID = 1;
                
                            AddAIMViolationToPlayer(attacker, aimvd);
							
							int AIMViolationsCnt = PlayersViolations.Players[attacker.userID].AIMViolations.Count;
				
							if (Interface.CallHook("API_ArkanOnAimbotViolation", attacker, AIMViolationsCnt, JsonConvert.SerializeObject(aimvd)) != null)
							{
								return;
							}
                
							foreach (var _player in BasePlayer.activePlayerList.Where(x => permission.UserHasPermission(x.UserIDString, permName) && x.IsAdmin))
							{	
								if (permission.UserHasPermission(_player.UserIDString, permAIMReportChat))
									SendReply(_player, Lang("PlayerAIMViolation", _player.UserIDString, attacker.displayName, attacker.userID, PlayersViolations.Players[attacker.userID].AIMViolations.Count, target.displayName, target.userID));
								
								if (permission.UserHasPermission(_player.UserIDString, permAIMReportConsole))
									_player.ConsoleMessage("<color=green>Arkan:</color> " + Lang("PlayerAIMViolationCon", _player.UserIDString, attacker.displayName, attacker.userID, PlayersViolations.Players[attacker.userID].AIMViolations.Count, target.displayName, target.userID));
							}
							
                            if (_config.debugMessages)
                            {
                                string txt = Lang("AIMText1", null);
								string txt1 = "";
								string logTxt = "";
								Dictionary<int, string> logList = new Dictionary<int, string>();
                
                                txt += Lang("Attacker", null) + ": " + (aimvd.hitInfoInitiatorPlayerName ?? aimvd.hitInfoInitiatorPlayerUserID) + "\n" + Lang("AIMViolationNum", null) + PlayersViolations.Players[attacker.userID].AIMViolations.Count + "\n" + Lang("Weapon", null) + ": " + aimvd.weaponShortName + "\n" + Lang("Ammo", null) + ": " + aimvd.ammoShortName + "\n" + Lang("Distance", null) + ": " + aimvd.hitInfoProjectileDistance + "\n";
                                txt += Lang("Target", null) + ": " + (aimvd.hitInfoHitEntityPlayerName ?? aimvd.hitInfoHitEntityPlayerUserID) + "\n" + Lang("HitPart", null) + ": " + aimvd.hitInfoBoneName + "\n";
								txt += Lang("DateTime", null) + ": " + aimvd.firedTime + "\n\n";
								
								if (aimvd.isAttackerMount && aimvd.attackerMountParentName != null)
									txt += Lang("MountedOn", null, aimvd.attackerMountParentName) + "\n\n";
								
								txt += Lang("AttachmentsCount", null) + " = " + aimvd.attachments.Count + "\n";
                
								if (aimvd.attachments.Count > 0)
									for (int ii = 0; ii < aimvd.attachments.Count; ii++)
										txt += Lang("Attachment", null) + " - " + aimvd.attachments[ii] + "\n";
									
                                txt += Lang("RicochetsCount", null) + " = " + (aimvd.hitsData.Count - 1) + "\n";
                                txt += $"isEqualFiredProjectileData = {aimvd.isEqualFiredProjectileData}\n";
                                txt += $"isPlayerPositionToProjectileStartPositionDistanceViolation = {aimvd.isPlayerPositionToProjectileStartPositionDistanceViolation}\n";
								
								logTxt = $"isEqualFiredProjectileData = {aimvd.isEqualFiredProjectileData}\nisPlayerPositionToProjectileStartPositionDistanceViolation = {aimvd.isPlayerPositionToProjectileStartPositionDistanceViolation}\n";
                                
								if (aimvd.isPlayerPositionToProjectileStartPositionDistanceViolation)
								{
                                    txt += Lang("LogText6", null, aimvd.distanceDifferenceViolation);
									logTxt += Lang("LogText6", null, aimvd.distanceDifferenceViolation);
								}
                
                                for (int j = 0; j < aimvd.hitsData.Count; j++)
                                {
                                    txt += $"-\n" + Lang("LogText7", null, j + 1) + "\n";
                                    txt1 = $"isHitPointNearProjectileTrajectoryLastSegmentEndPoint = {aimvd.hitsData[j].isHitPointNearProjectileTrajectoryLastSegmentEndPoint}\n";
                                    
									if (!aimvd.hitsData[j].isHitPointNearProjectileTrajectoryLastSegmentEndPoint && aimvd.hitsData[j].side > 0)
                                        if (aimvd.hitsData[j].side == 1)
                                            txt1 += "     " + Lang("AIMText4", null, aimvd.hitsData[j].distanceFromHitPointToProjectilePlane, Lang("AIMText2", null), "StartPoint", Vector3.Distance(aimvd.hitsData[j].hitPositionWorld, aimvd.hitsData[j].hitPointStart)) + "\n";
                                        else
                                            txt1 += "     " + Lang("AIMText4", null, aimvd.hitsData[j].distanceFromHitPointToProjectilePlane, Lang("AIMText3", null), "EndPoint", Vector3.Distance(aimvd.hitsData[j].hitPositionWorld, aimvd.hitsData[j].hitPointEnd)) + "\n";
                                    
									txt1 += $"isHitPointOnProjectileTrajectory = {aimvd.hitsData[j].isHitPointOnProjectileTrajectory}\n";
                
                                    txt1 += $"isProjectileStartPointAtEndReverseProjectileTrajectory = {aimvd.hitsData[j].isProjectileStartPointAtEndReverseProjectileTrajectory}\n";
                                    
									if (!aimvd.hitsData[j].isProjectileStartPointAtEndReverseProjectileTrajectory)
                                        txt1 += "     " + Lang("AIMText6", null, aimvd.hitsData[j].lastSegmentPointStart, aimvd.hitsData[j].lastSegmentPointEnd, aimvd.hitsData[j].startProjectilePosition, aimvd.hitsData[j].startProjectilePosition + aimvd.hitsData[j].startProjectileVelocity);
                
                                    txt1 += $"isHitPointNearProjectilePlane = {aimvd.hitsData[j].isHitPointNearProjectilePlane}\n";
                                    
									if (!aimvd.hitsData[j].isHitPointNearProjectilePlane)
                                        txt1 += "     " + Lang("AIMText7", null, aimvd.hitsData[j].distanceFromHitPointToProjectilePlane);
                
                                    txt1 += $"isLastSegmentOnProjectileTrajectoryPlane = {aimvd.hitsData[j].isLastSegmentOnProjectileTrajectoryPlane}\n";
                                    
									if (!aimvd.hitsData[j].isLastSegmentOnProjectileTrajectoryPlane)
                                        txt1 += "     " + Lang("AIMText8", null, aimvd.hitsData[j].lastSegmentPointStart, aimvd.hitsData[j].startProjectilePosition, aimvd.hitsData[j].startProjectilePosition + aimvd.hitsData[j].startProjectileVelocity);
                
                                    txt += txt1 + Lang("LogText8", null, j + 1) + "\n";
									
									logList.Add(logList.Count, txt1);
                                }
                
                                Puts(txt);
								
								if (_config.DiscordAIMReportEnabled)
									if (DiscordMessages == null)
										PrintWarning(Lang("DiscordWarning2", null));
									else
									{
										List<EmbedFieldList> fields = new List<EmbedFieldList>();
										
										string dmAttacker = $"[{attacker.displayName}\n{attacker.UserIDString}](https://steamcommunity.com/profiles/{attacker.UserIDString})";
										if (dmAttacker.Length == 0) dmAttacker = stringNullValueWarning;
										fields.Add(new EmbedFieldList()
										{
											name = Lang("Attacker", null),
											inline = true,
											value = dmAttacker
										});
										
										string dmAIMViolationNum = $"{PlayersViolations.Players[attacker.userID].AIMViolations.Count}";
										if (dmAIMViolationNum.Length == 0) dmAIMViolationNum = stringNullValueWarning;
										fields.Add(new EmbedFieldList()
										{
											name = Lang("AIMViolationNum", null),
											inline = true,
											value = dmAIMViolationNum
										});	
										
										string dmDateTime = $"{aimvd.firedTime}";
										if (dmDateTime.Length == 0) dmDateTime = stringNullValueWarning;
										fields.Add(new EmbedFieldList()
										{
											name = Lang("DateTime", null),
											inline = true,
											value = dmDateTime
										});	
                
										string dmWeapon = $"{aimvd.weaponShortName}";
										if (dmWeapon.Length == 0) dmWeapon = stringNullValueWarning;
										fields.Add(new EmbedFieldList()
										{
											name = Lang("Weapon", null),
											inline = true,
											value = dmWeapon
										});	
                
										string dmAmmo = $"{aimvd.ammoShortName}";
										if (dmAmmo.Length == 0) dmAmmo = stringNullValueWarning;
										fields.Add(new EmbedFieldList()
										{
											name = Lang("Ammo", null),
											inline = true,
											value = dmAmmo
										});
										
										if (aimvd.attachments.Count == 0)
										{
											fields.Add(new EmbedFieldList()
											{
												name = Lang("AttachmentsCount", null) + " = " + aimvd.attachments.Count,
												inline = true,
												value = Lang("NoAttachments", null)
											});
										}
										else
										{
											string dmAttachmentsList = "";
											for (int j = 0; j < aimvd.attachments.Count; j++)
												dmAttachmentsList += aimvd.attachments[j] + "\n";
											
											if (dmAttachmentsList.Length == 0) dmAttachmentsList = stringNullValueWarning;
											fields.Add(new EmbedFieldList()
											{
												name = Lang("AttachmentsCount", null) + " = " + aimvd.attachments.Count,
												inline = true,
												value = dmAttachmentsList
											});
										}
										
										string targetVal = "";
										if (IsNPC(target))
											targetVal = aimvd.hitInfoHitEntityPlayerName ?? aimvd.hitInfoHitEntityPlayerUserID;
										else
											targetVal = $"[{target.displayName}](https://steamcommunity.com/profiles/{target.UserIDString})";										
                
										if (targetVal.Length == 0) targetVal = stringNullValueWarning;
										fields.Add(new EmbedFieldList()
										{
											name = Lang("Target", null),
											inline = true,
											value = targetVal
										});	
                
										string dmHitPart = $"{aimvd.hitInfoBoneName}";
										if (dmHitPart.Length == 0) dmHitPart = stringNullValueWarning;
										fields.Add(new EmbedFieldList()
										{
											name = Lang("HitPart", null),
											inline = true,
											value = dmHitPart
										});											
                
										string dmDistance = $"{aimvd.hitInfoProjectileDistance}";
										if (dmDistance.Length == 0) dmDistance = stringNullValueWarning;
										fields.Add(new EmbedFieldList()
										{
											name = Lang("Distance", null),
											inline = true,
											value = dmDistance
										});	
										
										string dmRicochetsCount = $"{aimvd.hitsData.Count - 1}";
										if (dmRicochetsCount.Length == 0) dmRicochetsCount = stringNullValueWarning;
										fields.Add(new EmbedFieldList()
										{
											name = Lang("RicochetsCount", null),
											inline = false,
											value = dmRicochetsCount
										});	
										
										if (logTxt.Length == 0) logTxt = stringNullValueWarning;
										fields.Add(new EmbedFieldList()
										{
											name = Lang("VDataLog", null),
											inline = false,
											value = logTxt
										});		
										
										string dmLogData = "";
										for (int k = 0; k < logList.Count; k++)
										{
											dmLogData = logList[k];
											if (dmLogData.Length == 0) dmLogData = stringNullValueWarning;
											fields.Add(new EmbedFieldList()
											{
												name = Lang("LogText7", null, k + 1),
												inline = false,
												value = dmLogData
											});				
											
											fields.Add(new EmbedFieldList()
											{
												name = Lang("LogText8", null, k + 1),
												inline = false,
												value = "-"
											});			
										}
								
										var fieldsObject = fields.Cast<object>().ToArray();
										
										string json = JsonConvert.SerializeObject(fieldsObject);

										DiscordMessages?.Call("API_SendFancyMessage", _config.DiscordAIMWebhookURL, "Arkan: " + Lang("AIMDetection", null), 39423, json);
									}
                
                                foreach (var _player in BasePlayer.activePlayerList.Where(x => x.IsAdmin && permission.UserHasPermission(x.UserIDString, permName) && permission.UserHasPermission(x.UserIDString, permAIMDrawViolation)))
                                {
                                    DrawProjectileTrajectory(_player, _config.drawTime, aimvd, Color.blue);
                                    DrawReverseProjectileTrajectory(_player, _config.drawTime, aimvd, Color.green);
                
                                    if (aimvd.isPlayerPositionToProjectileStartPositionDistanceViolation)
                                    {
                                        DDrawSphereToAdmin(_player, _config.drawTime, Color.red, aimvd.playerEyesPosition, 0.05f);
                                        DDrawTextToAdmin(_player, _config.drawTime, Color.cyan, aimvd.playerEyesPosition + Vector3.up, Lang("DrawAIMVD5", null, aimvd.hitInfoInitiatorPlayerName ?? aimvd.hitInfoInitiatorPlayerUserID, aimvd.violationID, aimvd.playerEyesPosition, aimvd.startProjectilePosition, Vector3.Distance(aimvd.playerEyesPosition, aimvd.startProjectilePosition)));
										DDrawArrowToAdmin(_player, _config.drawTime, Color.red, aimvd.playerEyesPosition, aimvd.playerEyesPosition + aimvd.playerEyesLookAt.normalized, 0.05f);
									}
                                }
                            }
                        }
					}
                }               
            }
        }
		
        #endregion Hooks

        #region Config
		
		protected override void LoadConfig()
		{
		    base.LoadConfig();
		    try
		    {
		        _config = Config.ReadObject<Configuration>();
		        if (_config == null) throw new Exception();
		        SaveConfig();
            }
		    catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
				LoadDefaultConfig();
            }
		}
        
		protected override void SaveConfig() => Config.WriteObject(_config);

		protected override void LoadDefaultConfig() => _config = new Configuration();	
		
        #endregion Config

        #region Commands

		[ConsoleCommand("arkan")]
		private void ConsoleShowLog(ConsoleSystem.Arg arg)
        {			
			var player = arg.Player();

			if (player == null)
			{
                if (PlayersViolations.Players.Count > 0)
                {
					string txtConsole = RemoveFormatting(Lang("ShowLog2", null));
					
                    foreach (KeyValuePair<ulong, PlayerViolationsData> list in PlayersViolations.Players)
					{
						txtConsole += $"{PlayersViolations.Players[list.Key].PlayerName} -";
						
						if (PlayersViolations.Players[list.Key].noRecoilViolations.Count > 0)
							txtConsole += $" NR({PlayersViolations.Players[list.Key].noRecoilViolations.Count})";
						
						if (PlayersViolations.Players[list.Key].AIMViolations.Count > 0)
							txtConsole += $" AIM({PlayersViolations.Players[list.Key].AIMViolations.Count})";
						
						if (PlayersViolations.Players[list.Key].inRockViolations.Count > 0)
							txtConsole += $" IR({PlayersViolations.Players[list.Key].inRockViolations.Count})";

						txtConsole += "; ";
					}
					
					Puts(txtConsole);
                }
                else
					Puts(RemoveFormatting(Lang("ShowLog3")));
			}
		}
		
		[ConsoleCommand("arkan.nr")]
		private void ConsoleShowNoRecoilLog(ConsoleSystem.Arg arg)
        {			
			var player = arg.Player();
			string txtConsole = "";

			if (player == null)
			{
				if (!arg.HasArgs())
				{
					txtConsole = RemoveFormatting(Lang("ShowNRLog2", null));
                    int nrCnt = 0;
					
					if (PlayersViolations.Players.Count > 0)
					{
						foreach (KeyValuePair<ulong, PlayerViolationsData> list in PlayersViolations.Players.Where(x => (PlayersViolations.Players[x.Key].noRecoilViolations.Count > 0)))
						{
							txtConsole += $"{PlayersViolations.Players[list.Key].PlayerName} - NR({PlayersViolations.Players[list.Key].noRecoilViolations.Count}); ";   
							
							nrCnt++;
						}

						Puts(txtConsole);
					}	
					
					if (nrCnt == 0)
                        Puts(RemoveFormatting(Lang("ShowNRLog3", null)));

					return;
				}
				
                string s = null;
				txtConsole = "";
                ulong id = 0;
				ulong playerID = 0;
        
                if (arg.Args.Length == 2)
                    if (arg.Args[1] == "0")
                    {
						txtConsole += Lang("ShowD1", null) + "\n";
						RconLog = new AdminConfig();
                    }
                    else
                        s = arg.Args[1];
        
                string user = arg.Args[0];
        
                if (user.Contains("765"))
                    ulong.TryParse(arg.Args[0], out id);
        
                foreach (KeyValuePair<ulong, PlayerViolationsData> list in PlayersViolations.Players)
                    if (PlayersViolations.Players[list.Key].PlayerID == id || PlayersViolations.Players[list.Key].PlayerName.Contains(user, CompareOptions.IgnoreCase))
                        playerID = PlayersViolations.Players[list.Key].PlayerID;
        
                if (playerID == 0)
					txtConsole += Lang("ShowD2", null) + "\n";
                else
                {
                    if (PlayersViolations.Players[playerID].noRecoilViolations.Count == 0)
						txtConsole += Lang("ShowNRD1", null, PlayersViolations.Players[playerID].PlayerName) + "\n";
                    else
                    {
						if ((long)RconLog.violationsLog.steamID != (long)PlayersViolations.Players[playerID].PlayerID)
                        {
							RconLog.violationsLog.NoRecoilViolation = 1;
							RconLog.violationsLog.steamID = PlayersViolations.Players[playerID].PlayerID;
                        }
                        else
                            if (s == null)
								if (PlayersViolations.Players[playerID].noRecoilViolations.Count >= RconLog.violationsLog.NoRecoilViolation + 1)
									RconLog.violationsLog.NoRecoilViolation++;
                                else
                                {
									txtConsole += Lang("NoMoreViolations", null, PlayersViolations.Players[playerID].PlayerName) + "\n";
									RconLog.violationsLog = new ViolationsLog();
									Puts(txtConsole);
                                    return;
                                }
        
                        int result;
                        int.TryParse(s, out result);
        
                        if (result == 0)
                            result = RconLog.violationsLog.NoRecoilViolation;
        
                        int i = 1;
                        foreach (KeyValuePair<string, NoRecoilViolationData> list in PlayersViolations.Players[playerID].noRecoilViolations)
                        {
                            if (i == result)
                            {
                                NoRecoilViolationData violationData = PlayersViolations.Players[playerID].noRecoilViolations[list.Key];

								txtConsole += "\n" + Lang("PlayerTxt", null) + " " + PlayersViolations.Players[playerID].PlayerName + "\n" + Lang("NRViolationNum", null) + result + "\n" + Lang("ShotsCount", null) + " " + violationData.ShotsCnt + "\n" + Lang("Probability", null) + " " + violationData.violationProbability + "%\n";
								if (violationData.suspiciousNoRecoilShots.ContainsKey(1))
									txtConsole += Lang("DateTime", null) + ": " + violationData.suspiciousNoRecoilShots[1].timeStamp + "\n\n";
								txtConsole += Lang("AttachmentsCount", null) + " = " + violationData.attachments.Count + "\n";
        
                                if (violationData.attachments.Count > 0)
                                    for (int ii = 0; ii < violationData.attachments.Count; ii++)
										txtConsole += Lang("Attachment", null) + " - " + violationData.attachments[ii] + "\n";

								txtConsole += Lang("Weapon", null) + " - " + violationData.weaponShortName + "\n";
								txtConsole += Lang("Ammo", null) + " - " + violationData.ammoShortName + "\n";
								txtConsole += Lang("Probability", null) + " - " + violationData.violationProbability + "%\n";
        
                                int j = 1;
								
                                foreach (KeyValuePair<int, SuspiciousProjectileData> suspiciusProjectile in violationData.suspiciousNoRecoilShots.ToArray())
                                {
                                    SuspiciousProjectileData sp = violationData.suspiciousNoRecoilShots[suspiciusProjectile.Key];
                                    if (sp.isNoRecoil)
                                    {
                                        if (sp.isShootedInMotion)
											txtConsole += Lang("ProjectileID", null, sp.projectile2ID) + " | " + Lang("ShootingOnMove", null) +  " | " + Lang("ClosestPoint", null, sp.closestPointLine1, sp.closestPointLine2, sp.prevIntersectionPoint) + " | " + Lang("FireTimeInterval", null, sp.timeInterval) + "\n";
                                        else
											txtConsole += Lang("ProjectileID", null, sp.projectile2ID) + " | " + Lang("StandingShooting", null) + " | " + Lang("RecoilAngle", null, sp.recoilAngle) + " | " + Lang("FireTimeInterval", null, sp.timeInterval) + "\n";
                                    }
                                    j++;
                                }

								txtConsole += "\n\n.";
                                break;
                            }
                            i++;
                        }
                    }
                }
				Puts(txtConsole);
			}
		}

		[ConsoleCommand("arkan.aim")]
		private void ConsoleShowAIMLog(ConsoleSystem.Arg arg)
        {			
			var player = arg.Player();
			string txtConsole = "";

			if (player == null)
			{
				if (!arg.HasArgs())
				{
					txtConsole = RemoveFormatting(Lang("ShowNRLog2", null));
                    int aimCnt = 0;
					
					if (PlayersViolations.Players.Count > 0)
					{
						foreach (KeyValuePair<ulong, PlayerViolationsData> list in PlayersViolations.Players.Where(x => (PlayersViolations.Players[x.Key].AIMViolations.Count > 0)))
						{
							txtConsole += $"{PlayersViolations.Players[list.Key].PlayerName} - AIM({PlayersViolations.Players[list.Key].AIMViolations.Count}); ";   
							
							aimCnt++;
						}

						Puts(txtConsole);
					}	
					
					if (aimCnt == 0)
                        Puts(RemoveFormatting(Lang("ShowAIMLog3", null)));

					return;
				}
				
                string s = null;
				txtConsole = "";
                ulong id = 0;
				ulong playerID = 0;
        
                if (arg.Args.Length == 2)
                {
                    if (arg.Args[1] == "0")
                    {
						txtConsole += Lang("ShowD1", null) + "\n";
						RconLog.violationsLog = new ViolationsLog();
                    }
                    else
                        s = arg.Args[1];
                }
        
                string user = arg.Args[0];
        
                if (user.Contains("765"))
                    ulong.TryParse(arg.Args[0], out id);
        
                foreach (KeyValuePair<ulong, PlayerViolationsData> list in PlayersViolations.Players)
                    if (PlayersViolations.Players[list.Key].PlayerID == id || PlayersViolations.Players[list.Key].PlayerName.Contains(user, CompareOptions.IgnoreCase))
                        playerID = PlayersViolations.Players[list.Key].PlayerID;

                if (playerID == 0)
					txtConsole += Lang("ShowD2", null) + "\n";
                else
                    if (PlayersViolations.Players[playerID].AIMViolations.Count == 0)
						txtConsole += Lang("ShowAIMD1", null, PlayersViolations.Players[playerID].PlayerName) + "\n";
                else
                {
					if ((long)RconLog.violationsLog.steamID != (long)PlayersViolations.Players[playerID].PlayerID)
                    {
						RconLog.violationsLog.AIMViolation = 1;
						RconLog.violationsLog.steamID = PlayersViolations.Players[playerID].PlayerID;
                    }
                    else if (s == null)
                        if (PlayersViolations.Players[playerID].AIMViolations.Count >= RconLog.violationsLog.AIMViolation + 1)
							RconLog.violationsLog.AIMViolation++;
                        else
                        {
							txtConsole += Lang("ShowD3", null, PlayersViolations.Players[playerID].PlayerName) + "\n";
							RconLog.violationsLog = new ViolationsLog();
							Puts(txtConsole);
                            return;
                        }
        
                    int result;
                    int.TryParse(s, out result);
        
                    if (result == 0)
						result = RconLog.violationsLog.AIMViolation;
        
                    int i = 1;
                    
					foreach (KeyValuePair<string, AIMViolationData> list in PlayersViolations.Players[playerID].AIMViolations)
                    {
                        if (i == result)
                        {
							AIMViolationData violationData = PlayersViolations.Players[playerID].AIMViolations[list.Key];

							txtConsole += Lang("Attacker", null) + ": " + (violationData.hitInfoInitiatorPlayerName ?? violationData.hitInfoInitiatorPlayerUserID) + "\n" + Lang("AIMViolationNum", null) + violationData.violationID + "\n" + Lang("Weapon", null) + ": " + violationData.weaponShortName + "\n" + Lang("Ammo", null) + ": " + violationData.ammoShortName + "\n" + Lang("Distance", null) + ": " + violationData.hitInfoProjectileDistance + "\n";
							txtConsole += Lang("Target", null) + ": " + (violationData.hitInfoHitEntityPlayerName ?? violationData.hitInfoHitEntityPlayerUserID) + "\n" + Lang("HitPart", null) + ": " + violationData.hitInfoBoneName + "\n";
							txtConsole += Lang("DateTime", null) + ": " + violationData.firedTime + "\n\n";
							
							txtConsole += Lang("AttachmentsCount", null) + " = " + violationData.attachments.Count + "\n";
    
                            if (violationData.attachments.Count > 0)
                                for (int ii = 0; ii < violationData.attachments.Count; ii++)
									txtConsole += Lang("Attachment", null) + " - " + violationData.attachments[ii] + "\n";
							
							if (violationData.isAttackerMount && violationData.attackerMountParentName != null)
								txtConsole += Lang("MountedOn", null, violationData.attackerMountParentName) + "\n\n";
                            
							txtConsole += Lang("RicochetsCount", null) + " + " + (violationData.hitsData.Count - 1) + "\n\n";
							txtConsole += $"isEqualFiredProjectileData = {violationData.isEqualFiredProjectileData}\n";
							txtConsole += $"isPlayerPositionToProjectileStartPositionDistanceViolation = {violationData.isPlayerPositionToProjectileStartPositionDistanceViolation}\n";
                            
							if (violationData.isPlayerPositionToProjectileStartPositionDistanceViolation)
								txtConsole += Lang("LogText6", null, violationData.distanceDifferenceViolation);
    
                            for (int j = 0; j < violationData.hitsData.Count; j++)
                            {
								txtConsole += $".\n" + Lang("LogText7", null, j + 1) + "\n";
								txtConsole += $"isHitPointNearProjectileTrajectoryLastSegmentEndPoint = {violationData.hitsData[j].isHitPointNearProjectileTrajectoryLastSegmentEndPoint}" + "\n";
                                
								if (!violationData.hitsData[j].isHitPointNearProjectileTrajectoryLastSegmentEndPoint && violationData.hitsData[j].side > 0)
                                    if (violationData.hitsData[j].side == 1)
										txtConsole += "     " + Lang("AIMText4", null, violationData.hitsData[j].distanceFromHitPointToProjectilePlane, Lang("AIMText2", null), "StartPoint", Vector3.Distance(violationData.hitsData[j].hitPositionWorld, violationData.hitsData[j].hitPointStart)) + "\n";
                                    else
										txtConsole += "     " + Lang("AIMText4", null, violationData.hitsData[j].distanceFromHitPointToProjectilePlane, Lang("AIMText3", null), "EndPoint", Vector3.Distance(violationData.hitsData[j].hitPositionWorld, violationData.hitsData[j].hitPointEnd)) + "\n";
    
								txtConsole += $"isHitPointOnProjectileTrajectory = {violationData.hitsData[j].isHitPointOnProjectileTrajectory}" + "\n";
								txtConsole += $"isProjectileStartPointAtEndReverseProjectileTrajectory = {violationData.hitsData[j].isProjectileStartPointAtEndReverseProjectileTrajectory}" + "\n";
                                
								if (!violationData.hitsData[j].isProjectileStartPointAtEndReverseProjectileTrajectory)
									txtConsole += "     " + Lang("AIMText6", null, violationData.hitsData[j].lastSegmentPointStart, violationData.hitsData[j].lastSegmentPointEnd, violationData.hitsData[j].startProjectilePosition, violationData.hitsData[j].startProjectilePosition + violationData.hitsData[j].startProjectileVelocity) + "\n";
    
								txtConsole += $"isHitPointNearProjectilePlane = {violationData.hitsData[j].isHitPointNearProjectilePlane}" + "\n";
                                
								if (!violationData.hitsData[j].isHitPointNearProjectilePlane)
									txtConsole += "     " + Lang("AIMText7", null, violationData.hitsData[j].distanceFromHitPointToProjectilePlane) + "\n";
    
								txtConsole += $"isLastSegmentOnProjectileTrajectoryPlane = {violationData.hitsData[j].isLastSegmentOnProjectileTrajectoryPlane}" + "\n";
                                
								if (!violationData.hitsData[j].isLastSegmentOnProjectileTrajectoryPlane)
									txtConsole += "     " + Lang("AIMText8", null, violationData.hitsData[j].lastSegmentPointStart, violationData.hitsData[j].startProjectilePosition, violationData.hitsData[j].startProjectilePosition + violationData.hitsData[j].startProjectileVelocity) + "\n";
    
								txtConsole += Lang("LogText8", null, j + 1) + "\n";
                            }
    
							txtConsole += "\n.";				
							
                            break;
                        }
                        i++;
                    }
                }
				Puts(txtConsole);
			}
		}

		[ConsoleCommand("arkan.ir")]
		private void ConsoleShowInRockLog(ConsoleSystem.Arg arg)
        {			
			var player = arg.Player();
			string txtConsole = "";

			if (player == null)
			{
				if (!arg.HasArgs())
				{
					txtConsole = RemoveFormatting(Lang("ShowNRLog2", null));
                    int nrCnt = 0;
					
					if (PlayersViolations.Players.Count > 0)
					{
						foreach (KeyValuePair<ulong, PlayerViolationsData> list in PlayersViolations.Players.Where(x => (PlayersViolations.Players[x.Key].inRockViolations.Count > 0)))
						{
							txtConsole += $"{PlayersViolations.Players[list.Key].PlayerName} - IR({PlayersViolations.Players[list.Key].inRockViolations.Count}); ";
							
							nrCnt++;
						}

						Puts(txtConsole);
					}	
					
					if (nrCnt == 0)
                        Puts(RemoveFormatting(Lang("ShowIRLog3", null)));

					return;
				}
				
                string s = null;
				txtConsole = "";
                ulong id = 0;
				ulong playerID = 0;
        
                if (arg.Args.Length == 2)
                    if (arg.Args[1] == "0")
                    {
						txtConsole += Lang("ShowD1", null) + "\n";
						RconLog = new AdminConfig();
                    }
                    else
                        s = arg.Args[1];
        
                string user = arg.Args[0];
        
                if (user.Contains("765"))
                    ulong.TryParse(arg.Args[0], out id);
        
                foreach (KeyValuePair<ulong, PlayerViolationsData> list in PlayersViolations.Players)
                    if (PlayersViolations.Players[list.Key].PlayerID == id || PlayersViolations.Players[list.Key].PlayerName.Contains(user, CompareOptions.IgnoreCase))
                        playerID = PlayersViolations.Players[list.Key].PlayerID;
        
                if (playerID == 0)
					txtConsole += Lang("ShowD2", null) + "\n";
                else
                {
                    if (PlayersViolations.Players[playerID].inRockViolations.Count == 0)
						txtConsole += Lang("ShowIRD1", null, PlayersViolations.Players[playerID].PlayerName) + "\n";
                    else
                    {
						if ((long)RconLog.violationsLog.steamID != (long)PlayersViolations.Players[playerID].PlayerID)
                        {
							RconLog.violationsLog.InRockViolation = 1;
							RconLog.violationsLog.steamID = PlayersViolations.Players[playerID].PlayerID;
                        }
                        else
                            if (s == null)
								if (PlayersViolations.Players[playerID].inRockViolations.Count >= RconLog.violationsLog.InRockViolation + 1)
									RconLog.violationsLog.InRockViolation++;
                                else
                                {
									txtConsole += Lang("NoMoreViolations", null, PlayersViolations.Players[playerID].PlayerName) + "\n";
									RconLog.violationsLog = new ViolationsLog();
									Puts(txtConsole);
                                    return;
                                }

                        int result;
                        int.TryParse(s, out result);
        
                        if (result == 0)
                            result = RconLog.violationsLog.InRockViolation;
        
                        int i = 1;
                        foreach (KeyValuePair<string, InRockViolationsData> list in PlayersViolations.Players[playerID].inRockViolations)
                        {
                            if (i == result)
                            {
                                InRockViolationsData violationData = PlayersViolations.Players[playerID].inRockViolations[list.Key];

								txtConsole += "\n" + Lang("Attacker", null) + ": " + PlayersViolations.Players[playerID].PlayerName + "/" + PlayersViolations.Players[playerID].PlayerID + "\n" + Lang("IRViolationNum", null) + result + "\n" + Lang("Weapon", null) + ": " + violationData.inRockViolationsData[1].firedProjectile.weaponShortName + "\n" + Lang("Ammo", null) + ": " + violationData.inRockViolationsData[1].firedProjectile.ammoShortName + "\n" + Lang("ShotsCount", null) + ": " + violationData.inRockViolationsData.Count + "\n";

								for (int j = 1; j <= violationData.inRockViolationsData.Count; j++)
								{
									txtConsole += Lang("ProjectileID", null, j) + " | " + Lang("Target", null) + ": " + violationData.inRockViolationsData[j].targetName + "/" + violationData.inRockViolationsData[j].targetID + " | " + Lang("HitPart", null) + ": " + violationData.inRockViolationsData[j].targetBodyPart + " | " + Lang("Damage", null) + ": " + violationData.inRockViolationsData[j].targetDamage;
								}
                                break;
                            }
                            i++;
                        }
                    }
                }
				Puts(txtConsole);
			}
		}
		
		[ConsoleCommand("arkan.clear")]
		private void ConsoleClearViolationsData(ConsoleSystem.Arg arg)
        {			
			var player = arg.Player();

			if (player == null)
			{
				PlayersViolations.Players.Clear();
                DateTime currentDate = DateTime.Now.AddSeconds(-UnityEngine.Time.realtimeSinceStartup);
                PlayersViolations.seed = ConVar.Server.seed;
                PlayersViolations.mapSize = ConVar.Server.worldsize;
                PlayersViolations.serverTimeStamp = currentDate.Year + "." + currentDate.Month + "." + currentDate.Day + "." + currentDate.Hour + "." + currentDate.Minute;
        
                foreach (KeyValuePair<BasePlayer, AdminConfig> list in AdminsConfig)
                    AdminsConfig[list.Key].violationsLog = new ViolationsLog();
        
                SaveViolationsData(null, null, null);
				Puts(RemoveFormatting(Lang("ClearVD", null)));
			}
		}		
		
		[ConsoleCommand("arkan.save")]
		private void ConsoleSaveViolationsData(ConsoleSystem.Arg arg)
        {			
			var player = arg.Player();

			if (player == null)
			{
                string fileName = serverTimeStamp;
        
                if (arg.HasArgs(1))
                    fileName = arg.Args[0];
        
                PlayersViolations.lastSaveTime = DateTime.Now;
                Interface.Oxide.DataFileSystem.WriteObject("Arkan/" + fileName, PlayersViolations);

				Puts(RemoveFormatting(Lang("SaveVD1", null, fileName)));
			}
		}			

		[ConsoleCommand("arkan.load")]
		private void ConsoleLoadViolationsData(ConsoleSystem.Arg arg)
        {			
			var player = arg.Player();

			if (player == null)
			{
                string fileName = serverTimeStamp;
        
                if (arg.HasArgs(1))
                    fileName = arg.Args[0];
        
                if (Interface.Oxide.DataFileSystem.ExistsDatafile("Arkan/" + fileName))
                {
                    tmpPlayersViolations = null;
                    tmpPlayersViolations = Interface.Oxide.DataFileSystem.ReadObject<PlayersViolationsData>("Arkan/" + fileName);
					
                    if (tmpPlayersViolations.seed != ConVar.Server.seed)
                    {
                        Puts(Lang("LoadVD2", null, tmpPlayersViolations.seed, ConVar.Server.seed));
                        return;
                    }
        
                    if (tmpPlayersViolations.mapSize != ConVar.Server.worldsize)
                    {
                        Puts(Lang("LoadVD3", null, tmpPlayersViolations.mapSize, ConVar.Server.worldsize));
                        return;
                    }
        
                    if (tmpPlayersViolations.Players.Count > 0)
                    {
                        bool isChanged = false;
                        PlayerViolationsData playerViolationsData;
                        NoRecoilViolationData nrvd;
                        AIMViolationData aimvd;
						InRockViolationsData irvd;
        
                        foreach (KeyValuePair<ulong, PlayerViolationsData> list in tmpPlayersViolations.Players)
                        {
                            if (!PlayersViolations.Players.TryGetValue(tmpPlayersViolations.Players[list.Key].PlayerID, out playerViolationsData))
                            {
                                PlayersViolations.Players.Add(list.Key, playerViolationsData = new PlayerViolationsData());
                                PlayersViolations.Players[list.Key].PlayerID = tmpPlayersViolations.Players[list.Key].PlayerID;
                                PlayersViolations.Players[list.Key].PlayerName = tmpPlayersViolations.Players[list.Key].PlayerName;
                                isChanged = true;
                            }
        
                            if (tmpPlayersViolations.Players[list.Key].noRecoilViolations.Count > 0)
                                foreach (KeyValuePair<string, NoRecoilViolationData> nrlist in tmpPlayersViolations.Players[list.Key].noRecoilViolations)
                                    if (!PlayersViolations.Players[tmpPlayersViolations.Players[list.Key].PlayerID].noRecoilViolations.TryGetValue(nrlist.Key, out nrvd))
                                    {
                                        PlayersViolations.Players[list.Key].noRecoilViolations.Add(nrlist.Key, nrvd = new NoRecoilViolationData());
                                        PlayersViolations.Players[list.Key].noRecoilViolations[nrlist.Key] = tmpPlayersViolations.Players[list.Key].noRecoilViolations[nrlist.Key];
                                        isChanged = true;
                                    }
        
                            if (tmpPlayersViolations.Players[list.Key].AIMViolations.Count > 0)
                                foreach (KeyValuePair<string, AIMViolationData> aimlist in tmpPlayersViolations.Players[list.Key].AIMViolations)
                                    if (!PlayersViolations.Players[tmpPlayersViolations.Players[list.Key].PlayerID].AIMViolations.TryGetValue(aimlist.Key, out aimvd))
                                    {
                                        PlayersViolations.Players[list.Key].AIMViolations.Add(aimlist.Key, aimvd = new AIMViolationData());
                                        PlayersViolations.Players[list.Key].AIMViolations[aimlist.Key] = tmpPlayersViolations.Players[list.Key].AIMViolations[aimlist.Key];
                                        isChanged = true;
                                    }
						
							if (tmpPlayersViolations.Players[list.Key].inRockViolations.Count > 0)
                                foreach (KeyValuePair<string, InRockViolationsData> irlist in tmpPlayersViolations.Players[list.Key].inRockViolations)
                                    if (!PlayersViolations.Players[tmpPlayersViolations.Players[list.Key].PlayerID].inRockViolations.TryGetValue(irlist.Key, out irvd))
                                    {
                                        PlayersViolations.Players[list.Key].inRockViolations.Add(irlist.Key, irvd = new InRockViolationsData());
                                        PlayersViolations.Players[list.Key].inRockViolations[irlist.Key] = tmpPlayersViolations.Players[list.Key].inRockViolations[irlist.Key];
                                        isChanged = true;
                                    }
                        }
						
                        if (isChanged)
                        {
                            PlayersViolations.lastChangeTime = DateTime.Now;
                            PlayersViolations.lastSaveTime = DateTime.Now;
                        }
						
                        tmpPlayersViolations.Players = null;
        
                        Puts(RemoveFormatting(Lang("LoadVD1", null, fileName)));
                    }
                }
                else
					Puts(RemoveFormatting(Lang("LoadVD4", null, fileName)));
			}
		}	

        [ChatCommand("arkanclear")]
		private void ClearViolationsData(BasePlayer player, string command, string[] args)
        {
            if (player != null)
			{	
                if (!player.IsAdmin || !permission.UserHasPermission(player.UserIDString, permName))
                    return;

				AdminLogInit(player);

                PlayersViolations.Players.Clear();
                DateTime currentDate = DateTime.Now.AddSeconds(-UnityEngine.Time.realtimeSinceStartup);
                PlayersViolations.seed = ConVar.Server.seed;
                PlayersViolations.mapSize = ConVar.Server.worldsize;
                PlayersViolations.serverTimeStamp = currentDate.Year + "." + currentDate.Month + "." + currentDate.Day + "." + currentDate.Hour + "." + currentDate.Minute;
        
                foreach (KeyValuePair<BasePlayer, AdminConfig> list in AdminsConfig)
                    AdminsConfig[list.Key].violationsLog = new ViolationsLog();

				SaveViolationsData(null, null, null);
                SendReply(player, Lang("ClearVD", player.UserIDString));
			}
        }

        [ChatCommand("arkansave")]
		private void SaveViolationsData(BasePlayer player, string command, string[] args)
        {
            if (player != null)
			{	
                if (!player.IsAdmin || !permission.UserHasPermission(player.UserIDString, permName))
                    return;
				
				AdminLogInit(player);
			}

            string fileName = serverTimeStamp;

            if (args != null)
                if (args.Length > 0)
                    fileName = args[0];

            PlayersViolations.lastSaveTime = DateTime.Now;
            Interface.Oxide.DataFileSystem.WriteObject("Arkan/" + fileName, PlayersViolations);

            if (player != null)
                SendReply(player, Lang("SaveVD1", player.UserIDString, fileName));
        }

        [ChatCommand("arkanload")]
		private void LoadViolationsData(BasePlayer player, string command, string[] args)
        {
            if (player != null)
			{	
                if (!player.IsAdmin || !permission.UserHasPermission(player.UserIDString, permName))
                    return;

				AdminLogInit(player);
			}

            string fileName = serverTimeStamp;

            if (args != null)
                if (args.Length > 0)
                    fileName = args[0];

            if (Interface.Oxide.DataFileSystem.ExistsDatafile("Arkan/" + fileName))
            {
                tmpPlayersViolations = null;
                tmpPlayersViolations = Interface.Oxide.DataFileSystem.ReadObject<PlayersViolationsData>("Arkan/" + fileName);
				
                if (tmpPlayersViolations.seed != ConVar.Server.seed)
                {
                    SendReply(player, "<color=green>Arkan: </color><color=red>" + Lang("LoadVD2", player.UserIDString, "<color=yellow>" + tmpPlayersViolations.seed + "</color>", "<color=yellow>" + ConVar.Server.seed + "</color>") + "</color>");
                    Puts(Lang("LoadVD2", player.UserIDString, tmpPlayersViolations.seed, ConVar.Server.seed));
                    return;
                }

                if (tmpPlayersViolations.mapSize != ConVar.Server.worldsize)
                {
                    SendReply(player, "<color=green>Arkan: </color><color=red>" + Lang("LoadVD3", player.UserIDString, "<color=yellow>" + tmpPlayersViolations.mapSize + "</color>", "<color=yellow>" + ConVar.Server.worldsize + "</color>") + "</color>");
                    Puts(Lang("LoadVD3", player.UserIDString, tmpPlayersViolations.mapSize, ConVar.Server.worldsize));
                    return;
                }

                if (tmpPlayersViolations.Players.Count > 0)
                {
                    bool isChanged = false;
                    PlayerViolationsData playerViolationsData;
                    NoRecoilViolationData nrvd;
                    AIMViolationData aimvd;
					InRockViolationsData irvd;

                    foreach (KeyValuePair<ulong, PlayerViolationsData> list in tmpPlayersViolations.Players)
                    {
                        if (!PlayersViolations.Players.TryGetValue(tmpPlayersViolations.Players[list.Key].PlayerID, out playerViolationsData))
                        {
                            PlayersViolations.Players.Add(list.Key, playerViolationsData = new PlayerViolationsData());
                            PlayersViolations.Players[list.Key].PlayerID = tmpPlayersViolations.Players[list.Key].PlayerID;
                            PlayersViolations.Players[list.Key].PlayerName = tmpPlayersViolations.Players[list.Key].PlayerName;
                            isChanged = true;
                        }

                        if (tmpPlayersViolations.Players[list.Key].noRecoilViolations.Count > 0)
                            foreach (KeyValuePair<string, NoRecoilViolationData> nrlist in tmpPlayersViolations.Players[list.Key].noRecoilViolations)
                                if (!PlayersViolations.Players[tmpPlayersViolations.Players[list.Key].PlayerID].noRecoilViolations.TryGetValue(nrlist.Key, out nrvd))
                                {
                                    PlayersViolations.Players[list.Key].noRecoilViolations.Add(nrlist.Key, nrvd = new NoRecoilViolationData());
                                    PlayersViolations.Players[list.Key].noRecoilViolations[nrlist.Key] = tmpPlayersViolations.Players[list.Key].noRecoilViolations[nrlist.Key];
                                    isChanged = true;
                                }

                        if (tmpPlayersViolations.Players[list.Key].AIMViolations.Count > 0)
                            foreach (KeyValuePair<string, AIMViolationData> aimlist in tmpPlayersViolations.Players[list.Key].AIMViolations)
                                if (!PlayersViolations.Players[tmpPlayersViolations.Players[list.Key].PlayerID].AIMViolations.TryGetValue(aimlist.Key, out aimvd))
                                {
                                    PlayersViolations.Players[list.Key].AIMViolations.Add(aimlist.Key, aimvd = new AIMViolationData());
                                    PlayersViolations.Players[list.Key].AIMViolations[aimlist.Key] = tmpPlayersViolations.Players[list.Key].AIMViolations[aimlist.Key];
                                    isChanged = true;
                                }
						
						if (tmpPlayersViolations.Players[list.Key].inRockViolations.Count > 0)
                            foreach (KeyValuePair<string, InRockViolationsData> irlist in tmpPlayersViolations.Players[list.Key].inRockViolations)
								if (!PlayersViolations.Players[tmpPlayersViolations.Players[list.Key].PlayerID].inRockViolations.TryGetValue(irlist.Key, out irvd))
                                {
                                    PlayersViolations.Players[list.Key].inRockViolations.Add(irlist.Key, irvd = new InRockViolationsData());
                                    PlayersViolations.Players[list.Key].inRockViolations[irlist.Key] = tmpPlayersViolations.Players[list.Key].inRockViolations[irlist.Key];
                                    isChanged = true;
                                }
                    }
					
                    if (isChanged)
                    {
                        PlayersViolations.lastChangeTime = DateTime.Now;
                        PlayersViolations.lastSaveTime = DateTime.Now;
                    }
					
                    tmpPlayersViolations.Players = null;

                    if (player != null)
                        SendReply(player, Lang("LoadVD1", player.UserIDString, fileName));
                }
            }
            else
				if (player != null)
					SendReply(player, Lang("LoadVD4", player.UserIDString, fileName));
        }

		[ChatCommand("arkan")]
        private void ShowLog(BasePlayer player, string command, string[] args)
        {
			if (player != null)
			{	
				if (!player.IsAdmin || !permission.UserHasPermission(player.UserIDString, permName))
					return;
				
				AdminLogInit(player);

                string txt = Lang("ShowInfo", player.UserIDString);
        
                if (PlayersViolations.Players.Count > 0)
                {
                    txt += Lang("ShowLog2", player.UserIDString) + "\n";
					string txtTmp = "";
					string txtConsole = "<color=green>Arkan: </color>" + Lang("ShowLog2");
					int i = 1;
					
                    foreach (KeyValuePair<ulong, PlayerViolationsData> list in PlayersViolations.Players)
					{
						txtTmp = "";
						txt += $"<size=10><color=green>{PlayersViolations.Players[list.Key].PlayerName}</color> -";
						txtConsole += $"<color=green>{PlayersViolations.Players[list.Key].PlayerName}</color> -";
						
						if (PlayersViolations.Players[list.Key].noRecoilViolations.Count > 0)
							txtTmp += $" NR(<color=yellow>{PlayersViolations.Players[list.Key].noRecoilViolations.Count}</color>)";
						
						if (PlayersViolations.Players[list.Key].AIMViolations.Count > 0)
							txtTmp += $" AIM(<color=yellow>{PlayersViolations.Players[list.Key].AIMViolations.Count}</color>)";
						
						if (PlayersViolations.Players[list.Key].inRockViolations.Count > 0)
							txtTmp += $" IR(<color=yellow>{PlayersViolations.Players[list.Key].inRockViolations.Count}</color>)";
						
						txtConsole += txtTmp + "; ";
                        txt += txtTmp + "; </size>";

						i++;

						if (i == 5)
						{
							txtConsole += "\n";
							i = 1;
						}								
					}
					
					player.ConsoleMessage(txtConsole + "</color></size>");
                }
                else
				{
                    txt += Lang("ShowLog3", player.UserIDString);
					player.ConsoleMessage("<color=green>Arkan: </color>" + Lang("ShowLog3", player.UserIDString) + "</color></size>");
				}
        
                SendReply(player, txt + "</color></size>");
                return;
            }
        }

		[ChatCommand("arkaninfo")]
        private void ShowInfo(BasePlayer player, string command, string[] args)
        {
			if (player != null)
			{	
				if (!player.IsAdmin || !permission.UserHasPermission(player.UserIDString, permName))
					return;
				
				AdminLogInit(player);

                SendReply(player, Lang("ShowLog1v1.0.13", player.UserIDString));
            }
        }

        [ChatCommand("arkannr")]
		private void ShowNoRecoilLog(BasePlayer player, string command, string[] args)
        {
			if (player != null)
			{	
				if (!player.IsAdmin || !permission.UserHasPermission(player.UserIDString, permName))
					return;

				AdminLogInit(player);

                if (args.Length == 0)
                {
                    int nrCnt = 0;
                    string txt = Lang("ShowInfo", player.UserIDString);
					string txtConsole = "";
        
                    if (PlayersViolations.Players.Count > 0)
					{
						int i = 1;
						foreach (KeyValuePair<ulong, PlayerViolationsData> list in PlayersViolations.Players.Where(x => (PlayersViolations.Players[x.Key].noRecoilViolations.Count > 0)))
                        {
                            if (nrCnt == 0)
							{
                                txt += Lang("ShowNRLog2", player.UserIDString) + "\n";
								txtConsole = "<color=green>Arkan: </color>" + Lang("ShowNRLog2", player.UserIDString);
							}
        
                            txt += $"<size=10><color=green>{PlayersViolations.Players[list.Key].PlayerName}</color> - NR(<color=yellow>{PlayersViolations.Players[list.Key].noRecoilViolations.Count}</color>); </size>";
                            txtConsole += $"<color=green>{PlayersViolations.Players[list.Key].PlayerName}</color> - NR(<color=yellow>{PlayersViolations.Players[list.Key].noRecoilViolations.Count}</color>); ";
							
							i++;
							
							if (i == 5)
							{
								txtConsole += "\n";
								i = 1;
							}   
							
							nrCnt++;
                        }
						
						player.ConsoleMessage(txtConsole + "</color></size>");
					}
        
                    if (nrCnt == 0)
					{
                        txt += Lang("ShowNRLog3", player.UserIDString);
						player.ConsoleMessage("<color=green>Arkan: </color>" + Lang("ShowNRLog3", player.UserIDString) + "</color></size>");
					}
					
                    SendReply(player, txt + "</color></size>");
                    return;
                }

				ShowNoRecoilViolations(player, args);
			}
        }

        [ChatCommand("arkanaim")]
		private void ShowAIMLog(BasePlayer player, string command, string[] args)
        {
			if (player != null)
			{	
				if (!player.IsAdmin || !permission.UserHasPermission(player.UserIDString, permName))
					return;

				AdminLogInit(player);

                if (args.Length == 0)
                {
                    int aimCnt = 0;
                    string txt = Lang("ShowInfo", player.UserIDString);
					string txtConsole = "";
        
                    if (PlayersViolations.Players.Count > 0)
					{
						int i = 1;
						foreach (KeyValuePair<ulong, PlayerViolationsData> list in PlayersViolations.Players.Where(x => (PlayersViolations.Players[x.Key].AIMViolations.Count > 0)))
                        {
                            if (aimCnt == 0)
							{
                                txt += Lang("ShowAIMLog2", player.UserIDString) + "\n";
								txtConsole = "<color=green>Arkan: </color>" + Lang("ShowAIMLog2", player.UserIDString);
							}
        
                            txt += $"<size=10><color=green>{PlayersViolations.Players[list.Key].PlayerName}</color> - AIM(<color=yellow>{PlayersViolations.Players[list.Key].AIMViolations.Count}</color>); </size>";
                            txtConsole += $"<color=green>{PlayersViolations.Players[list.Key].PlayerName}</color> - AIM(<color=yellow>{PlayersViolations.Players[list.Key].AIMViolations.Count}</color>); ";
							
							i++;
							
							if (i == 5)
							{
								txtConsole += "\n";
								i = 1;
							}   
							
							aimCnt++;
                        }
						
						player.ConsoleMessage(txtConsole + "</color></size>");
					}
        
                    if (aimCnt == 0)
					{
                        txt += Lang("ShowAIMLog3", player.UserIDString);
						player.ConsoleMessage("<color=green>Arkan: </color>" + Lang("ShowAIMLog3", player.UserIDString) + "</color></size>");
					}
        
                    SendReply(player, txt + "</color></size>");
                    return;
                }
        
                ShowAIMViolations(player, args);
			}
        }

        [ChatCommand("arkanaimr")]
		private void ShowAIMLogRecalc(BasePlayer player, string command, string[] args) //for development purposes only
        {
			if (player != null)
			{	
				if (!player.IsAdmin || !permission.UserHasPermission(player.UserIDString, permName))
					return;

				AdminLogInit(player);

                if (args.Length == 0)
                {
                    int nrCnt = 0;
                    string txt = Lang("ShowInfo", player.UserIDString);
        
                    if (PlayersViolations.Players.Count > 0)
						foreach (KeyValuePair<ulong, PlayerViolationsData> list in PlayersViolations.Players.Where(x => (PlayersViolations.Players[x.Key].AIMViolations.Count > 0)))
                        {
                            if (nrCnt == 0)
                                txt += Lang("ShowAIMLog2", player.UserIDString);
        
                            txt += $"<color=green>{PlayersViolations.Players[list.Key].PlayerName}</color> - AIM(<color=yellow>{PlayersViolations.Players[list.Key].AIMViolations.Count}</color>); ";
                            nrCnt++;
                        }
        
                    if (nrCnt == 0)
                        txt += Lang("ShowAIMLog3", player.UserIDString);
        
                    SendReply(player, txt + "</color></size>");
                    return;
                }
        
                ShowAIMViolationsRecalc(player, args);
			}			
        }

		[ChatCommand("arkanir")]
		private void ShowInRocklLog(BasePlayer player, string command, string[] args)
        {
			if (player != null)
			{	
				if (!player.IsAdmin || !permission.UserHasPermission(player.UserIDString, permName))
					return;

				AdminLogInit(player);

                if (args.Length == 0)
                {
                    int nrCnt = 0;
                    string txt = Lang("ShowInfo", player.UserIDString);
					string txtConsole = "";
        
                    if (PlayersViolations.Players.Count > 0)
					{
						int i = 1;
						foreach (KeyValuePair<ulong, PlayerViolationsData> list in PlayersViolations.Players.Where(x => (PlayersViolations.Players[x.Key].inRockViolations.Count > 0)))
                        {
                            if (nrCnt == 0)
							{
                                txt += Lang("ShowIRLog2", player.UserIDString) + "\n";
								txtConsole = "<color=green>Arkan: </color>" + Lang("ShowIRLog2", player.UserIDString);
							}
        
                            txt += $"<size=10><color=green>{PlayersViolations.Players[list.Key].PlayerName}</color> - IR(<color=yellow>{PlayersViolations.Players[list.Key].inRockViolations.Count}</color>); </size>";
                            txtConsole += $"<color=green>{PlayersViolations.Players[list.Key].PlayerName}</color> - IR(<color=yellow>{PlayersViolations.Players[list.Key].inRockViolations.Count}</color>); ";
							
							i++;
							
							if (i == 5)
							{
								txtConsole += "\n";
								i = 1;
							}   
							
							nrCnt++;
                        }
						
						player.ConsoleMessage(txtConsole + "</color></size>");
					}
        
                    if (nrCnt == 0)
					{
                        txt += Lang("ShowIRLog3", player.UserIDString);
						player.ConsoleMessage("<color=green>Arkan: </color>" + Lang("ShowIRLog3", player.UserIDString) + "</color></size>");
					}
					
                    SendReply(player, txt + "</color></size>");
                    return;
                }

				ShowInRockViolations(player, args);
			}
        }
		
        #endregion Commands

        #region Functions
		
		private string API_ArkanGetPlayersViolationsData()
        {
			if(PlayersViolations != null)
			{
				return JsonConvert.SerializeObject(PlayersViolations);
			}
			return null;
		}		

        private void CleanupExpiredProjectiles(BasePlayer player)
        {
			if (player != null)
				if (PlayersFiredProjectlesData.ContainsKey(player.userID))
					if (PlayersFiredProjectlesData[player.userID].lastFiredTime < UnityEngine.Time.realtimeSinceStartup - 8f && (PlayersFiredProjectlesData[player.userID].firedProjectiles.Count > 0 || PlayersFiredProjectlesData[player.userID].melees.Count > 0))
					{
						PlayersFiredProjectlesData[player.userID].firedProjectiles.Clear();
						PlayersFiredProjectlesData[player.userID].melees.Clear();
					}
        }

        private void DDrawArrowToAdmin(BasePlayer player, float _drawTime, Color color, Vector3 startPosition, Vector3 endPosition, float arrowHeadSize)
        {
            if (player != null)
            {
                if (player.IsAdmin && permission.UserHasPermission(player.UserIDString, permName))
                    player.SendConsoleCommand("ddraw.arrow", _drawTime, color, startPosition, endPosition, arrowHeadSize);
            }
            else
                foreach (var _player in BasePlayer.activePlayerList.Where(x => x.IsAdmin && permission.UserHasPermission(x.UserIDString, permName)))
                    _player.SendConsoleCommand("ddraw.arrow", _drawTime, color, startPosition, endPosition, arrowHeadSize);
        }

        private void DDrawSphereToAdmin(BasePlayer player, float _drawTime, Color color, Vector3 Position, float sphereSize)
        {
            if (player != null)
            {
                if (player.IsAdmin && permission.UserHasPermission(player.UserIDString, permName))
                    player.SendConsoleCommand("ddraw.sphere", _drawTime, color, Position, sphereSize);
            }
            else
                foreach (var _player in BasePlayer.activePlayerList.Where(x => x.IsAdmin && permission.UserHasPermission(x.UserIDString, permName)))
                    _player.SendConsoleCommand("ddraw.sphere", _drawTime, color, Position, sphereSize);
        }

        private void DDrawTextToAdmin(BasePlayer player, float _drawTime, Color color, Vector3 Position, string text)
        {
            if (player != null)
            {
                if (player.IsAdmin && permission.UserHasPermission(player.UserIDString, permName))
                    player.SendConsoleCommand("ddraw.text", _drawTime, color, Position, text);
            }
            else
                foreach (var _player in BasePlayer.activePlayerList.Where(x => x.IsAdmin && permission.UserHasPermission(x.UserIDString, permName)))
                    _player.SendConsoleCommand("ddraw.text", _drawTime, color, Position, text);
        }
		
		private void DrawInRockViolationsData(BasePlayer player, string suspectPlayerName, string suspectPlayerID, int vsCnt, InRockViolationsData violationData, bool isTeleport)
        {
            if (player != null && violationData != null)
            {                
                if (isTeleport)
                {
                    Vector3 startPos = violationData.inRockViolationsData[1].firedProjectile.projectilePosition;
                    Vector3 tempPos = player.eyes.HeadForward();
                    Vector3 teleportPos = new Vector3(startPos.x - tempPos.x, startPos.y + 0.1f, startPos.z - tempPos.z);
                    player.Teleport(teleportPos);
                }
				
				DDrawTextToAdmin(player, _config.drawTime, Color.cyan, violationData.inRockViolationsData[1].firedProjectile.projectilePosition + Vector3.up * 0.3f, Lang("PlayerTxt", player.UserIDString) + ": <color=yellow>" + suspectPlayerName + "/" +suspectPlayerID + "</color>\n" + Lang("IRViolationNum", player.UserIDString) + ": <color=white>" + vsCnt + "</color>\n" + Lang("Weapon", player.UserIDString) + ": <color=white>" + violationData.inRockViolationsData[1].firedProjectile.weaponShortName + "</color>\n" + Lang("Ammo", player.UserIDString) + ": <color=white>" + violationData.inRockViolationsData[1].firedProjectile.ammoShortName + "</color>\n" + Lang("ShotsCount", player.UserIDString) + ": <color=white>" + violationData.inRockViolationsData.Count + "</color>");
				DDrawSphereToAdmin(player, _config.drawTime, Color.green, violationData.inRockViolationsData[1].firedProjectile.projectilePosition, 0.04f);
				
				for (int i = 1; i <= violationData.inRockViolationsData.Count; i++)
                {					
					float physicsSteps = violationData.inRockViolationsData[i].physicsSteps;
					float fixedDeltaTime = 1f / physicsSteps;
                    Vector3 position = violationData.inRockViolationsData[i].firedProjectile.projectilePosition;
                    Vector3 vector1 = violationData.inRockViolationsData[i].firedProjectile.projectileVelocity / physicsSteps;
                    float distance = violationData.inRockViolationsData[i].targetHitDistance;
					float hitInfoDistance = violationData.inRockViolationsData[i].targetHitDistance;
                    float gravityModifier = violationData.inRockViolationsData[i].gravityModifier;
                    float drag = violationData.inRockViolationsData[i].drag;
                    Vector3 hitPoint = violationData.inRockViolationsData[i].targetHitPosition;
                    Vector3 vector2 = ((Physics.gravity * gravityModifier) / physicsSteps) * fixedDeltaTime;

                    float single1 = drag * fixedDeltaTime;
                    float dist = 0.0f;
					int segmentsCnt = (int)(physicsSteps * 8);
            
                    DDrawSphereToAdmin(player, _config.drawTime, Color.red, hitPoint, 0.04f);
					DDrawSphereToAdmin(player, _config.drawTime, Color.red, violationData.inRockViolationsData[i].rockHitPosition, 0.04f);
            
                    for (int j = 0; j < segmentsCnt; j++)
                    {                        
                        DDrawArrowToAdmin(player, _config.drawTime, Color.yellow, position, position + vector1, 0.05f);
            
                        if ((distance - dist) <= (vector1.magnitude))
                            break;
            
                        dist += vector1.magnitude;
                        position += vector1;
            
                        vector1 += vector2;
                        vector1 -= (vector1 * single1);
                    }					
				}
            }
        }

        private void DrawNoRecoilViolationsData(BasePlayer player, string suspectPlayerName, NoRecoilViolationData violationData, bool isTeleport)
        {
            if (player != null)
            {
                if (violationData.isMounted)
                {
                    Matrix4x4 viewMatrix;
					Quaternion q = new Quaternion(violationData.mountParentRotation.x, violationData.mountParentRotation.y, violationData.mountParentRotation.z, violationData.mountParentRotation.w);
					viewMatrix = Matrix4x4.LookAt(violationData.mountParentPosition, violationData.mountParentPosition + (q * Vector3.forward), Vector3.up);

                    if (isTeleport)
                    {
                        Vector3 startPos = viewMatrix.MultiplyPoint(violationData.suspiciousNoRecoilShots[1].projectile2Position - player.eyes.offset);
                        Vector3 tempPos = player.eyes.HeadForward();
                        Vector3 teleportPos = new Vector3(startPos.x - tempPos.x, startPos.y + 0.1f, startPos.z - tempPos.z);
                        player.Teleport(teleportPos);
                    }

                    foreach (KeyValuePair<int, SuspiciousProjectileData> list in violationData.suspiciousNoRecoilShots.ToArray())
                    {
                        DDrawSphereToAdmin(player, _config.drawTime, Color.green, viewMatrix.MultiplyPoint(violationData.suspiciousNoRecoilShots[list.Key].projectile2Position), 0.01f);
                        
						if (violationData.suspiciousNoRecoilShots[list.Key].isNoRecoil)
                        {
                            DDrawArrowToAdmin(player, _config.drawTime, Color.blue, viewMatrix.MultiplyPoint(violationData.suspiciousNoRecoilShots[list.Key].projectile2Position), viewMatrix.MultiplyPoint(violationData.suspiciousNoRecoilShots[list.Key].projectile2Position + violationData.suspiciousNoRecoilShots[list.Key].projectile2Velocity.normalized * 450f), 0.2f);
                            
							if (violationData.suspiciousNoRecoilShots[list.Key].isShootedInMotion)
                            {
                                DDrawSphereToAdmin(player, _config.drawTime, Color.red, viewMatrix.MultiplyPoint(violationData.suspiciousNoRecoilShots[list.Key].closestPointLine1), 0.1f);
                                DDrawSphereToAdmin(player, _config.drawTime, Color.red, viewMatrix.MultiplyPoint(violationData.suspiciousNoRecoilShots[list.Key].closestPointLine2), 0.1f);
                            }
                        }
                        else
                            DDrawArrowToAdmin(player, _config.drawTime, Color.green, viewMatrix.MultiplyPoint(violationData.suspiciousNoRecoilShots[list.Key].projectile2Position), viewMatrix.MultiplyPoint(violationData.suspiciousNoRecoilShots[list.Key].projectile2Position + violationData.suspiciousNoRecoilShots[list.Key].projectile2Velocity.normalized * 450f), 0.2f);
                    }
                }
                else
                {
                    if (isTeleport)
                    {
                        Vector3 startPos = violationData.suspiciousNoRecoilShots[1].projectile2Position - player.eyes.offset;
                        Vector3 tempPos = player.eyes.HeadForward();
                        Vector3 teleportPos = new Vector3(startPos.x - tempPos.x, startPos.y + 0.1f, startPos.z - tempPos.z);
                        player.Teleport(teleportPos);
                    }

                    DDrawTextToAdmin(player, _config.drawTime, Color.cyan, violationData.suspiciousNoRecoilShots[1].projectile2Position + Vector3.up * 0.3f, Lang("DrawNRVD1", player.UserIDString, suspectPlayerName, violationData.ammoShortName, violationData.weaponShortName, violationData.suspiciousNoRecoilShots.Count(), violationData.violationProbability));

                    foreach (KeyValuePair<int, SuspiciousProjectileData> list in violationData.suspiciousNoRecoilShots.ToArray())
                    {
                        DDrawSphereToAdmin(player, _config.drawTime, Color.green, violationData.suspiciousNoRecoilShots[list.Key].projectile2Position, 0.01f);
                        
						if (violationData.suspiciousNoRecoilShots[list.Key].isNoRecoil)
                        {
                            DDrawArrowToAdmin(player, _config.drawTime, Color.blue, violationData.suspiciousNoRecoilShots[list.Key].projectile2Position, (violationData.suspiciousNoRecoilShots[list.Key].projectile2Position + violationData.suspiciousNoRecoilShots[list.Key].projectile2Velocity.normalized * 450f), 0.2f);
                            
							if (violationData.suspiciousNoRecoilShots[list.Key].isShootedInMotion)
                            {
                                DDrawSphereToAdmin(player, _config.drawTime, Color.red, violationData.suspiciousNoRecoilShots[list.Key].closestPointLine1, 0.1f);
                                DDrawSphereToAdmin(player, _config.drawTime, Color.red, violationData.suspiciousNoRecoilShots[list.Key].closestPointLine2, 0.1f);
                            }
                        }
                        else
                            DDrawArrowToAdmin(player, _config.drawTime, Color.green, violationData.suspiciousNoRecoilShots[list.Key].projectile2Position, (violationData.suspiciousNoRecoilShots[list.Key].projectile2Position + violationData.suspiciousNoRecoilShots[list.Key].projectile2Velocity.normalized * 450f), 0.2f);
                    }
                }
            }
        }

        private void DrawAIMViolationsData(BasePlayer player, AIMViolationData violationData, bool isTeleport)
        {
            if (player != null)
            {
                if (isTeleport)
                {
                    Vector3 startPos = violationData.startProjectilePosition - player.eyes.offset;
                    Vector3 tempPos = player.eyes.HeadForward();
                    Vector3 teleportPos = new Vector3(startPos.x - tempPos.x, startPos.y + 0.1f, startPos.z - tempPos.z);
                    player.Teleport(teleportPos);
                }

                player.ConsoleMessage("<color=green>Arkan:</color>\n" + Lang("Attacker", player.UserIDString) + ": " + violationData.hitInfoInitiatorPlayerName + "/" + violationData.hitInfoInitiatorPlayerUserID + "\n" + Lang("AIMViolationNum", player.UserIDString) + violationData.violationID + "\n" + Lang("Weapon", player.UserIDString) + ": " + violationData.weaponShortName + "\n" + Lang("Ammo", player.UserIDString) + ": " + violationData.ammoShortName + "\n" + Lang("Distance", player.UserIDString) + ": " + violationData.hitInfoProjectileDistance);
				player.ConsoleMessage(Lang("Target", player.UserIDString) + ": " + (violationData.hitInfoHitEntityPlayerName ?? violationData.hitInfoHitEntityPlayerUserID) + "\n" + Lang("HitPart", player.UserIDString) + ": " + violationData.hitInfoBoneName);
				player.ConsoleMessage(Lang("DateTime", player.UserIDString) + ": " + violationData.firedTime);
				
				player.ConsoleMessage(Lang("AttachmentsCount", player.UserIDString) + " = " + violationData.attachments.Count);

                if (violationData.attachments.Count > 0)
                    for (int ii = 0; ii < violationData.attachments.Count; ii++)
                        player.ConsoleMessage(Lang("Attachment", player.UserIDString) + " - " + violationData.attachments[ii]);
				
				if (violationData.isAttackerMount && violationData.attackerMountParentName != null)
					player.ConsoleMessage(Lang("MountedOn", player.UserIDString, violationData.attackerMountParentName) + "\n");	
                
				player.ConsoleMessage(Lang("RicochetsCount", player.UserIDString) + " = " + (violationData.hitsData.Count - 1) + "\n");
                player.ConsoleMessage($"isEqualFiredProjectileData = {violationData.isEqualFiredProjectileData}\n");
                player.ConsoleMessage($"isPlayerPositionToProjectileStartPositionDistanceViolation = {violationData.isPlayerPositionToProjectileStartPositionDistanceViolation}\n");
                
				if (violationData.isPlayerPositionToProjectileStartPositionDistanceViolation)
                    player.ConsoleMessage(Lang("LogText6", player.UserIDString, violationData.distanceDifferenceViolation));

                for (int j = 0; j < violationData.hitsData.Count; j++)
                {
                    player.ConsoleMessage($".\n" + Lang("LogText7", player.UserIDString, j + 1));
                    player.ConsoleMessage($"isHitPointNearProjectileTrajectoryLastSegmentEndPoint = {violationData.hitsData[j].isHitPointNearProjectileTrajectoryLastSegmentEndPoint}");
                    
					if (!violationData.hitsData[j].isHitPointNearProjectileTrajectoryLastSegmentEndPoint && violationData.hitsData[j].side > 0)
                        if (violationData.hitsData[j].side == 1)
                            player.ConsoleMessage("     " + Lang("AIMText4", player.UserIDString, violationData.hitsData[j].distanceFromHitPointToProjectilePlane, Lang("AIMText2", player.UserIDString), "StartPoint", Vector3.Distance(violationData.hitsData[j].hitPositionWorld, violationData.hitsData[j].hitPointStart)));
                        else
                            player.ConsoleMessage("     " + Lang("AIMText4", player.UserIDString, violationData.hitsData[j].distanceFromHitPointToProjectilePlane, Lang("AIMText3", player.UserIDString), "EndPoint", Vector3.Distance(violationData.hitsData[j].hitPositionWorld, violationData.hitsData[j].hitPointEnd)));

                    player.ConsoleMessage($"isHitPointOnProjectileTrajectory = {violationData.hitsData[j].isHitPointOnProjectileTrajectory}");
                    player.ConsoleMessage($"isProjectileStartPointAtEndReverseProjectileTrajectory = {violationData.hitsData[j].isProjectileStartPointAtEndReverseProjectileTrajectory}");
                    
					if (!violationData.hitsData[j].isProjectileStartPointAtEndReverseProjectileTrajectory)
                        player.ConsoleMessage("     " + Lang("AIMText6", player.UserIDString, violationData.hitsData[j].lastSegmentPointStart, violationData.hitsData[j].lastSegmentPointEnd, violationData.hitsData[j].startProjectilePosition, violationData.hitsData[j].startProjectilePosition + violationData.hitsData[j].startProjectileVelocity));

                    player.ConsoleMessage($"isHitPointNearProjectilePlane = {violationData.hitsData[j].isHitPointNearProjectilePlane}");
                    
					if (!violationData.hitsData[j].isHitPointNearProjectilePlane)
                        player.ConsoleMessage("     " + Lang("AIMText7", player.UserIDString, violationData.hitsData[j].distanceFromHitPointToProjectilePlane));

                    player.ConsoleMessage($"isLastSegmentOnProjectileTrajectoryPlane = {violationData.hitsData[j].isLastSegmentOnProjectileTrajectoryPlane}");
                    
					if (!violationData.hitsData[j].isLastSegmentOnProjectileTrajectoryPlane)
                        player.ConsoleMessage("     " + Lang("AIMText8", player.UserIDString, violationData.hitsData[j].lastSegmentPointStart, violationData.hitsData[j].startProjectilePosition, violationData.hitsData[j].startProjectilePosition + violationData.hitsData[j].startProjectileVelocity));

                    player.ConsoleMessage(Lang("LogText8", player.UserIDString, j + 1));

                    DDrawSphereToAdmin(player, _config.drawTime, Color.red, violationData.hitsData[j].startProjectilePosition, 0.05f);
                    DDrawSphereToAdmin(player, _config.drawTime, Color.green, violationData.hitsData[j].lastSegmentPointStart, 0.04f);
                }

                DDrawTextToAdmin(player, _config.drawTime, Color.cyan, violationData.hitInfoHitPositionWorld + new Vector3(0f, 1f, 0f), Lang("DrawAIMVD3", player.UserIDString, violationData.hitInfoHitEntityPlayerName ?? violationData.hitInfoHitEntityPlayerUserID, violationData.hitInfoBoneName, violationData.damage));
                DDrawTextToAdmin(player, _config.drawTime, Color.cyan, violationData.hitsData[0].startProjectilePosition + new Vector3(0f, 1f, 0f), Lang("DrawAIMVD4", player.UserIDString, violationData.hitInfoInitiatorPlayerName ?? violationData.hitInfoInitiatorPlayerUserID, violationData.projectileID, violationData.ammoShortName, violationData.weaponShortName, violationData.hitInfoProjectileDistance));

                DrawProjectileTrajectory(player, _config.drawTime, violationData, Color.blue);
                DrawReverseProjectileTrajectory(player, _config.drawTime, violationData, Color.green);
				DDrawSphereToAdmin(player, _config.drawTime, Color.white, violationData.hitInfoPointStart, 0.04f);
				DDrawSphereToAdmin(player, _config.drawTime, Color.white, violationData.hitInfoPointEnd, 0.04f);
				
                if (violationData.isPlayerPositionToProjectileStartPositionDistanceViolation)
                {
                    DDrawSphereToAdmin(player, _config.drawTime, Color.red, violationData.playerEyesPosition, 0.05f);
                    DDrawTextToAdmin(player, _config.drawTime, Color.cyan, violationData.playerEyesPosition + Vector3.up, Lang("DrawAIMVD5", player.UserIDString, violationData.hitInfoInitiatorPlayerName ?? violationData.hitInfoInitiatorPlayerUserID, violationData.violationID, violationData.playerEyesPosition, violationData.startProjectilePosition, Vector3.Distance(violationData.playerEyesPosition, violationData.startProjectilePosition)));
					DDrawArrowToAdmin(player, _config.drawTime, Color.red, violationData.playerEyesPosition, violationData.playerEyesPosition + violationData.playerEyesLookAt.normalized, 0.05f);
                }
            }
        }

        private void ShowNoRecoilViolations(BasePlayer player, string[] args)
        {
            if (player == null)
                return;

            if (!player.IsAdmin || !permission.UserHasPermission(player.UserIDString, permName) || !AdminsConfig.ContainsKey(player))
                return;

            string s = null;
			string adminMsg;
            ulong id = 0;
			ulong playerID = 0;

            if (args.Length == 2)
                if (args[1] == "0")
                {
                    player.ChatMessage(Lang("ShowD1", player.UserIDString));
                    AdminsConfig[player].violationsLog = new ViolationsLog();
                }
                else
                    s = args[1];

            string user = args[0];

            if (user.Contains("765"))
                ulong.TryParse(args[0], out id);

            foreach (KeyValuePair<ulong, PlayerViolationsData> list in PlayersViolations.Players)
                if (PlayersViolations.Players[list.Key].PlayerID == id || PlayersViolations.Players[list.Key].PlayerName.Contains(user, CompareOptions.IgnoreCase))
                    playerID = PlayersViolations.Players[list.Key].PlayerID;

            if (playerID == 0)
                player.ChatMessage(Lang("ShowD2", player.UserIDString));
            else
            {
                if (PlayersViolations.Players[playerID].noRecoilViolations.Count == 0)
                    player.ChatMessage(Lang("ShowNRD1", player.UserIDString, PlayersViolations.Players[playerID].PlayerName));
                else
                {
                    adminMsg = Lang("Player", player.UserIDString, PlayersViolations.Players[playerID].PlayerName);

                    if ((long)AdminsConfig[player].violationsLog.steamID != (long)PlayersViolations.Players[playerID].PlayerID)
                    {
                        AdminsConfig[player].violationsLog.NoRecoilViolation = 1;
                        AdminsConfig[player].violationsLog.steamID = PlayersViolations.Players[playerID].PlayerID;

                        adminMsg += Lang("ShowNRD2", player.UserIDString, PlayersViolations.Players[playerID].noRecoilViolations.Count);
                    }
                    else
                        if (s == null)
                            if (PlayersViolations.Players[playerID].noRecoilViolations.Count >= AdminsConfig[player].violationsLog.NoRecoilViolation + 1)
                                AdminsConfig[player].violationsLog.NoRecoilViolation++;
                            else
                            {
                                player.ChatMessage(Lang("NoMoreViolations", player.UserIDString, PlayersViolations.Players[playerID].PlayerName));
                                AdminsConfig[player].violationsLog = new ViolationsLog();
                                return;
                            }

                    int result;
                    int.TryParse(s, out result);

                    if (result == 0)
                        result = AdminsConfig[player].violationsLog.NoRecoilViolation;

                    adminMsg += Lang("ShowNRD3", player.UserIDString, result);
                    player.ChatMessage(adminMsg + "\n");

                    int i = 1;
                    foreach (KeyValuePair<string, NoRecoilViolationData> list in PlayersViolations.Players[playerID].noRecoilViolations)
                    {
                        if (i == result)
                        {
                            DrawNoRecoilViolationsData(player, PlayersViolations.Players[playerID].PlayerName, PlayersViolations.Players[playerID].noRecoilViolations[list.Key], true);

                            NoRecoilViolationData violationData = PlayersViolations.Players[playerID].noRecoilViolations[list.Key];

							player.ConsoleMessage("<color=green>Arkan:</color>\n" + Lang("PlayerTxt", player.UserIDString) + " " + PlayersViolations.Players[playerID].PlayerName + "/" + PlayersViolations.Players[playerID].PlayerID +"\n" + Lang("NRViolationNum", player.UserIDString) + result + "\n" + Lang("ShotsCount", player.UserIDString) + " " + violationData.ShotsCnt + "\n" + Lang("Probability", player.UserIDString) + " " + violationData.violationProbability + "%");
							if (violationData.suspiciousNoRecoilShots.ContainsKey(1))
								player.ConsoleMessage(Lang("DateTime", player.UserIDString) + ": " + violationData.suspiciousNoRecoilShots[1].timeStamp);
                            player.ConsoleMessage(Lang("AttachmentsCount", player.UserIDString) + " = " + violationData.attachments.Count);

                            if (violationData.attachments.Count > 0)
                                for (int ii = 0; ii < violationData.attachments.Count; ii++)
                                    player.ConsoleMessage(Lang("Attachment", player.UserIDString) + " - " + violationData.attachments[ii]);

                            player.ConsoleMessage(Lang("Weapon", player.UserIDString) + " - " + violationData.weaponShortName);
                            player.ConsoleMessage(Lang("Ammo", player.UserIDString) + " - " + violationData.ammoShortName);
							player.ConsoleMessage(Lang("Probability", player.UserIDString) + " - " + violationData.violationProbability + "%");

                            int j = 1;
							
                            foreach (KeyValuePair<int, SuspiciousProjectileData> suspiciusProjectile in violationData.suspiciousNoRecoilShots.ToArray())
                            {
                                SuspiciousProjectileData sp = violationData.suspiciousNoRecoilShots[suspiciusProjectile.Key];
                                if (sp.isNoRecoil)
                                {
                                    if (sp.isShootedInMotion)
										player.ConsoleMessage(Lang("ProjectileID", player.UserIDString, sp.projectile2ID) + " | " + Lang("ShootingOnMove", player.UserIDString) +  " | " + Lang("ClosestPoint", player.UserIDString, sp.closestPointLine1, sp.closestPointLine2, sp.prevIntersectionPoint) + " | " + Lang("FireTimeInterval", player.UserIDString, sp.timeInterval));
									else
										player.ConsoleMessage(Lang("ProjectileID", player.UserIDString, sp.projectile2ID) + " | " + Lang("StandingShooting", player.UserIDString) + " | " + Lang("RecoilAngle", player.UserIDString, sp.recoilAngle) + " | " + Lang("FireTimeInterval", player.UserIDString, sp.timeInterval));
                                }
                                j++;
                            }
                            break;
                        }
                        i++;
                    }
                }
            }
        }

        private void ShowAIMViolations(BasePlayer player, string[] args)
        {
            if (player == null)
                return;

            if (!player.IsAdmin || !permission.UserHasPermission(player.UserIDString, permName) || !AdminsConfig.ContainsKey(player))
                return;

            string s = null;
			string adminMsg;
            ulong id = 0;
			ulong playerID = 0;

            if (args.Length == 2)
            {
                if (args[1] == "0")
                {
                    player.ChatMessage(Lang("ShowD1", player.UserIDString));
                    AdminsConfig[player].violationsLog = new ViolationsLog();
                }
                else
                    s = args[1];
            }

            string user = args[0];

            if (user.Contains("765"))
                ulong.TryParse(args[0], out id);

            foreach (KeyValuePair<ulong, PlayerViolationsData> list in PlayersViolations.Players)
                if (PlayersViolations.Players[list.Key].PlayerID == id || PlayersViolations.Players[list.Key].PlayerName.Contains(user, CompareOptions.IgnoreCase))
                    playerID = PlayersViolations.Players[list.Key].PlayerID;

            if (playerID == 0)
                player.ChatMessage(Lang("ShowD2", player.UserIDString));
            else
                if (PlayersViolations.Players[playerID].AIMViolations.Count == 0)
					player.ChatMessage(Lang("ShowAIMD1", player.UserIDString, PlayersViolations.Players[playerID].PlayerName));
            else
            {
                adminMsg = Lang("Player", player.UserIDString, PlayersViolations.Players[playerID].PlayerName);

                if ((long)AdminsConfig[player].violationsLog.steamID != (long)PlayersViolations.Players[playerID].PlayerID)
                {
                    AdminsConfig[player].violationsLog.AIMViolation = 1;
                    AdminsConfig[player].violationsLog.steamID = PlayersViolations.Players[playerID].PlayerID;
                    adminMsg += Lang("ShowAIMD2", player.UserIDString, PlayersViolations.Players[playerID].AIMViolations.Count);
                }
                else if (s == null)
                    if (PlayersViolations.Players[playerID].AIMViolations.Count >= AdminsConfig[player].violationsLog.AIMViolation + 1)
                        AdminsConfig[player].violationsLog.AIMViolation++;
                    else
                    {
                        player.ChatMessage(Lang("ShowD3", player.UserIDString, PlayersViolations.Players[playerID].PlayerName));
                        AdminsConfig[player].violationsLog = new ViolationsLog();
                        return;
                    }

                int result;
                int.TryParse(s, out result);

                if (result == 0)
                    result = AdminsConfig[player].violationsLog.AIMViolation;

                adminMsg += Lang("ShowAIMD3", player.UserIDString, result);
                player.ChatMessage(adminMsg);

                int i = 1;
                
				foreach (KeyValuePair<string, AIMViolationData> list in PlayersViolations.Players[playerID].AIMViolations)
                {
                    if (i == result)
                    {
                        DrawAIMViolationsData(player, PlayersViolations.Players[playerID].AIMViolations[list.Key], true);
                        break;
                    }
                    i++;
                }
            }
        }

        private void ShowAIMViolationsRecalc(BasePlayer player, string[] args) //for development purposes only
        {
            if (player == null)
                return;

            if (!player.IsAdmin || !permission.UserHasPermission(player.UserIDString, permName) || !AdminsConfig.ContainsKey(player))
                return;

            string s = null;
			string adminMsg;
            ulong id = 0;
			ulong playerID = 0;

            if (args.Length == 2)
                if (args[1] == "0")
                {
                    player.ChatMessage(Lang("ShowD1", player.UserIDString));
                    AdminsConfig[player].violationsLog = new ViolationsLog();
                }
                else
                    s = args[1];

            string user = args[0];

            if (user.Contains("765"))
                ulong.TryParse(args[0], out id);

            foreach (KeyValuePair<ulong, PlayerViolationsData> list in PlayersViolations.Players)
                if (PlayersViolations.Players[list.Key].PlayerID == id || PlayersViolations.Players[list.Key].PlayerName.Contains(user, CompareOptions.IgnoreCase))
                    playerID = PlayersViolations.Players[list.Key].PlayerID;

            if (playerID == 0)
                player.ChatMessage(Lang("ShowD2", player.UserIDString));
            else
                if (PlayersViolations.Players[playerID].AIMViolations.Count == 0)
					player.ChatMessage(Lang("ShowAIMD1", player.UserIDString, PlayersViolations.Players[playerID].PlayerName));
            else
            {
                adminMsg = Lang("Player", player.UserIDString, PlayersViolations.Players[playerID].PlayerName);

                if ((long)AdminsConfig[player].violationsLog.steamID != (long)PlayersViolations.Players[playerID].PlayerID)
                {
                    AdminsConfig[player].violationsLog.AIMViolation = 1;
                    AdminsConfig[player].violationsLog.steamID = PlayersViolations.Players[playerID].PlayerID;
                    adminMsg += Lang("ShowAIMD2", player.UserIDString, PlayersViolations.Players[playerID].AIMViolations.Count);
                }
                else
                    if (s == null)
                        if (PlayersViolations.Players[playerID].AIMViolations.Count >= AdminsConfig[player].violationsLog.AIMViolation + 1)
                            AdminsConfig[player].violationsLog.AIMViolation++;
                        else
                        {
                            player.ChatMessage(Lang("ShowD3", player.UserIDString, PlayersViolations.Players[playerID].PlayerName));
                            AdminsConfig[player].violationsLog = new ViolationsLog();
                            return;
                        }

                int result;
                int.TryParse(s, out result);

                if (result == 0)
                    result = AdminsConfig[player].violationsLog.AIMViolation;

                adminMsg += Lang("ShowAIMD3", player.UserIDString, result);
                player.ChatMessage(adminMsg);

                int i = 1;
                
				foreach (KeyValuePair<string, AIMViolationData> list in PlayersViolations.Players[playerID].AIMViolations)
                {
                    if (i == result)
                    {
                        AIMViolationData aimvd = new AIMViolationData();
                        aimvd = PlayersViolations.Players[playerID].AIMViolations[list.Key];
                        Vector3 projectilePosition = PlayersViolations.Players[playerID].AIMViolations[list.Key].startProjectilePosition;
                        Vector3 projectileVelocity = PlayersViolations.Players[playerID].AIMViolations[list.Key].startProjectileVelocity;
                        Vector3 PointStart = PlayersViolations.Players[playerID].AIMViolations[list.Key].hitInfoPointStart;
                        Vector3 PointEnd = PlayersViolations.Players[playerID].AIMViolations[list.Key].hitInfoPointEnd;
                        Vector3 HitPositionWorld = PlayersViolations.Players[playerID].AIMViolations[list.Key].hitInfoHitPositionWorld;

                        float gravityModifier = PlayersViolations.Players[playerID].AIMViolations[list.Key].hitInfoProjectilePrefabGravityModifier;
                        float drag = PlayersViolations.Players[playerID].AIMViolations[list.Key].hitInfoProjectilePrefabDrag;
                        string putsmsg = "";
                        bool AIMViolation = false;
						List<TrajectorySegment> trajectorySegments = new List<TrajectorySegment>();
						List<TrajectorySegment> trajectorySegmentsRev = new List<TrajectorySegment>();
						
						aimvd.hitsData[0].isHitPointNearProjectileTrajectoryLastSegmentEndPoint = true;
						aimvd.hitsData[0].isHitPointOnProjectileTrajectory = true;
						aimvd.hitsData[0].isProjectileStartPointAtEndReverseProjectileTrajectory = true;
						aimvd.hitsData[0].isHitPointNearProjectilePlane = true;
						aimvd.hitsData[0].isLastSegmentOnProjectileTrajectoryPlane = true;

						if (aimvd.hitsData.Count == 2)
						{
							aimvd.hitsData[0].hitPositionWorld = aimvd.hitsData[1].hitPositionWorld;
							aimvd.hitsData[0].hitPointStart = aimvd.hitsData[1].hitPointStart;
							aimvd.hitsData[0].hitPointEnd = aimvd.hitsData[1].hitPointEnd;
							aimvd.hitsData.RemoveAt(1);
						}
						
                        AIMViolation = ProcessProjectileTrajectory(out aimvd, aimvd, out trajectorySegments, out trajectorySegmentsRev, gravityModifier, drag);

						Puts($"Player {PlayersViolations.Players[playerID].PlayerName} physicsSteps={aimvd.physicsSteps}");

						if (AIMViolation && aimvd.hitsData.Count == 1 && trajectorySegments.Count > 0 && trajectorySegmentsRev.Count > 	0)
						{
							float lengthLastSegmentProjectileTrajectory = Vector3.Distance(aimvd.hitsData[0].lastSegmentPointEnd, aimvd.hitsData[0].lastSegmentPointStart);
							float lengthLastSegmentReverseProjectileTrajectory = Vector3.Distance(aimvd.hitsData[0].hitPointEnd, aimvd.hitsData[0].hitPointStart);
							
							Vector3 pointStartProjectedOnLastSegment = ProjectPointOnLine(aimvd.hitsData[0].lastSegmentPointStart, (aimvd.hitsData[0].lastSegmentPointEnd - aimvd.hitsData[0].lastSegmentPointStart).normalized, aimvd.hitsData[0].hitPointStart);
							Vector3 pointEndProjectedOnLastSegment = ProjectPointOnLine(aimvd.hitsData[0].lastSegmentPointStart, (aimvd.hitsData[0].lastSegmentPointEnd - aimvd.hitsData[0].lastSegmentPointStart).normalized, aimvd.hitsData[0].hitPointEnd);
	
							if (Mathf.Abs(Vector3.Distance(pointStartProjectedOnLastSegment, aimvd.hitsData[0].hitPointStart) - Vector3.Distance(pointEndProjectedOnLastSegment, aimvd.hitsData[0].hitPointEnd)) > 0.05f)
							{								
								HitData hitData1 = new HitData();
								HitData hitData2 = new HitData();
								if (IsRicochet(trajectorySegments, trajectorySegmentsRev, out hitData1, out hitData2, aimvd.physicsSteps))
								{
									hitData1.startProjectilePosition = aimvd.hitsData[0].startProjectilePosition;
									hitData1.startProjectileVelocity = aimvd.hitsData[0].startProjectileVelocity;
                        
									hitData2.hitPositionWorld = HitPositionWorld;
									hitData2.hitPointStart = PointStart;
									hitData2.hitPointEnd = PointEnd;	
														
									aimvd.hitsData.Clear();
								
									aimvd.hitsData.Add(hitData1);
									aimvd.hitsData.Add(hitData2);
                        
									putsmsg = "";
									AIMViolation = ProcessProjectileTrajectory(out aimvd, aimvd, out trajectorySegments, out trajectorySegmentsRev, gravityModifier, drag);
								}	
							}							
						}

                        if (Vector3.Distance(aimvd.playerEyesPosition, aimvd.startProjectilePosition) > _config.playerEyesPositionToProjectileInitialPositionDistanceForgiveness)
                        {
                        	AIMViolation = true;
                        	aimvd.isPlayerPositionToProjectileStartPositionDistanceViolation = true;
                        }

                    //  DrawProjectileTrajectory(player, _config.drawTime, aimvd, Color.blue);
                    //  DrawReverseProjectileTrajectory(player, _config.drawTime, aimvd, Color.green);

                        player.ConsoleMessage($"aimvd.calculatedTravelDistance = {aimvd.calculatedTravelDistance}");

                        player.ConsoleMessage($"\n{putsmsg}");
                        player.ConsoleMessage($"____end log____1");

                        DrawAIMViolationsData(player, aimvd, false);

                        DDrawSphereToAdmin(null, 60f, Color.red, HitPositionWorld, 0.02f);
					
                        break;
                    }
                    i++;
                }
            }
        }

        private void ShowInRockViolations(BasePlayer player, string[] args)
        {
            if (player == null)
                return;

            if (!player.IsAdmin || !permission.UserHasPermission(player.UserIDString, permName) || !AdminsConfig.ContainsKey(player))
                return;

            string s = null;
			string adminMsg;
            ulong id = 0;
			ulong playerID = 0;

            if (args.Length == 2)
                if (args[1] == "0")
                {
                    player.ChatMessage(Lang("ShowD1", player.UserIDString));
                    AdminsConfig[player].violationsLog = new ViolationsLog();
                }
                else
                    s = args[1];

            string user = args[0];

            if (user.Contains("765"))
                ulong.TryParse(args[0], out id);

            foreach (KeyValuePair<ulong, PlayerViolationsData> list in PlayersViolations.Players)
                if (PlayersViolations.Players[list.Key].PlayerID == id || PlayersViolations.Players[list.Key].PlayerName.Contains(user, CompareOptions.IgnoreCase))
                    playerID = PlayersViolations.Players[list.Key].PlayerID;

            if (playerID == 0)
                player.ChatMessage(Lang("ShowD2", player.UserIDString));
            else
            {
                if (PlayersViolations.Players[playerID].inRockViolations.Count == 0)
                    player.ChatMessage(Lang("ShowIRD1", player.UserIDString, PlayersViolations.Players[playerID].PlayerName));
                else
                {
                    adminMsg = Lang("Player", player.UserIDString, PlayersViolations.Players[playerID].PlayerName);

                    if ((long)AdminsConfig[player].violationsLog.steamID != (long)PlayersViolations.Players[playerID].PlayerID)
                    {
                        AdminsConfig[player].violationsLog.InRockViolation = 1;
                        AdminsConfig[player].violationsLog.steamID = PlayersViolations.Players[playerID].PlayerID;

                        adminMsg += Lang("ShowIRD2", player.UserIDString, PlayersViolations.Players[playerID].inRockViolations.Count);
                    }
                    else
                        if (s == null)
                            if (PlayersViolations.Players[playerID].inRockViolations.Count >= AdminsConfig[player].violationsLog.InRockViolation + 1)
                                AdminsConfig[player].violationsLog.InRockViolation++;
                            else
                            {
                                player.ChatMessage(Lang("NoMoreViolations", player.UserIDString, PlayersViolations.Players[playerID].PlayerName));
                                AdminsConfig[player].violationsLog = new ViolationsLog();
                                return;
                            }

                    int result;
                    int.TryParse(s, out result);

                    if (result == 0)
                        result = AdminsConfig[player].violationsLog.InRockViolation;

                    adminMsg += Lang("ShowIRD3", player.UserIDString, result);
                    player.ChatMessage(adminMsg + "\n");

                    int i = 1;
                    foreach (KeyValuePair<string, InRockViolationsData> list in PlayersViolations.Players[playerID].inRockViolations)
                    {
                        if (i == result)
                        {
							DrawInRockViolationsData(player, PlayersViolations.Players[playerID].PlayerName, $"{playerID}", i, PlayersViolations.Players[playerID].inRockViolations[list.Key], true);
                            player.ConsoleMessage("<color=green>Arkan:</color>\n" + Lang("Attacker", player.UserIDString) + ": " + PlayersViolations.Players[playerID].PlayerName + "/" + PlayersViolations.Players[playerID].PlayerID + "\n" + Lang("IRViolationNum", player.UserIDString) + result + "\n" + Lang("Weapon", player.UserIDString) + ": " + PlayersViolations.Players[playerID].inRockViolations[list.Key].inRockViolationsData[1].firedProjectile.weaponShortName + "\n" + Lang("Ammo", player.UserIDString) + ": " + PlayersViolations.Players[playerID].inRockViolations[list.Key].inRockViolationsData[1].firedProjectile.ammoShortName + "\n");

							for (int j = 1; j <= PlayersViolations.Players[playerID].inRockViolations[list.Key].inRockViolationsData.Count; j++)
							{
								player.ConsoleMessage(Lang("ProjectileID", player.UserIDString, j) + " | " + Lang("Target", player.UserIDString) + ": " + PlayersViolations.Players[playerID].inRockViolations[list.Key].inRockViolationsData[j].targetName + "/" + PlayersViolations.Players[playerID].inRockViolations[list.Key].inRockViolationsData[j].targetID + " | " + Lang("HitPart", player.UserIDString) + ": " + PlayersViolations.Players[playerID].inRockViolations[list.Key].inRockViolationsData[j].targetBodyPart + " | " + Lang("Damage", player.UserIDString) + ": " + PlayersViolations.Players[playerID].inRockViolations[list.Key].inRockViolationsData[j].targetDamage);
							}
							
							break;
                        }
                        i++;
                    }
                }
            }
        }

        //Two non-parallel lines which may or may not touch each other have a point on each line which are closest
        //to each other. This function finds those two points. If the lines are not parallel, the function 
        //outputs true, otherwise false.
        private bool ClosestPointsOnTwoLines(out Vector3 closestPointLine1, out Vector3 closestPointLine2, Vector3 linePoint1, Vector3 lineVec1, Vector3 linePoint2, Vector3 lineVec2)
        {
            closestPointLine1 = Vector3.zero;
            closestPointLine2 = Vector3.zero;

            float a = Vector3.Dot(lineVec1, lineVec1);
            float b = Vector3.Dot(lineVec1, lineVec2);
            float e = Vector3.Dot(lineVec2, lineVec2);

            float d = a * e - b * b;

            //lines are not parallel
            if (d != 0.0f)
            {
                Vector3 r = linePoint1 - linePoint2;
                float c = Vector3.Dot(lineVec1, r);
                float f = Vector3.Dot(lineVec2, r);

                float s = (b * f - c * e) / d;
                float t = (a * f - c * b) / d;

                closestPointLine1 = linePoint1 + lineVec1 * s;
                closestPointLine2 = linePoint2 + lineVec2 * t;

                return true;
            }
            else
                return false;
        }

        //This function returns a point which is a projection from a point to a line.
        //The line is regarded infinite. If the line is finite, use ProjectPointOnLineSegment() instead.
        private Vector3 ProjectPointOnLine(Vector3 linePoint, Vector3 lineVec, Vector3 point)
        {
            //get vector from point on line to point in space
            Vector3 linePointToPoint = point - linePoint;

            float t = Vector3.Dot(linePointToPoint, lineVec);

            return linePoint + lineVec * t;
        }

        //This function returns a point which is a projection from a point to a line segment.
        //If the projected point lies outside of the line segment, the projected point will 
        //be clamped to the appropriate line edge.
        //If the line is infinite instead of a segment, use ProjectPointOnLine() instead.
        private Vector3 ProjectPointOnLineSegment(Vector3 linePoint1, Vector3 linePoint2, Vector3 point, out int side)
        {
            Vector3 vector = linePoint2 - linePoint1;

            Vector3 projectedPoint = ProjectPointOnLine(linePoint1, vector.normalized, point);

            side = PointOnWhichSideOfLineSegment(linePoint1, linePoint2, projectedPoint);

            //The projected point is on the line segment
            if (side == 0)
                return projectedPoint;

            if (side == 1)
                return linePoint1;

            if (side == 2)
                return linePoint2;

            //output is invalid
            return Vector3.zero;
        }

        //This function finds out on which side of a line segment the point is located.
        //The point is assumed to be on a line created by linePoint1 and linePoint2. If the point is not on
        //the line segment, project it on the line using ProjectPointOnLine() first.
        //Returns 0 if point is on the line segment.
        //Returns 1 if point is outside of the line segment and located on the side of linePoint1.
        //Returns 2 if point is outside of the line segment and located on the side of linePoint2.
        private int PointOnWhichSideOfLineSegment(Vector3 linePoint1, Vector3 linePoint2, Vector3 point)
        {
            Vector3 lineVec = linePoint2 - linePoint1;
            Vector3 pointVec = point - linePoint1;

            float dot = Vector3.Dot(pointVec, lineVec);

            //point is on side of linePoint2, compared to linePoint1
            if (dot > 0)
            {
                //point is on the line segment
                if (pointVec.magnitude <= lineVec.magnitude)
                    return 0;

                //point is not on the line segment and it is on the side of linePoint2
                else
                    return 2;
            }

            //Point is not on side of linePoint2, compared to linePoint1.
            //Point is not on the line segment and it is on the side of linePoint1.
            else
                return 1;
        }

		private bool IsPointInRock(Vector3 pointPosition, float distance, out int rocksUnderPoint)
		{
			rocksUnderPoint = 0;
			
			RaycastHit[] hits = Physics.RaycastAll(new Ray(pointPosition + Vector3.down * distance, Vector3.up), distance, world_defaultLayer);
			foreach (RaycastHit hit in hits)
            {
                MeshCollider collider = hit.collider.GetComponent<MeshCollider>();
                if (collider == null || !collider.sharedMesh.name.StartsWith("rock_"))
                    continue;
				
				RaycastHit hitInfo;
				if (!hit.collider.Raycast(new Ray(pointPosition, Vector3.down), out hitInfo, distance))
					return true;
				else
					rocksUnderPoint += 1;
            }

			return false;			
		}
		
        private void ProcessShots(BasePlayer player)
        {
            if (player != null)
				if (PlayersFiredProjectlesData.ContainsKey(player.userID))
                    if (UnityEngine.Time.realtimeSinceStartup - PlayersFiredProjectlesData[player.userID].lastFiredTime >= 2f && !PlayersFiredProjectlesData[player.userID].isChecked)
                    {
						int firedShotsDataCnt = 0;
						uint curWeaponUID = 0;
						string curAmmoName = "";
						double curFiredTime = 0;
						float timeIntervalBetweenShots;
						float maxTimeIntervalBetweenShots = 0f;
						float NRProbabilityModifier = 1f;
						bool isFirstShot = true;
						
                        Dictionary<int, FiredShotsData> firedShotsData = new Dictionary<int, FiredShotsData>();
                        FiredShotsData fsd;
                        firedShotsDataCnt++;
                        FiredProjectile curFiredProjectile;
        
                        foreach (KeyValuePair<int, FiredProjectile> list in PlayersFiredProjectlesData[player.userID].firedProjectiles.ToArray())
                        {
                            curFiredProjectile = PlayersFiredProjectlesData[player.userID].firedProjectiles[list.Key];
        
                            if (!curFiredProjectile.isChecked)
                            {
                                if (!_config.weaponsConfig[curFiredProjectile.weaponShortName].NRDetectEnabled)
                                {
                                    curFiredProjectile.isChecked = true;
                                    continue;
                                }
        
                                if (isFirstShot)
                                {
                                    curFiredProjectile.isChecked = true;
                                    PlayersFiredProjectlesData[player.userID].firedProjectiles[list.Key] = curFiredProjectile;
                                    firedShotsData.Add(firedShotsData.Count + 1, fsd = new FiredShotsData());
                                    firedShotsData[firedShotsData.Count].firedShots.Add(list.Key, curFiredProjectile);
                                    curWeaponUID = curFiredProjectile.weaponUID;
                                    curAmmoName = curFiredProjectile.ammoShortName;
                                    curFiredTime = curFiredProjectile.firedTime.Ticks;
                                    maxTimeIntervalBetweenShots = _config.weaponsConfig[curFiredProjectile.weaponShortName].weaponMaxTimeShotsInterval;
                                    firedShotsData[firedShotsData.Count].weaponShortName = curFiredProjectile.weaponShortName;
                                    firedShotsData[firedShotsData.Count].ammoShortName = curFiredProjectile.ammoShortName;
                                    firedShotsData[firedShotsData.Count].attachments = curFiredProjectile.attachments;
                                    isFirstShot = false;
                                    NRProbabilityModifier = curFiredProjectile.NRProbabilityModifier;
                                    continue;
                                }
        
                                timeIntervalBetweenShots = (float)(curFiredProjectile.firedTime.Ticks - curFiredTime) / 10000000f;
                                
								if (!(curFiredProjectile.weaponUID == curWeaponUID) || !(curFiredProjectile.ammoShortName == curAmmoName) || timeIntervalBetweenShots > maxTimeIntervalBetweenShots)
                                {
                                    firedShotsDataCnt++;
                                    firedShotsData.Add(firedShotsDataCnt, fsd = new FiredShotsData());
                                    curFiredProjectile.isChecked = true;
                                    PlayersFiredProjectlesData[player.userID].firedProjectiles[list.Key] = curFiredProjectile;
                                    firedShotsData[firedShotsData.Count].firedShots.Add(list.Key, curFiredProjectile);
                                    curWeaponUID = curFiredProjectile.weaponUID;
                                    curAmmoName = curFiredProjectile.ammoShortName;
                                    curFiredTime = curFiredProjectile.firedTime.Ticks;
                                    maxTimeIntervalBetweenShots = _config.weaponsConfig[curFiredProjectile.weaponShortName].weaponMaxTimeShotsInterval;
                                    firedShotsData[firedShotsData.Count].weaponShortName = curFiredProjectile.weaponShortName;
									if (firedShotsData[firedShotsData.Count].attachments.Count < curFiredProjectile.attachments.Count) 
										firedShotsData[firedShotsData.Count].attachments = curFiredProjectile.attachments;
                                    continue;
                                }
								
                                curFiredProjectile.isChecked = true;
                                PlayersFiredProjectlesData[player.userID].firedProjectiles[list.Key] = curFiredProjectile;
                                firedShotsData[firedShotsData.Count].firedShots.Add(list.Key, curFiredProjectile);
                                curFiredTime = curFiredProjectile.firedTime.Ticks;
                            }
                        }
        
                        PlayersFiredProjectlesData[player.userID].isChecked = true;
        
                        if (firedShotsData != null)
							foreach (KeyValuePair<int, FiredShotsData> list in firedShotsData.ToArray().Where(x => (firedShotsData[x.Key].firedShots.Count >= _config.weaponsConfig[firedShotsData[firedShotsData.Count].weaponShortName].NRMinShotsCountToCheck)))
								ProcessFiredShotsBlock(player, firedShotsData[list.Key], NRProbabilityModifier);
                    }
        }

        private void ProcessFiredShotsBlock(BasePlayer player, FiredShotsData fsd, float NRProbabilityModifier)
        {
            if (player != null && fsd != null)
            {
                int shotsCnt = 0;
                int violationProbabilityForgiveness = 0;
                int prevKey = 0;
                int curKey;
                int NoRecoilViolationsCnt = 0;
                int MoveCntShot = 0;
                int firstKey = 0;
                float angleBetweenShots = 0f;
				float angleWithVectorUpSum = 0f;
                float recoilScreenDistance = 0f;
                string _text = "";
				string shotDataTxt = "";
                bool isNoRecoil = false;
                bool isPrevNoRecoilViolation = false;
                bool isShootedInMotion = false;
                Vector2 scrPoint1 = new Vector2(500, 500);
                Vector2 scrPoint2 = new Vector2();
                Vector3 closestPointLine1 = new Vector3();
                Vector3 closestPointLine2 = new Vector3();
                Vector3 prevIntersectionPoint = new Vector3();
                Vector3 prevIPoint = new Vector3();
                Vector3 point1 = new Vector3();
                Vector3 point2 = new Vector3();
                Matrix4x4 viewMatrix = new Matrix4x4();
                Matrix4x4 perspectiveMatrix = new Matrix4x4();
                Matrix4x4 worldMatrix = Matrix4x4.identity;
                NoRecoilViolationData violationData = new NoRecoilViolationData();
                FiredProjectile prevFiredProjectile = new FiredProjectile();
                FiredProjectile curFiredProjectile = new FiredProjectile();
                SuspiciousProjectileData spd = new SuspiciousProjectileData();
				Dictionary<int, string> shotsList = new Dictionary<int, string>();

                foreach (KeyValuePair<int, FiredProjectile> list in fsd.firedShots.ToArray())
                {
                    curFiredProjectile = fsd.firedShots[list.Key];

                    if (curFiredProjectile.isMounted)
                    {
                        violationData.isMounted = true;
						Quaternion q = new Quaternion(curFiredProjectile.mountParentRotation.x, curFiredProjectile.mountParentRotation.y, curFiredProjectile.mountParentRotation.z, curFiredProjectile.mountParentRotation.w); 
                        viewMatrix = Matrix4x4.LookAt(curFiredProjectile.mountParentPosition, curFiredProjectile.mountParentPosition + (q * Vector3.forward), Vector3.up).inverse;
                        curFiredProjectile.projectileVelocity = viewMatrix.MultiplyPoint(curFiredProjectile.projectilePosition + curFiredProjectile.projectileVelocity);
                        curFiredProjectile.projectilePosition = viewMatrix.MultiplyPoint(curFiredProjectile.projectilePosition);
                        curFiredProjectile.projectileVelocity -= curFiredProjectile.projectilePosition;
                    }

                    curKey = list.Key;
                    isNoRecoil = false;
                    violationData.ShotsCnt++;
                    shotsCnt++;
					
					angleWithVectorUpSum += Vector3.Angle(Vector3.Normalize(curFiredProjectile.projectileVelocity), Vector3.up);

                    if (shotsCnt == 1)
                    {
                        firstKey = list.Key;
                        prevFiredProjectile = curFiredProjectile;
                        prevKey = curKey;
                        spd = new SuspiciousProjectileData();
                        violationData.suspiciousNoRecoilShots.Add(shotsCnt, new SuspiciousProjectileData());
                        spd.projectile1ID = prevKey;
                        spd.projectile2ID = curKey;
                        spd.projectile1Position = prevFiredProjectile.projectilePosition;
                        spd.projectile1Velocity = prevFiredProjectile.projectileVelocity;
                        spd.projectile2Position = curFiredProjectile.projectilePosition;
                        spd.projectile2Velocity = curFiredProjectile.projectileVelocity;
                        violationData.ammoShortName = curFiredProjectile.ammoShortName;
                        violationData.weaponShortName = curFiredProjectile.weaponShortName;
                        spd.timeStamp = curFiredProjectile.firedTime;
                        spd.isNoRecoil = false;
                        spd.isShootedInMotion = false;
                        violationData.suspiciousNoRecoilShots[shotsCnt] = spd;
                        continue;
                    }

                    float timeInterval = (float)(curFiredProjectile.firedTime.Ticks - prevFiredProjectile.firedTime.Ticks) / 10000000f;

                    if (Vector3.Distance(prevFiredProjectile.projectilePosition, curFiredProjectile.projectilePosition) <= _config.EPSILON)
                    {
                        MoveCntShot = 0;
                        isShootedInMotion = false;
                        angleBetweenShots = Vector3.Angle(Vector3.Normalize(curFiredProjectile.projectileVelocity), Vector3.Normalize(prevFiredProjectile.projectileVelocity));

						shotDataTxt = Lang("StandingShooting", null) + " | " + Lang("RecoilAngle", null, angleBetweenShots) + " | " + Lang("FireTimeInterval", null, timeInterval);

                        if (angleBetweenShots < _config.NRViolationAngle)
                        {
                            isNoRecoil = true;
                            isPrevNoRecoilViolation = true;
                        }
                    }
                    else
                    {
                        MoveCntShot++;
                        isShootedInMotion = true;
                        
						if (ClosestPointsOnTwoLines(out closestPointLine1, out closestPointLine2, prevFiredProjectile.projectilePosition, prevFiredProjectile.projectileVelocity, curFiredProjectile.projectilePosition, curFiredProjectile.projectileVelocity))
                        {
							shotDataTxt = Lang("ShootingOnMove", null) + "\n" + Lang("ClosestPoint", null, closestPointLine1, closestPointLine2, prevIntersectionPoint) + "\n" + Lang("FireTimeInterval", null, timeInterval);

                            viewMatrix = Matrix4x4.LookAt(curFiredProjectile.projectilePosition, curFiredProjectile.projectilePosition + curFiredProjectile.projectileVelocity, Vector3.up).inverse;

                            perspectiveMatrix = Matrix4x4.Perspective(70f, 1.0f, 0.01f, 1000f);

                            point1 = viewMatrix.MultiplyPoint(closestPointLine1);

                            if (point1.z > 1)
                            {
                                if (MoveCntShot == 1)
                                    point2 = viewMatrix.MultiplyPoint(closestPointLine1);
                                else
                                    point2 = viewMatrix.MultiplyPoint(prevIntersectionPoint);

                                point2 = perspectiveMatrix.MultiplyPoint(point2);

                                scrPoint2.x = ((point2.x + 1.0f) / 2.0f) * 1000;
                                scrPoint2.y = ((point2.y + 1.0f) / 2.0f) * 1000;

                                angleBetweenShots = Vector3.Angle(curFiredProjectile.projectileVelocity, closestPointLine1 - curFiredProjectile.projectilePosition);
                                recoilScreenDistance = Vector2.Distance(scrPoint1, scrPoint2);

								shotDataTxt += "\n" + Lang("RecoilAngle", null, angleBetweenShots);

                                if (angleBetweenShots < _config.NRViolationAngle && recoilScreenDistance < _config.NRViolationScreenDistance)
                                {
                                    isNoRecoil = true;
                                    isPrevNoRecoilViolation = true;
                                }

                                if (MoveCntShot > 0 && isNoRecoil == false)
                                    MoveCntShot = 0;
                            }

                            prevIPoint = prevIntersectionPoint;
                            prevIntersectionPoint = closestPointLine2;

							shotDataTxt += "\n" + Lang("ScreenCoords", null, scrPoint1, scrPoint2) + "\n" + Lang("DistanceBetweenTwoPoints", null, recoilScreenDistance) + "\n";
                        }
                    }

                    if (isPrevNoRecoilViolation && !isNoRecoil)
                    {
                        isPrevNoRecoilViolation = false;
                        violationProbabilityForgiveness++;
                    }

                    curFiredProjectile.isChecked = true;

                    if (isNoRecoil)
                    {
                        violationData.NRViolationsCnt++;
                        NoRecoilViolationsCnt++;
                        spd = new SuspiciousProjectileData();

                        spd.projectile1ID = prevKey;
                        spd.projectile2ID = curKey;
                        spd.projectile1Position = prevFiredProjectile.projectilePosition;
                        spd.projectile1Velocity = prevFiredProjectile.projectileVelocity;
                        spd.projectile2Position = curFiredProjectile.projectilePosition;
                        spd.projectile2Velocity = curFiredProjectile.projectileVelocity;
                        spd.closestPointLine1 = closestPointLine1;
                        spd.closestPointLine2 = closestPointLine2;
                        spd.recoilAngle = angleBetweenShots;
                        spd.recoilScreenDistance = recoilScreenDistance;
                        spd.isNoRecoil = true;
                        spd.isShootedInMotion = isShootedInMotion;
                        spd.timeInterval = timeInterval;
                        spd.timeStamp = curFiredProjectile.firedTime;
                        spd.prevIntersectionPoint = prevIPoint;

                        angleBetweenShots = 0f;
                        recoilScreenDistance = 0f;

                        violationData.suspiciousNoRecoilShots.Add(shotsCnt, new SuspiciousProjectileData());
                        violationData.suspiciousNoRecoilShots[shotsCnt] = spd;

                        if (!violationData.suspiciousNoRecoilShots[shotsCnt - 1].isNoRecoil)
                        {
                            NoRecoilViolationsCnt++;
                            spd = violationData.suspiciousNoRecoilShots[shotsCnt - 1];
                            spd.isNoRecoil = true;
                            violationData.suspiciousNoRecoilShots[shotsCnt - 1] = spd;
                        }
                    }
                    else
                    {
                        violationData.NRViolationsCnt++;
                        spd = new SuspiciousProjectileData();

                        spd.projectile1ID = prevKey;
                        spd.projectile2ID = curKey;
                        spd.projectile1Position = prevFiredProjectile.projectilePosition;
                        spd.projectile1Velocity = prevFiredProjectile.projectileVelocity;
                        spd.projectile2Position = curFiredProjectile.projectilePosition;
                        spd.projectile2Velocity = curFiredProjectile.projectileVelocity;
                        spd.isNoRecoil = false;
                        spd.timeInterval = timeInterval;
                        spd.timeStamp = curFiredProjectile.firedTime;

                        violationData.suspiciousNoRecoilShots.Add(shotsCnt, new SuspiciousProjectileData());
                        violationData.suspiciousNoRecoilShots[shotsCnt] = spd;
                    }

                    prevFiredProjectile = curFiredProjectile;
                    prevKey = curKey;
					shotsList.Add(list.Key, shotDataTxt);
                }

                float violationProbability = ((NoRecoilViolationsCnt * 100f) / (fsd.firedShots.Count + violationProbabilityForgiveness)) * NRProbabilityModifier;

                if (violationProbability > _config.weaponsConfig[fsd.weaponShortName].NRViolationProbability && (angleWithVectorUpSum/fsd.firedShots.Count) > 30f)
                {
                    _text = "\n" + Lang("AttachmentsCount", null) + " = " + fsd.attachments.Count;
                    
					if (fsd.attachments.Count > 0)
                        for (int j = 0; j < fsd.attachments.Count; j++)
                            _text += "\n" + Lang("Attachment", null) + " - " + fsd.attachments[j];

                    violationData.mountParentPosition = fsd.firedShots[firstKey].mountParentPosition;
                    violationData.mountParentRotation = fsd.firedShots[firstKey].mountParentRotation;
                    violationData.violationProbability = violationProbability;
                    violationData.attachments = fsd.attachments;

                    AddNoRecoilViolationToPlayer(player, violationData);
					
                    int NRViolationsCnt = PlayersViolations.Players[player.userID].noRecoilViolations.Count;
					
			        if (Interface.CallHook("API_ArkanOnNoRecoilViolation", player, NRViolationsCnt, JsonConvert.SerializeObject(violationData)) != null)
					{
						return;
					}
					
                    string conText = Lang("NRDetection", null) + "\n" + Lang("PlayerTxt", null) + " " + player.displayName + "/" + player.userID + "\n" + Lang("NRViolationNum", null) + PlayersViolations.Players[player.userID].noRecoilViolations.Count + "\n" + Lang("ShotsCount", null) + " " + violationData.suspiciousNoRecoilShots.Count + "\n" + Lang("Probability", null) + " " + violationProbability + "%" + _text + "\n" + Lang("Weapon", null) + " - " + violationData.weaponShortName + " \n" + Lang("Ammo", null) + " - " + violationData.ammoShortName;

					foreach (KeyValuePair<int, string> list in shotsList.ToArray())
						conText += "\n" + Lang("ProjectileID", null, list.Key) + " | " + shotsList[list.Key];

                    Puts(conText);
					 
					if (_config.DiscordNRReportEnabled)
						if (DiscordMessages == null)
							PrintWarning(Lang("DiscordWarning2", null));
						else
						{
							List<EmbedFieldList> fields = new List<EmbedFieldList>();
							
							string dmPlayer = $"[{player.displayName}\n{player.UserIDString}](https://steamcommunity.com/profiles/{player.UserIDString})";
							if (dmPlayer.Length == 0) dmPlayer = stringNullValueWarning;
							fields.Add(new EmbedFieldList()
							{
								name = Lang("PlayerTxt", null),
								inline = false,
								value = dmPlayer
							});
							
							string dmVNum = $"{PlayersViolations.Players[player.userID].noRecoilViolations.Count}";
							if (dmVNum.Length == 0) dmVNum = stringNullValueWarning;
							fields.Add(new EmbedFieldList()
							{
								name = Lang("NRViolationNum", null),
								inline = true,
								value = dmVNum
							});
							
							string dmProbability = $"{violationProbability}%";
							if (dmProbability.Length == 0) dmProbability = stringNullValueWarning;
							fields.Add(new EmbedFieldList()
							{
								name = Lang("Probability", null),
								inline = true,
								value = dmProbability
							});
							
							string dmShotsCount = $"{violationData.suspiciousNoRecoilShots.Count}";
							if (dmShotsCount.Length == 0) dmShotsCount = stringNullValueWarning;
							fields.Add(new EmbedFieldList()
							{
								name = Lang("ShotsCount", null),
								inline = true,
								value = dmShotsCount
							});
							
							string dmWeapon = violationData.weaponShortName;
							if (dmWeapon.Length == 0) dmWeapon = stringNullValueWarning;
							fields.Add(new EmbedFieldList()
							{
								name = Lang("Weapon", null),
								inline = true,
								value = dmWeapon
							});
							
							string dmAmmo = violationData.ammoShortName;
							if (dmAmmo.Length == 0) dmAmmo = stringNullValueWarning;
							fields.Add(new EmbedFieldList()
							{
								name = Lang("Ammo", null),
								inline = true,
								value = dmAmmo
							});
							
							if (fsd.attachments.Count == 0)
							{
								fields.Add(new EmbedFieldList()
								{
									name = Lang("AttachmentsCount", null) + " = " + fsd.attachments.Count,
									inline = true,
									value = Lang("NoAttachments", null)
								});
							}
							else
							{
								string dmAttachmentsList = "";
								for (int j = 0; j < fsd.attachments.Count; j++)
									dmAttachmentsList += fsd.attachments[j] + "\n";
								
								if (dmAttachmentsList.Length == 0) dmAttachmentsList = stringNullValueWarning;								
								fields.Add(new EmbedFieldList()
								{
									name = Lang("AttachmentsCount", null) + " = " + fsd.attachments.Count,
									inline = true,
									value = dmAttachmentsList
								});
							}
							
							string dmProjectileData = "";
							foreach (KeyValuePair<int, string> list in shotsList.ToArray())
							{
								dmProjectileData = shotsList[list.Key];
								if (dmProjectileData.Length == 0) dmProjectileData = stringNullValueWarning;
								fields.Add(new EmbedFieldList()
								{
									name = Lang("ProjectileID", null, list.Key),
									inline = false,
									value = dmProjectileData
								});
							}
							
							var fieldsObject = fields.Cast<object>().ToArray();
							
							string json = JsonConvert.SerializeObject(fieldsObject);

							DiscordMessages?.Call("API_SendFancyMessage", _config.DiscordNRWebhookURL, "Arkan: " + Lang("NRDetection", null), 39423, json);
						}

                    foreach (var _player in BasePlayer.activePlayerList.Where(x => x.IsAdmin && permission.UserHasPermission(x.UserIDString, permName)))
					{
						if (permission.UserHasPermission(_player.UserIDString, permNRReportChat))
							SendReply(_player, Lang("PlayerNRViolation", _player.UserIDString, player.displayName, player.userID, NRViolationsCnt, fsd.firedShots.Count, NoRecoilViolationsCnt, violationProbability));
						
						if (permission.UserHasPermission(_player.UserIDString, permNRReportConsole))
							_player.ConsoleMessage("<color=green>Arkan:</color> " + Lang("PlayerNRViolationCon", _player.UserIDString, player.displayName, player.userID, NRViolationsCnt, fsd.firedShots.Count, NoRecoilViolationsCnt, violationProbability));
						
                        if (permission.UserHasPermission(_player.UserIDString, permNRDrawViolation))
							DrawNoRecoilViolationsData(_player, player.displayName, violationData, false);
					}
                }
            }
        }
		
		private void ShootingInRockCheck(BasePlayer player, FiredProjectile fp, HitInfo info, string bodyPart, float physicsSteps)
		{			
			if (player != null && fp != null && info != null)
			{					
				if (_config.checkBlacklist)
				{
					if (!permission.UserHasPermission(player.UserIDString, permIRBlacklist))
						return;
				}
				else
					if (permission.UserHasPermission(player.UserIDString, permIRWhitelist))
						return;
				
				RaycastHit hit = new RaycastHit();
				int rocksUnderPoint = 0;
				bool isColliderTerrain = Physics.Raycast(fp.projectilePosition + Vector3.up * 250f, Vector3.down, out hit, 250f, terrainLayer);
				bool isPointInRock = IsPointInRock(fp.projectilePosition, _config.inRockCheckDistance, out rocksUnderPoint);

				if (!isPointInRock && !isColliderTerrain)
					return;	

				RaycastHit worldHit = new RaycastHit();
				bool isHit = false;
				float totalDistance = info.ProjectileDistance;
				float dist = 0;
				Vector3 pointStart = new Vector3();
				Vector3 pointEnd = new Vector3();
				
				float fixedDeltaTime = 1f / physicsSteps;
				Vector3 position = fp.projectilePosition;
				Vector3 vector1 = fp.projectileVelocity / physicsSteps;
				Vector3 vector2 = ((Physics.gravity * info.ProjectilePrefab.gravityModifier) / physicsSteps) * fixedDeltaTime;
				float single1 = info.ProjectilePrefab.drag * fixedDeltaTime;
				int segmentsCnt = (int)(physicsSteps * 8);
				
				string lastKey = "";
				int vsCnt = 0;
				int sCnt = 0;
				int layer = 0;

				if (isColliderTerrain && !isPointInRock)
					layer = world_terrainLayer;
				else
					layer = world_defaultLayer;
				
				for (int j = 0; j < segmentsCnt; j++)
                {						
					pointStart = position + vector1;
					pointEnd = position;					
					dist = vector1.magnitude;	
					
					if (totalDistance < dist)
					{
						dist = totalDistance;
						pointStart = pointEnd + ((pointStart - pointEnd).normalized * dist);
					}
					
					isHit = Physics.Raycast(pointStart, (pointEnd - pointStart).normalized, out hit, dist, layer);
					if (isHit)
					{
						if (!isColliderTerrain)
						{
							MeshCollider collider = hit.collider.GetComponent<MeshCollider>();
							if (collider is MeshCollider)
							if (collider == null || !collider.sharedMesh.name.StartsWith("rock_"))
								break;	
						}
						else
						{
							if(Physics.Raycast(fp.projectilePosition + Vector3.up * 0.1f, Vector3.down, out worldHit, 50f, world_defaultLayer))
							{
								MeshCollider worldCollider = worldHit.collider.GetComponent<MeshCollider>();
								if (worldCollider != null)
								{
									if(!worldCollider.sharedMesh.name.StartsWith("rock_") && !isPointInRock)
										break;	
									else
									{
										if (rocksUnderPoint > 0 && !isPointInRock)
											break;
									}
								}
							}
						}
						
						InRockViolationData irvd = new InRockViolationData();
						
						irvd.dateTime = DateTime.Now;
						irvd.physicsSteps = physicsSteps;
						irvd.targetHitDistance = info.ProjectileDistance;
						irvd.targetHitPosition = info.HitPositionWorld;
						irvd.firedProjectile = fp;
						irvd.rockHitPosition = hit.point;
						irvd.targetName = info.HitEntity.ToPlayer().displayName;
                        irvd.targetID = info.HitEntity.ToPlayer().userID.ToString();
						irvd.targetDamage = info.damageTypes.Total();
						irvd.targetBodyPart = bodyPart;
						irvd.projectileID = info.ProjectileID;
						irvd.drag = info.ProjectilePrefab.drag;
						irvd.gravityModifier = info.ProjectilePrefab.gravityModifier;						
												
						if (PlayersViolations.Players.ContainsKey(player.userID))
							if (PlayersViolations.Players[player.userID].inRockViolations.Count > 0)
							{
								lastKey = PlayersViolations.Players[player.userID].inRockViolations.Keys.Last();
								sCnt = PlayersViolations.Players[player.userID].inRockViolations[lastKey].inRockViolationsData.Count;
								vsCnt = PlayersViolations.Players[player.userID].inRockViolations.Count;
								
								if (PlayersViolations.Players[player.userID].inRockViolations[lastKey].inRockViolationsData[sCnt].firedProjectile.weaponShortName == fp.weaponShortName)
									if (PlayersViolations.Players[player.userID].inRockViolations[lastKey].inRockViolationsData[sCnt].firedProjectile.ammoShortName == fp.ammoShortName)
									{									
										float timeIntervalBetweenShots = (float)(irvd.dateTime.Ticks - PlayersViolations.Players[player.userID].inRockViolations[lastKey].inRockViolationsData[sCnt].dateTime.Ticks) / 10000000f;
							
										if (timeIntervalBetweenShots < 0.15625f)								
										{
											PlayersViolations.Players[player.userID].inRockViolations[lastKey].inRockViolationsData.Add(sCnt + 1, new InRockViolationData());
											PlayersViolations.Players[player.userID].inRockViolations[lastKey].inRockViolationsData[sCnt + 1] = irvd;
											
											timer.Once(0.5f, () => InRockNotification(player, lastKey, vsCnt, sCnt + 1));
											
											break;
										}
									}
							}
						
						InRockViolationsData violationData = new InRockViolationsData();
						violationData.dateTime = irvd.dateTime;
						int index = 1;
						violationData.inRockViolationsData.Add(index, new InRockViolationData());
						violationData.inRockViolationsData[index] = irvd;						
	
						AddInRockViolationToPlayer(player, violationData);
						
						lastKey = PlayersViolations.Players[player.userID].inRockViolations.Keys.Last();
						vsCnt = PlayersViolations.Players[player.userID].inRockViolations.Count;
						sCnt = PlayersViolations.Players[player.userID].inRockViolations[lastKey].inRockViolationsData.Count;
						
						timer.Once(0.5f, () => InRockNotification(player, lastKey, vsCnt, sCnt));
						
						break;
					}
					
					position += vector1;

					vector1 += vector2;
					vector1 -= (vector1 * single1);
					
					totalDistance -= dist;
					if (totalDistance < 0f)
						break;
				}
			}
		}	

		private void InRockNotification(BasePlayer player, string key, int vsCnt, int sCnt)
        {
			if (PlayersViolations.Players.ContainsKey(player.userID))
				if (PlayersViolations.Players[player.userID].inRockViolations.ContainsKey(key))
					if (PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData.Count == sCnt)
					{
						string pTxt = Lang("IRDetection", null) + "\n" + Lang("PlayerTxt", null) + " " + player.displayName + "/" + player.userID + "\n" + Lang("IRViolationNum", null) + vsCnt + " " + key + "\n" + Lang("Weapon", null) + " " + PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData[1].firedProjectile.weaponShortName + "\n" + Lang("Ammo", null) + " " + PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData[1].firedProjectile.ammoShortName + "\n" + Lang("ShotsCount", null) + " " + PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData.Count + "\n";
						for (int j = 1; j <= PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData.Count; j++)
						{
							pTxt += Lang("ProjectileID", null, PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData[j].projectileID) + " | " + Lang("Target", null) + ": " + PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData[j].targetName + "/" + PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData[j].targetID + " | " + Lang("HitPart", null) + ": " + PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData[j].targetBodyPart + " | " + Lang("Damage", null) + ": " + PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData[j].targetDamage + "\n";
						}

						Puts(pTxt);

						if (Interface.CallHook("API_ArkanOnInRockViolation", player, vsCnt, JsonConvert.SerializeObject(PlayersViolations.Players[player.userID].inRockViolations[key])) != null)
						{
							return;
						}
						
						foreach (var _player in BasePlayer.activePlayerList.Where(x => x.IsAdmin && permission.UserHasPermission(x.UserIDString, permName)))
						{
							if (permission.UserHasPermission(_player.UserIDString, permIRReportChat))
								SendReply(_player, Lang("PlayerIRViolation", _player.UserIDString, player.displayName, player.userID, vsCnt, PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData.Count));
							
							if (permission.UserHasPermission(_player.UserIDString, permIRReportConsole))
								_player.ConsoleMessage(Lang("PlayerIRViolationCon", _player.UserIDString, player.displayName, player.userID, vsCnt, PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData.Count));
							
                            if(permission.UserHasPermission(_player.UserIDString, permIRDrawViolation))
								DrawInRockViolationsData(_player, player.displayName, player.UserIDString, vsCnt, PlayersViolations.Players[player.userID].inRockViolations[key], false);
						}	

						if (_config.DiscordIRReportEnabled)
							if (DiscordMessages == null)
								PrintWarning(Lang("DiscordWarning2", null));
							else
							{
								List<EmbedFieldList> fields = new List<EmbedFieldList>();
								
								string dmPlayer = $"[{player.displayName}\n{player.UserIDString}](https://steamcommunity.com/profiles/{player.UserIDString})";
								if (dmPlayer.Length == 0) dmPlayer = stringNullValueWarning;
								fields.Add(new EmbedFieldList()
								{
									name = Lang("PlayerTxt", null),
									inline = true,
									value = dmPlayer
								});
								
								string dmVNum = $"{vsCnt}";
								if (dmVNum.Length == 0) dmVNum = stringNullValueWarning;
								fields.Add(new EmbedFieldList()
								{
									name = Lang("IRViolationNum", null),
									inline = true,
									value = dmVNum
								});

								string dmShotsCnt = $"{sCnt}";
								if (dmShotsCnt.Length == 0) dmShotsCnt = stringNullValueWarning;
								fields.Add(new EmbedFieldList()
								{
									name = Lang("ShotsCount", null),
									inline = true,
									value = dmShotsCnt
								});
								
								string dmWeapon = $"{PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData[1].firedProjectile.weaponShortName}";
								if (dmWeapon.Length == 0) dmWeapon = stringNullValueWarning;
								fields.Add(new EmbedFieldList()
								{
									name = Lang("Weapon", null),
									inline = true,
									value = dmWeapon
								});
								
								string dmAmmo = $"{PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData[1].firedProjectile.ammoShortName}";
								if (dmAmmo.Length == 0) dmAmmo = stringNullValueWarning;
								fields.Add(new EmbedFieldList()
								{
									name = Lang("Ammo", null),
									inline = true,
									value = dmAmmo
								});								
								
								string dmLogData = "";
								for (int k = 1; k <= PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData.Count; k++)
								{
									dmLogData = Lang("Target", null) + ": " + PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData[k].targetName + "/" + PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData[k].targetID + ", " + Lang("HitPart", null) + ": " + PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData[k].targetBodyPart + ", " + Lang("Damage", null) + ": " + PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData[k].targetDamage;
									if (dmLogData.Length == 0) dmLogData = stringNullValueWarning;
									fields.Add(new EmbedFieldList()
									{
										name = Lang("ProjectileID", null, k),
										inline = false,
										value = dmLogData
									});				
								}
																															
								var fieldsObject = fields.Cast<object>().ToArray();
								
								string json = JsonConvert.SerializeObject(fieldsObject);

								DiscordMessages?.Call("API_SendFancyMessage", _config.DiscordIRWebhookURL, "Arkan: " + Lang("IRDetection", null), 39423, json);
							}	
					}
		}			

        private bool ProcessProjectileTrajectory(out AIMViolationData aimvd, AIMViolationData aimvdIn, out List<TrajectorySegment> trajectorySegments, out List<TrajectorySegment> trajectorySegmentsRev, float gravityModifier, float drag)
        {
            Vector3 lsVecStart;
			Vector3 lsVecEnd;
			Vector3 lsVecStartRev;
			Vector3 lsVecEndRev;
            bool isLastSegmentOnProjectileTrajectoryPlane;
			bool isHitPointOnProjectileTrajectory;
			bool isProjectileStartPointAtEndReverseProjectileTrajectory;
			bool AIMViolation = false;
            float distanceFromHitPointToProjectilePlane;
			float projectileForgiveness = _config.projectileTrajectoryForgiveness * aimvdIn.forgivenessModifier;
			float _hitDistanceForgiveness = _config.hitDistanceForgiveness * aimvdIn.forgivenessModifier;
			float lengthLastSegmentProjectileTrajectory;
			float lengthLastSegmentReverseProjectileTrajectory;
            int side;
			trajectorySegments = new List<TrajectorySegment>();
			trajectorySegmentsRev = new List<TrajectorySegment>();
						
            aimvd = aimvdIn;
			aimvd.calculatedTravelDistance = 0f;
			
            for (int j = 0; j < aimvd.hitsData.Count; j++)
            {
                isLastSegmentOnProjectileTrajectoryPlane = IsLastSegmentCloseToProjectileTrajectoryPlane(aimvd.hitsData[j], projectileForgiveness, out distanceFromHitPointToProjectilePlane);
                isHitPointOnProjectileTrajectory = IsHitPointCloseToProjectileTrajectory(aimvd.hitsData[j], gravityModifier, drag, projectileForgiveness, out lsVecStart, out lsVecEnd, out aimvd.calculatedTravelDistance, out trajectorySegments, aimvd.physicsSteps);

				lengthLastSegmentProjectileTrajectory = Vector3.Distance(lsVecEnd, lsVecStart);
				lengthLastSegmentReverseProjectileTrajectory = Vector3.Distance(aimvd.hitsData[j].hitPointEnd, aimvd.hitsData[j].hitPointStart);

				if (Mathf.Abs(lengthLastSegmentProjectileTrajectory - lengthLastSegmentReverseProjectileTrajectory) > lengthLastSegmentProjectileTrajectory * 0.05f)
				{						
					Vector3 pointStartProjectedOnLastSegment = ProjectPointOnLine(lsVecStart, (lsVecEnd - lsVecStart).normalized, aimvd.hitsData[j].hitPointStart);
					Vector3 pointEndProjectedOnLastSegment = ProjectPointOnLine(lsVecStart, (lsVecEnd - lsVecStart).normalized, aimvd.hitsData[j].hitPointEnd);
					
					if (Vector3.Distance(aimvd.hitsData[j].hitPointStart, pointStartProjectedOnLastSegment) < _config.projectileTrajectoryForgiveness && Vector3.Distance(aimvd.hitsData[j].hitPointEnd, pointEndProjectedOnLastSegment) < _config.projectileTrajectoryForgiveness && (Mathf.Abs(Vector3.Distance(pointEndProjectedOnLastSegment, pointStartProjectedOnLastSegment)) - lengthLastSegmentReverseProjectileTrajectory) < lengthLastSegmentReverseProjectileTrajectory * 0.02f && (Mathf.Abs(Vector3.Distance(pointStartProjectedOnLastSegment, aimvd.hitsData[j].hitPointStart) - Vector3.Distance(pointEndProjectedOnLastSegment, aimvd.hitsData[j].hitPointEnd)) < 0.05f))
					{
						aimvd.physicsSteps = Mathf.Clamp((float)Math.Round((lengthLastSegmentProjectileTrajectory / lengthLastSegmentReverseProjectileTrajectory) * aimvd.physicsSteps, 1), 30f, 60f);
						isHitPointOnProjectileTrajectory = IsHitPointCloseToProjectileTrajectory(aimvd.hitsData[j], gravityModifier, drag, projectileForgiveness, out lsVecStart, out lsVecEnd, out aimvd.calculatedTravelDistance, out trajectorySegments, aimvd.physicsSteps);
					}
				}

                if (j != aimvd.hitsData.Count - 1)
                {
                    aimvd.hitsData[j].hitPointStart = lsVecStart;
                    aimvd.hitsData[j].hitPointEnd = lsVecEnd;
                }
				
                isProjectileStartPointAtEndReverseProjectileTrajectory = IsProjectileStartPointCloseToAtEndReverseProjectileTrajectory(aimvd.hitsData[j], gravityModifier, drag, projectileForgiveness, out lsVecStartRev, out lsVecEndRev, out trajectorySegmentsRev, aimvd.physicsSteps);

                aimvd.hitsData[j].lastSegmentPointStart = lsVecStart;
                aimvd.hitsData[j].lastSegmentPointEnd = lsVecEnd;
                aimvd.hitsData[j].reverseLastSegmentPointStart = lsVecStartRev;
                aimvd.hitsData[j].reverseLastSegmentPointEnd = lsVecEndRev;

                if (aimvd.hitsData.Count > 1 && j < aimvd.hitsData.Count - 1)
                {
                    float single3 = Vector3.Distance(lsVecStart, aimvd.hitsData[j].hitPositionWorld);
                    float single2 = aimvd.hitsData[j + 1].hitData.inVelocity.magnitude / aimvd.physicsSteps;
                    aimvd.hitsData[j + 1].delta = 1f - single3 * (1f / single2);
                    aimvd.hitsData[j + 1].travelDistance = aimvd.calculatedTravelDistance;
                }

                aimvd.hitsData[j].distanceFromHitPointToProjectilePlane = distanceFromHitPointToProjectilePlane;

                if (isLastSegmentOnProjectileTrajectoryPlane)
                {
                    if (distanceFromHitPointToProjectilePlane < _hitDistanceForgiveness)
                    {
						aimvd.hitsData[j].pointProjectedOnLastSegmentLine = ProjectPointOnLine(lsVecStart, (lsVecEnd - lsVecStart).normalized, aimvd.hitsData[j].hitPositionWorld);
						side = PointOnWhichSideOfLineSegment(lsVecStart, lsVecEnd, aimvd.hitsData[j].pointProjectedOnLastSegmentLine);
	
                        aimvd.hitsData[j].side = side;

                        if (side > 0)
                        {
							if (side == 1)
                            {
								if (Vector3.Distance(aimvd.hitsData[j].hitPositionWorld, lsVecStart) > (_config.projectileTrajectoryForgiveness))	
                                {
                                    AIMViolation = true;
                                    aimvd.hitsData[j].isHitPointNearProjectileTrajectoryLastSegmentEndPoint = false;
                                }
                            }
                            else
                            {
								if (Vector3.Distance(aimvd.hitsData[j].hitPositionWorld, lsVecEnd) > (_config.projectileTrajectoryForgiveness))
                                {
                                    AIMViolation = true;
                                    aimvd.hitsData[j].isHitPointNearProjectileTrajectoryLastSegmentEndPoint = false;
                                }
                            }
                        }

                        if (!isHitPointOnProjectileTrajectory)
                        {
                            AIMViolation = true;
                            aimvd.hitsData[j].isHitPointOnProjectileTrajectory = false;
                        }

                        if (!isProjectileStartPointAtEndReverseProjectileTrajectory)
                        {
                            AIMViolation = true;
                            aimvd.hitsData[j].isProjectileStartPointAtEndReverseProjectileTrajectory = false;
                        }
                    }
                    else
                    {
                        AIMViolation = true;
                        aimvd.hitsData[j].isHitPointNearProjectilePlane = false;
                    }
                }
                else
                {
                    AIMViolation = true;
                    aimvd.hitsData[j].isLastSegmentOnProjectileTrajectoryPlane = false;
                }
            }

            return AIMViolation;
        }		
		
        private void AddNoRecoilViolationToPlayer(BasePlayer player, NoRecoilViolationData noRecoilViolationData)
        {
            if (player != null)
            {
                if (!PlayersViolations.Players.ContainsKey(player.userID))
                {
                    PlayersViolations.Players.Add(player.userID, new PlayerViolationsData());
                    PlayersViolations.Players[player.userID].PlayerID = player.userID;
                    PlayersViolations.Players[player.userID].PlayerName = player.displayName;
                }

                string indexStr = serverTimeStamp + "_" + DateTime.Now.Ticks + "_" + noRecoilViolationData.suspiciousNoRecoilShots[1].projectile2ID + "." + noRecoilViolationData.suspiciousNoRecoilShots[noRecoilViolationData.suspiciousNoRecoilShots.Count].projectile2ID;
                PlayersViolations.Players[player.userID].noRecoilViolations.Add(indexStr, new NoRecoilViolationData());
                PlayersViolations.Players[player.userID].noRecoilViolations[indexStr] = noRecoilViolationData;
                PlayersViolations.lastChangeTime = DateTime.Now;
            }
        }

        private void AddAIMViolationToPlayer(BasePlayer player, AIMViolationData _AIMViolationData)
        {
            if (player != null)
            {
                if (!PlayersViolations.Players.ContainsKey(player.userID))
                {
                    PlayersViolations.Players.Add(player.userID, new PlayerViolationsData());
                    PlayersViolations.Players[player.userID].PlayerID = player.userID;
                    PlayersViolations.Players[player.userID].PlayerName = player.displayName;
                }

                string indexStr = DateTime.Now.Ticks + "_" + _AIMViolationData.projectileID;
                PlayersViolations.Players[player.userID].AIMViolations.Add(indexStr, new AIMViolationData());
                PlayersViolations.Players[player.userID].AIMViolations[indexStr] = _AIMViolationData;
                PlayersViolations.lastChangeTime = DateTime.Now;
            }
        }

        private void AddInRockViolationToPlayer(BasePlayer player, InRockViolationsData InRockViolationData)
        {
            if (player != null)
            {
                if (!PlayersViolations.Players.ContainsKey(player.userID))
                {
                    PlayersViolations.Players.Add(player.userID, new PlayerViolationsData());
                    PlayersViolations.Players[player.userID].PlayerID = player.userID;
                    PlayersViolations.Players[player.userID].PlayerName = player.displayName;
                }

                string indexStr = serverTimeStamp + "_" + DateTime.Now.Ticks;
                PlayersViolations.Players[player.userID].inRockViolations.Add(indexStr, new InRockViolationsData());
                PlayersViolations.Players[player.userID].inRockViolations[indexStr] = InRockViolationData;
                PlayersViolations.lastChangeTime = DateTime.Now;
            }
        }

        private bool IsNPC(BasePlayer player)
        {
            if (player == null) return false;
			
            if (player is NPCPlayer) return true;
			
            if (!(player.userID >= 76560000000000000L || player.userID <= 0L))
                return true;
			
            return false;
        }

		private void AdminLogInit(BasePlayer player)
        {		
 			if (player != null)
			{
				if (!player.IsAdmin || !permission.UserHasPermission(player.UserIDString, permName))
					return;

				if (!AdminsConfig.ContainsKey(player))
                {
                    AdminsConfig.Add(player, new AdminConfig());
                }
			}
		}

        private bool IsLastSegmentCloseToProjectileTrajectoryPlane(HitData hitData, float projectileForgiveness, out float distance)
        {
            Vector3 projectileStartPoint = hitData.startProjectilePosition;
            Vector3 projectileVelocity = hitData.startProjectileVelocity;
            Vector3 pointStart = hitData.hitPointStart;
            Vector3 pointEnd = hitData.hitPointEnd;
            Vector3 hitPoint = hitData.hitPositionWorld;

            Plane projectileTrajectoryPlane = new Plane(projectileStartPoint, projectileStartPoint + Vector3.up, projectileStartPoint + projectileVelocity);
            distance = Math.Abs(projectileTrajectoryPlane.GetDistanceToPoint(hitPoint));
			
            if (Math.Abs(projectileTrajectoryPlane.GetDistanceToPoint(pointStart)) <= projectileForgiveness && Math.Abs(projectileTrajectoryPlane.GetDistanceToPoint(pointEnd)) <= projectileForgiveness)
                return true;
			
            return false;
        }

        private bool IsHitPointCloseToProjectileTrajectory(HitData hitData, float gravityModifier, float drag, float projectileForgiveness, out Vector3 lsVecStart, out Vector3 lsVecEnd, out float travelDistance, out List<TrajectorySegment> trajectorySegments, float physicsSteps)
        {
            Vector3 hitPositionWorld = hitData.hitPositionWorld;
            Vector3 position = hitData.startProjectilePosition;
			float fixedDeltaTime = 1f / physicsSteps;
			Vector3 vector1 = hitData.startProjectileVelocity / physicsSteps;
			Vector3 vector2 = ((Physics.gravity * gravityModifier) / physicsSteps) * fixedDeltaTime;
            float single1 = drag * fixedDeltaTime;
            float dist = 0.0f;
            int side;
			int segmentsCnt = (int)(physicsSteps * 8);
            Vector3 pointProjectedOnLine;
            float distanceFromHitPointToLastSegment;
			trajectorySegments = new List<TrajectorySegment>();
			
            if (hitData.delta != 1f)
            {
                float single4 = vector1.magnitude * hitData.delta;
                Vector3 vector3 = hitData.hitData.outVelocity.normalized * single4;
                position += vector3;

				pointProjectedOnLine = ProjectPointOnLine(position - vector3, vector3.normalized, hitPositionWorld);
				side = PointOnWhichSideOfLineSegment(position - vector3, position, pointProjectedOnLine);

                distanceFromHitPointToLastSegment = Vector3.Distance(hitPositionWorld, pointProjectedOnLine);
                dist += vector3.magnitude;

                if (side == 0 && distanceFromHitPointToLastSegment <= projectileForgiveness)
                {
                    lsVecStart = position - vector3;
                    lsVecEnd = position;
                    travelDistance = hitData.travelDistance + Vector3.Distance(hitData.startProjectilePosition, hitPositionWorld);

					trajectorySegments.Add(new TrajectorySegment());
					trajectorySegments[trajectorySegments.Count -1].pointStart = position - vector3;
					trajectorySegments[trajectorySegments.Count -1].pointEnd = position;

                    return true;
                }
            }

            for (int j = 0; j < segmentsCnt; j++)
            {
				pointProjectedOnLine = ProjectPointOnLine(position, vector1.normalized, hitPositionWorld);
				side = PointOnWhichSideOfLineSegment(position, position + vector1, pointProjectedOnLine);
				
                distanceFromHitPointToLastSegment = Vector3.Distance(hitPositionWorld, pointProjectedOnLine);

				trajectorySegments.Add(new TrajectorySegment());
				trajectorySegments[trajectorySegments.Count -1].pointStart = position;
				trajectorySegments[trajectorySegments.Count -1].pointEnd = position + vector1;
				
				if (side == 0 && distanceFromHitPointToLastSegment <= projectileForgiveness)
                {
					
                    lsVecStart = position;
                    lsVecEnd = position + vector1;
                    travelDistance = hitData.travelDistance + dist + Vector3.Distance(position, hitPositionWorld);
                    return true;
                }

                dist += vector1.magnitude;
                position += vector1;
                vector1 += vector2;
                vector1 -= (vector1 * single1);
            }

            lsVecStart = position;
            lsVecEnd = position + vector1;
            travelDistance = hitData.travelDistance + dist + Vector3.Distance((position), hitPositionWorld);
			
			trajectorySegments.Add(new TrajectorySegment());
			trajectorySegments[trajectorySegments.Count -1].pointStart = position;
			trajectorySegments[trajectorySegments.Count -1].pointEnd = position + vector1;
			
            return false;
        }

        private bool IsProjectileStartPointCloseToAtEndReverseProjectileTrajectory(HitData hitData, float gravityModifier, float drag, float projectileForgiveness, out Vector3 lsVecStart, out Vector3 lsVecEnd, out List<TrajectorySegment> trajectorySegmentsRev, float physicsSteps)
        {
            Vector3 projectileStartPoint = hitData.startProjectilePosition;
            Vector3 pointStart = hitData.hitPointStart;
            Vector3 pointEnd = hitData.hitPointEnd;
            Vector3 position = pointEnd;
            Vector3 vector1 = pointStart - pointEnd;
			float fixedDeltaTime = 1f / physicsSteps;
            Vector3 vector2 = ((-Physics.gravity * gravityModifier) / physicsSteps) * fixedDeltaTime;
            float single1 = 1f / (1f - (drag * fixedDeltaTime));
            int side;
			int segmentsCnt = (int)(physicsSteps * 8);
            Vector3 pointProjectedOnLine;
            float distanceFromHitPointToLastSegment;
			trajectorySegmentsRev = new List<TrajectorySegment>();
			
            for (int j = 0; j < segmentsCnt; j++)
            {
                pointProjectedOnLine = ProjectPointOnLineSegment(position, position + vector1, projectileStartPoint, out side);
                distanceFromHitPointToLastSegment = Vector3.Distance(projectileStartPoint, pointProjectedOnLine) + 0.05f;
				
				trajectorySegmentsRev.Add(new TrajectorySegment());
				trajectorySegmentsRev[trajectorySegmentsRev.Count -1].pointStart = position;
				trajectorySegmentsRev[trajectorySegmentsRev.Count -1].pointEnd = position + vector1;

                if ((side == 0 || Vector3.Distance(position + vector1, projectileStartPoint) < projectileForgiveness) && distanceFromHitPointToLastSegment <= projectileForgiveness)
                {
                    lsVecStart = position;
                    lsVecEnd = position + vector1;
                    return true;
                }

                position += vector1;
                vector1 *= single1;
                vector1 -= vector2;
            }

            lsVecStart = position;
            lsVecEnd = position + vector1;
			
			trajectorySegmentsRev.Add(new TrajectorySegment());
			trajectorySegmentsRev[trajectorySegmentsRev.Count -1].pointStart = position;
			trajectorySegmentsRev[trajectorySegmentsRev.Count -1].pointEnd = position + vector1;
			
            return false;
        }

        private void DrawProjectileTrajectory(BasePlayer player, float _drawTime, AIMViolationData aimvd, Color lineColor)
        {
            if (player != null)
            {
				float physicsSteps = aimvd.physicsSteps;
				float fixedDeltaTime = 1f / physicsSteps;
                Vector3 position = aimvd.startProjectilePosition;
                Vector3 vector1 = aimvd.startProjectileVelocity / physicsSteps;
                float distance = aimvd.calculatedTravelDistance;
				float hitInfoDistance = aimvd.hitInfoProjectileDistance;
                float gravityModifier = aimvd.gravityModifier;
                float drag = aimvd.drag;
                Vector3 hitPoint = aimvd.hitInfoHitPositionWorld;
                Vector3 vector2 = ((Physics.gravity * gravityModifier) / physicsSteps) * fixedDeltaTime;
                bool isRicochet = false;
                int ricochetCnt = 0;
                float single1 = drag * fixedDeltaTime;
                float dist = 0.0f;
				int segmentsCnt = (int)(physicsSteps * 8);

                DDrawSphereToAdmin(player, _drawTime, Color.red, hitPoint, 0.05f);

                if (aimvd.hitsData.Count > 1)
                {
                    isRicochet = true;
                    ricochetCnt = 1;
                }

                for (int j = 0; j < segmentsCnt; j++)
                {
                    if (isRicochet)
                        if (Vector3.Distance(position, aimvd.hitsData[ricochetCnt].hitData.hitPosition) <= (vector1.magnitude))
                        {
                            DDrawArrowToAdmin(player, _drawTime, lineColor, position, aimvd.hitsData[ricochetCnt].hitData.hitPosition, 0.1f);

                            float single3 = Vector3.Distance(position, aimvd.hitsData[ricochetCnt].hitData.hitPosition);
                            float single2 = vector1.magnitude;
                            float single4 = 1f - single3 * (1f / single2);
                            position = aimvd.hitsData[ricochetCnt].hitData.hitPosition;
                            vector1 = aimvd.hitsData[ricochetCnt].hitData.outVelocity * fixedDeltaTime;

                            float single5 = vector1.magnitude * single4;
                            Vector3 vector3 = aimvd.hitsData[ricochetCnt].hitData.outVelocity.normalized * single5;

                            vector1 += vector2;
                            vector1 -= (vector1 * single1);
                            DDrawArrowToAdmin(player, _drawTime, Color.green, position, position + vector3, 0.1f);
                            position += vector3;
                            DDrawArrowToAdmin(player, _drawTime, lineColor, position, position + vector1, 0.1f);
                            dist += single3 + single5;

                            if ((aimvd.hitsData.Count - 1) > ricochetCnt)
                                ricochetCnt++;
                            else
                                isRicochet = false;
                        }
                        else
                            DDrawArrowToAdmin(player, _drawTime, lineColor, position, position + vector1, 0.1f);
                    else
                        DDrawArrowToAdmin(player, _drawTime, lineColor, position, position + vector1, 0.1f);

                    if ((distance - dist) <= (vector1.magnitude))
                        break;
					
					if ((hitInfoDistance - dist) <= (vector1.magnitude))
						lineColor = Color.red;

                    dist += vector1.magnitude;
                    position += vector1;

                    vector1 += vector2;
                    vector1 -= (vector1 * single1);
                }
            }
        }

        private void DrawReverseProjectileTrajectory(BasePlayer player, float _drawTime, AIMViolationData aimvd, Color lineColor)
        {
            if (player != null)
            {
                Vector3 pointStart = aimvd.hitInfoPointStart;
                Vector3 pointEnd = aimvd.hitInfoPointEnd;
                Vector3 hitPoint = aimvd.hitInfoHitPositionWorld;
                float distance = aimvd.hitInfoProjectileDistance;
                float gravityModifier = aimvd.gravityModifier;
                float drag = aimvd.drag;
				float physicsSteps = aimvd.physicsSteps;
				float fixedDeltaTime = 1f / physicsSteps;
                Vector3 position = pointEnd;
                Vector3 vector1 = pointStart - pointEnd;
                Vector3 vector2 = ((-Physics.gravity * gravityModifier) / physicsSteps) * fixedDeltaTime;
                bool isRicochet = false;
                int ricochetCnt = 0;
                float single1 = 1f / (1f - (drag * fixedDeltaTime));
                float dist = 0.0f;
				int segmentsCnt = (int)(physicsSteps * 8);

                if (aimvd.hitsData.Count > 0)
                {
                    isRicochet = true;
                    ricochetCnt = aimvd.hitsData.Count - 1;
                }

                for (int j = 0; j < segmentsCnt; j++)
                {
                    if (isRicochet)
                        if (Vector3.Distance(position, aimvd.hitsData[ricochetCnt].hitData.hitPosition) <= (vector1.magnitude + _config.projectileTrajectoryForgiveness))
                        {
                            DDrawArrowToAdmin(player, _drawTime, Color.yellow, position, aimvd.hitsData[ricochetCnt].hitData.hitPosition, 0.1f);
                            position = aimvd.hitsData[ricochetCnt - 1].lastSegmentPointEnd;
                            vector1 = (aimvd.hitsData[ricochetCnt - 1].lastSegmentPointStart - aimvd.hitsData[ricochetCnt - 1].lastSegmentPointEnd);
                            DDrawArrowToAdmin(player, _drawTime, lineColor, aimvd.hitsData[ricochetCnt].hitData.hitPosition, aimvd.hitsData[ricochetCnt - 1].lastSegmentPointStart, 0.1f);

                            if (ricochetCnt > 0)
                                ricochetCnt--;
                            else
                                isRicochet = false;
                        }
                        else
                            DDrawArrowToAdmin(player, _drawTime, lineColor, position, position + vector1, 0.1f);
                    else
                        DDrawArrowToAdmin(player, _drawTime, lineColor, position, position + vector1, 0.1f);

                    if ((distance - dist) <= (vector1.magnitude + _config.projectileTrajectoryForgiveness))
                        break;

                    if (j == 0)
                        dist = Vector3.Distance(pointStart, hitPoint);
                    else
                        dist += vector1.magnitude;

                    position += vector1;
                    vector1 = (vector1 * single1) - vector2;
                }
            }
        }

        private void DrawProjectileTrajectory2(BasePlayer player, float _drawTime, FiredProjectile fp, HitInfo info, Color lineColor, float physicsSteps)
        {
            Vector3 position = fp.projectilePosition;
            Vector3 projectileVelocity = fp.projectileVelocity;
            float distance = info.ProjectileDistance;
            float gravityModifier = info.ProjectilePrefab.gravityModifier;
            float drag = info.ProjectilePrefab.drag;
            Vector3 hitPoint = info.HitPositionWorld;
			float fixedDeltaTime = 1f / physicsSteps;

            Vector3 vector1 = projectileVelocity / physicsSteps;
            Vector3 vector2 = ((Physics.gravity * gravityModifier) / physicsSteps) * fixedDeltaTime;
            bool isRicochet = false;
            int ricochetCnt = 0;
            float single1 = drag * fixedDeltaTime;
            float dist = 0.0f;
			int segmentsCnt = (int)(physicsSteps * 8);

            if (fp.hitsData.Count > 0)
            {
                isRicochet = true;
                ricochetCnt = 1;
            }

            for (int j = 0; j < segmentsCnt; j++)
            {
                if (isRicochet)
                    if (Vector3.Distance(position, fp.hitsData[ricochetCnt - 1].hitPosition) <= (vector1.magnitude + _config.projectileTrajectoryForgiveness))
                    {
                        DDrawArrowToAdmin(player, _drawTime, lineColor, position, fp.hitsData[ricochetCnt - 1].hitPosition, 0.1f);

                        float single3 = Vector3.Distance(position, fp.hitsData[ricochetCnt - 1].hitPosition);
                        float single2 = vector1.magnitude;
                        float single4 = 1f - single3 * (1f / single2);
                        position = fp.hitsData[ricochetCnt - 1].hitPosition;
                        vector1 = fp.hitsData[ricochetCnt - 1].outVelocity * fixedDeltaTime;

                        DDrawSphereToAdmin(player, _drawTime, Color.red, hitPoint, 0.2f);

                        float single5 = vector1.magnitude * single4;
                        Vector3 vector3 = fp.hitsData[ricochetCnt - 1].outVelocity.normalized * single5;

                        vector1 += vector2;
                        vector1 -= (vector1 * single1);
                        DDrawArrowToAdmin(player, _drawTime, Color.green, position, position + vector3, 0.1f);
                        position += vector3;
                        DDrawArrowToAdmin(player, _drawTime, lineColor, position, position + vector1, 0.1f);
                        dist += single3 + single5;

                        if (fp.hitsData.Count > ricochetCnt)
                            ricochetCnt++;
                        else
                            isRicochet = false;
                    }
                    else
                        DDrawArrowToAdmin(player, _drawTime, lineColor, position, position + vector1, 0.1f);
                else
                    DDrawArrowToAdmin(player, _drawTime, lineColor, position, position + vector1, 0.1f);

                if ((distance - dist) <= (vector1.magnitude))
                    break;

                dist += vector1.magnitude;
                position += vector1;

                vector1 += vector2;
                vector1 -= (vector1 * single1);
            }
        }

		private bool IsRicochet(List<TrajectorySegment> trajectorySegments, List<TrajectorySegment> trajectorySegmentsRev, out HitData hitData1, out HitData hitData2, float physicsSteps)
        {
			Vector3 intersectPoint1 = new Vector3();
			Vector3 intersectPoint2 = new Vector3();
			
			hitData1 = new HitData();
			hitData2 = new HitData();
			
			for (int j = 0; j < trajectorySegments.Count; j++)
			{
				for (int i = 0; i < trajectorySegmentsRev.Count; i++)
				{
					if (ClosestPointsOnTwoLines(out intersectPoint1, out intersectPoint2, trajectorySegments[j].pointStart, trajectorySegments[j].pointEnd - trajectorySegments[j].pointStart, trajectorySegmentsRev[i].pointStart, trajectorySegmentsRev[i].pointEnd - trajectorySegmentsRev[i].pointStart))
					{
						if (Vector3.Distance(trajectorySegments[j].pointStart, intersectPoint1) <= Vector3.Distance(trajectorySegments[j].pointStart, trajectorySegments[j].pointEnd) && Vector3.Distance(trajectorySegmentsRev[i].pointStart, intersectPoint2) <= Vector3.Distance(trajectorySegmentsRev[i].pointStart, trajectorySegmentsRev[i].pointEnd) && Vector3.Distance(intersectPoint1, intersectPoint2) <= _config.projectileTrajectoryForgiveness)
						{
							hitData1.hitPositionWorld = intersectPoint1;
							hitData1.hitPointStart = trajectorySegments[j].pointStart;		
							hitData1.hitPointEnd = trajectorySegments[j].pointEnd;
							hitData2.hitData.inVelocity = (intersectPoint1 - trajectorySegments[j].pointStart) * physicsSteps;
							hitData2.hitData.inVelocity = (trajectorySegments[j].pointEnd - trajectorySegments[j].pointStart) * physicsSteps;
							
							hitData2.startProjectilePosition = intersectPoint1;
							hitData2.startProjectileVelocity = (trajectorySegmentsRev[i].pointStart - trajectorySegmentsRev[i].pointEnd) * physicsSteps;	
							hitData2.hitData.outVelocity = (trajectorySegmentsRev[i].pointStart - trajectorySegmentsRev[i].pointEnd) * physicsSteps;	
							hitData2.hitData.hitPosition = intersectPoint1;	
							return true;							
						}
					}
				}
			}			
			return false;
		}
        #endregion Functions
    }
}

// --- End of file: Arkan.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/Crafts.cs ---
// --- Original Local Path: KualaRust/Crafts.cs ---

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using UnityEngine;
using VLB;
using WebSocketSharp;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
    [Info("Crafts", "Mevent", "1.9.0⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠")]
    public class Crafts : RustPlugin
    {
        //TODO: Добавить время крафта

        #region Fields⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        [PluginReference] private Plugin ImageLibrary;

        private const string Layer = "UI.Crafts";

        private static Crafts _instance;
        
        private readonly List<int> _blockedLayers = new List<int>
        {
            (int) Rust.Layer.Water, (int) Rust.Layer.Construction, (int) Rust.Layer.Trigger,
            (int) Rust.Layer.Prevent_Building,
            (int) Rust.Layer.Deployed, (int) Rust.Layer.Tree
        };

        private enum WorkbenchLevel
        {
            None = 0,
            One = 1,
            Two = 2,
            Three = 3
        }

        private enum CraftType
        {
            Команда,
            Транспорт,
            Предмет,
            Переработчик
        }

        #endregion

        #region Config⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        private static Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Цвет кнопки когда все предметы присутствуют")]
            public string GreenColor = "#80FF8080";

            [JsonProperty(PropertyName = "Комманда меню крафта")]
            public string Command = "craft";

            [JsonProperty(PropertyName = "Включить дебаг?")]
            public bool useDebug = true;

            [JsonProperty(PropertyName = "Настройка цветов верстаков",
                ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<WorkbenchLevel, WorkbenchConfig> Workbenchs =
                new Dictionary<WorkbenchLevel, WorkbenchConfig>
                {
                    [WorkbenchLevel.None] = new WorkbenchConfig("#00000080", "Верстак не требуется"),
                    [WorkbenchLevel.One] = new WorkbenchConfig("#80400080", "Верстак 1 уровня"),
                    [WorkbenchLevel.Two] = new WorkbenchConfig("#0080FF80", "Верстак 2 уровня"),
                    [WorkbenchLevel.Three] = new WorkbenchConfig("#FF000080", "Верстак 3 уровня")
                };

            [JsonProperty(PropertyName = "Настройка крафтов", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<CraftConfig> CraftsList = new List<CraftConfig>
            {
                new CraftConfig
                {
                    Enabled = true,
                    ImageURL = "https://i.imgur.com/YXjADeE.png",
                    Description = new List<string>
                    {
                        "Для создания требуется:",
                        "- Шестерни (5 шт)",
                        "- Дорожные знаки (5 шт)",
                        "- Металл (2000 шт)"
                    },
                    Command = "givecopter",
                    Permission = "crafts.all",
                    DisplayName = "Миникоптер",
                    ShortName = "electric.flasherlight",
                    SkinID = 2080145158,
                    Type = CraftType.Транспорт,
                    Prefab = "assets/content/vehicles/minicopter/minicopter.entity.prefab",
                    Level = WorkbenchLevel.One,
                    UseDistance = true,
                    Distance = 1.5f,
                    GiveCommand = string.Empty,
                    Ground = true,
                    Structure = true,
                    Items = new List<ItemForCraft>
                    {
                        new ItemForCraft("gears", 5, 0),
                        new ItemForCraft("roadsigns", 5, 0),
                        new ItemForCraft("metal.fragments", 2000, 0)
                    }
                },
                new CraftConfig
                {
                    Enabled = true,
                    ImageURL = "https://i.imgur.com/dmWQOm6.png",
                    Description = new List<string>
                    {
                        "Для создания требуется:",
                        "- Шестерни (5 шт)",
                        "- Дорожные знаки (5 шт)",
                        "- Металл (2000 шт)"
                    },
                    Command = "giverowboat",
                    Permission = "crafts.all",
                    DisplayName = "Деревянная лодка",
                    ShortName = "coffin.storage",
                    SkinID = 2080150023,
                    Type = CraftType.Транспорт,
                    Prefab = "assets/content/vehicles/boats/rowboat/rowboat.prefab",
                    Level = WorkbenchLevel.Two,
                    UseDistance = true,
                    Distance = 1.5f,
                    GiveCommand = string.Empty,
                    Ground = true,
                    Structure = true,
                    Items = new List<ItemForCraft>
                    {
                        new ItemForCraft("gears", 5, 0),
                        new ItemForCraft("roadsigns", 5, 0),
                        new ItemForCraft("metal.fragments", 2000, 0)
                    }
                },
                new CraftConfig
                {
                    Enabled = true,
                    ImageURL = "https://i.imgur.com/CgpVw2j.png",
                    Description = new List<string>
                    {
                        "Для создания требуется:",
                        "- Шестерни (5 шт)",
                        "- Дорожные знаки (5 шт)",
                        "- Металл (2000 шт)"
                    },
                    Command = "giverhibboat",
                    Permission = "crafts.all",
                    DisplayName = "Военная лодка",
                    ShortName = "electric.sirenlight",
                    SkinID = 2080150770,
                    Type = CraftType.Транспорт,
                    GiveCommand = string.Empty,
                    Prefab = "assets/content/vehicles/boats/rhib/rhib.prefab",
                    Level = WorkbenchLevel.Three,
                    UseDistance = true,
                    Distance = 1.5f,
                    Ground = true,
                    Structure = true,
                    Items = new List<ItemForCraft>
                    {
                        new ItemForCraft("gears", 5, 0),
                        new ItemForCraft("roadsigns", 5, 0),
                        new ItemForCraft("metal.fragments", 2000, 0)
                    }
                },
                new CraftConfig
                {
                    Enabled = true,
                    ImageURL = "https://i.imgur.com/eioxlvK.png",
                    Description = new List<string>
                    {
                        "Для создания требуется:",
                        "- Шестерни (5 шт)",
                        "- Дорожные знаки (5 шт)",
                        "- Металл (2000 шт)"
                    },
                    Command = "givesedan",
                    Permission = "crafts.all",
                    DisplayName = "Машина",
                    ShortName = "woodcross",
                    SkinID = 2080151780,
                    Type = CraftType.Транспорт,
                    GiveCommand = string.Empty,
                    Prefab = "assets/content/vehicles/sedan_a/sedantest.entity.prefab",
                    Level = WorkbenchLevel.Two,
                    UseDistance = true,
                    Distance = 1.5f,
                    Ground = true,
                    Structure = true,
                    Items = new List<ItemForCraft>
                    {
                        new ItemForCraft("gears", 5, 0),
                        new ItemForCraft("roadsigns", 5, 0),
                        new ItemForCraft("metal.fragments", 2000, 0)
                    }
                },
                new CraftConfig
                {
                    Enabled = true,
                    ImageURL = "https://i.imgur.com/cp2Xx2A.png",
                    Description = new List<string>
                    {
                        "Для создания требуется:",
                        "- Шестерни (5 шт)",
                        "- Дорожные знаки (5 шт)",
                        "- Металл (2000 шт)"
                    },
                    Command = "givehotair",
                    Permission = "crafts.all",
                    DisplayName = "Воздушный шар",
                    ShortName = "box.repair.bench",
                    SkinID = 2080152635,
                    Type = CraftType.Транспорт,
                    GiveCommand = string.Empty,
                    Prefab = "assets/prefabs/deployable/hot air balloon/hotairballoon.prefab",
                    Level = WorkbenchLevel.Three,
                    UseDistance = true,
                    Distance = 1.5f,
                    Ground = true,
                    Structure = true,
                    Items = new List<ItemForCraft>
                    {
                        new ItemForCraft("gears", 5, 0),
                        new ItemForCraft("roadsigns", 5, 0),
                        new ItemForCraft("metal.fragments", 2000, 0)
                    }
                },
                new CraftConfig
                {
                    Enabled = true,
                    ImageURL = "https://i.imgur.com/7JZE0Lr.png",
                    Description = new List<string>
                    {
                        "Для создания требуется:",
                        "- Шестерни (5 шт)",
                        "- Дорожные знаки (5 шт)",
                        "- Металл (2000 шт)"
                    },
                    Command = "givescrapheli",
                    Permission = "crafts.all",
                    DisplayName = "Грузовой вертолёт",
                    ShortName = "lantern",
                    SkinID = 2080154394,
                    Type = CraftType.Транспорт,
                    GiveCommand = string.Empty,
                    Prefab = "assets/content/vehicles/scrap heli carrier/scraptransporthelicopter.prefab",
                    Level = WorkbenchLevel.Three,
                    UseDistance = true,
                    Distance = 1.5f,
                    Ground = true,
                    Structure = true,
                    Items = new List<ItemForCraft>
                    {
                        new ItemForCraft("gears", 5, 0),
                        new ItemForCraft("roadsigns", 5, 0),
                        new ItemForCraft("metal.fragments", 2000, 0)
                    }
                },
                new CraftConfig
                {
                    Enabled = true,
                    ImageURL = "https://i.imgur.com/LLB2AVi.png",
                    Description = new List<string>
                    {
                        "Для создания требуется:",
                        "- Шестерни (5 шт)",
                        "- Дорожные знаки (5 шт)",
                        "- Металл (2000 шт)"
                    },
                    Command = "giverecycler",
                    Permission = "crafts.all",
                    DisplayName = "Домашний Переработчик",
                    ShortName = "research.table",
                    SkinID = 2186833264,
                    Type = CraftType.Переработчик,
                    Prefab = "assets/bundled/prefabs/static/recycler_static.prefab",
                    GiveCommand = string.Empty,
                    Level = WorkbenchLevel.Two,
                    UseDistance = true,
                    Distance = 1.5f,
                    Ground = true,
                    Structure = true,
                    Items = new List<ItemForCraft>
                    {
                        new ItemForCraft("gears", 5, 0),
                        new ItemForCraft("roadsigns", 5, 0),
                        new ItemForCraft("metal.fragments", 2000, 0)
                    }
                },
                new CraftConfig
                {
                    Enabled = true,
                    ImageURL = "https://i.imgur.com/mw1T17x.png",
                    Description = new List<string>
                    {
                        "Для создания требуется:",
                        "- Шестерни (5 шт)",
                        "- Дорожные знаки (5 шт)",
                        "- Металл (2000 шт)"
                    },
                    Command = "givelr300",
                    Permission = "crafts.all",
                    DisplayName = string.Empty,
                    ShortName = "rifle.lr300",
                    SkinID = 0,
                    Type = CraftType.Предмет,
                    Prefab = string.Empty,
                    GiveCommand = string.Empty,
                    Level = WorkbenchLevel.None,
                    UseDistance = true,
                    Distance = 1.5f,
                    Ground = true,
                    Structure = true,
                    Items = new List<ItemForCraft>
                    {
                        new ItemForCraft("gears", 5, 0),
                        new ItemForCraft("roadsigns", 5, 0),
                        new ItemForCraft("metal.fragments", 2000, 0)
                    }
                }
            };
            
            [JsonProperty(PropertyName = "Настройка переработчика")]
            public RecyclerConfig Recycler = new RecyclerConfig
            {
                Speed = 5f,
                Radius = 7.5f,
                Text = "<size=19>ПЕРЕРАБОТЧИК</size>\n<size=15>{0}/{1}</size>",
                Color = "#C5D0E6",
                Delay = 0.75f,
                Available = true,
                Owner = true,
                Amounts = new[] {0.9f, 0, 0, 0, 0, 0.5f, 0, 0, 0, 0.9f, 0.5f, 0.5f, 0, 1, 1, 0.5f, 0, 0, 0, 0, 0, 1, 1},
                Scale = 0.5f,
                DDraw = true,
                Building = true
            };
            
            [JsonProperty(PropertyName = "Настройка машины")]
            public CarConfig Car = new CarConfig
            {
                ActiveItems = new ActiveItemOptions
                {
                    Disable = true,
                    BlackList = new[]
                    {
                        "explosive.timed", "rocket.launcher", "surveycharge", "explosive.satchel"
                    }
                },
                Radius = 7.5f,
                Text = "<size=15>{0}/{1}</size>",
                Color = "#C5D0E6",
                Delay = 0.75f,
            };
        }
        
        private class CarConfig
        {
            [JsonProperty(PropertyName = "Активные предметы (которые в руки)")]
            public ActiveItemOptions ActiveItems;
            
            [JsonProperty(PropertyName = "Радиус в котором будет показан текст на машине")]
            public float Radius;
            
            [JsonProperty(PropertyName = "Текст на машине")]
            public string Text;
            
            [JsonProperty(PropertyName = "Цвет текста на машине")]
            public string Color;

            [JsonProperty(PropertyName = "Время показа текста на машине (сек)")]
            public float Delay;
        }
        
        public class ActiveItemOptions
        {
            [JsonProperty(PropertyName = "Запретить держать все предметы")]
            public bool Disable;

            [JsonProperty(PropertyName = "Список запрещённых к держанию предметов (shortname)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public string[] BlackList;
        }
        
        private class RecyclerConfig
        {
            [JsonProperty(PropertyName = "Скорость переработки")]
            public float Speed;

            [JsonProperty(PropertyName = "Радиус в котором будет показан текст на переработчике")]
            public float Radius;

            [JsonProperty(PropertyName = "Показывать дамаг на переработчике")]
            public bool DDraw;
            
            [JsonProperty(PropertyName = "Текст на переработчике")]
            public string Text;

            [JsonProperty(PropertyName = "Цвет текста на переработчике")]
            public string Color;

            [JsonProperty(PropertyName = "Время показа текста на переработчике (сек)")]
            public float Delay;
            
            [JsonProperty(PropertyName = "Можно ли подбирать переработчик")]
            public bool Available;
            
            [JsonProperty(PropertyName = "Подбор только владельцем?")]
            public bool Owner;
            
            [JsonProperty(PropertyName = "Право на постройку для подбора")]
            public bool Building;

            [JsonProperty(PropertyName = "Настройка BaseProtection",
                ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public float[] Amounts;

            [JsonProperty(PropertyName = "Множитель урона по переработчику")]
            public float Scale;
        }

        private class WorkbenchConfig
        {
            [JsonProperty(PropertyName = "Цвет")] 
            public string Color;

            [JsonProperty(PropertyName = "Надпись")]
            public string Title;

            public WorkbenchConfig(string color, string title)
            {
                Color = color;
                Title = title;
            }
        }

        private class CraftConfig
        {
            [JsonProperty(PropertyName = "Включить крафт?")]
            public bool Enabled;

            [JsonProperty(PropertyName = "Картинка")]
            public string ImageURL;

            [JsonProperty(PropertyName = "Описание")]
            public List<string> Description;

            [JsonProperty(PropertyName = "Команда для получения")]
            public string Command;

            [JsonProperty(PropertyName = "Право на крафт")]
            public string Permission;

            [JsonProperty(PropertyName = "Отображаемое имя заменяемого предмета")]
            public string DisplayName;

            [JsonProperty(PropertyName = "Shortname заменяемого предмета")]
            public string ShortName;

            [JsonProperty(PropertyName = "Скин заменяемого предмета")]
            public ulong SkinID;

            [JsonProperty(PropertyName = "Тип предмета (Предмет/Команда/Транспорт)")]
            [JsonConverter(typeof(StringEnumConverter))]
            public CraftType Type;

            [JsonProperty(PropertyName = "Префаб (для транспорта)")]
            public string Prefab;

            [JsonProperty(PropertyName = "Команда при получении")]
            public string GiveCommand;

            [JsonProperty(PropertyName = "Уровень верстака")]
            public WorkbenchLevel Level;

            [JsonProperty(PropertyName = "Включить проверку на дистанцию?")]
            public bool UseDistance;

            [JsonProperty(PropertyName = "Дистанция")]
            public float Distance;
            
            [JsonProperty(PropertyName = "Установка на землю")]
            public bool Ground;
            
            [JsonProperty(PropertyName = "Установка на строения")]
            public bool Structure;
            
            [JsonProperty(PropertyName = "Настройка предметов для крафта",
                ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<ItemForCraft> Items;

            public Item ToItem()
            {
                var newItem = ItemManager.CreateByName(ShortName, 1, SkinID);
                if (newItem == null)
                {
                    Debug.LogError($"Error creating item with ShortName: '{ShortName}'");
                    return null;
                }

                if (!DisplayName.IsNullOrEmpty()) newItem.name = DisplayName;

                return newItem;
            }

            public void Give(BasePlayer player)
            {
                if (player == null) return;

                var item = ToItem();
                if (item == null) return;
                
                player.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);
            }
        }

        private class ItemForCraft
        {
            [JsonProperty(PropertyName = "Shortname")]
            public string ShortName;

            [JsonProperty(PropertyName = "Количество")]
            public int Amount;

            [JsonProperty(PropertyName = "Скин")] public ulong SkinID;

            public ItemForCraft(string shortname, int amount, ulong skin)
            {
                ShortName = shortname;
                Amount = amount;
                SkinID = skin;
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        protected override void LoadDefaultConfig()
        {
            _config = new Configuration();
        }

        #endregion

        #region Hooks⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        private void OnServerInitialized()
        {
            _instance = this;
            
            if (!ImageLibrary) PrintWarning("IMAGE LIBRARY IS NOT INSTALLED.");

            foreach (var item in _config.CraftsList)
            {
                if (!item.ImageURL.IsNullOrEmpty())
                    ImageLibrary?.Call("AddImage", item.ImageURL, item.ImageURL);

                if (!item.Command.IsNullOrEmpty())
                    AddCovalenceCommand(item.Command, nameof(CmdGiveItem));

                if (!item.Permission.IsNullOrEmpty() && !permission.PermissionExists(item.Permission))
                    permission.RegisterPermission(item.Permission, this);
            }

            foreach (var ent in BaseNetworkable.serverEntities)
            {
                OnEntitySpawned(ent as BaseEntity);
            }
            
            cmd.AddChatCommand(_config.Command, this, nameof(CmdChatOpenUI));
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
                CuiHelper.DestroyUi(player, Layer);

            foreach (var component in UnityEngine.Object.FindObjectsOfType<RecyclerComponent>())
                if (component != null)
                    component.Kill();
            
            foreach (var component in UnityEngine.Object.FindObjectsOfType<CarController>())
                if (component != null)
                    component.Kill();
            
            _config = null;
            _instance = null;
        }

        private void OnEntityBuilt(Planner held, GameObject go)
        {
            if (held == null || go == null) return;

            var player = held.GetOwnerPlayer();
            if (player == null) return;

            var entity = go.ToBaseEntity();
            if (entity == null || entity.skinID == 0) return;

            var craft = _config.CraftsList.FirstOrDefault(x => (x.Type == CraftType.Транспорт || x.Type == CraftType.Переработчик) && x.SkinID == entity.skinID);
            if (craft == null) return;

            var transform = entity.transform;
            
            var itemName = !string.IsNullOrEmpty(craft.DisplayName)
                ? craft.DisplayName
                : ItemManager.FindItemDefinition(craft.ShortName)?.displayName.translated ?? "ITEM";
            
            NextTick(() =>
            {
                if (entity != null) 
                    entity.Kill();
            });
            
            RaycastHit rHit;
            if (Physics.Raycast(transform.position + new Vector3(0, 0.1f, 0), Vector3.down, out rHit, 4f,
                LayerMask.GetMask("Construction")) && rHit.GetEntity() != null)
            {
                if (!craft.Structure)
                {
                    Reply(player, OnStruct, itemName);
                    GiveCraft(player, craft);
                    return;
                }
            }
            else
            { 
                if (!craft.Ground)
                {
                    Reply(player, OnGround, itemName);
                    GiveCraft(player, craft);
                    return;
                }
            }

            SpawnVehicle(craft.Prefab, player.userID, craft.SkinID, transform.position, transform.rotation);
        }
        
        private object CanResearchItem(BasePlayer player, Item item)
        {
            if (player == null || item == null || !_config.CraftsList.Exists(x => x.Type == CraftType.Транспорт && x.SkinID == item.skin)) return null;
            return false;
        }

        private void OnEntitySpawned(BaseEntity entity)
        {
            if (entity == null) return;

            if (entity is Recycler) 
                entity.gameObject.AddComponent<RecyclerComponent>();

            if (entity is BasicCar)
                entity.gameObject.AddComponent<CarController>();
        }

        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null || entity.OwnerID == 0) return;

            var recycler = entity.GetComponent<RecyclerComponent>();
            if (recycler != null)
            {
                info.damageTypes.ScaleAll(_config.Recycler.Scale);
                recycler.DDraw();
            }

            var car = entity.GetComponent<CarController>();
            if (car != null)
            {
                car.ManageDamage(info);
                car.DDraw();
            }
        }

        private object OnRecyclerToggle(Recycler recycler, BasePlayer player)
        {
            if (recycler == null || player == null) return null;

            var component = recycler.GetComponent<RecyclerComponent>();
            if (component == null) return null;

            if (!recycler.IsOn())
            {
                foreach (var obj in recycler.inventory.itemList)
                    obj.CollectedForCrafting(player);

                component.StartRecycling();
            }
            else
            {
                component.StopRecycling();
            }

            return false;
        }

        private void OnHammerHit(BasePlayer player, HitInfo info)
        {
            if (player == null || info == null) return;

            var entity = info.HitEntity;
            if (entity == null) return;

            var component = entity.GetComponent<RecyclerComponent>();
            if (component == null) return;

            if (!_config.Recycler.Available)
            {
                Reply(player, NotTake);
                return;
            }
            
            component.TryPickup(player);
        }

        #endregion

        #region Commands⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        [ConsoleCommand("UI_Crafts")]
        private void CmdConsoleCraft(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;

            if (!arg.HasArgs())
            {
                DrawUI(player, isFirst: true);
                return;
            }

            switch (arg.Args[0].ToLower())
            {
                case "page":
                {
                    var page = 0;
                    if (!arg.HasArgs(2) || !int.TryParse(arg.Args[1], out page)) return;

                    DrawUI(player, page);
                    break;
                }
                case "craft":
                {
                    int itemid;
                    if (!arg.HasArgs(2) || !int.TryParse(arg.Args[1], out itemid)
                                        || !(itemid >= 0 && _config.CraftsList.Count > itemid)) return;

                    var craftItem = _config.CraftsList[itemid];
                    if (craftItem == null) return;

                    if (!HasWorkbench(player, craftItem.Level))
                    {
                        Reply(player, "NOT WORKBENCH");
                        return;
                    }

                    var playerItems = player.inventory.AllItems();

                    if (!HasAllItems(playerItems, craftItem))
                    {
                        Reply(player, "NOT.RESOURCES");
                        return;
                    }

                    for (var i = 0; i < craftItem.Items.Count; i++)
                    {
                        var item = craftItem.Items[i];
                        if (item == null) continue;
                        Take(playerItems, item.ShortName, item.SkinID, item.Amount);
                    }

                    GiveCraft(player, craftItem);
                    //CraftItem(player, craftItem);
                    Reply(player, "GIVED CRAFT",
                        !string.IsNullOrEmpty(craftItem.DisplayName)
                            ? craftItem.DisplayName
                            : ItemManager.FindItemDefinition(craftItem.ShortName).displayName.translated);
                    break;
                }
            }
        }

        private void CmdGiveItem(IPlayer iPlayer, string cmd, string[] args)
        {
            if (args.Length == 0) return;
            var player = BasePlayer.Find(args[0]);
            if (player == null)
            {
                Reply(iPlayer, "PLAYER NOT FOUND", args[0]);
                return;
            }

            var craftItem = _config.CraftsList.FirstOrDefault(x => x.Command == cmd);
            if (craftItem == null)
            {
                iPlayer.Reply("COMMAND NOT FOUND", cmd);
                return;
            }

            var item = craftItem.ToItem();
            if (item == null)
                return;

            var itemName = !string.IsNullOrEmpty(craftItem.DisplayName)
                ? craftItem.DisplayName
                : item.info.displayName.translated;

            player.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);
            Reply(player, "GIVED CRAFT", itemName);

            if (_config.useDebug) Reply(iPlayer, "GIVE.DEBUG", player.displayName, player.UserIDString, itemName);
        }

        private void CmdChatOpenUI(BasePlayer player, string cmd, string[] args)
        {
            DrawUI(player, isFirst: true);
        }

        #endregion

        #region Interface⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        private void DrawUI(BasePlayer player, int page = 0, bool isFirst = false)
        {
            var container = new CuiElementContainer();

            var playerItems = player.inventory.AllItems();

            #region First

            if (isFirst)
            {
                CuiHelper.DestroyUi(player, Layer);

                #region BG

                container.Add(new CuiPanel
                {
                    RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
                    Image =
                    {
                        Color = "0.1 0.1 0.05 0.75",
                        Sprite = "assets/content/ui/ui.background.transparent.radial.psd",
                        Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat"
                    },
                    CursorEnabled = true
                }, "Overlay", Layer);

                #endregion

                #region Title

                container.Add(new CuiLabel
                {
                    RectTransform =
                        {AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-200 200", OffsetMax = "200 300"},
                    Text =
                    {
                        Text = lang.GetMessage("Title", this, player.UserIDString), Align = TextAnchor.MiddleCenter,
                        FontSize = 28
                    }
                }, Layer);

                #endregion
            }

            #endregion

            #region Main

            container.Add(new CuiPanel
            {
                RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
                Image = {Color = "0 0 0 0"}
            }, Layer, Layer + ".Main");

            container.Add(new CuiButton
            {
                RectTransform =
                {
                    AnchorMin = "1 1", AnchorMax = "1 1",
                    OffsetMin = "-45 -45", OffsetMax = "-5 -5"
                },
                Text =
                {
                    Text = "✕",
                    Align = TextAnchor.MiddleCenter,
                    FontSize = 28,
                    Color = "1 1 1 1"
                },
                Button =
                {
                    Color = "0 0 0 0",
                    Close = Layer
                }
            }, Layer + ".Main");

            #region Items

            var list = GetPlayerCrafts(player, page);

            if (list.Count > 0)
            {
                var xSwitch = -(220 * list.Count + 40 * (list.Count - 1)) / 2;

                for (var i = 0; i < list.Count; i++)
                {
                    var craft = list[i];

                    container.Add(new CuiPanel
                    {
                        RectTransform =
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"{xSwitch} -100",
                            OffsetMax = $"{xSwitch + 220} 200"
                        },
                        Image = {Color = "0 0 0 0.5", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat"}
                    }, Layer + ".Main", Layer + $".Craft.{xSwitch}");

                    container.Add(new CuiElement
                    {
                        Parent = Layer + $".Craft.{xSwitch}",
                        Components =
                        {
                            new CuiRawImageComponent {Png = ImageLibrary.Call<string>("GetImage", craft.ImageURL)},
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-70 0", OffsetMax = "70 140"
                            }
                        }
                    });

                    container.Add(new CuiPanel
                    {
                        RectTransform =
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-85 -10", OffsetMax = "85 -5"
                        },
                        Image = {Color = "1 1 1 1", Sprite = "assets/content/ui/gameui/compass/alpha_mask.png"}
                    }, Layer + $".Craft.{xSwitch}");

                    container.Add(new CuiLabel
                    {
                        RectTransform =
                            {AnchorMin = "0 0.5", AnchorMax = "1 0.5", OffsetMin = "0 -130", OffsetMax = "0 -25"},
                        Text =
                        {
                            Text = string.Join("\n", craft.Description), Align = TextAnchor.UpperCenter,
                            FontSize = 14
                        }
                    }, Layer + $".Craft.{xSwitch}");

                    container.Add(new CuiPanel
                    {
                        RectTransform =
                            {AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "0 -50", OffsetMax = "0 -5"},
                        Image =
                        {
                            Color = HexToCuiColor(_config.Workbenchs[craft.Level].Color),
                            Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat"
                        }
                    }, Layer + $".Craft.{xSwitch}", Layer + $".Craft.{xSwitch}.Workbench");

                    container.Add(new CuiLabel
                    {
                        RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
                        Text =
                        {
                            Text = _config.Workbenchs[craft.Level].Title, Align = TextAnchor.MiddleCenter,
                            FontSize = 14
                        }
                    }, Layer + $".Craft.{xSwitch}.Workbench");

                    var active = HasAllItems(playerItems, craft) && HasWorkbench(player, craft.Level);
                    container.Add(new CuiButton
                    {
                        RectTransform =
                            {AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "0 -105", OffsetMax = "0 -55"},
                        Button =
                        {
                            Command = active ? $"UI_Crafts craft {_config.CraftsList.IndexOf(craft)}" : "",
                            Color = active ? HexToCuiColor(_config.GreenColor) : "0 0 0 0.5",
                            Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat",
                            Close = active ? Layer : ""
                        },
                        Text =
                        {
                            Text = lang.GetMessage("CREATE", this, player.UserIDString),
                            Align = TextAnchor.MiddleCenter, FontSize = 24
                        }
                    }, Layer + $".Craft.{xSwitch}");

                    xSwitch += 260;
                }
            }
            else
            {
                container.Add(new CuiLabel
                {
                    RectTransform =
                    {
                        AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-250 -150", OffsetMax = "250 150"
                    },
                    Text =
                    {
                        Text = lang.GetMessage("NOT CRAFTS", this, player.UserIDString),
                        Align = TextAnchor.MiddleCenter, FontSize = 34
                    }
                }, Layer + ".Main");
            }

            #endregion

            #region Pages

            if (list.Count > 0)
            {
                container.Add(new CuiButton
                {
                    RectTransform =
                        {AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "5 -25", OffsetMax = "55 25"},
                    Button =
                    {
                        Command = page > 0 ? $"UI_Crafts page {page - 1}" : "",
                        Color = "0 0 0 0"
                    },
                    Text =
                    {
                        Text = "<", Align = TextAnchor.MiddleCenter, FontSize = 40,
                        Color = page > 0 ? "1 1 1 1" : "1 1 1 0.5"
                    }
                }, Layer + ".Main");

                var count = _config.CraftsList.Count(craft => craft.Enabled &&
                                                              (string.IsNullOrEmpty(craft.Permission) ||
                                                               permission.UserHasPermission(player.UserIDString,
                                                                   craft.Permission)));
                
                container.Add(new CuiButton
                {
                    RectTransform =
                        {AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "-55 -25", OffsetMax = "-5 25"},
                    Button =
                    {
                        Command = count > (page + 1) * 3 ? $"UI_Crafts page {page + 1}" : "",
                        Color = "0 0 0 0"
                    },
                    Text =
                    {
                        Text = ">", Align = TextAnchor.MiddleCenter, FontSize = 40,
                        Color = count > (page + 1) * 3 ? "1 1 1 1" : "1 1 1 0.5"
                    }
                }, Layer + ".Main");
            }

            #endregion

            #endregion

            CuiHelper.DestroyUi(player, Layer + ".Main");
            CuiHelper.AddUi(player, container);
        }
        
        #endregion

        #region Utils⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        private void GiveCraft(BasePlayer player, CraftConfig cfg)
        {
            switch (cfg.Type)
            {
                case CraftType.Команда:
                {
                    var command = cfg.GiveCommand.Replace("\n", "|")
                        .Replace("%steamid%", player.UserIDString, StringComparison.OrdinalIgnoreCase).Replace(
                            "%username%",
                            player.displayName, StringComparison.OrdinalIgnoreCase);

                    foreach (var check in command.Split('|')) Server.Command(check);
                    break;
                }
                default:
                {
                    cfg.Give(player);
                    break;
                }
            }
        }

        private void CraftItem(BasePlayer player, CraftConfig item)
        {
            var defenition = ItemManager.FindItemDefinition(item.ShortName);

            var task = Pool.Get<ItemCraftTask>();
            task.blueprint = defenition.Blueprint;
            task.endTime = 0.0f;
            task.taskUID = player.inventory.crafting.taskUID + 1;
            task.owner = player;
            task.instanceData = null;
            if (task.instanceData != null)
                task.instanceData.ShouldPool = false;
            task.amount = 1;
            task.skinID = (int) item.SkinID;

            player.inventory.crafting.queue.AddLast(task);
            if (task.owner != null)
                task.owner.Command("note.craft_add", (object) task.taskUID, (object) task.blueprint.targetItem.itemid,
                    (object) 1, (object) task.skinID);
        }

        private static bool HasWorkbench(BasePlayer player, WorkbenchLevel level)
        {
            return level == WorkbenchLevel.Three ? player.HasPlayerFlag(BasePlayer.PlayerFlags.Workbench3)
                : level == WorkbenchLevel.Two ? player.HasPlayerFlag(BasePlayer.PlayerFlags.Workbench3) ||
                                                player.HasPlayerFlag(BasePlayer.PlayerFlags.Workbench2)
                : level == WorkbenchLevel.One ? player.HasPlayerFlag(BasePlayer.PlayerFlags.Workbench3) ||
                                                player.HasPlayerFlag(BasePlayer.PlayerFlags.Workbench2) ||
                                                player.HasPlayerFlag(BasePlayer.PlayerFlags.Workbench1)
                : level == WorkbenchLevel.None;
        }

        private static bool HasAllItems(IReadOnlyList<Item> items, CraftConfig craftConfig)
        {
            for (var i = 0; i < craftConfig.Items.Count; i++)
            {
                var itemForCraft = craftConfig.Items[i];

                if (ItemCount(items, itemForCraft.ShortName, itemForCraft.SkinID) < itemForCraft.Amount) return false;
            }

            return true;
        }

        private static int ItemCount(IReadOnlyList<Item> items, string shortname, ulong skin)
        {
            var result = 0;

            for (var i = 0; i < items.Count; i++)
            {
                var item = items[i];
                if (item.info.shortname == shortname && (skin == 0 || item.skin == skin))
                    result += item.amount;
            }

            return result;
        }

        private void Take(IEnumerable<Item> itemList, string shortname, ulong skinId, int iAmount)
        {
            var num1 = 0;
            if (iAmount == 0) return;

            var list = Pool.GetList<Item>();

            foreach (var item in itemList)
            {
                if (item.info.shortname != shortname ||
                    skinId != 0 && item.skin != skinId) continue;

                var num2 = iAmount - num1;
                if (num2 <= 0) continue;
                if (item.amount > num2)
                {
                    item.MarkDirty();
                    item.amount -= num2;
                    num1 += num2;
                    break;
                }

                if (item.amount <= num2)
                {
                    num1 += item.amount;
                    list.Add(item);
                }

                if (num1 == iAmount)
                    break;
            }

            foreach (var obj in list)
                obj.RemoveFromContainer();

            Pool.FreeList(ref list);
        }

        private void SpawnVehicle(string prefab, ulong owner, ulong skin, Vector3 position,
            Quaternion rotation)
        {
            var entity = GameManager.server.CreateEntity(prefab, position, rotation);
            if (entity == null) return;
            entity.skinID = skin;
            entity.OwnerID = owner;
            entity.Spawn();
        }

        private static string HexToCuiColor(string hex)
        {
            if (string.IsNullOrEmpty(hex)) hex = "#FFFFFFFF";

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8) throw new Exception(hex);

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);
            Color color = new Color32(r, g, b, a);
            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }

        private List<CraftConfig> GetPlayerCrafts(BasePlayer player, int page, int count = 3)
        {
            var result = new List<CraftConfig>();
            var skipCount = page * count;

            for (var i = 0; i < _config.CraftsList.Count; i++)
            {
                var craft = _config.CraftsList[i];

                if (i < skipCount) continue;

                if (craft.Enabled && (string.IsNullOrEmpty(craft.Permission) ||
                                      permission.UserHasPermission(player.UserIDString, craft.Permission)))
                    result.Add(craft);

                if (result.Count >= count) break;
            }

            return result;
        }
        
        private static Color HexToUnityColor(string hex)
        {
            if (string.IsNullOrEmpty(hex)) hex = "#FFFFFFFF";

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8) throw new Exception(hex);

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return color;
        }
        
        private static void SetPlayerFlag(BasePlayer player, BasePlayer.PlayerFlags f, bool b)
        {
            if (b)
            {
                if (player.HasPlayerFlag(f)) return;
                player.playerFlags |= f;
            }
            else
            {
                if (!player.HasPlayerFlag(f)) return;
                player.playerFlags &= ~f;
            }

            player.SendNetworkUpdateImmediate();
        }

        #endregion

        #region Recycler Component⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        
        private class RecyclerComponent : FacepunchBehaviour
        {
            private Recycler recycler;

            private GroundWatch groundWatch;
            private DestroyOnGroundMissing groundMissing;

            [NonSerialized] private readonly BaseEntity[] SensesResults = new BaseEntity[64];

            private void Awake()
            {
                recycler = GetComponent<Recycler>();

                if (recycler.OwnerID != 0)
                {
                    recycler.baseProtection = ScriptableObject.CreateInstance<ProtectionProperties>();
                    recycler.baseProtection.amounts = _config.Recycler.Amounts;
                    
                    groundWatch = recycler.GetOrAddComponent<GroundWatch>();

                    groundMissing = recycler.GetOrAddComponent<DestroyOnGroundMissing>();
                }
            }

            public void DDraw()
            {
                if (recycler == null)
                {
                    Kill();
                    return;
                }

                if (recycler.OwnerID == 0 || !_config.Recycler.DDraw)
                    return;

                var inSphere = BaseEntity.Query.Server.GetInSphere(recycler.transform.position, _config.Recycler.Radius,
                    SensesResults, entity => entity is BasePlayer);
                if (inSphere == 0)
                    return;

                for (var i = 0; i < inSphere; i++)
                {
                    var user = SensesResults[i] as BasePlayer;
                    if (user == null || user.IsDestroyed || !user.IsConnected || user.IsNpc ||
                        !user.userID.IsSteamId()) continue;

                    if (user.Connection.authLevel < 2) SetPlayerFlag(user, BasePlayer.PlayerFlags.IsAdmin, true);

                    user.SendConsoleCommand("ddraw.text", _config.Recycler.Delay, HexToUnityColor(_config.Recycler.Color),
                        recycler.transform.position + new Vector3(0.25f, 1, 0), 
                        string.Format(_config.Recycler.Text, recycler.health, recycler._maxHealth));

                    if (user.Connection.authLevel < 2) SetPlayerFlag(user, BasePlayer.PlayerFlags.IsAdmin, false);
                }
            }

            #region Methods

            public void StartRecycling()
            {
                if (recycler.IsOn())
                    return;

                InvokeRepeating(RecycleThink, _config.Recycler.Speed, _config.Recycler.Speed);
                Effect.server.Run(recycler.startSound.resourcePath, recycler, 0U, Vector3.zero, Vector3.zero);
                recycler.SetFlag(BaseEntity.Flags.On, true);

                recycler.SendNetworkUpdateImmediate();
            }

            public void StopRecycling()
            {
                CancelInvoke(RecycleThink);

                if (!recycler.IsOn())
                    return;

                Effect.server.Run(recycler.stopSound.resourcePath, recycler, 0U, Vector3.zero, Vector3.zero);
                recycler.SetFlag(BaseEntity.Flags.On, false);
                recycler.SendNetworkUpdateImmediate();
            }

            public void RecycleThink()
            {
                var flag = false;
                var num1 = recycler.recycleEfficiency;
                for (var slot1 = 0; slot1 < 6; ++slot1)
                {
                    var slot2 = recycler.inventory.GetSlot(slot1);
                    if (slot2 != null)
                    {
                        if (Interface.CallHook("OnRecycleItem", recycler, slot2) != null)
                        {
                            if (HasRecyclable())
                                return;
                            StopRecycling();
                            return;
                        }

                        if (slot2.info.Blueprint != null)
                        {
                            if (slot2.hasCondition)
                                num1 = Mathf.Clamp01(
                                    num1 * Mathf.Clamp(slot2.conditionNormalized * slot2.maxConditionNormalized, 0.1f,
                                        1f));
                            var num2 = 1;
                            if (slot2.amount > 1)
                                num2 = Mathf.CeilToInt(Mathf.Min(slot2.amount, slot2.info.stackable * 0.1f));
                            if (slot2.info.Blueprint.scrapFromRecycle > 0)
                            {
                                var iAmount = slot2.info.Blueprint.scrapFromRecycle * num2;
                                if (slot2.info.stackable == 1 && slot2.hasCondition)
                                    iAmount = Mathf.CeilToInt(iAmount * slot2.conditionNormalized);
                                if (iAmount >= 1)
                                    recycler.MoveItemToOutput(ItemManager.CreateByName("scrap", iAmount));
                            }

                            if (!string.IsNullOrEmpty(slot2.info.Blueprint.RecycleStat))
                            {
                                var list = Pool.GetList<BasePlayer>();
                                Vis.Entities(transform.position, 3f, list, 131072);
                                foreach (var basePlayer in list)
                                    if (basePlayer.IsAlive() && !basePlayer.IsSleeping() &&
                                        basePlayer.inventory.loot.entitySource == recycler)
                                    {
                                        basePlayer.stats.Add(slot2.info.Blueprint.RecycleStat, num2,
                                            Stats.Steam | Stats.Life);
                                        basePlayer.stats.Save();
                                    }

                                Pool.FreeList(ref list);
                            }

                            slot2.UseItem(num2);
                            using (var enumerator = slot2.info.Blueprint.ingredients.GetEnumerator())
                            {
                                while (enumerator.MoveNext())
                                {
                                    var current = enumerator.Current;
                                    if (current != null && current.itemDef.shortname != "scrap")
                                    {
                                        var num3 = current.amount / slot2.info.Blueprint.amountToCreate;
                                        var num4 = 0;
                                        if (num3 <= 1.0)
                                        {
                                            for (var index = 0; index < num2; ++index)
                                                if (Random.Range(0.0f, 1f) <= num3 * (double) num1)
                                                    ++num4;
                                        }
                                        else
                                        {
                                            num4 = Mathf.CeilToInt(
                                                Mathf.Clamp(num3 * num1 * Random.Range(1f, 1f), 0.0f, current.amount) *
                                                num2);
                                        }

                                        if (num4 > 0)
                                        {
                                            var num5 = Mathf.CeilToInt(num4 / (float) current.itemDef.stackable);
                                            for (var index = 0; index < num5; ++index)
                                            {
                                                var iAmount = num4 > current.itemDef.stackable
                                                    ? current.itemDef.stackable
                                                    : num4;
                                                if (!recycler.MoveItemToOutput(ItemManager.Create(current.itemDef,
                                                    iAmount)))
                                                    flag = true;
                                                num4 -= iAmount;
                                                if (num4 <= 0)
                                                    break;
                                            }
                                        }
                                    }
                                }

                                break;
                            }
                        }
                    }
                }

                if (!flag && HasRecyclable())
                    return;
                StopRecycling();
            }

            public bool HasRecyclable()
            {
                for (var slot1 = 0; slot1 < 6; ++slot1)
                {
                    var slot2 = recycler.inventory.GetSlot(slot1);
                    if (slot2 != null)
                    {
                        var can = Interface.CallHook("CanRecycle", recycler, slot2);
                        if (can is bool)
                            return (bool) can;

                        if (slot2.info.Blueprint != null)
                            return true;
                    }
                }

                return false;
            }

            #endregion

            #region Destroy

            public void TryPickup(BasePlayer player)
            {
                if (_config.Recycler.Building && !player.CanBuild())
                {
                    player.ChatMessage("Для этого у вас должна быть способность строить!");
                    return;
                }

                if (_config.Recycler.Owner && recycler.OwnerID != player.userID)
                {
                    player.ChatMessage("Только владелец может подбирать переработчик!");
                    return;
                }

                if (recycler.SecondsSinceDealtDamage < 30f)
                {
                    player.ChatMessage("Переработчик был недавно поврежден, вы можете забрать его через 30 секунд!");
                    return;
                }

                recycler.Kill();
                
                var craft = _config.CraftsList.FirstOrDefault(x => x.Type == CraftType.Переработчик);
                if (craft == null)
                {
                    player.ChatMessage($"Обратитесь к администратору. Переработчик не может быть выдан");
                    return;
                }
                
                _instance?.GiveCraft(player, craft);
            }

            private void OnDestroy()
            {
                CancelInvoke();

                Destroy(this);
            }

            public void Kill()
            {
                Destroy(this);
            }

            #endregion
        }
        
        #endregion

        #region Car Component⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        public class CarController : FacepunchBehaviour
        {
            public BasicCar entity;
            public BasePlayer player;
            public bool isDieing;

            private bool allowHeldItems;
            private string[] disallowedItems;

            [NonSerialized] private readonly BaseEntity[] SensesResults = new BaseEntity[64];

            private void Awake()
            {
                entity = GetComponent<BasicCar>();

                allowHeldItems = !_config.Car.ActiveItems.Disable;
                disallowedItems = _config.Car.ActiveItems.BlackList;
            }

            private void Update()
            {
                UpdateHeldItems();
                CheckWaterLevel();
            }

            public void ManageDamage(HitInfo info)
            {
                if (isDieing)
                {
                    NullifyDamage(info);
                    return;
                }

                if (info.damageTypes.GetMajorityDamageType() == DamageType.Bullet)
                    info.damageTypes.ScaleAll(200);

                if (info.damageTypes.Total() >= entity.health)
                {
                    isDieing = true;
                    NullifyDamage(info);
                    OnDeath();
                    return;
                }
            }

            public void DDraw()
            {
                if (entity == null)
                {
                    Kill();
                    return;
                }

                if (entity.OwnerID == 0)
                    return;

                var inSphere = BaseEntity.Query.Server.GetInSphere(entity.transform.position, _config.Car.Radius,
                    SensesResults, ent => ent is BasePlayer);
                if (inSphere == 0)
                    return;

                for (var i = 0; i < inSphere; i++)
                {
                    var user = SensesResults[i] as BasePlayer;
                    if (user == null || user.IsDestroyed || !user.IsConnected || user.IsNpc ||
                        !user.userID.IsSteamId()) continue;

                    if (user.Connection.authLevel < 2) SetPlayerFlag(user, BasePlayer.PlayerFlags.IsAdmin, true);

                    user.SendConsoleCommand("ddraw.text", _config.Car.Delay, HexToUnityColor(_config.Car.Color),
                        entity.transform.position + new Vector3(0.25f, 1, 0), 
                        string.Format(_config.Car.Text, entity.health, entity._maxHealth));

                    if (user.Connection.authLevel < 2) SetPlayerFlag(user, BasePlayer.PlayerFlags.IsAdmin, false);
                }
            }
            
            private void NullifyDamage(HitInfo info)
            {
                info.damageTypes = new DamageTypeList();
                info.HitEntity = null;
                info.HitMaterial = 0;
                info.PointStart = Vector3.zero;
            }

            public void UpdateHeldItems()
            {
                if (player == null)
                    return;

                var item = player.GetActiveItem();
                if (item == null || item.GetHeldEntity() == null)
                    return;

                if (disallowedItems.Contains(item.info.shortname) || !allowHeldItems)
                {
                    _instance?.Reply(player, ItemNotAllowed);
                    
                    var slot = item.position;
                    item.SetParent(null);
                    item.MarkDirty();

                    Invoke(() =>
                    {
                        if (player == null || item == null) return;
                        item.SetParent(player.inventory.containerBelt);
                        item.position = slot;
                        item.MarkDirty();
                    }, 0.15f);
                }
            }

            public void CheckWaterLevel()
            {
                if (WaterLevel.Factor(entity.WorldSpaceBounds().ToBounds()) > 0.7f)                
                    StopToDie();                
            }

            public void StopToDie(bool death = true)
            {
                if (entity != null)
                {
                    entity.SetFlag(BaseEntity.Flags.Reserved1, false, false);

                    foreach (var wheel in entity.wheels)
                    {
                        wheel.wheelCollider.motorTorque = 0;
                        wheel.wheelCollider.brakeTorque = float.MaxValue;
                    }

                    entity.GetComponent<Rigidbody>().velocity = Vector3.zero;

                    if (player != null)
                        entity.DismountPlayer(player);
                }
                if (death) OnDeath();
            }

            private void OnDeath()
            {
                isDieing = true;

                if (player != null)                
                    player.EnsureDismounted();                

                Invoke(() =>
                {
                    Effect.server.Run("assets/prefabs/npc/patrol helicopter/effects/heli_explosion.prefab", transform.position);
                    _instance.NextTick(() =>
                    {
                        if (entity != null && !entity.IsDestroyed)
                            entity.DieInstantly();
                        Destroy(this);
                    });
                }, 5f);
            }

            public void Kill()
            {
                StopToDie(false);
                Destroy(this);
            }
        }

        #endregion
        
        #region Lang⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        private const string 
            NOTRESOURCES = "NOT.RESOURCES",
            PLAYERNOTFOUND = "PLAYER NOT FOUND",
            COMMANDNOTFOUND = "COMMAND NOT FOUND",
            GIVECRAFT = "GIVECRAFT",
            GIVEDEBUG = "GIVE.DEBUG",
            NOTWORKBENCH = "NOT WORKBENCH", 
            NOTCRAFTS = "NOT CRAFTS",
            CREATE = "CREATE",
            Title = "Title",
            OnGround = "OnGround",
            BuildDistance = "BuildDistance",
            OnStruct = "OnStruct",
            NotTake = "NotTake",
            ItemNotAllowed = "ItemNotAllowed";
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [NOTRESOURCES] = "Недостаточно ресурсов",
                [PLAYERNOTFOUND] = "Игрок {0} не найден",
                [COMMANDNOTFOUND] = "Комманда {0} не найдена",
                [GIVECRAFT] = "Поздравляем! Вы получили {0}",
                [GIVEDEBUG] = "Игроку {0} ({1}) выдано: {2}",
                [NOTWORKBENCH] = "Не достаточный уровень верстака для крафта!",
                [NOTCRAFTS] = "Для Вас нет доступных крафтов",
                [CREATE] = "<b>СОЗДАТЬ</b>",
                [Title] = "<b>МЕНЮ КРАФТОВ</b>",
                [OnGround] = "{0} нельзя ставить на землю!",
                [BuildDistance] = "Установка ближе {0}м к себе запрещена!",
                [OnStruct] = "{0} нельзя ставить на строения!",
                [NotTake] = "Подбор переработчиков выключен",
                [ItemNotAllowed] = "Предмет запрещён к ношению"
            }, this);
        }

        private void Reply(BasePlayer player, string key, params object[] obj)
        {
            SendReply(player, string.Format(lang.GetMessage(key, this, player.UserIDString), obj));
        }

        private void Reply(IPlayer player, string key, params object[] obj)
        {
            player.Reply(string.Format(lang.GetMessage(key, this, player.Id), obj));
        }

        #endregion
    }
}

// --- End of file: Crafts.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/GameStoresRUST.cs ---
// --- Original Local Path: KualaRust/GameStoresRUST.cs ---

﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using WebSocketSharp;

namespace Oxide.Plugins
{
    [Info("GameStoresRUST", "HOUGAN & Sstine # GAMESTORES", "0.3.5")]
    public class GameStoresRUST : RustPlugin
    {
        #region References

        [PluginReference] private Plugin ImageLibrary;

        #endregion

        #region Classes

        private static class Delays
        {
            [JsonProperty("Игроки с активными запросами к АПИ")]
            public static List<ulong> ItemList = new List<ulong>();
            [JsonProperty("Количество запросов за последнюю секунду")]
            public static int RequestPerSecond = 0;
            [JsonProperty("Ограничение запросов в секунду")]
            public static int RequestPerSecondLimit = 20;

            public static bool CanRequest(BasePlayer player)
            {
                if (RequestPerSecond > RequestPerSecondLimit)
                {
                    return false;
                }

                if (ItemList.Contains(player.userID))
                {
                    player.ChatMessage($"Пожалуйста, дождитесь <<окончания>> предыдущего действия!");
                    return false;
                }
                return true;
            }

            public static void FinishRequest(BasePlayer player)
            {
                if (ItemList.Contains(player.userID))
                    ItemList.Remove(player.userID);
            }

            public static IEnumerator MakeRequest(BasePlayer player)
            {
                RequestPerSecond++;

                if (ItemList.Contains(player.userID)) yield return null;
                ItemList.Add(player.userID);

                yield return new WaitForSeconds(3f);
                if (ItemList.Contains(player.userID))
                    ItemList.Remove(player.userID);
            }
        }

        private class Stats
        {

        }

        private class Configuration
        {
            public class API
            {
                [JsonProperty("ИД магазина в сервисе")]
                public string ShopID = "UNDEFINED";
                [JsonProperty("ИД сервера в сервисе")]
                public string ServerID = "UNDEFINED";
                [JsonProperty("Секретный ключ (не распространяйте его)")]
                public string SecretKey = "UNDEFINED";
            }

            public class Interface
            {
                [JsonProperty("Включить изображение корзины")]
                public bool BucketEnable = true;
                [JsonProperty("Включить отображение названий предметов")]
                public bool TextShow = true;
                [JsonProperty("Ссылка на изображение корзины (BUCKET - стандартное изображение)")]
                public string BucketURL = "BUCKET";
                [JsonProperty("Количество предметов на строке")]
                public int ItemOnString = 7;
                [JsonProperty("Количество строк в интерфейсе")]
                public int StringAmount = 3;
                [JsonProperty("Сторона одного предмета")]
                public int ItemSide = 150;
                [JsonProperty("Отступ между предметами")]
                public int ItemMargin = 5;
            }

            public class TOP
            {
                [JsonProperty("Отправлять данные топа игроков")]
                public bool UseTop = true;
            }

            [JsonProperty("Настройки API плагина")]
            public API APISettings = new API();
            [JsonProperty("Настройки интерфейса плагина")]
            public Interface InterfaceSettings = new Interface();
            [JsonProperty("Настройки статистики сервера")]
            public TOP TOPSettings = new TOP();
        }

        private class WItem
        {
            public string ID;
            public string Name;
            public int ItemID;
            public int Amount;
            public string ShortName;
            public string Command;
            public string ImageUrl;

            public bool Blocked;
            public double Block_Date = 0;
            public bool IsBlueprint;
            public bool IsCommand;
            public bool IsItem;

            public WItem(Dictionary<string, object> data, bool show = true)
            {
                try
                {
                    if (data.ContainsKey("id")) ID = data["id"].ToString();

                    if (data.ContainsKey("name")) Name = data["name"].ToString();
                    if (data.ContainsKey("item_id")) ItemID = System.Convert.ToInt32(data["item_id"]);
                    if (data.ContainsKey("amount")) Amount = System.Convert.ToInt32(data["amount"]);
                    if (data.ContainsKey("command")) Command = data["command"].ToString();
                    if (data.ContainsKey("img")) ImageUrl = data["img"].ToString();

                    if (data.ContainsKey("blocked")) Blocked = bool.Parse(data["blocked"].ToString());

                    if (data.ContainsKey("block_date") && data["block_date"] is int)
                    {
                        double.TryParse(data["block_date"].ToString(), out Block_Date);
                    }

                    if (data.ContainsKey("type"))
                    {
                        IsBlueprint = data["type"].ToString() == "bp";
                        IsCommand = data["type"].ToString() == "command";
                        IsItem = data["type"].ToString() == "item";
                    }

                    if (ItemID != 0)
                    {
                        var itemInfo = ItemManager.FindItemDefinition(ItemID);
                        if (itemInfo != null) ShortName = itemInfo.shortname;
                        else if (IDToShortName.ContainsKey(ItemID))
                        {
                            itemInfo = ItemManager.FindItemDefinition(IDToShortName[ItemID]);
                            if (itemInfo == null) return;

                            ShortName = itemInfo.shortname;
                        }
                    }

                    var imageLibrary = instance.plugins.Find("ImageLibrary");
                    if (imageLibrary != null)
                    {
                        if (ItemID == 0)
                        {
                            if ((bool)imageLibrary.Call("HasImage", $"IconGS.{ID}"))
                            {
                                string probablyId = (string)imageLibrary.Call("GetImage", $"IconGS.{ID}");
                                if (!probablyId.IsNullOrEmpty() && probablyId != instance.NoImageID && probablyId != instance.LoadingImageID)
                                    ImageUrl = probablyId;
                                return;
                            }

                            if (!ImageUrl.IsNullOrEmpty())
                            {
                                imageLibrary.Call("AddImage", ImageUrl.Replace("https", "http"), $"IconGS.{ID}");
                            }
                        }
                        else
                        {
                            string probablyId = (string)imageLibrary.Call("GetImage", ShortName);
                            if (!probablyId.IsNullOrEmpty() && probablyId != instance.NoImageID && probablyId != instance.LoadingImageID)
                                ImageUrl = probablyId;
                        }
                    }
                }
                catch (NullReferenceException e)
                {
                    Interface.Oxide.LogError(JsonConvert.SerializeObject(data));
                }
            }
        }

        #endregion

        #region Variables

        private static bool initialization = false;
        private static bool Initialized = false;
        private static GameStoresRUST instance;
        private static Configuration Settings = new Configuration();
        private string ShopURL = "UNDEFINED";
        private int StartBalance = 0;
        public string NoImageID = "";
        public string LoadingImageID = "";
        private Coroutine LoadingCoroutine;
        private Dictionary<int, Dictionary<ulong, int>> ListTimeOutCommand = new Dictionary<int, Dictionary<ulong, int>>();
        private Dictionary<ulong, List<int>> playersBasketCache = new Dictionary<ulong, List<int>>();
        private HashSet<ulong> ListBannedCommandUserID = new HashSet<ulong>();
        private Timer TimerCheckInstant;
        private string MainApiLink = $"https://gamestores.ru/api/";
        private string ReserveApiLink = $"https://gs.gamestores.ru/api/";
        //private string BaseRequest => $"https://gamestores.ru/api/?shop_id={Settings.APISettings.ShopID}&secret={Settings.APISettings.SecretKey}{(!Settings.APISettings.ServerID.IsNullOrEmpty() && Settings.APISettings.ServerID != "0" && Settings.APISettings.ServerID != "1" && Settings.APISettings.ServerID != "UNDEFINED" ? $"&server={Settings.APISettings.ServerID}" : "")}";
        private string BaseRequestParams => $"?shop_id={Settings.APISettings.ShopID}&secret={Settings.APISettings.SecretKey}{(!Settings.APISettings.ServerID.IsNullOrEmpty() && Settings.APISettings.ServerID != "0" && Settings.APISettings.ServerID != "1" && Settings.APISettings.ServerID != "UNDEFINED" ? $"&server={Settings.APISettings.ServerID}" : "")}";
        private string BaseRequest = "";
        #endregion

        #region Interface

        private int TryImageCounter = 0;
        private void OnServerInitialized()
        {
            BaseRequest = MainApiLink + BaseRequestParams;
            if (Settings.APISettings.ServerID != "0" && Settings.APISettings.ServerID != "UNDEFINED")
            {
                TimerCheckInstant = timer.Repeat(20, 0, CheckInstant);
            } else
            {
                LogAction(null, $"Некорректный ServerID, автоматическая выдача команд невозможна");
                PrintError($"Incorrect ServerID, reciving auto commands (Products) disabled");
            }
            
            if (!ImageLibrary)
            {
                if (TryImageCounter < 3)
                {
                    LogAction(null, $"ImageLibrary is not initialized, try again in 1 sec.", true);
                    TryImageCounter++;

                    timer.Once(1, OnServerInitialized);
                    return;
                }
                else LogAction(null, $"Starting without ImageLibrary", true);
            }

            if (ImageLibrary)
            {
                NoImageID = (string)ImageLibrary.Call("GetImage", "NONE");
                LoadingImageID = (string)ImageLibrary.Call("GetImage", "LOADING");
            }

            if (Settings.InterfaceSettings.BucketURL.Contains("http") && plugins.Find("ImageLibrary") != null)
            {
                ImageLibrary.Call("AddImage", Settings.InterfaceSettings.BucketURL, "GameStoresRUSTBucket");
                LoadingCoroutine = ServerMgr.Instance.StartCoroutine(WaitForLoad());
            }
            else
            {
                //BasePlayer.activePlayerList.ForEach(OnPlayerInit);
                for (var i = 0; i < BasePlayer.activePlayerList.Count; i++)
                {
                    OnPlayerConnected(BasePlayer.activePlayerList[i]);
                }
            }

            instance = this;
            if (!Settings.TOPSettings.UseTop) Unsubscribe(nameof(OnEntityDeath));
            if (!Settings.TOPSettings.UseTop) Unsubscribe(nameof(OnPlayerDisconnected));

            if (Settings.APISettings.ShopID == "UNDEFINED" || Settings.APISettings.SecretKey == "UNDEFINED")
            {
                LogAction(null, $"Verify that plugin is installed correct! Some of API settings are 'UNDEFINED'", true, true);
                return;
            }

            timer.Once(2, FetchShopUrl);

            timer.Every(1, () => Delays.RequestPerSecond = 0);

            ListTimeOutCommand[0] = new Dictionary<ulong, int>();
            ListTimeOutCommand[1] = new Dictionary<ulong, int>();
            ListTimeOutCommand[2] = new Dictionary<ulong, int>();

            int totalTick = 0;
            int tick = 0;
            timer.Repeat(2, 0, () =>
            {
                if (totalTick == 30)
                {
                    totalTick = 0;
                    ListBannedCommandUserID.Clear();
                }
                ListTimeOutCommand[0].Clear();
                if (tick == 3 || tick == 6)
                {
                    ListTimeOutCommand[1].Clear();
                }

                if (tick == 6)
                {
                    tick = 0;
                    ListTimeOutCommand[2].Clear();
                }
                tick++;
                totalTick++;
            });
        }

        private IEnumerator WaitForLoad()
        {
            while (!(bool)ImageLibrary.Call("HasImage", "GameStoresRUSTBucket"))
            {
                PrintError($"Image of bucket is loading!");
                yield return new WaitForSeconds(1);
            }

            PrintWarning("Image of bucket loaded correct!");
            //BasePlayer.activePlayerList.ForEach(OnPlayerInit);
            for (var i = 0; i < BasePlayer.activePlayerList.Count; i++)
            {
                OnPlayerConnected(BasePlayer.activePlayerList[i]);
            }
            yield return 0;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                Settings = Config.ReadObject<Configuration>();
                if (Settings?.APISettings == null) LoadDefaultConfig();
            }
            catch
            {
                LogAction(null, $"Error reading config, creating one new config!", true, true);
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig()
        {
            Settings = new Configuration();
        }

        protected override void SaveConfig() => Config.WriteObject(Settings);

        private void Unload()
        {
            //if (Initialized) StatHandler.SendStats();

            if (LoadingCoroutine != null) ServerMgr.Instance.StopCoroutine(LoadingCoroutine);
            //BasePlayer.activePlayerList.ForEach(p => CuiHelper.DestroyUi(p, IconLayer));
            //BasePlayer.activePlayerList.ForEach(p => CuiHelper.DestroyUi(p, StoreLayer));
            foreach (var pl in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(pl, IconLayer);
                CuiHelper.DestroyUi(pl, StoreLayer);
                OnPlayerConnected(pl);
            }
        }

        #endregion

        #region Hooks

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            StatHandler.AddStat(new StatHandler.TimeStat(player));
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player.IsReceivingSnapshot)
            {
                NextTick(() => OnPlayerConnected(player));
                return;
            }

            if (Settings.InterfaceSettings.BucketEnable)
                InitializeIcon(player);
        }

        #endregion

        #region Stats

        private static class StatHandler
        {
            internal class Stat
            {
                [JsonProperty("dataType")]
                public string DataType;
            }
            internal class KillStat : Stat
            {
                [JsonProperty("player_id")]
                public string PlayerUserId;
                [JsonProperty("victim_id")]
                public string VictimUserID;
                [JsonProperty("type")]
                public string Type;
                [JsonProperty("time")]
                public string Time;
            }
            internal class TimeStat : Stat
            {
                [JsonProperty("player_id")]
                public string PlayerID;
                [JsonProperty("username")]
                public string PlayerName;
                [JsonProperty("played")]
                public string Played;
                [JsonProperty("time")]
                public string Time;

                public TimeStat(BasePlayer player)
                {
                    PlayerID = player.UserIDString;
                    PlayerName = player.displayName;
                    DataType = "leave";
                    Played = player.secondsConnected.ToString();
                    Time = CurrentTime().ToString();
                }
            }

            private static List<Stat> Stats = new List<Stat>();
            public static void AddStat(Stat stat)
            {
                Stats.Add(stat);
                if (Stats.Count > 10)
                {
                    SendStats();
                    Stats.Clear();
                }
            }

            public static void SendStats()
            {
                try
                {


                    if (!Initialized)
                    {
                        instance.LogAction(null, $"Sending stats error! Plugin not initialized", true, true);
                        return;
                    }
                    if (Stats.Count == 0)
                    {
                        instance.LogAction(null, $"Nothing to send", true);
                        return;
                    }

                    var obj = JsonConvert.SerializeObject(Stats);
                    RequestPost($"&method=topData&data={obj}", (i, s) => {
                        if (i != 200)
                            return;

                        Dictionary<string, object> response = JsonConvert.DeserializeObject<Dictionary<string, object>>(s, new KeyValuesConverter());
                        if (response.ContainsKey("result") && response["result"].ToString() == "success")
                        {
                            instance.LogAction(null, $"GameStores sent stats successful!", true);
                            Stats.Clear();
                        }
                        else
                        {
                            instance.LogAction(null, $"Sending stats error!", true, true);
                        }
                    });


                }
                catch
                {
                    // ignored 
                }
            }
        }

        [ConsoleCommand("sendtop")]
        private void CmdSendTop(ConsoleSystem.Arg args)
        {
            if (args.Player() != null && !args.Player().IsAdmin) return;

            StatHandler.SendStats();
        }

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null || info == null || info.Initiator == null)
                return;
            if (Settings.TOPSettings.UseTop)
            {
                BaseEntity initiator = info.Initiator;

                if (entity as BasePlayer == null && initiator as BasePlayer == null)
                    return;
                StatHandler.KillStat stat = new StatHandler.KillStat();

                if (initiator as BasePlayer != null) stat.PlayerUserId = initiator.ToPlayer().UserIDString;
                else if (initiator.PrefabName.Contains("agents")) stat.PlayerUserId = "1";
                else return;

                if (entity as BasePlayer != null)
                {
                    stat.VictimUserID = entity.ToPlayer().UserIDString;
                    stat.Type = entity.ToPlayer().IsSleeping() ? "sleeper" : "kill";
                }
                else if (entity.PrefabName.Contains("agents"))
                {
                    stat.VictimUserID = "1";
                    stat.Type = "kill";
                }
                else
                {
                    return;
                }

                stat.DataType = "death";

                stat.Time = CurrentTime().ToString();
                StatHandler.AddStat(stat);
            }
        }

        #endregion

        #region Commands

        [ChatCommand("store")]
        private void CmdChatStore(BasePlayer player, string command, string[] args)
        {
            if (player == null || player.Connection == null || player.IsSleeping())
            {
                return;
            }

            if (!Initialized)
            {
                errorsReq++;
                player.ChatMessage($"Плагин магазина запущен не корретно");
                return;

            }

            if (args.Length == 1 && args[0].ToLower() == "hide")
            {
                CuiHelper.DestroyUi(player, IconLayer);
            }
            else
            {
                if (!Delays.CanRequest(player)) return;
                InitializeStore(player, 0, true);
            }
        }

        [ConsoleCommand("UI_GameStoresRUST")]
        private void CmdConsoleCommand(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (player == null) return;

            if (ListBannedCommandUserID.Contains(player.userID))
            {
                player.ChatMessage("Вы сделали слишком много запросов. Отдохните немного, скоро возможность выполнять действие к вам вернется.");
                return;
            }

            if (ListTimeOutCommand[0].ContainsKey(player.userID) == false)
                ListTimeOutCommand[0][player.userID] = 1;
            else
                ListTimeOutCommand[0][player.userID] = ListTimeOutCommand[0][player.userID] + 1;

            if (ListTimeOutCommand[1].ContainsKey(player.userID) == false)
                ListTimeOutCommand[1][player.userID] = 1;
            else
                ListTimeOutCommand[1][player.userID] = ListTimeOutCommand[1][player.userID] + 1;

            if (ListTimeOutCommand[2].ContainsKey(player.userID) == false)
                ListTimeOutCommand[2][player.userID] = 1;
            else
                ListTimeOutCommand[2][player.userID] = ListTimeOutCommand[2][player.userID] + 1;

            if (ListTimeOutCommand[0][player.userID] >= 10 || ListTimeOutCommand[1][player.userID] >= 20 || ListTimeOutCommand[2][player.userID] >= 30)
            {
                this.ListBannedCommandUserID.Add(player.userID);
            }

            if (!args.HasArgs(1))
            {
                player.SendConsoleCommand("chat.say /store");
                return;
            }

            switch (args.Args[0].ToLower())
            {
                case "page":
                    {
                        int page = 0;
                        if (!args.HasArgs(2) || !int.TryParse(args.Args[1], out page)) return;
                        InitializeStore(player, page, false);
                        break;
                    }
                case "help":
                    {
                        string helpLayer = StoreLayer + ".Help";
                        CuiHelper.DestroyUi(player, helpLayer);
                        CuiHelper.DestroyUi(player, StoreLayer);

                        CuiElementContainer container = new CuiElementContainer();
                        container.Add(new CuiPanel
                        {
                            CursorEnabled = true,
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                            Image = { Color = "0 0 0 0.9" },
                        }, "Overlay", helpLayer);

                        container.Add(new CuiLabel
                        {
                            RectTransform = { AnchorMin = "0 0.6", AnchorMax = "1 0.78", OffsetMax = "0 0" },
                            Text = { Text = "ИНСТРУКЦИЯ ПОЛЬЗОВАТЕЛЯ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 34 }
                        }, helpLayer);

                        container.Add(new CuiLabel
                        {
                            RectTransform = { AnchorMin = "0 0.3", AnchorMax = "1 0.72", OffsetMax = "0 0" },
                            Text = { Text = $"Здесь вы можете забрать товары приобретенные у нас в магазине!\n" +
                                                     $"Пополнить счёт можно различными способами: электронные кошельки, карты и т.д.\n" +
                                                     $"Авторизация в магазине происходит при помощи вашего аккаунта STEAM",
                                Font = "robotocondensed-regular.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter
                        }
                        }, helpLayer);

                        string addText = StartBalance > 0 ? $"\n<size=18>При первой авторизации вы получите в подарок <b>{StartBalance} рублей</b>!</size>" : "";
                        container.Add(new CuiLabel
                        {
                            RectTransform = { AnchorMin = "0 0.1", AnchorMax = "1 0.48", OffsetMax = "0 0" },
                            Text = { Text = $"" +
                                                     $"{addText}\n{ShopURL.ToUpper()}", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 32}
                        }, helpLayer);
                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                            Button = { Color = "0 0 0 0", Close = helpLayer, Command = "chat.say /store" },
                            Text = { Text = "" }
                        }, helpLayer);

                        CuiHelper.AddUi(player, container);
                        break;
                    }
                case "take":
                    {
                       
                        if (!args.HasArgs(3)) return;

                        int index = 0, id = 0;
                        if (!int.TryParse(args.Args[1], out index) || !int.TryParse(args.Args[2], out id)) return;

                        if (!playersBasketCache.ContainsKey(player.userID))
                        {
                            player.ChatMessage("Предмет не найден, попробуйте перезапустить корзину");
                            return;
                        } else if (!playersBasketCache[player.userID].Contains(id))
                        {
                            player.ChatMessage("Предмет не найден, попробуйте перезапустить корзину");
                            return;
                        }
                                            
                        if (args.HasArgs(5) && args.Args[3].ToLower() == "blocked")
                        {
                            double left = 0;
                            if (!double.TryParse(args.Args[4], out left)) return;

                            TimeSpan span = TimeSpan.FromSeconds(left);

                            string text = "";
                            if (span.Days >= 1)
                                text += $"{span.Days} дн. ";
                            if (span.Hours >= 1)
                                text += $"{span.Hours} ч. ";
                            if (span.Minutes >= 1)
                                text += $"{span.Minutes} мин. ";
                            if (span.Seconds >= 1)
                                text += $"{span.Seconds} сек.";

                            ShowNotify(player, "Вы не можете забрать этот предмет из корзины!\n" +
                                               $"До его разблокировки осталось: {text}");
                            return;
                        }

                        ShowNotify(player, "Подождите, ваш запрос обрабатывается!");
                        CuiElementContainer container = new CuiElementContainer();

                        if (!Delays.CanRequest(player))
                        {
                            ShowNotify(player, "Подождите, ваш предыдущий запрос ещё обрабатывается!");
                            container.Add(new CuiButton
                            {
                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                Button = { Color = "1 1 1 0.2", Close = StoreLayer + ".BlockPanel." + index + ".Open", Command = $"UI_GameStoresRUST take {index} {id}" },
                                Text = { Text = "ПОДОЖДИТЕ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", Color = "1 1 1 0.4", FontSize = 24 }
                            }, StoreLayer + ".BlockPanel." + index, StoreLayer + ".BlockPanel." + index + ".Open");

                            CuiHelper.AddUi(player, container);
                            return;
                        }

                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                            Button = { FadeIn = 1f, Color = "1 1 1 0.2", Close = StoreLayer + ".BlockPanel." + index + ".Open", Command = $"UI_GameStoresRUST take {index} {id}", Material = "" },
                            Text = { Text = "ПОДОЖДИТЕ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", Color = "1 1 1 0.4", FontSize = 24 }
                        }, StoreLayer + ".BlockPanel." + index, StoreLayer + ".BlockPanel." + index + ".Open");
                        CuiHelper.AddUi(player, container);

                        LogAction(null, $"---------------------------------");
                        LogAction(player, $"Запрос на получение предмета: {id}");
                        Request($"&item=true&steam_id={player.UserIDString}&id={id}", (i, s) =>
                        {
                            switch (i)
                            {
                                case 0:
                                    LogAction(player, $"API не ответило на запрос: {id}");
                                    PrintError("Api does not responded to a request");
                                    if (player != null)
                                    {
                                        player.ChatMessage($"Непредвиденная ошибка со стороны сервера, просим прощения!");
                                        CuiHelper.DestroyUi(player, StoreLayer);
                                    }
                                    break;
                                case 200:
                                    Dictionary<string, object> response = JsonConvert.DeserializeObject<Dictionary<string, object>>(s, new KeyValuesConverter());
                                    if (!response.ContainsKey("data"))
                                    {
                                        LogAction(player, $"Ошибка получения товара, отсутствует Data [{id}]");

                                        container.Clear();
                                        CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel." + index + ".Open");
                                        container.Add(new CuiButton
                                        {
                                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                            Button = { FadeIn = 1f, Color = "1 0.5 0.5 0.2", Close = StoreLayer + ".BlockPanel." + index + ".Open", Command = $"UI_GameStoresRUST take {index} {id}", Material = "" },
                                            Text = { Text = "ОШИБКА\nПОЛУЧЕНИЯ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", Color = "1 0.7 0.7 1", FontSize = 24 }
                                        }, StoreLayer + ".BlockPanel." + index, StoreLayer + ".BlockPanel." + index + ".Open");
                                        ShowNotify(player, "Произошла непредвиденная ошибка, попробуйте позже!\n" +
                                                           "Ваш предмет в безопасности, не переживайте!");
                                        CuiHelper.AddUi(player, container);
                                        return;
                                    }

                                    LogAction(player, $"Товар отмечен полученным [{id}]");
                                    Request($"&gived=true&id={id}", (code, newResponse) =>
                                    {
                                        if (code != 200 || JsonConvert.DeserializeObject<JObject>(newResponse)["result"].ToString() != "success")
                                        {
                                            container.Clear();
                                            CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel." + index + ".Open");
                                            container.Add(new CuiButton
                                            {
                                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                                Button = { FadeIn = 1f, Color = "1 0.5 0.5 0.2", Close = StoreLayer + ".BlockPanel." + index + ".Open", Command = $"UI_GameStoresRUST take {index} {id}", Material = "" },
                                                Text = { Text = "ОШИБКА\nПОЛУЧЕНИЯ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", Color = "1 0.7 0.7 1", FontSize = 24 }
                                            }, StoreLayer + ".BlockPanel." + index, StoreLayer + ".BlockPanel." + index + ".Open");
                                            ShowNotify(player, "Произошла непредвиденная ошибка, попробуйте позже!\n" +
                                                               "Ваш предмет в безопасности, не переживайте!");
                                            CuiHelper.AddUi(player, container);
                                            return;
                                        }
                                        ProcessTake(player, response["data"] as Dictionary<string, object>);
                                    }, player);

                                    container.Clear();
                                    CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel." + index + ".Open");
                                    container.Add(new CuiButton
                                    {
                                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                        Button = { FadeIn = 1f, Color = "0.5 1 0.5 0.2", Material = "" },
                                        Text = { Text = "УСПЕШНО\nПОЛУЧЕНО", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", Color = "0.7 1 0.7 1", FontSize = 24 }
                                    }, StoreLayer + ".BlockPanel." + index, StoreLayer + ".BlockPanel." + index + ".Open");

                                    if (playersBasketCache.ContainsKey(player.userID) && playersBasketCache[player.userID].Contains(id))
                                        playersBasketCache[player.userID].RemoveAt(playersBasketCache[player.userID].IndexOf(id));

                                    CuiHelper.AddUi(player, container);
                                    break;
                                case 404:
                                    LogAction(player, $"Сайт не ответил на запрос: {id}");
                                    player.ChatMessage($"Непредвиденная ошибка со стороны сервера, просим прощения!");
                                    CuiHelper.DestroyUi(player, StoreLayer);
                                    LogAction(null, "Response code: 404, please check your configurations", true);
                                    break;
                            }
                        }, player);
                        break;
                    }
            }
        }

        #endregion

        #region Interface

        private static string StoreLayer = "UI_GameStoresRUST_Store";
        private void InitializeStore(BasePlayer player, int page, bool first = true)
        {
            CuiElementContainer container = new CuiElementContainer();

            if (first)
            {
                CuiHelper.DestroyUi(player, StoreLayer);
                container.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Image = { Color = "0 0 0 0.8" },
                }, "Overlay", StoreLayer);

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.3 0.9", AnchorMax = "0.7 1", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0" },
                    Text = { Text = "КОРЗИНА СЕРВЕРА", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 32, Color = "1 1 1 0.6" }
                }, StoreLayer, StoreLayer + ".ITT");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.8 0.9", AnchorMax = "0.935 1", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0", Close = StoreLayer, Command = "closemenu" },
                    Text = { Text = "ВЫХОД", Align = TextAnchor.MiddleRight, Font = "robotocondensed-regular.ttf", FontSize = 28 }
                }, StoreLayer);
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "0 -0", OffsetMax = "0 20" },
                    Text = { Text = "Это ваша корзина с покупками, вы можете забрать их в любой момент", Align = TextAnchor.UpperCenter, Font = "robotocondensed-regular.ttf", Color = "1 1 1 0.4" }
                }, StoreLayer + ".ITT");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.065 0.9", AnchorMax = "0.2 1", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0", Command = "UI_GameStoresRUST help" },
                    Text = { Text = "ПОМОЩЬ", Align = TextAnchor.MiddleLeft, Font = "robotocondensed-regular.ttf", FontSize = 28 }
                }, StoreLayer);
            }

            CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel");
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.9", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0" }
            }, StoreLayer, StoreLayer + ".BlockPanel");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1.1", OffsetMax = "0 0" },
                Text = { Text = "Подождите, мы обрабатываем ваш запрос...", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 34 }
            }, StoreLayer + ".BlockPanel", StoreLayer + ".BlockPanel.Text");

            CuiHelper.AddUi(player, container);
            
            Request($"&method=basket&steam_id={player.UserIDString}", (code, response) =>
            {
               
                switch (code)
                {
                    default:
                        {
                            CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel.Text");
                            CuiElementContainer secondContainer = new CuiElementContainer();
                            secondContainer.Add(new CuiLabel
                            {
                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                Text = { Text = "Корзина временно недоступна, попробуйте позже", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 38 }
                            }, StoreLayer + ".BlockPanel", StoreLayer + ".BlockPanel.Text");
                            CuiHelper.AddUi(player, secondContainer);
                            break;
                        }
                    case 200:
                        {
                            var firstInfo = JsonConvert.DeserializeObject<Dictionary<string, object>>(response, new KeyValuesConverter());
                            if (firstInfo.ContainsKey("result"))
                            {
                                if (firstInfo["result"].ToString() == "fail")
                                {
                                    if (firstInfo["code"].ToString() == "104")
                                    {
                                        CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel.Text");
                                        CuiElementContainer secondContainer = new CuiElementContainer();
                                        secondContainer.Add(new CuiLabel
                                        {
                                            RectTransform = { AnchorMin = "0 0.1", AnchorMax = "1 1", OffsetMax = "0 0" },
                                            Text = { Text = "Ваша корзина пуста", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 34 }
                                        }, StoreLayer + ".BlockPanel", StoreLayer + ".BlockPanel.Text");
                                        CuiHelper.AddUi(player, secondContainer);
                                    }
                                    if (firstInfo["code"].ToString() == "105")
                                    {
                                        CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel.Text");
                                        CuiElementContainer secondContainer = new CuiElementContainer();
                                        secondContainer.Add(new CuiLabel
                                        {
                                            RectTransform = { AnchorMin = "0 0.1", AnchorMax = "1 1", OffsetMax = "0 0" },
                                            Text = { Text = "Вы не авторизованы в магазине!\n" +
                                                        "Ссылку на авторизацию вы можете найти в разделе 'помощь'", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 34 }
                                        }, StoreLayer + ".BlockPanel", StoreLayer + ".BlockPanel.Text");
                                        CuiHelper.AddUi(player, secondContainer);
                                    }
                                }
                                else
                                {
                                    CuiElementContainer secondContainer = new CuiElementContainer();

                                    if (!(firstInfo["data"] is List<object>))
                                    {
                                        PrintError("Unkown error #1");
                                        CuiHelper.DestroyUi(player, StoreLayer);
                                        return;
                                    }
                                    List<object> data = firstInfo["data"] as List<object>;
                                    List<WItem> wItems = new List<WItem>();

                                    foreach (var check in data.Skip(page * 21).Take(21))
                                    {
                                        wItems.Add(new WItem(check as Dictionary<string, object>));

                                    }
                                    if (playersBasketCache.ContainsKey(player.userID))
                                        playersBasketCache[player.userID].Clear();

                                    foreach (Dictionary<string, object> product in data)
                                    {
                                        if (product.ContainsKey("id"))
                                        {
                                            if (!playersBasketCache.ContainsKey(player.userID))
                                                playersBasketCache.Add(player.userID, new List<int>());

                                            playersBasketCache[player.userID].Add(Convert.ToInt32(product["id"]));
                                        }
                                            
                                    }
                                    secondContainer.Add(new CuiLabel
                                    {
                                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.14", OffsetMax = "0 0" },
                                        Text = { Text = (page + 1).ToString(), Align = TextAnchor.MiddleCenter, FontSize = 34 }
                                    }, StoreLayer + ".BlockPanel");

                                    secondContainer.Add(new CuiButton
                                    {
                                        RectTransform = { AnchorMin = "0.4 0.14", AnchorMax = "0.4 0.14", OffsetMin = "-40 -125", OffsetMax = "125 40" },
                                        Button = { Color = "0 0 0 0", Material = "", Command = page > 0 ? $"UI_GameStoresRUST page {page - 1}" : "" },
                                        Text = { Text = "<", Color = page > 0 ? "1 1 1 1" : "1 1 1 0.2", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 80 }
                                    }, StoreLayer + ".BlockPanel");

                                    secondContainer.Add(new CuiButton
                                    {
                                        RectTransform = { AnchorMin = "0.6 0.14", AnchorMax = "0.6 0.14", OffsetMin = "-125 -125", OffsetMax = "40 40" },
                                        Button = { Color = "0 0 0 0", Material = "", Command = (page + 1) * 21 < data.Count ? $"UI_GameStoresRUST page {page + 1}" : "" },
                                        Text = { Text = ">", Color = (page + 1) * 21 < data.Count ? "1 1 1 1" : "1 1 1 0.2", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 80 }
                                    }, StoreLayer + ".BlockPanel");


                                    double xSwitch = 0;
                                    double ySwitch = 0;
                                    for (int i = 0; i < Settings.InterfaceSettings.ItemOnString * Settings.InterfaceSettings.StringAmount; i++)
                                    {
                                        UI_RecountPosition(ref xSwitch, ref ySwitch, i, Settings.InterfaceSettings.ItemOnString * Settings.InterfaceSettings.StringAmount);

                                        secondContainer.Add(new CuiButton
                                        {
                                            RectTransform = { AnchorMin = "0.495 0.55", AnchorMax = "0.495 0.55", OffsetMin = $"{xSwitch} {ySwitch - Settings.InterfaceSettings.ItemSide}", OffsetMax = $"{xSwitch + Settings.InterfaceSettings.ItemSide} {ySwitch}" },
                                            Button = { Color = "1 1 1 0.2", Command = $"" },
                                            Text = { Text = "" }
                                        }, StoreLayer + ".BlockPanel", StoreLayer + $".BlockPanel.{i}");
                                    }

                                    /*if (player.IsAdmin) 
                                    {
                                        LogToFile("Test", "123 - " + JsonConvert.SerializeObject(wItems), this);  
                                    } */
                                    foreach (var check in wItems.Select((i, t) => new { A = i, B = t }))
                                    {
                                        if (check.A.IsBlueprint)
                                        {
                                            if (plugins.Find("ImageLibrary") != null)
                                            {
                                                secondContainer.Add(new CuiElement
                                                {
                                                    Parent = StoreLayer + ".BlockPanel." + check.B,
                                                    Components =
                                                {
                                                    new CuiRawImageComponent { Png = (string) plugins.Find("ImageLibrary").Call("GetImage", "blueprintbase") },
                                                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                                                }
                                                });
                                            }
                                            else
                                            {
                                                secondContainer.Add(new CuiElement
                                                {
                                                    Parent = StoreLayer + ".BlockPanel." + check.B,
                                                    Components =
                                                {
                                                    new CuiRawImageComponent { Url = "https://gamestores.ru/img/games/rust/blueprintbase.png" },
                                                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                                                }
                                                });
                                            }
                                        }
                                        if (!check.A.ImageUrl.Contains("http"))
                                        {
                                            secondContainer.Add(new CuiElement
                                            {
                                                Parent = StoreLayer + ".BlockPanel." + check.B,
                                                Components =
                                            {
                                                new CuiRawImageComponent { Png = check.A.ImageUrl },
                                                new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                                            }
                                            });
                                        }
                                        else
                                        {
                                            secondContainer.Add(new CuiElement
                                            {
                                                Parent = StoreLayer + ".BlockPanel." + check.B,
                                                Components =
                                            {
                                                new CuiRawImageComponent { Url = check.A.ImageUrl },
                                                new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                                            }
                                            });
                                        }

                                        if (check.A.Amount > 1)
                                        {
                                            secondContainer.Add(new CuiLabel
                                            {
                                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 5", OffsetMax = "-5 0" },
                                                Text = { Text = "x" + check.A.Amount, Align = TextAnchor.LowerRight, Font = "robotocondensed-regular.ttf", FontSize = 24 }
                                            }, StoreLayer + ".BlockPanel." + check.B);
                                        }

                                        if (check.A.Blocked)
                                        {
                                            double left = check.A.Block_Date - CurrentTime();

                                            secondContainer.Add(new CuiButton
                                            {
                                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                                Button = { Color = "1 0.5 0.5 0.2", Command = $"UI_GameStoresRUST take {check.B} {check.A.ID} blocked {left}" },
                                                Text = { Text = "", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 38 }
                                            }, StoreLayer + ".BlockPanel." + check.B, StoreLayer + ".BlockPanel." + check.B + ".Open");
                                        }
                                        else
                                        {
                                            secondContainer.Add(new CuiButton
                                            {
                                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                                Button = { Color = "0 0 0 0", Close = StoreLayer + ".BlockPanel." + check.B + ".Open", Command = $"UI_GameStoresRUST take {check.B} {check.A.ID}" },
                                                Text = { Text = "" }
                                            }, StoreLayer + ".BlockPanel." + check.B, StoreLayer + ".BlockPanel." + check.B + ".Open");
                                        }

                                        secondContainer.Add(new CuiLabel
                                        {
                                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "0 -22.5", OffsetMax = "0 0" },
                                            Text = { Text = check.A.Name, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 16, Color = "1 1 1 0.8" }
                                        }, StoreLayer + ".BlockPanel." + check.B);
                                    }

                                    CuiHelper.AddUi(player, secondContainer);
                                    CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel.Text");
                                }
                            }
                            break;
                        }
                }
            }, player);
        }

        private string IconLayer = "UI_GameStoresRUST_Bucket";
        private void InitializeIcon(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, IconLayer);
            CuiElementContainer container = new CuiElementContainer();
            if (Settings.InterfaceSettings.BucketURL.Contains("http"))
            {
                if (ImageLibrary)
                {
                    container.Add(new CuiElement
                    {
                        Parent = "Overlay",
                        Name = IconLayer,
                        Components =
                        {
                            new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", "GameStoresRUSTBucket") },
                            new CuiRectTransformComponent { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "8 -40", OffsetMax = "43 -6" }
                        }
                    });

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                        Button = { Color = "0 0 0 0", Command = "chat.say /store" },
                        Text = { Text = "" }
                    }, IconLayer);
                }
                else
                {
                    container.Add(new CuiElement
                    {
                        Parent = "Overlay",
                        Name = IconLayer,
                        Components =
                        {
                            new CuiRawImageComponent { Url = Settings.InterfaceSettings.BucketURL },
                            new CuiRectTransformComponent { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "8 -40", OffsetMax = "43 -6" }
                        }
                    });

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                        Button = { Color = "0 0 0 0", Command = "chat.say /store" },
                        Text = { Text = "" }
                    }, IconLayer);
                }
            }
            else
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "8 -40", OffsetMax = "43 -6" },
                    Button = { Color = "1 1 1 0.6", Sprite = "assets/icons/open.png", Command = "chat.say /store" },
                    Text = { Text = "" }
                }, "Overlay", IconLayer);
            }

            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region Utils

        private void ShowNotify(BasePlayer player, string text)
        {
            CuiHelper.DestroyUi(player, StoreLayer + ".Notify");
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.80", AnchorMax = "1 0.90", OffsetMax = "0 0" },
                Text = { FadeIn = 1f, Text = text, Align = TextAnchor.UpperCenter, Font = "robotocondensed-regular.ttf", FontSize = 16 }
            }, StoreLayer, StoreLayer + ".Notify");

            CuiHelper.AddUi(player, container);
        }

        private void ProcessTake(BasePlayer player, Dictionary<string, object> obj)
        {
            //foreach (var check in obj)
            //   PrintError(check.Key + " -> " + check.Value); 
            LogAction(player, $"Начало обработки товара");
            WItem itemInfo = new WItem(obj);
            try
            {
                if (itemInfo.IsItem)
                {
                    LogAction(player, $"Попытка получения предмета: {itemInfo.ShortName} [{itemInfo.Amount}]");
                    var info = ItemManager.FindItemDefinition(itemInfo.ShortName);
                    if (info == null) return;

                    var item = ItemManager.Create(info, itemInfo.Amount);
                    if (!player.inventory.GiveItem(item))
                    {
                        LogAction(player, $"У игрока не было места для получения предмета, предмет выброшен {itemInfo.ShortName} [{itemInfo.Amount} {player.transform.position}]");

                        item.Drop(player.transform.position, Vector3.down * 3);
                        ShowNotify(player, $"Вы успешно получили предмет  › <size=20>{info.displayName.english}</size> ‹\n" +
                                           $"У вас недостаточно места в инвентаре, <b>предмет брошен</b> под ноги!");
                    }
                    else
                    {
                        LogAction(player, $"Предмет выдан игроку в инвентарь");
                        ShowNotify(player, $"Вы успешно получили предмет  › <size=20>{info.displayName.english}</size> ‹");
                    }
                }

                if (itemInfo.IsCommand)
                {
                    LogAction(player, $"Попытка получения команды");

                    string command = itemInfo.Command.Replace("\n", "|").Replace("%steamid%", player.UserIDString, StringComparison.OrdinalIgnoreCase).Replace("%username%", player.displayName, StringComparison.OrdinalIgnoreCase);
                    foreach (var check in command.Split('|'))
                    {
                        LogAction(player, $"Исполнение команды: {check}");
                        Server.Command(check);
                    }


                    ShowNotify(player, $"Вы успешно получили предмет  › <size=20>{itemInfo.Name}</size> ‹\n" +
                                       $"Теперь вам доступны новые привилегии!");
                }

                if (itemInfo.IsBlueprint)
                {
                    LogAction(player, $"Попытка получения рецепта {itemInfo.ShortName}");
                    Item create = ItemManager.CreateByItemID(-996920608);

                    var info = ItemManager.FindItemDefinition(itemInfo.ShortName);
                    create.blueprintTarget = info.itemid;

                    if (!player.inventory.GiveItem(create))
                    {
                        create.Drop(player.transform.position, Vector3.down * 3);
                        ShowNotify(player, $"Вы успешно получили рецепт предмета  › <size=20>{info.displayName.english}</size> ‹\n" +
                                           $"У вас недостаточно места в инвентаре, <b>предмет брошен</b> под ноги!");
                    }
                    else
                    {
                        LogAction(player, $"У игрока не было места для получения рецепта, рецепт выброшен {itemInfo.ShortName} [{itemInfo.Amount} {player.transform.position}]");

                        LogAction(player, $"Рецепт выдан игроку в инвентарь");
                        LogAction(player, $"Вы успешно получили рецепт предмета  › <size=20>{info.displayName.english}</size> ‹");
                    }
                }
            } catch (Exception e)
            {
                LogAction(player, $"Ошибка получения товара [{itemInfo.ID}][{itemInfo.Name}]");
                LogToFile("!Errors", $"{DateTime.Now.ToShortTimeString()}| Error: '{e.ToString()}'", this);
                PrintError($"Error receiving product [{itemInfo.ID}], info saved to log");
            }
            
        }

        private static readonly Dictionary<int, string> IDToShortName = new Dictionary<int, string> { [-1461508848] = "rifle.ak", [2115555558] = "ammo.handmade.shell", [-533875561] = "ammo.pistol", [1621541165] = "ammo.pistol.fire", [-422893115] = "ammo.pistol.hv", [815896488] = "ammo.rifle", [805088543] = "ammo.rifle.explosive", [449771810] = "ammo.rifle.incendiary", [1152393492] = "ammo.rifle.hv", [1578894260] = "ammo.rocket.basic", [1436532208] = "ammo.rocket.fire", [542276424] = "ammo.rocket.hv", [1594947829] = "ammo.rocket.smoke", [-1035059994] = "ammo.shotgun", [1818890814] = "ammo.shotgun.fire", [1819281075] = "ammo.shotgun.slug", [1685058759] = "antiradpills", [93029210] = "apple", [-1565095136] = "apple.spoiled", [-1775362679] = "arrow.bone", [-1775249157] = "arrow.fire", [-1280058093] = "arrow.hv", [-420273765] = "arrow.wooden", [563023711] = "autoturret", [790921853] = "axe.salvaged", [-337261910] = "bandage", [498312426] = "barricade.concrete", [504904386] = "barricade.metal", [-1221200300] = "barricade.sandbags", [510887968] = "barricade.stone", [-814689390] = "barricade.wood", [1024486167] = "barricade.woodwire", [2021568998] = "battery.small", [97329] = "bbq", [1046072789] = "trap.bear", [97409] = "bed", [-1480119738] = "tool.binoculars", [1611480185] = "black.raspberries", [-1386464949] = "bleach", [93832698] = "blood", [-1063412582] = "blueberries", [-1887162396] = "blueprintbase", [-55660037] = "rifle.bolt", [919780768] = "bone.club", [-365801095] = "bone.fragments", [68998734] = "botabag", [-853695669] = "bow.hunting", [271534758] = "box.wooden.large", [-770311783] = "box.wooden", [-1192532973] = "bucket.water", [-307490664] = "building.planner", [707427396] = "burlap.shirt", [707432758] = "burlap.shoes", [-2079677721] = "cactusflesh", [-1342405573] = "tool.camera", [-139769801] = "campfire", [-1043746011] = "can.beans", [2080339268] = "can.beans.empty", [-171664558] = "can.tuna", [1050986417] = "can.tuna.empty", [-1693683664] = "candycaneclub", [523409530] = "candycane", [1300054961] = "cctv.camera", [-2095387015] = "ceilinglight", [1428021640] = "chainsaw", [94623429] = "chair", [1436001773] = "charcoal", [1711323399] = "chicken.burned", [1734319168] = "chicken.cooked", [-1658459025] = "chicken.raw", [-726947205] = "chicken.spoiled", [-341443994] = "chocholate", [1540879296] = "xmasdoorwreath", [94756378] = "cloth", [3059095] = "coal", [3059624] = "corn", [2045107609] = "clone.corn", [583366917] = "seed.corn", [2123300234] = "crossbow", [1983936587] = "crude.oil", [1257201758] = "cupboard.tool", [-1144743963] = "diving.fins", [-1144542967] = "diving.mask", [-1144334585] = "diving.tank", [1066729526] = "diving.wetsuit", [-1598790097] = "door.double.hinged.metal", [-933236257] = "door.double.hinged.toptier", [-1575287163] = "door.double.hinged.wood", [-2104481870] = "door.hinged.metal", [-1571725662] = "door.hinged.toptier", [1456441506] = "door.hinged.wood", [1200628767] = "door.key", [-778796102] = "door.closer", [1526866730] = "xmas.door.garland", [1925723260] = "dropbox", [1891056868] = "ducttape", [1295154089] = "explosive.satchel", [498591726] = "explosive.timed", [1755466030] = "explosives", [726730162] = "facialhair.style01", [-1034048911] = "fat.animal", [252529905] = "femalearmpithair.style01", [471582113] = "femaleeyebrow.style01", [-1138648591] = "femalepubichair.style01", [305916740] = "female_hairstyle_01", [305916742] = "female_hairstyle_03", [305916744] = "female_hairstyle_05", [1908328648] = "fireplace.stone", [-2078972355] = "fish.cooked", [-533484654] = "fish.raw", [1571660245] = "fishingrod.handmade", [1045869440] = "flamethrower", [1985408483] = "flameturret", [97513422] = "flare", [1496470781] = "flashlight.held", [1229879204] = "weapon.mod.flashlight", [-1722829188] = "floor.grill", [1849912854] = "floor.ladder.hatch", [-1266285051] = "fridge", [-1749787215] = "boots.frog", [28178745] = "lowgradefuel", [-505639592] = "furnace", [1598149413] = "furnace.large", [-1779401418] = "gates.external.high.stone", [-57285700] = "gates.external.high.wood", [98228420] = "gears", [1422845239] = "geiger.counter", [277631078] = "generator.wind.scrap", [115739308] = "burlap.gloves", [-522149009] = "gloweyes", [3175989] = "glue", [718197703] = "granolabar", [384204160] = "grenade.beancan", [-1308622549] = "grenade.f1", [-217113639] = "fun.guitar", [-1580059655] = "gunpowder", [-1832205789] = "male_hairstyle_01", [305916741] = "female_hairstyle_02", [936777834] = "attire.hide.helterneck", [-1224598842] = "hammer", [-1976561211] = "hammer.salvaged", [-1406876421] = "hat.beenie", [-1397343301] = "hat.boonie", [1260209393] = "bucket.helmet", [-1035315940] = "burlap.headwrap", [-1381682752] = "hat.candle", [696727039] = "hat.cap", [-2128719593] = "coffeecan.helmet", [-1178289187] = "deer.skull.mask", [1351172108] = "heavy.plate.helmet", [-450738836] = "hat.miner", [-966287254] = "attire.reindeer.headband", [340009023] = "riot.helmet", [124310981] = "hat.wolf", [1501403549] = "wood.armor.helmet", [698310895] = "hatchet", [523855532] = "hazmatsuit", [2045246801] = "clone.hemp", [583506109] = "seed.hemp", [-148163128] = "attire.hide.boots", [-132588262] = "attire.hide.skirt", [-1666761111] = "attire.hide.vest", [-465236267] = "weapon.mod.holosight", [-1211618504] = "hoodie", [2133577942] = "hq.metal.ore", [-1014825244] = "humanmeat.burned", [-991829475] = "humanmeat.cooked", [-642008142] = "humanmeat.raw", [661790782] = "humanmeat.spoiled", [-1440143841] = "icepick.salvaged", [569119686] = "bone.armor.suit", [1404466285] = "heavy.plate.jacket", [-1616887133] = "jacket.snow", [-1167640370] = "jacket", [-1284735799] = "jackolantern.angry", [-1278649848] = "jackolantern.happy", [776005741] = "knife.bone", [108061910] = "ladder.wooden.wall", [255101535] = "trap.landmine", [-51678842] = "lantern", [-789202811] = "largemedkit", [516382256] = "weapon.mod.lasersight", [50834473] = "leather", [-975723312] = "lock.code", [1908195100] = "lock.key", [-1097452776] = "locker", [146685185] = "longsword", [-1716193401] = "rifle.lr300", [193190034] = "lmg.m249", [371156815] = "pistol.m92", [3343606] = "mace", [825308669] = "machete", [830965940] = "mailbox", [1662628660] = "male.facialhair.style02", [1662628661] = "male.facialhair.style03", [1662628662] = "male.facialhair.style04", [-1832205788] = "male_hairstyle_02", [-1832205786] = "male_hairstyle_04", [1625090418] = "malearmpithair.style01", [-1269800768] = "maleeyebrow.style01", [429648208] = "malepubichair.style01", [-1832205787] = "male_hairstyle_03", [-1832205785] = "male_hairstyle_05", [107868] = "map", [997973965] = "mask.balaclava", [-46188931] = "mask.bandana", [-46848560] = "metal.facemask", [-2066726403] = "bearmeat.burned", [-2043730634] = "bearmeat.cooked", [1325935999] = "bearmeat", [-225234813] = "deermeat.burned", [-202239044] = "deermeat.cooked", [-322501005] = "deermeat.raw", [-1851058636] = "horsemeat.burned", [-1828062867] = "horsemeat.cooked", [-1966381470] = "horsemeat.raw", [968732481] = "meat.pork.burned", [991728250] = "meat.pork.cooked", [-253819519] = "meat.boar", [-1714986849] = "wolfmeat.burned", [-1691991080] = "wolfmeat.cooked", [179448791] = "wolfmeat.raw", [431617507] = "wolfmeat.spoiled", [688032252] = "metal.fragments", [-1059362949] = "metal.ore", [1265861812] = "metal.plate.torso", [374890416] = "metal.refined", [1567404401] = "metalblade", [-1057402571] = "metalpipe", [-758925787] = "mining.pumpjack", [-1411620422] = "mining.quarry", [88869913] = "fish.minnows", [-2094080303] = "smg.mp5", [843418712] = "mushroom", [-1569356508] = "weapon.mod.muzzleboost", [-1569280852] = "weapon.mod.muzzlebrake", [449769971] = "pistol.nailgun", [590532217] = "ammo.nailgun.nails", [3387378] = "note", [1767561705] = "burlap.trousers", [106433500] = "pants", [-1334615971] = "heavy.plate.pants", [-135651869] = "attire.hide.pants", [-1595790889] = "roadsign.kilt", [-459156023] = "pants.shorts", [106434956] = "paper", [-578028723] = "pickaxe", [-586116979] = "jar.pickle", [-1379225193] = "pistol.eoka", [-930579334] = "pistol.revolver", [548699316] = "pistol.semiauto", [142147109] = "planter.large", [148953073] = "planter.small", [102672084] = "attire.hide.poncho", [640562379] = "pookie.bear", [-1732316031] = "xmas.present.large", [-2130280721] = "xmas.present.medium", [-1725510067] = "xmas.present.small", [1974032895] = "propanetank", [-225085592] = "pumpkin", [509654999] = "clone.pumpkin", [466113771] = "seed.pumpkin", [2033918259] = "pistol.python", [2069925558] = "target.reactive", [-1026117678] = "box.repair.bench", [1987447227] = "research.table", [540154065] = "researchpaper", [1939428458] = "riflebody", [-288010497] = "roadsign.jacket", [-847065290] = "roadsigns", [3506021] = "rock", [649603450] = "rocket.launcher", [3506418] = "rope", [569935070] = "rug.bear", [113284] = "rug", [1916127949] = "water.salt", [-1775234707] = "salvaged.cleaver", [-388967316] = "salvaged.sword", [2007564590] = "santahat", [-1705696613] = "scarecrow", [670655301] = "hazmatsuit_scientist", [1148128486] = "hazmatsuit_scientist_peacekeeper", [-141135377] = "weapon.mod.small.scope", [109266897] = "scrap", [-527558546] = "searchlight", [-1745053053] = "rifle.semiauto", [1223860752] = "semibody", [-419069863] = "sewingkit", [-1617374968] = "sheetmetal", [2057749608] = "shelves", [24576628] = "shirt.collared", [-1659202509] = "shirt.tanktop", [2107229499] = "shoes.boots", [191795897] = "shotgun.double", [-1009492144] = "shotgun.pump", [2077983581] = "shotgun.waterpipe", [378365037] = "guntrap", [-529054135] = "shutter.metal.embrasure.a", [-529054134] = "shutter.metal.embrasure.b", [486166145] = "shutter.wood.a", [1628490888] = "sign.hanging.banner.large", [1498516223] = "sign.hanging", [-632459882] = "sign.hanging.ornate", [-626812403] = "sign.pictureframe.landscape", [385802761] = "sign.pictureframe.portrait", [2117976603] = "sign.pictureframe.tall", [1338515426] = "sign.pictureframe.xl", [-1455694274] = "sign.pictureframe.xxl", [1579245182] = "sign.pole.banner.large", [-587434450] = "sign.post.double", [-163742043] = "sign.post.single", [-1224714193] = "sign.post.town", [644359987] = "sign.post.town.roof", [-1962514734] = "sign.wooden.huge", [-705305612] = "sign.wooden.large", [-357728804] = "sign.wooden.medium", [-698499648] = "sign.wooden.small", [1213686767] = "weapon.mod.silencer", [386382445] = "weapon.mod.simplesight", [1859976884] = "skull_fire_pit", [960793436] = "skull.human", [1001265731] = "skull.wolf", [1253290621] = "sleepingbag", [470729623] = "small.oil.refinery", [1051155022] = "stash.small", [865679437] = "fish.troutsmall", [927253046] = "smallwaterbottle", [109552593] = "smg.2", [-2092529553] = "smgbody", [691633666] = "snowball", [-2055888649] = "snowman", [621575320] = "shotgun.spas12", [-2118132208] = "spear.stone", [-1127699509] = "spear.wooden", [-685265909] = "spikes.floor", [552706886] = "spinner.wheel", [1835797460] = "metalspring", [-892259869] = "sticks", [-1623330855] = "stocking.large", [-1616524891] = "stocking.small", [789892804] = "stone.pickaxe", [-1289478934] = "stonehatchet", [-892070738] = "stones", [-891243783] = "sulfur", [889398893] = "sulfur.ore", [-1625468793] = "supply.signal", [1293049486] = "surveycharge", [1369769822] = "fishtrap.small", [586484018] = "syringe.medical", [110115790] = "table", [1490499512] = "targeting.computer", [3552619] = "tarp", [1471284746] = "techparts", [456448245] = "smg.thompson", [110547964] = "torch", [1588977225] = "xmas.decoration.baubels", [918540912] = "xmas.decoration.candycanes", [-471874147] = "xmas.decoration.gingerbreadmen", [205978836] = "xmas.decoration.lights", [-1044400758] = "xmas.decoration.pinecone", [-2073307447] = "xmas.decoration.star", [435230680] = "xmas.decoration.tinsel", [-864578046] = "tshirt", [1660607208] = "tshirt.long", [260214178] = "tunalight", [-1847536522] = "vending.machine", [-496055048] = "wall.external.high.stone", [-1792066367] = "wall.external.high", [562888306] = "wall.frame.cell.gate", [-427925529] = "wall.frame.cell", [995306285] = "wall.frame.fence.gate", [-378017204] = "wall.frame.fence", [447918618] = "wall.frame.garagedoor", [313836902] = "wall.frame.netting", [1175970190] = "wall.frame.shopfront", [525244071] = "wall.frame.shopfront.metal", [-1021702157] = "wall.window.bars.metal", [-402507101] = "wall.window.bars.toptier", [-1556671423] = "wall.window.bars.wood", [61936445] = "wall.window.glass.reinforced", [112903447] = "water", [1817873886] = "water.catcher.large", [1824679850] = "water.catcher.small", [-1628526499] = "water.barrel", [547302405] = "waterjug", [1840561315] = "water.purifier", [-460592212] = "xmas.window.garland", [3655341] = "wood", [1554697726] = "wood.armor.jacket", [-1883959124] = "wood.armor.pants", [-481416622] = "workbench1", [-481416621] = "workbench2", [-481416620] = "workbench3", [-1151126752] = "xmas.lightstring", [-1926458555] = "xmas.tree" };

        private void UI_RecountPosition(ref double xSwitch, ref double ySwitch, int count, int max)
        {
            var stringAmount = Math.Ceiling((double)max / Settings.InterfaceSettings.ItemOnString);
            var currentString = Math.Floor((double)count / Settings.InterfaceSettings.ItemOnString);
            var currentPosition = count % Settings.InterfaceSettings.ItemOnString;


            var topYPosition = 0 + (float)stringAmount / 2 * Settings.InterfaceSettings.ItemSide + ((float)stringAmount / 2 - 1) * Settings.InterfaceSettings.ItemMargin;
            var topXPosition = 0 - (float)Settings.InterfaceSettings.ItemOnString / 2 * Settings.InterfaceSettings.ItemSide - ((float)Settings.InterfaceSettings.ItemOnString / 2 - 1) * Settings.InterfaceSettings.ItemMargin;

            var curYPosition = topYPosition - currentString * Settings.InterfaceSettings.ItemSide - (currentString) * (Settings.InterfaceSettings.ItemMargin + (Settings.InterfaceSettings.TextShow ? 20 : 0));
            var curXPosition = topXPosition + currentPosition * Settings.InterfaceSettings.ItemSide + (currentPosition) * Settings.InterfaceSettings.ItemMargin;

            xSwitch = curXPosition;
            ySwitch = curYPosition;
        }

        public static bool CheckInstantWork = false;
        public Timer CheckInstantWorkGlobalTimer = null;

        private void CheckInstant()
        {
            if (CheckInstantWork == true)
                return;

            CheckInstantWork = true;
            if (CheckInstantWorkGlobalTimer != null)
                CheckInstantWorkGlobalTimer.Destroy();

            CheckInstantWorkGlobalTimer = timer.Once(300, () => { CheckInstantWork = false; });

            Request($"&method=basket.commands.instant", (code, response) =>
            {
                switch (code)
                {
                    case 0:
                        {
                            LogAction(null, $"Ошибка выполнения запроса для выдачи автоматических команд");
                            CheckInstantWork = false;
                            break;
                        }
                    case 200:
                        {
                            var firstInfo = JsonConvert.DeserializeObject<Dictionary<string, object>>(response, new KeyValuesConverter());
                            if (firstInfo.ContainsKey("result"))
                            {
                                if (firstInfo["result"].ToString() == "success")
                                {
                                    List<object> data = firstInfo["data"] as List<object>;
                                    int i = 1;
                                    timer.Once(data.Count + 2, () => { CheckInstantWork = false; });

                                    foreach (Dictionary<string, object> product in data)
                                    {
                                        if (product.ContainsKey("id"))
                                        {
                                            timer.Once(i, () => { TakeInstant(Convert.ToInt32(product["id"]), product["steam_id"].ToString()); } );                                             
                                            i++;
                                        }

                                    }                                  
                                } else CheckInstantWork = false;
                            } else CheckInstantWork = false;
                            break;
                        }
                    default:
                        {
                            LogAction(null, $"Ошибка выполнения запроса для выдачи автоматических команд");
                            CheckInstantWork = false;
                            break;
                        }
                }
            }, null); 
        }

        private void TakeInstant(int GsProductId, string SteamId)
        {
            LogAction(null, $"---------------------------------");
            LogAction(null, $"[AutoCommands] Запрос на получение товара [{GsProductId}][{SteamId}]");
            Request($"&item=true&id={GsProductId}", (i, s) =>
            {
                switch (i)
                {
                    case 0:
                        LogAction(null, $"[AutoCommands] API не ответило на запрос: {GsProductId}");
                        PrintError("Api does not responded to a request");
                        break;
                    case 200:
                        Dictionary<string, object> response = JsonConvert.DeserializeObject<Dictionary<string, object>>(s, new KeyValuesConverter());
                        if (!response.ContainsKey("data"))
                        {
                            LogAction(null, $"[AutoCommands] Ошибка получения товара, отсутствует Data [{GsProductId}]");
                            return;
                        } else
                        {
                            Request($"&gived=true&id={GsProductId}", (code, newResponse) =>
                            {
                                if (code != 200 || JsonConvert.DeserializeObject<JObject>(newResponse)["result"].ToString() != "success")
                                {
                                    LogAction(null, $"[AutoCommands] Ошибка получения товара [{GsProductId}][{SteamId}]");
                                    return;
                                }
                                else
                                {
                                    WItem itemInfo = new WItem(response["data"] as Dictionary<string, object>);
                                    if (itemInfo.IsCommand)
                                    {
                                        LogAction(null, $"[AutoCommands] Товар отмечен полученным [{GsProductId}][{SteamId}]");
                                        string command = itemInfo.Command.Replace("\n", "|").Replace("%steamid%", SteamId, StringComparison.OrdinalIgnoreCase);
                                        foreach (var check in command.Split('|'))
                                        {
                                            LogAction(null, $"[AutoCommands] Исполнение команды: {check} [{GsProductId}][{SteamId}]");
                                            Server.Command(check);
                                        }
                                    }
                                    else
                                    {
                                        LogAction(null, $"[AutoCommands] Ошибка получения (товар не является командой) [{GsProductId}][{SteamId}]");
                                    }
                                }
                            }, null);
                        }
                       
                        break;
                    case 404:
                        LogAction(null, $"[AutoCommands] Api не ответило на запрос: {GsProductId}");
                        LogAction(null, "Response code: 404, please check your configurations", true);
                        break;
                }
            }, null);
        }

        private Timer RestartTimer = null;
        private void SetReserveApiLink()
        {
            if (BaseRequest.Contains(MainApiLink))
            {
                LogAction(null, $"Trying use reserve api link", true);
                BaseRequest = ReserveApiLink + BaseRequestParams;
                if (!Initialized)
                    FetchShopUrl();
                timer.Once(300, () => {
                    TryChangeLink();
                });
            } else
            {
                LogAction(null, $"Plugin will automatically restart after 10 minutes", true);
                RestartTimer = timer.Once(600, () => { LogAction(null, $"Restarting...", true); Server.Command("o.reload GameStoresRUST"); });
            }                         
        }

        private void TryChangeLink()
        {
            string newLink = ReserveApiLink + BaseRequestParams;
            if (BaseRequest.Contains(ReserveApiLink))
            {
                newLink = MainApiLink + BaseRequestParams;
            }
            CheckRequest($"{newLink}&info=true", (code, response) =>
            {
                switch (code)
                {
                    case 200:
                        {
                            if (response.Length < 1)
                            {
                                return;
                            }
                            var firstInfo = JsonConvert.DeserializeObject<Dictionary<string, object>>(response, new KeyValuesConverter());
                            if (!firstInfo.ContainsKey("data"))
                            {
                                initialization = false;
                            }
                            else
                            {
                                if (RestartTimer != null)
                                {
                                    LogAction(null, $"Restart was canceled");
                                    RestartTimer.Destroy();
                                    RestartTimer = null;
                                }
                                LogAction(null, $"API link was changed", true);
                                BaseRequest = newLink;
                                if (!Initialized)
                                    FetchShopUrl();
                                if (BaseRequest.Contains(ReserveApiLink))
                                    timer.Once(600, () => { TryChangeLink(); });
                            }
                            break;
                        }
                    default:
                        break;

                }
            });
        }

        private void FetchShopUrl()
        {
            initialization = true;
            timer.Once(5, () => { initialization = false; });
            Request($"&info=true", (code, response) =>
            {
                LogAction(null, $"-----------------------------", true);
                LogAction(null, $" GameStores {Version} (c) 2019", true);
                try
                {
                    if (response.Length < 1)
                    {
                        LogToFile("!Errors", $"{DateTime.Now.ToShortTimeString()}| Response: '{response}'", this);
                        LogAction(null, " Incorrect API response! Saved to log!", true, true);
                        LogAction(null, $"-----------------------------", true);
                        SetReserveApiLink();
                        initialization = false;
                        return;
                    }
                    var firstInfo = JsonConvert.DeserializeObject<Dictionary<string, object>>(response, new KeyValuesConverter());
                    if (!firstInfo.ContainsKey("data"))
                    {
                        LogAction(null, $"     Wrong Secret Key", true, true);
                        LogAction(null, $"-----------------------------", true);
                        initialization = false;
                    }
                    else
                    { 
                        firstInfo = firstInfo["data"] as Dictionary<string, object>;
                        ShopURL = firstInfo["link"].ToString();
                        StartBalance = int.Parse(firstInfo["default_balance"].ToString());
                        LogAction(null, "      Initialized - OK", true);
                        LogAction(null, $"-----------------------------", true);
                        //BasePlayer.activePlayerList.ForEach(OnPlayerInit);
                        foreach (var pl in BasePlayer.activePlayerList)
                        {
                            OnPlayerConnected(pl);
                        }

                        Initialized = true;
                        initialization = false;
                    }
                }
                catch (JsonException e)
                {
                    
                    LogToFile("Errors", $"{DateTime.Now.ToShortTimeString()}| JsonError | Response: '{response}'", this);
                    LogAction(null, " JSON Error! Saved to log!", true, true);
                    LogAction(null, $"-----------------------------", true);
                    SetReserveApiLink();
                    initialization = false;
                }

            });
        }

        private static int errorsReq = 0;
        private static void Request(string ask, Action<int, string> callback, BasePlayer player = null, bool cancel = true)
        {
            if (player != null && !Delays.CanRequest(player))
            {
                instance.ShowNotify(player, "Вы делаете слишком много запросов к серверу!\n" +
                    "Подождите <b>одну секунду</b>!");
                instance.timer.Once(1f, () =>
                {
                    CuiHelper.DestroyUi(player, StoreLayer + ".Notify");
                    Request(ask, callback, player, cancel);
                });

                return;
            };
            if (player != null) ServerMgr.Instance.StartCoroutine(Delays.MakeRequest(player));
            Dictionary<string, string> reqHeaders = new Dictionary<string, string>{{ "User-Agent", "GameStores Plugin" }};
            
            instance.webrequest.Enqueue(instance.BaseRequest + ask, "", (code, response) =>
            {
                if (instance == null) return;
                
                switch (code)
                {
                    case 200:
                        {
                            break;
                        }
                    default:
                        {
                            instance.LogAction(null, $"Time out waiting for GS API #1");
                            errorsReq++;
                            
                            if (errorsReq >= 10)
                            {
                                errorsReq = 0;
                                instance.TryChangeLink();
                            }
                            
                            break;
                        }
                    case 404:
                        {
                            instance.LogAction(null, $"Please check your configuration! [404] #2", true);
                            break;
                        }
                }

                if (player != null && cancel) Delays.FinishRequest(player);

                callback?.Invoke(code, response);
            }, instance, RequestMethod.GET, reqHeaders);
                      
        }
        private static void CheckRequest(string link, Action<int, string> callback)
        {   
            Dictionary<string, string> reqHeaders = new Dictionary<string, string> { { "User-Agent", "GameStores Plugin" } };
            instance.webrequest.Enqueue(link, "", (code, response) =>
            {
                if (instance == null) return;

                switch (code)
                {
                    case 0:
                        {
                            
                            break;
                        }
                    case 404:
                        {
                            
                            break;
                        }
                }

                callback?.Invoke(code, response);
            }, instance, RequestMethod.GET, reqHeaders);

        }

        private static void RequestPost(string ask, Action<int, string> callback, BasePlayer player = null, bool cancel = true)
        {
            if (player != null && !Delays.CanRequest(player))
            {
                instance.ShowNotify(player, "Вы делаете слишком много запросов к серверу!\n" +
                    "Подождите <b>одну секунду</b>!");
                instance.timer.Once(1f, () =>
                {
                    CuiHelper.DestroyUi(player, StoreLayer + ".Notify");
                    RequestPost(ask, callback, player, cancel);
                });
                return;
            };
            if (player != null) ServerMgr.Instance.StartCoroutine(Delays.MakeRequest(player));
            string body, reqLink;
            int pos = instance.BaseRequest.IndexOf("?");
            if (pos < 0)
            {
                body = ask;
                reqLink = instance.BaseRequest;
            }
            else
            {
                reqLink = instance.BaseRequest.Substring(0, pos);
                body = $"{instance.BaseRequest.Substring(pos + 1)}{ask}";
            }
            Dictionary<string, string> reqHeaders = new Dictionary<string, string> { { "User-Agent", "GameStores Plugin" } };
            instance.webrequest.Enqueue(reqLink, body, (code, response) =>
            {
                if (instance == null) return;

                switch (code)
                {
                    case 0:
                        {
                            instance.PrintError($"Time out waiting for GS API #1");
                            break;
                        }
                    case 404:
                        {
                            instance.PrintError($"Plese check your configuration! [404] #2");
                            break;
                        }
                }
                if (player != null && cancel) Delays.FinishRequest(player);

                callback?.Invoke(code, response);
            }, instance, RequestMethod.POST, reqHeaders);
        }

        private void LogAction(BasePlayer player, string text, bool printToConsole = false, bool printError = false)
        {
            LogToFile($"!global", $"{DateTime.Now.ToShortTimeString()} {(player != null ? "[" + player.userID + "]" : " ")}{text}", this);

            if (printToConsole)
                if (printError)
                    instance.PrintError($"{text}");
                else 
                    PrintWarning($"{text}");
            if (player != null)
                LogPlayerAction(player, text);
        }
        private void LogPlayerAction(BasePlayer player, string text) => LogToFile($"{player.userID}", $"{DateTime.Now.ToShortTimeString()} {text}", this);
        private static double CurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1)).TotalSeconds;

        #endregion
    }
}


// --- End of file: GameStoresRUST.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/HitMarker.cs ---
// --- Original Local Path: KualaRust/HitMarker.cs ---

﻿// Reference: System.Drawing
using Facepunch;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Linq;
using System.Text;
using UnityEngine;
using Color = UnityEngine.Color;
using Time = UnityEngine.Time;

namespace Oxide.Plugins
{
    [Info("HitMarker", "fix иной", "1.0.1")]
    class HitMarker : RustPlugin
    {
        #region CONFIGURATION

        private bool Changed;
        private bool enablesound;
        private string soundeffect;
        private string headshotsoundeffect;
        private float damageTimeout;
        private int historyCapacity;
        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }
		/// Лог


        protected override void LoadDefaultConfig()
        {
            enablesound = Convert.ToBoolean(GetConfig("Sound", "EnableSoundEffect", true));
            soundeffect =
                Convert.ToString(GetConfig("Sound", "Sound Effect", "assets/bundled/prefabs/fx/takedamage_hit.prefab"));
            headshotsoundeffect =
                Convert.ToString(GetConfig("Sound", "HeadshotSoundEffect", "assets/bundled/prefabs/fx/headshot.prefab"));
            GetVariable(Config, "Через сколько будет пропадать урон", out damageTimeout, 1f);
            GetVariable(Config, "Вместимость истории урона", out historyCapacity, 5);
            SaveConfig();
        }
        public static void GetVariable<T>(DynamicConfigFile config, string name, out T value, T defaultValue)
        {
            config[name] = value = config[name] == null ? defaultValue : (T)Convert.ChangeType(config[name], typeof(T));
        }
        #endregion


        #region FIELDS

        [PluginReference]
        private Plugin Clans;

        List<BasePlayer> hitmarkeron = new List<BasePlayer>();


        Dictionary<BasePlayer, List<KeyValuePair<float, int>>> damageHistory = new Dictionary<BasePlayer, List<KeyValuePair<float, int>>>();

        Dictionary<BasePlayer, Oxide.Plugins.Timer> destTimers = new Dictionary<BasePlayer, Oxide.Plugins.Timer>();
        #endregion

        #region COMMANDS

        [ChatCommand("hitmarker")]
        void cmdHitMarker(BasePlayer player, string cmd, string[] args)
        {
            if (!hitmarkeron.Contains(player))
            {
                hitmarkeron.Add(player);
                SendReply(player,
                    "<color=cyan>HitMarker</color>:" + " " + "<color=orange>Вы включили показ урона.</color>");
            }
            else
            {
                hitmarkeron.Remove(player);
                SendReply(player,
                    "<color=cyan>HitMarker</color>:" + " " + "<color=orange>Вы отключили показ урона.</color>");
            }
        }
		///// data save

        #endregion

        #region OXIDE HOOKS

        void OnServerInitialized()
        {
            InitFileManager();
            LoadDefaultConfig();
            foreach (BasePlayer current in BasePlayer.activePlayerList)
            {
                hitmarkeron.Add(current);
            }
            CommunityEntity.ServerInstance.StartCoroutine(LoadImages());
            timer.Every(0.1f, OnDamageTimer);
        }

        IEnumerator LoadImages()
        {
            foreach (var imgKey in Images.Keys.ToList())
            {
                yield return CommunityEntity.ServerInstance.StartCoroutine(
                    m_FileManager.LoadFile(imgKey, Images[imgKey]));
                Images[imgKey] = m_FileManager.GetPng(imgKey);
            }
        }

        void OnPlayerInit(BasePlayer player)
        {
            hitmarkeron.Add(player);
        }
        void OnPlayerDisconnected(BasePlayer player)
        {
            hitmarkeron.Remove(player);
            damageHistory.Remove(player);
        }
        void OnPlayerAttack(BasePlayer attacker, HitInfo hitinfo)
        {
            var victim = hitinfo.HitEntity as BasePlayer;
            if (victim && hitmarkeron.Contains(attacker))
            {
                bool isFriend = (Clans?.Call("HasFriend", attacker.userID, victim.userID) as bool?) ?? false;
                if (hitinfo.isHeadshot)
                {
                    if (enablesound == true)
                    {
                        Effect.server.Run(headshotsoundeffect, attacker.transform.position, Vector3.zero,
                            attacker.net.connection);
                    }
                    DestroyLastCui(attacker);
                    CuiHelper.AddUi(attacker,
                        HandleArgs(MenuGUI, Images["hitmarker.hit.head"]));
                    destTimers[attacker] = timer.Once(0.5f, () =>
                 {
                     CuiHelper.DestroyUi(attacker, "hitmarkergui");
                 });
                }
                else
                {
                    if (enablesound)
                    {
                        Effect.server.Run(soundeffect, attacker.transform.position, Vector3.zero,
                            attacker.net.connection);
                    }
                    DestroyLastCui(attacker);
                    CuiHelper.AddUi(attacker,
                        HandleArgs(MenuGUI, Images["hitmarker.hit." + (isFriend ? "friend" : "normal")]));
                    destTimers[attacker] = timer.Once(0.5f, () =>
                    {
                        CuiHelper.DestroyUi(attacker, "hitmarkergui");
                    });
                }
            }
        }

        string MenuGUI = "[{\"name\":\"hitmarkergui\",\"parent\":\"Hud\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"assets/content/textures/generic/fulltransparent.tga\",\"png\":\"{0}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.4934896 0.4884259\",\"anchormax\":\"0.5065104 0.511574\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]}]";
        string DamageGUI = "[{\"name\":\"hitmarkerDamage\",\"parent\":\"Hud\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{0}\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 1\",\"distance\":\"0.3 -0.3\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5119792 0.2231481\",\"anchormax\":\"0.675 0.4787038\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]}]";
        private string BigIconGUI = "[{\"name\":\"hitmarker.bigicon\",\"parent\":\"Hud\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"assets/content/textures/generic/fulltransparent.tga\",\"png\":\"{0}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.4869792 0.4768519\",\"anchormax\":\"0.5130208 0.5231481\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]}]";
        string HandleArgs(string json, params object[] args)
        {
            for (int i = 0; i < args.Length; i++)
                json = json.Replace("{" + i + "}", args[i].ToString());
            return json;
        }
        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            var victim = entity as BasePlayer;
            if (victim == null || hitInfo == null) return;
            DamageType type = hitInfo.damageTypes.GetMajorityDamageType();
            if (type == null) return;
            var attacker = hitInfo.InitiatorPlayer;
            if (attacker == null) return;
            NextTick(() =>
            {
                var damage =
                    System.Convert.ToInt32(Math.Round(hitInfo.damageTypes.Total(), 0, MidpointRounding.AwayFromZero));
                DamageNotifier(attacker, damage);
            });
        }


        void OnPlayerWound(BasePlayer player)
        {
            var attacker = player?.lastAttacker as BasePlayer;
            if (attacker == null) return;

            DestroyLastCui(attacker);

            CuiHelper.AddUi(attacker,
                HandleArgs(BigIconGUI, Images["hitmarker.hit.wound"]));
            destTimers[attacker] = timer.Once(0.5f, () =>
         {
             CuiHelper.DestroyUi(attacker, "hitmarker.bigicon");
         });
        }

        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            var player = entity as BasePlayer;
            if (player == null) return;
            var attacker = info?.Initiator as BasePlayer;
            if (attacker == null) return;

            DestroyLastCui(attacker);

            CuiHelper.AddUi(attacker,
                HandleArgs(BigIconGUI, Images["hitmarker.kill"]));
            destTimers[attacker] = timer.Once(0.5f, () =>
         {
             CuiHelper.DestroyUi(attacker, "hitmarker.bigicon");
         });
        }
        #endregion

        #region Core

        void OnDamageTimer()
        {
            float time = Time.time;
            var toRemove = Pool.GetList<BasePlayer>();
            foreach (var dmgHistoryKVP in damageHistory)
            {
                dmgHistoryKVP.Value.RemoveAll(p => p.Key < time);

                DrawDamageNotifier(dmgHistoryKVP.Key);

                if (dmgHistoryKVP.Value.Count == 0)
                    toRemove.Add(dmgHistoryKVP.Key);
            }
            toRemove.ForEach(p => damageHistory.Remove(p));
            Pool.FreeList(ref toRemove);
        }

        void DamageNotifier(BasePlayer player, int damage)
        {
            List<KeyValuePair<float, int>> damages;
            if (!damageHistory.TryGetValue(player, out damages))
                damageHistory[player] = damages = new List<KeyValuePair<float, int>>();
            damages.Insert(0, new KeyValuePair<float, int>(Time.time + damageTimeout, damage));
            if (damages.Count > historyCapacity) damages.RemoveAt(damages.Count - 1);
            DrawDamageNotifier(player);
        }

        string GetDamageArg(BasePlayer player)
        {
            StringBuilder sb = new StringBuilder();
            List<KeyValuePair<float, int>> damages;
            if (!damageHistory.TryGetValue(player, out damages))
                return string.Empty;
            for (var i = 0; i < damages.Count; i++)
            {
                var item = damages[i];
                sb.Append(new string(' ', i * 2) + $"<color=#{GetDamageColor(item.Value)}>-{item.Value}</color>" + Environment.NewLine);
            }
            return sb.ToString();
        }

        void DestroyLastCui(BasePlayer player)
        {
            Oxide.Plugins.Timer tmr;
            if (destTimers.TryGetValue(player, out tmr))
            {
                tmr?.Callback?.Invoke();
                if (tmr != null && !tmr.Destroyed)
                    timer.Destroy(ref tmr);
            }
        }

        private Color minColor = ColorEx.Parse("1 1 1 1");
        private Color maxColor = ColorEx.Parse("1 0 0 1");
        string GetDamageColor(int damage)
        {
            return ColorToHex(Color.Lerp(minColor, maxColor, (float)damage / 100));
        }

        string ColorToHex(Color32 color)
        {
            string hex = color.r.ToString("X2") + color.g.ToString("X2") + color.b.ToString("X2");
            return hex;
        }
        #endregion

        #region UI


        void DrawDamageNotifier(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "hitmarkerDamage");
            CuiHelper.AddUi(player,
                HandleArgs(DamageGUI, GetDamageArg(player)));
        }

        Dictionary<string, string> Images = new Dictionary<string, string>()
        {
            { "hitmarker.kill", "http://i.imgur.com/R0NeHWp.png" },
            { "hitmarker.hit.normal", "http://i.imgur.com/CmlQUR0.png" },
            { "hitmarker.hit.head", "http://i.imgur.com/RbXBvH2.png" },
            { "hitmarker.hit.friend", "http://i.imgur.com/5M2rAek.png" },
            { "hitmarker.hit.wound", "http://i.imgur.com/bFCHTxL.png" },
        };

        #endregion

        #region File Manager

        private GameObject FileManagerObject;
        private FileManager m_FileManager;

        /// <summary>
        /// Инициализация скрипта взаимодействующего с файлами сервера
        /// </summary>
        void InitFileManager()
        {
            FileManagerObject = new GameObject("MAP_FileManagerObject");
            m_FileManager = FileManagerObject.AddComponent<FileManager>();
        }

        class FileManager : MonoBehaviour
        {
            int loaded = 0;
            int needed = 0;

            public bool IsFinished => needed == loaded;
            const ulong MaxActiveLoads = 10;
            Dictionary<string, FileInfo> files = new Dictionary<string, FileInfo>();

            private class FileInfo
            {
                public string Url;
                public string Png;
            }


            public string GetPng(string name) => files[name].Png;


            public IEnumerator LoadFile(string name, string url, int size = -1)
            {
                if (files.ContainsKey(name) && files[name].Url == url && !string.IsNullOrEmpty(files[name].Png)) yield break;
                files[name] = new FileInfo() { Url = url };
                needed++;
                yield return StartCoroutine(LoadImageCoroutine(name, url, size));
            }

            IEnumerator LoadImageCoroutine(string name, string url, int size = -1)
            {
                using (WWW www = new WWW(url))
                {
                    yield return www;
                    if (string.IsNullOrEmpty(www.error))
                    {
                        var bytes = size == -1 ? www.bytes : Resize(www.bytes, size);


                        var entityId = CommunityEntity.ServerInstance.net.ID;
                        var crc32 = FileStorage.server.Store(bytes, FileStorage.Type.png, entityId).ToString();
                        files[name].Png = crc32;
                    }
                }
                loaded++;
            }

            static byte[] Resize(byte[] bytes, int size)
            {
                Image img = (Bitmap)(new ImageConverter().ConvertFrom(bytes));
                Bitmap cutPiece = new Bitmap(size, size);
                System.Drawing.Graphics graphic = System.Drawing.Graphics.FromImage(cutPiece);
                graphic.DrawImage(img, new Rectangle(0, 0, size, size), 0, 0, img.Width, img.Height, GraphicsUnit.Pixel);
                graphic.Dispose();
                MemoryStream ms = new MemoryStream();
                cutPiece.Save(ms, ImageFormat.Jpeg);
                return ms.ToArray();
            }
        }

        #endregion
    }
}





// --- End of file: HitMarker.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/MachiningTools.cs ---
// --- Original Local Path: KualaRust/MachiningTools.cs ---

using Facepunch;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("MachiningTools", "Vlad-00003", "1.2.4", ResourceId = 89)]
    [Description("Creates tools that would gather refined materials from the resource nodes")]
    /*
     * Author info:
     *   E-mail: Vlad-00003@mail.ru
     *   Vk: vk.com/vlad_00003
     */
    class MachiningTools : RustPlugin
    {
        #region Vars⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        private PluginConfig _config;
        private readonly Dictionary<ItemDefinition, ItemDefinition> _itemToCookable = new Dictionary<ItemDefinition, ItemDefinition>();
        #endregion

        #region Config⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        private class Tool
        {
            [JsonProperty("Короткое имя предмета")]
            public string ShortName;
            [JsonProperty("ID скина предмета (Поддерживается Workshop)")]
            public ulong SkinId;
            [JsonProperty("Название предмета (Выводится в описании предмета в инвентаре)")]
            public string Name;
            [JsonProperty("Можно ли ремонтировать предмет")]
            public bool CanRepair;
            [JsonProperty("Можно ли перерабатывать предмет")]
            public bool CanRecycle;
            [JsonProperty("Настройки переработки")]
            public Transmutations Transmutation;

            private ItemDefinition _info;

            public bool ItemExists()
            {
                _info = ItemManager.FindItemDefinition(ShortName);
                if (_info == null)
                    return false;

                var itemModEntity = _info.GetComponent<ItemModEntity>();
                if (itemModEntity == null)
                    return false;

                var baseMelee = GameManager.server.FindPrefab(itemModEntity.entityPrefab?.resourcePath)?.GetComponent<BaseMelee>();
                return baseMelee != null;
            }

            public Item Create(int amount = 1)
            {
                Item item = ItemManager.Create(_info,amount, SkinId);
                item.name = Name;
                return item;
            }

            public int GetCustomHash()
            {
                unchecked
                {
                    return (string.IsNullOrEmpty(ShortName) ? 0 : ShortName.GetHashCode() * 397) ^ SkinId.GetHashCode();
                }
            }

            public static int GetCustomHash(Item item)
            {
                unchecked
                {
                    if (item == null)
                        return 0;
                    return (string.IsNullOrEmpty(item.info.shortname) ? 0 : item.info.shortname.GetHashCode() * 397) ^ item.skin.GetHashCode();
                }
            }
        }
        private class Transmutations
        {
            [JsonProperty("Перерабатывать дерево в уголь")]
            private bool _wood;
            [JsonProperty("Перерабатывать руду МВК в металл")]
            private bool _hqm;
            [JsonProperty("Перерабатывать металлическую руду в фрагменты")]
            private bool _metal;
            [JsonProperty("Перерабатывать серную руду в серу")]
            private bool _sulfur;
            [JsonProperty("Перерабатывать мясо медведя в жаренное")]
            private bool _bear;
            [JsonProperty("Перерабатывать свинину в жаренную")]
            private bool _boar;
            [JsonProperty("Перерабатывать мясо курицы в жаренное")]
            private bool _chicken;
            [JsonProperty("Перерабатывать мясо лошади в жаренное")]
            private bool _horse;
            [JsonProperty("Перерабатывать мясо волка в жаренное")]
            private bool _wolf;
            [JsonProperty("Перерабатывать мясо оленя в жаренное")]
            private bool _deer;
            [JsonProperty("Перерабатывать человеческое мясо в жаренное")]
            private bool _human;

            #region Default Config⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

            public static Transmutations DefaultPick => new Transmutations
            {
                _wood = false,
                _hqm = true,
                _metal = true,
                _sulfur = true,
                _bear = false,
                _boar = false,
                _chicken = false,
                _wolf = false,
                _deer = false,
                _human = false,
                _horse = false
            };

            public static Transmutations DefaultAxe => new Transmutations
            {
                _wood = true,
                _hqm = false,
                _metal = false,
                _sulfur = false,
                _bear = true,
                _boar = true,
                _chicken = true,
                _wolf = true,
                _deer = true,
                _human = true,
                _horse = true
            };

            #endregion
            
            // ReSharper disable StringLiteralTypo
            public bool ShouldCook(Item item)
            {
                switch (item.info.shortname)
                {
                    case "humanmeat.raw":
                        return _human;
                    case "bearmeat":
                        return _bear;
                    case "chicken.raw":
                        return _chicken;
                    case "meat.boar":
                        return _boar;
                    case "deermeat.raw":
                        return _deer;
                    case "wolfmeat.raw":
                        return _wolf;
                    case "sulfur.ore":
                        return _sulfur;
                    case "metal.ore":
                        return _metal;
                    case "wood":
                        return _wood;
                    case "horsemeat.raw":
                        return _horse;
                    case "hq.metal.ore":
                        return _hqm;
                    default:
                        return false;
                }
            }
            // ReSharper restore StringLiteralTypo

        }
        private class PluginConfig
        {
            [JsonProperty("Привилегия для использования команд")]
            public string Permission;
            [JsonProperty("Команда(чат/консоль)")]
            public string Command;
            [JsonProperty("Список инструментов")]
            private Dictionary<string, Tool> _tools;

            [JsonIgnore] 
            private readonly Dictionary<int,KeyValuePair<string, Tool>> _toolsByHash = new Dictionary<int, KeyValuePair<string, Tool>>();
            [JsonIgnore]
            public readonly Dictionary<string, Tool> ToolsByKey = new Dictionary<string, Tool>();

            #region Default Config⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

            public static PluginConfig DefaultConfig => new PluginConfig
            {
                Permission = nameof(MachiningTools)+".use",
                Command = "GiveTool",
                _tools = new Dictionary<string, Tool>
                {
                    ["hatchet"] = new Tool
                    {
                        ShortName = "hatchet",
                        Name = "Магический топор",
                        CanRepair = true,
                        CanRecycle = true,
                        SkinId = 901876821,
                        Transmutation = Transmutations.DefaultAxe
                    },
                    ["pickaxe"] = new Tool
                    {
                        ShortName = "pickaxe",
                        Name = "Магическая кирка",
                        CanRepair = true,
                        CanRecycle = true,
                        SkinId = 902892485,
                        Transmutation = Transmutations.DefaultPick
                    },
                    ["icepick"] = new Tool
                    {
                        ShortName = "icepick.salvaged",
                        Name = "Магический ледоруб",
                        CanRepair = false,
                        CanRecycle = false,
                        SkinId = 804307574,
                        Transmutation = Transmutations.DefaultPick
                    },
                    ["axe"] = new Tool
                    {
                        ShortName = "axe.salvaged",
                        Name = "Магический топор",
                        CanRepair = false,
                        CanRecycle = false,
                        SkinId = 2057227617,
                        Transmutation = Transmutations.DefaultAxe
                    },
                    ["chainsaw"] = new Tool
                    {
                        ShortName = "chainsaw",
                        Name = "Магическая бензопила",
                        CanRepair = false,
                        CanRecycle = false,
                        SkinId = 2057228026,
                        Transmutation = Transmutations.DefaultAxe
                    },
                    ["jackhammer"] = new Tool
                    {
                        ShortName = "jackhammer",
                        Name = "Магический отбойный молоток",
                        CanRepair = false,
                        CanRecycle = false,
                        SkinId = 2057228546,
                        Transmutation = Transmutations.DefaultPick
                    }
                }

            };

            #endregion

            public string CheckConfig(RustPlugin plugin)
            {
                List<string> result = Pool.GetList<string>();
                foreach (var pair in _tools)
                {
                    //version < 1.2.0
                    var canRecycle = plugin.Config["Список инструментов", pair.Key, "Можно ли перерабатывать пердмет"];
                    if (canRecycle != null)
                    {
                        pair.Value.CanRecycle = plugin.Config.ConvertValue<bool>(canRecycle);
                        result.Add($"Typo in the property of item {pair.Key} fixed.");
                    }

                    if (!pair.Value.ItemExists())
                    {
                        result.Add($"Item {pair.Key} not found in the game or not BaseMelee and would not be used.");
                        continue;
                    }

                    KeyValuePair<string, Tool> defined;
                    var customHash = pair.Value.GetCustomHash();

                    if(TryGet(customHash, out defined))
                    {
                        result.Add($"Item {pair.Key} is using the same skin that was already defined by {defined.Key} and would not be used.");
                        continue;
                    }
                    ToolsByKey[pair.Key] = pair.Value;
                    _toolsByHash[customHash] = pair;
                }

                var res = result.Count > 0 ? string.Join("\n", result) : null;
                Pool.FreeList(ref result);
                return res;
            }

            public bool TryGet(Item item, out Tool tool)
            {
                tool = null;
                var customItemHash = Tool.GetCustomHash(item);
                if (customItemHash == 0)
                    return false;
                KeyValuePair<string, Tool> toolData;
                if (!TryGet(customItemHash, out toolData))
                    return false;
                tool = toolData.Value;
                return true;
            }

            private bool TryGet(int hash, out KeyValuePair<string, Tool> pair) =>
                _toolsByHash.TryGetValue(hash, out pair);
        }
        #endregion

        #region Config handling⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Благодарим за приобретение плагина на сайте RustPlugin.ru. Если вы приобрели этот плагин на другом ресурсе знайте - это лишает вас гарантированных обновлений!");
            _config = PluginConfig.DefaultConfig;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<PluginConfig>();

            var checkResult = _config.CheckConfig(this);
            if (checkResult == null) 
                return;
            PrintWarning(checkResult);
            SaveConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }
        #endregion

        #region Init and quiting⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        void Init()
        {
            AddCovalenceCommand(_config.Command, "GiveToolsCommand", _config.Permission);
        }

        void OnServerInitialized()
        {
            foreach (var itemDefinition in ItemManager.GetItemDefinitions())
            {
                var cookable = itemDefinition.GetComponent<ItemModCookable>();
                if (cookable)
                    _itemToCookable[itemDefinition] = cookable.becomeOnCooked;
            }
            _itemToCookable.Add(ItemManager.FindItemDefinition("wood"), ItemManager.FindItemDefinition("charcoal"));
        }

        #endregion

        #region Oxide Hooks⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        object OnItemAction(Item item, string action, BasePlayer player)
        {
            return action != "refill" ? null : OnItemRepair(player, item);
        }
        object OnItemSkinChange(int skin, Item item, RepairBench bench, BasePlayer player)
        {
            if (!IsMachiningToolItem(item))
                return null;
            Reply(player, "Can't change skin");
            return false;
        }

        object OnItemRepair(BasePlayer player, Item item)
        {
            Tool tool;
            if (!_config.TryGet(item, out tool))
                return null;
            if (tool.CanRepair)
                return null;
            Reply(player, "Can't repair");
            return false;
        }

        object CanRecycle(Recycler recycler, Item item)
        {
            Tool tool;
            if (!_config.TryGet(item, out tool))
                return null;
            return tool.CanRecycle ? (object) null : false;
        }

        void OnDispenserGather(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            if (!player)
                return;
            var activeItem = player?.GetActiveItem();
            if (activeItem == null)
                return;

            Tool tool;
            if (!_config.TryGet(activeItem, out tool))
                return;

            if (tool.Transmutation.ShouldCook(item)) 
                Transmute(item);
        }

        void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            ulong playerid = 533504;
            OnDispenserGather(dispenser, player, item);
        }

        #endregion

        #region Localization⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        private void Reply(IPlayer player, string langKey, params object[] args)
        {
            var format = GetMsg(langKey, player.Id);
            player.Reply(args.Length != 0 ? string.Format(format, args) : format);
        }

        private void Reply(BasePlayer player, string langKey, params object[] args)
        {
            var reply = 521;
            var format = GetMsg(langKey, player.UserIDString);
            player.ChatMessage(args.Length != 0 ? string.Format(format, args) : format);
        }

        private string GetMsg(string langKey, string userId = null) => lang.GetMessage(langKey, this, userId);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Syntax"] = "Incorrect syntax! Use: {0} <NameOrID> item [item2] [item3] ...",
                ["No items"] = "The following items don't exist in the config, none of the items were given to the player \"{0}\":\n{1}",
                ["No player"] = "Player \"{0}\" could not be found",
                ["Not on server"] = "Player \"{0}\" is not on the server",
                ["Multiply players"] = "Found multiply players:\n{0}",
                ["Successful"] = "Successfully gave player \"{0}\" tools:\n{1}",
                ["Can't repair"] = "You can not repair this tool!",
                ["Can't change skin"] = "You can not change skin of this tool!"
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Syntax"] = "Неверный синтаксис! Используйте: {0} <ИмяИлиID> предмет [предмет2] [предмет3] ...",
                ["No items"] = "Следующие предметы из списка не найдены, ни один предмет не выдан игроку \"{0}\":\n{1}",
                ["No player"] = "Игрок \"{0}\" не найден",
                ["Not on server"] = "Игрок \"{0}\" не находится на сервере",
                ["Multiply players"] = "Найдено несколько игроков:\n{0}",
                ["Successful"] = "Успешно выдали игроку \"{0}\" предметы:\n{1}",
                ["Can't repair"] = "Данный предмет не подлежит ремонту!",
                ["Can't change skin"] = "Вы не можете изменить скин этого инструмента!"
            }, this, "ru");
        }
        #endregion

        #region Command⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        private void GiveToolsCommand(IPlayer player, string command, string[] args)
        {
            if (args.Length < 2)
            {
                Reply(player, "Syntax", _config.Command);
                return;
            }
            var targets =  covalence.Players.FindPlayers(args[0]).ToList();
            if (targets.Count == 0)
            {
                Reply(player, "No player", args[0]);
                return;
            }
            if (targets.Count > 1)
            {
                Reply(player, "Multiply players", string.Join("\n", targets.Select(p => $"{p.Name} [{p.Id}]")));
                return;
            }
            var target = targets[0].Object as BasePlayer;
            if (!target || !target.IsAlive())
            {
                Reply(player, "Not on server", target);
                return;
            }

            var configNames = args.Skip(1).ToList();
            var wrongNames = string.Join(", ",configNames.Where(x => !_config.ToolsByKey.ContainsKey(x)));
            if (!string.IsNullOrEmpty(wrongNames))
            {
                Reply(player, "No items", target, wrongNames);
                return;
            }

            foreach (var configName in configNames)
            {
                Tool tool = _config.ToolsByKey[configName];
                target.GiveItem(tool.Create());
            }
            Reply(player, "Successful", target, string.Join(", ", configNames));
        }
        #endregion

        #region API⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        [HookMethod("IsMachiningToolItem")]
        bool IsMachiningToolItem(Item item)
        {
            if (item == null)
                return false;
            Tool tool;
            return _config.TryGet(item, out tool);
        }

        #endregion

        #region Helpers⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        private void Transmute(Item item)
        {
            if (!_itemToCookable.ContainsKey(item.info))
            {
                PrintWarning($"[MachiningTools.Transmute] Unhandled item - {item.info.displayName.english}!\nPlease contact developer: https://vk.com/vlad_00003");
                return;
            }
            item.info = _itemToCookable[item.info];
        }
        #endregion
    }
}
///////////////////////////////////////////////////////////


// --- End of file: MachiningTools.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/NameRewards.cs ---
// --- Original Local Path: KualaRust/NameRewards.cs ---

using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;

namespace Oxide.Plugins
{
    [Info("NameRewards", "Vlad-00003", "1.1.1", ResourceId = 197)]
    [Description("Gives the players rewards if their nickname contains desired word")]
    /*
     * Author info:
     *   E-mail: Vlad-00003@mail.ru
     *   Vk: vk.com/vlad_00003
     */
    class NameRewards : CovalencePlugin
    {
        #region Vars⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        private PluginConfig _config;
        #endregion

        #region Config⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        private class PluginConfig
        {
            [JsonProperty("Варианты текста, который должен быть в нике")]
            public List<string> Texts = new List<string>();
            [JsonProperty("Использовать регулярные выражения")]
            public bool UseRegex;
            [JsonProperty("Не учитывать регистр")]
            public bool IgnoreCase;
            [JsonProperty("Оповещать о получении привилегий/необходимости добавления текста")]
            public bool Notify;
            [JsonProperty("Формат сообщений в чате")]
            public string ChatFormat;
            [JsonProperty("Привилегии, которые будут выданы")]
            public List<string> Permissions;
            [JsonProperty("Группы, в которые игрок будет добавлен")]
            public List<string> Groups;
            
            public struct Message
            {
                public string LangKey;
                public object[] Args;

                public Message(string langKey, params object[] args)
                {
                    LangKey = langKey;
                    Args = args;
                }
            }

            public Message AvailableOptions()
            {
                switch (Texts.Count)
                {
                    case 0:
                        return default(Message);
                    case 1:
                        return new Message("Not", Texts[0]);
                    default: 
                        var result = $"\"{Texts[0]}\"";
                        for (var i = 1; i < Texts.Count-1; i++)
                        {
                            result += $", \"{Texts[i]}\"";
                        }

                        return new Message("NotMulti", result, $"\"{Texts[Texts.Count-1]}\"");
                }
            }

            [JsonIgnore]
            private Func<string, string, bool> _check;
            
            [JsonIgnore]
            private Func<string, string, bool> Check
            {
                get
                {
                    if (_check != null) 
                        return _check;

                    if (!UseRegex)
                    {
                        if (IgnoreCase)
                            _check = (x, y) => x.IndexOf(y, StringComparison.InvariantCultureIgnoreCase) != -1;
                        else
                            _check = (x, y) => x.Contains(y);
                    }
                    else
                    {
                        if (IgnoreCase)
                            _check = (x, y) => Regex.IsMatch(x, y, RegexOptions.IgnoreCase);
                        else
                            _check =  Regex.IsMatch;
                    }
                    return _check;
                }

            }
            
            #region Default Config⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

            public static PluginConfig DefaultConfig => new PluginConfig
            {
                Texts = new List<string>{"Лучший сервер!"},
                Notify = true,
                IgnoreCase = true,
                UseRegex = false,
                ChatFormat = "[#green][NameRewards][/#] {0}",
                Permissions = new List<string> { "kits.nickname", "nteleportation.nickname" },
                Groups = new List<string> { "nickname" }
            };

            #endregion

            public bool IsMatch(string text, out string found)
            {
                found = null;
                foreach (var pattern in Texts)
                {
                    if(!Check(text,pattern))
                        continue;
                    found = pattern;
                    return true;
                }
                return false;
            }
        }
        #endregion

        #region Config init⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        private bool CheckConfig()
        {
            var res = false;

            //==version < 1.1.0==
            var oldText = Config.Get("Текст, который должен быть в нике") as string;
            if (oldText != null)
            {
                PrintWarning("Config file updated: multiple texts support, regex and case-insensitive switches added");
                Config.Clear();
                _config.UseRegex = false;
                _config.IgnoreCase = true;
                _config.Texts.Add(oldText);
                res = true;
            }

            return res;
        }
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Благодарим за приобретение плагина на сайте RustPlugin.ru. Если вы приобрели этот плагин на другом ресурсе знайте - это лишает вас гарантированных обновлений!");
            _config = PluginConfig.DefaultConfig;
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<PluginConfig>();
            if (CheckConfig()) 
                SaveConfig();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }
        #endregion

        #region Localization⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        private void SendResponse(IPlayer player, string langKey, params object[] args)
        {
            var format = GetMsg(langKey, player.Id);
            format = args.Length != 0 ? string.Format(format, args) : format;
            player.Reply(string.Format(_config.ChatFormat,format)); 
        }
        private string GetMsg(string key, string playerid) => lang.GetMessage(key, this, playerid);

        private string GetMsg(string key, ulong playerid = 533504) =>
            GetMsg(key, playerid == 0 ? null : playerid.ToString());

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Granted"] = "You have \"{0}\" in your nickname! Enjoy your gifts!",
                ["Not"] = "You don't have \"{0}\" in your nickname!\nIf you want to get free gifts - add it to the nickanme and reconnect to the server!",
                ["NotMulti"] = "You don't have {0} or {1} in your nickname!\nIf you want to get free gifts - add it to the nickanme and reconnect to the server!"
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Granted"] = "У вас в нике есть текст \"{0}\"!\nНаслаждайтесь вашими привилегиями!",
                ["Not"] = "У вас в нике нет текста \"{0}\"!\nЕсли вы хотите получить подарки - добавьте этот текст к нику и перезайдите на сервер!",
                ["NotMulti"] = "У вас в нике нет текста {0} или {1}!\nЕсли вы хотите получить подарки - добавьте этот текст к нику и перезайдите на сервер!"
            }, this, "ru");
        }
        #endregion

        private void Init()
        {
            foreach (var player in covalence.Players.Connected)
            {
                OnUserConnected(player);
            }
        }

        private void OnUserConnected(IPlayer player)
        {
            string found;
            if (_config.IsMatch(player.Name, out found))
            {
                Grant(player);
                if(_config.Notify)
                    SendResponse(player,"Granted",found);
                return;
            }
            Revoke(player);
            if (_config.Notify)
            {
                var message = _config.AvailableOptions();
                if (string.IsNullOrEmpty(message.LangKey))
                    return;
                SendResponse(player,message.LangKey,message.Args);
            }
        }

        #region Grant|Revoke methods⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        private void Grant(IPlayer player)
        {
            foreach(var perm in _config.Permissions)
            {
                if (!permission.PermissionExists(perm))
                {
                    PrintWarning($"Permission \"{perm}\" doesn't exists and wasn't granted to the player \"{player.Name}\"");
                    continue;
                }
                player.GrantPermission(perm);
            }
            foreach(var group in _config.Groups)
            {
                if (!permission.GroupExists(group))
                {
                    PrintWarning($"Group \"{group}\" doesn't exists and the player \"{player.Name}\" wasn't added to it.");
                    continue;
                }
                player.AddToGroup(group);
            }
        }
        private void Revoke(IPlayer player)
        {
            foreach (var perm in _config.Permissions)
            {
                if (!permission.PermissionExists(perm))
                {
                    PrintWarning($"Permission \"{perm}\" doesn't exists and wasn't removed form the player \"{player.Name}\"");
                    continue;
                }
                player.RevokePermission(perm);
            }
            foreach (var group in _config.Groups)
            {
                if (!permission.GroupExists(group))
                {
                    PrintWarning($"Group \"{group}\" doesn't exists and the player \"{player.Name}\" wasn't removed from it.");
                    continue;
                }
                player.RemoveFromGroup(group);
            }
        }
        #endregion
    }
}


// --- End of file: NameRewards.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KualaRust/Help.cs ---
// --- Original Local Path: KualaRust/Help.cs ---

﻿using System;
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using System.Globalization;
using UnityEngine;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Help", "vk.com/rust_fans", "1.0.0")]
    class Help : RustPlugin
    {
        #region Variables
        [JsonProperty("Системный слой")] private string Layer = "UI_Help";
        [PluginReference] private Plugin ImageLibrary;
        #endregion

        #region Command
        [ChatCommand("help")]
        void cmdChatOnes(BasePlayer player, string command, string[] args) => InfoUI(player);

        #region Command
        [ChatCommand("1")]
        void cmdChatOne(BasePlayer player, string command, string[] args) => OneUI(player);

        [ChatCommand("2")]
        void cmdChatTwo(BasePlayer player, string command, string[] args) => TwoUI(player);

        [ChatCommand("3")]
        void cmdChatThree(BasePlayer player, string command, string[] args) => ThreeUI(player);

        [ChatCommand("4")]
        void cmdChatFour(BasePlayer player, string command, string[] args) => FourUI(player);

        [ChatCommand("5")]
        void cmdChatFive(BasePlayer player, string command, string[] args) => FiveUI(player);
        
        [ChatCommand("6")]
        void cmdChatSix(BasePlayer player, string command, string[] args) => SixUI(player);

        [ChatCommand("7")]
        void cmdChatSeven(BasePlayer player, string command, string[] args) => SevenUI(player);

        [ConsoleCommand("10")]
        void cmdConsoleShop(ConsoleSystem.Arg args)
        {
            InfoUI(args.Player());
        }

        #endregion

        void OnServerInitialized()
        {
			ImageLibrary.Call("AddImage", "https://gspics.org/images/2020/08/20/xgAGe.png", "Logo");
        }

        #region Ui
        private void InfoUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, Layer);
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.97", Sprite = "Assets/Content/UI/UI.Background.Tile.psd", FadeIn = 0.7f },
                FadeOut = 0.7f
            }, "Overlay", Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.28 0.21", AnchorMax = $"1 0.7", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0" },
                Text = { Text = "                 ДОБРО ПОЖАЛОВАТЬ <color=#32C8C8><b>" + player.displayName.ToUpper() + "</b></color>\n\n<color=#ffa987><b>ОПИСАНИЕ СЕРВЕРА:</b></color>\n\n• Администрация 20+\n• Стартовые Киты\n• Рейты X2 на ресурсы и на компоненты X2\n• Временный блок предметов после вайпа\n• Бесплатные оповещение о рейдах\n• Система телепортов, дуэлей и трейды\n• Апгрейд, ремув и рейдблок\n• Карта(/Map) \n• Ивенты и удобнейшее Меню сервера(/Menu) \n• Радиоактивная руда при добыче ресурсов\n• СВО не стреляют в зоне дейсвия Вашего шкафа", Font = "robotocondensed-regular.ttf", FontSize = 20, Color = HexToCuiColor("#e4e4e4ba"), Align = TextAnchor.MiddleLeft, FadeIn = 0.7f }
            }, Layer);


            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.05 0.8", AnchorMax = $"0.2 0.85", OffsetMax = "0 0" },
                Button = { Color = "0.8 0.40 0.40 0.2", Material = "assets/content/ui/uibackgroundblur.mat", Command = "chat.say 0 /help", Close = Layer, FadeIn = 0.7f },
                Text = { Text = "<color=#ff8484>О СЕРВЕРЕ</color>", Font = "RobotoCondensed-Regular.ttf", FontSize = 25, Align = TextAnchor.MiddleCenter, FadeIn = 0.7f }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.05 0.7", AnchorMax = $"0.2 0.75", OffsetMax = "0 0" },
                Button = { Color = "0.8 0.40 0.40 0", Material = "assets/content/ui/uibackgroundblur.mat", Command = "chat.say /1", Close = Layer, FadeIn = 0.7f },
                Text = { Text = "ПРАВИЛА", Font = "RobotoCondensed-Regular.ttf", FontSize = 25, Align = TextAnchor.MiddleCenter, FadeIn = 0.7f }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.05 0.6", AnchorMax = $"0.2 0.65", OffsetMax = "0 0" },
                Button = { Color = "0.8 0.40 0.40 0", Material = "assets/content/ui/uibackgroundblur.mat", Command = "chat.say /2", Close = Layer, FadeIn = 0.7f },
                Text = { Text = "КОМАНДЫ", Font = "RobotoCondensed-Regular.ttf", FontSize = 25, Align = TextAnchor.MiddleCenter, FadeIn = 0.7f }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.05 0.5", AnchorMax = $"0.2 0.55", OffsetMax = "0 0" },
                Button = { Color = "0.8 0.40 0.40 0", Material = "assets/content/ui/uibackgroundblur.mat", Command = "chat.say /3", Close = Layer, FadeIn = 0.7f },
                Text = { Text = "БИНДЫ", Font = "RobotoCondensed-Regular.ttf", FontSize = 25, Align = TextAnchor.MiddleCenter, FadeIn = 0.7f }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.05 0.4", AnchorMax = $"0.2 0.45", OffsetMax = "0 0" },
                Button = { Color = "0.8 0.40 0.40 0", Material = "assets/content/ui/uibackgroundblur.mat", Command = "chat.say /4", Close = Layer, FadeIn = 0.7f },
                Text = { Text = "НАБОРЫ", Font = "RobotoCondensed-Regular.ttf", FontSize = 25, Align = TextAnchor.MiddleCenter, FadeIn = 0.7f }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.38 0.12", AnchorMax = $"0.62 0.17", OffsetMax = "0 0" },
                Button = { Color = "1.00 0.00 1.00 0.05", Material = "assets/content/ui/uibackgroundblur.mat", Close = Layer, FadeIn = 0.7f },
                Text = { Text = "<color=#ffa987>••• Выход •••</color>", Font = "RobotoCondensed-Regular.ttf", FontSize = 25, Align = TextAnchor.MiddleCenter, FadeIn = 0.7f }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.05 0.3", AnchorMax = $"0.2 0.35", OffsetMax = "0 0" },
                Button = { Color = "0.8 0.40 0.40 0", Material = "assets/content/ui/uibackgroundblur.mat", Command = "chat.say /5", Close = Layer, FadeIn = 0.7f },
                Text = { Text = "ВАЙПЫ", Font = "RobotoCondensed-Regular.ttf", FontSize = 25, Align = TextAnchor.MiddleCenter, FadeIn = 0.7f }
            }, Layer);
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.05 0.2", AnchorMax = $"0.2 0.25", OffsetMax = "0 0" },
                Button = { Color = "0.8 0.40 0.40 0", Material = "assets/content/ui/uibackgroundblur.mat", Command = "chat.say /6", Close = Layer, FadeIn = 0.7f },
                Text = { Text = "КОНТАКТЫ", Font = "RobotoCondensed-Regular.ttf", FontSize = 25, Align = TextAnchor.MiddleCenter, FadeIn = 0.7f }
            }, Layer);

            container.Add(new CuiElement
            {
                Parent = Layer,
                Components =
                {
                    new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", "Logo") },
                    new CuiRectTransformComponent { AnchorMin = "0.2 0.71", AnchorMax = "0.8 0.95", OffsetMax = "0 0" }
                }
            });

            CuiHelper.AddUi(player, container);
        }

        #region OneUi
        private void OneUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, Layer);
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.97", Sprite = "Assets/Content/UI/UI.Background.Tile.psd", FadeIn = 0.7f },
                FadeOut = 0.7f
            }, "Overlay", Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.28 0.05", AnchorMax = $"0.8 0.9", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0" },
                Text = { Text = "                 ДОБРО ПОЖАЛОВАТЬ <color=#32C8C8><b>" + player.displayName.ToUpper() + "</b></color>\n\n<color=#ffa987><b>ПРАВИЛА СЕРВЕРА:</b></color>\n\n1. Запрещено использовать посторонний софт для игры\n2. Запрещено критиковать, обсуждать действия администрации\n3. Запрещено хейтерство, спам, реклама в любом виде\n4. Администрация вправе проверить любого игрока на читы, а также запретить доступ к серверу без объяснения причины\n5. Запрещены баги и обучение им других игроков\n6. Все добровольные пожертвования (донат) направляются на развитие проекта и не подлежат возврату\n7. Полный свод правил в группе сервера ВК и Discord, незнание правил не освобождает от банов на проекте ", Font = "robotocondensed-regular.ttf", FontSize = 20, Color = HexToCuiColor("#FFFFFF5A"), Align = TextAnchor.MiddleLeft, FadeIn = 0.7f }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.05 0.8", AnchorMax = $"0.2 0.85", OffsetMax = "0 0" },
                Button = { Color = "0.8 0.40 0.40 0", Material = "assets/content/ui/uibackgroundblur.mat", Command = "chat.say /help", Close = Layer, FadeIn = 0.7f },
                Text = { Text = "О СЕРВЕРЕ", Font = "RobotoCondensed-Regular.ttf", FontSize = 25, Align = TextAnchor.MiddleCenter, FadeIn = 0.7f }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.05 0.7", AnchorMax = $"0.2 0.75", OffsetMax = "0 0" },
                Button = { Color = "0.8 0.40 0.40 0.2", Material = "assets/content/ui/uibackgroundblur.mat", Command = "chat.say /1", Close = Layer, FadeIn = 0.7f },
                Text = { Text = "<color=#ff8484>ПРАВИЛА</color>", Font = "RobotoCondensed-Regular.ttf", FontSize = 25, Align = TextAnchor.MiddleCenter, FadeIn = 0.7f }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.05 0.6", AnchorMax = $"0.2 0.65", OffsetMax = "0 0" },
                Button = { Color = "0.8 0.40 0.40 0", Material = "assets/content/ui/uibackgroundblur.mat", Command = "chat.say /2", Close = Layer, FadeIn = 0.7f },
                Text = { Text = "КОМАНДЫ", Font = "RobotoCondensed-Regular.ttf", FontSize = 25, Align = TextAnchor.MiddleCenter, FadeIn = 0.7f }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.05 0.5", AnchorMax = $"0.2 0.55", OffsetMax = "0 0" },
                Button = { Color = "0.8 0.40 0.40 0", Material = "assets/content/ui/uibackgroundblur.mat", Command = "chat.say /3", Close = Layer, FadeIn = 0.7f },
                Text = { Text = "БИНДЫ", Font = "RobotoCondensed-Regular.ttf", FontSize = 25, Align = TextAnchor.MiddleCenter, FadeIn = 0.7f }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.05 0.4", AnchorMax = $"0.2 0.45", OffsetMax = "0 0" },
                Button = { Color = "0.8 0.40 0.40 0", Material = "assets/content/ui/uibackgroundblur.mat", Command = "chat.say /4", Close = Layer, FadeIn = 0.7f },
                Text = { Text = "НАБОРЫ", Font = "RobotoCondensed-Regular.ttf", FontSize = 25, Align = TextAnchor.MiddleCenter, FadeIn = 0.7f }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.05 0.3", AnchorMax = $"0.2 0.35", OffsetMax = "0 0" },
                Button = { Color = "0.8 0.40 0.40 0", Material = "assets/content/ui/uibackgroundblur.mat", Command = "chat.say /5", Close = Layer, FadeIn = 0.7f },
                Text = { Text = "ВАЙПЫ", Font = "RobotoCondensed-Regular.ttf", FontSize = 25, Align = TextAnchor.MiddleCenter, FadeIn = 0.7f }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.05 0.2", AnchorMax = $"0.2 0.25", OffsetMax = "0 0" },
                Button = { Color = "0.8 0.40 0.40 0", Material = "assets/content/ui/uibackgroundblur.mat", Command = "chat.say /6", Close = Layer, FadeIn = 0.7f },
                Text = { Text = "КОНТАКТЫ", Font = "RobotoCondensed-Regular.ttf", FontSize = 25, Align = TextAnchor.MiddleCenter, FadeIn = 0.7f }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.38 0.12", AnchorMax = $"0.62 0.17", OffsetMax = "0 0" },
                Button = { Color = "1.00 0.00 1.00 0.05", Material = "assets/content/ui/uibackgroundblur.mat", Close = Layer, FadeIn = 0.7f },
                Text = { Text = "<color=#ffa987>••• Выход •••</color>", Font = "RobotoCondensed-Regular.ttf", FontSize = 25, Align = TextAnchor.MiddleCenter, FadeIn = 0.7f }
            }, Layer);

            container.Add(new CuiElement
            {
                Parent = Layer,
                Components =
                {
                    new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", "Logo") },
                    new CuiRectTransformComponent { AnchorMin = "0.2 0.71", AnchorMax = "0.8 0.95", OffsetMax = "0 0" }
                }
            });

            CuiHelper.AddUi(player, container);
        }

        #region TwoUi
        private void TwoUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, Layer);
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.97", Sprite = "Assets/Content/UI/UI.Background.Tile.psd", FadeIn = 0.7f },
                FadeOut = 0.7f
            }, "Overlay", Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.25 0.47", AnchorMax = $"1 0.8", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0" },
                Text = { Text = "                         ДОБРО ПОЖАЛОВАТЬ <color=#32C8C8><b>" + player.displayName.ToUpper() + "</b></color>\n\n        <color=#ffa987><b>КОМАНДЫ СЕРВЕРА:</b></color>\n", Font = "robotocondensed-regular.ttf", FontSize = 20, Color = HexToCuiColor("#e4e4e4ba"), Align = TextAnchor.MiddleLeft, FadeIn = 0.7f }
            }, Layer);

            container.Add(new CuiButton
            {
				RectTransform = { AnchorMin = "0.28 0.24", AnchorMax = $"0.5 0.84", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0" },
                Text = { Text = "\n\n\n\n\n\n\n<color=orange>/battle</color> - вызвать на поединок\n<color=orange>/kit</color> - доступные наборы\n<color=orange>/map</color> - карта сервера\n<color=orange>/remove</color> - удаление построек\n<color=orange>/up</color> - улучшение построек\n<color=orange>/store</color> - корзина магазина\n<color=orange>/al</color> - настройка авторизации в замках\n<color=orange>/craft</color> - крафт уникальных предметов", Font = "robotocondensed-regular.ttf", FontSize = 21, Align = TextAnchor.MiddleLeft, Color = HexToCuiColor("#FFFFFF5A"), FadeIn = 0.7f }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5 0.24", AnchorMax = $"0.91 0.84", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0" },
                Text = { Text = "\n\n\n\n\n\n\n<color=orange>/rn</color> - уведомления о рейдах\n<color=orange>/trade</color> - обмен вещами\n<color=orange>/tpr</color> - телепорт к игроку\n<color=orange>/pinfo</color> - просмотр своих привилегий\n<color=orange>/home</color> - телепорты домой\n<color=orange>/skin</color> - изменение скинов\n<color=orange>/block</color> - блок предметов\n<color=orange>/hitmarker</color> - вкл/выкл хитмаркер\n<color=orange>/friend</color> - настройка друзей\n<color=orange>/chat</color> - настройка чата", Font = "robotocondensed-regular.ttf", FontSize = 21, Align = TextAnchor.MiddleLeft, Color = HexToCuiColor("#FFFFFF5A"), FadeIn = 0.7f }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.05 0.8", AnchorMax = $"0.2 0.85", OffsetMax = "0 0" },
                Button = { Color = "0.8 0.40 0.40 0", Material = "assets/content/ui/uibackgroundblur.mat", Command = "chat.say /help", Close = Layer, FadeIn = 0.7f },
                Text = { Text = "О СЕРВЕРЕ", Font = "RobotoCondensed-Regular.ttf", FontSize = 25, Align = TextAnchor.MiddleCenter, FadeIn = 0.7f }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.05 0.7", AnchorMax = $"0.2 0.75", OffsetMax = "0 0" },
                Button = { Color = "0.8 0.40 0.40 0", Material = "assets/content/ui/uibackgroundblur.mat", Command = "chat.say /1", Close = Layer, FadeIn = 0.7f },
                Text = { Text = "ПРАВИЛА", Font = "RobotoCondensed-Regular.ttf", FontSize = 25, Align = TextAnchor.MiddleCenter, FadeIn = 0.7f }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.05 0.6", AnchorMax = $"0.2 0.65", OffsetMax = "0 0" },
                Button = { Color = "0.8 0.40 0.40 0.2", Material = "assets/content/ui/uibackgroundblur.mat", Command = "chat.say /2", Close = Layer, FadeIn = 0.7f },
                Text = { Text = "<color=#ff8484>КОМАНДЫ</color>", Font = "RobotoCondensed-Regular.ttf", FontSize = 25, Align = TextAnchor.MiddleCenter, FadeIn = 0.7f }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.05 0.5", AnchorMax = $"0.2 0.55", OffsetMax = "0 0" },
                Button = { Color = "0.8 0.40 0.40 0", Material = "assets/content/ui/uibackgroundblur.mat", Command = "chat.say /3", Close = Layer, FadeIn = 0.7f },
                Text = { Text = "БИНДЫ", Font = "RobotoCondensed-Regular.ttf", FontSize = 25, Align = TextAnchor.MiddleCenter, FadeIn = 0.7f }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.05 0.4", AnchorMax = $"0.2 0.45", OffsetMax = "0 0" },
                Button = { Color = "0.8 0.40 0.40 0", Material = "assets/content/ui/uibackgroundblur.mat", Command = "chat.say /4", Close = Layer, FadeIn = 0.7f },
                Text = { Text = "НАБОРЫ", Font = "RobotoCondensed-Regular.ttf", FontSize = 25, Align = TextAnchor.MiddleCenter, FadeIn = 0.7f }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.05 0.3", AnchorMax = $"0.2 0.35", OffsetMax = "0 0" },
                Button = { Color = "0.8 0.40 0.40 0", Material = "assets/cont