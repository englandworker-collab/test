alization 1.1.1
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Usage", "Usage:\n" +
                          " * blueprintmanager reset 'player name or id' - resets blueprints for player\n" +
                          " * blueprintmanager unlock 'player name or id' 'item shortname' - unlock specified blueprint for player\n" +
                          " * blueprintmanager unlockall 'player name or id'- unlocks all blueprints for player"},
                {"Permission", "You don't have permission to use that!"},
                
                {"No Players", "There are no players with that Name or steamID! ({0})"},
                {"Multiple Players", "There are many players with that Name:\n{0}"},
                {"Success", "Your action was done successfully for '{0}'!"}
            }, this);
        }
        
        private string GetMessage(string messageKey, string playerID, params object[] args)
        {
            return string.Format(lang.GetMessage(messageKey, this, playerID), args);
        }

        private void Message(ConsoleSystem.Arg arg, string messageKey, params object[] args)
        {
            var message = GetMessage(messageKey, null, args);
            var player = arg.Player();
            if (player != null)
            {
                player.ChatMessage(message);
            }
            else
            {
                SendReply(arg, message);
            }
        }

        #endregion
    }
}

// --- End of file: BlueprintManager.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/Backpacks.cs ---
// --- Original Local Path: BeeRust/Backpacks.cs ---

ï»¿// #define DEBUG_POOLING
// #define DEBUG_BACKPACK_LIFECYCLE

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using Network;
using Newtonsoft.Json.Converters;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries;
using Rust;
using UnityEngine;
using UnityEngine.UI;
using Time = UnityEngine.Time;

namespace Oxide.Plugins
{
    [Info("Backpacks", "WhiteThunder", "3.11.9")]
    [Description("Allows players to have a Backpack which provides them extra inventory space.")]
    internal class Backpacks : CovalencePlugin
    {
        #region Fields

        private static int _maxCapacityPerPage = 48;

        private const int MinRows = 1;
        private const int MaxRows = 8;
        private const int MinCapacity = 1;
        private const int MaxCapacity = 48;
        private const int SlotsPerRow = 6;
        private const int ReclaimEntryMaxSize = 40;
        private const float StandardLootDelay = 0.1f;
        private const Item.Flag UnsearchableItemFlag = (Item.Flag)(1 << 24);

        private const string UsagePermission = "backpacks.use";
        private const string SizePermission = "backpacks.size";
        private const string GUIPermission = "backpacks.gui";
        private const string FetchPermission = "backpacks.fetch";
        private const string GatherPermission = "backpacks.gather";
        private const string RetrievePermission = "backpacks.retrieve";
        private const string AdminPermission = "backpacks.admin";
        private const string KeepOnDeathPermission = "backpacks.keepondeath";
        private const string LegacyKeepOnWipePermission = "backpacks.keeponwipe";
        private const string LegacyNoBlacklistPermission = "backpacks.noblacklist";

        private const string CoffinPrefab = "assets/prefabs/misc/halloween/coffin/coffinstorage.prefab";
        private const string DroppedBackpackPrefab = "assets/prefabs/misc/item drop/item_drop_backpack.prefab";
        private const string ResizableLootPanelName = "generic_resizable";

        private const int SaddleBagItemId = 1400460850;

        private readonly BackpackCapacityManager _backpackCapacityManager;
        private readonly BackpackManager _backpackManager;
        private readonly SubscriberManager _subscriberManager = new SubscriberManager();

        private ProtectionProperties _immortalProtection;
        private Effect _reusableEffect = new Effect();
        private string _cachedButtonUi;

        private readonly ApiInstance _api;
        private Configuration _config;
        private StoredData _storedData;
        private readonly HashSet<ulong> _uiViewers = new HashSet<ulong>();
        private Coroutine _saveRoutine;

        [PluginReference]
        private readonly Plugin Arena, BagOfHolding, BackpackButton, EventManager, ItemRetriever;

        public Backpacks()
        {
            _backpackCapacityManager = new BackpackCapacityManager(this);
            _backpackManager = new BackpackManager(this);
            _api = new ApiInstance(this);
        }

        #endregion

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(UsagePermission, this);
            permission.RegisterPermission(GUIPermission, this);
            permission.RegisterPermission(FetchPermission, this);
            permission.RegisterPermission(GatherPermission, this);
            permission.RegisterPermission(RetrievePermission, this);
            permission.RegisterPermission(AdminPermission, this);
            permission.RegisterPermission(KeepOnDeathPermission, this);

            _config.Init(this);

            _maxCapacityPerPage = Mathf.Clamp(_config.BackpackSize.MaxCapacityPerPage, MinCapacity, MaxCapacity);

            _backpackCapacityManager.Init(_config);

            PoolUtils.ResizePools();

            _storedData = StoredData.Load();

            Unsubscribe(nameof(OnPlayerSleep));
            Unsubscribe(nameof(OnPlayerSleepEnded));

            if (_config.GUI.Enabled)
            {
                AddCovalenceCommand("backpackgui", nameof(ToggleBackpackGUICommand));
            }
            else
            {
                Unsubscribe(nameof(OnPlayerConnected));
                Unsubscribe(nameof(OnNpcConversationStart));
                Unsubscribe(nameof(OnNpcConversationEnded));
            }
        }

        private void OnServerInitialized()
        {
            _immortalProtection = ScriptableObject.CreateInstance<ProtectionProperties>();
            _immortalProtection.name = "BackpacksProtection";
            _immortalProtection.Add(1);

            CheckBackpackButtonPlugin();
            RegisterAsItemSupplier();

            if (_config.GUI.Enabled)
            {
                Subscribe(nameof(OnPlayerSleep));
                Subscribe(nameof(OnPlayerSleepEnded));
                Subscribe(nameof(OnPlayerConnected));
                Subscribe(nameof(OnNpcConversationStart));
                Subscribe(nameof(OnNpcConversationEnded));

                foreach (var player in BasePlayer.activePlayerList)
                {
                    MaybeCreateButtonUi(player);
                }
            }
        }

        private void Unload()
        {
            UnityEngine.Object.Destroy(_immortalProtection);

            RestartSaveRoutine(async: false, keepInUseBackpacks: false);

            BackpackNetworkController.ResetNetworkGroupId();

            foreach (var player in BasePlayer.activePlayerList)
            {
                DestroyButtonUi(player);
            }

            PoolUtils.ResizePools(empty: true);
        }

        private void OnNewSave(string filename)
        {
            if (!_config.ClearOnWipe.Enabled)
                return;

            _backpackManager.ClearCache();

            IEnumerable<string> fileNames;
            try
            {
                fileNames = Interface.Oxide.DataFileSystem.GetFiles(Name)
                    .Select(fn => {
                        return fn.Split(Path.DirectorySeparatorChar).Last()
                            .Replace(".json", string.Empty);
                    });
            }
            catch (DirectoryNotFoundException)
            {
                // No backpacks to clear.
                return;
            }

            var skippedBackpackCount = 0;

            foreach (var fileName in fileNames)
            {
                ulong userId;
                if (!ulong.TryParse(fileName, out userId))
                    continue;

                var ruleset = _config.ClearOnWipe.GetForPlayer(fileName);
                if (ruleset == null || ruleset.DisallowsAll)
                {
                    _backpackManager.ClearBackpackFile(userId);
                    continue;
                }

                if (ruleset.AllowsAll)
                    continue;

                var backpack = _backpackManager.GetBackpackIfExists(userId);
                if (backpack == null)
                    continue;

                backpack.EraseContents(ruleset);
                backpack.SaveIfChanged();
            }

            _backpackManager.ClearCache();
            LogWarning($"New save created. Backpacks were wiped according to the config and player permissions.");
        }

        private void OnServerSave()
        {
            RestartSaveRoutine(async: true, keepInUseBackpacks: true);
        }

        private void OnPluginLoaded(Plugin plugin)
        {
            switch (plugin.Name)
            {
                case nameof(BackpackButton):
                    CheckBackpackButtonPlugin();
                    break;
                case nameof(ItemRetriever):
                    RegisterAsItemSupplier();
                    break;
                case nameof(BagOfHolding):
                {
                    NextTick(() =>
                    {
                        if (!plugin.IsLoaded)
                            return;

                        _backpackManager.DiscoverBags(plugin);
                    });
                    break;
                }
            }
        }

        private void OnPluginUnloaded(Plugin plugin)
        {
            _subscriberManager.RemoveSubscriber(plugin);
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            _backpackCapacityManager.ForgetCachedCapacity(player.userID);
            _backpackManager.GetBackpackIfCached(player.userID)?.NetworkController?.Unsubscribe(player);
        }

        // Handle player death by normal means.
        private void OnEntityDeath(BasePlayer player, HitInfo info) =>
            OnEntityKill(player);

        // Handle player death while sleeping in a safe zone.
        private void OnEntityKill(BasePlayer player)
        {
            if (player.IsNpc)
                return;

            DestroyButtonUi(player);

            if (!_backpackManager.HasBackpackFile(player.userID)
                || permission.UserHasPermission(player.UserIDString, KeepOnDeathPermission))
                return;

            if (_config.EraseOnDeath)
            {
                _backpackManager.TryEraseForPlayer(player.userID);
            }
            else if (_config.DropOnDeath)
            {
                _backpackManager.Drop(player.userID, player.transform.position);
            }
        }

        private void OnGroupPermissionGranted(string groupName, string perm)
        {
            if (!perm.StartsWith("backpacks"))
                return;

            if (perm.StartsWith(SizePermission) || perm.StartsWith(UsagePermission))
            {
                _backpackManager.HandleCapacityPermissionChangedForGroup(groupName);
            }
            else if (perm.StartsWith(RestrictionRuleset.FullPermissionPrefix) || perm.Equals(LegacyNoBlacklistPermission))
            {
                _backpackManager.HandleRestrictionPermissionChangedForGroup(groupName);
            }
            else if (perm.Equals(GatherPermission))
            {
                _backpackManager.HandleGatherPermissionChangedForGroup(groupName);
            }
            else if (perm.Equals(RetrievePermission))
            {
                _backpackManager.HandleRetrievePermissionChangedForGroup(groupName);
            }
            else if (_config.GUI.Enabled && perm.Equals(GUIPermission))
            {
                var groupName2 = groupName;
                foreach (var player in BasePlayer.activePlayerList.Where(p => permission.UserHasGroup(p.UserIDString, groupName2)))
                {
                    CreateOrDestroyButtonUi(player);
                }
            }
        }

        private void OnGroupPermissionRevoked(string groupName, string perm)
        {
            OnGroupPermissionGranted(groupName, perm);
        }

        private void OnUserPermissionGranted(string userId, string perm)
        {
            if (!perm.StartsWith("backpacks"))
                return;

            if (perm.StartsWith(SizePermission) || perm.StartsWith(UsagePermission))
            {
                _backpackManager.HandleCapacityPermissionChangedForUser(userId);
            }
            else if (perm.StartsWith(RestrictionRuleset.FullPermissionPrefix) || perm.Equals(LegacyNoBlacklistPermission))
            {
                _backpackManager.HandleRestrictionPermissionChangedForUser(userId);
            }
            else if (perm.Equals(GatherPermission))
            {
                _backpackManager.HandleGatherPermissionChangedForUser(userId);
            }
            else if (perm.Equals(RetrievePermission))
            {
                _backpackManager.HandleRetrievePermissionChangedForUser(userId);
            }
            else if (_config.GUI.Enabled && perm.Equals(GUIPermission))
            {
                var player = BasePlayer.Find(userId);
                if (player != null)
                {
                    CreateOrDestroyButtonUi(player);
                }
            }
        }

        private void OnUserPermissionRevoked(string userId, string perm)
        {
            OnUserPermissionGranted(userId, perm);
        }

        private void OnUserGroupAdded(string userId, string groupName)
        {
            _backpackManager.HandleGroupChangeForUser(userId);
        }

        private void OnUserGroupRemoved(string userId, string groupName)
        {
            _backpackManager.HandleGroupChangeForUser(userId);
        }

        // Only subscribed while the GUI button is enabled.
        private void OnPlayerConnected(BasePlayer player) => MaybeCreateButtonUi(player);

        private void OnPlayerRespawned(BasePlayer player)
        {
            MaybeCreateButtonUi(player);
            _backpackManager.GetBackpackIfCached(player.userID)?.PauseGatherMode(1f);
        }

        // Only subscribed while the GUI button is enabled.
        private void OnPlayerSleepEnded(BasePlayer player) => OnPlayerRespawned(player);

        // Only subscribed while the GUI button is enabled.
        private void OnPlayerSleep(BasePlayer player) => DestroyButtonUi(player);

        // Only subscribed while the GUI button is enabled.
        private void OnNpcConversationStart(NPCTalking npcTalking, BasePlayer player, ConversationData conversationData)
        {
            // This delay can be removed in the future if an OnNpcConversationStarted hook is created.
            NextTick(() =>
            {
                // Verify the conversation started, since another plugin may have blocked it.
                if (!npcTalking.conversingPlayers.Contains(player))
                    return;

                DestroyButtonUi(player);
            });
        }

        // Only subscribed while the GUI button is enabled.
        private void OnNpcConversationEnded(NPCTalking npcTalking, BasePlayer player) => MaybeCreateButtonUi(player);

        private void OnNetworkSubscriptionsUpdate(Network.Networkable networkable, List<Network.Visibility.Group> groupsToAdd, List<Network.Visibility.Group> groupsToRemove)
        {
            if (groupsToRemove == null)
                return;

            for (var i = groupsToRemove.Count - 1; i >= 0; i--)
            {
                var group = groupsToRemove[i];
                if (BackpackNetworkController.IsBackpackNetworkGroup(group))
                {
                    // Prevent automatically unsubscribing from backpack network groups.
                    // This allows the subscriptions to persist while players move around.
                    groupsToRemove.Remove(group);
                }
            }
        }

        #endregion

        #region API

        private class ApiInstance
        {
            public readonly Dictionary<string, object> ApiWrapper;

            private readonly Backpacks _plugin;
            private BackpackManager _backpackManager => _plugin._backpackManager;

            public ApiInstance(Backpacks plugin)
            {
                _plugin = plugin;

                ApiWrapper = new Dictionary<string, object>
                {
                    [nameof(AddSubscriber)] = new Action<Plugin, Dictionary<string, object>>(AddSubscriber),
                    [nameof(RemoveSubscriber)] = new Action<Plugin>(RemoveSubscriber),
                    [nameof(GetExistingBackpacks)] = new Func<Dictionary<ulong, ItemContainer>>(GetExistingBackpacks),
                    [nameof(EraseBackpack)] = new Action<ulong>(EraseBackpack),
                    [nameof(DropBackpack)] = new Func<BasePlayer, List<DroppedItemContainer>, DroppedItemContainer>(DropBackpack),
                    [nameof(GetBackpackOwnerId)] = new Func<ItemContainer, ulong>(GetBackpackOwnerId),
                    [nameof(IsBackpackLoaded)] = new Func<BasePlayer, bool>(IsBackpackLoaded),
                    [nameof(GetBackpackCapacity)] = new Func<BasePlayer, int>(GetBackpackCapacity),
                    [nameof(IsBackpackGathering)] = new Func<BasePlayer, bool>(IsBackpackGathering),
                    [nameof(IsBackpackRetrieving)] = new Func<BasePlayer, bool>(IsBackpackRetrieving),
                    [nameof(GetBackpackContainer)] = new Func<ulong, ItemContainer>(GetBackpackContainer),
                    [nameof(GetBackpackItemAmount)] = new Func<ulong, int, ulong, int>(GetBackpackItemAmount),
                    [nameof(TryOpenBackpack)] = new Func<BasePlayer, ulong, bool>(TryOpenBackpack),
                    [nameof(TryOpenBackpackContainer)] = new Func<BasePlayer, ulong, ItemContainer, bool>(TryOpenBackpackContainer),
                    [nameof(TryOpenBackpackPage)] = new Func<BasePlayer, ulong, int, bool>(TryOpenBackpackPage),
                    [nameof(SumBackpackItems)] = new Func<ulong, Dictionary<string, object>, int>(SumBackpackItems),
                    [nameof(CountBackpackItems)] = new Func<ulong, Dictionary<string, object>, int>(CountBackpackItems),
                    [nameof(TakeBackpackItems)] = new Func<ulong, Dictionary<string, object>, int, List<Item>, int>(TakeBackpackItems),
                    [nameof(TryDepositBackpackItem)] = new Func<ulong, Item, bool>(TryDepositBackpackItem),
                    [nameof(WriteBackpackContentsFromJson)] = new Action<ulong, string>(WriteBackpackContentsFromJson),
                    [nameof(ReadBackpackContentsAsJson)] = new Func<ulong, string>(ReadBackpackContentsAsJson),
                };
            }

            public void AddSubscriber(Plugin plugin, Dictionary<string, object> spec)
            {
                if (plugin == null)
                    throw new ArgumentNullException(nameof(plugin));

                if (spec == null)
                    throw new ArgumentNullException(nameof(spec));

                _plugin._subscriberManager.AddSubscriber(plugin, spec);
            }

            public void RemoveSubscriber(Plugin plugin)
            {
                if (plugin == null)
                    throw new ArgumentNullException(nameof(plugin));

                _plugin._subscriberManager.RemoveSubscriber(plugin);
            }

            public Dictionary<ulong, ItemContainer> GetExistingBackpacks()
            {
                return _backpackManager.GetAllCachedContainers();
            }

            public void EraseBackpack(ulong userId)
            {
                _backpackManager.TryEraseForPlayer(userId);
            }

            public DroppedItemContainer DropBackpack(BasePlayer player, List<DroppedItemContainer> collect)
            {
                var backpack = _backpackManager.GetBackpackIfExists(player.userID);
                if (backpack == null)
                    return null;

                return _backpackManager.Drop(player.userID, player.transform.position, collect);
            }

            public ulong GetBackpackOwnerId(ItemContainer container)
            {
                return _backpackManager.GetCachedBackpackForContainer(container)?.OwnerId ?? 0;
            }

            public bool IsBackpackLoaded(BasePlayer player)
            {
                return _backpackManager.GetBackpackIfCached(player.userID) != null;
            }

            public int GetBackpackCapacity(BasePlayer player)
            {
                return _plugin._backpackCapacityManager.GetCapacity(player.userID, player.UserIDString);
            }

            public bool IsBackpackGathering(BasePlayer player)
            {
                return _backpackManager.GetBackpackIfCached(player.userID)?.IsGathering ?? false;
            }

            public bool IsBackpackRetrieving(BasePlayer player)
            {
                return _backpackManager.GetBackpackIfCached(player.userID)?.IsRetrieving ?? false;
            }

            public ItemContainer GetBackpackContainer(ulong ownerId)
            {
                return _backpackManager.GetBackpackIfExists(ownerId)?.GetContainer(ensureContainer: true);
            }

            public int GetBackpackItemAmount(ulong ownerId, int itemId, ulong skinId)
            {
                var itemQuery = new ItemQuery { ItemId = itemId, SkinId = skinId };
                return _backpackManager.GetBackpackIfExists(ownerId)?.SumItems(ref itemQuery) ?? 0;
            }

            public bool TryOpenBackpack(BasePlayer player, ulong ownerId)
            {
                return _backpackManager.TryOpenBackpack(player, ownerId);
            }

            public bool TryOpenBackpackContainer(BasePlayer player, ulong ownerId, ItemContainer container)
            {
                return _backpackManager.TryOpenBackpackContainer(player, ownerId, container);
            }

            public bool TryOpenBackpackPage(BasePlayer player, ulong ownerId, int page)
            {
                return _backpackManager.TryOpenBackpackPage(player, ownerId, page);
            }

            public int SumBackpackItems(ulong ownerId, Dictionary<string, object> dict)
            {
                var itemQuery = ItemQuery.Parse(dict);
                return _backpackManager.GetBackpackIfExists(ownerId)?.SumItems(ref itemQuery) ?? 0;
            }

            public int CountBackpackItems(ulong ownerId, Dictionary<string, object> dict)
            {
                var backpack = _backpackManager.GetBackpackIfExists(ownerId);
                if (backpack == null)
                    return 0;

                if (dict == null)
                    return backpack.ItemCount;

                var itemQuery = ItemQuery.Parse(dict);
                return backpack.CountItems(ref itemQuery);
            }

            public int TakeBackpackItems(ulong ownerId, Dictionary<string, object> dict, int amount, List<Item> collect)
            {
                var itemQuery = ItemQuery.Parse(dict);
                return _backpackManager.GetBackpackIfExists(ownerId)?.TakeItems(ref itemQuery, amount, collect) ?? 0;
            }

            public bool TryDepositBackpackItem(ulong ownerId, Item item)
            {
                return _backpackManager.GetBackpack(ownerId).TryDepositItem(item);
            }

            public void WriteBackpackContentsFromJson(ulong ownerId, string json)
            {
                _backpackManager.GetBackpack(ownerId).WriteContentsFromJson(json);
            }

            public string ReadBackpackContentsAsJson(ulong ownerId)
            {
                return _backpackManager.GetBackpackIfExists(ownerId)?.SerializeContentsAsJson();
            }
        }

        [HookMethod(nameof(API_GetApi))]
        public Dictionary<string, object> API_GetApi()
        {
            return _api.ApiWrapper;
        }

        [HookMethod(nameof(API_AddSubscriber))]
        public void API_AddSubscriber(Plugin plugin, Dictionary<string, object> spec)
        {
            _api.AddSubscriber(plugin, spec);
        }

        [HookMethod(nameof(API_RemoveSubscriber))]
        public void API_RemoveSubscriber(Plugin plugin)
        {
            _api.RemoveSubscriber(plugin);
        }

        [HookMethod(nameof(API_GetExistingBackpacks))]
        public Dictionary<ulong, ItemContainer> API_GetExistingBackpacks()
        {
            return _api.GetExistingBackpacks();
        }

        [HookMethod(nameof(API_EraseBackpack))]
        public void API_EraseBackpack(ulong userId)
        {
            _api.EraseBackpack(userId);
        }

        [HookMethod(nameof(API_DropBackpack))]
        public DroppedItemContainer API_DropBackpack(BasePlayer player, List<DroppedItemContainer> collect = null)
        {
            return _api.DropBackpack(player, collect);
        }

        [HookMethod(nameof(API_GetBackpackOwnerId))]
        public object API_GetBackpackOwnerId(ItemContainer container)
        {
            return ObjectCache.Get(_api.GetBackpackOwnerId(container));
        }

        [HookMethod(nameof(API_IsBackpackLoaded))]
        public object API_IsBackpackLoaded(BasePlayer player)
        {
            return ObjectCache.Get(_api.IsBackpackLoaded(player));
        }

        [HookMethod(nameof(API_GetBackpackCapacity))]
        public object API_GetBackpackCapacity(BasePlayer player)
        {
            return ObjectCache.Get(_api.GetBackpackCapacity(player));
        }

        [HookMethod(nameof(API_IsBackpackGathering))]
        public object API_IsBackpackGathering(BasePlayer player)
        {
            return ObjectCache.Get(_api.IsBackpackGathering(player));
        }

        [HookMethod(nameof(API_IsBackpackRetrieving))]
        public object API_IsBackpackRetrieving(BasePlayer player)
        {
            return ObjectCache.Get(_api.IsBackpackRetrieving(player));
        }

        [HookMethod(nameof(API_GetBackpackContainer))]
        public ItemContainer API_GetBackpackContainer(ulong ownerId)
        {
            return _api.GetBackpackContainer(ownerId);
        }

        [HookMethod(nameof(API_GetBackpackItemAmount))]
        public int API_GetBackpackItemAmount(ulong ownerId, int itemId, ulong skinId = 0)
        {
            return _api.GetBackpackItemAmount(ownerId, itemId, skinId);
        }

        [HookMethod(nameof(API_TryOpenBackpack))]
        public object API_TryOpenBackpack(BasePlayer player, ulong ownerId = 0)
        {
            return ObjectCache.Get(_api.TryOpenBackpack(player, ownerId));
        }

        [HookMethod(nameof(API_TryOpenBackpackContainer))]
        public object API_TryOpenBackpackContainer(BasePlayer player, ulong ownerId, ItemContainer container)
        {
            return ObjectCache.Get(_api.TryOpenBackpackContainer(player, ownerId, container));
        }

        [HookMethod(nameof(API_TryOpenBackpackPage))]
        public object API_TryOpenBackpackPage(BasePlayer player, ulong ownerId = 0, int page = 0)
        {
            return ObjectCache.Get(_api.TryOpenBackpackPage(player, ownerId, page));
        }

        [HookMethod(nameof(API_SumBackpackItems))]
        public object API_SumBackpackItems(ulong ownerId, Dictionary<string, object> dict)
        {
            return ObjectCache.Get(_api.SumBackpackItems(ownerId, dict));
        }

        [HookMethod(nameof(API_CountBackpackItems))]
        public object API_CountBackpackItems(ulong ownerId, Dictionary<string, object> dict)
        {
            return ObjectCache.Get(_api.CountBackpackItems(ownerId, dict));
        }

        [HookMethod(nameof(API_TakeBackpackItems))]
        public object API_TakeBackpackItems(ulong ownerId, Dictionary<string, object> dict, int amount, List<Item> collect)
        {
            return ObjectCache.Get(_api.TakeBackpackItems(ownerId, dict, amount, collect));
        }

        [HookMethod(nameof(API_TryDepositBackpackItem))]
        public object API_TryDepositBackpackItem(ulong ownerId, Item item)
        {
            return ObjectCache.Get(_api.TryDepositBackpackItem(ownerId, item));
        }

        [HookMethod(nameof(API_WriteBackpackContentsFromJson))]
        public void API_WriteBackpackContentsFromJson(ulong ownerId, string json)
        {
            _api.WriteBackpackContentsFromJson(ownerId, json);
        }

        [HookMethod(nameof(API_ReadBackpackContentsAsJson))]
        public object API_ReadBackpackContentsAsJson(ulong ownerId)
        {
            return _api.ReadBackpackContentsAsJson(ownerId);
        }

        #endregion

        #region Exposed Hooks

        private static class ExposedHooks
        {
            public static object CanOpenBackpack(BasePlayer looter, ulong ownerId)
            {
                return Interface.CallHook("CanOpenBackpack", looter, ObjectCache.Get(ownerId));
            }

            public static void OnBackpackClosed(BasePlayer looter, ulong ownerId, ItemContainer container)
            {
                Interface.CallHook("OnBackpackClosed", looter, ObjectCache.Get(ownerId), container);
            }

            public static void OnBackpackOpened(BasePlayer looter, ulong ownerId, ItemContainer container)
            {
                Interface.CallHook("OnBackpackOpened", looter, ObjectCache.Get(ownerId), container);
            }

            public static object CanDropBackpack(ulong ownerId, Vector3 position)
            {
                return Interface.CallHook("CanDropBackpack", ObjectCache.Get(ownerId), position);
            }

            public static object CanEraseBackpack(ulong ownerId)
            {
                return Interface.CallHook("CanEraseBackpack", ObjectCache.Get(ownerId));
            }

            public static object CanBackpackAcceptItem(ulong ownerId, ItemContainer container, Item item)
            {
                return Interface.CallHook("CanBackpackAcceptItem", ObjectCache.Get(ownerId), container, item);
            }
        }

        #endregion

        #region Commands

        [Command("backpack", "backpack.open")]
        private void BackpackOpenCommand(IPlayer player, string cmd, string[] args)
        {
            BasePlayer basePlayer;
            if (!VerifyCanInteract(player, out basePlayer)
                || !VerifyHasPermission(player, UsagePermission))
                return;

            OpenBackpack(
                basePlayer,
                IsKeyBindArg(args.LastOrDefault()),
                ParsePageArg(args.FirstOrDefault()),
                wrapAround: false
            );
        }

        [Command("backpack.next")]
        private void BackpackNextCommand(IPlayer player, string cmd, string[] args)
        {
            BasePlayer basePlayer;if (!VerifyCanInteract(player, out basePlayer)
                || !VerifyHasPermission(player, UsagePermission))
                return;

            OpenBackpack(
                basePlayer,
                IsKeyBindArg(args.LastOrDefault())
            );
        }

        [Command("backpack.previous", "backpack.prev")]
        private void BackpackPreviousCommand(IPlayer player, string cmd, string[] args)
        {
            BasePlayer basePlayer;
            if (!VerifyCanInteract(player, out basePlayer)
                || !VerifyHasPermission(player, UsagePermission))
                return;

            OpenBackpack(
                basePlayer,
                IsKeyBindArg(args.LastOrDefault()),
                forward: false
            );
        }

        [Command("backpack.fetch")]
        private void BackpackFetchCommand(IPlayer player, string cmd, string[] args)
        {
            BasePlayer basePlayer;
            if (!VerifyCanInteract(player, out basePlayer)
                || !VerifyHasPermission(player, FetchPermission))
                return;

            if (args.Length < 2)
            {
                player.Reply(GetMessage(player, "Backpack Fetch Syntax"));
                return;
            }

            if (!VerifyCanOpenBackpack(basePlayer, basePlayer.userID))
                return;

            ItemDefinition itemDefinition;
            if (!VerifyValidItem(player, args[0], out itemDefinition))
                return;

            int desiredAmount;
            if (!int.TryParse(args[1], out desiredAmount) || desiredAmount < 1)
            {
                player.Reply(GetMessage(player, "Invalid Item Amount"));
                return;
            }

            var itemLocalizedName = itemDefinition.displayName.translated;
            var backpack = _backpackManager.GetBackpack(basePlayer.userID);

            var itemQuery = new ItemQuery { ItemDefinition = itemDefinition };

            var quantityInBackpack = backpack.SumItems(ref itemQuery);
            if (quantityInBackpack == 0)
            {
                player.Reply(string.Format(GetMessage(player, "Item Not In Backpack"), itemLocalizedName));
                return;
            }

            if (desiredAmount > quantityInBackpack)
            {
                desiredAmount = quantityInBackpack;
            }

            var amountTransferred = backpack.FetchItems(basePlayer, ref itemQuery, desiredAmount);
            if (amountTransferred <= 0)
            {
                player.Reply(string.Format(GetMessage(player, "Fetch Failed"), itemLocalizedName));
                return;
            }

            player.Reply(string.Format(GetMessage(player, "Items Fetched"), amountTransferred.ToString(), itemLocalizedName));
        }

        [Command("backpack.erase")]
        private void EraseBackpackCommand(IPlayer player, string cmd, string[] args)
        {
            if (!player.IsServer)
                return;

            ulong userId;
            if (args.Length < 1 || !ulong.TryParse(args[0], out userId))
            {
                player.Reply($"Syntax: {cmd} <id>");
                return;
            }

            if (!_backpackManager.TryEraseForPlayer(userId))
            {
                LogWarning($"Player {userId.ToString()} has no backpack to erase.");
                return;
            }

            LogWarning($"Erased backpack for player {userId.ToString()}.");
        }

        [Command("viewbackpack")]
        private void ViewBackpackCommand(IPlayer player, string cmd, string[] args)
        {
            BasePlayer basePlayer;
            if (!VerifyCanInteract(player, out basePlayer)
                || !VerifyHasPermission(player, AdminPermission))
                return;

            if (args.Length < 1)
            {
                player.Reply(GetMessage(player, "View Backpack Syntax"));
                return;
            }

            string failureMessage;
            var targetPlayer = FindPlayer(player, args[0], out failureMessage);

            if (targetPlayer == null)
            {
                player.Reply(failureMessage);
                return;
            }

            var targetBasePlayer = targetPlayer.Object as BasePlayer;
            var desiredOwnerId = targetBasePlayer?.userID ?? ulong.Parse(targetPlayer.Id);

            OpenBackpack(
                basePlayer,
                IsKeyBindArg(args.LastOrDefault()),
                ParsePageArg(args.ElementAtOrDefault(1)),
                desiredOwnerId: desiredOwnerId
            );
        }

        // Alias for older versions of Player Administration (which should ideally not be calling this method directly).
        private void ViewBackpack(BasePlayer player, string cmd, string[] args) =>
            ViewBackpackCommand(player.IPlayer, cmd, args);

        private void ToggleBackpackGUICommand(IPlayer player, string cmd, string[] args)
        {
            BasePlayer basePlayer;
            if (!VerifyPlayer(player, out basePlayer)
                || !VerifyHasPermission(player, GUIPermission))
                return;

            var enabledNow = _storedData.ToggleGuiButtonPreference(basePlayer.userID, _config.GUI.EnabledByDefault);
            if (enabledNow)
            {
                MaybeCreateButtonUi(basePlayer);
            }
            else
            {
                DestroyButtonUi(basePlayer);
            }

            player.Reply(GetMessage(player, "Toggled Backpack GUI"));
        }

        [Command("backpack.togglegather")]
        private void ToggleGatherCommand(IPlayer player, string cmd, string[] args)
        {
            BasePlayer basePlayer;
            if (!VerifyPlayer(player, out basePlayer))
                return;

            var lootingContainer = basePlayer.inventory.loot.containers.FirstOrDefault();
            if (lootingContainer == null)
                return;

            Backpack backpack;
            int pageIndex;
            if (!_backpackManager.IsBackpack(lootingContainer, out backpack, out pageIndex)
                || backpack.OwnerId != basePlayer.userID
                || !backpack.CanGather)
                return;

            backpack.ToggleGatherMode(basePlayer, pageIndex);
        }

        [Command("backpack.toggleretrieve")]
        private void ToggleRetrieveCommand(IPlayer player, string cmd, string[] args)
        {
            BasePlayer basePlayer;
            if (!VerifyPlayer(player, out basePlayer))
                return;

            var lootingContainer = basePlayer.inventory.loot.containers.FirstOrDefault();
            if (lootingContainer == null)
                return;

            Backpack backpack;
            int pageIndex;
            if (!_backpackManager.IsBackpack(lootingContainer, out backpack, out pageIndex)
                || pageIndex > 31
                || backpack.OwnerId != basePlayer.userID
                || !backpack.CanRetrieve)
                return;

            backpack.ToggleRetrieve(basePlayer, pageIndex);
        }

        #endregion

        #region Helper Methods

        public static void LogDebug(string message) => Interface.Oxide.LogDebug($"[Backpacks] {message}");
        public static void LogInfo(string message) => Interface.Oxide.LogInfo($"[Backpacks] {message}");
        public static void LogWarning(string message) => Interface.Oxide.LogWarning($"[Backpacks] {message}");
        public static void LogError(string message) => Interface.Oxide.LogError($"[Backpacks] {message}");

        private static T[] ParseEnumList<T>(string[] list, string errorFormat) where T : struct
        {
            var valueList = new List<T>(list?.Length ?? 0);

            if (list != null)
            {
                foreach (var itemName in list)
                {
                    T result;
                    if (Enum.TryParse(itemName, ignoreCase: true, result: out result))
                    {
                        valueList.Add(result);
                    }
                    else
                    {
                        LogError(string.Format(errorFormat, itemName));
                    }
                }
            }

            return valueList.ToArray();
        }

        private static bool IsKeyBindArg(string arg)
        {
            return arg == "True";
        }

        private static int ParsePageArg(string arg)
        {
            if (arg == null)
                return -1;

            int pageIndex;
            return int.TryParse(arg, out pageIndex)
                ? Math.Max(0, pageIndex - 1)
                : -1;
        }

        private static string DetermineLootPanelName(ItemContainer container)
        {
            return (container.entityOwner as StorageContainer)?.panelName
                   ?? (container.entityOwner as ContainerIOEntity)?.lootPanelName
                   ?? (container.entityOwner as LootableCorpse)?.lootPanelName
                   ?? (container.entityOwner as DroppedItemContainer)?.lootPanelName
                   ?? (container.entityOwner as BaseRidableAnimal)?.lootPanelName
                   ?? ResizableLootPanelName;
        }

        private static void ClosePlayerInventory(BasePlayer player)
        {
            player.ClientRPCPlayer(null, player, "OnRespawnInformation");
        }

        private static float CalculateOpenDelay(ItemContainer currentContainer, int nextContainerCapacity, bool isKeyBind = false)
        {
            if (currentContainer != null)
            {
                // Can instantly switch to a smaller container.
                if (nextContainerCapacity <= currentContainer.capacity)
                    return 0;

                // Can instantly switch to a generic resizable loot panel from a different loot panel.
                if (DetermineLootPanelName(currentContainer) != ResizableLootPanelName)
                    return 0;

                // Need a short delay so the generic_resizable loot panel can be redrawn properly.
                return StandardLootDelay;
            }

            // Can open instantly since not looting and chat is assumed to be closed.
            if (isKeyBind)
                return 0;

            // Not opening via key bind, so the chat window may be open.
            // Must delay in case the chat is still closing or else the loot panel may close instantly.
            return StandardLootDelay;
        }

        private static void StartLooting(BasePlayer player, ItemContainer container, StorageContainer entitySource)
        {
            if (player.CanInteract()
                && Interface.CallHook("CanLootEntity", player, entitySource) == null
                && player.inventory.loot.StartLootingEntity(entitySource, doPositionChecks: false))
            {
                player.inventory.loot.AddContainer(container);
                player.inventory.loot.SendImmediate();
                player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", entitySource.panelName);
            }
        }

        private static ItemContainer CreateItemContainer(int capacity, StorageContainer entityOwner)
        {
            var container = new ItemContainer();
            container.ServerInitialize(null, capacity);
            container.GiveUID();
            container.entityOwner = entityOwner;
            return container;
        }

        private static ItemContainer GetRootContainer(Item item)
        {
            var container = item.parent;
            if (container == null)
                return null;

            while (container.parent?.parent != null && container.parent != item)
            {
                container = container.parent.parent;
            }

            return container;
        }

        private void SendEffect(BasePlayer player, string effectPrefab)
        {
            if (string.IsNullOrWhiteSpace(effectPrefab))
                return;

            _reusableEffect.Init(Effect.Type.Generic, player, 0, Vector3.zero, Vector3.forward);
            _reusableEffect.pooledString = effectPrefab;
            EffectNetwork.Send(_reusableEffect, player.net.connection);
        }

        private void CheckBackpackButtonPlugin()
        {
            if (BackpackButton == null
                || _config.UsingDefaults
                || !_config.GUI.Enabled)
                return;

            foreach (var player in BasePlayer.activePlayerList)
            {
                DestroyButtonUi(player);
            }

            _config.GUI.Enabled = false;
            SaveConfig();
            LogWarning($"Disabled GUI button in the config because the {nameof(BackpackButton)} plugin was detected.");
        }

        private void RegisterAsItemSupplier()
        {
            ItemRetriever?.Call("API_AddSupplier", this, new Dictionary<string, object>
            {
                ["FindPlayerItems"] = new Action<BasePlayer, Dictionary<string, object>, List<Item>>((player, rawItemQuery, collect) =>
                {
                    var backpack = _backpackManager.GetBackpackIfCached(player.userID);
                    if (backpack == null || !backpack.CanRetrieve || !backpack.CanAccess)
                        return;

                    var itemQuery = ItemQuery.Parse(rawItemQuery);
                    backpack.FindItems(ref itemQuery, collect, forItemRetriever: true);
                }),

                ["FindPlayerAmmo"] = new Action<BasePlayer, AmmoTypes, List<Item>>((player, ammoType, collect) =>
                {
                    var backpack = _backpackManager.GetBackpackIfCached(player.userID);
                    if (backpack == null || !backpack.CanRetrieve || !backpack.CanAccess)
                        return;

                    backpack.FindAmmo(ammoType, collect, forItemRetriever: true);
                }),

                ["SumPlayerItems"] = new Func<BasePlayer, Dictionary<string, object>, int>((player, rawItemQuery) =>
                {
                    var backpack = _backpackManager.GetBackpackIfCached(player.userID);
                    if (backpack == null || !backpack.CanRetrieve || !backpack.CanAccess)
                        return 0;

                    var itemQuery = ItemQuery.Parse(rawItemQuery);
                    return backpack.SumItems(ref itemQuery, forItemRetriever: true);
                }),

                ["TakePlayerItems"] = new Func<BasePlayer, Dictionary<string, object>, int, List<Item>, int>((player, rawItemQuery, amount, collect) =>
                {
                    var backpack = _backpackManager.GetBackpackIfCached(player.userID);
                    if (backpack == null || !backpack.CanRetrieve || !backpack.CanAccess)
                        return 0;

                    var itemQuery = ItemQuery.Parse(rawItemQuery);
                    return backpack.TakeItems(ref itemQuery, amount, collect, forItemRetriever: true);
                }),

                ["SerializeForNetwork"] = new Action<BasePlayer, List<ProtoBuf.Item>>((player, saveList) =>
                {
                    var backpack = _backpackManager.GetBackpackIfCached(player.userID);
                    // Don't check CanAccess here to save on performance. This may result in minor issues like the
                    // player attempting an action they can't perform.
                    if (backpack == null || !backpack.CanRetrieve)
                        return;

                    backpack.SerializeForNetwork(saveList, forItemRetriever: true);
                }),
            });
        }

        private IEnumerator SaveRoutine(bool async, bool keepInUseBackpacks)
        {
            if (_storedData.SaveIfChanged() && async)
                yield return null;

            yield return _backpackManager.SaveAllAndKill(async, keepInUseBackpacks);
        }

        private void RestartSaveRoutine(bool async, bool keepInUseBackpacks)
        {
            if (_saveRoutine != null)
            {
                ServerMgr.Instance.StopCoroutine(_saveRoutine);
            }

            ServerMgr.Instance?.StartCoroutine(SaveRoutine(async, keepInUseBackpacks));
        }

        private void OpenBackpackMaybeDelayed(BasePlayer looter, ItemContainer currentContainer, Backpack backpack, int pageIndex, bool isKeyBind)
        {
            var pageCapacity = backpack.GetAllowedPageCapacityForLooter(looter.userID, pageIndex);

            var delaySeconds = CalculateOpenDelay(currentContainer, pageCapacity, isKeyBind);
            if (delaySeconds > 0)
            {
                if (currentContainer != null)
                {
                    looter.EndLooting();
                    looter.inventory.loot.SendImmediate();
                }

                var ownerId2 = backpack.OwnerId;
                var looter2 = looter;
                var pageIndex2 = pageIndex;

                timer.Once(delaySeconds, () => _backpackManager.TryOpenBackpackPage(looter2, ownerId2, pageIndex2));
                return;
            }

            _backpackManager.TryOpenBackpackPage(looter, backpack.OwnerId, pageIndex);
        }

        private void OpenBackpack(BasePlayer looter, bool isKeyBind, int desiredPageIndex = -1, bool forward = true, bool wrapAround = true, ulong desiredOwnerId = 0)
        {
            var playerLoot = looter.inventory.loot;
            var lootingContainer = playerLoot.containers.FirstOrDefault();

            if (lootingContainer != null)
            {
                Backpack currentBackpack;
                int currentPageIndex;
                if (_backpackManager.IsBackpack(lootingContainer, out currentBackpack, out currentPageIndex)
                    && (currentBackpack.OwnerId == desiredOwnerId || desiredOwnerId == 0))
                {
                    var nextPageIndex = currentBackpack.DetermineNextPageIndexForLooter(looter.userID, currentPageIndex, desiredPageIndex, forward, wrapAround, requireContents: false);
                    if (nextPageIndex == currentPageIndex)
                    {
                        if (!wrapAround)
                        {
                            // Close the backpack.
                            looter.EndLooting();
                            ClosePlayerInventory(looter);
                        }
                        return;
                    }

                    var nextPageCapacity = currentBackpack.GetAllowedPageCapacityForLooter(looter.userID, nextPageIndex);
                    if (nextPageCapacity > lootingContainer.capacity)
                    {
                        playerLoot.Clear();
                        playerLoot.SendImmediate();

                        {
                            var backpack2 = currentBackpack;
                            var looter2 = looter;
                            var pageIndex2 = desiredPageIndex;
                            timer.Once(StandardLootDelay, () => backpack2.TryOpen(looter2, pageIndex2));
                        }
                        return;
                    }

                    currentBackpack.SwitchToPage(looter, nextPageIndex);
                    return;
                }

                var parent = lootingContainer.parent?.parent;
                if (parent != null && _backpackManager.IsBackpack(parent, out currentBackpack, out currentPageIndex)
                    && (currentBackpack.OwnerId == desiredOwnerId || desiredOwnerId == 0))
                {
                    // Player is looting a child container of the target backpack, so open the current page.
                    OpenBackpackMaybeDelayed(looter, lootingContainer, currentBackpack, currentPageIndex, isKeyBind);
                    return;
                }
            }

            // At this point, player is not looting, looting a different backpack, or looting a different container.
            if (desiredOwnerId == 0)
            {
                desiredOwnerId = looter.userID;
            }

            var backpack = _backpackManager.GetBackpack(desiredOwnerId);
            desiredPageIndex = backpack.DetermineInitialPageForLooter(looter.userID, desiredPageIndex, forward);

            OpenBackpackMaybeDelayed(looter, lootingContainer, backpack, desiredPageIndex, isKeyBind);
        }

        private bool ShouldDisplayGuiButton(BasePlayer player)
        {
            return _storedData.GetGuiButtonPreference(player.userID)
                ?? _config.GUI.EnabledByDefault;
        }

        private IPlayer FindPlayer(IPlayer requester, string nameOrID, out string failureMessage)
        {
            failureMessage = string.Empty;

            ulong userId;
            if (nameOrID.StartsWith("7656119") && nameOrID.Length == 17 && ulong.TryParse(nameOrID, out userId))
            {
                IPlayer player = covalence.Players.All.FirstOrDefault(p => p.Id == nameOrID);

                if (player == null)
                {
                    failureMessage = string.Format(GetMessage(requester, "User ID not Found"), nameOrID);
                }

                return player;
            }

            var foundPlayers = new List<IPlayer>();

            foreach (var player in covalence.Players.All)
            {
                if (player.Name.Equals(nameOrID, StringComparison.InvariantCultureIgnoreCase))
                    return player;

                if (player.Name.ToLower().Contains(nameOrID.ToLower()))
                {
                    foundPlayers.Add(player);
                }
            }

            switch (foundPlayers.Count)
            {
                case 0:
                    failureMessage = string.Format(GetMessage(requester, "User Name not Found"), nameOrID);
                    return null;

                case 1:
                    return foundPlayers[0];

                default:
                    string names = string.Join(", ", foundPlayers.Select(p => p.Name).ToArray());
                    failureMessage = string.Format(GetMessage(requester, "Multiple Players Found"), names);
                    return null;
            }
        }

        private bool VerifyPlayer(IPlayer player, out BasePlayer basePlayer)
        {
            if (player.IsServer)
            {
                basePlayer = null;
                return false;
            }

            basePlayer = player.Object as BasePlayer;
            return true;
        }

        private bool VerifyHasPermission(IPlayer player, string perm)
        {
            if (player.HasPermission(perm))
                return true;

            player.Reply(GetMessage(player, "No Permission"));
            return false;
        }

        private bool VerifyValidItem(IPlayer player, string itemArg, out ItemDefinition itemDefinition)
        {
            itemDefinition = ItemManager.FindItemDefinition(itemArg);
            if (itemDefinition != null)
                return true;

            // User may have provided an itemID instead of item short name
            int itemID;
            if (!int.TryParse(itemArg, out itemID))
            {
                player.Reply(GetMessage(player, "Invalid Item"));
                return false;
            }

            itemDefinition = ItemManager.FindItemDefinition(itemID);
            if (itemDefinition != null)
                return true;

            player.Reply(GetMessage(player, "Invalid Item"));
            return false;
        }

        private bool VerifyCanInteract(IPlayer player, out BasePlayer basePlayer)
        {
            return VerifyPlayer(player, out basePlayer)
                   && basePlayer.CanInteract();
        }

        private bool VerifyCanOpenBackpack(BasePlayer looter, ulong ownerId)
        {
            if (IsPlayingEvent(looter))
            {
                looter.ChatMessage(GetMessage(looter, "May Not Open Backpack In Event"));
                return false;
            }

            var hookResult = ExposedHooks.CanOpenBackpack(looter, ownerId);
            if (hookResult != null && hookResult is string)
            {
                looter.ChatMessage(hookResult as string);
                return false;
            }

            return true;
        }

        private bool IsPlayingEvent(BasePlayer player)
        {
            // Multiple event/arena plugins define the isEventPlayer method as a standard.
            var isPlaying = Interface.CallHook("isEventPlayer", player);
            if (isPlaying is bool && (bool)isPlaying)
                return true;

            if (EventManager != null)
            {
                // EventManager 3.x
                isPlaying = EventManager.Call("isPlaying", player);
                if (isPlaying is bool && (bool)isPlaying)
                    return true;
            }

            if (Arena != null)
            {
                isPlaying = Arena.Call("IsEventPlayer", player);
                if (isPlaying is bool && (bool)isPlaying)
                    return true;
            }

            return false;
        }

        private void MaybeCreateButtonUi(BasePlayer player)
        {
            if (!_config.GUI.Enabled)
                return;

            if (player == null || player.IsNpc || !player.IsAlive() || player.IsSleeping())
                return;

            if (!permission.UserHasPermission(player.UserIDString, GUIPermission))
                return;

            if (!ShouldDisplayGuiButton(player))
                return;

            _uiViewers.Add(player.userID);

            if (_cachedButtonUi == null)
            {
                _cachedButtonUi = ButtonUi.CreateButtonUi(_config);
            }

            CuiHelper.AddUi(player, _cachedButtonUi);
        }

        private void DestroyButtonUi(BasePlayer player)
        {
            if (!_uiViewers.Remove(player.userID))
                return;

            ButtonUi.DestroyUi(player);
        }

        private void CreateOrDestroyButtonUi(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, GUIPermission))
            {
                MaybeCreateButtonUi(player);
            }
            else
            {
                DestroyButtonUi(player);
            }
        }

        #endregion

        #region Helper Classes

        private static class StringUtils
        {
            public static bool Equals(string a, string b) =>
                string.Compare(a, b, StringComparison.OrdinalIgnoreCase) == 0;

            public static bool Contains(string haystack, string needle) =>
                haystack.Contains(needle, CompareOptions.IgnoreCase);
        }

        private static class ObjectCache
        {
            private static readonly object True = true;
            private static readonly object False = false;

            private static class StaticObjectCache<T>
            {
                private static readonly Dictionary<T, object> _cacheByValue = new Dictionary<T, object>();

                public static object Get(T value)
                {
                    object cachedObject;
                    if (!_cacheByValue.TryGetValue(value, out cachedObject))
                    {
                        cachedObject = value;
                        _cacheByValue[value] = cachedObject;
                    }
                    return cachedObject;
                }
            }

            public static object Get<T>(T value)
            {
                return StaticObjectCache<T>.Get(value);
            }

            public static object Get(bool value)
            {
                return value ? True : False;
            }
        }

        private class PoolConverter<T> : CustomCreationConverter<T> where T : class, new()
        {
            public override T Create(Type objectType)
            {
                #if DEBUG_POOLING
                LogDebug($"{typeof(PoolConverter<T>).Name}<{objectType.Name}>::Create");
                #endif

                return CustomPool.Get<T>();
            }
        }

        private class PoolListConverter<T> : CustomCreationConverter<List<T>> where T : class, new()
        {
            public override List<T> Create(Type objectType)
            {
                #if DEBUG_POOLING
                LogDebug($"{typeof(PoolListConverter<T>).Name}<{objectType.Name}>::Create");
                #endif

                return CustomPool.GetList<T>();
            }
        }

        private static class ItemUtils
        {
            public static int PositionOf(List<Item> itemList, ref ItemQuery itemQuery)
            {
                // Assumes the list is sorted.
                foreach (var item in itemList)
                {
                    var usableAmount = itemQuery.GetUsableAmount(item);
                    if (usableAmount > 0)
                        return item.position;
                }

                return -1;
            }

            public static int PositionOf(List<ItemData> itemDataList, ref ItemQuery itemQuery)
            {
                // Assumes the list is sorted.
                foreach (var itemData in itemDataList)
                {
                    var usableAmount = itemQuery.GetUsableAmount(itemData);
                    if (usableAmount > 0)
                        return itemData.Position;
                }

                return -1;
            }

            public static void FindItems(List<Item> itemList, ref ItemQuery itemQuery, List<Item> collect)
            {
                foreach (var item in itemList)
                {
                    var usableAmount = itemQuery.GetUsableAmount(item);
                    if (usableAmount > 0)
                    {
                        collect.Add(item);
                    }

                    List<Item> childItemList;
                    if (HasSearchableContainer(item, out childItemList))
                    {
                        FindItems(childItemList, ref itemQuery, collect);
                    }
                }
            }

            public static int CountItems(List<Item> itemList, ref ItemQuery itemQuery)
            {
                var count = 0;

                foreach (var item in itemList)
                {
                    var usableAmount = itemQuery.GetUsableAmount(item);
                    if (usableAmount > 0)
                    {
                        count++;
                    }

                    List<Item> childItems;
                    if (HasSearchableContainer(item, out childItems))
                    {
                        count += CountItems(childItems, ref itemQuery);
                    }
                }

                return count;
            }

            public static int CountItems(List<ItemData> itemDataList, ref ItemQuery itemQuery)
            {
                var count = 0;

                foreach (var itemData in itemDataList)
                {
                    var usableAmount = itemQuery.GetUsableAmount(itemData);
                    if (usableAmount > 0)
                    {
                        count++;
                    }

                    List<ItemData> childItems;
                    if (HasSearchableContainer(itemData, out childItems))
                    {
                        count += CountItems(childItems, ref itemQuery);
                    }
                }

                return count;
            }

            public static int SumItems(List<Item> itemList, ref ItemQuery itemQuery)
            {
                var sum = 0;

                foreach (var item in itemList)
                {
                    sum += itemQuery.GetUsableAmount(item);

                    List<Item> childItems;
                    if (HasSearchableContainer(item, out childItems))
                    {
                        sum += SumItems(childItems, ref itemQuery);
                    }
                }

                return sum;
            }

            public static int SumItems(List<ItemData> itemDataList, ref ItemQuery itemQuery)
            {
                var sum = 0;

                foreach (var itemData in itemDataList)
                {
                    sum += itemQuery.GetUsableAmount(itemData);

                    List<ItemData> childItemList;
                    if (HasSearchableContainer(itemData, out childItemList))
                    {
                        sum += SumItems(childItemList, ref itemQuery);
                    }
                }

                return sum;
            }

            public static int TakeItems(List<Item> itemList, ref ItemQuery itemQuery, int amount, List<Item> collect)
            {
                var totalAmountTaken = 0;

                for (var i = itemList.Count - 1; i >= 0; i--)
                {
                    var item = itemList[i];
                    var amountToTake = amount - totalAmountTaken;
                    if (amountToTake <= 0)
                        break;

                    var usableAmount = itemQuery.GetUsableAmount(item);
                    if (usableAmount > 0)
                    {
                        amountToTake = Math.Min(usableAmount, amountToTake);

                        TakeItemAmount(item, amountToTake, collect);
                        totalAmountTaken += amountToTake;
                    }

                    amountToTake = amount - totalAmountTaken;
                    List<Item> childItemList;
                    if (amountToTake > 0 && HasSearchableContainer(item, out childItemList))
                    {
                        totalAmountTaken += TakeItems(childItemList, ref itemQuery, amountToTake, collect);
                    }
                }

                return totalAmountTaken;
            }

            public static int TakeItems(List<ItemData> itemDataList, ref ItemQuery itemQuery, int amount, List<Item> collect)
            {
                var totalAmountTaken = 0;

                for (var i = itemDataList.Count - 1; i >= 0; i--)
                {
                    var itemData = itemDataList[i];
                    var amountToTake = amount - totalAmountTaken;
                    if (amountToTake <= 0)
                        break;

                    var usableAmount = itemQuery.GetUsableAmount(itemData);
                    if (usableAmount > 0)
                    {
                        amountToTake = Math.Min(usableAmount, amountToTake);

                        collect?.Add(itemData.ToItem(amountToTake));
                        itemData.Reduce(amountToTake);

                        totalAmountTaken += amountToTake;

                        if (itemData.Amount <= 0)
                        {
                            itemDataList.RemoveAt(i);
                            CustomPool.Free(ref itemData);
                            continue;
                        }
                    }

                    amountToTake = amount - totalAmountTaken;
                    List<ItemData> childItemList;
                    if (amountToTake > 0 && HasSearchableContainer(itemData, out childItemList))
                    {
                        totalAmountTaken += TakeItems(childItemList, ref itemQuery, amountToTake, collect);
                    }
                }

                return totalAmountTaken;
            }

            public static void SerializeForNetwork(List<Item> itemList, List<ProtoBuf.Item> collect)
            {
                foreach (var item in itemList)
                {
                    collect.Add(item.Save());

                    List<Item> childItems;
                    if (HasSearchableContainer(item, out childItems))
                    {
                        SerializeForNetwork(childItems, collect);
                    }
                }
            }

            public static void SerializeForNetwork(List<ItemData> itemDataList, List<ProtoBuf.Item> collect)
            {
                foreach (var itemData in itemDataList)
                {
                    var serializedItemData = CustomPool.Get<ProtoBuf.Item>();
                    serializedItemData.itemid = itemData.ID;
                    serializedItemData.amount = itemData.Amount;

                    if (itemData.DataInt != 0 || itemData.BlueprintTarget != 0)
                    {
                        if (serializedItemData.instanceData == null)
                        {
                            serializedItemData.instanceData = CustomPool.Get<ProtoBuf.Item.InstanceData>();
                        }

                        serializedItemData.instanceData.dataInt = itemData.DataInt;
                        serializedItemData.instanceData.blueprintTarget = itemData.BlueprintTarget;
                    }

                    collect.Add(serializedItemData);

                    List<ItemData> childItemList;
                    if (HasSearchableContainer(itemData, out childItemList))
                    {
                        SerializeForNetwork(childItemList, collect);
                    }
                }
            }

            private static bool HasItemMod<T>(ItemDefinition itemDefinition) where T : ItemMod
            {
                foreach (var itemMod in itemDefinition.itemMods)
                {
                    if (itemMod is T)
                        return true;
                }

                return false;
            }

            private static bool HasSearchableContainer(ItemDefinition itemDefinition)
            {
                // Don't consider vanilla containers searchable (i.e., don't take low grade out of a miner's hat).
                return !HasItemMod<ItemModContainer>(itemDefinition);
            }

            private static bool HasSearchableContainer(Item item, out List<Item> itemList)
            {
                itemList = item.contents?.itemList;
                return itemList?.Count > 0 && !item.HasFlag(UnsearchableItemFlag) && HasSearchableContainer(item.info);
            }

            private static bool HasSearchableContainer(int itemId)
            {
                var itemDefinition = ItemManager.FindItemDefinition(itemId);
                if ((object)itemDefinition == null)
                    return false;

                return HasSearchableContainer(itemDefinition);
            }

            private static bool HasSearchableContainer(ItemData itemData, out List<ItemData> itemDataList)
            {
                itemDataList = itemData.Contents;
                return itemDataList?.Count > 0 && !itemData.Flags.HasFlag(UnsearchableItemFlag) && HasSearchableContainer(itemData.ID);
            }

            private static void TakeItemAmount(Item item, int amount, List<Item> collect)
            {
                if (amount >= item.amount)
                {
                    item.RemoveFromContainer();
                    if (collect != null)
                    {
                        collect.Add(item);
                    }
                    else
                    {
                        item.Remove();
                    }
                }
                else
                {
                    if (collect != null)
                    {
                        collect.Add(item.SplitItem(amount));
                    }
                    else
                    {
                        item.amount -= amount;
                        item.MarkDirty();
                    }
                }
            }
        }

        #endregion

        #region Pooling

        private static class CustomPool
        {
            public interface IPooled
            {
                void EnterPool();
                void LeavePool();
            }

            private static class StaticPool<T> where T : class, new()
            {
                public static readonly PoolCollection<T> Collection = new PoolCollection<T>();
            }

            private class PoolCollection<T> where T : class, new()
            {
                public const int DefaultPoolSize = 512;

                private T[] _buffer;
                public int ItemsCreated { get; private set; }
                public int ItemsInStack { get; private set; }
                public int ItemsInUse { get; private set; }
                public int ItemsSpilled { get; private set; }
                public int ItemsTaken { get; private set; }

                public PoolCollection()
                {
                    Reset(DefaultPoolSize);
                }

                public void Reset(int size = 0)
                {
                    _buffer = size == 0 ? Array.Empty<T>() : new T[size];

                    ItemsCreated = 0;
                    ItemsInStack = 0;
                    ItemsInUse = 0;
                    ItemsSpilled = 0;
                    ItemsTaken = 0;
                }

                public void Add(T obj)
                {
                    (obj as IPooled)?.EnterPool();

                    ItemsInUse--;

                    if (ItemsInStack >= _buffer.Length)
                    {
                        ItemsSpilled++;
                        return;
                    }

                    _buffer[ItemsInStack] = obj;
                    ItemsInStack++;
                }

                public T Take()
                {
                    if (ItemsInStack > 0)
                    {
                        ItemsInStack--;
                        ItemsInUse++;
                        var obj = _buffer[ItemsInStack];
                        _buffer[ItemsInStack] = null;
                        (obj as IPooled)?.LeavePool();
                        ItemsTaken++;
                        return obj;
                    }

                    ItemsCreated++;
                    ItemsInUse++;
                    return new T();
                }
            }

            public static void Reset<T>(int size) where T : class, new()
            {
                StaticPool<T>.Collection.Reset(size);
            }

            public static string GetStats<T>() where T : class, new()
            {
                var pool = StaticPool<T>.Collection;
                return $"{typeof(T).Name} | {pool.ItemsInUse.ToString()} used of {pool.ItemsCreated.ToString()} created | {pool.ItemsTaken.ToString()} taken";
            }

            public static T Get<T>() where T : class, new()
            {
                return StaticPool<T>.Collection.Take();
            }

            public static List<T> GetList<T>()
            {
                return Get<List<T>>();
            }

            public static void Free<T>(ref T obj) where T : class, new()
            {
                FreeInternal(ref obj);
            }

            public static void FreeList<T>(ref List<T> list) where T : class
            {
                list.Clear();
                FreeInternal(ref list);
            }

            private static void FreeInternal<T>(ref T obj) where T : class, new()
            {
                StaticPool<T>.Collection.Add(obj);
                obj = null;
            }
        }

        private static class PoolUtils
        {
            public const int BackpackPoolSize = 500;

            public static void ResetItemsAndClear<T>(IList<T> list) where T : class, CustomPool.IPooled, new()
            {
                for (var i = list.Count - 1; i >= 0; i--)
                {
                    var item = list[i];
                    if (item == null)
                        continue;

                    CustomPool.Free(ref item);
                }

                if (list.IsReadOnly)
                {
                    for (var i = 0; i < list.Count; i++)
                    {
                        list[i] = null;
                    }
                }
                else
                {
                    list.Clear();
                }
            }

            public static void ResizePools(bool empty = false)
            {
                CustomPool.Reset<ItemData>(empty ? 0 : 2 * BackpackPoolSize);
                CustomPool.Reset<List<ItemData>>(empty ? 0 : BackpackPoolSize);
                CustomPool.Reset<EntityData>(empty ? 0 : BackpackPoolSize / 4);
                CustomPool.Reset<Backpack>(empty ? 0 : BackpackPoolSize);
                CustomPool.Reset<VirtualContainerAdapter>(empty ? 0 : 2 * BackpackPoolSize);
                CustomPool.Reset<ItemContainerAdapter>(empty ? 0 : 2 * BackpackPoolSize);
                CustomPool.Reset<DisposableList<Item>>(empty ? 0 : 4);
                CustomPool.Reset<DisposableList<ItemData>>(empty ? 0 : 4);
                CustomPool.Reset<ContainerAdapterEnumerator>(empty ? 0 : 4);
            }
        }

        private class DisposableList<T> : List<T>, IDisposable
        {
            public static DisposableList<T> Get()
            {
                return CustomPool.Get<DisposableList<T>>();
            }

            public void Dispose()
            {
                Clear();
                var self = this;
                CustomPool.Free(ref self);
            }
        }

        #endregion

        #region String Cache

        private interface IStringCache
        {
            string Get<T>(T value);
            string Get<T>(T value, Func<T, string> createString);
            string Get(bool value);
        }

        private sealed class DefaultStringCache : IStringCache
        {
            public static readonly DefaultStringCache Instance = new DefaultStringCache();

            private static class StaticStringCache<T>
            {
                private static readonly Dictionary<T, string> _cacheByValue = new Dictionary<T, string>();

                public static string Get(T value)
                {
                    string str;
                    if (!_cacheByValue.TryGetValue(value, out str))
                    {
                        str = value.ToString();
                        _cacheByValue[value] = str;
                    }

                    return str;
                }
            }

            private static class StaticStringCacheWithFactory<T>
            {
                private static readonly Dictionary<Func<T, string>, Dictionary<T, string>> _cacheByDelegate =
                    new Dictionary<Func<T, string>, Dictionary<T, string>>();

                public static string Get(T value, Func<T, string> createString)
                {
                    Dictionary<T, string> cache;
                    if (!_cacheByDelegate.TryGetValue(createString, out cache))
                    {
                        cache = new Dictionary<T, string>();
                        _cacheByDelegate[createString] = cache;
                    }

                    string str;
                    if (!cache.TryGetValue(value, out str))
                    {
                        str = createString(value);
                        cache[value] = str;
                    }

                    return str;
                }
            }

            private DefaultStringCache() {}

            public string Get<T>(T value)
            {
                return StaticStringCache<T>.Get(value);
            }

            public string Get(bool value)
            {
                return value ? "true" : "false";
            }

            public string Get<T>(T value, Func<T, string> createString)
            {
                return StaticStringCacheWithFactory<T>.Get(value, createString);
            }
        }

        #endregion

        #region UI Builder

        private interface IUiSerializable
        {
            void Serialize(IUiBuilder uiBuilder);
        }

        private interface IUiBuilder
        {
            IStringCache StringCache { get; }
            void Start();
            void End();
            void StartElement();
            void EndElement();
            void StartComponent();
            void EndComponent();
            void AddField<T>(string key, T value);
            void AddField(string key, string value);
            void AddXY(string key, float x, float y);
            void AddSerializable<T>(T serializable) where T : IUiSerializable;
            void AddComponents<T>(T components) where T : IUiComponentCollection;
            string ToJson();
            byte[] GetBytes();
            void AddUi(SendInfo sendInfo);
            void AddUi(BasePlayer player);
        }

        private class UiBuilder : IUiBuilder
        {
            private static NetWrite ClientRPCStart(BaseEntity entity, string funcName)
            {
                if (Net.sv.IsConnected() && entity.net != null)
                {
                    var write = Net.sv.StartWrite();
                    write.PacketID(Message.Type.RPCMessage);
                    write.EntityID(entity.net.ID);
                    write.UInt32(StringPool.Get(funcName));
                    write.UInt64(0);
                    return write;
                }
                return null;
            }

            public static readonly UiBuilder Default = new UiBuilder(65536);

            private enum State
            {
                Empty,
                ElementList,
                Element,
                ComponentList,
                Component,
                Complete
            }

            public int Length { get; private set; }

            private const char Delimiter = ',';
            private const char Quote = '"';
            private const char Colon = ':';
            private const char Space = ' ';
            private const char OpenBracket = '[';
            private const char CloseBracket = ']';
            private const char OpenCurlyBrace = '{';
            private const char CloseCurlyBrace = '}';

            private const int MinCapacity = 1024;
            private const int DefaultCapacity = 4096;

            public IStringCache StringCache { get; }
            private char[] _chars;
            private byte[] _bytes;
            private State _state;
            private bool _needsDelimiter;

            public UiBuilder(int capacity, IStringCache stringCache)
            {
                if (capacity < MinCapacity)
                    throw new InvalidOperationException($"Capacity must be at least {MinCapacity}");

                Resize(capacity);
                StringCache = stringCache;
            }

            public UiBuilder(int capacity = DefaultCapacity) : this(capacity, DefaultStringCache.Instance) {}

            public void Start()
            {
                Reset();
                StartArray();
                _state = State.ElementList;
            }

            public void End()
            {
                ValidateState(State.ElementList);
                EndArray();
                _state = State.Complete;
            }

            public void StartElement()
            {
                ValidateState(State.ElementList);
                StartObject();
                _state = State.Element;
            }

            public void EndElement()
            {
                ValidateState(State.Element);
                EndObject();
                _state = State.ElementList;
            }

            public void StartComponent()
            {
                ValidateState(State.ComponentList);
                StartObject();
                _state = State.Component;
            }

            public void EndComponent()
            {
                ValidateState(State.Component);
                EndObject();
                _state = State.ComponentList;
            }

            public void AddField<T>(string key, T value)
            {
                AddKey(key);
                Append(StringCache.Get(value));
                _needsDelimiter = true;
            }

            public void AddField(string key, string value)
            {
                if (value == null)
                    return;

                AddKey(key);
                Append(Quote);
                Append(value);
                Append(Quote);
                _needsDelimiter = true;
            }

            public void AddXY(string key, float x, float y)
            {
                AddKey(key);
                Append(Quote);
                Append(StringCache.Get(x));
                Append(Space);
                Append(StringCache.Get(y));
                Append(Quote);
                _needsDelimiter = true;
            }

            public void AddSerializable<T>(T serializable) where T : IUiSerializable
            {
                serializable.Serialize(this);
            }

            public void AddComponents<T>(T components) where T : IUiComponentCollection
            {
                ValidateState(State.Element);
                AddKey("components");
                StartArray();
                _state = State.ComponentList;
                components.Serialize(this);
                EndArray();
                _state = State.Element;
            }

            public string ToJson()
            {
                ValidateState(State.Complete);
                return new string(_chars, 0, Length);
            }

            public byte[] GetBytes()
            {
                ValidateState(State.Complete);
                var bytes = new byte[Length];
                Buffer.BlockCopy(_bytes, 0, bytes, 0, Length);
                return bytes;
            }

            public void AddUi(SendInfo sendInfo)
            {
                var write = ClientRPCStart(CommunityEntity.ServerInstance, "AddUI");
                if (write != null)
                {
                    var byteCount = Encoding.UTF8.GetBytes(_chars, 0, Length, _bytes, 0);
                    write.BytesWithSize(_bytes, byteCount);
                    write.Send(sendInfo);
                }
            }

            public void AddUi(BasePlayer player)
            {
                AddUi(new SendInfo(player.Connection));
            }

            private void ValidateState(State desiredState)
            {
                if (_state != desiredState)
                    throw new InvalidOperationException($"Expected state {desiredState} but found {_state}");
            }

            private void ValidateState(State desiredState, State alternateState)
            {
                if (_state != desiredState && _state != alternateState)
                    throw new InvalidOperationException($"Expected state {desiredState} or {alternateState} but found {_state}");
            }

            private void Resize(int length)
            {
                Array.Resize(ref _chars, length);
                Array.Resize(ref _bytes, length * 2);
            }

            private void ResizeIfApproachingLength()
            {
                if (Length + 1024 > _chars.Length)
                {
                    Resize(_chars.Length * 2);
                }
            }

            private void Append(char @char)
            {
                _chars[Length++] = @char;
            }

            private void Append(string str)
            {
                for (var i = 0; i < str.Length; i++)
                {
                    _chars[Length + i] = str[i];
                }

                Length += str.Length;
            }

            private void AddDelimiter()
            {
                Append(Delimiter);
            }

            private void AddDelimiterIfNeeded()
            {
                if (_needsDelimiter)
                {
                    AddDelimiter();
                }
            }

            private void StartObject()
            {
                AddDelimiterIfNeeded();
                Append(OpenCurlyBrace);
                _needsDelimiter = false;
            }

            private void EndObject()
            {
                Append(CloseCurlyBrace);
                _needsDelimiter = true;
            }

            private void StartArray()
            {
                Append(OpenBracket);
                _needsDelimiter = false;
            }

            private void EndArray()
            {
                Append(CloseBracket);
                _needsDelimiter = true;
            }

            private void AddKey(string key)
            {
                ValidateState(State.Element, State.Component);
                ResizeIfApproachingLength();
                AddDelimiterIfNeeded();
                Append(Quote);
                Append(key);
                Append(Quote);
                Append(Colon);
            }

            private void Reset()
            {
                Length = 0;
                _state = State.Empty;
                _needsDelimiter = false;
            }
        }

        #endregion

        #region UI Layout

        private struct UiRect
        {
            public string Anchor;
            public float XMin;
            public float XMax;
            public float YMin;
            public float YMax;
        }

        private static class Layout
        {
            [Flags]
            public enum Option
            {
                AnchorBottom = 1 << 0,
                AnchorRight = 1 << 1,
                Vertical = 1 << 2
            }

            public const string AnchorBottomLeft = "0 0";
            public const string AnchorBottomRight = "1 0";
            public const string AnchorTopLeft = "0 1";
            public const string AnchorTopRight = "1 1";

            public const string AnchorBottomCenter = "0.5 0";
            public const string AnchorTopCenter = "0.5 1";
            public const string AnchorCenterLeft = "0 0.5";
            public const string AnchorCenterRight = "1 0.5";

            public static string DetermineAnchor(Option options)
            {
                return options.HasFlag(Option.AnchorBottom)
                    ? options.HasFlag(Option.AnchorRight) ? AnchorBottomRight : AnchorBottomLeft
                    : options.HasFlag(Option.AnchorRight) ? AnchorTopRight : AnchorTopLeft;
            }
        }

        private interface ILayoutProvider {}

        private struct StatelessLayoutProvider : ILayoutProvider
        {
            public static UiRect GetRect(int index, Layout.Option options, Vector2 size, float spacing = 0, Vector2 offset = default(Vector2))
            {
                var xMin = !options.HasFlag(Layout.Option.Vertical)
                    ? offset.x + index * (spacing + size.x)
                    : offset.x;

                var xMax = xMin + size.x;

                var yMin = options.HasFlag(Layout.Option.Vertical)
                    ? offset.y + index * (spacing + size.y)
                    : offset.y;

                var yMax = yMin + size.y;

                if (options.HasFlag(Layout.Option.AnchorRight))
                {
                    var temp = xMin;
                    xMin = -xMax;
                    xMax = -temp;
                }

                if (!options.HasFlag(Layout.Option.AnchorBottom))
                {
                    var temp = yMin;
                    yMin = -yMax;
                    yMax = -temp;
                }

                return new UiRect
                {
                    Anchor = Layout.DetermineAnchor(options),
                    XMin = xMin,
                    XMax = xMax,
                    YMin = yMin,
                    YMax = yMax,
                };
            }

            public Layout.Option Options;
            public Vector2 Offset;
            public Vector2 Size;
            public float Spacing;

            public UiRect this[int index] => GetRect(index, Options, Size, Spacing, Offset);

            public static StatelessLayoutProvider operator +(StatelessLayoutProvider layoutProvider, Vector2 vector)
            {
                layoutProvider.Offset += vector;
                return layoutProvider;
            }

            public static StatelessLayoutProvider operator -(StatelessLayoutProvider layoutProvider, Vector2 vector)
            {
                layoutProvider.Offset -= vector;
                return layoutProvider;
            }
        }

        private struct StatefulLayoutProvider : ILayoutProvider
        {
            public Layout.Option Options;
            public Vector2 Offset;
            public Vector2 Size;
            public float Spacing;

            public static StatefulLayoutProvider operator +(StatefulLayoutProvider layoutProvider, Vector2 vector)
            {
                layoutProvider.Offset += vector;
                return layoutProvider;
            }

            public static StatefulLayoutProvider operator -(StatefulLayoutProvider layoutProvider, Vector2 vector)
            {
                layoutProvider.Offset -= vector;
                return layoutProvider;
            }

            public UiRect Current(Vector2 size)
            {
                return StatelessLayoutProvider.GetRect(0, Options, size, Spacing, Offset);
            }

            public UiRect Current()
            {
                return Current(Size);
            }

            public UiRect Next(Vector2 size)
            {
                var position = Current(size);

                if (Options.HasFlag(Layout.Option.Vertical))
                {
                    Offset.y += size.y + Spacing;
                }
                else
                {
                    Offset.x += size.x + Spacing;
                }

                return position;
            }

            public UiRect Next(float x, float y)
            {
                return Next(new Vector2(x, y));
            }

            public UiRect Next()
            {
                return Next(Size);
            }
        }

        #endregion

        #region UI Components

        private interface IUiComponent : IUiSerializable {}

        private struct UiButtonComponent : IUiComponent
        {
            private const string Type = "UnityEngine.UI.Button";

            private const string DefaultCommand = null;
            private const string DefaultClose = null;
            private const string DefaultSprite = "Assets/Content/UI/UI.Background.Tile.psd";
            private const string DefaultMaterial = "Assets/Icons/IconMaterial.mat";
            private const string DefaultColor = "1 1 1 1";
            private const Image.Type DefaultImageType = Image.Type.Simple;
            private const float DefaultFadeIn = 0;

            public string Command;
            public string Close;
            public string Sprite;
            public string Material;
            public string Color;
            public Image.Type ImageType;
            public float FadeIn;

            public void Serialize(IUiBuilder builder)
            {
                if (Sprite == default(string))
                    Sprite = DefaultSprite;

                if (Material == default(string))
                    Material = DefaultMaterial;

                if (Color == default(string))
                    Color = DefaultColor;

                if (ImageType == default(Image.Type))
                    ImageType = DefaultImageType;

                builder.StartComponent();
                builder.AddField("type", Type);

                if (Command != DefaultCommand)
                    builder.AddField("command", Command);

                if (Close != DefaultClose)
                    builder.AddField("close", Close);

                if (Sprite != DefaultSprite)
                    builder.AddField("sprite", Sprite);

                if (Material != DefaultMaterial)
                    builder.AddField("material", Material);

                if (Color != DefaultColor)
                    builder.AddField("color", Color);

                if (ImageType != DefaultImageType)
                    builder.AddField("imagetype", builder.StringCache.Get(ImageType));

                if (FadeIn != DefaultFadeIn)
                    builder.AddField("fadeIn", FadeIn);

                builder.EndComponent();
            }
        }

        private struct UiImageComponent : IUiComponent
        {
            private const string Type = "UnityEngine.UI.Image";

            private const string DefaultSprite = "Assets/Content/UI/UI.Background.Tile.psd";
            private const string DefaultMaterial = "Assets/Icons/IconMaterial.mat";
            private const string DefaultColor = "1 1 1 1";
            private const Image.Type DefaultImageType = Image.Type.Simple;
            private const string DefaultPng = null;
            private const int DefaultItemId = 0;
            private const ulong DefaultSkinId = 0;
            private const float DefaultFadeIn = 0;

            public string Sprite;
            public string Material;
            public string Color;
            public Image.Type ImageType;
            public string Png;
            public int ItemId;
            public ulong SkinId;
            public float FadeIn;

            public void Serialize(IUiBuilder builder)
            {
                if (Sprite == default(string))
                    Sprite = DefaultSprite;

                if (Material == default(string))
                    Material = DefaultMaterial;

                if (Color == default(string))
                    Color = DefaultColor;

                if (ImageType == default(Image.Type))
                    ImageType = DefaultImageType;

                builder.StartComponent();
                builder.AddField("type", Type);

                if (Sprite != DefaultSprite)
                    builder.AddField("sprite", Sprite);

                if (Material != DefaultMaterial)
                    builder.AddField("material", Material);

                if (Color != DefaultColor)
                    builder.AddField("color", Color);

                if (ImageType != DefaultImageType)
                    builder.AddField("imagetype", builder.StringCache.Get(ImageType));

                if (Png != DefaultPng)
                    builder.AddField("png", Png);

                if (ItemId != DefaultItemId)
                    builder.AddField("itemid", ItemId);

                if (SkinId != DefaultSkinId)
                    builder.AddField("skinid", SkinId);

                if (FadeIn != DefaultFadeIn)
                    builder.AddField("fadeIn", FadeIn);

                builder.EndComponent();
            }
        }

        private struct UiRawImageComponent : IUiComponent
        {
            private const string Type = "UnityEngine.UI.RawImage";

            private const string DefaultSprite = "Assets/Icons/rust.png";
            private const string DefaultColor = "1 1 1 1";
            private const string DefaultMaterial = null;
            private const string DefaultUrl = null;
            private const string DefaultPng = null;
            private const float DefaultFadeIn = 0;

            public string Sprite;
            public string Color;
            public string Material;
            public string Url;
            public string Png;
            public float FadeIn;

            public void Serialize(IUiBuilder builder)
            {
                if (Sprite == default(string))
                    Sprite = DefaultSprite;

                if (Color == default(string))
                    Color = DefaultColor;

                builder.StartComponent();
                builder.AddField("type", Type);

                if (Sprite != DefaultSprite)
                    builder.AddField("sprite", Sprite);

                if (Color != DefaultColor)
                    builder.AddField("color", Color);

                if (Material != DefaultMaterial)
                    builder.AddField("material", Material);

                if (Url != DefaultUrl)
                    builder.AddField("url", Url);

                if (Png != DefaultPng)
                    builder.AddField("png", Png);

                if (FadeIn != DefaultFadeIn)
                    builder.AddField("fadeIn", FadeIn);

                builder.EndComponent();
            }
        }

        private struct UiRectTransformComponent : IUiComponent
        {
            private const string Type = "RectTransform";

            public const string DefaultAnchorMin = "0.0 0.0";
            public const string DefaultAnchorMax = "1.0 1.0";
            public const string DefaultOffsetMin = "0.0 0.0";
            public const string DefaultOffsetMax = "1.0 1.0";

            public string AnchorMin;
            public string AnchorMax;
            public string OffsetMin;
            public string OffsetMax;

            public void Serialize(IUiBuilder builder)
            {
                if (AnchorMin == default(string))
                    AnchorMin = DefaultAnchorMin;

                if (AnchorMax == default(string))
                    AnchorMax = DefaultAnchorMax;

                if (OffsetMin == default(string))
                    OffsetMin = DefaultOffsetMin;

                if (OffsetMax == default(string))
                    OffsetMax = DefaultOffsetMax;

                builder.StartComponent();
                builder.AddField("type", Type);

                if (AnchorMin != DefaultAnchorMin)
                    builder.AddField("anchormin", AnchorMin);

                if (AnchorMax != DefaultAnchorMax)
                    builder.AddField("anchormax", AnchorMax);

                if (OffsetMin != DefaultOffsetMin)
                    builder.AddField("offsetmin", OffsetMin);

                if (OffsetMax != DefaultOffsetMax)
                    builder.AddField("offsetmax", OffsetMax);

                builder.EndComponent();
            }
        }

        private struct UiTextComponent : IUiComponent
        {
            private const string Type = "UnityEngine.UI.Text";

            private const string DefaultText = "Text";
            private const int DefaultFontSize = 14;
            private const string DefaultFont = "RobotoCondensed-Bold.ttf";
            private const TextAnchor DefaultTextAlign = TextAnchor.UpperLeft;
            private const string DefaultColor = "1 1 1 1";
            private const VerticalWrapMode DefaultVerticalWrapMode = VerticalWrapMode.Truncate;
            private const float DefaultFadeIn = 0;

            public string Text;
            public int FontSize;
            public string Font;
            public TextAnchor TextAlign;
            public string Color;
            public VerticalWrapMode VerticalWrapMode;
            public float FadeIn;

            public void Serialize(IUiBuilder builder)
            {
                if (Text == default(string))
                    Text = DefaultText;

                if (FontSize == default(int))
                    FontSize = DefaultFontSize;

                if (Font == default(string))
                    Font = DefaultFont;

                if (TextAlign == default(TextAnchor))
                    TextAlign = DefaultTextAlign;

                if (Color == default(string))
                    Color = DefaultColor;

                if (VerticalWrapMode == default(VerticalWrapMode))
                    VerticalWrapMode = DefaultVerticalWrapMode;

                builder.StartComponent();
                builder.AddField("type", Type);

                if (Text != DefaultText)
                    builder.AddField("text", Text);

                if (FontSize != DefaultFontSize)
                    builder.AddField("fontSize", FontSize);

                if (Font != DefaultFont)
                    builder.AddField("font", Font);

                if (TextAlign != DefaultTextAlign)
                    builder.AddField("align", builder.StringCache.Get(TextAlign));

                if (Color != DefaultColor)
                    builder.AddField("color", Color);

                if (VerticalWrapMode != DefaultVerticalWrapMode)
                    builder.AddField("verticalOverflow", builder.StringCache.Get(VerticalWrapMode));

                if (FadeIn != DefaultFadeIn)
                    builder.AddField("fadeIn", FadeIn);

                builder.EndComponent();
            }
        }

        // Custom component for handling positions.
        private struct UiRectComponent : IUiComponent
        {
            private const string Type = "RectTransform";

            public const string DefaultAnchorMin = "0.0 0.0";

            private const string DefaultAnchor = "0 0";

            public UiRect Rect;

            public UiRectComponent(UiRect rect)
            {
                Rect = rect;
            }

            public UiRectComponent(float x, float y, string anchor = DefaultAnchor)
            {
                Rect = new UiRect
                {
                    Anchor = anchor,
                    XMin = x,
                    XMax = x,
                    YMin = y,
                    YMax = y
                };
            }

            public void Serialize(IUiBuilder builder)
            {
                builder.StartComponent();
                builder.AddField("type", Type);

                if (Rect.Anchor != DefaultAnchorMin)
                {
                    builder.AddField("anchormin", Rect.Anchor);
                    builder.AddField("anchormax", Rect.Anchor);
                }

                builder.AddXY("offsetmin", Rect.XMin, Rect.YMin);
                builder.AddXY("offsetmax", Rect.XMax, Rect.YMax);

                builder.EndComponent();
            }
        }

        #endregion

        #region UI Elements

        private interface IUiComponentCollection : IUiSerializable {}

        private struct UiComponents<T1> : IUiComponentCollection, IEnumerable<IUiComponentCollection>
            where T1 : IUiComponent
        {
            public T1 Component1;

            public void Add(T1 item) => Component1 = item;

            public void Serialize(IUiBuilder builder)
            {
                Component1.Serialize(builder);
            }

            public IEnumerator<IUiComponentCollection> GetEnumerator()
            {
                throw new NotImplementedException();
            }

            IEnumerator IEnumerable.GetEnumerator()
            {
                throw new NotImplementedException();
            }
        }

        private struct UiComponents<T1, T2> : IUiComponentCollection, IEnumerable<IUiComponentCollection>
            where T1 : IUiComponent
            where T2 : IUiComponent
        {
            public T1 Component1;
            public T2 Component2;

            public void Add(T1 item) => Component1 = item;
            public void Add(T2 item) => Component2 = item;

            public void Serialize(IUiBuilder builder)
            {
                Component1.Serialize(builder);
                Component2.Serialize(builder);
            }

            public IEnumerator<IUiComponentCollection> GetEnumerator()
            {
                throw new NotImplementedException();
            }

            IEnumerator IEnumerable.GetEnumerator()
            {
                throw new NotImplementedException();
            }
        }

        private struct UiElement<T> : IUiSerializable
            where T : IUiComponentCollection
        {
            public string Name;
            public string Parent;
            public string DestroyName;
            public float FadeOut;
            public T Components;

            public void Serialize(IUiBuilder builder)
            {
                builder.StartElement();
                builder.AddField("name", Name);
                builder.AddField("parent", Parent);

                if (DestroyName != default(string))
                    builder.AddField("destroyUi", DestroyName);

                if (FadeOut != default(float))
                    builder.AddField("fadeOut", FadeOut);

                builder.AddComponents(Components);
                builder.EndElement();
            }
        }

        private struct UiButtonElement<TButton, TText> : IUiSerializable
            where TButton : IUiComponentCollection
            where TText : IUiComponentCollection
        {
            public string Name;
            public string Parent;
            public string DestroyName;
            public float FadeOut;
            public TButton Button;
            public TText Text;

            public void Serialize(IUiBuilder builder)
            {
                builder.AddSerializable(new UiElement<TButton>
                {
                    Parent = Parent,
                    Name = Name,
                    Components = Button,
                    DestroyName = DestroyName,
                    FadeOut = FadeOut
                });

                builder.AddSerializable(new UiElement<TText>
                {
                    Parent = Name,
                    Components = Text,
                    FadeOut = FadeOut
                });
            }
        }

        #endregion

        #region UI

        private static class ContainerUi
        {
            public const float BaseOffsetY = 112;
            public const float BaseOffsetX = 192.5f;
            public const float HeaderWidth = 380;
            public const float HeaderHeight = 23;
            public const float PerRowOffsetY = 62;

            private const float PageButtonSpacing = 6;
            private const float PageButtonSize = HeaderHeight;

            private const string BlueButtonColor = "0.25 0.5 0.75 1";
            private const string BlueButtonTextColor = "0.75 0.85 1 1";
            private const string GreenButtonColor = "0.451 0.553 0.271 1";
            private const string GreenButtonTextColor = "0.659 0.918 0.2 1";

            private const string Name = "Backpacks.Container";

            public static void CreateContainerUi(BasePlayer player, int numPages, int activePageIndex, int capacity, Backpack backpack)
            {
                var numRows = 1 + (capacity - 1) / 6;
                var offsetY = BaseOffsetY + numRows * PerRowOffsetY;

                var builder = UiBuilder.Default;
                builder.Start();

                builder.AddSerializable(new UiElement<UiComponents<UiRectComponent>>
                {
                    Parent = "Hud.Menu",
                    Name = Name,
                    DestroyName = Name,
                    Components =
                    {
                        new UiRectComponent(BaseOffsetX, offsetY, Layout.AnchorBottomCenter),
                    }
                });

                var buttonLayoutProvider = new StatefulLayoutProvider
                {
                    Options = Layout.Option.AnchorBottom,
                    Spacing = 6
                };

                if (backpack.CanGather)
                {
                    AddGatherModeButton(builder, ref buttonLayoutProvider, player, backpack, activePageIndex);
                }

                if (backpack.CanRetrieve)
                {
                    AddRetrieveButton(builder, ref buttonLayoutProvider, player, backpack, activePageIndex);
                }

                if (numPages > 1)
                {
                    AddPaginationUi(builder, backpack, numPages, activePageIndex);
                }

                builder.End();
                builder.AddUi(player);
            }

            public static void DestroyUi(BasePlayer player)
            {
                CuiHelper.DestroyUi(player, Name);
            }

            private static void AddGatherModeButton(UiBuilder builder, ref StatefulLayoutProvider layoutProvider, BasePlayer player, Backpack backpack, int activePageIndex)
            {
                var gatherMode = backpack.GetGatherModeForPage(activePageIndex);

                builder.AddSerializable(new UiButtonElement<UiComponents<UiRectComponent, UiButtonComponent>, UiComponents<UiTextComponent>>
                {
                    Parent = Name,
                    Name = "Backpacks.Container.Gather",
                    Button =
                    {
                        new UiRectComponent(layoutProvider.Next(105, HeaderHeight)),
                        new UiButtonComponent
                        {
                            Command = "backpack.togglegather",
                            Color = gatherMode == GatherMode.None ? GreenButtonColor : BlueButtonColor
                        }
                    },
                    Text =
                    {
                        new UiTextComponent
                        {
                            Text = backpack.Plugin.GetMessage(player, gatherMode == GatherMode.All
                                ? "UI - Gather All"
                                : gatherMode == GatherMode.Existing
                                    ? "UI - Gather Existing"
                                    : "UI - Gather Off"),
                            Color = gatherMode == GatherMode.None ? GreenButtonTextColor : BlueButtonTextColor,
                            TextAlign = TextAnchor.MiddleCenter,
                            FontSize = 12
                        }
                    }
                });
            }

            private static void AddRetrieveButton(UiBuilder builder, ref StatefulLayoutProvider layoutProvider, BasePlayer player, Backpack backpack, int activePageIndex)
            {
                var retrieve = backpack.IsRetrievingFromPage(activePageIndex);

                builder.AddSerializable(new UiButtonElement<UiComponents<UiRectComponent, UiButtonComponent>, UiComponents<UiTextComponent>>
                {
                    Parent = Name,
                    Name = "Backpacks.Container.Retrieve",
                    Button =
                    {
                        new UiRectComponent(layoutProvider.Next(85, HeaderHeight)),
                        new UiButtonComponent
                        {
                            Command = "backpack.toggleretrieve",
                            Color = retrieve ? BlueButtonColor : GreenButtonColor
                        }
                    },
                    Text =
                    {
                        new UiTextComponent
                        {
                            Text = backpack.Plugin.GetMessage(player, retrieve
                                ? "UI - Retrieve On"
                                : "UI - Retrieve Off"),
                            Color = retrieve ? BlueButtonTextColor : GreenButtonTextColor,
                            TextAlign = TextAnchor.MiddleCenter,
                            FontSize = 12
                        }
                    }
                });
            }

            private static void AddPaginationUi(UiBuilder builder, Backpack backpack, int numPages, int activePageIndex)
            {
                var offsetY = backpack.Plugin._config.ContainerUi.ShowPageButtonsOnContainerBar
                    ? 0
                    : HeaderHeight + PageButtonSpacing;

                var buttonLayoutProvider = new StatelessLayoutProvider
                {
                    Options = Layout.Option.AnchorBottom | Layout.Option.AnchorRight,
                    Offset = new Vector2(-HeaderWidth, offsetY),
                    Size = new Vector2(PageButtonSize, PageButtonSize),
                    Spacing = PageButtonSpacing
                };

                for (var i = 0; i < numPages; i++)
                {
                    var visiblePageNumber = numPages - i;
                    var pageIndex = visiblePageNumber - 1;
                    var isActivePage = activePageIndex == visiblePageNumber - 1;

                    var name = DefaultStringCache.Instance.Get(i, n => $"{Name}.{n.ToString()}");

                    var buttonColor = isActivePage ? BlueButtonColor : GreenButtonColor;
                    var buttonTextColor = isActivePage ? BlueButtonTextColor : GreenButtonTextColor;

                    builder.AddSerializable(new UiButtonElement<UiComponents<UiRectComponent, UiButtonComponent>, UiComponents<UiTextComponent>>
                    {
                        Parent = Name,
                        Name = name,
                        Button =
                        {
                            new UiRectComponent(buttonLayoutProvider[i]),
                            new UiButtonComponent
                            {
                                Color = buttonColor,
                                Command = isActivePage ? "" : DefaultStringCache.Instance.Get(visiblePageNumber, n => $"backpack.open {n.ToString()}"),
                            }
                        },
                        Text =
                        {
                            new UiTextComponent
                            {
                                Text = DefaultStringCache.Instance.Get(visiblePageNumber),
                                TextAlign = TextAnchor.MiddleCenter,
                                Color = buttonTextColor
                            }
                        }
                    });

                    var arrowSize = new Vector2(PageButtonSize / 2, PageButtonSize / 2);
                    var arrowOffset = new Vector2(0, 1);

                    if (backpack.CanGather && backpack.GetGatherModeForPage(pageIndex) != GatherMode.None)
                    {
                        builder.AddSerializable(new UiElement<UiComponents<UiRectComponent, UiTextComponent>>
                        {
                            Parent = name,
                            Components =
                            {
                                new UiRectComponent(StatelessLayoutProvider.GetRect(0, Layout.Option.AnchorBottom | Layout.Option.AnchorRight | Layout.Option.Vertical, arrowSize, offset: arrowOffset)),
                                new UiTextComponent
                                {
                                    Text = "â",
                                    FontSize = 10,
                                    TextAlign = TextAnchor.LowerRight,
                                    Color = buttonTextColor,
                                    VerticalWrapMode = VerticalWrapMode.Overflow
                                }
                            }
                        });
                    }

                    if (backpack.CanRetrieve && backpack.IsRetrievingFromPage(pageIndex))
                    {
                        builder.AddSerializable(new UiElement<UiComponents<UiRectComponent, UiTextComponent>>
                        {
                            Parent = name,
                            Components =
                            {
                                new UiRectComponent(StatelessLayoutProvider.GetRect(0, Layout.Option.AnchorRight | Layout.Option.Vertical, arrowSize, offset: -arrowOffset)),
                                new UiTextComponent
                                {
                                    Text = "â",
                                    FontSize = 10,
                                    TextAlign = TextAnchor.UpperRight,
                                    Color = buttonTextColor,
                                    VerticalWrapMode = VerticalWrapMode.Overflow
                                }
                            }
                        });
                    }
                }
            }
        }

        private static class ButtonUi
        {
            private const string Name = "BackpacksUI";

            public static string CreateButtonUi(Configuration config)
            {
                var uiBuilder = UiBuilder.Default;

                uiBuilder.Start();
                uiBuilder.AddSerializable(new UiElement<UiComponents<UiRawImageComponent, UiRectTransformComponent>>
                {
                    Name = Name,
                    DestroyName = Name,
                    Parent = "Hud.Menu",
                    Components =
                    {
                        new UiRawImageComponent
                        {
                            Color = config.GUI.Color,
                            Sprite = "assets/content/ui/ui.background.tiletex.psd",
                        },
                        new UiRectTransformComponent
                        {
                            AnchorMin = config.GUI.GUIButtonPosition.AnchorsMin,
                            AnchorMax = config.GUI.GUIButtonPosition.AnchorsMax,
                            OffsetMin = config.GUI.GUIButtonPosition.OffsetsMin,
                            OffsetMax = config.GUI.GUIButtonPosition.OffsetsMax
                        },
                    }
                });

                var rectTransformComponent = new UiRectTransformComponent
                {
                    AnchorMin = "0 0",
                    AnchorMax = "1 1",
                };

                if (config.GUI.SkinId != 0)
                {
                    uiBuilder.AddSerializable(new UiElement<UiComponents<UiImageComponent, UiRectTransformComponent>>
                    {
                        Parent = Name,
                        Components =
                        {
                            new UiImageComponent
                            {
                                ItemId = SaddleBagItemId,
                                SkinId = config.GUI.SkinId
                            },
                            rectTransformComponent
                        }
                    });
                }
                else
                {
                    uiBuilder.AddSerializable(new UiElement<UiComponents<UiRawImageComponent, UiRectTransformComponent>>
                    {
                        Parent = Name,
                        Components =
                        {
                            new UiRawImageComponent
                            {
                                Url = config.GUI.Image
                            },
                            rectTransformComponent
                        }
                    });
                }

                uiBuilder.AddSerializable(new UiElement<UiComponents<UiButtonComponent, UiRectTransformComponent>>
                {
                    Parent = Name,
                    Components =
                    {
                        new UiButtonComponent
                        {
                            Command = "backpack.open",
                            Color = "0 0 0 0"
                        },
                        new UiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1",
                        }
                    }
                });

                uiBuilder.End();
                return uiBuilder.ToJson();
            }

            public static void DestroyUi(BasePlayer player)
            {
                CuiHelper.DestroyUi(player, Name);
            }
        }

        #endregion

        #region Subscriber Manager

        private class EventSubscriber
        {
            public static EventSubscriber FromSpec(Plugin plugin, Dictionary<string, object> spec)
            {
                var subscriber = new EventSubscriber { Plugin = plugin };

                GetOption(spec, nameof(OnBackpackLoaded), out subscriber.OnBackpackLoaded);
                GetOption(spec, nameof(OnBackpackItemCountChanged), out subscriber.OnBackpackItemCountChanged);
                GetOption(spec, nameof(OnBackpackGatherChanged), out subscriber.OnBackpackGatherChanged);
                GetOption(spec, nameof(OnBackpackRetrieveChanged), out subscriber.OnBackpackRetrieveChanged);

                return subscriber;
            }

            private static void GetOption<T>(Dictionary<string, object> dict, string key, out T result)
            {
                object value;
                result = dict.TryGetValue(key, out value) && value is T
                    ? (T)value
                    : default(T);
            }

            public Plugin Plugin { get; private set; }
            public Action<BasePlayer, int, int> OnBackpackLoaded;
            public Action<BasePlayer, int, int> OnBackpackItemCountChanged;
            public Action<BasePlayer, bool> OnBackpackGatherChanged;
            public Action<BasePlayer, bool> OnBackpackRetrieveChanged;
        }

        private class SubscriberManager
        {
            private readonly Dictionary<string, EventSubscriber> _subscribers = new Dictionary<string, EventSubscriber>();

            public void AddSubscriber(Plugin plugin, Dictionary<string, object> spec)
            {
                RemoveSubscriber(plugin);

                _subscribers[plugin.Name] = EventSubscriber.FromSpec(plugin, spec);
            }

            public void RemoveSubscriber(Plugin plugin)
            {
                _subscribers.Remove(plugin.Name);
            }

            public void BroadcastBackpackLoaded(Backpack backpack)
            {
                if (_subscribers.Count == 0 || (object)backpack.Owner == null)
                    return;

                foreach (var subscriber in _subscribers.Values)
                {
                    subscriber.OnBackpackLoaded?.Invoke(backpack.Owner, backpack.ItemCount, backpack.Capacity);
                }
            }

            public void BroadcastItemCountChanged(Backpack backpack)
            {
                if (_subscribers.Count == 0 || (object)backpack.Owner == null)
                    return;

                foreach (var subscriber in _subscribers.Values)
                {
                    subscriber.OnBackpackItemCountChanged?.Invoke(backpack.Owner, backpack.ItemCount, backpack.Capacity);
                }
            }

            public void BroadcastGatherChanged(Backpack backpack, bool isGathering)
            {
                if (_subscribers.Count == 0 || (object)backpack.Owner == null)
                    return;

                foreach (var subscriber in _subscribers.Values)
                {
                    subscriber.OnBackpackGatherChanged?.Invoke(backpack.Owner, isGathering);
                }
            }

            public void BroadcastRetrieveChanged(Backpack backpack, bool isRetrieving)
            {
                if (_subscribers.Count == 0 || (object)backpack.Owner == null)
                    return;

                foreach (var subscriber in _subscribers.Values)
                {
                    subscriber.OnBackpackRetrieveChanged?.Invoke(backpack.Owner, isRetrieving);
                }
            }
        }

        #endregion

        #region Backpack Capacity Manager

        private class BackpackCapacityManager
        {
            private class BackpackSize
            {
                public readonly int Capacity;
                public readonly string Permission;

                public BackpackSize(int capacity, string permission)
                {
                    Capacity = capacity;
                    Permission = permission;
                }
            }

            private readonly Backpacks _plugin;
            private Configuration _config;
            private BackpackSize[] _sortedBackpackSizes;
            private readonly Dictionary<ulong, int> _cachedPlayerBackpackSizes = new Dictionary<ulong, int>();

            public BackpackCapacityManager(Backpacks plugin)
            {
                _plugin = plugin;
            }

            public void Init(Configuration config)
            {
                _config = config;

                var backpackSizeList = new List<BackpackSize>();

                if (config.BackpackSize.EnableLegacyRowPermissions)
                {
                    for (var row = MinRows; row <= MaxRows; row++)
                    {
                        var backpackSize = new BackpackSize(row * SlotsPerRow, $"{UsagePermission}.{row.ToString()}");
                        _plugin.permission.RegisterPermission(backpackSize.Permission, _plugin);
                        backpackSizeList.Add(backpackSize);
                    }
                }

                foreach (var capacity in new HashSet<int>(config.BackpackSize.PermissionSizes))
                {
                    backpackSizeList.Add(new BackpackSize(capacity, $"{SizePermission}.{capacity.ToString()}"));
                }

                backpackSizeList.Sort((a, b) => a.Capacity.CompareTo(b.Capacity));
                _sortedBackpackSizes = backpackSizeList.ToArray();

                foreach (var backpackSize in _sortedBackpackSizes)
                {
                    // The "backpacks.use.X" perms are registered all at once to make them easier to view.
                    if (backpackSize.Permission.StartsWith(UsagePermission))
                        continue;

                    _plugin.permission.RegisterPermission(backpackSize.Permission, _plugin);
                }
            }

            public void ForgetCachedCapacity(ulong userId)
            {
                _cachedPlayerBackpackSizes.Remove(userId);
            }

            public int GetCapacity(ulong userId, string userIdString)
            {
                int capacity;
                if (_cachedPlayerBackpackSizes.TryGetValue(userId, out capacity))
                    return capacity;

                capacity = DetermineCapacityFromPermission(userIdString);
                _cachedPlayerBackpackSizes[userId] = capacity;
                return capacity;
            }

            private int DetermineCapacityFromPermission(string userIdString)
            {
                if (!_plugin.permission.UserHasPermission(userIdString, UsagePermission))
                    return 0;

                for (var i = _sortedBackpackSizes.Length - 1; i >= 0; i--)
                {
                    var backpackSize = _sortedBackpackSizes[i];
                    if (_plugin.permission.UserHasPermission(userIdString, backpackSize.Permission))
                        return backpackSize.Capacity;
                }

                return _config.BackpackSize.DefaultSize;
            }
        }

        #endregion

        #region Backpack Manager

        private class BackpackManager
        {
            private static string DetermineBackpackPath(ulong userId) => $"{nameof(Backpacks)}/{userId.ToString()}";

            private readonly Backpacks _plugin;

            private readonly Dictionary<ulong, Backpack> _cachedBackpacks = new Dictionary<ulong, Backpack>();
            private readonly Dictionary<ulong, string> _backpackPathCache = new Dictionary<ulong, string>();
            private readonly Dictionary<ItemContainer, Backpack> _backpackContainers = new Dictionary<ItemContainer, Backpack>();

            private readonly List<Backpack> _tempBackpackList = new List<Backpack>(PoolUtils.BackpackPoolSize);

            public BackpackManager(Backpacks plugin)
            {
                _plugin = plugin;
            }

            public void DiscoverBags(Plugin bagOfHolding)
            {
                foreach (var backpack in _cachedBackpacks.Values)
                {
                    backpack.DiscoverBags(bagOfHolding);
                }
            }

            public void HandleCapacityPermissionChangedForGroup(string groupName)
            {
                foreach (var backpack in _cachedBackpacks.Values)
                {
                    if (!_plugin.permission.UserHasGroup(backpack.OwnerIdString, groupName))
                        continue;

                    _plugin._backpackCapacityManager.ForgetCachedCapacity(backpack.OwnerId);
                    backpack.SetFlag(Backpack.Flag.CapacityCached, false);
                }
            }

            public void HandleCapacityPermissionChangedForUser(string userIdString)
            {
                var backpack = GetBackpackIfCached(userIdString);
                if (backpack == null)
                    return;

                _plugin._backpackCapacityManager.ForgetCachedCapacity(backpack.OwnerId);
                backpack.SetFlag(Backpack.Flag.CapacityCached, false);
            }

            public void HandleRestrictionPermissionChangedForGroup(string groupName)
            {
                foreach (var backpack in _cachedBackpacks.Values)
                {
                    if (!_plugin.permission.UserHasGroup(backpack.OwnerIdString, groupName))
                        continue;

                    backpack.SetFlag(Backpack.Flag.RestrictionsCached, false);
                }
            }

            public void HandleRestrictionPermissionChangedForUser(string userIdString)
            {
                var backpack = GetBackpackIfCached(userIdString);
                if (backpack == null)
                    return;

                backpack.SetFlag(Backpack.Flag.RestrictionsCached, false);
            }

            public void HandleGatherPermissionChangedForGroup(string groupName)
            {
                foreach (var backpack in _cachedBackpacks.Values)
                {
                    if (!_plugin.permission.UserHasGroup(backpack.OwnerIdString, groupName))
                        continue;

                    backpack.SetFlag(Backpack.Flag.GatherCached, false);
                }
            }

            public void HandleGatherPermissionChangedForUser(string userIdString)
            {
                GetBackpackIfCached(userIdString)?.SetFlag(Backpack.Flag.GatherCached, false);
            }

            public void HandleRetrievePermissionChangedForGroup(string groupName)
            {
                foreach (var backpack in _cachedBackpacks.Values)
                {
                    if (!_plugin.permission.UserHasGroup(backpack.OwnerIdString, groupName))
                        continue;

                    backpack.SetFlag(Backpack.Flag.RetrieveCached, false);
                }
            }

            public void HandleRetrievePermissionChangedForUser(string userIdString)
            {
                GetBackpackIfCached(userIdString)?.SetFlag(Backpack.Flag.RetrieveCached, false);
            }

            public void HandleGroupChangeForUser(string userIdString)
            {
                var backpack = GetBackpackIfCached(userIdString);
                if (backpack == null)
                    return;

                _plugin._backpackCapacityManager.ForgetCachedCapacity(backpack.OwnerId);
                backpack.SetFlag(Backpack.Flag.CapacityCached, false);
                backpack.SetFlag(Backpack.Flag.RestrictionsCached, false);
                backpack.SetFlag(Backpack.Flag.GatherCached, false);
                backpack.SetFlag(Backpack.Flag.RetrieveCached, false);
            }

            public bool IsBackpack(ItemContainer container)
            {
                return _backpackContainers.ContainsKey(container);
            }

            public bool IsBackpack(ItemContainer container, out Backpack backpack, out int pageIndex)
            {
                if (!_backpackContainers.TryGetValue(container, out backpack))
                {
                    pageIndex = 0;
                    return false;
                }

                pageIndex = backpack.GetPageIndexForContainer(container);
                if (pageIndex == -1)
                {
                    pageIndex = 0;
                    return false;
                }

                return true;
            }

            public bool HasBackpackFile(ulong userId)
            {
                return Interface.Oxide.DataFileSystem.ExistsDatafile(GetBackpackPath(userId));
            }

            public Backpack GetBackpackIfCached(ulong userId)
            {
                Backpack backpack;
                return _cachedBackpacks.TryGetValue(userId, out backpack)
                    ? backpack
                    : null;
            }

            public Backpack GetBackpack(ulong userId)
            {
                return GetBackpackIfCached(userId) ?? Load(userId);
            }

            public Backpack GetBackpackIfExists(ulong userId)
            {
                return GetBackpackIfCached(userId) ?? (HasBackpackFile(userId)
                    ? Load(userId)
                    : null);
            }

            public void RegisterContainer(ItemContainer container, Backpack backpack)
            {
                _backpackContainers[container] = backpack;
            }

            public void UnregisterContainer(ItemContainer container)
            {
                _backpackContainers.Remove(container);
            }

            public Backpack GetCachedBackpackForContainer(ItemContainer container)
            {
                Backpack backpack;
                return _backpackContainers.TryGetValue(container, out backpack)
                    ? backpack
                    : null;
            }

            public Dictionary<ulong, ItemContainer> GetAllCachedContainers()
            {
                var cachedContainersByUserId = new Dictionary<ulong, ItemContainer>();

                foreach (var entry in _cachedBackpacks)
                {
                    var container = entry.Value.GetContainer();
                    if (container != null)
                        cachedContainersByUserId[entry.Key] = container;
                }

                return cachedContainersByUserId;
            }

            public DroppedItemContainer Drop(ulong userId, Vector3 position, List<DroppedItemContainer> collect = null)
            {
                return GetBackpackIfExists(userId)?.Drop(position, collect);
            }

            public bool TryOpenBackpack(BasePlayer looter, ulong backpackOwnerId)
            {
                if (backpackOwnerId == 0)
                {
                    backpackOwnerId = looter.userID;
                }

                return GetBackpack(backpackOwnerId).TryOpen(looter);
            }

            public bool TryOpenBackpackContainer(BasePlayer looter, ulong backpackOwnerId, ItemContainer container)
            {
                if (backpackOwnerId == 0)
                {
                    backpackOwnerId = looter.userID;
                }

                Backpack backpack;
                int pageIndex;
                if (!IsBackpack(container, out backpack, out pageIndex) || backpack.OwnerId != backpackOwnerId)
                {
                    backpack = GetBackpack(backpackOwnerId);
                    pageIndex = -1;
                }

                return backpack.TryOpen(looter, pageIndex);
            }

            public bool TryOpenBackpackPage(BasePlayer looter, ulong backpackOwnerId, int pageIndex = -1)
            {
                if (backpackOwnerId == 0)
                {
                    backpackOwnerId = looter.userID;
                }

                return GetBackpack(backpackOwnerId).TryOpen(looter, pageIndex);
            }

            public void ClearBackpackFile(ulong userId)
            {
                Interface.Oxide.DataFileSystem.WriteObject<object>(DetermineBackpackPath(userId), null);
            }

            public bool TryEraseForPlayer(ulong userId)
            {
                var backpack = GetBackpackIfExists(userId);
                if (backpack == null)
                    return false;

                backpack.EraseContents(force: true);
                return true;
            }

            public IEnumerator SaveAllAndKill(bool async, bool keepInUseBackpacks)
            {
                // Clear the list before usage, in case an error prevented cleanup, or in case coroutine was restarted.
                _tempBackpackList.Clear();

                // Copy the list of cached backpacks because it may be modified.
                foreach (var backpack in _cachedBackpacks.Values)
                {
                    _tempBackpackList.Add(backpack);
                }

                foreach (var backpack in _tempBackpackList)
                {
                    var didSave = backpack.SaveIfChanged();

                    // Kill the backpack to free up space, if no admins are viewing it and its owner is disconnected.
                    if (!keepInUseBackpacks || (!backpack.HasLooters && BasePlayer.FindByID(backpack.OwnerId) == null))
                    {
                        backpack.Kill();
                        _cachedBackpacks.Remove(backpack.OwnerId);
                        _backpackPathCache.Remove(backpack.OwnerId);
                        var backpackToFree = backpack;
                        CustomPool.Free(ref backpackToFree);
                    }

                    if (didSave && async)
                        yield return null;
                }

                _tempBackpackList.Clear();
            }

            public void ClearCache()
            {
                foreach (var backpack in _cachedBackpacks.Values)
                {
                    var backpackToFree = backpack;
                    CustomPool.Free(ref backpackToFree);
                }

                _cachedBackpacks.Clear();
            }

            private string GetBackpackPath(ulong userId)
            {
                string filepath;
                if (!_backpackPathCache.TryGetValue(userId, out filepath))
                {
                    filepath = DetermineBackpackPath(userId);
                    _backpackPathCache[userId] = filepath;
                }

                return filepath;
            }

            private Backpack Load(ulong userId)
            {
                #if DEBUG_BACKPACK_LIFECYCLE
                LogDebug($"Backpack::Load | {userId.ToString()}");
                #endif

                var filePath = GetBackpackPath(userId);

                Backpack backpack = null;

                var dataFile = Interface.Oxide.DataFileSystem.GetFile(filePath);
                if (dataFile.Exists())
                {
                    backpack = dataFile.ReadObject<Backpack>();
                }

                // Note: Even if the user has a backpack file, the file contents may be null in some edge cases.
                // For example, if a data file cleaner plugin writes the file content as `null`.
                if (backpack == null)
                {
                    backpack = CustomPool.Get<Backpack>();
                }

                backpack.Setup(_plugin, userId, dataFile);
                _cachedBackpacks[userId] = backpack;

                _plugin._subscriberManager.BroadcastBackpackLoaded(backpack);

                return backpack;
            }

            private Backpack GetBackpackIfCached(string userIdString)
            {
                ulong userId;
                if (!ulong.TryParse(userIdString, out userId))
                    return null;

                return GetBackpackIfCached(userId);
            }
        }

        #endregion

        #region Backpack Networking

        private class BackpackNetworkController
        {
            private const uint StartNetworkGroupId = 10000000;
            private static uint _nextNetworkGroupId = StartNetworkGroupId;

            public static void ResetNetworkGroupId()
            {
                _nextNetworkGroupId = StartNetworkGroupId;
            }

            public static bool IsBackpackNetworkGroup(Network.Visibility.Group group)
            {
                return group.ID >= StartNetworkGroupId && group.ID < _nextNetworkGroupId;
            }

            public static BackpackNetworkController Create()
            {
                return new BackpackNetworkController(_nextNetworkGroupId++);
            }

            public readonly Network.Visibility.Group NetworkGroup;

            private readonly List<BasePlayer> _subscribers = new List<BasePlayer>(1);

            private BackpackNetworkController(uint networkGroupId)
            {
                NetworkGroup = new Network.Visibility.Group(null, networkGroupId);
            }

            public void Subscribe(BasePlayer player)
            {
                if (player.Connection == null || _subscribers.Contains(player))
                    return;

                _subscribers.Add(player);

                // Send the client a message letting them know they are subscribed to the group.
                ServerMgr.OnEnterVisibility(player.Connection, NetworkGroup);

                // Send the client a snapshot of every entity currently in the group.
                // Don't use the entity queue for this because it could be cleared which could cause updates to be missed.
                foreach (var networkable in NetworkGroup.networkables)
                {
                    (networkable.handler as BaseNetworkable).SendAsSnapshot(player.Connection);
                }

                if (!NetworkGroup.subscribers.Contains(player.Connection))
                {
                    // Register the client with the group so that entities added to it will be automatically sent to the client.
                    NetworkGroup.subscribers.Add(player.Connection);
                }

                var subscriber = player.net.subscriber;
                if (!subscriber.subscribed.Contains(NetworkGroup))
                {
                    // Register the group with the client so that ShouldNetworkTo() returns true in SendNetworkUpdate().
                    // This covers cases such as toggling a pager's silent mode.
                    subscriber.subscribed.Add(NetworkGroup);
                }
            }

            public void Unsubscribe(BasePlayer player)
            {
                if (!_subscribers.Remove(player))
                    return;

                if (player.Connection == null)
                    return;

                // Unregister the client from the group so they don't get future entity updates.
                NetworkGroup.subscribers.Remove(player.Connection);
                player.net.subscriber.subscribed.Remove(NetworkGroup);

                // Send the client a message so they kill all client-side entities in the group.
                ServerMgr.OnLeaveVisibility(player.Connection, NetworkGroup);
            }

            public void UnsubscribeAll()
            {
                for (var i = _subscribers.Count - 1; i >= 0; i--)
                {
                    Unsubscribe(_subscribers[i]);
                }
            }
        }

        #endregion

        #region Unity Components

        private class NoRagdollCollision : FacepunchBehaviour
        {
            private Collider _collider;

            private void Awake()
            {
                _collider = GetComponent<Collider>();
            }

            private void OnCollisionEnter(Collision collision)
            {
                if (collision.collider.IsOnLayer(Rust.Layer.Ragdoll))
                {
                    Physics.IgnoreCollision(_collider, collision.collider);
                }
            }
        }

        private class BackpackCloseListener : EntityComponent<StorageContainer>
        {
            public static void AddToBackpackStorage(Backpacks plugin, StorageContainer containerEntity, Backpack backpack)
            {
                var component = containerEntity.gameObject.AddComponent<BackpackCloseListener>();
                component._plugin = plugin;
                component._backpack = backpack;
            }

            private Backpacks _plugin;
            private Backpack _backpack;

            // Called via `entity.SendMessage("PlayerStoppedLooting", player)` in PlayerLoot.Clear().
            private void PlayerStoppedLooting(BasePlayer looter)
            {
                _plugin.TrackStart();
                _backpack.OnClosed(looter);
                ExposedHooks.OnBackpackClosed(looter, _backpack.OwnerId, looter.inventory.loot.containers.FirstOrDefault());
                _plugin.TrackEnd();
            }
        }

        #endregion

        #region Item Query

        private struct ItemQuery
        {
            public static ItemQuery FromItem(Item item)
            {
                return new ItemQuery
                {
                    BlueprintId = item.blueprintTarget,
                    DataInt = item.instanceData?.dataInt ?? 0,
                    DisplayName = item.name,
                    ItemDefinition = item.info,
                    ItemId = item.info.itemid,
                    SkinId = item.skin,
                };
            }

            public static ItemQuery Parse(Dictionary<string, object> raw)
            {
                var itemQuery = new ItemQuery();

                GetOption(raw, "BlueprintId", out itemQuery.BlueprintId);
                GetOption(raw, "DisplayName", out itemQuery.DisplayName);
                GetOption(raw, "DataInt", out itemQuery.DataInt);
                GetOption(raw, "FlagsContain", out itemQuery.FlagsContain);
                GetOption(raw, "FlagsEqual", out itemQuery.FlagsEqual);
                GetOption(raw, "ItemDefinition", out itemQuery.ItemDefinition);
                GetOption(raw, "ItemId", out itemQuery.ItemId);
                GetOption(raw, "MinCondition", out itemQuery.MinCondition);
                GetOption(raw, "RequireEmpty", out itemQuery.RequireEmpty);
                GetOption(raw, "SkinId", out itemQuery.SkinId);

                return itemQuery;
            }

            private static void GetOption<T>(Dictionary<string, object> dict, string key, out T result)
            {
                object value;
                result = dict.TryGetValue(key, out value) && value is T
                    ? (T)value
                    : default(T);
            }

            public int? BlueprintId;
            public int? DataInt;
            public string DisplayName;
            public Item.Flag? FlagsContain;
            public Item.Flag? FlagsEqual;
            public ItemDefinition ItemDefinition;
            public int? ItemId;
            public float MinCondition;
            public bool RequireEmpty;
            public ulong? SkinId;

            private int? GetItemId()
            {
                if (ItemDefinition != null)
                    return ItemDefinition?.itemid ?? ItemId;

                return ItemId;
            }

            private ItemDefinition GetItemDefinition()
            {
                if ((object)ItemDefinition == null && ItemId.HasValue)
                {
                    ItemDefinition = ItemManager.FindItemDefinition(ItemId.Value);
                }

                return ItemDefinition;
            }

            private bool HasCondition()
            {
                return GetItemDefinition()?.condition.enabled ?? false;
            }

            private float ConditionNormalized(ItemData itemData)
            {
                return itemData.Condition / itemData.MaxCondition;
            }

            private float MaxConditionNormalized(ItemData itemData)
            {
                var itemDefinition = GetItemDefinition();
                if (itemDefinition == null)
                    return 1;

                return itemData.MaxCondition / itemDefinition.condition.max;
            }

            public int GetUsableAmount(Item item)
            {
                var itemId = GetItemId();
                if (itemId.HasValue && itemId != item.info.itemid)
                    return 0;

                if (SkinId.HasValue && SkinId != item.skin)
                    return 0;

                if (BlueprintId.HasValue && BlueprintId != item.blueprintTarget)
                    return 0;

                if (DataInt.HasValue && DataInt != (item.instanceData?.dataInt ?? 0))
                    return 0;

                if (FlagsContain.HasValue && !item.flags.HasFlag(FlagsContain.Value))
                    return 0;

                if (FlagsEqual.HasValue && FlagsEqual != item.flags)
                    return 0;

                if (MinCondition > 0 && HasCondition() && (item.conditionNormalized < MinCondition || item.maxConditionNormalized < MinCondition))
                    return 0;

                if (!string.IsNullOrEmpty(DisplayName) && !StringUtils.Equals(DisplayName, item.name))
                    return 0;

                return RequireEmpty && item.contents?.itemList?.Count > 0
                    ? Math.Max(0, item.amount - 1)
                    : item.amount;
            }

            public int GetUsableAmount(ItemData itemData)
            {
                var itemId = GetItemId();
                if (itemId.HasValue && itemId != itemData.ID)
                    return 0;

                if (SkinId.HasValue && SkinId != itemData.Skin)
                    return 0;

                if (BlueprintId.HasValue && BlueprintId != itemData.BlueprintTarget)
                    return 0;

                if (DataInt.HasValue && DataInt != itemData.DataInt)
                    return 0;

                if (FlagsContain.HasValue && !itemData.Flags.HasFlag(FlagsContain.Value))
                    return 0;

                if (FlagsEqual.HasValue && FlagsEqual != itemData.Flags)
                    return 0;

                if (MinCondition > 0 && HasCondition() && (ConditionNormalized(itemData) < MinCondition || MaxConditionNormalized(itemData) < MinCondition))
                    return 0;

                if (!string.IsNullOrEmpty(DisplayName) && !StringUtils.Equals(DisplayName, itemData.Name))
                    return 0;

                return RequireEmpty && itemData.Contents?.Count > 0
                    ? Math.Max(0, itemData.Amount - 1)
                    : itemData.Amount;
            }
        }

        #endregion

        #region Container Adapters

        private struct WipeContext
        {
            public int SlotsKept;
        }

        private interface IContainerAdapter : CustomPool.IPooled
        {
            int PageIndex { get; }
            int Capacity { get; set; }
            int ItemCount { get; }
            bool HasItems { get; }
            int PositionOf(ref ItemQuery itemQuery);
            int CountItems(ref ItemQuery itemQuery);
            int SumItems(ref ItemQuery itemQuery);
            int TakeItems(ref ItemQuery itemQuery, int amount, List<Item> collect);
            bool TryDepositItem(Item item);
            void ReclaimFractionForSoftcore(float fraction, List<Item> collect);
            void TakeRestrictedItems(List<Item> collect);
            void TakeAllItems(List<Item> collect, int startPosition = 0);
            void SerializeForNetwork(List<ProtoBuf.Item> saveList);
            void SerializeTo(List<ItemData> saveList, List<ItemData> itemsToReleaseToPool);
            void EraseContents(WipeRuleset ruleset, ref WipeContext wipeContext);
            void Kill();
            void FreeToPool();
        }

        private class VirtualContainerAdapter : IContainerAdapter
        {
            public int PageIndex { get; private set; }
            public int Capacity { get; set; }
            public List<ItemData> ItemDataList { get; } = new List<ItemData>(_maxCapacityPerPage);
            public int ItemCount => ItemDataList.Count;
            public bool HasItems => ItemCount > 0;

            private Backpack _backpack;

            public VirtualContainerAdapter Setup(Backpack backpack, int pageIndex, int capacity)
            {
                #if DEBUG_POOLING
                LogDebug($"VirtualContainerAdapter::Setup | PageIndex: {pageIndex.ToString()} | Capacity: {capacity.ToString()}");
                #endif

                PageIndex = pageIndex;
                Capacity = capacity;
                _backpack = backpack;
                return this;
            }

            public void EnterPool()
            {
                #if DEBUG_POOLING
                LogDebug($"VirtualContainerAdapter::EnterPool | {CustomPool.GetStats<VirtualContainerAdapter>()}");
                #endif

                PageIndex = 0;
                Capacity = 0;
                PoolUtils.ResetItemsAndClear(ItemDataList);
                _backpack = null;
            }

            public void LeavePool()
            {
                #if DEBUG_POOLING
                LogDebug($"VirtualContainerAdapter::LeavePool | {CustomPool.GetStats<VirtualContainerAdapter>()}");
                #endif
            }

            public void SortByPosition()
            {
                ItemDataList.Sort((a, b) => a.Position.CompareTo(b.Position));
            }

            public int PositionOf(ref ItemQuery itemQuery)
            {
                SortByPosition();
                return ItemUtils.PositionOf(ItemDataList, ref itemQuery);
            }

            public int CountItems(ref ItemQuery itemQuery)
            {
                return ItemUtils.CountItems(ItemDataList, ref itemQuery);
            }

            public int SumItems(ref ItemQuery itemQuery)
            {
                return ItemUtils.SumItems(ItemDataList, ref itemQuery);
            }

            public int TakeItems(ref ItemQuery itemQuery, int amount, List<Item> collect)
            {
                var originalItemCount = ItemCount;

                var amountTaken = ItemUtils.TakeItems(ItemDataList, ref itemQuery, amount, collect);
                if (amountTaken > 0)
                {
                    _backpack.SetFlag(Backpack.Flag.Dirty, true);

                    if (ItemCount != originalItemCount)
                    {
                        _backpack.HandleItemCountChanged();
                    }
                }

                return amountTaken;
            }

            public void ReclaimFractionForSoftcore(float fraction, List<Item> collect)
            {
                // For some reason, the vanilla reclaim logic doesn't take the last item.
                if (ItemDataList.Count <= 1)
                    return;

                var numToTake = Mathf.Ceil(ItemDataList.Count * fraction);

                for (var i = 0; i < numToTake; i++)
                {
                    var indexToTake = UnityEngine.Random.Range(0, ItemDataList.Count);
                    var itemDataToTake = ItemDataList[indexToTake];
                    if (itemDataToTake.Amount > 1)
                    {
                        // Prefer taking a smaller stack if possible (vanilla behavior).
                        for (var j = 0; j < ItemDataList.Count; j++)
                        {
                            var alternateItemData = ItemDataList[j];
                            if (alternateItemData.ID != itemDataToTake.ID)
                                continue;

                            if (alternateItemData.Amount >= itemDataToTake.Amount)
                                continue;

                            itemDataToTake = alternateItemData;
                            indexToTake = j;
                        }
                    }

                    var item = itemDataToTake.ToItem();
                    if (item != null)
                    {
                        collect.Add(item);
                    }

                    RemoveItem(indexToTake);
                }
            }

            public void TakeRestrictedItems(List<Item> collect)
            {
                if (ItemDataList.Count == 0)
                    return;

                for (var i = ItemDataList.Count - 1; i >= 0; i--)
                {
                    var itemData = ItemDataList[i];
                    if (_backpack.RestrictionRuleset.AllowsItem(itemData))
                        continue;

                    var item = itemData.ToItem();
                    if (item != null)
                    {
                        collect.Add(item);
                    }

                    RemoveItem(i);
                }
            }

            public void TakeAllItems(List<Item> collect, int startPosition = 0)
            {
                SortByPosition();

                if (ItemDataList.Count == 0)
                    return;

                for (var i = 0; i < ItemDataList.Count; i++)
                {
                    var itemData = ItemDataList[i];
                    if (itemData.Position < startPosition)
                        continue;

                    var item = itemData.ToItem();
                    if (item != null)
                    {
                        collect.Add(item);
                    }

                    RemoveItem(i--);
                }
            }

            public void SerializeForNetwork(List<ProtoBuf.Item> saveList)
            {
                ItemUtils.SerializeForNetwork(ItemDataList, saveList);
            }

            public void SerializeTo(List<ItemData> saveList, List<ItemData> itemsToReleaseToPool)
            {
                foreach (var itemData in ItemDataList)
                {
                    saveList.Add(itemData);
                }
            }

            public void EraseContents(WipeRuleset ruleset, ref WipeContext wipeContext)
            {
                if (ruleset == null || ruleset.DisallowsAll)
                {
                    if (ItemDataList.Count > 0)
                    {
                        PoolUtils.ResetItemsAndClear(ItemDataList);
                        _backpack.SetFlag(Backpack.Flag.Dirty, true);
                    }
                    return;
                }

                SortByPosition();

                for (var i = 0; i < ItemDataList.Count; i++)
                {
                    var itemData = ItemDataList[i];
                    if ((ruleset.MaxSlotsToKeep < 0 || wipeContext.SlotsKept < ruleset.MaxSlotsToKeep)
                        && ruleset.AllowsItem(itemData))
                    {
                        wipeContext.SlotsKept++;
                        continue;
                    }

                    RemoveItem(i--);
                }
            }

            public void Kill()
            {
                // Intentionally not implemented because there are no actual resources to destroy.
            }

            public void FreeToPool()
            {
                var self = this;
                CustomPool.Free(ref self);
            }

            public VirtualContainerAdapter CopyItemsFrom(List<ItemData> itemDataList)
            {
                var startPosition = PageIndex * _maxCapacityPerPage;
                var endPosition = startPosition + Capacity;

                // This assumes the list has already been sorted by item position.
                foreach (var itemData in itemDataList)
                {
                    if (itemData.Position < startPosition)
                        continue;

                    if (itemData.Position >= endPosition)
                        break;

                    ItemDataList.Add(itemData);
                }

                return this;
            }

            public bool TryDepositItem(Item item)
            {
                var firstEmptyPosition = GetFirstEmptyPosition();
                if (firstEmptyPosition >= Capacity)
                {
                    // To keep things simple, simply deny the item if there are no empty slots. This is done because
                    // it's difficult to know whether the item can be stacked with an existing item without calling
                    // stacking related hooks which require a physical page and item. This results in an edge case
                    // where if all pages are full, and no physical pages can accept the item, then any full virtual
                    // page would reject the item, even if upgrading the page would allow the item. In the future, the
                    // page could be upgraded to a physical container to handle this edge case if necessary.
                    return false;
                }

                if (!_backpack.ShouldAcceptItem(item, null))
                    return false;

                var itemData = CustomPool.Get<ItemData>().Setup(item, firstEmptyPosition);
                ItemDataList.Add(itemData);

                item.RemoveFromContainer();
                item.Remove();

                _backpack.SetFlag(Backpack.Flag.Dirty, true);
                _backpack.HandleItemCountChanged();
                return true;
            }

            private int GetFirstEmptyPosition()
            {
                var nextPossiblePosition = 0;

                for (var i = 0; i < ItemDataList.Count; i++)
                {
                    var itemData = ItemDataList[i];
                    if (itemData.Position > nextPossiblePosition)
                        return i;

                    nextPossiblePosition++;
                }

                return nextPossiblePosition;
            }

            private void RemoveItem(int index)
            {
                var itemData = ItemDataList[index];
                ItemDataList.RemoveAt(index);
                CustomPool.Free(ref itemData);
                _backpack.SetFlag(Backpack.Flag.Dirty, true);
                _backpack.HandleItemCountChanged();
            }
        }

        private class ItemContainerAdapter : IContainerAdapter
        {
            public int PageIndex { get; private set; }
            public int Capacity
            {
                get { return ItemContainer.capacity; }
                set { ItemContainer.capacity = value; }
            }
            public ItemContainer ItemContainer { get; private set; }
            public int ItemCount => ItemContainer.itemList.Count;
            public bool HasItems => ItemCount > 0;

            private Backpack _backpack;

            private Action _onDirty;
            private Func<Item, int, bool> _canAcceptItem;
            private Action<Item, bool> _onItemAddedRemoved;

            private Backpacks _plugin => _backpack.Plugin;
            private Configuration _config => _plugin._config;

            public ItemContainerAdapter()
            {
                _onDirty = () => _backpack.MarkDirty();
                _canAcceptItem = (item, amount) =>
                {
                    // Explicitly track hook time so server owners can be informed of the cost.
                    var result = _backpack.ShouldAcceptItem(item, ItemContainer);
                    if (!result)
                    {
                        var feedbackRecipient = _backpack.DetermineFeedbackRecipientIfEligible();
                        if ((object)feedbackRecipient != null)
                        {
                            feedbackRecipient.ChatMessage(_plugin.GetMessage(feedbackRecipient, "Backpack Item Rejected"));
                            _plugin.SendEffect(feedbackRecipient, _config.ItemRestrictions.FeedbackEffect);
                            _backpack.TimeSinceLastFeedback = 0;
                        }
                    }
                    return result;
                };
                _onItemAddedRemoved = (item, wasAdded) =>
                {
                    _backpack.HandleItemCountChanged();
                };
            }

            public ItemContainerAdapter Setup(Backpack backpack, int pageIndex, ItemContainer container)
            {
                #if DEBUG_POOLING
                LogDebug($"ItemContainerAdapter::Setup | PageIndex: {pageIndex.ToString()} | Capacity: {container.capacity.ToString()}");
                #endif

                PageIndex = pageIndex;
                ItemContainer = container;
                _backpack = backpack;

                return this;
            }

            public void EnterPool()
            {
                #if DEBUG_POOLING
                LogDebug($"ItemContainerAdapter::EnterPool | PageIndex: {PageIndex.ToString()} | Capacity: {Capacity.ToString()} | {CustomPool.GetStats<ItemContainerAdapter>()}");
                #endif

                PageIndex = 0;
                ItemContainer = null;
                _backpack = null;
            }

            public void LeavePool()
            {
                #if DEBUG_POOLING
                LogDebug($"ItemContainerAdapter::LeavePool | {CustomPool.GetStats<ItemContainerAdapter>()}");
                #endif
            }

            public ItemContainerAdapter AddDelegates()
            {
                // Add delegates only after filling the container initially to avoid marking the container as dirty
                // before any changes have been made, and avoids unnecessary CanBackpackAcceptItem hook calls.
                ItemContainer.onDirty += _onDirty;
                ItemContainer.canAcceptItem = _canAcceptItem;
                ItemContainer.onItemAddedRemoved += _onItemAddedRemoved;
                return this;
            }

            public void SortByPosition()
            {
                ItemContainer.itemList.Sort((a, b) => a.position.CompareTo(b.position));
            }

            public void FindItems(ref ItemQuery itemQuery, List<Item> collect)
            {
                ItemUtils.FindItems(ItemContainer.itemList, ref itemQuery, collect);
            }

            public void FindAmmo(AmmoTypes ammoType, List<Item> collect)
            {
                ItemContainer.FindAmmo(collect, ammoType);
            }

            public int PositionOf(ref ItemQuery itemQuery)
            {
                SortByPosition();
                return ItemUtils.PositionOf(ItemContainer.itemList, ref itemQuery);
            }

            public int CountItems(ref ItemQuery itemQuery)
            {
                return ItemUtils.CountItems(ItemContainer.itemList, ref itemQuery);
            }

            public int SumItems(ref ItemQuery itemQuery)
            {
                return ItemUtils.SumItems(ItemContainer.itemList, ref itemQuery);
            }

            public int TakeItems(ref ItemQuery itemQuery, int amount, List<Item> collect)
            {
                return ItemUtils.TakeItems(ItemContainer.itemList, ref itemQuery, amount, collect);
            }

            public bool TryDepositItem(Item item)
            {
                return item.MoveToContainer(ItemContainer);
            }

            public bool TryInsertItem(Item item, ref ItemQuery itemQuery, int position)
            {
                for (var i = position; i < ItemContainer.capacity; i++)
                {
                    var existingItem = ItemContainer.GetSlot(i);
                    if (existingItem != null && itemQuery.GetUsableAmount(existingItem) <= 0)
                        continue;

                    if (item.MoveToContainer(ItemContainer, i, allowSwap: false))
                        return true;
                }

                return item.MoveToContainer(ItemContainer);
            }

            public void ReclaimFractionForSoftcore(float fraction, List<Item> collect)
            {
                var itemList = ItemContainer.itemList;

                // For some reason, the vanilla reclaim logic doesn't take the last item.
                if (itemList.Count <= 1)
                    return;

                var numToTake = Mathf.Ceil(itemList.Count * fraction);

                for (var i = 0; i < numToTake; i++)
                {
                    var indexToTake = UnityEngine.Random.Range(0, itemList.Count);
                    var itemToTake = itemList[indexToTake];
                    if (itemToTake.amount > 1)
                    {
                        // Prefer taking a smaller stack if possible (vanilla behavior).
                        foreach (var item in itemList)
                        {
                            if (item.info != itemToTake.info)
                                continue;

                            if (item.amount >= itemToTake.amount)
                                continue;

                            itemToTake = item;
                        }
                    }

                    collect.Add(itemToTake);
                    itemToTake.RemoveFromContainer();
                }
            }

            public void TakeRestrictedItems(List<Item> collect)
            {
                for (var i = ItemContainer.itemList.Count - 1; i >= 0; i--)
                {
                    var item = ItemContainer.itemList[i];
                    if (_backpack.RestrictionRuleset.AllowsItem(item))
                        continue;

                    collect.Add(item);
                    item.RemoveFromContainer();
                }
            }

            public void TakeAllItems(List<Item> collect, int startPosition = 0)
            {
                SortByPosition();

                for (var i = 0; i < ItemContainer.itemList.Count; i++)
                {
                    var item = ItemContainer.itemList[i];
                    if (item.position < startPosition)
                        continue;

                    collect.Add(item);
                    item.RemoveFromContainer();
                    i--;
                }
            }

            public void SerializeForNetwork(List<ProtoBuf.Item> saveList)
            {
                ItemUtils.SerializeForNetwork(ItemContainer.itemList, saveList);
            }

            public void SerializeTo(List<ItemData> saveList, List<ItemData> itemsToReleaseToPool)
            {
                var positionOffset = PageIndex * _maxCapacityPerPage;

                foreach (var item in ItemContainer.itemList)
                {
                    var itemData = CustomPool.Get<ItemData>().Setup(item, positionOffset);
                    saveList.Add(itemData);
                    itemsToReleaseToPool.Add(itemData);
                }
            }

            public void EraseContents(WipeRuleset ruleset, ref WipeContext wipeContext)
            {
                for (var i = ItemContainer.itemList.Count - 1; i >= 0; i--)
                {
                    var item = ItemContainer.itemList[i];
                    item.RemoveFromContainer();
                    item.Remove();
                }
            }

            public void Kill()
            {
                if (ItemContainer == null || ItemContainer.uid.Value == 0)
                    return;

                ItemContainer.Kill();
            }

            public void FreeToPool()
            {
                var self = this;
                CustomPool.Free(ref self);
            }

            public ItemContainerAdapter CopyItemsFrom(List<ItemData> itemDataList)
            {
                foreach (var itemData in itemDataList)
                {
                    var item = itemData.ToItem();
                    if (item == null)
                        continue;

                    if (!item.MoveToContainer(ItemContainer, item.position) && !item.MoveToContainer(ItemContainer))
                    {
                        _backpack.AddRejectedItem(item);
                    }
                }

                return this;
            }
        }

        private class ContainerAdapterEnumerator : IEnumerator<IContainerAdapter>, CustomPool.IPooled
        {
            private ContainerAdapterCollection _adapterCollection;
            private int _position = -1;

            public ContainerAdapterEnumerator Setup(ContainerAdapterCollection adapterCollection)
            {
                #if DEBUG_POOLING
                LogDebug("ContainerAdapterEnumerator::Setup");
                #endif

                _adapterCollection = adapterCollection;
                _position = -1;
                return this;
            }

            public void EnterPool()
            {
                #if DEBUG_POOLING
                LogDebug($"ContainerAdapterEnumerator::EnterPool | {CustomPool.GetStats<ContainerAdapterEnumerator>()}");
                #endif

                _adapterCollection = null;
                _position = -1;
            }

            public void LeavePool()
            {
                #if DEBUG_POOLING
                LogDebug($"ContainerAdapterEnumerator::LeavePool | {CustomPool.GetStats<ContainerAdapterEnumerator>()}");
                #endif
            }

            public bool MoveNext()
            {
                while (++_position < _adapterCollection.Count)
                {
                    if (_adapterCollection[_position] != null)
                        return true;
                }

                return false;
            }

            public void Reset()
            {
                throw new NotImplementedException();
            }

            public IContainerAdapter Current => _adapterCollection[_position];

            object IEnumerator.Current => Current;

            public void Dispose()
            {
                var self = this;
                CustomPool.Free(ref self);
            }
        }

        /// <summary>
        /// A collection of IContainerAdapters which may contain null entries.
        ///
        /// The underlying array may be enlarged but not shrunk via the Resize method.
        ///
        /// When enumerating via foreach, null entries are skipped, and enumeration stops at Count.
        /// </summary>
        private class ContainerAdapterCollection : IEnumerable<IContainerAdapter>
        {
            public int Count { get; private set; }
            private IContainerAdapter[] _containerAdapters;

            public ContainerAdapterCollection(int size)
            {
                Resize(size);
            }

            public void RemoveAt(int index)
            {
                this[index] = null;
            }

            public IContainerAdapter this[int i]
            {
                get
                {
                    if (i >= Count)
                        throw new IndexOutOfRangeException($"Index {i} was outside the bounds of the collection of size {Count}");

                    return _containerAdapters[i];
                }
                set
                {
                    if (i >= Count)
                        throw new IndexOutOfRangeException($"Index {i} was outside the bounds of the collection of size {Count}");

                    _containerAdapters[i] = value;
                }
            }

            public IEnumerator<IContainerAdapter> GetEnumerator()
            {
                return CustomPool.Get<ContainerAdapterEnumerator>().Setup(this);
            }

            IEnumerator IEnumerable.GetEnumerator()
            {
                return GetEnumerator();
            }

            public void Resize(int newSize)
            {
                if (newSize == Count)
                    return;

                if (newSize > Count)
                {
                    Array.Resize(ref _containerAdapters, newSize);
                }
                else
                {
                    for (var i = Count; i < _containerAdapters.Length; i++)
                    {
                        if (_containerAdapters[i] != null)
                            throw new InvalidOperationException($"ContainerAdapterCollection cannot be shrunk from {Count} to {newSize} because there is an existing container adapter at index {i}");
                    }
                }

                Count = newSize;
            }

            public void ResetPooledItemsAndClear()
            {
                foreach (var containerAdapter in _containerAdapters)
                {
                    containerAdapter?.FreeToPool();
                }

                Count = 0;
            }
        }

        #endregion

        #region Player Inventory Watcher

        private class InventoryWatcher : FacepunchBehaviour
        {
            public static InventoryWatcher AddToPlayer(BasePlayer player, Backpack backpack)
            {
                var component = player.gameObject.AddComponent<InventoryWatcher>();
                component._player = player;
                component._backpack = backpack;

                if (player.inventory.containerMain != null)
                    player.inventory.containerMain.onItemAddedRemoved += component._onItemAddedRemoved;

                if (player.inventory.containerBelt != null)
                    player.inventory.containerBelt.onItemAddedRemoved += component._onItemAddedRemoved;

                if (player.inventory.containerWear != null)
                    player.inventory.containerWear.onItemAddedRemoved += component._onItemAddedRemoved;

                return component;
            }

            private BasePlayer _player;
            private Backpack _backpack;

            private Action<Item, bool> _onItemAddedRemoved;
            private int _pauseGatherModeUntilFrame;

            public void DestroyImmediate() => DestroyImmediate(this);

            private InventoryWatcher()
            {
                _onItemAddedRemoved = OnItemAddedRemoved;
            }

            private bool IsLootingBackpackOrChildContainer()
            {
                var lootingContainer = _player.inventory.loot.containers.FirstOrDefault();
                if (lootingContainer == null)
                    return false;

                var rootContainer = lootingContainer.parent != null
                    ? GetRootContainer(lootingContainer.parent)
                    : lootingContainer;

                if (rootContainer == null)
                    return false;

                return _backpack.Plugin._backpackManager.IsBackpack(rootContainer);
            }

            private void OnItemAddedRemoved(Item item, bool wasAdded)
            {
                if (_player.IsDestroyed
                    || _player.IsDead()
                    || _player.IsIncapacitated()
                    || _player.IsSleeping()
                    || _player.IsReceivingSnapshot
                    || IsLootingBackpackOrChildContainer())
                    return;

                if (wasAdded)
                {
                    // Don't gather items from the wearable container.
                    // We still listen to events from it in order to determine when an item is removed.
                    if (item.parent == _player.inventory.containerWear)
                        return;

                    if (_pauseGatherModeUntilFrame != 0)
                    {
                        if (_pauseGatherModeUntilFrame > Time.frameCount)
                            return;

                        _pauseGatherModeUntilFrame = 0;
                    }

                    var itemQuery = ItemQuery.FromItem(item);
                    if (HasMatchingItem(_player.inventory.containerMain.itemList, item, ref itemQuery, 24)
                        || HasMatchingItem(_player.inventory.containerBelt.itemList, item, ref itemQuery, 6))
                        return;

                    var originalPauseGatherModeUntilFrame = _pauseGatherModeUntilFrame;
                    if (_backpack.TryGatherItem(item) && originalPauseGatherModeUntilFrame != _pauseGatherModeUntilFrame)
                    {
                        // Don't pause gather mode due to gathering an item.
                        _pauseGatherModeUntilFrame = 0;
                    }
                }
                else
                {
                    _pauseGatherModeUntilFrame = Time.frameCount + 1;
                }
            }

            private bool HasMatchingItem(List<Item> itemList, Item item, ref ItemQuery itemQuery, int maxSlots)
            {
                for (var i = 0; i < itemList.Count; i++)
                {
                    var possibleItem = itemList[i];
                    if (possibleItem == item || possibleItem.position >= maxSlots)
                        continue;

                    if (itemQuery.GetUsableAmount(possibleItem) > 0)
                        return true;
                }

                return false;
            }

            private void OnDestroy()
            {
                if (_player.inventory.containerMain != null)
                    _player.inventory.containerMain.onItemAddedRemoved -= _onItemAddedRemoved;

                if (_player.inventory.containerBelt != null)
                    _player.inventory.containerBelt.onItemAddedRemoved -= _onItemAddedRemoved;

                if (_player.inventory.containerWear != null)
                    _player.inventory.containerWear.onItemAddedRemoved -= _onItemAddedRemoved;

                _backpack.HandleGatheringStopped();
            }
        }

        #endregion

        #region Backpack

        private enum GatherMode
        {
            // Don't rename these since the names are persisted in data files.
            None = 0,
            All,
            Existing
        }

        [JsonObject(MemberSerialization.OptIn)]
        [JsonConverter(typeof(PoolConverter<Backpack>))]
        private class Backpack : CustomPool.IPooled
        {
            [Flags]
            public enum Flag
            {
                CapacityCached = 1 << 0,
                RestrictionsCached = 1 << 1,
                GatherCached = 1 << 2,
                RetrieveCached = 1 << 3,
                ProcessedRestrictedItems = 1 << 4,
                Dirty = 1 << 5,
            }

            private class PausableCallback : IDisposable
            {
                private Action _action;
                private bool _isPaused;
                private bool _wasCalled;

                public PausableCallback(Action action)
                {
                    _action = action;
                }

                public PausableCallback Pause()
                {
                    _isPaused = true;
                    return this;
                }

                public void Call()
                {
                    if (_isPaused)
                    {
                        _wasCalled = true;
                        return;
                    }

                    _action();
                }

                public void Dispose()
                {
                    if (_isPaused && _wasCalled)
                    {
                        _action();
                    }

                    _isPaused = false;
                    _wasCalled = false;
                }
            }

            private struct BackpackCapacity
            {
                public static int CalculatePageCapacity(int totalCapacity, int pageIndex)
                {
                    if (pageIndex < 0)
                        throw new ArgumentOutOfRangeException($"Page cannot be negative: {pageIndex}.");

                    var numPages = CalculatePageCountForCapacity(totalCapacity);
                    var lastPageIndex = numPages - 1;

                    if (pageIndex > lastPageIndex)
                        throw new ArgumentOutOfRangeException($"Page {pageIndex} cannot exceed {lastPageIndex}");

                    return pageIndex < lastPageIndex
                        ? _maxCapacityPerPage
                        : totalCapacity - _maxCapacityPerPage * lastPageIndex;
                }

                public static bool operator >(BackpackCapacity a, BackpackCapacity b) => a.Capacity > b.Capacity;
                public static bool operator <(BackpackCapacity a, BackpackCapacity b) => a.Capacity < b.Capacity;

                public static bool operator >=(BackpackCapacity a, BackpackCapacity b) => a.Capacity >= b.Capacity;
                public static bool operator <=(BackpackCapacity a, BackpackCapacity b) => a.Capacity <= b.Capacity;

                private static int CalculatePageCountForCapacity(int capacity)
                {
                    return 1 + (capacity - 1) / _maxCapacityPerPage;
                }

                public int Capacity
                {
                    get
                    {
                        return _capacity;
                    }
                    set
                    {
                        _capacity = value;
                        PageCount = CalculatePageCountForCapacity(value);
                    }
                }
                public int PageCount { get; private set; }
                public int LastPage => PageCount - 1;
                public int LastPageCapacity => CapacityForPage(LastPage);
                public int CapacityForPage(int pageIndex) => CalculatePageCapacity(Capacity, pageIndex);
                public int ClampPage(int pageIndex) => Mathf.Clamp(pageIndex, 0, LastPage);

                private int _capacity;
            }

            private const float FeedbackThrottleSeconds = 1f;

            private static int CalculatePageIndexForItemPosition(int position)
            {
                return position / _maxCapacityPerPage;
            }

            [JsonProperty("OwnerID", Order = 0)]
            public ulong OwnerId { get; private set; }

            [JsonProperty("GatherMode", ItemConverterType = typeof(StringEnumConverter))]
            private Dictionary<int, GatherMode> GatherModeByPage = new Dictionary<int, GatherMode>();

            [JsonProperty("Retrieve", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private int RetrieveFromPagesMask;

            [JsonProperty("Items", Order = 2)]
            private List<ItemData> ItemDataCollection = new List<ItemData>();

            public List<Item> _rejectedItems;

            public Backpacks Plugin;
            public BackpackNetworkController NetworkController { get; private set; }
            public string OwnerIdString;
            public RealTimeSince TimeSinceLastFeedback;

            private BackpackCapacity ActualCapacity;
            private BackpackCapacity _allowedCapacity;

            private PausableCallback _itemCountChangedEvent;
            private Flag _flags;
            private RestrictionRuleset _restrictionRuleset;
            private bool _canGather;
            private bool _canRetrieve;
            private DynamicConfigFile _dataFile;
            private StorageContainer _storageContainer;
            private BasePlayer _owner;
            private ContainerAdapterCollection _containerAdapters;
            private readonly List<BasePlayer> _looters = new List<BasePlayer>();
            private readonly List<BasePlayer> _uiViewers = new List<BasePlayer>();
            private InventoryWatcher _inventoryWatcher;
            private float _pauseGatherModeUntilTime;
            private int _checkedAccessOnFrame;

            public bool HasLooters => _looters.Count > 0;
            public bool IsGathering => (object)_inventoryWatcher != null;
            private Configuration _config => Plugin._config;
            private BackpackManager _backpackManager => Plugin._backpackManager;
            private SubscriberManager _subscriberManager => Plugin._subscriberManager;

            public BasePlayer Owner
            {
                get
                {
                    if (_owner == null || !_owner.IsConnected)
                    {
                        foreach (var looter in _looters)
                        {
                            if (looter.userID == OwnerId)
                            {
                                _owner = looter;
                                break;
                            }
                        }

                        if (_owner == null)
                        {
                            _owner = BasePlayer.FindByID(OwnerId);
                        }
                    }

                    return _owner;
                }
            }

            public int Capacity => AllowedCapacity.Capacity;

            private BackpackCapacity AllowedCapacity
            {
                get
                {
                    if (!HasFlag(Flag.CapacityCached))
                    {
                        _allowedCapacity.Capacity = Math.Max(MinCapacity, Plugin._backpackCapacityManager.GetCapacity(OwnerId, OwnerIdString));
                        SetFlag(Flag.CapacityCached, true);
                    }

                    return _allowedCapacity;
                }
            }

            public RestrictionRuleset RestrictionRuleset
            {
                get
                {
                    if (!HasFlag(Flag.RestrictionsCached))
                    {
                        var restrictionRuleset = _config.ItemRestrictions.GetForPlayer(OwnerIdString);
                        if (restrictionRuleset != _restrictionRuleset)
                        {
                            // Re-evaluate existing items when the backpack is next opened.
                            SetFlag(Flag.ProcessedRestrictedItems, false);
                        }

                        _restrictionRuleset = restrictionRuleset;
                        SetFlag(Flag.RestrictionsCached, true);
                    }

                    return _restrictionRuleset;
                }
            }

            public bool CanGather
            {
                get
                {
                    if (!HasFlag(Flag.GatherCached))
                    {
                        _canGather = Plugin.permission.UserHasPermission(OwnerIdString, GatherPermission);
                        SetFlag(Flag.GatherCached, true);
                    }

                    return _canGather;
                }
            }

            public bool CanRetrieve
            {
                get
                {
                    if (Plugin.ItemRetriever == null)
                        return false;

                    if (!HasFlag(Flag.RetrieveCached))
                    {
                        _canRetrieve = Plugin.permission.UserHasPermission(OwnerIdString, RetrievePermission);
                        SetFlag(Flag.RetrieveCached, true);
                    }

                    return _canRetrieve;
                }
            }

            public int ItemCount
            {
                get
                {
                    var count = 0;

                    foreach (var containerAdapter in _containerAdapters)
                    {
                        count += containerAdapter.ItemCount;
                    }

                    return count;
                }
            }

            public bool IsRetrieving
            {
                get
                {
                    if (!CanRetrieve)
                        return false;

                    var allowedPageCount = AllowedCapacity.PageCount;

                    for (var pageIndex = 0; pageIndex < allowedPageCount; pageIndex++)
                    {
                        if (IsRetrievingFromPage(pageIndex))
                            return true;
                    }

                    return false;
                }
            }

            public bool CanAccess
            {
                get
                {
                    var frameCount = Time.frameCount;
                    if (frameCount == _checkedAccessOnFrame)
                    {
                        // Access was already allowed this frame.
                        return true;
                    }

                    if (frameCount == -_checkedAccessOnFrame)
                    {
                        // Access was already denied this frame.
                        return false;
                    }

                    if (Plugin.IsPlayingEvent(Owner) || ExposedHooks.CanOpenBackpack(Owner, OwnerId) is string)
                    {
                        _checkedAccessOnFrame = -frameCount;
                        return false;
                    }

                    _checkedAccessOnFrame = frameCount;
                    return true;
                }
            }

            private bool HasItems => ItemCount > 0;

            public Backpack()
            {
                _itemCountChangedEvent = new PausableCallback(BroadcastItemCountChanged);
            }

            public void Setup(Backpacks plugin, ulong ownerId, DynamicConfigFile dataFile)
            {
                #if DEBUG_POOLING
                LogDebug($"Backpack::Setup | OwnerId: {ownerId.ToString()}");
                #endif

                Plugin = plugin;
                OwnerId = ownerId;
                OwnerIdString = ownerId.ToString();
                _dataFile = dataFile;

                if (NetworkController == null)
                {
                    NetworkController = BackpackNetworkController.Create();
                }

                SetupItemsAndContainers();
            }

            public void EnterPool()
            {
                #if DEBUG_POOLING
                LogDebug($"Backpack::EnterPool | OwnerId: {OwnerIdString} | {CustomPool.GetStats<Backpack>()}");
                #endif

                OwnerId = 0;
                GatherModeByPage.Clear();
                RetrieveFromPagesMask = 0;

                if (ItemDataCollection != null)
                {
                    PoolUtils.ResetItemsAndClear(ItemDataCollection);
                }

                // Don't remove the NetworkController. Will reuse it for the next Backpack owner.
                NetworkController?.UnsubscribeAll();
                _itemCountChangedEvent.Dispose();
                _flags = 0;
                OwnerIdString = null;
                ActualCapacity = default(BackpackCapacity);
                _allowedCapacity = default(BackpackCapacity);
                _restrictionRuleset = null;
                _canGather = false;
                _canRetrieve = false;
                _dataFile = null;
                _storageContainer = null;
                _owner = null;
                _containerAdapters?.ResetPooledItemsAndClear();
                _looters.Clear();
                _uiViewers.Clear();
                StopGathering();
                if (_rejectedItems?.Count > 0)
                {
                    foreach (var item in _rejectedItems)
                    {
                        LogError($"Found rejected item when backpack entered pool: {item.amount.ToString()} {item.info.shortname} (skin: {item.skin.ToString()})");
                        item.Remove();
                    }
                    _rejectedItems.Clear();
                }

                Plugin = null;
            }

            public void LeavePool()
            {
                #if DEBUG_POOLING
                LogDebug($"LeavePool | {CustomPool.GetStats<Backpack>()}");
                #endif
            }

            public void SetFlag(Flag flag, bool value)
            {
                if (value)
                {
                    _flags |= flag;
                }
                else
                {
                    _flags &= ~flag;
                }
            }

            public bool HasFlag(Flag flag)
            {
                return _flags.HasFlag(flag);
            }

            public void DiscoverBags(Plugin bagOfHolding)
            {
                foreach (var containerAdapter in _containerAdapters)
                {
                    var itemContainerAdapter = containerAdapter as ItemContainerAdapter;
                    if (itemContainerAdapter == null)
                        continue;

                    bagOfHolding.Call("API_DiscoverBags", itemContainerAdapter.ItemContainer);
                }
            }

            public void MarkDirty()
            {
                SetFlag(Flag.Dirty, true);

                if (Plugin.ItemRetriever != null)
                {
                    Owner?.inventory?.containerMain?.MarkDirty();
                }
            }

            public bool IsRetrievingFromPage(int pageIndex)
            {
                var flag = 1 << pageIndex;
                return (RetrieveFromPagesMask & flag) != 0;
            }

            public void ToggleRetrieve(BasePlayer player, int pageIndex)
            {
                var wasPreviouslyRetrieving = IsRetrieving;
                SetRetrieveFromPage(pageIndex, !IsRetrievingFromPage(pageIndex));
                MaybeCreateContainerUi(player,  AllowedCapacity.PageCount, pageIndex, EnsurePage(pageIndex).Capacity);

                var isNowRetrieving = IsRetrieving;
                if (isNowRetrieving != wasPreviouslyRetrieving)
                {
                    _subscriberManager.BroadcastRetrieveChanged(this, isNowRetrieving);
                }
            }

            public GatherMode GetGatherModeForPage(int pageIndex)
            {
                GatherMode gatherMode;
                return GatherModeByPage.TryGetValue(pageIndex, out gatherMode)
                    ? gatherMode
                    : GatherMode.None;
            }

            public void ToggleGatherMode(BasePlayer player, int pageIndex)
            {
                switch (GetGatherModeForPage(pageIndex))
                {
                    case GatherMode.All:
                        SetGatherModeForPage(pageIndex, GatherMode.Existing);
                        break;

                    case GatherMode.Existing:
                        SetGatherModeForPage(pageIndex, GatherMode.None);
                        break;

                    case GatherMode.None:
                        SetGatherModeForPage(pageIndex, GatherMode.All);
                        break;
                }

                if (GatherModeByPage.Count > 0)
                {
                    StartGathering(player);
                }
                else
                {
                    StopGathering();
                }

                MaybeCreateContainerUi(player,  AllowedCapacity.PageCount, pageIndex, EnsurePage(pageIndex).Capacity);
            }

            public void HandleGatheringStopped()
            {
                _inventoryWatcher = null;
            }

            public void PauseGatherMode(float durationSeconds)
            {
                if (!IsGathering)
                    return;

                _pauseGatherModeUntilTime = Time.time + durationSeconds;
            }

            public bool TryGatherItem(Item item)
            {
                if (!CanGather)
                {
                    GatherModeByPage.Clear();
                    SetFlag(Flag.Dirty, true);
                    StopGathering();
                    return false;
                }

                // When overflowing, don't allow items to be added.
                if (ActualCapacity > AllowedCapacity)
                    return false;

                if (_pauseGatherModeUntilTime != 0)
                {
                    if (_pauseGatherModeUntilTime > Time.time)
                        return false;

                    _pauseGatherModeUntilTime = 0;
                }

                // Optimization: Don't search pages for a matching item it's not allowed.
                if (_config.ItemRestrictions.Enabled && !RestrictionRuleset.AllowsItem(item))
                    return false;

                if (!CanAccess)
                    return false;

                var itemQuery = ItemQuery.FromItem(item);
                var anyPagesWithGatherAll = false;
                var allowedPageCount = AllowedCapacity.PageCount;

                using (_itemCountChangedEvent.Pause())
                {
                    // Use a for loop so empty pages aren't skipped.
                    for (var i = 0; i < allowedPageCount; i++)
                    {
                        var gatherMode = GetGatherModeForPage(i);
                        if (gatherMode == GatherMode.None)
                            continue;

                        if (gatherMode == GatherMode.All)
                        {
                            anyPagesWithGatherAll = true;
                            continue;
                        }

                        var containerAdapter = _containerAdapters[i];
                        if (containerAdapter == null || !containerAdapter.HasItems)
                            continue;

                        var position = containerAdapter.PositionOf(ref itemQuery);
                        if (position == -1)
                            continue;

                        if (EnsureItemContainerAdapter(i).TryInsertItem(item, ref itemQuery, position))
                            return true;
                    }

                    if (anyPagesWithGatherAll)
                    {
                        // Try to add the item to a Gather:All page that has a matching stack.
                        // Use a foreach loop to skip uninitialized pages (which are empty).
                        foreach (var containerAdapter in _containerAdapters)
                        {
                            var gatherMode = GetGatherModeForPage(containerAdapter.PageIndex);
                            if (gatherMode != GatherMode.All || !containerAdapter.HasItems)
                                continue;

                            var position = containerAdapter.PositionOf(ref itemQuery);
                            if (position == -1)
                                continue;

                            if (EnsureItemContainerAdapter(containerAdapter.PageIndex)
                                .TryInsertItem(item, ref itemQuery, position))
                                return true;
                        }

                        // Try to add the item to any Gather:All page.
                        // Use a for loop so uninitialized pages aren't skipped.
                        for (var i = 0; i < allowedPageCount; i++)
                        {
                            var gatherMode = GetGatherModeForPage(i);
                            if (gatherMode != GatherMode.All)
                                continue;

                            if (EnsureItemContainerAdapter(i).TryDepositItem(item))
                                return true;
                        }
                    }
                }

                return false;
            }

            public void AddRejectedItem(Item item)
            {
                if (_rejectedItems == null)
                {
                    _rejectedItems = new List<Item>();
                }

                _rejectedItems.Add(item);
            }

            public int GetPageIndexForContainer(ItemContainer container)
            {
                return GetAdapterForContainer(container)?.PageIndex ?? -1;
            }

            public ItemContainerAdapter EnsureItemContainerAdapter(int pageIndex)
            {
                var containerAdapter = EnsurePage(pageIndex, preferRealContainer: true);
                return containerAdapter as ItemContainerAdapter
                       ?? UpgradeToItemContainer(containerAdapter as VirtualContainerAdapter);
            }

            public int GetAllowedPageCapacityForLooter(ulong looterId, int desiredPageIndex)
            {
                return GetAllowedCapacityForLooter(looterId).CapacityForPage(desiredPageIndex);
            }

            public int DetermineInitialPageForLooter(ulong looterId, int desiredPageIndex, bool forward)
            {
                var allowedCapacity = GetAllowedCapacityForLooter(looterId);

                if (desiredPageIndex == -1)
                {
                    desiredPageIndex = forward ? 0 : allowedCapacity.LastPage;
                }

                return allowedCapacity.ClampPage(desiredPageIndex);
            }

            public int DetermineNextPageIndexForLooter(ulong looterId, int currentPageIndex, int desiredPageIndex, bool forward, bool wrapAround, bool requireContents)
            {
                var allowedCapacity = GetAllowedCapacityForLooter(looterId);

                if (desiredPageIndex >= 0)
                    return Math.Min(desiredPageIndex, allowedCapacity.LastPage);

                if (forward)
                {
                    for (var i = currentPageIndex + 1; i < allowedCapacity.PageCount; i++)
                    {
                        var containerAdapter = _containerAdapters[i];
                        if (!requireContents || (containerAdapter?.HasItems ?? false))
                            return i;
                    }

                    if (wrapAround)
                    {
                        for (var i = 0; i < currentPageIndex; i++)
                        {
                            var containerAdapter = _containerAdapters[i];
                            if (!requireContents || (containerAdapter?.HasItems ?? false))
                                return i;
                        }
                    }
                }
                else
                {
                    // Searching backward.
                    for (var i = currentPageIndex - 1; i >= 0; i--)
                    {
                        var containerAdapter = _containerAdapters[i];
                        if (!requireContents || (containerAdapter?.HasItems ?? false))
                            return i;
                    }

                    if (wrapAround)
                    {
                        for (var i = allowedCapacity.LastPage; i > currentPageIndex; i++)
                        {
                            var containerAdapter = _containerAdapters[i];
                            if (!requireContents || (containerAdapter?.HasItems ?? false))
                                return i;
                        }
                    }
                }

                return currentPageIndex;
            }

            public int CountItems(ref ItemQuery itemQuery)
            {
                var count = 0;

                foreach (var containerAdapter in _containerAdapters)
                {
                    count += containerAdapter.CountItems(ref itemQuery);
                }

                return count;
            }

            public void FindItems(ref ItemQuery itemQuery, List<Item> collect, bool forItemRetriever = false)
            {
                foreach (var containerAdapter in _containerAdapters)
                {
                    if (forItemRetriever && !IsRetrievingFromPage(containerAdapter.PageIndex))
                        continue;

                    (containerAdapter as ItemContainerAdapter)?.FindItems(ref itemQuery, collect);
                }
            }

            public void FindAmmo(AmmoTypes ammoType, List<Item> collect, bool forItemRetriever = false)
            {
                foreach (var containerAdapter in _containerAdapters)
                {
                    if (forItemRetriever && !IsRetrievingFromPage(containerAdapter.PageIndex))
                        continue;

                    (containerAdapter as ItemContainerAdapter)?.FindAmmo(ammoType, collect);
                }
            }

            public int SumItems(ref ItemQuery itemQuery, bool forItemRetriever = false)
            {
                var sum = 0;

                foreach (var containerAdapter in _containerAdapters)
                {
                    if (forItemRetriever && !IsRetrievingFromPage(containerAdapter.PageIndex))
                        continue;

                    sum += containerAdapter.SumItems(ref itemQuery);
                }

                return sum;
            }

            public int TakeItems(ref ItemQuery itemQuery, int amount, List<Item> collect, bool forItemRetriever = false)
            {
                using (_itemCountChangedEvent.Pause())
                {
                    var amountTaken = 0;

                    foreach (var containerAdapter in _containerAdapters)
                    {
                        if (forItemRetriever && !IsRetrievingFromPage(containerAdapter.PageIndex))
                            continue;

                        var amountToTake = amount - amountTaken;
                        if (amountToTake <= 0)
                            break;

                        amountTaken += containerAdapter.TakeItems(ref itemQuery, amountToTake, collect);
                    }

                    return amountTaken;
                }
            }

            public bool TryDepositItem(Item item)
            {
                // When overflowing, don't allow items to be added.
                if (ActualCapacity > AllowedCapacity)
                    return false;

                using (_itemCountChangedEvent.Pause())
                {
                    for (var i = 0; i < AllowedCapacity.PageCount; i++)
                    {
                        var containerAdapter = EnsurePage(i);
                        if (!containerAdapter.TryDepositItem(item))
                            continue;

                        return true;
                    }
                }

                return false;
            }

            public void SerializeForNetwork(List<ProtoBuf.Item> saveList, bool forItemRetriever = false)
            {
                foreach (var containerAdapter in _containerAdapters)
                {
                    if (forItemRetriever && !IsRetrievingFromPage(containerAdapter.PageIndex))
                        continue;

                    containerAdapter.SerializeForNetwork(saveList);
                }
            }

            public IPlayer FindOwnerPlayer() => Plugin.covalence.Players.FindPlayerById(OwnerIdString);

            public bool ShouldAcceptItem(Item item, ItemContainer container)
            {
                if (_config.ItemRestrictions.Enabled && !RestrictionRuleset.AllowsItem(item))
                    return false;

                var hookResult = ExposedHooks.CanBackpackAcceptItem(OwnerId, container, item);
                if (hookResult is bool && (bool)hookResult == false)
                    return false;

                return true;
            }

            public void HandleItemCountChanged()
            {
                _itemCountChangedEvent.Call();
            }

            public ItemContainer GetContainer(bool ensureContainer = false)
            {
                if (ensureContainer)
                    return EnsureItemContainerAdapter(0).ItemContainer;

                return (EnsurePage(0) as ItemContainerAdapter)?.ItemContainer;
            }

            public bool TryOpen(BasePlayer looter, int pageIndex = -1)
            {
                if (!Plugin.VerifyCanOpenBackpack(looter, OwnerId))
                    return false;

                EnlargeIfNeeded();

                var allowedCapacity = GetAllowedCapacityForLooter(looter.userID);
                pageIndex = allowedCapacity.ClampPage(pageIndex);
                var itemContainerAdapter = EnsureItemContainerAdapter(pageIndex);

                NetworkController.Subscribe(looter);

                // Some operations are only appropriate for the owner (not for admins viewing the backpack).
                if (looter.userID == OwnerId)
                {
                    EjectRejectedItemsIfNeeded(looter);
                    EjectRestrictedItemsIfNeeded(looter);
                    ShrinkIfNeededAndEjectOverflowingItems(looter);
                    if (CanGather && GatherModeByPage.Count > 0)
                    {
                        StartGathering(looter);
                    }
                }

                if (!_looters.Contains(looter))
                {
                    _looters.Add(looter);
                }

                StartLooting(looter, itemContainerAdapter.ItemContainer, _storageContainer);
                ExposedHooks.OnBackpackOpened(looter, OwnerId, itemContainerAdapter.ItemContainer);
                MaybeCreateContainerUi(looter,  allowedCapacity.PageCount, pageIndex, itemContainerAdapter.Capacity);

                return true;
            }

            public void SwitchToPage(BasePlayer looter, int pageIndex)
            {
                // In case the backpack size permissions changed while open (e.g., a backpack upgrade button).
                EnlargeIfNeeded();

                var itemContainerAdapter = EnsureItemContainerAdapter(pageIndex);
                var itemContainer = itemContainerAdapter.ItemContainer;
                var playerLoot = looter.inventory.loot;
                foreach (var container in playerLoot.containers)
                {
                    container.onDirty -= playerLoot.MarkDirty;
                }

                if (looter.userID == OwnerId)
                {
                    EjectRejectedItemsIfNeeded(looter);

                    // In case the backpack size permissions changed while open.
                    ShrinkIfNeededAndEjectOverflowingItems(looter);
                }

                playerLoot.containers.Clear();
                Interface.CallHook("OnLootEntityEnd", looter, itemContainer.entityOwner);
                Interface.CallHook("OnLootEntity", looter, itemContainer.entityOwner);
                playerLoot.AddContainer(itemContainer);
                playerLoot.SendImmediate();
                ExposedHooks.OnBackpackOpened(looter, OwnerId, itemContainer);
                MaybeCreateContainerUi(looter, GetAllowedCapacityForLooter(looter.userID).PageCount, pageIndex, itemContainerAdapter.Capacity);
            }

            public BasePlayer DetermineFeedbackRecipientIfEligible()
            {
                if (_looters.Count == 0)
                    return null;

                if (TimeSinceLastFeedback < FeedbackThrottleSeconds)
                    return null;

                // Can't know who tried to place the item if there are multiple looters.
                if (_looters.Count > 1)
                    return null;

                return _looters.FirstOrDefault();
            }

            public void OnClosed(BasePlayer looter)
            {
                _looters.Remove(looter);

                if (_uiViewers.Contains(looter))
                {
                    ContainerUi.DestroyUi(looter);
                    _uiViewers.Remove(looter);
                }

                // Clean up the subscription immediately if admin stopped looting.
                // This avoids having to clean up the admin subscriptions some other way which would add complexity.
                if (looter.userID != OwnerId)
                {
                    NetworkController?.Unsubscribe(looter);
                }
            }

            public DroppedItemContainer Drop(Vector3 position, List<DroppedItemContainer> collect = null)
            {
                if (!HasItems)
                    return null;

                var hookResult = ExposedHooks.CanDropBackpack(OwnerId, position);
                if (hookResult is bool && (bool)hookResult == false)
                    return null;

                ForceCloseAllLooters();
                ReclaimItemsForSoftcore();

                // Check again since the items may have all been reclaimed for Softcore.
                if (!HasItems)
                    return null;

                DroppedItemContainer firstContainer = null;

                using (_itemCountChangedEvent.Pause())
                {
                    using (var itemList = DisposableList<Item>.Get())
                    {
                        foreach (var containerAdapter in _containerAdapters)
                        {
                            if (!containerAdapter.HasItems)
                                continue;

                            containerAdapter.TakeAllItems(itemList);
                            var droppedItemContainer = SpawnDroppedBackpack(position, containerAdapter.Capacity, itemList);
                            if (droppedItemContainer == null)
                                break;

                            itemList.Clear();

                            if ((object)firstContainer == null)
                            {
                                firstContainer = droppedItemContainer;
                            }

                            collect?.Add(droppedItemContainer);
                        }

                        if (itemList.Count > 0)
                        {
                            foreach (var item in itemList)
                            {
                                item.Drop(position, UnityEngine.Random.insideUnitSphere, Quaternion.identity);
                            }
                        }
                    }
                }

                return firstContainer;
            }

            public void EraseContents(WipeRuleset wipeRuleset = null, bool force = false)
            {
                // Optimization: If no container and no stored data, don't bother with the rest of the logic.
                var originalItemCount = ItemCount;
                if (originalItemCount == 0)
                    return;

                if (!force)
                {
                    var hookResult = ExposedHooks.CanEraseBackpack(OwnerId);
                    if (hookResult is bool && (bool)hookResult == false)
                        return;
                }

                var wipeContext = new WipeContext();

                using (_itemCountChangedEvent.Pause())
                {
                    foreach (var containerAdapter in _containerAdapters)
                    {
                        containerAdapter.EraseContents(wipeRuleset, ref wipeContext);
                    }
                }

                if (ItemCount != originalItemCount)
                {
                    HandleItemCountChanged();
                }
            }

            public bool SaveIfChanged()
            {
                if (!HasFlag(Flag.Dirty))
                    return false;

                #if DEBUG_BACKPACK_LIFECYCLE
                LogDebug($"Backpack::Save | {OwnerIdString} | Frame: {Time.frameCount.ToString()}");
                #endif

                using (var itemsToReleaseToPool = DisposableList<ItemData>.Get())
                {
                    foreach (var containerAdapter in _containerAdapters)
                    {
                        containerAdapter.SerializeTo(ItemDataCollection, itemsToReleaseToPool);
                    }

                    SerializeRejectedItems(itemsToReleaseToPool);

                    _dataFile.WriteObject(this);
                    SetFlag(Flag.Dirty, false);

                    // After saving, unused ItemData instances can be pooled.
                    PoolUtils.ResetItemsAndClear(itemsToReleaseToPool);
                }

                // Clear the list, but don't reset the items to the pool, since they have been referenced in the container adapters.
                ItemDataCollection.Clear();

                return true;
            }

            public int FetchItems(BasePlayer player, ref ItemQuery itemQuery, int desiredAmount)
            {
                using (var collect = DisposableList<Item>.Get())
                {
                    var amountTaken = TakeItems(ref itemQuery, desiredAmount, collect);

                    if (amountTaken > 0)
                    {
                        PauseGatherMode(1f);

                        foreach (var item in collect)
                        {
                            player.GiveItem(item);
                        }

                        _pauseGatherModeUntilTime = 0;
                    }

                    return amountTaken;
                }
            }

            public void Kill()
            {
                #if DEBUG_BACKPACK_LIFECYCLE
                LogDebug($"Backpack::Kill | OwnerId: {OwnerIdString} | Frame: {Time.frameCount.ToString()}");
                #endif

                ForceCloseAllLooters();

                foreach (var containerAdapter in _containerAdapters)
                {
                    KillContainerAdapter(containerAdapter);
                }

                if (_rejectedItems?.Count > 0)
                {
                    foreach (var item in _rejectedItems)
                    {
                        item.Remove();
                    }

                    _rejectedItems.Clear();
                }

                if (_storageContainer != null && !_storageContainer.IsDestroyed)
                {
                    // Note: The ItemContainer will already be Kill()'d by this point, but that's OK.
                    _storageContainer.Kill();
                }
            }

            public string SerializeContentsAsJson()
            {
                using (var itemsToReleaseToPool = DisposableList<ItemData>.Get())
                {
                    foreach (var containerAdapter in _containerAdapters)
                    {
                        containerAdapter.SerializeTo(ItemDataCollection, itemsToReleaseToPool);
                    }

                    SerializeRejectedItems(itemsToReleaseToPool);

                    var json = JsonConvert.SerializeObject(ItemDataCollection);

                    // After saving, unused ItemData instances can be pooled.
                    PoolUtils.ResetItemsAndClear(itemsToReleaseToPool);

                    // Clear the list, but don't reset the items to the pool, since they have been referenced in the container adapters.
                    ItemDataCollection.Clear();

                    return json;
                }
            }

            public void WriteContentsFromJson(string json)
            {
                var itemDataList = JsonConvert.DeserializeObject<List<ItemData>>(json);

                Kill();

                foreach (var itemData in itemDataList)
                {
                    ItemDataCollection.Add(itemData);
                }

                SetupItemsAndContainers();

                SetFlag(Flag.Dirty, true);
                SaveIfChanged();
            }

            private void CreateContainerAdapters()
            {
                var previousPageIndex = -1;

                // This assumes the collection has been sorted by item position.
                foreach (var itemData in ItemDataCollection)
                {
                    var pageIndex = CalculatePageIndexForItemPosition(itemData.Position);
                    if (pageIndex < previousPageIndex)
                        throw new InvalidOperationException("Found an item for an earlier page while setting up a virtual container. This should not happen.");

                    // Skip items for the previously created page, since creating the page would have copied all items.
                    if (pageIndex == previousPageIndex)
                        continue;

                    // Create an adapter for the page, copying all items.
                    _containerAdapters[pageIndex] = CreateVirtualContainerAdapter(pageIndex)
                        .CopyItemsFrom(ItemDataCollection);

                    previousPageIndex = pageIndex;
                }

                // Clear the list, but don't reset the items to the pool, since they have been referenced in the container adapters.
                ItemDataCollection.Clear();
            }

            private void SetupItemsAndContainers()
            {
                // Sort the items so it's easier to partition the list for multiple pages.
                ItemDataCollection.Sort((a, b) => a.Position.CompareTo(b.Position));

                // Allow the backpack to start beyond the allowed capacity.
                // Overflowing items will be handled when the backpack is opened by its owner.
                var highestUsedPosition = ItemDataCollection.LastOrDefault()?.Position ?? 0;
                ActualCapacity.Capacity = Math.Max(_allowedCapacity.Capacity, highestUsedPosition + 1);

                var pageCount = ActualCapacity.PageCount;
                if (_containerAdapters == null)
                {
                    _containerAdapters = new ContainerAdapterCollection(pageCount);
                }
                else
                {
                    _containerAdapters.Resize(pageCount);
                }

                CreateContainerAdapters();
            }

            private VirtualContainerAdapter CreateVirtualContainerAdapter(int pageIndex)
            {
                return CustomPool.Get<VirtualContainerAdapter>().Setup(this, pageIndex, ActualCapacity.CapacityForPage(pageIndex));
            }

            private ItemContainerAdapter CreateItemContainerAdapter(int pageIndex)
            {
                var container = CreateContainerForPage(pageIndex, ActualCapacity.CapacityForPage(pageIndex));
                return CustomPool.Get<ItemContainerAdapter>().Setup(this, pageIndex, container);
            }

            private ItemContainerAdapter UpgradeToItemContainer(VirtualContainerAdapter virtualContainerAdapter)
            {
                // Must cache the page index since it will be reset when pooled.
                var pageIndex = virtualContainerAdapter.PageIndex;
                var itemContainerAdapter = CreateItemContainerAdapter(pageIndex)
                    .CopyItemsFrom(virtualContainerAdapter.ItemDataList)
                    .AddDelegates();

                CustomPool.Free(ref virtualContainerAdapter);

                _containerAdapters[pageIndex] = itemContainerAdapter;
                return itemContainerAdapter;
            }

            private void SerializeRejectedItems(List<ItemData> itemsToReleaseToPool)
            {
                if (_rejectedItems == null || _rejectedItems.Count == 0)
                    return;

                var lastPosition = ItemDataCollection.LastOrDefault()?.Position ?? 0;

                foreach (var item in _rejectedItems)
                {
                    item.position = ++lastPosition;
                    var itemData = CustomPool.Get<ItemData>().Setup(item);
                    ItemDataCollection.Add(itemData);
                    itemsToReleaseToPool.Add(itemData);
                }
            }

            private void EjectRejectedItemsIfNeeded(BasePlayer receiver)
            {
                if (_rejectedItems == null || _rejectedItems.Count == 0)
                    return;

                foreach (var item in _rejectedItems)
                {
                    receiver.GiveItem(item);
                }

                _rejectedItems.Clear();
                BroadcastItemCountChanged();
                SetFlag(Flag.Dirty, true);

                receiver.ChatMessage(Plugin.GetMessage(receiver, "Backpack Items Rejected"));
            }

            private void EjectRestrictedItemsIfNeeded(BasePlayer receiver)
            {
                if (!Plugin._config.ItemRestrictions.Enabled)
                    return;

                // Optimization: Avoid processing item restrictions every time the backpack is opened.
                if (HasFlag(Flag.ProcessedRestrictedItems))
                    return;

                using (var ejectedItems = DisposableList<Item>.Get())
                {
                    using (_itemCountChangedEvent.Pause())
                    {
                        foreach (var containerAdapter in _containerAdapters)
                        {
                            containerAdapter.TakeRestrictedItems(ejectedItems);
                        }
                    }

                    if (ejectedItems.Count > 0)
                    {
                        foreach (var item in ejectedItems)
                        {
                            receiver.GiveItem(item);
                        }

                        receiver.ChatMessage(Plugin.GetMessage(receiver, "Blacklisted Items Removed"));
                    }
                }

                SetFlag(Flag.ProcessedRestrictedItems, true);
            }

            private void ShrinkIfNeededAndEjectOverflowingItems(BasePlayer overflowRecipient)
            {
                var allowedCapacity = AllowedCapacity;
                if (ActualCapacity <= allowedCapacity)
                    return;

                var allowedLastPageCapacity = allowedCapacity.LastPageCapacity;

                var itemsDroppedOrGivenToPlayer = 0;

                using (var overflowingItems = DisposableList<Item>.Get())
                {
                    var lastAllowedContainerAdapter = _containerAdapters[allowedCapacity.LastPage];
                    if (lastAllowedContainerAdapter != null)
                    {
                        lastAllowedContainerAdapter.TakeAllItems(overflowingItems, allowedLastPageCapacity);
                        lastAllowedContainerAdapter.Capacity = allowedLastPageCapacity;

                        if (allowedLastPageCapacity > 0)
                        {
                            // Try to give the items to the original page first.
                            var lastAllowedItemContainerAdapter = EnsureItemContainerAdapter(allowedCapacity.LastPage);

                            for (var i = 0; i < overflowingItems.Count; i++)
                            {
                                if (overflowingItems[i].MoveToContainer(lastAllowedItemContainerAdapter.ItemContainer))
                                {
                                    overflowingItems.RemoveAt(i--);
                                }
                            }
                        }
                    }

                    for (var i = allowedCapacity.PageCount; i < ActualCapacity.PageCount; i++)
                    {
                        var containerAdapter = _containerAdapters[i];
                        if (containerAdapter == null)
                            continue;

                        containerAdapter.TakeAllItems(overflowingItems);
                        KillContainerAdapter(containerAdapter);
                    }

                    foreach (var item in overflowingItems)
                    {
                        var wasItemAddedToBackpack = false;

                        for (var i = 0; i < allowedCapacity.PageCount; i++)
                        {
                            // Simplification: Make all potential destination containers real containers.
                            var itemContainerAdapter = EnsureItemContainerAdapter(i);
                            if (itemContainerAdapter.TryDepositItem(item))
                            {
                                wasItemAddedToBackpack = true;
                                break;
                            }
                        }

                        if (!wasItemAddedToBackpack)
                        {
                            overflowRecipient.GiveItem(item);
                            itemsDroppedOrGivenToPlayer++;
                        }
                    }
                }

                if (itemsDroppedOrGivenToPlayer > 0)
                {
                    overflowRecipient.ChatMessage(Plugin.GetMessage(overflowRecipient, "Backpack Over Capacity"));
                }

                ActualCapacity = AllowedCapacity;
            }

            private void SetupContainer(ItemContainer container)
            {
                _backpackManager.RegisterContainer(container, this);
            }

            private ItemContainer CreateContainerForPage(int page, int capacity)
            {
                if ((object)_storageContainer == null || _storageContainer.IsDestroyed)
                {
                    _storageContainer = SpawnStorageContainer(0);
                    if ((object)_storageContainer == null)
                        return null;
                }

                if (page == 0)
                {
                    _storageContainer.inventory.capacity = capacity;
                    SetupContainer(_storageContainer.inventory);
                    return _storageContainer.inventory;
                }

                var itemContainer = CreateItemContainer(capacity, _storageContainer);
                SetupContainer(itemContainer);
                return itemContainer;
            }

            private ItemContainerAdapter GetAdapterForContainer(ItemContainer container)
            {
                foreach (var containerAdapter in _containerAdapters)
                {
                    var itemContainerAdapter = containerAdapter as ItemContainerAdapter;
                    if (itemContainerAdapter?.ItemContainer != container)
                        continue;

                    return itemContainerAdapter;
                }

                return null;
            }

            private IContainerAdapter EnsurePage(int pageIndex, bool preferRealContainer = false)
            {
                var containerAdapter = _containerAdapters[pageIndex];
                if (containerAdapter == null)
                {
                    if (preferRealContainer)
                    {
                        containerAdapter = CreateItemContainerAdapter(pageIndex).AddDelegates();
                    }
                    else
                    {
                        containerAdapter = CreateVirtualContainerAdapter(pageIndex);
                    }

                    _containerAdapters[pageIndex] = containerAdapter;
                }

                return containerAdapter;
            }

            private BackpackCapacity GetAllowedCapacityForLooter(ulong looterId)
            {
                return looterId == OwnerId ? AllowedCapacity : ActualCapacity;
            }

            private DroppedItemContainer SpawnDroppedBackpack(Vector3 position, int capacity, List<Item> itemList)
            {
                var entity = GameManager.server.CreateEntity(DroppedBackpackPrefab, position);
                if (entity == null)
                {
                    LogError($"Failed to create entity: {DroppedBackpackPrefab}");
                    return null;
                }

                var droppedItemContainer = entity as DroppedItemContainer;
                if (droppedItemContainer == null)
                {
                    LogError($"Entity is not an instance of DroppedItemContainer: {DroppedBackpackPrefab}");
                    return null;
                }

                droppedItemContainer.gameObject.AddComponent<NoRagdollCollision>();

                droppedItemContainer.lootPanelName = ResizableLootPanelName;
                droppedItemContainer.playerName = $"{FindOwnerPlayer()?.Name ?? "Somebody"}'s Backpack";
                droppedItemContainer.playerSteamID = OwnerId;

                droppedItemContainer.inventory = new ItemContainer();
                droppedItemContainer.inventory.ServerInitialize(null, capacity);
                droppedItemContainer.inventory.GiveUID();
                droppedItemContainer.inventory.entityOwner = droppedItemContainer;
                droppedItemContainer.inventory.SetFlag(ItemContainer.Flag.NoItemInput, true);

                foreach (var item in itemList)
                {
                    if (!item.MoveToContainer(droppedItemContainer.inventory))
                    {
                        item.Remove();
                    }
                }

                droppedItemContainer.Spawn();
                droppedItemContainer.ResetRemovalTime(Math.Max(Plugin._config.MinimumDespawnTime, droppedItemContainer.CalculateRemovalTime()));

                return droppedItemContainer;
            }

            private void EnlargeIfNeeded()
            {
                var allowedCapacity = AllowedCapacity;
                if (ActualCapacity >= allowedCapacity)
                    return;

                var allowedPageCount = allowedCapacity.PageCount;
                if (_containerAdapters.Count < allowedPageCount)
                {
                    _containerAdapters.Resize(allowedPageCount);
                }

                for (var i = 0; i < allowedPageCount; i++)
                {
                    var containerAdapter = _containerAdapters[i];
                    if (containerAdapter == null)
                        continue;

                    var allowedPageCapacity = allowedCapacity.CapacityForPage(i);
                    if (containerAdapter.Capacity < allowedPageCapacity)
                    {
                        containerAdapter.Capacity = allowedPageCapacity;
                    }
                }

                ActualCapacity = AllowedCapacity;
            }

            private void KillContainerAdapter(IContainerAdapter containerAdapter)
            {
                #if DEBUG_BACKPACK_LIFECYCLE
                LogDebug($"Backpack::KillContainerAdapter({typeof(T).Name}) | OwnerId: {OwnerIdString} | PageIndex: {containerAdapter.PageIndex.ToString()} | Capacity: {containerAdapter.Capacity.ToString()} ");
                #endif

                var itemContainerAdapter = containerAdapter as ItemContainerAdapter;
                if (itemContainerAdapter != null)
                {
                    _backpackManager.UnregisterContainer(itemContainerAdapter.ItemContainer);
                }

                containerAdapter.Kill();
                _containerAdapters.RemoveAt(containerAdapter.PageIndex);
                containerAdapter.FreeToPool();
            }

            private void ForceCloseLooter(BasePlayer looter)
            {
                looter.inventory.loot.Clear();
                looter.inventory.loot.MarkDirty();
                looter.inventory.loot.SendImmediate();

                OnClosed(looter);
            }

            private void ForceCloseAllLooters()
            {
                for (var i = _looters.Count - 1; i >= 0; i--)
                {
                    ForceCloseLooter(_looters[i]);
                }
            }

            private StorageContainer SpawnStorageContainer(int capacity)
            {
                var storageEntity = GameManager.server.CreateEntity(CoffinPrefab, new Vector3(0, -500, 0));
                if (storageEntity == null)
                    return null;

                var containerEntity = storageEntity as StorageContainer;
                if (containerEntity == null)
                {
                    UnityEngine.Object.Destroy(storageEntity.gameObject);
                    return null;
                }

                containerEntity.SetFlag(BaseEntity.Flags.Disabled, true);

                UnityEngine.Object.DestroyImmediate(containerEntity.GetComponent<DestroyOnGroundMissing>());
                UnityEngine.Object.DestroyImmediate(containerEntity.GetComponent<GroundWatch>());

                foreach (var collider in containerEntity.GetComponentsInChildren<Collider>())
                    UnityEngine.Object.DestroyImmediate(collider);

                containerEntity.CancelInvoke(containerEntity.DecayTick);

                BackpackCloseListener.AddToBackpackStorage(Plugin, containerEntity, this);

                containerEntity.baseProtection = Plugin._immortalProtection;
                containerEntity.panelName = ResizableLootPanelName;

                // Temporarily disable networking to prevent initially sending the entity to clients based on the positional network group.
                containerEntity._limitedNetworking = true;

                containerEntity.EnableSaving(false);
                containerEntity.Spawn();

                // Must change the network group after spawning,
                // or else vanilla UpdateNetworkGroup will switch it to a positional network group.
                containerEntity.net.SwitchGroup(NetworkController.NetworkGroup);

                // Re-enable networking now that the entity is in the correct network group.
                containerEntity._limitedNetworking = false;

                containerEntity.inventory.allowedContents = ItemContainer.ContentsType.Generic;
                containerEntity.inventory.capacity = capacity;

                return containerEntity;
            }

            private void ReclaimItemsForSoftcore()
            {
                var softcoreGameMode = BaseGameMode.svActiveGameMode as GameModeSoftcore;
                if ((object)softcoreGameMode == null || (object)ReclaimManager.instance == null)
                    return;

                var reclaimFraction = Plugin._config.Softcore.ReclaimFraction;
                if (reclaimFraction <= 0)
                    return;

                using (var allItemsToReclaim = DisposableList<Item>.Get())
                {
                    using (_itemCountChangedEvent.Pause())
                    {
                        foreach (var containerAdapter in _containerAdapters)
                        {
                            containerAdapter.ReclaimFractionForSoftcore(reclaimFraction, allItemsToReclaim);
                        }
                    }

                    if (allItemsToReclaim.Count > 0)
                    {
                        // There's a vanilla issue where accessing the reclaim backpack will erase items in the reclaim entry above 32.
                        // So we just add new reclaim entries which can only be accessed at the terminal to avoid this issue.
                        // Additionally, reclaim entries have a max size, so we may need to create multiple.
                        while (allItemsToReclaim.Count > ReclaimEntryMaxSize)
                        {
                            using (var itemsToReclaimForEntry = DisposableList<Item>.Get())
                            {
                                for (var i = 0; i < ReclaimEntryMaxSize; i++)
                                {
                                    itemsToReclaimForEntry.Add(allItemsToReclaim[i]);
                                    allItemsToReclaim.RemoveAt(i--);
                                }
                                ReclaimManager.instance.AddPlayerReclaim(OwnerId, itemsToReclaimForEntry);
                            }
                        }

                        ReclaimManager.instance.AddPlayerReclaim(OwnerId, allItemsToReclaim);
                    }
                }
            }

            private void SetRetrieveFromPage(int pageIndex, bool retrieve)
            {
                if (pageIndex > 31)
                    return;

                var flag = 1 << pageIndex;

                if (retrieve)
                {
                    RetrieveFromPagesMask |= flag;
                }
                else
                {
                    RetrieveFromPagesMask &= ~flag;
                }

                MarkDirty();
            }

            private void SetGatherModeForPage(int pageIndex, GatherMode gatherMode)
            {
                if (gatherMode == GatherMode.None)
                {
                    GatherModeByPage.Remove(pageIndex);
                }
                else
                {
                    GatherModeByPage[pageIndex] = gatherMode;
                }

                SetFlag(Flag.Dirty, true);
            }

            private void StartGathering(BasePlayer player)
            {
                if (IsGathering)
                    return;

                _inventoryWatcher = InventoryWatcher.AddToPlayer(player, this);
                _subscriberManager.BroadcastGatherChanged(this, true);
            }

            private void StopGathering()
            {
                if (!IsGathering)
                    return;

                _inventoryWatcher.DestroyImmediate();
                _pauseGatherModeUntilTime = 0;
                _subscriberManager.BroadcastGatherChanged(this, false);
            }

            private void BroadcastItemCountChanged()
            {
                _subscriberManager.BroadcastItemCountChanged(this);
            }

            private void MaybeCreateContainerUi(BasePlayer looter, int allowedPageCount, int pageIndex, int containerCapacity)
            {
                if (!CanGather && !CanRetrieve && allowedPageCount <= 1)
                    return;

                ContainerUi.CreateContainerUi(looter, allowedPageCount, pageIndex, containerCapacity, this);

                if (!_uiViewers.Contains(looter))
                {
                    _uiViewers.Add(looter);
                }
            }
        }

        [JsonConverter(typeof(PoolConverter<EntityData>))]
        private class EntityData : CustomPool.IPooled
        {
            [JsonProperty("Flags", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public BaseEntity.Flags Flags;

            [JsonProperty("DataInt", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public int DataInt;

            [JsonProperty("CreatorSteamId", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public ulong CreatorSteamId;

            [JsonProperty("FileContent", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string[] FileContent;

            public void Setup(BaseEntity entity)
            {
                var photoEntity = entity as PhotoEntity;
                if ((object)photoEntity != null)
                {
                    if (photoEntity.ImageCrc == 0)
                        return;

                    var fileContent = FileStorage.server.Get(photoEntity.ImageCrc, FileStorage.Type.jpg, entity.net.ID);
                    if (fileContent == null)
                        return;

                    CreatorSteamId = photoEntity.PhotographerSteamId;
                    FileContent = new[] { Convert.ToBase64String(fileContent) };
                    return;
                }

                var signContent = entity as SignContent;
                if ((object)signContent != null)
                {
                    var imageIdList = signContent.GetContentCRCs;

                    var hasContent = false;
                    foreach (var imageId in imageIdList)
                    {
                        if (imageId != 0)
                        {
                            hasContent = true;
                            break;
                        }
                    }

                    if (!hasContent)
                        return;

                    FileContent = new string[imageIdList.Length];

                    for (var i = 0; i < imageIdList.Length; i++)
                    {
                        var imageId = imageIdList[i];
                        if (imageId == 0)
                            continue;

                        var fileContent = FileStorage.server.Get(imageId, FileStorage.Type.png, entity.net.ID);
                        if (fileContent == null)
                            continue;

                        FileContent[i] = Convert.ToBase64String(fileContent);
                    }

                    return;
                }

                var paintedItemStorageEntity = entity as PaintedItemStorageEntity;
                if ((object)paintedItemStorageEntity != null)
                {
                    if (paintedItemStorageEntity._currentImageCrc == 0)
                        return;

                    var fileContent = FileStorage.server.Get(paintedItemStorageEntity._currentImageCrc, FileStorage.Type.png, entity.net.ID);
                    if (fileContent == null)
                        return;

                    FileContent = new[] { Convert.ToBase64String(fileContent) };
                    return;
                }

                var cassette = entity as Cassette;
                if ((object)cassette != null)
                {
                    DataInt = cassette.preloadedAudioId;

                    if (cassette.AudioId == 0)
                        return;

                    var fileContent = FileStorage.server.Get(cassette.AudioId, FileStorage.Type.ogg, entity.net.ID);
                    if (fileContent == null)
                        return;

                    CreatorSteamId = cassette.CreatorSteamId;
                    FileContent = new[] { Convert.ToBase64String(fileContent) };
                    return;
                }

                var pagerEntity = entity as PagerEntity;
                if ((object)pagerEntity != null)
                {
                    Flags = pagerEntity.flags;
                    DataInt = pagerEntity.GetFrequency();
                    return;
                }

                var mobileInventoryEntity = entity as MobileInventoryEntity;
                if ((object)mobileInventoryEntity != null)
                {
                    Flags = mobileInventoryEntity.flags;
                    return;
                }

                LogWarning($"Unable to serialize associated entity of type {entity.GetType()}.");
            }

            public void EnterPool()
            {
                #if DEBUG_POOLING
                LogDebug($"EntityData::EnterPool | {CustomPool.GetStats<EntityData>()}");
                #endif

                Flags = 0;
                DataInt = 0;
                CreatorSteamId = 0;
                FileContent = null;
            }

            public void LeavePool()
            {
                #if DEBUG_POOLING
                LogDebug($"EntityData::LeavePool | {CustomPool.GetStats<EntityData>()}");
                #endif
            }

            public void UpdateAssociatedEntity(Item item)
            {
                BaseEntity entity;

                var entityId = item.instanceData?.subEntity ?? new NetworkableId(0);
                if (entityId.Value == 0)
                {
                    var itemModSign = item.info.GetComponent<ItemModSign>();
                    if (itemModSign == null)
                        return;

                    entity = itemModSign.CreateAssociatedEntity(item);
                }
                else
                {
                    entity = BaseNetworkable.serverEntities.Find(entityId) as BaseEntity;
                    if (entity == null)
                        return;
                }

                var photoEntity = entity as PhotoEntity;
                if ((object)photoEntity != null)
                {
                    var fileContent = FileContent?.FirstOrDefault();
                    if (fileContent == null)
                        return;

                    photoEntity.SetImageData(CreatorSteamId, Convert.FromBase64String(fileContent));
                    return;
                }

                var signContent = entity as SignContent;
                if ((object)signContent != null)
                {
                    if (FileContent == null)
                        return;

                    for (uint i = 0; i < FileContent.Length && i < signContent.GetContentCRCs.Length; i++)
                    {
                        var fileContent = FileContent[i];
                        if (fileContent == null)
                            continue;

                        signContent.GetContentCRCs[i] = FileStorage.server.Store(Convert.FromBase64String(fileContent), FileStorage.Type.png, entity.net.ID, i);
                    }
                    return;
                }

                var paintedItemStorageEntity = entity as PaintedItemStorageEntity;
                if ((object)paintedItemStorageEntity != null)
                {
                    var fileContent = FileContent?.FirstOrDefault();
                    if (fileContent == null)
                        return;

                    paintedItemStorageEntity._currentImageCrc = FileStorage.server.Store(Convert.FromBase64String(fileContent), FileStorage.Type.png, entity.net.ID);
                    return;
                }

                var cassette = entity as Cassette;
                if ((object)cassette != null)
                {
                    cassette.preloadedAudioId = DataInt;

                    var fileContent = FileContent?.FirstOrDefault();
                    if (fileContent == null)
                        return;

                    var audioId = FileStorage.server.Store(Convert.FromBase64String(fileContent), FileStorage.Type.ogg, entity.net.ID);
                    cassette.SetAudioId(audioId, CreatorSteamId);
                    return;
                }

                var pagerEntity = entity as PagerEntity;
                if ((object)pagerEntity != null)
                {
                    pagerEntity.flags |= Flags;
                    pagerEntity.ChangeFrequency(DataInt);
                    return;
                }

                var mobileInventoryEntity = entity as MobileInventoryEntity;
                if ((object)mobileInventoryEntity != null)
                {
                    mobileInventoryEntity.flags |= Flags;
                    return;
                }
            }
        }

        [JsonConverter(typeof(PoolConverter<ItemData>))]
        private class ItemData : CustomPool.IPooled
        {
            [JsonProperty("ID")]
            public int ID { get; private set; }

            [JsonProperty("Position")]
            public int Position { get; set; } = -1;

            [JsonProperty("Amount")]
            public int Amount { get; private set; }

            [JsonProperty("IsBlueprint", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private bool IsBlueprint;

            [JsonProperty("BlueprintTarget", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public int BlueprintTarget { get; private set; }

            [JsonProperty("Skin", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public ulong Skin { get; private set; }

            [JsonProperty("Fuel", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private float Fuel;

            [JsonProperty("FlameFuel", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private int FlameFuel;

            [JsonProperty("Condition", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public float Condition { get; private set; }

            [JsonProperty("MaxCondition", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public float MaxCondition { get; private set; } = -1;

            [JsonProperty("Ammo", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private int Ammo;

            [JsonProperty("AmmoType", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private int AmmoType;

            [JsonProperty("DataInt", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public int DataInt { get; private set; }

            [JsonProperty("Name", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string Name { get; private set; }

            [JsonProperty("Text", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private string Text;

            [JsonProperty("Flags", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public Item.Flag Flags { get; private set; }

            [JsonProperty("EntityData", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public EntityData EntityData { get; private set; }

            [JsonProperty("Contents", DefaultValueHandling = DefaultValueHandling.Ignore)]
            [JsonConverter(typeof(PoolListConverter<ItemData>))]
            public List<ItemData> Contents { get; private set; }

            public ItemData Setup(Item item, int positionOffset = 0)
            {
                #if DEBUG_POOLING
                LogDebug($"ItemData::Setup | {item.amount.ToString()} {item.info.shortname}");
                #endif

                var heldEntity = item.GetHeldEntity();

                ID = item.info.itemid;
                Position = item.position + positionOffset;
                Amount = item.amount;
                IsBlueprint = item.IsBlueprint();
                BlueprintTarget = item.blueprintTarget;
                Skin = item.skin;
                Fuel = item.fuel;
                FlameFuel = heldEntity?.GetComponent<FlameThrower>()?.ammo ?? 0;
                Condition = item.condition;
                MaxCondition = item.maxCondition;
                Ammo = heldEntity?.GetComponent<BaseProjectile>()?.primaryMagazine?.contents ?? 0;
                AmmoType = heldEntity?.GetComponent<BaseProjectile>()?.primaryMagazine?.ammoType?.itemid ?? 0;
                DataInt = item.instanceData?.dataInt ?? 0;
                Name = item.name;
                Text = item.text;
                Flags = item.flags;

                var subEntityId = item.instanceData?.subEntity ?? new NetworkableId(0);
                if (subEntityId.Value != 0)
                {
                    var subEntity = BaseNetworkable.serverEntities.Find(subEntityId) as BaseEntity;
                    if (subEntity != null)
                    {
                        if (EntityData == null)
                        {
                            EntityData = CustomPool.Get<EntityData>();
                        }
                        EntityData.Setup(subEntity);
                    }
                }

                if (item.contents != null)
                {
                    Contents = CustomPool.GetList<ItemData>();
                    foreach (var childItem in item.contents.itemList)
                    {
                        Contents.Add(CustomPool.Get<ItemData>().Setup(childItem));
                    }
                }

                return this;
            }

            public void EnterPool()
            {
                #if DEBUG_POOLING
                LogDebug($"ItemData::EnterPool | {Amount.ToString()} {ItemManager.FindItemDefinition(ID)?.shortname ?? ID.ToString()} | {CustomPool.GetStats<ItemData>()}");
                #endif

                ID = 0;
                Position = 0;
                Amount = 0;
                IsBlueprint = false;
                BlueprintTarget = 0;
                Skin = 0;
                Fuel = 0;
                FlameFuel = 0;
                Condition = 0;
                MaxCondition = 0;
                Ammo = 0;
                AmmoType = 0;
                DataInt = 0;
                Name = null;
                Text = null;
                Flags = 0;

                if (EntityData != null)
                {
                    var entityData = EntityData;
                    CustomPool.Free(ref entityData);
                    EntityData = null;
                }

                if (Contents != null)
                {
                    PoolUtils.ResetItemsAndClear(Contents);
                    var contents = Contents;
                    CustomPool.FreeList(ref contents);
                    Contents = null;
                }
            }

            public void LeavePool()
            {
                #if DEBUG_POOLING
                LogDebug($"ItemData::LeavePool | {CustomPool.GetStats<ItemData>()}");
                #endif
            }

            public void Reduce(int amount)
            {
                Amount -= amount;
            }

            public Item ToItem(int amount = -1)
            {
                if (amount == -1)
                {
                    amount = Amount;
                }

                if (amount == 0)
                    return null;

                var item = ItemManager.CreateByItemID(ID, amount, Skin);
                if (item == null)
                    return null;

                item.position = Position % _maxCapacityPerPage;

                if (IsBlueprint)
                {
                    item.blueprintTarget = BlueprintTarget;
                    return item;
                }

                item.fuel = Fuel;
                item.condition = Condition;

                if (MaxCondition != -1)
                {
                    item.maxCondition = MaxCondition;
                }

                if (Name != null)
                {
                    item.name = Name;
                }

                if (amount == Amount && Contents?.Count > 0)
                {
                    if (item.contents == null)
                    {
                        item.contents = new ItemContainer();
                        item.contents.ServerInitialize(null, Contents.Count);
                        item.contents.GiveUID();
                        item.contents.parent = item;
                    }
                    else
                    {
                        item.contents.capacity = Math.Max(item.contents.capacity, Contents.Count);
                    }

                    foreach (var contentItem in Contents)
                    {
                        var childItem = contentItem.ToItem();
                        if (childItem == null)
                            continue;

                        if (!childItem.MoveToContainer(item.contents, childItem.position)
                            && !childItem.MoveToContainer(item.contents))
                        {
                            childItem.Remove();
                        }
                    }
                }

                item.flags |= Flags;

                var heldEntity = item.GetHeldEntity();
                var magazine = (heldEntity as BaseProjectile)?.primaryMagazine;
                if (magazine != null && AmmoType != 0)
                {
                    magazine.contents = Ammo;
                    magazine.ammoType = ItemManager.FindItemDefinition(AmmoType) ?? magazine.ammoType;
                }

                var flameThrower = heldEntity as FlameThrower;
                if ((object)flameThrower != null)
                {
                    flameThrower.ammo = FlameFuel;
                }

                if (DataInt > 0)
                {
                    item.instanceData = new ProtoBuf.Item.InstanceData
                    {
                        ShouldPool = false,
                        dataInt = DataInt,
                    };

                    var detonator = heldEntity as Detonator;
                    if ((object)detonator != null)
                    {
                        detonator.frequency = DataInt;
                    }
                }

                item.text = Text;

                EntityData?.UpdateAssociatedEntity(item);

                return item;
            }
        }

        #endregion

        #region Stored Data

        [JsonObject(MemberSerialization.OptIn)]
        private class StoredData
        {
            public static StoredData Load()
            {
                var data = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(nameof(Backpacks));
                if (data == null)
                {
                    LogWarning($"Data file {nameof(Backpacks)}.json is invalid. Creating new data file.");
                    data = new StoredData { _dirty = true };
                    data.SaveIfChanged();
                }
                return data;
            }

            [JsonProperty("PlayersWithDisabledGUI")]
            private HashSet<ulong> DeprecatedPlayersWithDisabledGUI
            {
                set
                {
                    foreach (var playerId in value)
                    {
                        EnabledGuiPreference[playerId] = false;
                    }
                }
            }

            [JsonProperty("PlayerGuiPreferences")]
            private Dictionary<ulong, bool> EnabledGuiPreference = new Dictionary<ulong, bool>();

            [JsonIgnore]
            private bool _dirty;

            public bool? GetGuiButtonPreference(ulong userId)
            {
                bool guiEnabled;
                return EnabledGuiPreference.TryGetValue(userId, out guiEnabled)
                    ? guiEnabled as bool?
                    : null;
            }

            public bool ToggleGuiButtonPreference(ulong userId, bool defaultEnabled)
            {
                var enabledNow = !(GetGuiButtonPreference(userId) ?? defaultEnabled);
                EnabledGuiPreference[userId] = enabledNow;
                _dirty = true;
                return enabledNow;
            }

            public bool SaveIfChanged()
            {
                if (!_dirty)
                    return false;

                Interface.Oxide.DataFileSystem.WriteObject(nameof(Backpacks), this);
                _dirty = false;
                return true;
            }
        }

        #endregion

        #region Configuration

        [JsonObject(MemberSerialization.OptIn)]
        private abstract class BaseItemRuleset
        {
            [JsonIgnore]
            protected abstract string PermissionPrefix { get; }

            [JsonProperty("Name", Order = -2, DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string Name;

            [JsonProperty("Allowed item categories")]
            public string[] AllowedItemCategoryNames = Array.Empty<string>();

            [JsonProperty("Disallowed item categories")]
            public string[] DisallowedItemCategoryNames = Array.Empty<string>();

            [JsonProperty("Allowed item short names")]
            public string[] AllowedItemShortNames = Array.Empty<string>();

            [JsonProperty("Disallowed item short names")]
            public string[] DisallowedItemShortNames = Array.Empty<string>();

            [JsonProperty("Allowed skin IDs")]
            public HashSet<ulong> AllowedSkinIds = new HashSet<ulong>();

            [JsonProperty("Disallowed skin IDs")]
            public HashSet<ulong> DisallowedSkinIds = new HashSet<ulong>();

            [JsonIgnore]
            protected ItemCategory[] _allowedItemCategories;

            [JsonIgnore]
            protected ItemCategory[] _disallowedItemCategories;

            [JsonIgnore]
            protected HashSet<int> _allowedItemIds = new HashSet<int>();

            [JsonIgnore]
            protected HashSet<int> _disallowedItemIds = new HashSet<int>();

            [JsonIgnore]
            public string Permission { get; protected set; }

            [JsonIgnore]
            public bool AllowsAll { get; protected set; }

            public void Init(Backpacks plugin)
            {
                if (!string.IsNullOrWhiteSpace(Name))
                {
                    Permission = $"{nameof(Backpacks)}.{PermissionPrefix}.{Name}".ToLower();
                    plugin.permission.RegisterPermission(Permission, plugin);
                }

                var errorFormat = "Invalid item category in config: {0}";
                _allowedItemCategories = ParseEnumList<ItemCategory>(AllowedItemCategoryNames, errorFormat);
                _disallowedItemCategories = ParseEnumList<ItemCategory>(DisallowedItemCategoryNames, errorFormat);

                foreach (var itemShortName in AllowedItemShortNames)
                {
                    var itemDefinition = ItemManager.FindItemDefinition(itemShortName);
                    if (itemDefinition != null)
                    {
                        _allowedItemIds.Add(itemDefinition.itemid);
                    }
                    else
                    {
                        LogError($"Invalid item short name in config: {itemShortName}");
                    }
                }

                foreach (var itemShortName in DisallowedItemShortNames)
                {
                    var itemDefinition = ItemManager.FindItemDefinition(itemShortName);
                    if (itemDefinition != null)
                    {
                        _disallowedItemIds.Add(itemDefinition.itemid);
                    }
                    else
                    {
                        LogError($"Invalid item short name in config: {itemShortName}");
                    }
                }

                if (_allowedItemCategories.Contains(ItemCategory.All)
                    && _disallowedItemCategories.Length == 0
                    && _disallowedItemIds.Count == 0
                    && DisallowedSkinIds.Count == 0)
                {
                    AllowsAll = true;
                }
            }

            public bool AllowsItem(Item item)
            {
                // Optimization: Skip all checks if all items are allowed.
                if (AllowsAll)
                    return true;

                if (DisallowedSkinIds.Contains(item.skin))
                    return false;

                if (AllowedSkinIds.Contains(item.skin))
                    return true;

                if (_disallowedItemIds.Contains(item.info.itemid))
                    return false;

                if (_allowedItemIds.Contains(item.info.itemid))
                    return true;

                if (_disallowedItemCategories.Contains(item.info.category))
                    return false;

                if (_allowedItemCategories.Contains(item.info.category))
                    return true;

                return _allowedItemCategories.Contains(ItemCategory.All);
            }

            public bool AllowsItem(ItemData itemData)
            {
                // Optimization: Skip all checks if all items are allowed.
                if (AllowsAll)
                    return true;

                if (DisallowedSkinIds.Contains(itemData.Skin))
                    return false;

                if (AllowedSkinIds.Contains(itemData.Skin))
                    return true;

                if (_disallowedItemIds.Contains(itemData.ID))
                    return false;

                if (_allowedItemIds.Contains(itemData.ID))
                    return true;

                // Optimization: Skip looking up the ItemDefinition if all categories are allowed.
                if (_allowedItemCategories.Contains(ItemCategory.All) && _disallowedItemCategories.Length == 0)
                    return true;

                var itemDefinition = ItemManager.FindItemDefinition(itemData.ID);
                if ((object)itemDefinition == null)
                    return true;

                if (_disallowedItemCategories.Contains(itemDefinition.category))
                    return false;

                if (_allowedItemCategories.Contains(itemDefinition.category))
                    return true;

                return _allowedItemCategories.Contains(ItemCategory.All);
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class RestrictionRuleset : BaseItemRuleset
        {
            private const string PartialPermissionPrefix = "restrictions";

            public static readonly string FullPermissionPrefix = $"{nameof(Backpacks)}.{PartialPermissionPrefix}".ToLower();

            public static readonly RestrictionRuleset AllowAll = new RestrictionRuleset { AllowsAll = true };

            protected override string PermissionPrefix => PartialPermissionPrefix;
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class RestrictionOptions
        {
            [JsonProperty("Enabled")]
            public bool Enabled;

            [JsonProperty("Enable legacy noblacklist permission")]
            public bool EnableLegacyPermission;

            [JsonProperty("Feedback effect")]
            public string FeedbackEffect = "assets/prefabs/locks/keypad/effects/lock.code.denied.prefab";

            [JsonProperty("Default ruleset")]
            public RestrictionRuleset DefaultRuleset = new RestrictionRuleset
            {
                AllowedItemCategoryNames = new[] { ItemCategory.All.ToString() }
            };

            [JsonProperty("Rulesets by permission")]
            public RestrictionRuleset[] RulesetsByPermission =
            {
                new RestrictionRuleset
                {
                    Name = "allowall",
                    AllowedItemCategoryNames = new [] { ItemCategory.All.ToString() },
                },
            };

            [JsonIgnore]
            private Permission _permission;

            public void Init(Backpacks plugin)
            {
                _permission = plugin.permission;

                if (EnableLegacyPermission)
                {
                    _permission.RegisterPermission(LegacyNoBlacklistPermission, plugin);
                }

                DefaultRuleset.Init(plugin);

                foreach (var ruleset in RulesetsByPermission)
                {
                    ruleset.Init(plugin);
                }
            }

            public RestrictionRuleset GetForPlayer(string userIdString)
            {
                if (EnableLegacyPermission && _permission.UserHasPermission(userIdString, LegacyNoBlacklistPermission))
                    return RestrictionRuleset.AllowAll;

                for (var i = RulesetsByPermission.Length - 1; i >= 0; i--)
                {
                    var ruleset = RulesetsByPermission[i];
                    if (ruleset.Permission != null && _permission.UserHasPermission(userIdString, ruleset.Permission))
                        return ruleset;
                }

                return DefaultRuleset;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class WipeRuleset : BaseItemRuleset
        {
            public static readonly WipeRuleset AllowAll = new WipeRuleset
            {
                MaxSlotsToKeep = -1,
                AllowsAll = true
            };

            [JsonIgnore]
            protected override string PermissionPrefix => "keeponwipe";

            [JsonProperty("Max slots to keep")]
            public int MaxSlotsToKeep;

            [JsonIgnore]
            public bool DisallowsAll
            {
                get
                {
                    if (AllowsAll)
                        return false;

                    if (MaxSlotsToKeep == 0)
                        return true;

                    return _allowedItemCategories.Length == 0
                       && _allowedItemIds.Count == 0
                       && AllowedSkinIds.Count == 0;
                }
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class WipeOptions
        {
            [JsonProperty("Enabled")]
            public bool Enabled;

            [JsonProperty("Enable legacy keeponwipe permission")]
            public bool EnableLegacyPermission;

            [JsonProperty("Default ruleset")]
            public WipeRuleset DefaultRuleset = new WipeRuleset();

            [JsonProperty("Rulesets by permission")]
            public WipeRuleset[] RulesetsByPermission =
            {
                new WipeRuleset
                {
                    Name = "all",
                    MaxSlotsToKeep = -1,
                    AllowedItemCategoryNames = new [] { ItemCategory.All.ToString() },
                },
            };

            [JsonIgnore]
            private Permission _permission;

            public void Init(Backpacks plugin)
            {
                _permission = plugin.permission;

                if (EnableLegacyPermission)
                {
                    _permission.RegisterPermission(LegacyKeepOnWipePermission, plugin);
                }

                DefaultRuleset.Init(plugin);

                foreach (var ruleset in RulesetsByPermission)
                {
                    ruleset.Init(plugin);
                }
            }

            public WipeRuleset GetForPlayer(string userIdString)
            {
                if (EnableLegacyPermission && _permission.UserHasPermission(userIdString, LegacyKeepOnWipePermission))
                    return WipeRuleset.AllowAll;

                for (var i = RulesetsByPermission.Length - 1; i >= 0; i--)
                {
                    var ruleset = RulesetsByPermission[i];
                    if (ruleset.Permission != null && _permission.UserHasPermission(userIdString, ruleset.Permission))
                        return ruleset;
                }

                return DefaultRuleset;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class BackpackSizeOptions
        {
            [JsonProperty("Default size")]
            public int DefaultSize = 6;

            [JsonProperty("Max size per page")]
            public int MaxCapacityPerPage = 48;

            [JsonProperty("Enable legacy backpacks.use.1-8 row permissions")]
            public bool EnableLegacyRowPermissions;

            [JsonProperty("Permission sizes")]
            public int[] PermissionSizes = { 6, 12, 18, 24, 30, 36, 42, 48, 96, 144 };
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class ContainerUiOptions
        {
            [JsonProperty("Show page buttons on container bar")]
            public bool ShowPageButtonsOnContainerBar;
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class Configuration : BaseConfiguration
        {
            [JsonProperty("Backpack size")]
            public BackpackSizeOptions BackpackSize = new BackpackSizeOptions();

            [JsonProperty("Backpack Size (1-8 Rows)")]
            private int DeprecatedBackpackRows
            {
                set
                {
                    BackpackSize.DefaultSize = value * 6;
                    BackpackSize.EnableLegacyRowPermissions = true;
                }
            }

            [JsonProperty("Backpack Size (1-7 Rows)")]
            private int DeprecatedBackpackSize
            {
                set
                {
                    BackpackSize.DefaultSize = value * 6;
                    BackpackSize.EnableLegacyRowPermissions = true;
                }
            }

            // Backwards compatibility for 3.8+ pre-releases.
            [JsonProperty("Default Backpack Size")]
            private int DeprecatedDefaultBackpackSize { set { BackpackSize.DefaultSize = value; } }

            // Backwards compatibility for 3.8+ pre-releases.
            [JsonProperty("Max Size Per Page")]
            private int DeprecatedMaxSizePerPage { set { BackpackSize.MaxCapacityPerPage = value; } }

            // Backwards compatibility for 3.8+ pre-releases.
            [JsonProperty("Backpack Permission Sizes")]
            private int[] DeprecatedPermissionSizes { set { BackpackSize.PermissionSizes = value; } }

            // Backwards compatibility for 3.8+ pre-releases.
            [JsonProperty("Enable Legacy Row Permissions (true/false)")]
            private bool EnableLegacyRowPermissions { set { BackpackSize.EnableLegacyRowPermissions = value; } }

            [JsonProperty("Drop on Death (true/false)")]
            public bool DropOnDeath = true;

            [JsonProperty("Erase on Death (true/false)")]
            public bool EraseOnDeath = false;

            [JsonProperty("Clear Backpacks on Map-Wipe (true/false)")]
            public bool DeprecatedClearBackpacksOnWipe;

            public bool ShouldSerializeDeprecatedClearBackpacksOnWipe() => false;

            [JsonProperty("Use Blacklist (true/false)")]
            public bool DeprecatedUseDenylist;

            public bool ShouldSerializeDeprecatedUseDenylist() => false;

            [JsonProperty("Blacklisted Items (Item Shortnames)")]
            public string[] DeprecatedDenylistItemShortNames;

            public bool ShouldSerializeDeprecatedDenylistItemShortNames() => false;

            [JsonProperty("Use Whitelist (true/false)")]
            public bool DeprecatedUseAllowlist;

            public bool ShouldSerializeDeprecatedUseAllowlist() => false;

            [JsonProperty("Whitelisted Items (Item Shortnames)")]
            public string[] DeprecatedAllowedItemShortNames;

            public bool ShouldSerializeDeprecatedAllowedItemShortNames() => false;

            [JsonProperty("Minimum Despawn Time (Seconds)")]
            public float MinimumDespawnTime = 300;

            [JsonProperty("GUI Button")]
            public GUIButton GUI = new GUIButton();

            [JsonProperty("Container UI")]
            public ContainerUiOptions ContainerUi = new ContainerUiOptions();

            [JsonProperty("Softcore")]
            public SoftcoreOptions Softcore = new SoftcoreOptions();

            [JsonProperty("Item restrictions")]
            public RestrictionOptions ItemRestrictions = new RestrictionOptions();

            [JsonProperty("Clear on wipe")]
            public WipeOptions ClearOnWipe = new WipeOptions();

            public class GUIButton
            {
                [JsonProperty("Enabled")]
                public bool Enabled = true;

                [JsonProperty("Enabled by default (for players with permission)")]
                public bool EnabledByDefault = true;

                [JsonProperty("Skin Id")]
                public ulong SkinId;

                [JsonProperty("Image")]
                public string Image = "https://i.imgur.com/T6orn2Q.png";

                [JsonProperty("Background Color")]
                public string Color = "0.969 0.922 0.882 0.035";

                [JsonProperty("GUI Button Position")]
                public Position GUIButtonPosition = new Position();

                public class Position
                {
                    [JsonProperty("Anchors Min")]
                    public string AnchorsMin = "0.5 0.0";

                    [JsonProperty("Anchors Max")]
                    public string AnchorsMax = "0.5 0.0";

                    [JsonProperty("Offsets Min")]
                    public string OffsetsMin = "185 18";

                    [JsonProperty("Offsets Max")]
                    public string OffsetsMax = "245 78";
                }
            }

            public class SoftcoreOptions
            {
                [JsonProperty("Reclaim Fraction")]
                public float ReclaimFraction = 0.5f;
            }

            public void Init(Backpacks plugin)
            {
                ItemRestrictions.Init(plugin);
                ClearOnWipe.Init(plugin);
            }
        }

        private Configuration GetDefaultConfig() => new Configuration();

        #region Configuration Helpers

        [JsonObject(MemberSerialization.OptIn)]
        private class BaseConfiguration
        {
            public bool UsingDefaults = false;

            private string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(BaseConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigSection(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigSection(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            bool changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigSection(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                var changed = MaybeUpdateConfig(_config);

                if (_config.DeprecatedUseAllowlist || _config.DeprecatedUseDenylist)
                {
                    changed = true;

                    _config.ItemRestrictions.Enabled = true;
                    _config.ItemRestrictions.EnableLegacyPermission = true;

                    if (_config.DeprecatedUseAllowlist)
                    {
                        _config.ItemRestrictions.DefaultRuleset.AllowedItemCategoryNames = Array.Empty<string>();
                        _config.ItemRestrictions.DefaultRuleset.AllowedItemShortNames = _config.DeprecatedAllowedItemShortNames;
                    }
                    else if (_config.DeprecatedUseDenylist)
                    {
                        _config.ItemRestrictions.DefaultRuleset.DisallowedItemShortNames = _config.DeprecatedDenylistItemShortNames;
                    }
                }

                if (_config.DeprecatedClearBackpacksOnWipe)
                {
                    changed = true;

                    _config.ClearOnWipe.Enabled = true;
                    _config.ClearOnWipe.EnableLegacyPermission = true;
                }

                if (_config.GUI.Image == "https://i.imgur.com/CyF0QNV.png")
                {
                    _config.GUI.Image = "https://i.imgur.com/T6orn2Q.png";
                    changed = true;
                }

                if (changed)
                {
                    PrintWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                PrintError(e.Message);
                PrintWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
                _config.UsingDefaults = true;
            }
        }

        protected override void SaveConfig()
        {
            Puts($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #endregion

        #region Localization

        private string GetMessage(string playerId, string langKey) =>
            lang.GetMessage(langKey, this, playerId);

        private string GetMessage(IPlayer player, string langKey) =>
            GetMessage(player.Id, langKey);

        private string GetMessage(BasePlayer basePlayer, string langKey) =>
            GetMessage(basePlayer.UserIDString, langKey);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["No Permission"] = "You don't have permission to use this command.",
                ["May Not Open Backpack In Event"] = "You may not open a backpack while participating in an event!",
                ["View Backpack Syntax"] = "Syntax: /viewbackpack <name or id>",
                ["User ID not Found"] = "Could not find player with ID '{0}'",
                ["User Name not Found"] = "Could not find player with name '{0}'",
                ["Multiple Players Found"] = "Multiple matching players found:\n{0}",
                ["Backpack Item Rejected"] = "That item is not allowed in the backpack.",
                ["Backpack Items Rejected"] = "Your backpack rejected some items. They have been added to your inventory or dropped.",
                ["Backpack Over Capacity"] = "Your backpack was over capacity. Overflowing items were added to your inventory or dropped.",
                ["Blacklisted Items Removed"] = "Your backpack contained blacklisted items. They have been added to your inventory or dropped.",
                ["Backpack Fetch Syntax"] = "Syntax: backpack.fetch <item short name or id> <amount>",
                ["Invalid Item"] = "Invalid Item Name or ID.",
                ["Invalid Item Amount"] = "Item amount must be an integer greater than 0.",
                ["Item Not In Backpack"] = "Item \"{0}\" not found in backpack.",
                ["Items Fetched"] = "Fetched {0} \"{1}\" from backpack.",
                ["Fetch Failed"] = "Couldn't fetch \"{0}\" from backpack. Inventory may be full.",
                ["Toggled Backpack GUI"] = "Toggled backpack GUI button.",
                ["UI - Gather All"] = "Gather: All â",
                ["UI - Gather Existing"] = "Gather: Existing â",
                ["UI - Gather Off"] = "Gather: Off",
                ["UI - Retrieve On"] = "Retrieve: On â",
                ["UI - Retrieve Off"] = "Retrieve: Off"
            }, this);
        }

        #endregion
    }
}


// --- End of file: Backpacks.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/RemoveUpgradeV2.cs ---
// --- Original Local Path: BeeRust/RemoveUpgradeV2.cs ---

using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using System.Text.RegularExpressions;

///Ð¡ÐºÐ°ÑÐ°Ð½Ð¾ Ñ Ð´Ð¸ÑÐºÐ¾ÑÐ´ ÑÐµÑÐ²ÐµÑÐ° Rust Edit [PRO+]
///discord.gg/9vyTXsJyKR

namespace Oxide.Plugins
{
    [Info("RemoveUpgradeV2", "discord.gg/9vyTXsJyKR", "1.0.3")]
    [Description("ÐÐÐ¢ÐÐÐÐÐÐ ÐÐÐÐ! ÐÑÑÑÐ¸Ð¹ Ð¿Ð»Ð°Ð³Ð¸Ð½ Ð´Ð»Ñ ÑÐµÐ¼ÑÐ²Ð° Ð¸ Ð°Ð¿Ð³ÑÐµÐ¹Ð´Ð° Ð¿Ð¾ÑÑÑÐ¾ÐµÐº")]
    class RemoveUpgradeV2 : RustPlugin
    {
        #region Config
        private PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }
        private class PluginConfig
        {
            [JsonProperty("Ð Ð°Ð·ÑÐµÑÐ¸ÑÑ ÑÐµÐ¼ÑÐ²Ð°ÑÑ Ð¿Ð¾ÑÑÑÐ¾Ð¹ÐºÐ¸ Ð´ÑÑÐ·ÑÑÐ¼")]
            public bool friends;

            [JsonProperty("Ð Ð°Ð·ÑÐµÑÐ¸ÑÑ Ð»Ð¾Ð¼Ð°ÑÑ Ð¿Ð¾ÑÑÑÐ¾Ð¹ÐºÐ¸ Ð°Ð²ÑÐ¾ÑÐ¸Ð·Ð¾Ð²Ð°Ð½ÑÐ¼ Ð² ÑÐºÐ°ÑÑ")]
            public bool cupboard;

            [JsonProperty("ÐÑÐºÐ»ÑÑÐ¸ÑÑ GUI?")]
            public bool disablegui;

            [JsonProperty("ÐÑÐµÐ¼Ñ Ð´ÐµÐ¹ÑÑÐ²Ð¸Ñ ÑÐµÐ¼ÑÐ²Ð°/Ð°Ð¿Ð³ÑÐµÐ¹Ð´Ð°")]
            public int time;

            [JsonProperty("ÐÑÐ¾ÑÐµÐ½Ñ Ð²Ð¾Ð·Ð²ÑÐ°ÑÐ°ÐµÐ¼ÑÑ ÑÐµÑÑÑÑÐ¾Ð² Ñ Ð¿Ð¾ÑÑÑÐ¾ÐµÐº")]
            public float procent;

            [JsonProperty("Ð Ð°ÑÐ¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ GUI - AnchorMin")]
            public string AnchorMin;

            [JsonProperty("Ð Ð°ÑÐ¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ GUI - AnchorMax")]
            public string AnchorMax;

            [JsonProperty("ÐÐ»Ð¾ÐºÐ¸ÑÐ¾Ð²ÐºÐ° ÑÐµÐ¼ÑÐ²Ð° Ð¾Ð±ÑÐµÐºÑÐ° ÑÐµÑÐµÐ· Ð¾Ð¿ÑÐµÐ´ÐµÐ»ÑÐ½Ð½Ð¾Ðµ Ð²ÑÐµÐ¼Ñ (ÑÐµÐºÑÐ½Ð´) [-1 - Ð²ÑÐºÐ»ÑÑÐ¸ÑÑ]")]
            public int blocktime;

            [JsonProperty("ÐÐµÑÑÐ¸Ñ ÑÐµÐ¹Ð´Ð±Ð»Ð¾ÐºÐ° [0 - Ð¥ÑÐ³Ð°Ð½Ð°, 1 - Ð¡ ÑÐ¼Ð¾Ð´Ð°]")]
            public int whatblock;

            [JsonProperty("GUI - Ð¦Ð²ÐµÑ ÑÐ¾Ð½Ð°")]
            public string color;

            [JsonProperty("Ð¡Ð¾Ð¾Ð±ÑÐµÐ½Ð¸Ñ")]
            public List<string> messages;

            [JsonProperty("Ð¡Ð¾Ð¾Ð±ÑÐµÐ½Ð¸Ñ - ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ñ")]
            public List<string> messages2;
            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    friends = true,
                    cupboard = false,
                    time = 60,
                    procent = 100f,
                    AnchorMin = "0.3447913 0.1135",
                    AnchorMax = "0.640625 0.1435",
                    color = "0.97 0.92 0.88 0.18",
                    blocktime = 7200,
                    whatblock = 0,
                    messages = new List<string>
                    {
                        "Ð ÐÐÐÐ Ð£ÐÐÐÐÐÐÐ¯ ÐÐ«ÐÐÐ®Ð§ÐÐ¢Ð¡Ð¯ Ð§ÐÐ ÐÐ <color=#ffd479>{count} Ð¡ÐÐÐ£ÐÐ</color>",
                        "<size=15>Ð ÐµÐ¶Ð¸Ð¼ ÑÐ´Ð°Ð»ÐµÐ½Ð¸Ñ Ð²ÑÐºÐ»ÑÑÐµÐ½</size>.",
                        "<color=red>ÐÐµ Ð½Ð°Ð¹Ð´ÐµÐ½ Ð¾Ð±ÑÐµÐºÑ Ð´Ð»Ñ ÑÐ´Ð°Ð»ÐµÐ½Ð¸Ñ.</color>",
                        "<color=#ffd479>BIND X REMOVE.USE</color> ÐÐÐÐ ÐÐÐ¯ <color=#ffd479>Ð ÐÐÐ£ÐÐ</color>\n<color=#ffd479>ÐÐÐÐÐÐ¢Ð ÐÐ 'E' </color>ÐÐÐ¯ <color=#ffd479>Ð£ÐÐ£Ð§Ð¨ÐÐÐÐ¯</color>",
                        "<color=#ffd479>BIND C UPGRADE.USE</color> ÐÐÐÐ ÐÐÐ¯ <color=#ffd479>Ð£ÐÐ£Ð§Ð¨ÐÐÐÐ¯</color>",
                        "<size=15>Ð ÐºÐ¾Ð½ÑÐµÐ¹Ð½ÐµÑÐµ ÐµÑÑÑ Ð¿ÑÐµÐ´Ð¼ÐµÑÑ!</size>", //5
                        "<size=15>Ð ÐµÐ¼ÑÐ² ÑÑÐ¾Ð³Ð¾ Ð¾Ð±ÑÐµÐºÑÐ° ÑÑÐ¾Ð¸Ñ <color=#ffd479>{amount} Ð´ÐµÑÐµÐ²Ð°</color>!</size>",
                        "ÐÐ±ÑÐµÐºÑ ÑÐ¶Ðµ ÑÐ½Ð¸ÑÑÐ¾Ð¶ÐµÐ½.",
                        "Ð¡Ð¸ÑÑÐµÐ¼Ð½ÑÐ¹ Ð¾Ð±ÑÐµÐºÑ.",//8
                        "<size=15>ÐÑÐ¾ÑÐ»Ð¾ Ð¼Ð½Ð¾Ð³Ð¾ Ð²ÑÐµÐ¼ÐµÐ½Ð¸ Ð¿Ð¾ÑÐ»Ðµ Ð¿Ð¾ÑÑÑÐ¾Ð¹ÐºÐ¸ Ð´Ð°Ð½Ð½Ð¾Ð³Ð¾ Ð¾Ð±ÑÐµÐºÑÐ°!</size>",
                        "<size=15>ÐÐµÐ»ÑÐ·Ñ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ <color=#ffd479>remove</color> Ð²Ð¾ Ð²ÑÐµÐ¼Ñ ÑÐµÐ¹Ð´-Ð±Ð»Ð¾ÐºÐ°</size>",
                        "<size=15><color=yellow>ÐÑ Ð½Ðµ Ð¸Ð¼ÐµÐµÑÐµ Ð¿ÑÐ°Ð²Ð° ÑÐ´Ð°Ð»ÑÑÑ ÑÑÐ¶Ð¸Ðµ Ð¿Ð¾ÑÑÑÐ¾Ð¹ÐºÐ¸!</color></size>",
                        "<size=15><color=yellow>Ð§ÑÐ¾ Ð±Ñ ÑÐ´Ð°Ð»ÑÑÑ Ð¿Ð¾ÑÑÑÐ¾Ð¹ÐºÐ¸, Ð²Ñ Ð´Ð¾Ð»Ð¶Ð½Ñ Ð±ÑÑÑ Ð°Ð²ÑÐ¾ÑÐ¸Ð·Ð¸ÑÐ¾Ð²Ð°Ð½Ñ Ð² ÑÐºÐ°ÑÑ!</color></size>",
                        "Ð£ ÑÐµÐ±Ñ Ð½ÐµÑÑ Ð¿ÑÐ°Ð² Ð½Ð° Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ ÑÑÐ¾Ð¹ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ",
                        "<size=15>ÐÑÐ¿Ð¾Ð»ÑÐ·ÑÐ¹ÑÐµ <color=#ffd479>ÐºÐ¸ÑÐ½ÐºÑ</color> Ð´Ð»Ñ ÑÐ´Ð°Ð»ÐµÐ½Ð¸Ñ Ð¾Ð±ÑÐµÐºÑÐ¾Ð².\nÐÐ¾Ð¼Ð°Ð½Ð´Ð° <color=#ffd479>/remove</color> - Ð²ÑÐºÐ»ÑÑÐ¸ÑÑ ÑÐµÐ¶Ð¸Ð¼ ÑÐ´Ð°Ð»ÐµÐ½Ð¸Ñ</size>",
                        "<size=15>ÐÑÐ¿Ð¾Ð»ÑÐ·ÑÐ¹ÑÐµ <color=#ffd479>Ð¿Ð»Ð°Ð½ Ð¿Ð¾ÑÑÑÐ¾Ð¹ÐºÐ¸</color> Ð¸ <color=#ffd479>ÐºÐ¸ÑÐ½ÐºÑ</color> Ð´Ð»Ñ ÑÐ»ÑÑÑÐµÐ½Ð¸Ñ Ð¾Ð±ÑÐµÐºÑÐ¾Ð².\nÐÐ¾Ð¼Ð°Ð½Ð´Ð° <color=#ffd479>/up</color> - ÑÐ¼ÐµÐ½Ð¸ÑÑ ÑÐµÑÑÑÑ ÑÐ»ÑÑÑÐµÐ½Ð¸Ñ\nÐÐ¾Ð¼Ð°Ð½Ð´Ð° <color=#ffd479>/remove</color> - Ð²ÑÐºÐ»ÑÑÐ¸ÑÑ ÑÐµÐ¶Ð¸Ð¼ ÑÐ»ÑÑÑÐµÐ½Ð¸Ñ</size>",
                        "<size=15>ÐÑ Ð¸Ð·Ð¼ÐµÐ½Ð¸Ð»Ð¸ ÑÐµÐ¶Ð¸Ð¼ ÑÐ»ÑÑÑÐµÐ½Ð¸Ñ Ð´Ð¾ <color=#ffd479>{grade}</color></size>", //16
                        "ÐÐÐ¢ÐÐ£ÐÐ£Ð§Ð¨ÐÐÐÐ ÐÐ <color=#ffd479>{grade}</color> ÐÐ«ÐÐÐ®Ð§ÐÐ¢Ð¡Ð¯ Ð§ÐÐ ÐÐ <color=#ffd479>{count} Ð¡ÐÐ</color>",
                        "<size=15>Ð ÐµÐ¶Ð¸Ð¼ ÑÐ»ÑÑÑÐµÐ½Ð¸Ñ Ð²ÑÐºÐ»ÑÑÐµÐ½</size>.",
                        "<size=15>Ð­ÑÐ¾Ñ Ð¾Ð±ÑÐµÐºÑ Ð½Ðµ Ð½ÑÐ¶Ð´Ð°ÐµÑÑÑ Ð² ÑÐ»ÑÑÑÐµÐ½Ð¸Ð¸ Ð´Ð¾ <color=#ffd479>{grade}</color>!</size>",
                        "<size=15>ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ Ð°Ð²ÑÐ¾-ÑÐ»ÑÑÑÐ°ÑÑ Ð¿Ð¾ÑÑÑÐ¾Ð¹ÐºÐ¸ <color=#ffd479>Ð²Ð¾ Ð²ÑÐµÐ¼Ñ ÑÐµÐ¹Ð´Ð°</color>!</size>", //20
                        "<size=15>ÐÑ Ð½Ð°ÑÐ¾Ð´Ð¸ÑÐµÑÑ Ð½Ð° ÑÑÐ¶Ð¾Ð¹ ÑÐµÑÑÐ¸ÑÐ¾ÑÐ¸Ð¸!</size>",
                        "Ð­ÑÐ¾Ñ Ð¾Ð±ÑÐµÐºÑ Ð¼Ð¾Ð¶Ð½Ð¾ Ð±ÑÐ´ÐµÑ ÑÐ»ÑÑÑÐ¸ÑÑ ÑÐµÑÐµÐ· <color=#ffd479>{count} ÑÐµÐºÑÐ½Ð´</color>",
                        "Ð£ Ð²Ð°Ñ Ð½Ðµ ÑÐ²Ð°ÑÐ°ÐµÑ ÑÐµÑÑÑÑÐ¾Ð² Ð´Ð»Ñ ÑÐ»ÑÑÑÐµÐ½Ð¸Ñ Ð´Ð¾ <color=#ffd479>{grade}</color>!" //23
                    },
                    messages2 = new List<string>()
                    {
                        { "None" }, { "ÐÐÐ ÐÐÐ" }, { "ÐÐÐÐÐ¯" }, { "ÐÐÐ¢ÐÐÐ" }, { "ÐÐÐ" }
                    },
                    disablegui = false
                };
            }
        }
        #endregion

        Dictionary<ulong, DateTime> canremove = new Dictionary<ulong, DateTime>();
        private void OnEntitySpawned(BaseCombatEntity ent)
        {
            if (ent == null) return;
            if (ent is DecayEntity)
            {
                if (!ent.IsDestroyed) canremove[ent.net.ID.Value] = DateTime.Now.AddSeconds(config.blocktime);
            }
        }

        static string GUIjson = "";
        static RemoveUpgradeV2 _ins;
        string helpstring;

        void Init()
        {
            Unsubscribe(nameof(OnEntitySpawned));
        }

        private static bool wipe = false;
        private void OnNewSave(string filename) => wipe = true;

        void OnServerInitialized()
        {
            if (wipe) wipe = false;
            else
            {
                Dictionary<ulong, string> saved = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, string>>("entspawned");

                foreach (var z in saved)
                {
                    DateTime dateTime = Convert.ToDateTime(z.Value);
                    if (dateTime < DateTime.Now) continue;
                    canremove[z.Key] = dateTime;
                }
            }

            LoadItemPrefabs();

            SaveConfig();
            if (config.disablegui) Unsubscribe(nameof(OnActiveItemChanged));
            if (config.blocktime >= 1) Subscribe(nameof(OnEntitySpawned));
            GUIjson = "[{\"name\":\"RemoverGUIBackground\", \"parent\":\"Hud\", \"components\":[{\"type\":\"UnityEngine.UI.Image\", \"color\":\"{color}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0\",\"anchormax\":\"0.5 0\",\"offsetmin\":\"-199.5 80\",\"offsetmax\":\"180.5 {max}\"}]},{\"name\":\"RemoverGUIText\",\"parent\":\"RemoverGUIBackground\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{text}\",\"font\":\"robotocondensed-regular.ttf\",\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.5\",\"distance\":\"0.5 -0.5\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\"}]}]".Replace("{max}", "100").Replace("{color}", config.color);

            float number;
            string[] ar = config.AnchorMax.Split(' ');
            if (float.TryParse(ar[1], out number))
            {
                helpstring = ar[0] + " " + (number + 0.03f).ToString();
            }
            else Debug.LogError("ÐÐ¾Ð½ÑÐ¸Ð³ Ð¿Ð¾Ð²ÑÐµÐ¶Ð´ÐµÐ½!");

            _ins = this;

            permission.RegisterPermission("RemoveUpgradeV2.admin", this);
            permission.RegisterPermission("RemoveUpgradeV2.use", this);
            permission.RegisterPermission("RemoveUpgradeV2.refund", this);
            permission.RegisterPermission("RemoveUpgradeV2.remove", this);
            permission.RegisterPermission("RemoveUpgradeV2.up", this);
            permission.RegisterPermission("RemoveUpgradeV2.vip", this);

            foreach (ItemDefinition def in ItemManager.GetItemDefinitions())
            {
                if (!def.Blueprint) continue;
                ItemModDeployable deployable = def.GetComponent<ItemModDeployable>();
                if (deployable != null) deployedToItem[deployable.entityPrefab.resourceID] = def.itemid;
            }
        }

        void unloadbehavior(BasePlayer player)
        {
            player.GetComponent<ToolRemover>()?.DoDestroy();
            player.GetComponent<UpgradeConstruction>()?.DoDestroy();
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            unloadbehavior(player);
        }

        private void Unload()
        {
            if (canremove.Count > 0) Interface.Oxide.DataFileSystem.WriteObject("entspawned", canremove);
            foreach (BasePlayer player in BasePlayer.activePlayerList) unloadbehavior(player);
        }

        private Dictionary<ulong, int> deployedToItem = new Dictionary<ulong, int>();

        enum RemoveType
        {
            Normal,
            Refund,
            Admin,
            All
        }

        static void PrintToChat(BasePlayer player, string message) => player.ChatMessage(message);


        class ToolRemover : MonoBehaviour
        {
            public BasePlayer player;
            int count;
            int maxcount;
            public RemoveType removeType;

            void Awake()
            {
                player = GetComponent<BasePlayer>();
                if (player == null) Destroy(this);
                SetCount(_ins.config.time);
                InvokeRepeating("UpdateGUI", 0, 1);
            }

            public void SetCount(int number)
            {
                count = number;
                maxcount = number;
            }

            public void ResetDestroy()
            {
                count = maxcount;
            }

            void UpdateGUI()
            {
                if (count.Equals(0)) DoDestroy();
                if (!_ins.config.disablegui)
                {
                    CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "RemoverGUIBackground");
                    CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", GUIjson.Replace("{text}", _ins.config.messages[0].Replace("{count}", count.ToString())).Replace("{max}", _ins.config.AnchorMax));
                }
                count--;
            }

            public void DoDestroy()
            {
                Destroy(this);
            }

            void OnDestroy()
            {
                if (!_ins.config.disablegui) CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "RemoverGUIBackground");
                PrintToChat(player, _ins.config.messages[1]);
            }
        }


        object OnHammerHit(BasePlayer player, HitInfo info)
        {
            if (player == null || info == null) return null;

			var entity = info.HitEntity as BaseCombatEntity;
			if (entity == null || entity.OwnerID == 0) return null;

            ToolRemover RemoverClass = player.GetComponent<ToolRemover>();
            if (RemoverClass != null)
            {
                TryRemove(player, entity, RemoverClass.removeType);
                RemoverClass.ResetDestroy();
                return false;
            }
            else if (info.HitEntity is BuildingBlock)
            {
				var block = entity as BuildingBlock;
				if (block == null) return null;

                var grade = player.GetComponent<UpgradeConstruction>();
                if (grade == null) return null;

                TryUpgrade(player, block, grade);
                return true;
            }
            return null;
        }

		private static void GiveRefund(BaseCombatEntity entity, BasePlayer player)
		{
			var shortPrefabName = entity.ShortPrefabName;

			if (!_ins._shortPrefabNamesToItem.TryGetValue(shortPrefabName, out shortPrefabName))
				shortPrefabName = Regex.Replace(entity.ShortPrefabName, "\\.deployed|_deployed", "");

			var item = ItemManager.CreateByName(shortPrefabName);
			if (item != null)
			{

				player.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);
				return;
			}

			entity.BuildCost()?.ForEach(value =>
			{
				var amount = Convert.ToInt32(_ins.config.procent < 100
					? value.amount * (_ins.config.procent / 100f)
					: value.amount);

				item = ItemManager.Create(value.itemDef, amount);
				if (item == null) return;

				player.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);
			});
		}

		private static void RemoveEntity(BasePlayer player, BaseCombatEntity entity, bool isRefund = false)
		{
            if (entity == null || entity.IsDestroyed) return;

            if (isRefund)
            {
                GiveRefund(entity, player);
            }

			DropContainer(entity.GetComponent<StorageContainer>());
			DropContainer(entity.GetComponent<ContainerIOEntity>());

            if (!entity.IsDestroyed)
			entity.Kill();
		}

		private static void DropContainer(StorageContainer container)
		{
			if (container == null || container.inventory.itemList.Count < 1) return;

			ItemContainer.Drop("assets/prefabs/misc/item drop/item_drop.prefab", container.GetDropPosition(),
				container.Transform.rotation, container.inventory);
		}

		private static void DropContainer(ContainerIOEntity container)
		{
			if (container == null || container.inventory.itemList.Count < 1) return;

			ItemContainer.Drop("assets/prefabs/misc/item drop/item_drop.prefab", container.GetDropPosition(),
				container.Transform.rotation, container.inventory);
		}

        private static bool IsUpgradeBlocked(BuildingBlock block)
        {
            var deployVolumeArray = PrefabAttribute.server.FindAll<DeployVolume>(block.prefabID);
            return DeployVolume.Check(block.transform.position, block.transform.rotation, deployVolumeArray, ~(1 << (block.gameObject.layer & 31)));
        }
        private void TryUpgrade(BasePlayer player, BuildingBlock block, UpgradeConstruction gr)
        {
            if (block == null) return;

            if ((int)block.grade >= gr.currentgrade)
            {
                PrintToChat(player, config.messages[19].Replace("{grade}", config.messages2[gr.currentgrade]));
                return;
            }

            if (NoEscape)
            {
                object can = NoEscape?.Call("IsRaidBlocked", player);
                if (can != null) if ((bool)can)
                {
                    gr.DoDestroy();
                    PrintToChat(player, config.messages[20]);
                    return;
                }
            }

            if (block.prefabID == 72949757 || block.prefabID == 3234260181)
            {
                if (IsUpgradeBlocked(block))
                {
                    PrintToChat(player, "<color=yellow>Ð ÑÑÐ½Ð´Ð°Ð¼ÐµÐ½ÑÐµ ÑÑÐ¾-ÑÐ¾ Ð½Ð°ÑÐ¾Ð´Ð¸ÑÑÑÑ!</color>");
                    return;
                }
            }

            if (!player.CanBuild())
            {
                gr.DoDestroy();
                PrintToChat(player, config.messages[21]);
                return;
            }

            if (block.SecondsSinceAttacked < 30)
            {
                PrintToChat(player, config.messages[22].Replace("{count}", (30 - block.SecondsSinceAttacked).ToString()));
                return;
            }

            BuildingGrade.Enum grade = (BuildingGrade.Enum)gr.currentgrade;

            if (!CanAffordUpgrade(block, grade, player))
            {
                PrintToChat(player, config.messages[23].Replace("{grade}", config.messages2[gr.currentgrade]));
                return;
            }

            PayForUpgrade(block, grade, player);

            UpgradeBuildingBlock(block, grade);
            Effect.server.Run("assets/bundled/prefabs/fx/build/promote_" + grade.ToString().ToLower() + ".prefab", block, 0U, Vector3.zero, Vector3.zero);
            gr.count = _ins.config.time;
        }

        private void TryRemove(BasePlayer player, BaseCombatEntity removeObject, RemoveType removeType)
        {
            if (player == null) return;
            if (removeObject == null)
            {
                PrintToChat(player, config.messages[2]);
                return;
            }

            bool can = CanRemoveEntity(player, removeObject, removeType);
            if (!can) return;

            if (removeType.Equals(RemoveType.All)) Removeall(removeObject);
            else if (removeType.Equals(RemoveType.Refund)) RemoveEntity(player, removeObject, true);
            else RemoveEntity(player, removeObject);
        }

        Dictionary<ulong, Timer> activegui = new Dictionary<ulong, Timer>();
        List<ulong> activeusers = new List<ulong>();
        private void OnActiveItemChanged(BasePlayer player, Item oldItem, Item newItem)
        {
            if (newItem != null)
            {
                if (newItem.info.itemid.Equals(200773292) || newItem.info.itemid.Equals(1803831286))
                {
                    if (player.GetComponent<ToolRemover>() || player.GetComponent<UpgradeConstruction>()) return;
                    destroynotif(player);
                    CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", GUIjson.Replace("{text}", config.messages[3]).Replace("{max}", "100"));
                    activegui.Add(player.userID, timer.Once(7f, () =>
                    {
                        destroynotif(player);
                    }));
                }
                else if (newItem.info.itemid.Equals(1525520776))
                {
                    if (player.GetComponent<ToolRemover>() || player.GetComponent<UpgradeConstruction>()) return;
                    destroynotif(player);
                    CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", GUIjson.Replace("{text}", config.messages[4]).Replace("{max}", "100"));
                    activegui.Add(player.userID, timer.Once(7f, () =>
                    {
                        destroynotif(player);
                    }));
                }
                else if (activegui.ContainsKey(player.userID))
                {
                    destroynotif(player);
                }
            }
            else if (activegui.ContainsKey(player.userID))
            {
                destroynotif(player);
            }
        }

        void destroynotif(BasePlayer player)
        {
            if (activegui.ContainsKey(player.userID))
            {
                activegui[player.userID]?.Destroy();
                activegui.Remove(player.userID);
            }
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "RemoverGUIBackground");
        }

        static int constructionColl = LayerMask.GetMask(new string[] { "Construction", "Deployable", "Prevent Building", "Deployed" });

        void Removeall(BaseEntity removeObject)
        {
            ServerMgr.Instance.StartCoroutine(Loop(removeObject.transform.position));
        }

        private static IEnumerator Loop(Vector3 pos)
        {
            List<BaseEntity> list = Pool.GetList<BaseEntity>();
            yield return new WaitForEndOfFrame();
            Vis.Entities<BaseEntity>(pos, 10f, list, constructionColl);
            yield return new WaitForEndOfFrame();
            foreach (var z in list)
            {
                z.KillMessage();
                yield return new WaitForSeconds(0.05f);
            }
        }

        void DoRemove(BaseEntity removeObject, BasePlayer player)
        {
            if (removeObject is StorageContainer && removeObject.GetComponent<StorageContainer>().inventory.itemList.Count > 0)
            {
                PrintToChat(player, config.messages[5]);
                return;
            }
            EffectNetwork.Send(new Effect("assets/bundled/prefabs/fx/item_break.prefab", removeObject, 0, Vector3.up, Vector3.zero) { scale = UnityEngine.Random.Range(0f, 1f) });

            if (!removeObject.IsDestroyed)
            removeObject.KillMessage();
        }

        [PluginReference] Plugin NoEscape, RaidBlock, RaidZone, BLimitObject = null;

        public double GetMultiply(BasePlayer player, int costToBuild)
        {
            return (double)BLimitObject?.Call("GetMultiply", player, costToBuild);
        }

        bool CanRemoveEntity(BasePlayer player, BaseEntity entity, RemoveType removeType)
        {
            if (entity.IsDestroyed)
            {
                PrintToChat(player, config.messages[7]);
                return false;
            }

            if (entity.OwnerID == 0)
            {
                PrintToChat(player, config.messages[8]);
                return false;
            }

            if (removeType == RemoveType.Admin || removeType == RemoveType.All) return true;

            if (entity.OwnerID != player.userID && !config.cupboard)
            {
                if (config.friends)
                {
                    if (player.Team == null || !player.Team.members.Contains(entity.OwnerID))
                    {
                        PrintToChat(player, config.messages[11]);
                        return false;
                    }
                }
            }

            var externalPlugins = Interface.CallHook("canRemove", player, entity);
            if (externalPlugins != null)
            {
                player.ChatMessage("ÐÐµ ÑÐ´Ð°Ð»Ð¾ÑÑ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ ÑÐ´Ð°Ð»ÐµÐ½Ð¸Ðµ Ð¿Ð¾ÑÑÑÐ¾Ð¹ÐºÐ¸: Ð²Ð½ÐµÑÐ½Ð¸Ð¹ ÑÐ°ÐºÑÐ¾Ñ Ð·Ð°Ð±Ð»Ð¾ÐºÐ¸ÑÐ¾Ð²Ð°Ð» ÐµÐ³Ð¾ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ");
                return false;
            }

            if (NoEscape)
            {
                object can = NoEscape?.Call("IsRaidBlocked", player);
                if (can != null) if ((bool)can)
                {
                    PrintToChat(player, config.messages[10]);
                    return false;
                }
            }

            var privilege = entity.GetBuildingPrivilege();
            if (privilege != null)
            {
                if (!privilege.IsAuthed(player))
                {
                    player.ChatMessage("ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐ´Ð°Ð»ÑÑÑ Ð¿Ð¾ÑÑÑÐ¾Ð¹ÐºÑ Ð±ÐµÐ· Ð°Ð²ÑÐ¾ÑÐ¸Ð·Ð°ÑÐ¸Ð¸ Ð² ÑÐºÐ°ÑÑ!");
                    return false;
                }
            }

            if (!player.CanBuild())
            {
                PrintToChat(player, config.messages[12]);
                return false;
            }

            return true;
        }

        [ChatCommand("remove")]
        void cmdChatRemove(BasePlayer player, string command, string[] args)
        {
            removecommand(player, args);
        }

        [ChatCommand("up")]
        void cmdChatUpgrade(BasePlayer player, string command, string[] args)
        {
            upgradecommand(player, args);
        }

        [ConsoleCommand("upgrade.use")]
        void ConsoleUP(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            upgradecommand(player, arg.Args);
        }

        [ConsoleCommand("remove.use")]
        void ConsoleRemove(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            removecommand(player, arg.Args);
        }

        void removecommand(BasePlayer player, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "RemoveUpgradeV2.use") && !permission.UserHasPermission(player.UserIDString, "RemoveUpgradeV2.remove"))
            {
                SendReply(player, config.messages[13]);
                return;
            }
            UpgradeConstruction tool = player.GetComponent<UpgradeConstruction>();
            if (tool != null)
            {
                tool.DoDestroy();
                return;
            }
            ToolRemover toolremover = player.GetComponent<ToolRemover>();
            if (toolremover != null)
            {
                toolremover.DoDestroy();
                return;
            }
            int removeTime = config.time;
            RemoveType removetype = permission.UserHasPermission(player.UserIDString, "RemoveUpgradeV2.refund") ? RemoveType.Refund : RemoveType.Normal;

            if (args.Length != 0)
            {
                switch (args[0])
                {
                    case "admin":
                        if (!permission.UserHasPermission(player.UserIDString, "RemoveUpgradeV2.admin") && !player.IsAdmin)
                        {
                            SendReply(player, config.messages[13]);
                            return;
                        }
                        removetype = RemoveType.Admin;
                        if (args.Length > 1) int.TryParse(args[1], out removeTime);
                        break;
                    case "all":
                        if (!permission.UserHasPermission(player.UserIDString, "RemoveUpgradeV2.admin") && !player.IsAdmin)
                        {
                            SendReply(player, config.messages[13]);
                            return;
                        }
                        removetype = RemoveType.All;
                        if (args.Length > 1) int.TryParse(args[1], out removeTime);
                        break;
                    default:
                        int.TryParse(args[0], out removeTime);
                        break;
                }
            }
            if (removeTime == 0) removeTime = config.time;

            if (activegui != null && activegui.ContainsKey(player.userID))
            {
                activegui[player.userID]?.Destroy();
                activegui.Remove(player.userID);
            }
            toolremover = player.gameObject.AddComponent<ToolRemover>();

            PrintToChat(player, config.messages[14]);

            toolremover.SetCount(removeTime);
            toolremover.removeType = removetype;
        }


        #region Upgrade
        [ConsoleCommand("upgrade.off")]
        void ConsoleUasd1P(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            player.GetComponent<UpgradeConstruction>()?.DoDestroy();
        }

        [ConsoleCommand("remove.off")]
        void ConsoleUasd(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            player.GetComponent<ToolRemover>()?.DoDestroy();
        }

        bool IsUpgrade(BasePlayer player)
        {
            UpgradeConstruction uc = player.GetComponent<UpgradeConstruction>();
            if (uc == null) return false;
            return true;
        }

        bool IsRemove(BasePlayer player)
        {
            ToolRemover re = player.GetComponent<ToolRemover>();
            if (re == null) return false;
            return true;
        }

        void upgradecommand(BasePlayer player, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "RemoveUpgradeV2.use") && !permission.UserHasPermission(player.UserIDString, "RemoveUpgradeV2.up"))
            {
                SendReply(player, config.messages[13]);
                return;
            }
            int current = 0;
            if (args != null && args.Length > 0) int.TryParse(args[0], out current);
            UpgradeConstruction tool = player.GetComponent<UpgradeConstruction>();
            if (tool != null)
            {
                if (current != 0) tool.changegrade(current);
                else tool.changegrade(tool.currentgrade + 1);
                return;
            }

            if (activegui != null && activegui.ContainsKey(player.userID))
            {
                activegui[player.userID]?.Destroy();
                activegui.Remove(player.userID);
            }
            tool = player.gameObject.AddComponent<UpgradeConstruction>();
            if (current != 0) tool.changegrade(current);
            PrintToChat(player, config.messages[15]);
        }

        class UpgradeConstruction : MonoBehaviour
        {
            BasePlayer player;
            public int count = _ins.config.time;
            public int currentgrade = 2;

            void Awake()
            {
                player = GetComponent<BasePlayer>();
                if (player == null) Destroy(this);
                ToolRemover tool = player.GetComponent<ToolRemover>();
                if (tool != null) tool.DoDestroy();
                InvokeRepeating("UpdateGUI", 0, 1f);
            }

            public void changegrade(int change)
            {
                if (change > 4) currentgrade = 1;
                else if (change <= 0) currentgrade = 2;
                else currentgrade = change;
                if (change != 0) PrintToChat(player, _ins.config.messages[16].Replace("{grade}", _ins.config.messages2[currentgrade]));
                count = _ins.config.time;
                UpdateGUI();
                EffectNetwork.Send(new Effect("assets/bundled/prefabs/fx/notice/loot.drag.grab.fx.prefab", player, 0, Vector3.up, Vector3.zero) { scale = UnityEngine.Random.Range(0f, 1f) }, player.net.connection);
            }

            void UpdateGUI()
            {
                if (count.Equals(0))
                {
                    DoDestroy();
                    return;
                }
                if (!_ins.config.disablegui)
                {
                    CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "RemoverGUIBackground");
                    CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", GUIjson.Replace("{text}", _ins.config.messages[17].Replace("{grade}", _ins.config.messages2[currentgrade]).Replace("{count}", count.ToString())).Replace("{max}", "100"));
                }
                count--;
            }

            public void DoDestroy()
            {
                Destroy(this);
            }

            void OnDestroy()
            {
                if (!_ins.config.disablegui) CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "RemoverGUIBackground");
                PrintToChat(player, _ins.config.messages[18]);
            }
        }

        private Dictionary<string, string> _shortPrefabNamesToItem = new Dictionary<string, string>();

		private void LoadItemPrefabs()
		{
			foreach (var itemDefinition in ItemManager.GetItemDefinitions())
			{
				var entityPrefab = itemDefinition.GetComponent<ItemModDeployable>()?.entityPrefab?.resourcePath;
				if (string.IsNullOrEmpty(entityPrefab))
					continue;

				var shortPrefabName = Utility.GetFileNameWithoutExtension(entityPrefab);
				if (!string.IsNullOrEmpty(shortPrefabName))
					_shortPrefabNamesToItem.TryAdd(shortPrefabName, itemDefinition.shortname);
			}
		}

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null) return;
            if (entity is BasePlayer)
            {
                BasePlayer player = entity.ToPlayer();
                if (player == null || player.IsNpc) return;
                ToolRemover tool = player.GetComponent<ToolRemover>();
                if (tool != null) tool.DoDestroy();
                UpgradeConstruction tool2 = player.GetComponent<UpgradeConstruction>();
                if (tool2 != null) tool2.DoDestroy();
            }
        }

        private void OnEntityBuilt(Planner plan, GameObject go)
        {
            if (plan == null || go == null) return;
            BasePlayer player = plan.GetOwnerPlayer();
            if (player == null) return;
            UpgradeConstruction gr = player.GetComponent<UpgradeConstruction>();
            if (gr == null) return;
            BuildingBlock block = go.GetComponent<BuildingBlock>();
            if (block == null) return;
            TryUpgrade(player, block, gr);
        }
        #endregion

        #region [Added]

        private bool CanAffordUpgrade(BuildingBlock block, BuildingGrade.Enum @enum, BasePlayer player)
        {
			var dict = new Dictionary<int, int>();

			foreach (var itemAmount in block.blockDefinition.GetGrade(@enum, block.skinID).CostToBuild())
			{
				int amount;
				if (!dict.TryGetValue(itemAmount.itemid, out amount))
					amount = player.inventory.GetAmount(itemAmount.itemid);
                double Factor = GetMultiply(player, (int)itemAmount.amount);
				if (amount < itemAmount.amount + Factor)
					return false;

				dict[itemAmount.itemid] = amount - Mathf.RoundToInt(itemAmount.amount);
			}

            return true;
        }

        private void PayForUpgrade(BuildingBlock block, BuildingGrade.Enum @enum, BasePlayer player)
        {
			var collect = new List<Item>();

            foreach (var itemAmount in block.blockDefinition.GetGrade(@enum, block.skinID).CostToBuild())
            {
                double Factor = GetMultiply(player, (int)itemAmount.amount);
                player.inventory.Take(collect, itemAmount.itemid, (int)itemAmount.amount + (int)Factor);
                player.Command("note.inv " + itemAmount.itemid + " " + (float) ((int) itemAmount.amount * -1.0));
            }

			foreach (var obj in collect)
				obj.Remove();
        }

        private static void UpgradeBuildingBlock(BuildingBlock block, BuildingGrade.Enum @enum)
        {
            if (block == null || block.IsDestroyed) return;

			block.SetGrade(@enum);
			block.SetHealthToMax();
			block.StartBeingRotatable();
			block.SendNetworkUpdate();
			block.UpdateSkin();
			block.ResetUpkeepTime();
			block.UpdateSurroundingEntities();
			block.GetBuilding()?.Dirty();
        }

        #endregion
    }

}


// --- End of file: RemoveUpgradeV2.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/CopyPaste.cs ---
// --- Original Local Path: BeeRust/CopyPaste.cs ---

ï»¿//If debug is defined it will add a stopwatch to the paste and copydata which can be used to profile copying and pasting.
// #define DEBUG

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Linq;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Libraries.Covalence;
using ProtoBuf;
using UnityEngine;
using Graphics = System.Drawing.Graphics;

// ReSharper disable SpecifyACultureInStringConversionExplicitly

/*
 * CREDITS
 *
 * Orange - Saving ContainerIOEntity
 * UIP88 - Turrets fix
 * bsdinis - Wire fix
 * nivex - Ownership option, sign fix
 * DezLife - CCTV fix
 * Wulf - Skipping 4.1.24 :D
 * 
 */

namespace Oxide.Plugins
{
    [Info("Copy Paste", "misticos", "4.1.36")]
    [Description("Copy and paste buildings to save them or move them")]
    public class CopyPaste : CovalencePlugin
    {
        // ReSharper disable once Unity.IncorrectMonoBehaviourInstantiation
        private readonly Item _emptyItem = new Item { info = new ItemDefinition() };
        private readonly IPlayer _consolePlayer = new RustConsolePlayer();

        private int _copyLayer =
                LayerMask.GetMask("Construction", "Prevent Building", "Construction Trigger", "Trigger", "Deployed",
                    "Default", "Ragdoll"),
            _groundLayer = LayerMask.GetMask("Terrain", "Default"),
            _rayCopy = LayerMask.GetMask("Construction", "Deployed", "Tree", "Resource", "Prevent Building"),
            _rayPaste = LayerMask.GetMask("Construction", "Deployed", "Tree", "Terrain", "World", "Water",
                "Prevent Building");

        private string _copyPermission = "copypaste.copy",
            _listPermission = "copypaste.list",
            _pastePermission = "copypaste.paste",
            _pastebackPermission = "copypaste.pasteback",
            _undoPermission = "copypaste.undo",
            _subDirectory = "copypaste/";

        private Dictionary<string, Stack<List<BaseEntity>>> _lastPastes =
            new Dictionary<string, Stack<List<BaseEntity>>>();

        private Dictionary<string, SignSize> _signSizes = new Dictionary<string, SignSize>
        {
            //{"spinner.wheel.deployed", new SignSize(512, 512)},
            { "sign.pictureframe.landscape", new SignSize(256, 128) },
            { "sign.pictureframe.tall", new SignSize(128, 512) },
            { "sign.pictureframe.portrait", new SignSize(128, 256) },
            { "sign.pictureframe.xxl", new SignSize(1024, 512) },
            { "sign.pictureframe.xl", new SignSize(512, 512) },
            { "sign.small.wood", new SignSize(128, 64) },
            { "sign.medium.wood", new SignSize(256, 128) },
            { "sign.large.wood", new SignSize(256, 128) },
            { "sign.huge.wood", new SignSize(512, 128) },
            { "sign.hanging.banner.large", new SignSize(64, 256) },
            { "sign.pole.banner.large", new SignSize(64, 256) },
            { "sign.post.single", new SignSize(128, 64) },
            { "sign.post.double", new SignSize(256, 256) },
            { "sign.post.town", new SignSize(256, 128) },
            { "sign.post.town.roof", new SignSize(256, 128) },
            { "sign.hanging", new SignSize(128, 256) },
            { "sign.hanging.ornate", new SignSize(256, 128) },
            { "sign.neon.xl.animated", new SignSize(250, 250) },
            { "sign.neon.xl", new SignSize(250, 250) },
            { "sign.neon.125x215.animated", new SignSize(215, 125) },
            { "sign.neon.125x215", new SignSize(215, 125) },
            { "sign.neon.125x125", new SignSize(125, 125) },
        };

        private List<BaseEntity.Slot> _checkSlots = new List<BaseEntity.Slot>
        {
            BaseEntity.Slot.Lock,
            BaseEntity.Slot.UpperModifier,
            BaseEntity.Slot.MiddleModifier,
            BaseEntity.Slot.LowerModifier
        };

        public enum CopyMechanics
        {
            Building,
            Proximity
        }

        private class SignSize
        {
            public int Width;
            public int Height;

            public SignSize(int width, int height)
            {
                Width = width;
                Height = height;
            }
        }

        //Config

        private ConfigData _config;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Copy Options")]
            public CopyOptions Copy { get; set; }

            [JsonProperty(PropertyName = "Paste Options")]
            public PasteOptions Paste { get; set; }

            [JsonProperty(PropertyName =
                "Amount of entities to paste per batch. Use to tweak performance impact of pasting")]
            [DefaultValue(15)]
            public int PasteBatchSize = 15;

            [JsonProperty(PropertyName =
                "Amount of entities to copy per batch. Use to tweak performance impact of copying")]
            [DefaultValue(100)]
            public int CopyBatchSize = 100;

            [JsonProperty(PropertyName =
                "Amount of entities to undo per batch. Use to tweak performance impact of undoing")]
            [DefaultValue(15)]
            public int UndoBatchSize = 15;

            [JsonProperty(PropertyName = "Enable data saving feature")]
            [DefaultValue(true)]
            public bool DataSaving = true;

            public class CopyOptions
            {
                [JsonProperty(PropertyName = "Check radius from each entity (true/false)")]
                [DefaultValue(true)]
                public bool EachToEach { get; set; } = true;

                [JsonProperty(PropertyName = "Share (true/false)")]
                [DefaultValue(false)]
                public bool Share { get; set; } = false;

                [JsonProperty(PropertyName = "Tree (true/false)")]
                [DefaultValue(false)]
                public bool Tree { get; set; } = false;

                [JsonProperty(PropertyName = "Default radius to look for entities from block")]
                [DefaultValue(3.0f)]
                public float Radius { get; set; } = 3.0f;
            }

            public class PasteOptions
            {
                [JsonProperty(PropertyName = "Auth (true/false)")]
                [DefaultValue(false)]
                public bool Auth { get; set; } = false;

                [JsonProperty(PropertyName = "Deployables (true/false)")]
                [DefaultValue(true)]
                public bool Deployables { get; set; } = true;

                [JsonProperty(PropertyName = "Inventories (true/false)")]
                [DefaultValue(true)]
                public bool Inventories { get; set; } = true;

                [JsonProperty(PropertyName = "Vending Machines (true/false)")]
                [DefaultValue(true)]
                public bool VendingMachines { get; set; } = true;

                [JsonProperty(PropertyName = "Stability (true/false)")]
                [DefaultValue(true)]
                public bool Stability { get; set; } = true;

                [JsonProperty(PropertyName = "EntityOwner (true/false)")]
                [DefaultValue(true)]
                public bool EntityOwner { get; set; } = true;
            }
        }

        private void LoadVariables()
        {
            Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;

            _config = Config.ReadObject<ConfigData>();

            Config.WriteObject(_config, true);
        }

        protected override void LoadDefaultConfig()
        {
            var configData = new ConfigData
            {
                Copy = new ConfigData.CopyOptions(),
                Paste = new ConfigData.PasteOptions()
            };

            Config.WriteObject(configData, true);
        }

        //Hooks

        private void Init()
        {
            permission.RegisterPermission(_copyPermission, this);
            permission.RegisterPermission(_listPermission, this);
            permission.RegisterPermission(_pastePermission, this);
            permission.RegisterPermission(_pastebackPermission, this);
            permission.RegisterPermission(_undoPermission, this);

            var compiledLangs = new Dictionary<string, Dictionary<string, string>>();

            foreach (var line in _messages)
            {
                foreach (var translate in line.Value)
                {
                    if (!compiledLangs.ContainsKey(translate.Key))
                        compiledLangs[translate.Key] = new Dictionary<string, string>();

                    compiledLangs[translate.Key][line.Key] = translate.Value;
                }
            }

            foreach (var cLangs in compiledLangs)
            {
                lang.RegisterMessages(cLangs.Value, this, cLangs.Key);
            }
        }

        private void OnServerInitialized()
        {
            LoadVariables();

            Vis.colBuffer = new Collider[8192 * 16];

            JsonConvert.DefaultSettings = () => new JsonSerializerSettings
            {
                Formatting = Formatting.Indented,
                ReferenceLoopHandling = ReferenceLoopHandling.Ignore
            };
        }

        #region API

        private object TryCopyFromSteamId(ulong userId, string filename, string[] args, Action callback = null)
        {
            var player = players.FindPlayerById(userId.ToString())?.Object as BasePlayer;
            if (player == null)
                return Lang("NOT_FOUND_PLAYER");

            RaycastHit hit;

            if (!Physics.Raycast(player.eyes.HeadRay(), out hit, 1000f, _rayCopy))
                return Lang("NO_ENTITY_RAY", player.UserIDString);

            return TryCopy(hit.point, hit.GetEntity().GetNetworkRotation().eulerAngles, filename,
                DegreeToRadian(player.GetNetworkRotation().eulerAngles.y), args, player.IPlayer, callback);
        }

        private object TryPasteFromSteamId(ulong userId, string filename, string[] args, Action callback = null,
            Action<BaseEntity> callbackSpawned = null)
        {
            var player = players.FindPlayerById(userId.ToString())?.Object as BasePlayer;
            if (player == null)
                return Lang("NOT_FOUND_PLAYER");

            RaycastHit hit;

            if (!Physics.Raycast(player.eyes.HeadRay(), out hit, 1000f, _rayPaste))
                return Lang("NO_ENTITY_RAY", player.UserIDString);

            return TryPaste(hit.point, filename, player.IPlayer,
                DegreeToRadian(player.GetNetworkRotation().eulerAngles.y),
                args, callback: callback, callbackSpawned: callbackSpawned).Item1;
        }

        private object TryPasteFromVector3(Vector3 pos, float rotationCorrection, string filename, string[] args,
            Action callback = null, Action<BaseEntity> callbackSpawned = null)
        {
            return TryPaste(pos, filename, _consolePlayer, rotationCorrection, args, callback: callback,
                callbackSpawned: callbackSpawned).Item1;
        }

        private ValueTuple<object, Action> TryPasteFromVector3Cancellable(Vector3 pos, float rotationCorrection,
            string filename, string[] args,
            Action callback = null, Action<BaseEntity> callbackSpawned = null)
        {
            var result = TryPaste(pos, filename, _consolePlayer, rotationCorrection, args, callback: callback,
                callbackSpawned: callbackSpawned);

            var pasteData = result.Item2;

            return new ValueTuple<object, Action>(result.Item1, () => pasteData.Cancelled = true);
        }

        #endregion

        //Other methods

        private object CheckCollision(HashSet<Dictionary<string, object>> entities, Vector3 startPos, float radius)
        {
            foreach (var entityobj in entities)
            {
                if (Physics.CheckSphere((Vector3)entityobj["position"], radius, _copyLayer))
                    return Lang("BLOCKING_PASTE");
            }

            return true;
        }

        private bool CheckPlaced(string prefabname, Vector3 pos, Quaternion rot)
        {
            const float maxDiff = 0.01f;

            var ents = Pool.GetList<BaseEntity>();
            try
            {
                Vis.Entities(pos, maxDiff, ents);

                foreach (var ent in ents)
                {
                    if (ent.PrefabName != prefabname)
                        continue;

                    if (Vector3.Distance(ent.transform.position, pos) > maxDiff)
                    {
                        continue;
                    }

                    if (Vector3.Distance(ent.transform.rotation.eulerAngles, rot.eulerAngles) > maxDiff)
                    {
                        continue;
                    }

                    return true;
                }

                return false;
            }
            finally
            {
                Pool.FreeList(ref ents);
            }
        }

        private void UndoLoop(HashSet<BaseEntity> entities, IPlayer player, int count = 0)
        {
            foreach (var storageContainer in entities.OfType<StorageContainer>().Where(x => !x.IsDestroyed))
            {
                storageContainer.Kill();
            }

            // Take an amount of entities from the entity list (defined in config) and kill them. Will be repeated for every tick until there are no entities left.
            entities
                .Take(_config.UndoBatchSize)
                .ToList()
                .ForEach(p =>
                {
                    entities.Remove(p);

                    // Cleanup the hotspot beloning to the node.
                    var ore = p as OreResourceEntity;
                    if (ore != null)
                    {
                        ore.CleanupBonus();
                    }

                    var io = p as IOEntity;
                    if (io != null)
                    {
                        io.ClearConnections();
                    }

                    if (p != null && !p.IsDestroyed)
                        p.Kill();
                });

            // If it gets stuck in infinite loop break the loop.
            if (count != 0 && entities.Count != 0 && entities.Count == count)
            {
                player?.Reply("Undo cancelled because of infinite loop.");
                return;
            }

            if (entities.Count > 0)
                NextTick(() => UndoLoop(entities, player, entities.Count));
            else if (player != null)
            {
                player.Reply(Lang("UNDO_SUCCESS", player.Id));

                if (_lastPastes.ContainsKey(player.Id) && _lastPastes[player.Id].Count == 0)
                    _lastPastes.Remove(player.Id);
            }
        }

        private void Copy(Vector3 sourcePos, Vector3 sourceRot, string filename, float rotationCorrection,
            CopyMechanics copyMechanics, float range, bool saveTree, bool saveShare, bool eachToEach, IPlayer player,
            Action callback)
        {
            var currentLayer = _copyLayer;

            if (saveTree)
                currentLayer |= LayerMask.GetMask("Tree");

            var copyData = new CopyData
            {
                Filename = filename,
                CurrentLayer = currentLayer,
                RotCor = rotationCorrection,
                Range = range,
                SaveShare = saveShare,
                SaveTree = saveTree,
                CopyMechanics = copyMechanics,
                EachToEach = eachToEach,
                SourcePos = sourcePos,
                SourceRot = sourceRot,
                Player = player,
                BasePlayer = player.Object as BasePlayer,
                Callback = callback
            };

            copyData.CheckFrom.Push(sourcePos);

            NextTick(() => CopyLoop(copyData));
        }

        // Main loop for copy, will fetch all the data needed. Is called every tick untill copy is done (can't find any entities)
        private void CopyLoop(CopyData copyData)
        {
            var checkFrom = copyData.CheckFrom;
            var houseList = copyData.HouseList;
            var buildingId = copyData.BuildingId;
            var copyMechanics = copyData.CopyMechanics;
            var batchSize = checkFrom.Count < _config.CopyBatchSize ? checkFrom.Count : _config.CopyBatchSize;

            for (var i = 0; i < batchSize; i++)
            {
                if (checkFrom.Count == 0)
                    break;

                var list = Pool.GetList<BaseEntity>();
                try
                {
                    Vis.Entities(checkFrom.Pop(), copyData.Range, list, copyData.CurrentLayer);

                    foreach (var entity in list)
                    {
                        if (!houseList.Add(entity))
                            continue;

                        if (copyMechanics == CopyMechanics.Building)
                        {
                            var buildingBlock = entity.GetComponentInParent<BuildingBlock>();

                            if (buildingBlock != null)
                            {
                                if (buildingId == 0)
                                    buildingId = buildingBlock.buildingID;

                                if (buildingId != buildingBlock.buildingID)
                                    continue;
                            }
                        }

                        var transform = entity.transform;
                        if (copyData.EachToEach)
                            checkFrom.Push(transform.position);

                        if (entity.GetComponent<BaseLock>() != null)
                            continue;

                        copyData.RawData.Add(EntityData(entity, transform.position,
                            transform.rotation.eulerAngles / 57.29578f, copyData));
                    }
                }
                finally
                {
                    Pool.FreeList(ref list);
                }

                copyData.BuildingId = buildingId;
            }

            if (checkFrom.Count > 0)
            {
                NextTick(() => CopyLoop(copyData));
            }
            else
            {
                var path = _subDirectory + copyData.Filename;
                var datafile = Interface.Oxide.DataFileSystem.GetDatafile(path);

                datafile.Clear();

                var sourcePos = copyData.SourcePos;

                datafile["default"] = new Dictionary<string, object>
                {
                    {
                        "position", new Dictionary<string, object>
                        {
                            { "x", sourcePos.x.ToString() },
                            { "y", sourcePos.y.ToString() },
                            { "z", sourcePos.z.ToString() }
                        }
                    },
                    { "rotationy", copyData.SourceRot.y.ToString() },
                    { "rotationdiff", copyData.RotCor.ToString() }
                };

                datafile["entities"] = copyData.RawData;
                datafile["protocol"] = new Dictionary<string, object>
                {
                    { "items", 2 },
                    { "version", Version }
                };

                Interface.Oxide.DataFileSystem.SaveDatafile(path);

                copyData.Player.Reply(Lang("COPY_SUCCESS", copyData.Player.Id, copyData.Filename));

                copyData.Callback?.Invoke();

                Interface.CallHook("OnCopyFinished", copyData.RawData, copyData.Filename, copyData.Player, copyData.SourcePos);
            }
        }

        private float DegreeToRadian(float angle)
        {
            return (float)(Math.PI * angle / 180.0f);
        }

        private Dictionary<string, object> EntityData(BaseEntity entity, Vector3 entPos, Vector3 entRot,
            CopyData copyData)
        {
            var normalizedPos = NormalizePosition(copyData.SourcePos, entPos, copyData.RotCor);

            entRot.y -= copyData.RotCor;

            var data = new Dictionary<string, object>
            {
                { "prefabname", entity.PrefabName },
                { "skinid", entity.skinID },
                { "flags", TryCopyFlags(entity) },
                {
                    "pos", new Dictionary<string, object>
                    {
                        { "x", normalizedPos.x.ToString() },
                        { "y", normalizedPos.y.ToString() },
                        { "z", normalizedPos.z.ToString() }
                    }
                },
                {
                    "rot", new Dictionary<string, object>
                    {
                        { "x", entRot.x.ToString() },
                        { "y", entRot.y.ToString() },
                        { "z", entRot.z.ToString() }
                    }
                },
                { "ownerid", entity.OwnerID }
            };

            var growableEntity = entity as GrowableEntity;
            if (growableEntity != null)
            {
                var genes = GrowableGeneEncoding.EncodeGenesToInt(growableEntity.Genes);
                if (genes > 0)
                {
                    data.Add("genes", genes);
                }

                var perent = growableEntity.GetParentEntity();
                if (perent != null)
                {
                    data.Add("hasParent", true);
                }
            }

            TryCopySlots(entity, data, copyData.SaveShare);

            var buildingblock = entity as BuildingBlock;

            if (buildingblock != null)
            {
                data.Add("grade", buildingblock.grade);
            }

            var box = entity as StorageContainer;
            if (box?.inventory != null)
            {
                var itemlist = new List<object>();

                foreach (var item in box.inventory.itemList)
                {
                    var itemdata = new Dictionary<string, object>
                    {
                        { "condition", item.condition.ToString() },
                        { "id", item.info.itemid },
                        { "amount", item.amount },
                        { "skinid", item.skin },
                        { "position", item.position },
                        { "blueprintTarget", item.blueprintTarget },
                        { "dataInt", item.instanceData?.dataInt ?? 0 }
                    };

                    if (!string.IsNullOrEmpty(item.text))
                        itemdata["text"] = item.text;

                    var heldEnt = item.GetHeldEntity();

                    if (heldEnt != null)
                    {
                        var projectiles = heldEnt.GetComponent<BaseProjectile>();

                        if (projectiles != null)
                        {
                            var magazine = projectiles.primaryMagazine;

                            if (magazine != null)
                            {
                                itemdata.Add("magazine", new Dictionary<string, object>
                                {
                                    { magazine.ammoType.itemid.ToString(), magazine.contents }
                                });
                            }
                        }
                    }

                    if (item?.contents?.itemList != null)
                    {
                        var contents = new List<object>();

                        foreach (var itemContains in item.contents.itemList)
                        {
                            contents.Add(new Dictionary<string, object>
                            {
                                { "id", itemContains.info.itemid },
                                { "amount", itemContains.amount }
                            });
                        }

                        itemdata["items"] = contents;
                    }

                    itemlist.Add(itemdata);
                }

                data.Add("items", itemlist);
            }

            var box2 = entity as ContainerIOEntity;
            if (box2 != null)
            {
                var itemlist = new List<object>();

                foreach (var item in box2.inventory.itemList)
                {
                    var itemdata = new Dictionary<string, object>
                    {
                        { "condition", item.condition.ToString() },
                        { "id", item.info.itemid },
                        { "amount", item.amount },
                        { "skinid", item.skin },
                        { "position", item.position },
                        { "blueprintTarget", item.blueprintTarget },
                        { "dataInt", item.instanceData?.dataInt ?? 0 }
                    };

                    if (!string.IsNullOrEmpty(item.text))
                        itemdata["text"] = item.text;

                    var heldEnt = item.GetHeldEntity();

                    if (heldEnt != null)
                    {
                        var projectiles = heldEnt.GetComponent<BaseProjectile>();

                        if (projectiles != null)
                        {
                            var magazine = projectiles.primaryMagazine;

                            if (magazine != null)
                            {
                                itemdata.Add("magazine", new Dictionary<string, object>
                                {
                                    { magazine.ammoType.itemid.ToString(), magazine.contents }
                                });
                            }
                        }
                    }

                    if (item?.contents?.itemList != null)
                    {
                        var contents = new List<object>();

                        foreach (var itemContains in item.contents.itemList)
                        {
                            contents.Add(new Dictionary<string, object>
                            {
                                { "id", itemContains.info.itemid },
                                { "amount", itemContains.amount }
                            });
                        }

                        itemdata["items"] = contents;
                    }

                    itemlist.Add(itemdata);
                }

                data.Add("items", itemlist);
            }

            var sign = entity as Signage;
            if (sign != null && sign.textureIDs != null)
            {
                data.Add("sign", new Dictionary<string, object>
                {
                    { "locked", sign.IsLocked() }
                });

                var signData = (Dictionary<string, object>)data["sign"];

                for (var num = 0; num < sign.textureIDs.Length; num++)
                {
                    var textureId = sign.textureIDs[num];
                    if (textureId == 0)
                        continue;

                    var imageByte = FileStorage.server.Get(textureId, FileStorage.Type.png, sign.net.ID);
                    if (imageByte != null)
                    {
                        signData.Add($"texture{num}", Convert.ToBase64String(imageByte));
                    }
                }

                signData["amount"] = sign.textureIDs.Length;
            }

            var lights = entity as AdvancedChristmasLights;
            if (lights != null)
            {
                data.Add("points", lights.points.Select(x => new { x.normal, x.point }));
                data.Add("animationStyle", lights.animationStyle);
            }

            if (copyData.SaveShare)
            {
                var sleepingBag = entity as SleepingBag;

                if (sleepingBag != null)
                {
                    data.Add("sleepingbag", new Dictionary<string, object>
                    {
                        { "niceName", sleepingBag.niceName },
                        { "deployerUserID", sleepingBag.deployerUserID },
                        { "isPublic", sleepingBag.IsPublic() }
                    });
                }

                var cupboard = entity as BuildingPrivlidge;

                if (cupboard != null)
                {
                    data.Add("cupboard", new Dictionary<string, object>
                    {
                        { "authorizedPlayers", cupboard.authorizedPlayers.Select(y => y.userid).ToList() }
                    });
                }

                var autoTurret = entity as AutoTurret;

                if (autoTurret != null)
                {
                    data.Add("autoturret", new Dictionary<string, object>
                    {
                        { "authorizedPlayers", autoTurret.authorizedPlayers.Select(p => p.userid).ToList() }
                    });
                }
            }

            var cctvRc = entity as CCTV_RC;
            if (cctvRc != null)
            {
                data.Add("cctv", new Dictionary<string, object>
                {
                    { "yaw", cctvRc.yawAmount },
                    { "pitch", cctvRc.pitchAmount },
                    { "rcIdentifier", cctvRc.rcIdentifier }
                });
            }

            var vendingMachine = entity as VendingMachine;

            if (vendingMachine != null)
            {
                var sellOrders = new List<object>();

                foreach (var vendItem in vendingMachine.sellOrders.sellOrders)
                {
                    sellOrders.Add(new Dictionary<string, object>
                    {
                        { "itemToSellID", vendItem.itemToSellID },
                        { "itemToSellAmount", vendItem.itemToSellAmount },
                        { "currencyID", vendItem.currencyID },
                        { "currencyAmountPerItem", vendItem.currencyAmountPerItem },
                        { "inStock", vendItem.inStock },
                        { "currencyIsBP", vendItem.currencyIsBP },
                        { "itemToSellIsBP", vendItem.itemToSellIsBP }
                    });
                }

                data.Add("vendingmachine", new Dictionary<string, object>
                {
                    { "shopName", vendingMachine.shopName },
                    { "isBroadcasting", vendingMachine.IsBroadcasting() },
                    { "sellOrders", sellOrders }
                });
            }

            var ioEntity = entity as IOEntity;

            if (ioEntity != null)
            {
                var ioData = new Dictionary<string, object>();
                var inputs = ioEntity.inputs.Select(input => new Dictionary<string, object>
                    {
                        { "connectedID", input.connectedTo.entityRef.uid.Value },
                        { "connectedToSlot", input.connectedToSlot },
                        { "niceName", input.niceName },
                        { "type", (int)input.type }
                    })
                    .Cast<object>()
                    .ToList();

                ioData.Add("inputs", inputs);

                var outputs = new List<object>();
                foreach (var output in ioEntity.outputs)
                {
                    var ioConnection = new Dictionary<string, object>
                    {
                        { "connectedID", output.connectedTo.entityRef.uid.Value },
                        { "connectedToSlot", output.connectedToSlot },
                        { "niceName", output.niceName },
                        { "type", (int)output.type },
                        { "linePoints", output.linePoints?.ToList() ?? new List<Vector3>() }
                    };

                    outputs.Add(ioConnection);
                }

                ioData.Add("outputs", outputs);
                ioData.Add("oldID", ioEntity.net.ID.Value);
                var electricalBranch = ioEntity as ElectricalBranch;
                if (electricalBranch != null)
                {
                    ioData.Add("branchAmount", electricalBranch.branchAmount);
                }

                var counter = ioEntity as PowerCounter;
                if (counter != null)
                {
                    ioData.Add("targetNumber", counter.GetTarget());
                }

                var timerSwitch = ioEntity as TimerSwitch;
                if (timerSwitch != null)
                {
                    ioData.Add("timerLength", timerSwitch.timerLength);
                }

                var rfBroadcaster = ioEntity as IRFObject;
                if (rfBroadcaster != null)
                {
                    ioData.Add("frequency", rfBroadcaster.GetFrequency());
                }

                data.Add("IOEntity", ioData);
            }

            return data;
        }

        private object FindBestHeight(HashSet<Dictionary<string, object>> entities, Vector3 startPos)
        {
            var maxHeight = 0f;

            foreach (var entity in entities)
            {
                var prefab = (string)entity["prefabname"];
                if (prefab.Contains("/foundation/") || prefab.Contains("/foundation.triangle/"))
                {
                    var foundHeight = GetGround((Vector3)entity["position"]);

                    if (foundHeight != null)
                    {
                        var height = (Vector3)foundHeight;

                        if (height.y > maxHeight)
                            maxHeight = height.y;
                    }
                }
            }

            maxHeight += 1f;

            return maxHeight;
        }

        private bool FindRayEntity(Vector3 sourcePos, Vector3 sourceDir, out Vector3 point, out BaseEntity entity,
            int rayLayer)
        {
            RaycastHit hitinfo;
            entity = null;
            point = Vector3.zero;

            if (!Physics.Raycast(sourcePos, sourceDir, out hitinfo, 1000f, rayLayer))
                return false;

            entity = hitinfo.GetEntity();
            point = hitinfo.point;

            return true;
        }

        private void FixSignage(Signage sign, byte[] imageBytes, int index)
        {
            if (!_signSizes.ContainsKey(sign.ShortPrefabName))
                return;

            var size = Math.Max(sign.paintableSources.Length, 1);
            if (sign.textureIDs == null || sign.textureIDs.Length != size)
            {
                Array.Resize(ref sign.textureIDs, size);
            }

            var resizedImage = ImageResize(imageBytes, _signSizes[sign.ShortPrefabName].Width,
                _signSizes[sign.ShortPrefabName].Height);

            sign.textureIDs[index] = FileStorage.server.Store(resizedImage, FileStorage.Type.png, sign.net.ID);
        }

        private object GetGround(Vector3 pos)
        {
            RaycastHit hitInfo;
            pos += new Vector3(0, 100, 0);

            if (Physics.Raycast(pos, Vector3.down, out hitInfo, 200, _groundLayer))
                return hitInfo.point;

            return null;
        }

        private int GetItemId(int itemId)
        {
            if (ReplaceItemId.ContainsKey(itemId))
                return ReplaceItemId[itemId];

            return itemId;
        }

        private bool HasAccess(IPlayer player, string permName)
        {
            return player.IsAdmin || player.HasPermission(permName);
        }

        private byte[] ImageResize(byte[] imageBytes, int width, int height)
        {
            Bitmap resizedImage = new Bitmap(width, height),
                sourceImage = new Bitmap(new MemoryStream(imageBytes));

            Graphics.FromImage(resizedImage).DrawImage(sourceImage, new Rectangle(0, 0, width, height),
                new Rectangle(0, 0, sourceImage.Width, sourceImage.Height), GraphicsUnit.Pixel);

            var ms = new MemoryStream();
            resizedImage.Save(ms, ImageFormat.Png);

            return ms.ToArray();
        }

        private string Lang(string key, string userId = null, params object[] args) =>
            string.Format(lang.GetMessage(key, this, userId), args);

        private Vector3 NormalizePosition(Vector3 initialPos, Vector3 currentPos, float diffRot)
        {
            var transformedPos = currentPos - initialPos;
            var newX = transformedPos.x * (float)Math.Cos(-diffRot) +
                       transformedPos.z * (float)Math.Sin(-diffRot);
            var newZ = transformedPos.z * (float)Math.Cos(-diffRot) -
                       transformedPos.x * (float)Math.Sin(-diffRot);

            transformedPos.x = newX;
            transformedPos.z = newZ;

            return transformedPos;
        }

        private PasteData Paste(ICollection<Dictionary<string, object>> entities, Dictionary<string, object> protocol,
            bool ownership, Vector3 startPos, IPlayer player, bool stability, float rotationCorrection,
            float heightAdj, bool auth, Action callback, Action<BaseEntity> callbackSpawned, string filename, bool checkPlaced)
        {
            //Settings

            var isItemReplace = !protocol.ContainsKey("items");

            var eulerRotation = new Vector3(0f, rotationCorrection * 57.2958f, 0f);
            var quaternionRotation = Quaternion.Euler(eulerRotation);

            var pasteData = new PasteData
            {
                HeightAdj = heightAdj,
                IsItemReplace = isItemReplace,
                Entities = entities,
                Player = player,
                BasePlayer = player.Object as BasePlayer,
                QuaternionRotation = quaternionRotation,
                StartPos = startPos,
                Stability = stability,
                Auth = auth,
                Ownership = ownership,
                CallbackFinished = callback,
                CallbackSpawned = callbackSpawned,
                Filename = filename,
                CheckPlaced = checkPlaced
            };

            NextTick(() => PasteLoop(pasteData));

            return pasteData;
        }

        private void PasteLoop(PasteData pasteData)
        {
            if (pasteData.Cancelled)
            {
                UndoLoop(new HashSet<BaseEntity>(pasteData.PastedEntities), pasteData.Player,
                    pasteData.PastedEntities.Count);
                
                return;
            }

            var entities = pasteData.Entities;
            var todo = entities.Take(_config.PasteBatchSize).ToArray();

            foreach (var data in todo)
            {
                entities.Remove(data);

                var prefabname = (string)data["prefabname"];
#if DEBUG
                Puts($"{nameof(PasteLoop)}: Entity {prefabname}");
#endif

                var skinid = ulong.Parse(data["skinid"].ToString());
                var pos = (Vector3)data["position"];
                var rot = (Quaternion)data["rotation"];

                var ownerId = pasteData.BasePlayer?.userID ?? 0;
                if (data.ContainsKey("ownerid"))
                {
#if DEBUG
                    Puts($"{nameof(PasteLoop)}: Convert.ToUInt64 1077");
#endif
                    ownerId = Convert.ToUInt64(data["ownerid"]);
                }

                if (pasteData.CheckPlaced && CheckPlaced(prefabname, pos, rot))
                    continue;

                if (prefabname.Contains("pillar"))
                    continue;

                // Used to copy locks for no reason in previous versions (is included in the slots info so no need to copy locks) so just skipping them.
                if (prefabname.Contains("locks"))
                    continue;

                var entity = GameManager.server.CreateEntity(prefabname, pos, rot);

                if (entity == null)
                    continue;

                var transform = entity.transform;
                transform.position = pos;
                transform.rotation = rot;

                if (pasteData.BasePlayer != null)
                    entity.SendMessage("SetDeployedBy", pasteData.BasePlayer, SendMessageOptions.DontRequireReceiver);

                if (pasteData.Ownership)
                    entity.OwnerID = ownerId;

                var buildingBlock = entity as BuildingBlock;

                if (buildingBlock != null)
                {
                    buildingBlock.blockDefinition = PrefabAttribute.server.Find<Construction>(buildingBlock.prefabID);
                    if (buildingBlock.skinID != 10220) buildingBlock.skinID = 0uL;
                    buildingBlock.SetGrade((BuildingGrade.Enum)data["grade"]);
                    if (!pasteData.Stability)
                        buildingBlock.grounded = true;
                }

                var decayEntity = entity as DecayEntity;

                if (decayEntity != null)
                {
                    if (pasteData.BuildingId == 0)
                        pasteData.BuildingId = BuildingManager.server.NewBuildingID();

                    decayEntity.AttachToBuilding(pasteData.BuildingId);
                }

                var stabilityEntity = entity as StabilityEntity;

                if (stabilityEntity != null)
                {
                    if (!stabilityEntity.grounded)
                    {
                        stabilityEntity.grounded = true;
                        pasteData.StabilityEntities.Add(stabilityEntity);
                    }
                }

                if (buildingBlock == null)
                    entity.skinID = skinid;

                entity.Spawn();

                var baseCombat = entity as BaseCombatEntity;

                if (buildingBlock != null)
                {
                    buildingBlock.SetHealthToMax();
                    buildingBlock.SendNetworkUpdate();
                    buildingBlock.UpdateSkin();
                }
                else if (baseCombat != null)
                    baseCombat.SetHealth(baseCombat.MaxHealth());

                pasteData.PastedEntities.AddRange(TryPasteSlots(entity, data, pasteData));

                var box = entity as StorageContainer;
                if (box != null)
                {
                    if (box.inventory == null)
                    {
                        box.inventory = new ItemContainer();
                        box.inventory.ServerInitialize(null, box.inventorySlots);
                        box.inventory.GiveUID();
                        box.inventory.entityOwner = box;
                    }
                    else box.inventory.Clear();

                    var items = new List<object>();

                    if (data.ContainsKey("items"))
                        items = data["items"] as List<object>;

                    foreach (var itemDef in items)
                    {
                        var item = itemDef as Dictionary<string, object>;
                        var itemid = Convert.ToInt32(item["id"]);
                        var itemamount = Convert.ToInt32(item["amount"]);
                        var itemskin = ulong.Parse(item["skinid"].ToString());
                        var itemcondition = Convert.ToSingle(item["condition"]);
                        var dataInt = 0;
                        if (item.ContainsKey("dataInt"))
                        {
                            dataInt = Convert.ToInt32(item["dataInt"]);
                        }

                        var growableEntity = entity as GrowableEntity;
                        if (growableEntity != null)
                        {
                            if (data.ContainsKey("genes"))
                            {
                                var genesData = (int)data["genes"];

                                if (genesData > 0)
                                {
                                    GrowableGeneEncoding.DecodeIntToGenes(genesData, growableEntity.Genes);
                                }
                            }

                            if (data.ContainsKey("hasParent"))
                            {
                                var isParented = (bool)data["hasParent"];

                                if (isParented)
                                {
                                    RaycastHit hitInfo;

                                    if (Physics.Raycast(growableEntity.transform.position, Vector3.down, out hitInfo,
                                            .5f, Rust.Layers.DefaultDeployVolumeCheck))
                                    {
                                        var parentEntity = hitInfo.GetEntity();
                                        if (parentEntity != null)
                                        {
                                            growableEntity.SetParent(parentEntity, true);
                                        }
                                    }
                                }
                            }
                        }

                        if (pasteData.IsItemReplace)
                            itemid = GetItemId(itemid);

                        var i = ItemManager.CreateByItemID(itemid, itemamount, itemskin);

                        if (i != null)
                        {
                            i.condition = itemcondition;

                            if (item.ContainsKey("text"))
                                i.text = item["text"].ToString();

                            if (item.ContainsKey("blueprintTarget"))
                            {
                                var blueprintTarget = Convert.ToInt32(item["blueprintTarget"]);

                                if (pasteData.IsItemReplace)
                                    blueprintTarget = GetItemId(blueprintTarget);

                                i.blueprintTarget = blueprintTarget;
                            }

                            if (dataInt > 0)
                            {
                                i.instanceData = new ProtoBuf.Item.InstanceData()
                                {
                                    ShouldPool = false,
                                    dataInt = dataInt
                                };
                            }

                            if (item.ContainsKey("magazine"))
                            {
                                var heldent = i.GetHeldEntity();

                                if (heldent != null)
                                {
                                    var projectiles = heldent.GetComponent<BaseProjectile>();

                                    if (projectiles != null)
                                    {
                                        var magazine = item["magazine"] as Dictionary<string, object>;
                                        var ammotype = int.Parse(magazine.Keys.ToArray()[0]);
                                        var ammoamount = int.Parse(magazine[ammotype.ToString()].ToString());

                                        if (pasteData.IsItemReplace)
                                            ammotype = GetItemId(ammotype);

                                        projectiles.primaryMagazine.ammoType = ItemManager.FindItemDefinition(ammotype);
                                        projectiles.primaryMagazine.contents = ammoamount;
                                    }

                                    //TODO Doesn't add water to some containers

                                    if (item.ContainsKey("items"))
                                    {
                                        var itemContainsList = item["items"] as List<object>;

                                        foreach (var itemContains in itemContainsList)
                                        {
                                            var contents = itemContains as Dictionary<string, object>;

                                            var contentsItemId = Convert.ToInt32(contents["id"]);

                                            if (pasteData.IsItemReplace)
                                                contentsItemId = GetItemId(contentsItemId);

                                            i.contents.AddItem(ItemManager.FindItemDefinition(contentsItemId),
                                                Convert.ToInt32(contents["amount"]));
                                        }
                                    }
                                }
                            }

                            var targetPos = -1;

                            if (item.ContainsKey("position"))
                                targetPos = Convert.ToInt32(item["position"]);

                            i.position = targetPos;
                            box.inventory.Insert(i);
                        }
                    }
                }

                var autoTurret = entity as AutoTurret;
                if (autoTurret != null)
                {
                    var authorizedPlayers = new List<ulong>();

                    if (data.ContainsKey("autoturret"))
                    {
#if DEBUG
                        Puts($"{nameof(PasteLoop)}: Convert.ToUInt64 1305");
#endif
                        var autoTurretData = data["autoturret"] as Dictionary<string, object>;
                        authorizedPlayers = (autoTurretData["authorizedPlayers"] as List<object>)
                            .Select(Convert.ToUInt64).ToList();
                    }

                    if (pasteData.BasePlayer != null && !authorizedPlayers.Contains(pasteData.BasePlayer.userID) &&
                        pasteData.Auth)
                        authorizedPlayers.Add(pasteData.BasePlayer.userID);

                    foreach (var userId in authorizedPlayers)
                    {
                        autoTurret.authorizedPlayers.Add(new PlayerNameID
                        {
                            userid = userId,
                            username = "Player"
                        });
                    }

                    autoTurret.SendNetworkUpdate();
                }

                var containerIo = entity as ContainerIOEntity;
                if (containerIo != null)
                {
                    if (containerIo.inventory == null)
                    {
                        containerIo.CreateInventory(true);
                        containerIo.OnInventoryFirstCreated(containerIo.inventory);
                    }
                    else containerIo.inventory.Clear();

                    var items = new List<object>();

                    if (data.ContainsKey("items"))
                        items = data["items"] as List<object>;

                    foreach (var itemDef in items)
                    {
                        var itemJson = itemDef as Dictionary<string, object>;
                        var itemid = Convert.ToInt32(itemJson["id"]);
                        var itemamount = Convert.ToInt32(itemJson["amount"]);
                        var itemskin = ulong.Parse(itemJson["skinid"].ToString());
                        var itemcondition = Convert.ToSingle(itemJson["condition"]);
                        var dataInt = 0;
                        if (itemJson.ContainsKey("dataInt"))
                        {
                            dataInt = Convert.ToInt32(itemJson["dataInt"]);
                        }

                        if (pasteData.IsItemReplace)
                            itemid = GetItemId(itemid);

                        var item = ItemManager.CreateByItemID(itemid, itemamount, itemskin);

                        if (item != null)
                        {
                            item.condition = itemcondition;

                            if (itemJson.ContainsKey("text"))
                                item.text = itemJson["text"].ToString();

                            if (itemJson.ContainsKey("blueprintTarget"))
                            {
                                var blueprintTarget = Convert.ToInt32(itemJson["blueprintTarget"]);

                                if (pasteData.IsItemReplace)
                                    blueprintTarget = GetItemId(blueprintTarget);

                                item.blueprintTarget = blueprintTarget;
                            }

                            if (dataInt > 0)
                            {
                                item.instanceData = new ProtoBuf.Item.InstanceData()
                                {
                                    ShouldPool = false,
                                    dataInt = dataInt
                                };
                            }

                            if (itemJson.ContainsKey("magazine"))
                            {
                                var heldent = item.GetHeldEntity();

                                if (heldent != null)
                                {
                                    var projectiles = heldent.GetComponent<BaseProjectile>();

                                    if (projectiles != null)
                                    {
                                        var magazine = itemJson["magazine"] as Dictionary<string, object>;
                                        var ammotype = int.Parse(magazine.Keys.ToArray()[0]);
                                        var ammoamount = int.Parse(magazine[ammotype.ToString()].ToString());

                                        if (pasteData.IsItemReplace)
                                            ammotype = GetItemId(ammotype);

                                        projectiles.primaryMagazine.ammoType = ItemManager.FindItemDefinition(ammotype);
                                        projectiles.primaryMagazine.contents = ammoamount;
                                    }

                                    //TODO Doesn't add water to some containers

                                    if (itemJson.ContainsKey("items"))
                                    {
                                        var itemContainsList = itemJson["items"] as List<object>;

                                        foreach (var itemContains in itemContainsList)
                                        {
                                            var contents = itemContains as Dictionary<string, object>;

                                            var contentsItemId = Convert.ToInt32(contents["id"]);

                                            if (pasteData.IsItemReplace)
                                                contentsItemId = GetItemId(contentsItemId);

                                            item.contents.AddItem(ItemManager.FindItemDefinition(contentsItemId),
                                                Convert.ToInt32(contents["amount"]));
                                        }
                                    }
                                }
                            }

                            var targetPos = -1;
                            if (itemJson.ContainsKey("position"))
                                targetPos = Convert.ToInt32(itemJson["position"]);

                            item.position = targetPos;
                            containerIo.inventory.Insert(item);
                        }
                    }

                    if (autoTurret != null)
                    {
                        autoTurret.Invoke(autoTurret.UpdateAttachedWeapon, 0.5f);
                    }

                    containerIo.SendNetworkUpdate();
                }

                var sign = entity as Signage;
                if (sign != null && data.ContainsKey("sign"))
                {
                    var signData = data["sign"] as Dictionary<string, object>;

                    if (signData.ContainsKey("amount"))
                    {
                        int amount;
                        if (int.TryParse(signData["amount"].ToString(), out amount))
                        {
                            for (var num = 0; num < amount; num++)
                            {
                                if (signData.ContainsKey($"texture{num}"))
                                {
                                    var imageBytes = Convert.FromBase64String(signData[$"texture{num}"].ToString());

                                    FixSignage(sign, imageBytes, num);
                                }
                            }
                        }
                    }
                    else if (signData.ContainsKey("texture"))
                    {
                        var imageBytes = Convert.FromBase64String(signData["texture"].ToString());

                        FixSignage(sign, imageBytes, 0);
                    }

                    if (Convert.ToBoolean(signData["locked"]))
                        sign.SetFlag(BaseEntity.Flags.Locked, true);

                    sign.SendNetworkUpdate();
                }

                var lights = entity as AdvancedChristmasLights;
                if (lights != null)
                {
                    if (data.ContainsKey("points"))
                    {
                        var points = data["points"] as List<object>;
                        if (points != null && points.Count > 0)
                        {
                            foreach (Dictionary<string, object> point in points)
                            {
                                lights.points.Add(new AdvancedChristmasLights.pointEntry
                                    { normal = (Vector3)point["normal"], point = (Vector3)point["point"] });
                            }
                        }
                    }

                    if (data.ContainsKey("animationStyle"))
                    {
                        lights.animationStyle = (AdvancedChristmasLights.AnimationType)data["animationStyle"];
                    }
                }

                var sleepingBag = entity as SleepingBag;
                if (sleepingBag != null && data.ContainsKey("sleepingbag"))
                {
                    var bagData = data["sleepingbag"] as Dictionary<string, object>;

                    sleepingBag.niceName = bagData["niceName"].ToString();
                    sleepingBag.deployerUserID = ulong.Parse(bagData["deployerUserID"].ToString());
                    sleepingBag.SetPublic(Convert.ToBoolean(bagData["isPublic"]));
                }

                var cupboard = entity as BuildingPrivlidge;
                if (cupboard != null)
                {
                    var authorizedPlayers = new List<ulong>();

                    if (data.ContainsKey("cupboard"))
                    {
#if DEBUG
                        Puts($"{nameof(PasteLoop)}: Convert.ToUInt64 1521");
#endif
                        var cupboardData = data["cupboard"] as Dictionary<string, object>;
                        authorizedPlayers = (cupboardData["authorizedPlayers"] as List<object>).Select(Convert.ToUInt64)
                            .ToList();
                    }

                    if (pasteData.BasePlayer != null && !authorizedPlayers.Contains(pasteData.BasePlayer.userID) &&
                        pasteData.Auth)
                        authorizedPlayers.Add(pasteData.BasePlayer.userID);

                    foreach (var userId in authorizedPlayers)
                    {
                        cupboard.authorizedPlayers.Add(new PlayerNameID
                        {
                            userid = userId,
                            username = "Player"
                        });
                    }

                    cupboard.SendNetworkUpdate();
                }

                var cctvRc = entity as CCTV_RC;
                if (cctvRc != null && data.ContainsKey("cctv"))
                {
                    var cctv = (Dictionary<string, object>)data["cctv"];
                    cctvRc.yawAmount = Convert.ToSingle(cctv["yaw"]);
                    cctvRc.pitchAmount = Convert.ToSingle(cctv["pitch"]);
                    cctvRc.rcIdentifier = cctv["rcIdentifier"].ToString();
                    cctvRc.SendNetworkUpdate();
                }

                var vendingMachine = entity as VendingMachine;
                if (vendingMachine != null && data.ContainsKey("vendingmachine"))
                {
                    var vendingData = data["vendingmachine"] as Dictionary<string, object>;

                    vendingMachine.shopName = vendingData["shopName"].ToString();
                    vendingMachine.SetFlag(BaseEntity.Flags.Reserved4,
                        Convert.ToBoolean(vendingData["isBroadcasting"]));

                    var sellOrders = vendingData["sellOrders"] as List<object>;

                    foreach (var orderPreInfo in sellOrders)
                    {
                        var orderInfo = orderPreInfo as Dictionary<string, object>;

                        if (!orderInfo.ContainsKey("inStock"))
                        {
                            orderInfo["inStock"] = 0;
                            orderInfo["currencyIsBP"] = false;
                            orderInfo["itemToSellIsBP"] = false;
                        }

                        int itemToSellId = Convert.ToInt32(orderInfo["itemToSellID"]),
                            currencyId = Convert.ToInt32(orderInfo["currencyID"]);

                        if (pasteData.IsItemReplace)
                        {
                            itemToSellId = GetItemId(itemToSellId);
                            currencyId = GetItemId(currencyId);
                        }

                        vendingMachine.sellOrders.sellOrders.Add(new ProtoBuf.VendingMachine.SellOrder
                        {
                            ShouldPool = false,
                            itemToSellID = itemToSellId,
                            itemToSellAmount = Convert.ToInt32(orderInfo["itemToSellAmount"]),
                            currencyID = currencyId,
                            currencyAmountPerItem = Convert.ToInt32(orderInfo["currencyAmountPerItem"]),
                            inStock = Convert.ToInt32(orderInfo["inStock"]),
                            currencyIsBP = Convert.ToBoolean(orderInfo["currencyIsBP"]),
                            itemToSellIsBP = Convert.ToBoolean(orderInfo["itemToSellIsBP"])
                        });
                    }

                    vendingMachine.FullUpdate();
                }

                var ioEntity = entity as IOEntity;

                if (ioEntity != null)
                {
                    var ioData = new Dictionary<string, object>();

                    if (data.ContainsKey("IOEntity"))
                    {
                        ioData = data["IOEntity"] as Dictionary<string, object> ?? new Dictionary<string, object>();
                    }

                    ioData.Add("entity", ioEntity);
                    ioData.Add("newId", ioEntity.net.ID.Value);

                    object oldIdObject;
                    if (ioData.TryGetValue("oldID", out oldIdObject))
                    {
#if DEBUG
                        Puts($"{nameof(PasteLoop)}: Convert.ToUInt64 1619");
#endif
                        var oldId = Convert.ToUInt64(oldIdObject);
                        pasteData.IoEntities.Add(oldId, ioData);
                    }
                }

                var flagsData = new Dictionary<string, object>();

                if (data.ContainsKey("flags"))
                    flagsData = data["flags"] as Dictionary<string, object>;

                var flags = new Dictionary<BaseEntity.Flags, bool>();

                foreach (var flagData in flagsData)
                {
                    BaseEntity.Flags baseFlag;
                    if (Enum.TryParse(flagData.Key, out baseFlag))
                        flags.Add(baseFlag, Convert.ToBoolean(flagData.Value));
                }

                foreach (var flag in flags)
                {
                    entity.SetFlag(flag.Key, flag.Value);
                }

                pasteData.PastedEntities.Add(entity);
                pasteData.CallbackSpawned?.Invoke(entity);
            }

            if (entities.Count > 0)
                NextTick(() => PasteLoop(pasteData));
            else
            {
                foreach (var ioData in pasteData.IoEntities.Values.ToArray())
                {
                    if (!ioData.ContainsKey("entity"))
                        continue;


                    var ioEntity = ioData["entity"] as IOEntity;

                    List<object> inputs = null;
                    if (ioData.ContainsKey("inputs"))
                        inputs = ioData["inputs"] as List<object>;

                    var electricalBranch = ioEntity as ElectricalBranch;
                    if (electricalBranch != null && ioData.ContainsKey("branchAmount"))
                    {
                        electricalBranch.branchAmount = Convert.ToInt32(ioData["branchAmount"]);
                    }

                    var counter = ioEntity as PowerCounter;
                    if (counter != null && ioData.ContainsKey("targetNumber"))
                    {
                        counter.targetCounterNumber = Convert.ToInt32(ioData["targetNumber"]);
                    }

                    var timer = ioEntity as TimerSwitch;
                    if (timer != null && ioData.ContainsKey("timerLength"))
                    {
                        timer.timerLength = Convert.ToInt32(ioData["timerLength"]);
                    }

                    var rfBroadcaster = ioEntity as RFBroadcaster;
                    if (rfBroadcaster != null && ioData.ContainsKey("frequency"))
                    {
                        rfBroadcaster.frequency = Convert.ToInt32(ioData["frequency"]);
                    }

                    var rfReceiver = ioEntity as RFReceiver;
                    if (rfReceiver != null && ioData.ContainsKey("frequency"))
                    {
                        rfReceiver.frequency = Convert.ToInt32(ioData["frequency"]);
                    }

                    var doorManipulator = ioEntity as CustomDoorManipulator;
                    if (doorManipulator != null)
                    {
                        var door = doorManipulator.FindDoor();
                        doorManipulator.SetTargetDoor(door);
                    }

                    if (inputs != null && inputs.Count > 0)
                    {
                        for (var index = 0; index < inputs.Count; index++)
                        {
                            var input = inputs[index] as Dictionary<string, object>;
                            object oldIdObject;
                            if (!input.TryGetValue("connectedID", out oldIdObject))
                                continue;

#if DEBUG
                            Puts($"{nameof(PasteLoop)}: Convert.ToUInt64 1712");
#endif
                            var oldId = Convert.ToUInt64(oldIdObject);

                            if (oldId != 0 && pasteData.IoEntities.ContainsKey(oldId))
                            {
                                if (ioEntity.inputs[index] == null)
                                    ioEntity.inputs[index] = new IOEntity.IOSlot();

                                var ioConnection = pasteData.IoEntities[oldId];
                                if (ioConnection.ContainsKey("newId"))
                                {
#if DEBUG
                    Puts($"{nameof(PasteLoop)}: Convert.ToUInt64 1719");
#endif
                                    ioEntity.inputs[index].connectedTo.entityRef.uid =
                                        new NetworkableId(Convert.ToUInt64(ioConnection["newId"]));
                                }
                            }
                        }
                    }

                    List<object> outputs = null;
                    if (ioData.ContainsKey("outputs"))
                        outputs = ioData["outputs"] as List<object>;

                    if (outputs != null && outputs.Count > 0)
                    {
                        for (var index = 0; index < outputs.Count; index++)
                        {
                            var output = outputs[index] as Dictionary<string, object>;
#if DEBUG
                            Puts($"{nameof(PasteLoop)}: Convert.ToUInt64 1744");
#endif
                            var oldId = Convert.ToUInt64(output["connectedID"]);

                            if (oldId != 0 && pasteData.IoEntities.ContainsKey(oldId))
                            {
                                if (ioEntity.outputs[index] == null)
                                    ioEntity.outputs[index] = new IOEntity.IOSlot();

                                var ioConnection = pasteData.IoEntities[oldId];

                                if (ioConnection.ContainsKey("newId"))
                                {
                                    var ioEntity2 = ioConnection["entity"] as IOEntity;
                                    var connectedToSlot = Convert.ToInt32(output["connectedToSlot"]);
                                    var ioOutput = ioEntity.outputs[index];

                                    ioOutput.connectedTo = new IOEntity.IORef();
                                    ioOutput.connectedTo.Set(ioEntity2);
                                    ioOutput.connectedToSlot = connectedToSlot;
                                    ioOutput.connectedTo.Init();

                                    ioEntity2.inputs[connectedToSlot].connectedTo = new IOEntity.IORef();
                                    ioEntity2.inputs[connectedToSlot].connectedTo.Set(ioEntity);
                                    ioEntity2.inputs[connectedToSlot].connectedToSlot = index;
                                    ioEntity2.inputs[connectedToSlot].connectedTo.Init();

                                    ioOutput.niceName = output["niceName"] as string;

                                    ioOutput.type = (IOEntity.IOType)Convert.ToInt32(output["type"]);
                                }

                                if (output.ContainsKey("linePoints"))
                                {
                                    var linePoints = output["linePoints"] as List<object>;
                                    if (linePoints != null)
                                    {
                                        var lineList = new List<Vector3>();
                                        foreach (var point in linePoints)
                                        {
                                            var linePoint = point as Dictionary<string, object>;
                                            lineList.Add(new Vector3(
                                                Convert.ToSingle(linePoint["x"]),
                                                Convert.ToSingle(linePoint["y"]),
                                                Convert.ToSingle(linePoint["z"])));
                                        }

                                        ioEntity.outputs[index].linePoints = lineList.ToArray();
                                    }
                                }
                            }
                        }
                    }

                    ioEntity.MarkDirtyForceUpdateOutputs();
                    ioEntity.SendNetworkUpdate();
                }

                foreach (var entity in pasteData.StabilityEntities)
                {
                    entity.grounded = false;
                    entity.InitializeSupports();
                    entity.UpdateStability();
                }

                pasteData.Player.Reply(Lang("PASTE_SUCCESS", pasteData.Player.Id));
#if DEBUG
                pasteData.Player.Reply($"Stopwatch took: {pasteData.Sw.Elapsed.TotalMilliseconds} ms");
#endif

                if (!_lastPastes.ContainsKey(pasteData.Player.Id))
                    _lastPastes[pasteData.Player.Id] = new Stack<List<BaseEntity>>();

                _lastPastes[pasteData.Player.Id].Push(pasteData.PastedEntities);

                pasteData.CallbackFinished?.Invoke();

                Interface.CallHook("OnPasteFinished", pasteData.PastedEntities, pasteData.Filename, pasteData.Player, pasteData.StartPos);
            }
        }

        private HashSet<Dictionary<string, object>> PreLoadData(List<object> entities, Vector3 startPos,
            float rotationCorrection, bool deployables, bool inventories, bool auth, bool vending)
        {
            var eulerRotation = new Vector3(0f, rotationCorrection, 0f);
            var quaternionRotation = Quaternion.EulerRotation(eulerRotation);
            var preloaddata = new HashSet<Dictionary<string, object>>();

            foreach (Dictionary<string, object> entity in entities)
            {
                if (!deployables && !entity.ContainsKey("grade"))
                    continue;

                var pos = (Dictionary<string, object>)entity["pos"];
                var rot = (Dictionary<string, object>)entity["rot"];

                entity.Add("position",
                    quaternionRotation * new Vector3(Convert.ToSingle(pos["x"]), Convert.ToSingle(pos["y"]),
                        Convert.ToSingle(pos["z"])) + startPos);
                entity.Add("rotation",
                    Quaternion.EulerRotation(eulerRotation + new Vector3(Convert.ToSingle(rot["x"]),
                        Convert.ToSingle(rot["y"]), Convert.ToSingle(rot["z"]))));

                if (!inventories && entity.ContainsKey("items"))
                    entity["items"] = new List<object>();

                if (!vending && entity["prefabname"].ToString().Contains("vendingmachine"))
                    entity.Remove("vendingmachine");

                preloaddata.Add(entity);
            }

            return preloaddata;
        }

        private object TryCopy(Vector3 sourcePos, Vector3 sourceRot, string filename, float rotationCorrection,
            string[] args, IPlayer player, Action callback)
        {
            bool saveShare = _config.Copy.Share, saveTree = _config.Copy.Tree, eachToEach = _config.Copy.EachToEach;
            var copyMechanics = CopyMechanics.Proximity;
            var radius = _config.Copy.Radius;

            for (var i = 0;; i += 2)
            {
                if (i >= args.Length)
                    break;

                var valueIndex = i + 1;

                if (valueIndex >= args.Length)
                    return Lang("SYNTAX_COPY");

                var param = args[i].ToLower();

                switch (param)
                {
                    case "e":
                    case "each":
                        if (!bool.TryParse(args[valueIndex], out eachToEach))
                            return Lang("SYNTAX_BOOL", null, param);

                        break;

                    case "m":
                    case "method":
                        switch (args[valueIndex].ToLower())
                        {
                            case "b":
                            case "building":
                                copyMechanics = CopyMechanics.Building;
                                break;

                            case "p":
                            case "proximity":
                                copyMechanics = CopyMechanics.Proximity;
                                break;
                        }

                        break;

                    case "r":
                    case "radius":
                        if (!float.TryParse(args[valueIndex], out radius))
                            return Lang("SYNTAX_RADIUS");

                        break;

                    case "s":
                    case "share":
                        if (!bool.TryParse(args[valueIndex], out saveShare))
                            return Lang("SYNTAX_BOOL", null, param);

                        break;

                    case "t":
                    case "tree":
                        if (!bool.TryParse(args[valueIndex], out saveTree))
                            return Lang("SYNTAX_BOOL", null, param);

                        break;

                    default:
                        return Lang("SYNTAX_COPY");
                }
            }

            Copy(sourcePos, sourceRot, filename, rotationCorrection, copyMechanics, radius, saveTree, saveShare,
                eachToEach, player, callback);

            return true;
        }

        private void TryCopySlots(BaseEntity ent, IDictionary<string, object> housedata, bool saveShare)
        {
            foreach (var slot in _checkSlots)
            {
                if (!ent.HasSlot(slot))
                    continue;

                var slotEntity = ent.GetSlot(slot);

                if (slotEntity == null)
                    continue;

                var codedata = new Dictionary<string, object>
                {
                    { "prefabname", slotEntity.PrefabName },
                    { "flags", TryCopyFlags(ent) }
                };

                if (slotEntity.GetComponent<CodeLock>())
                {
                    var codeLock = slotEntity.GetComponent<CodeLock>();

                    codedata.Add("code", codeLock.code);

                    if (saveShare)
                        codedata.Add("whitelistPlayers", codeLock.whitelistPlayers);

                    if (codeLock.guestCode != null && codeLock.guestCode.Length == 4)
                    {
                        codedata.Add("guestCode", codeLock.guestCode);

                        if (saveShare)
                            codedata.Add("guestPlayers", codeLock.guestPlayers);
                    }
                }
                else if (slotEntity.GetComponent<KeyLock>())
                {
                    var keyLock = slotEntity.GetComponent<KeyLock>();
                    var code = keyLock.keyCode;

                    if (keyLock.firstKeyCreated)
                        code |= 0x80;

                    codedata.Add("ownerId", keyLock.OwnerID.ToString());
                    codedata.Add("code", code.ToString());
                }

                var slotName = slot.ToString().ToLower();

                housedata.Add(slotName, codedata);
            }
        }

        private Dictionary<string, object> TryCopyFlags(BaseEntity entity)
        {
            var flags = new Dictionary<string, object>();

            foreach (BaseEntity.Flags flag in Enum.GetValues(typeof(BaseEntity.Flags)))
            {
                if (!_config.DataSaving || entity.HasFlag(flag))
                    flags.Add(flag.ToString(), entity.HasFlag(flag));
            }

            return flags;
        }

        private ValueTuple<object, PasteData> TryPaste(Vector3 startPos, string filename, IPlayer player,
            float rotationCorrection,
            string[] args, bool autoHeight = true, Action callback = null,
            Action<BaseEntity> callbackSpawned = null)
        {
            var userId = player?.Id;

            var path = _subDirectory + filename;

            if (!Interface.Oxide.DataFileSystem.ExistsDatafile(path))
                return new ValueTuple<object, PasteData>(Lang("FILE_NOT_EXISTS", userId), null);

            var data = Interface.Oxide.DataFileSystem.GetDatafile(path);

            if (data["default"] == null || data["entities"] == null)
                return new ValueTuple<object, PasteData>(Lang("FILE_BROKEN", userId), null);

            float heightAdj = 0f, blockCollision = 0f;
            bool auth = _config.Paste.Auth,
                inventories = _config.Paste.Inventories,
                deployables = _config.Paste.Deployables,
                vending = _config.Paste.VendingMachines,
                stability = _config.Paste.Stability,
                ownership = _config.Paste.EntityOwner,
                checkPlaced = true;

            for (var i = 0;; i += 2)
            {
                if (i >= args.Length)
                    break;

                var valueIndex = i + 1;

                if (valueIndex >= args.Length)
                    return new ValueTuple<object, PasteData>(Lang("SYNTAX_PASTE_OR_PASTEBACK", userId), null);

                var param = args[i].ToLower();

                switch (param)
                {
                    case "a":
                    case "auth":
                        if (!bool.TryParse(args[valueIndex], out auth))
                            return new ValueTuple<object, PasteData>(Lang("SYNTAX_BOOL", userId, param), null);

                        break;

                    case "b":
                    case "blockcollision":
                        if (!float.TryParse(args[valueIndex], out blockCollision))
                            return new ValueTuple<object, PasteData>(Lang("SYNTAX_BLOCKCOLLISION", userId), null);

                        break;

                    case "d":
                    case "deployables":
                        if (!bool.TryParse(args[valueIndex], out deployables))
                            return new ValueTuple<object, PasteData>(Lang("SYNTAX_BOOL", userId, param), null);

                        break;

                    case "h":
                    case "height":
                        if (!float.TryParse(args[valueIndex], out heightAdj))
                            return new ValueTuple<object, PasteData>(Lang("SYNTAX_HEIGHT", userId), null);

                        break;

                    case "i":
                    case "inventories":
                        if (!bool.TryParse(args[valueIndex], out inventories))
                            return new ValueTuple<object, PasteData>(Lang("SYNTAX_BOOL", userId, param), null);

                        break;

                    case "s":
                    case "stability":
                        if (!bool.TryParse(args[valueIndex], out stability))
                            return new ValueTuple<object, PasteData>(Lang("SYNTAX_BOOL", userId, param), null);

                        break;

                    case "v":
                    case "vending":
                        if (!bool.TryParse(args[valueIndex], out vending))
                            return new ValueTuple<object, PasteData>(Lang("SYNTAX_BOOL", userId, param), null);

                        break;

                    case "o":
                    case "entityowner":
                        if (!bool.TryParse(args[valueIndex], out ownership))
                            return new ValueTuple<object, PasteData>(Lang("SYNTAX_BOOL", userId, param), null);

                        break;

                    case "cp":
                    case "checkplaced":
                        if (!bool.TryParse(args[valueIndex], out checkPlaced))
                            return new ValueTuple<object, PasteData>(Lang("SYNTAX_BOOL", userId, param), null);

                        break;

                    case "autoheight":
                        if (!bool.TryParse(args[valueIndex], out autoHeight))
                            return new ValueTuple<object, PasteData>(Lang("SYNTAX_BOOL", userId, param), null);

                        break;

                    case "position":
                        startPos = args[valueIndex].ToVector3();
                        break;

                    case "rotation":
                        if (!float.TryParse(args[valueIndex], out rotationCorrection))
                            return new ValueTuple<object, PasteData>(Lang("SYNTAX_FLOAT", userId, param), null);

                        break;

                    default:
                        return new ValueTuple<object, PasteData>(Lang("SYNTAX_PASTE_OR_PASTEBACK", userId), null);
                }
            }

            startPos.y += heightAdj;

            var preloadData = PreLoadData(data["entities"] as List<object>, startPos, rotationCorrection, deployables,
                inventories, auth, vending);

            if (autoHeight)
            {
                var bestHeight = FindBestHeight(preloadData, startPos);

                if (bestHeight is string)
                    return new ValueTuple<object, PasteData>(bestHeight, null);

                heightAdj += (float)bestHeight - startPos.y;

                foreach (var entity in preloadData)
                {
                    var pos = (Vector3)entity["position"];
                    pos.y += heightAdj;

                    entity["position"] = pos;
                }
            }

            if (blockCollision > 0f)
            {
                var collision = CheckCollision(preloadData, startPos, blockCollision);

                if (collision is string)
                    return new ValueTuple<object, PasteData>(collision, null);
            }

            var protocol = new Dictionary<string, object>();

            if (data["protocol"] != null)
                protocol = data["protocol"] as Dictionary<string, object>;

            var pasteData = Paste(preloadData, protocol, ownership, startPos, player, stability, rotationCorrection,
                autoHeight ? heightAdj : 0, auth, callback, callbackSpawned, filename, checkPlaced);

            return new ValueTuple<object, PasteData>(true, pasteData);
        }

        private List<BaseEntity> TryPasteSlots(BaseEntity ent, Dictionary<string, object> structure,
            PasteData pasteData)
        {
            var entitySlots = new List<BaseEntity>();

            foreach (var slot in _checkSlots)
            {
                var slotName = slot.ToString().ToLower();

                if (!ent.HasSlot(slot) || !structure.ContainsKey(slotName))
                    continue;

                var slotData = structure[slotName] as Dictionary<string, object>;
                var slotEntity = GameManager.server.CreateEntity((string)slotData?["prefabname"], Vector3.zero);
                if (slotEntity == null)
                    continue;

                slotEntity.gameObject.Identity();
                slotEntity.SetParent(ent, slotName);
                slotEntity.OnDeployed(ent, null, _emptyItem);
                slotEntity.Spawn();

                ent.SetSlot(slot, slotEntity);

                entitySlots.Add(slotEntity);

                if (slotName != "lock" || !slotData.ContainsKey("code"))
                    continue;

                if (slotEntity.GetComponent<CodeLock>())
                {
                    var code = (string)slotData["code"];

                    if (!string.IsNullOrEmpty(code))
                    {
                        var codeLock = slotEntity.GetComponent<CodeLock>();
                        codeLock.code = code;
                        codeLock.hasCode = true;

                        if (pasteData.Auth && pasteData.BasePlayer != null)
                            codeLock.whitelistPlayers.Add(pasteData.BasePlayer.userID);

                        if (slotData.ContainsKey("whitelistPlayers"))
                        {
                            foreach (var userId in (List<object>)slotData["whitelistPlayers"])
                            {
#if DEBUG
                                Puts($"{nameof(PasteLoop)}: Convert.ToUInt64 2206");
#endif
                                codeLock.whitelistPlayers.Add(Convert.ToUInt64(userId));
                            }
                        }

                        if (slotData.ContainsKey("guestCode"))
                        {
                            var guestCode = (string)slotData["guestCode"];

                            codeLock.guestCode = guestCode;
                            codeLock.hasGuestCode = true;

                            if (slotData.ContainsKey("guestPlayers"))
                            {
                                foreach (var userId in (List<object>)slotData["guestPlayers"])
                                {
#if DEBUG
                                    Puts($"{nameof(PasteLoop)}: Convert.ToUInt64 2224");
#endif
                                    codeLock.guestPlayers.Add(Convert.ToUInt64(userId));
                                }
                            }
                        }

                        codeLock.SetFlag(BaseEntity.Flags.Locked, true);
                    }
                }
                else if (slotEntity.GetComponent<KeyLock>())
                {
                    var code = Convert.ToInt32(slotData["code"]);
                    var keyLock = slotEntity.GetComponent<KeyLock>();

                    if ((code & 0x80) != 0)
                    {
                        keyLock.keyCode = code & 0x7F;
                        keyLock.firstKeyCreated = true;
                        keyLock.SetFlag(BaseEntity.Flags.Locked, true);
                    }

                    if (pasteData.Ownership && slotData.ContainsKey("ownerId"))
                    {
#if DEBUG
                        Puts($"{nameof(PasteLoop)}: Convert.ToUInt64 2249");
#endif
                        keyLock.OwnerID = Convert.ToUInt64(slotData["ownerId"]);
                    }
                }

                pasteData.CallbackSpawned?.Invoke(ent);
            }

            return entitySlots;
        }

        private object TryPasteBack(string filename, IPlayer player, string[] args)
        {
            var path = _subDirectory + filename;

            if (!Interface.Oxide.DataFileSystem.ExistsDatafile(path))
                return Lang("FILE_NOT_EXISTS", player?.Id);

            var data = Interface.Oxide.DataFileSystem.GetDatafile(path);

            if (data["default"] == null || data["entities"] == null)
                return Lang("FILE_BROKEN", player?.Id);

            var defaultdata = data["default"] as Dictionary<string, object>;
            var pos = defaultdata?["position"] as Dictionary<string, object>;
            var rotationCorrection = Convert.ToSingle(defaultdata?["rotationdiff"]);
            var startPos = new Vector3(Convert.ToSingle(pos?["x"]), Convert.ToSingle(pos?["y"]),
                Convert.ToSingle(pos?["z"]));

            return TryPaste(startPos, filename, player, rotationCorrection, args, false).Item1;
        }

        [Command("copy")]
        private void CmdCopy(IPlayer player, string command, string[] args)
        {
            if (!HasAccess(player, _copyPermission))
            {
                player.Reply(Lang("NO_ACCESS", player.Id));
                return;
            }

            if (args.Length < 1)
            {
                player.Reply(Lang("SYNTAX_COPY", player.Id));
                return;
            }

            var basePlayer = player.Object as BasePlayer;
            var savename = args[0];
            var success =
                TryCopyFromSteamId(basePlayer == null ? 0ul : basePlayer.userID, savename,
                    args.Skip(1).ToArray()) as string;

            if (!string.IsNullOrEmpty(success))
                player.Reply(success);
        }

        [Command("paste")]
        private void CmdPaste(IPlayer player, string command, string[] args)
        {
            if (!HasAccess(player, _pastePermission))
            {
                player.Reply(Lang("NO_ACCESS", player.Id));
                return;
            }

            if (args.Length < 1)
            {
                player.Reply(Lang("SYNTAX_PASTE_OR_PASTEBACK", player.Id));
                return;
            }

            var basePlayer = player.Object as BasePlayer;
            var success =
                TryPasteFromSteamId(basePlayer == null ? 0ul : basePlayer.userID, args[0],
                    args.Skip(1).ToArray()) as string;

            if (!string.IsNullOrEmpty(success))
                player.Reply(success);
        }

        [Command("copylist")]
        private void CmdList(IPlayer player, string command, string[] args)
        {
            if (!HasAccess(player, _listPermission))
            {
                player.Reply(Lang("NO_ACCESS", player.Id));
                return;
            }

            var files = Interface.Oxide.DataFileSystem.GetFiles(_subDirectory);

            var fileList = new List<string>();

            foreach (var file in files)
            {
                var strFileParts = file.Split('/');
                var justfile = strFileParts[strFileParts.Length - 1].Replace(".json", "");
                fileList.Add(justfile);
            }

            player.Reply(Lang("AVAILABLE_STRUCTURES", player.Id));
            player.Reply(string.Join(", ", fileList.ToArray()));
        }

        [Command("pasteback")]
        private void CmdPasteBack(IPlayer player, string command, string[] args)
        {
            if (!HasAccess(player, _pastebackPermission))
            {
                player.Reply(Lang("NO_ACCESS", player.Id));
                return;
            }

            if (args.Length < 1)
            {
                player.Reply(Lang("SYNTAX_PASTEBACK", player.Id));
                return;
            }

            var success = TryPasteBack(args[0], player, args.Skip(1).ToArray()) as string;
            if (!string.IsNullOrEmpty(success))
                player.Reply(success);
        }

        [Command("undo")]
        private void CmdUndo(IPlayer player, string command, string[] args)
        {
            if (!HasAccess(player, _undoPermission))
            {
                player.Reply(Lang("NO_ACCESS", player.Id));
                return;
            }

            if (!_lastPastes.ContainsKey(player.Id))
            {
                player.Reply(Lang("NO_PASTED_STRUCTURE", player.Id));
                return;
            }

            var entities = new HashSet<BaseEntity>(_lastPastes[player.Id].Pop().ToList());

            UndoLoop(entities, player);
        }

        //Replace between old ItemID to new ItemID

        private static readonly Dictionary<int, int> ReplaceItemId = new Dictionary<int, int>
        {
            { -1461508848, 1545779598 },
            { 2115555558, 588596902 },
            { -533875561, 785728077 },
            { 1621541165, 51984655 },
            { -422893115, -1691396643 },
            { 815896488, -1211166256 },
            { 805088543, -1321651331 },
            { 449771810, 605467368 },
            { 1152393492, 1712070256 },
            { 1578894260, -742865266 },
            { 1436532208, 1638322904 },
            { 542276424, -1841918730 },
            { 1594947829, -17123659 },
            { -1035059994, -1685290200 },
            { 1818890814, -1036635990 },
            { 1819281075, -727717969 },
            { 1685058759, -1432674913 },
            { 93029210, 1548091822 },
            { -1565095136, 352130972 },
            { -1775362679, 215754713 },
            { -1775249157, 14241751 },
            { -1280058093, -1023065463 },
            { -420273765, -1234735557 },
            { 563023711, -2139580305 },
            { 790921853, -262590403 },
            { -337261910, -2072273936 },
            { 498312426, -1950721390 },
            { 504904386, 1655650836 },
            { -1221200300, -559599960 },
            { 510887968, 15388698 },
            { -814689390, 866889860 },
            { 1024486167, 1382263453 },
            { 2021568998, 609049394 },
            { 97329, 1099314009 },
            { 1046072789, -582782051 },
            { 97409, -1273339005 },
            { -1480119738, -1262185308 },
            { 1611480185, 1931713481 },
            { -1386464949, 1553078977 },
            { 93832698, 1776460938 },
            { -1063412582, -586342290 },
            { -1887162396, -996920608 },
            { -55660037, 1588298435 },
            { 919780768, 1711033574 },
            { -365801095, 1719978075 },
            { 68998734, 613961768 },
            { -853695669, 1443579727 },
            { 271534758, 833533164 },
            { -770311783, -180129657 },
            { -1192532973, 1424075905 },
            { -307490664, 1525520776 },
            { 707427396, 602741290 },
            { 707432758, -761829530 },
            { -2079677721, 1783512007 },
            { -1342405573, -1316706473 },
            { -139769801, 1946219319 },
            { -1043746011, -700591459 },
            { 2080339268, 1655979682 },
            { -171664558, -1941646328 },
            { 1050986417, -1557377697 },
            { -1693683664, 1789825282 },
            { 523409530, 1121925526 },
            { 1300054961, 634478325 },
            { -2095387015, 1142993169 },
            { 1428021640, 1104520648 },
            { 94623429, 1534542921 },
            { 1436001773, -1938052175 },
            { 1711323399, 1973684065 },
            { 1734319168, -1848736516 },
            { -1658459025, -1440987069 },
            { -726947205, -751151717 },
            { -341443994, 363467698 },
            { 1540879296, 2009734114 },
            { 94756378, -858312878 },
            { 3059095, 204391461 },
            { 3059624, 1367190888 },
            { 2045107609, -778875547 },
            { 583366917, 998894949 },
            { 2123300234, 1965232394 },
            { 1983936587, -321733511 },
            { 1257201758, -97956382 },
            { -1144743963, 296519935 },
            { -1144542967, -113413047 },
            { -1144334585, -2022172587 },
            { 1066729526, -1101924344 },
            { -1598790097, 1390353317 },
            { -933236257, 1221063409 },
            { -1575287163, -1336109173 },
            { -2104481870, -2067472972 },
            { -1571725662, 1353298668 },
            { 1456441506, 1729120840 },
            { 1200628767, -1112793865 },
            { -778796102, 1409529282 },
            { 1526866730, 674734128 },
            { 1925723260, -1519126340 },
            { 1891056868, 1401987718 },
            { 1295154089, -1878475007 },
            { 498591726, 1248356124 },
            { 1755466030, -592016202 },
            { 726730162, 798638114 },
            { -1034048911, -1018587433 },
            { 252529905, 274502203 },
            { 471582113, -1065444793 },
            { -1138648591, 16333305 },
            { 305916740, 649305914 },
            { 305916742, 649305916 },
            { 305916744, 649305918 },
            { 1908328648, -1535621066 },
            { -2078972355, 1668129151 },
            { -533484654, 989925924 },
            { 1571660245, 1569882109 },
            { 1045869440, -1215753368 },
            { 1985408483, 528668503 },
            { 97513422, 304481038 },
            { 1496470781, -196667575 },
            { 1229879204, 952603248 },
            { -1722829188, 936496778 },
            { 1849912854, 1948067030 },
            { -1266285051, 1413014235 },
            { -1749787215, -1000573653 },
            { 28178745, -946369541 },
            { -505639592, -1999722522 },
            { 1598149413, -1992717673 },
            { -1779401418, -691113464 },
            { -57285700, -335089230 },
            { 98228420, 479143914 },
            { 1422845239, 999690781 },
            { 277631078, -1819763926 },
            { 115739308, 1366282552 },
            { -522149009, -690276911 },
            { 3175989, -1899491405 },
            { 718197703, -746030907 },
            { 384204160, 1840822026 },
            { -1308622549, 143803535 },
            { -217113639, -2124352573 },
            { -1580059655, -265876753 },
            { -1832205789, 1070894649 },
            { 305916741, 649305917 },
            { 936777834, 3222790 },
            { -1224598842, 200773292 },
            { -1976561211, -1506397857 },
            { -1406876421, 1675639563 },
            { -1397343301, -23994173 },
            { 1260209393, 850280505 },
            { -1035315940, 1877339384 },
            { -1381682752, 1714496074 },
            { 696727039, -1022661119 },
            { -2128719593, -803263829 },
            { -1178289187, -1903165497 },
            { 1351172108, 1181207482 },
            { -450738836, -1539025626 },
            { -966287254, -324675402 },
            { 340009023, 671063303 },
            { 124310981, -1478212975 },
            { 1501403549, -2094954543 },
            { 698310895, -1252059217 },
            { 523855532, 1266491000 },
            { 2045246801, -886280491 },
            { 583506109, -237809779 },
            { -148163128, 794356786 },
            { -132588262, -1773144852 },
            { -1666761111, 196700171 },
            { -465236267, 442289265 },
            { -1211618504, 1751045826 },
            { 2133577942, -1982036270 },
            { -1014825244, -682687162 },
            { -991829475, 1536610005 },
            { -642008142, -1709878924 },
            { 661790782, 1272768630 },
            { -1440143841, -1780802565 },
            { 569119686, 1746956556 },
            { 1404466285, -1102429027 },
            { -1616887133, -48090175 },
            { -1167640370, -1163532624 },
            { -1284735799, 1242482355 },
            { -1278649848, -1824943010 },
            { 776005741, 1814288539 },
            { 108061910, -316250604 },
            { 255101535, -1663759755 },
            { -51678842, 1658229558 },
            { -789202811, 254522515 },
            { 516382256, -132516482 },
            { 50834473, 1381010055 },
            { -975723312, 1159991980 },
            { 1908195100, -850982208 },
            { -1097452776, -110921842 },
            { 146685185, -1469578201 },
            { -1716193401, -1812555177 },
            { 193190034, -2069578888 },
            { 371156815, -852563019 },
            { 3343606, -1966748496 },
            { 825308669, -1137865085 },
            { 830965940, -586784898 },
            { 1662628660, -163828118 },
            { 1662628661, -163828117 },
            { 1662628662, -163828112 },
            { -1832205788, 1070894648 },
            { -1832205786, 1070894646 },
            { 1625090418, 181590376 },
            { -1269800768, -874975042 },
            { 429648208, -1190096326 },
            { -1832205787, 1070894647 },
            { -1832205785, 1070894645 },
            { 107868, 696029452 },
            { 997973965, -2012470695 },
            { -46188931, -702051347 },
            { -46848560, -194953424 },
            { -2066726403, -989755543 },
            { -2043730634, 1873897110 },
            { 1325935999, -1520560807 },
            { -225234813, -78533081 },
            { -202239044, -1509851560 },
            { -322501005, 1422530437 },
            { -1851058636, 1917703890 },
            { -1828062867, -1162759543 },
            { -1966381470, -1130350864 },
            { 968732481, 1391703481 },
            { 991728250, -242084766 },
            { -253819519, 621915341 },
            { -1714986849, 1827479659 },
            { -1691991080, 813023040 },
            { 179448791, -395377963 },
            { 431617507, -1167031859 },
            { 688032252, 69511070 },
            { -1059362949, -4031221 },
            { 1265861812, 1110385766 },
            { 374890416, 317398316 },
            { 1567404401, 1882709339 },
            { -1057402571, 95950017 },
            { -758925787, -1130709577 },
            { -1411620422, 1052926200 },
            { 88869913, -542577259 },
            { -2094080303, 1318558775 },
            { 843418712, -1962971928 },
            { -1569356508, -1405508498 },
            { -1569280852, 1478091698 },
            { 449769971, 1953903201 },
            { 590532217, -2097376851 },
            { 3387378, 1414245162 },
            { 1767561705, 1992974553 },
            { 106433500, 237239288 },
            { -1334615971, -1778159885 },
            { -135651869, 1722154847 },
            { -1595790889, 1850456855 },
            { -459156023, -1695367501 },
            { 106434956, -1779183908 },
            { -578028723, -1302129395 },
            { -586116979, 286193827 },
            { -1379225193, -75944661 },
            { -930579334, 649912614 },
            { 548699316, 818877484 },
            { 142147109, 1581210395 },
            { 148953073, 1903654061 },
            { 102672084, 980333378 },
            { 640562379, -1651220691 },
            { -1732316031, -1622660759 },
            { -2130280721, 756517185 },
            { -1725510067, -722241321 },
            { 1974032895, -1673693549 },
            { -225085592, -567909622 },
            { 509654999, 1898094925 },
            { 466113771, -1511285251 },
            { 2033918259, 1373971859 },
            { 2069925558, -1736356576 },
            { -1026117678, 803222026 },
            { 1987447227, -1861522751 },
            { 540154065, -544317637 },
            { 1939428458, 176787552 },
            { -288010497, -2002277461 },
            { -847065290, 1199391518 },
            { 3506021, 963906841 },
            { 649603450, 442886268 },
            { 3506418, 1414245522 },
            { 569935070, -1104881824 },
            { 113284, -1985799200 },
            { 1916127949, -277057363 },
            { -1775234707, -1978999529 },
            { -388967316, 1326180354 },
            { 2007564590, -575483084 },
            { -1705696613, 177226991 },
            { 670655301, -253079493 },
            { 1148128486, -1958316066 },
            { -141135377, 567235583 },
            { 109266897, -932201673 },
            { -527558546, 2087678962 },
            { -1745053053, -904863145 },
            { 1223860752, 573926264 },
            { -419069863, 1234880403 },
            { -1617374968, -1994909036 },
            { 2057749608, 1950721418 },
            { 24576628, -2025184684 },
            { -1659202509, 1608640313 },
            { 2107229499, -1549739227 },
            { 191795897, -765183617 },
            { -1009492144, 795371088 },
            { 2077983581, -1367281941 },
            { 378365037, 352499047 },
            { -529054135, -1199897169 },
            { -529054134, -1199897172 },
            { 486166145, -1023374709 },
            { 1628490888, 23352662 },
            { 1498516223, 1205607945 },
            { -632459882, -1647846966 },
            { -626812403, -845557339 },
            { 385802761, -1370759135 },
            { 2117976603, 121049755 },
            { 1338515426, -996185386 },
            { -1455694274, 98508942 },
            { 1579245182, 2070189026 },
            { -587434450, 1521286012 },
            { -163742043, 1542290441 },
            { -1224714193, -1832422579 },
            { 644359987, 826309791 },
            { -1962514734, -143132326 },
            { -705305612, 1153652756 },
            { -357728804, -1819233322 },
            { -698499648, -1138208076 },
            { 1213686767, -1850571427 },
            { 386382445, -855748505 },
            { 1859976884, 553887414 },
            { 960793436, 996293980 },
            { 1001265731, 2048317869 },
            { 1253290621, -1754948969 },
            { 470729623, -1293296287 },
            { 1051155022, -369760990 },
            { 865679437, -1878764039 },
            { 927253046, -1039528932 },
            { 109552593, 1796682209 },
            { -2092529553, 1230323789 },
            { 691633666, -363689972 },
            { -2055888649, 1629293099 },
            { 621575320, -41440462 },
            { -2118132208, 1602646136 },
            { -1127699509, 1540934679 },
            { -685265909, -92759291 },
            { 552706886, -1100422738 },
            { 1835797460, -1021495308 },
            { -892259869, 642482233 },
            { -1623330855, -465682601 },
            { -1616524891, 1668858301 },
            { 789892804, 171931394 },
            { -1289478934, -1583967946 },
            { -892070738, -2099697608 },
            { -891243783, -1581843485 },
            { 889398893, -1157596551 },
            { -1625468793, 1397052267 },
            { 1293049486, 1975934948 },
            { 1369769822, 559147458 },
            { 586484018, 1079279582 },
            { 110115790, 593465182 },
            { 1490499512, 1523195708 },
            { 3552619, 2019042823 },
            { 1471284746, 73681876 },
            { 456448245, -1758372725 },
            { 110547964, 795236088 },
            { 1588977225, -1667224349 },
            { 918540912, -209869746 },
            { -471874147, 1686524871 },
            { 205978836, 1723747470 },
            { -1044400758, -129230242 },
            { -2073307447, -1331212963 },
            { 435230680, 2106561762 },
            { -864578046, 223891266 },
            { 1660607208, 935692442 },
            { 260214178, -1478445584 },
            { -1847536522, 198438816 },
            { -496055048, -967648160 },
            { -1792066367, 99588025 },
            { 562888306, -956706906 },
            { -427925529, -1429456799 },
            { 995306285, 1451568081 },
            { -378017204, -1117626326 },
            { 447918618, -148794216 },
            { 313836902, 1516985844 },
            { 1175970190, -796583652 },
            { 525244071, -148229307 },
            { -1021702157, -819720157 },
            { -402507101, 671706427 },
            { -1556671423, -1183726687 },
            { 61936445, -1614955425 },
            { 112903447, -1779180711 },
            { 1817873886, -1100168350 },
            { 1824679850, -132247350 },
            { -1628526499, -1863559151 },
            { 547302405, -119235651 },
            { 1840561315, 2114754781 },
            { -460592212, -1379835144 },
            { 3655341, -151838493 },
            { 1554697726, 418081930 },
            { -1883959124, 832133926 },
            { -481416622, 1524187186 },
            { -481416621, -41896755 },
            { -481416620, -1607980696 },
            { -1151126752, 1058261682 },
            { -1926458555, 794443127 }
        };

        //Languages phrases

        private readonly Dictionary<string, Dictionary<string, string>> _messages =
            new Dictionary<string, Dictionary<string, string>>
            {
                {
                    "FILE_NOT_EXISTS", new Dictionary<string, string>
                    {
                        { "en", "File does not exist" },
                        { "ru", "Ð¤Ð°Ð¹Ð» Ð½Ðµ ÑÑÑÐµÑÑÐ²ÑÐµÑ" },
                        { "nl", "Bestand bestaat niet." }
                    }
                },
                {
                    "FILE_BROKEN", new Dictionary<string, string>
                    {
                        { "en", "Something went wrong during pasting because of a error in the file." },
                        { "ru", "Ð¤Ð°Ð¹Ð» Ð¿Ð¾Ð²ÑÐµÐ¶Ð´ÐµÐ½, Ð²ÑÑÐ°Ð²ÐºÐ° Ð½ÐµÐ²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð°" },
                        { "nl", "Er is iets misgegaan tijdens het plakken door een beschadigd bestand." }
                    }
                },
                {
                    "NO_ACCESS", new Dictionary<string, string>
                    {
                        { "en", "You don't have the permissions to use this command" },
                        { "ru", "Ð£ Ð²Ð°Ñ Ð½ÐµÑ Ð¿ÑÐ°Ð² Ð´Ð¾ÑÑÑÐ¿Ð° Ðº Ð´Ð°Ð½Ð½Ð¾Ð¹ ÐºÐ¾Ð¼Ð°Ð½Ð´Ðµ" },
                        { "nl", "U heeft geen toestemming/permissie om dit commando te gebruiken." }
                    }
                },
                {
                    "SYNTAX_PASTEBACK", new Dictionary<string, string>
                    {
                        {
                            "en", "Syntax: /pasteback <Target Filename> <options values>\n" +
                                  "height XX - Adjust the height\n" +
                                  "vending - Information and sellings in vending machine\n" +
                                  "stability <true/false> - Wether or not to disable stability\n" +
                                  "deployables <true/false> - Wether or not to copy deployables\n" +
                                  "auth <true/false> - Wether or not to copy lock and cupboard whitelists\n" +
                                  "position <x,y,z> - Override position\n" +
                                  "rotation <X> - Override rotation"
                        },
                        {
                            "ru", "Ð¡Ð¸Ð½ÑÐ°ÐºÑÐ¸Ñ: /pasteback <ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ ÐÐ±ÑÐµÐºÑÐ°> <Ð¾Ð¿ÑÐ¸Ñ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ>\n" +
                                  "height XX - ÐÑÑÐ¾ÑÐ° Ð¾Ñ Ð·ÐµÐ¼Ð»Ð¸\n" +
                                  "vending - ÐÐ½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ñ Ð¸ ÑÐ¾Ð²Ð°ÑÑ Ð² ÑÐ¾ÑÐ³Ð¾Ð²Ð¾Ð¼ Ð°Ð²ÑÐ¾Ð¼Ð°ÑÐµ"
                        },
                        {
                            "nl", "Syntax: /pasteback <Bestandsnaam> <opties waarden>\n" +
                                  "height XX - Pas de hoogte aan \n" +
                                  "vending <true/false> - Informatie en inventaris van \"vending machines\" kopiÃ«ren\n" +
                                  "stability <true/false> - of de stabiliteit van het gebouw uitgezet moet worden\n" +
                                  "deployables <true/false> - of de \"deployables\" gekopiÃ«rd moeten worden\n" +
                                  "auth <true/false> - Of authorisatie op sloten en tool cupboards gekopiÃ«rd moet worden"
                        }
                    }
                },
                {
                    "SYNTAX_PASTE_OR_PASTEBACK", new Dictionary<string, string>
                    {
                        {
                            "en", "Syntax: /paste or /pasteback <Target Filename> <options values>\n" +
                                  "height XX - Adjust the height\n" +
                                  "autoheight true/false - sets best height, carefull of the steep\n" +
                                  "blockcollision XX - blocks the entire paste if something the new building collides with something\n" +
                                  "deployables true/false - false to remove deployables\n" +
                                  "inventories true/false - false to ignore inventories\n" +
                                  "vending - Information and sellings in vending machine\n" +
                                  "stability <true/false> - Wether or not to disable stability on the building\n" +
                                  "position <x,y,z> - Override position\n" +
                                  "rotation <X> - Override rotation"
                        },
                        {
                            "ru", "Ð¡Ð¸Ð½ÑÐ°ÐºÑÐ¸Ñ: /paste or /pasteback <ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ ÐÐ±ÑÐµÐºÑÐ°> <Ð¾Ð¿ÑÐ¸Ñ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ>\n" +
                                  "height XX - ÐÑÑÐ¾ÑÐ° Ð¾Ñ Ð·ÐµÐ¼Ð»Ð¸\n" +
                                  "autoheight true/false - Ð°Ð²ÑÐ¾Ð¼Ð°ÑÐ¸ÑÐµÑÐºÐ¸ Ð¿Ð¾Ð´Ð¾Ð±ÑÐ°ÑÑ Ð²ÑÑÐ¾ÑÑ Ð¾Ñ Ð·ÐµÐ¼Ð»Ð¸\n" +
                                  "blockcollision XX - Ð±Ð»Ð¾ÐºÐ¸ÑÐ¾Ð²Ð°ÑÑ Ð²ÑÑÐ°Ð²ÐºÑ, ÐµÑÐ»Ð¸ ÑÑÐ¾-ÑÐ¾ ÑÑÐ¾Ð¼Ñ Ð¼ÐµÑÐ°ÐµÑ\n" +
                                  "deployables true/false - false Ð´Ð»Ñ ÑÐ´Ð°Ð»ÐµÐ½Ð¸Ñ Ð¿ÑÐµÐ´Ð¼ÐµÑÐ¾Ð²\n" +
                                  "inventories true/false - false Ð´Ð»Ñ Ð¸Ð³Ð½Ð¾ÑÐ¸ÑÐ¾Ð²Ð°Ð½Ð¸Ñ ÐºÐ¾Ð¿Ð¸ÑÐ¾Ð²Ð°Ð½Ð¸Ñ Ð¸Ð½Ð²ÐµÐ½ÑÐ°ÑÑ\n" +
                                  "vending - ÐÐ½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ñ Ð¸ ÑÐ¾Ð²Ð°ÑÑ Ð² ÑÐ¾ÑÐ³Ð¾Ð²Ð¾Ð¼ Ð°Ð²ÑÐ¾Ð¼Ð°ÑÐµ"
                        },
                        {
                            "nl", "Syntax: /paste of /pasteback <Bestandsnaam> <opties waarden>\n" +
                                  "height XX - Pas de hoogte aan \n" +
                                  "autoheight true/false - probeert de optimale hoogte te vinden om gebouw te plaatsen. Werkt optimaal op vlakke grond.\n" +
                                  "vending true/false - Informatie en inventaris van \"vending machines\" kopiÃ«ren\n" +
                                  "stability <true/false> - of de stabiliteit van het gebouw uitgezet moet worden\n" +
                                  "deployables <true/false> - of de \"deployables\" gekopiÃ«rd moeten worden\n" +
                                  "auth <true/false> - Of authorisatie op sloten en tool cupboards gekopiÃ«rd moet worden"
                        }
                    }
                },
                {
                    "PASTEBACK_SUCCESS", new Dictionary<string, string>
                    {
                        { "en", "You've successfully placed back the structure" },
                        { "ru", "ÐÐ¾ÑÑÑÐ¾Ð¹ÐºÐ° ÑÑÐ¿ÐµÑÐ½Ð¾ Ð²ÑÑÐ°Ð²Ð»ÐµÐ½Ð° Ð½Ð° ÑÑÐ°ÑÐ¾Ðµ Ð¼ÐµÑÑÐ¾" },
                        { "nl", "Het gebouw is succesvol teruggeplaatst." }
                    }
                },
                {
                    "PASTE_SUCCESS", new Dictionary<string, string>
                    {
                        { "en", "You've successfully pasted the structure" },
                        { "ru", "ÐÐ¾ÑÑÑÐ¾Ð¹ÐºÐ° ÑÑÐ¿ÐµÑÐ½Ð¾ Ð²ÑÑÐ°Ð²Ð»ÐµÐ½Ð°" },
                        { "nl", "Het gebouw is succesvol geplaatst." }
                    }
                },
                {
                    "SYNTAX_COPY", new Dictionary<string, string>
                    {
                        {
                            "en", "Syntax: /copy <Target Filename> <options values>\n" +
                                  "radius XX (default 3) - The radius in which to search for the next object (performs this search from every other object)\n" +
                                  "method proximity/building (default proximity) - Building only copies objects which are part of the building, proximity copies everything (within the radius)\n" +
                                  "deployables true/false (saves deployables or not) - Wether to save deployables\n" +
                                  "inventories true/false (saves inventories or not) - Wether to save inventories of found objects with inventories."
                        },
                        {
                            "ru", "Ð¡Ð¸Ð½ÑÐ°ÐºÑÐ¸Ñ: /copy <ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ ÐÐ±ÑÐµÐºÑÐ°> <Ð¾Ð¿ÑÐ¸Ñ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ>\n" +
                                  "radius XX (default 3)\n" +
                                  "method proximity/building (Ð¿Ð¾ ÑÐ¼Ð¾Ð»ÑÐ°Ð½Ð¸Ñ proximity)\n" +
                                  "deployables true/false (ÑÐ¾ÑÑÐ°Ð½ÑÑÑ Ð¿ÑÐµÐ´Ð¼ÐµÑÑ Ð¸Ð»Ð¸ Ð½ÐµÑ)\n" +
                                  "inventories true/false (ÑÐ¾ÑÑÐ°Ð½ÑÑÑ Ð¸Ð½Ð²ÐµÐ½ÑÐ°ÑÑ Ð¸Ð»Ð¸ Ð½ÐµÑ)"
                        },
                        {
                            "nl", "Syntax: /copy <Bestandsnaam> <opties waarden>\n" +
                                  "radius XX (standaard 3) - De radius waarin copy paste naar het volgende object zoekt\n" +
                                  "method proximity/building (standaard proximity) - Building kopieÃ«rd alleen objecten die bij het gebouw horen, proximity kopieÃ«rd alles wat gevonden is\n" +
                                  "deployables true/false (saves deployables or not) - Of de data van gevonden \"deployables\" opgeslagen moet worden\n" +
                                  "inventories true/false (saves inventories or not) - Of inventarissen van objecten (kisten, tool cupboards, etc) opgeslagen moet worden"
                        }
                    }
                },
                {
                    "NO_ENTITY_RAY", new Dictionary<string, string>
                    {
                        { "en", "Couldn't ray something valid in front of you" },
                        { "ru", "ÐÐµ ÑÐ´Ð°Ð»Ð¾ÑÑ Ð½Ð°Ð¹ÑÐ¸ ÐºÐ°ÐºÐ¾Ð¹-Ð»Ð¸Ð±Ð¾ Ð¾Ð±ÑÐµÐºÑ Ð¿ÐµÑÐµÐ´ Ð²Ð°Ð¼Ð¸" },
                        { "nl", "U kijkt niet naar een geschikt object om een kopie op te starten." }
                    }
                },
                {
                    "COPY_SUCCESS", new Dictionary<string, string>
                    {
                        { "en", "The structure was successfully copied as {0}" },
                        { "ru", "ÐÐ¾ÑÑÑÐ¾Ð¹ÐºÐ° ÑÑÐ¿ÐµÑÐ½Ð¾ ÑÐºÐ¾Ð¿Ð¸ÑÐ¾Ð²Ð°Ð½Ð° Ð¿Ð¾Ð´ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸ÐµÐ¼: {0}" },
                        { "nl", "Gebouw is succesvol gekopieÃ«rd" }
                    }
                },
                {
                    "NO_PASTED_STRUCTURE", new Dictionary<string, string>
                    {
                        { "en", "You must paste structure before undoing it" },
                        { "ru", "ÐÑ Ð´Ð¾Ð»Ð¶Ð½Ñ Ð²ÑÑÐ°Ð²Ð¸ÑÑ Ð¿Ð¾ÑÑÑÐ¾Ð¹ÐºÑ Ð¿ÐµÑÐµÐ´ ÑÐµÐ¼, ÐºÐ°Ðº Ð¾ÑÐ¼ÐµÐ½Ð¸ÑÑ Ð´ÐµÐ¹ÑÑÐ²Ð¸Ðµ" },
                        {
                            "nl",
                            "U moet eerst een gebouw terugplaatsen alvorens deze ongedaan gemaakt kan worden (duhh)"
                        }
                    }
                },
                {
                    "UNDO_SUCCESS", new Dictionary<string, string>
                    {
                        { "en", "You've successfully undid what you pasted" },
                        { "ru", "ÐÑ ÑÑÐ¿ÐµÑÐ½Ð¾ ÑÐ½ÐµÑÐ»Ð¸ Ð²ÑÑÐ°Ð²Ð»ÐµÐ½Ð½ÑÑ Ð¿Ð¾ÑÑÑÐ¾Ð¹ÐºÑ" },
                        { "nl", "Laatse geplaatste gebouw is succesvol ongedaan gemaakt." }
                    }
                },
                {
                    "NOT_FOUND_PLAYER", new Dictionary<string, string>
                    {
                        { "en", "Couldn't find the player" },
                        { "ru", "ÐÐµ ÑÐ´Ð°Ð»Ð¾ÑÑ Ð½Ð°Ð¹ÑÐ¸ Ð¸Ð³ÑÐ¾ÐºÐ°" },
                        { "nl", "Speler niet gevonden." }
                    }
                },
                {
                    "SYNTAX_BOOL", new Dictionary<string, string>
                    {
                        { "en", "Option {0} must be true/false" },
                        { "ru", "ÐÐ¿ÑÐ¸Ñ {0} Ð¿ÑÐ¸Ð½Ð¸Ð¼Ð°ÐµÑ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ñ true/false" },
                        { "nl", "Optie {0} moet true of false zijn" }
                    }
                },
                {
                    "SYNTAX_FLOAT", new Dictionary<string, string>
                    {
                        { "en", "Option {0} must be a decimal" },
                        { "ru", "ÐÐ¿ÑÐ¸Ñ {0} Ð¿ÑÐ¸Ð½Ð¸Ð¼Ð°ÐµÑ ÑÐ¾Ð»ÑÐºÐ¾ ÑÐ¸ÑÐ»Ð¾Ð²ÑÐµ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ñ Ñ ÑÐ¾ÑÐºÐ¾Ð¹" },
                        { "nl", "Optie {0} moet een decimal zijn" }
                    }
                },
                {
                    "SYNTAX_HEIGHT", new Dictionary<string, string>
                    {
                        { "en", "Option height must be a number" },
                        { "ru", "ÐÐ¿ÑÐ¸Ñ height Ð¿ÑÐ¸Ð½Ð¸Ð¼Ð°ÐµÑ ÑÐ¾Ð»ÑÐºÐ¾ ÑÐ¸ÑÐ»Ð¾Ð²ÑÐµ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ñ" },
                        { "nl", "De optie height accepteert alleen nummers" }
                    }
                },
                {
                    "SYNTAX_BLOCKCOLLISION", new Dictionary<string, string>
                    {
                        { "en", "Option blockcollision must be a number, 0 will deactivate the option" },
                        {
                            "ru",
                            "ÐÐ¿ÑÐ¸Ñ blockcollision Ð¿ÑÐ¸Ð½Ð¸Ð¼Ð°ÐµÑ ÑÐ¾Ð»ÑÐºÐ¾ ÑÐ¸ÑÐ»Ð¾Ð²ÑÐµ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ñ, 0 Ð¿Ð¾Ð·Ð²Ð¾Ð»ÑÐµÑ Ð¾ÑÐºÐ»ÑÑÐ¸ÑÑ Ð¿ÑÐ¾Ð²ÐµÑÐºÑ"
                        },
                        { "nl", "Optie blockcollision accepteert alleen nummers, 0 schakelt deze functionaliteit uit" }
                    }
                },
                {
                    "SYNTAX_RADIUS", new Dictionary<string, string>
                    {
                        { "en", "Option radius must be a number" },
                        { "ru", "ÐÐ¿ÑÐ¸Ñ radius Ð¿ÑÐ¸Ð½Ð¸Ð¼Ð°ÐµÑ ÑÐ¾Ð»ÑÐºÐ¾ ÑÐ¸ÑÐ»Ð¾Ð²ÑÐµ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ñ" },
                        { "nl", "Optie height accepteert alleen nummers" }
                    }
                },
                {
                    "BLOCKING_PASTE", new Dictionary<string, string>
                    {
                        { "en", "Something is blocking the paste" },
                        { "ru", "Ð§ÑÐ¾-ÑÐ¾ Ð¿ÑÐµÐ¿ÑÑÑÑÐ²ÑÐµÑ Ð²ÑÑÐ°Ð²ÐºÐµ" },
                        { "nl", "Iets blokkeert het plaatsen van dit gebouw" }
                    }
                },
                {
                    "AVAILABLE_STRUCTURES", new Dictionary<string, string>
                    {
                        { "ru", "<color=orange>ÐÐ¾ÑÑÑÐ¿Ð½ÑÐµ Ð¿Ð¾ÑÑÑÐ¾Ð¹ÐºÐ¸:</color>" },
                        { "en", "<color=orange>Available structures:</color>" },
                        { "nl", "Beschikbare bestanden om te plaatsen zijn:" }
                    }
                }
            };

        public class CopyData
        {
            public IPlayer Player;
            public BasePlayer BasePlayer;
            public Stack<Vector3> CheckFrom = new Stack<Vector3>();
            public HashSet<BaseEntity> HouseList = new HashSet<BaseEntity>();
            public List<object> RawData = new List<object>();
            public Vector3 SourcePos;
            public Vector3 SourceRot;
            public Action Callback;

            public string Filename;
            public int CurrentLayer;
            public float RotCor;
            public float Range;
            public bool SaveTree;
            public bool SaveShare;
            public CopyMechanics CopyMechanics;
            public bool EachToEach;
            public uint BuildingId = 0;

#if DEBUG
            public Stopwatch Sw = new Stopwatch();
#endif
        }

        public class PasteData
        {
            public ICollection<Dictionary<string, object>> Entities;
            public List<BaseEntity> PastedEntities = new List<BaseEntity>();
            public string Filename;

            public Dictionary<ulong, Dictionary<string, object>> IoEntities =
                new Dictionary<ulong, Dictionary<string, object>>();

            public IPlayer Player;
            public BasePlayer BasePlayer;
            public List<StabilityEntity> StabilityEntities = new List<StabilityEntity>();
            public Quaternion QuaternionRotation;
            public Action CallbackFinished;
            public Action<BaseEntity> CallbackSpawned;

            public bool Auth;
            public Vector3 StartPos;
            public float HeightAdj;
            public bool Stability;
            public bool IsItemReplace;
            public bool Ownership;
            public bool CheckPlaced = true;

            public bool Cancelled = false;

            public uint BuildingId = 0;

#if DEBUG
            public Stopwatch Sw = new Stopwatch();
#endif
        }
    }
}

// --- End of file: CopyPaste.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/NTeleportation.cs ---
// --- Original Local Path: BeeRust/NTeleportation.cs ---

//#define DEBUG
using Facepunch;
using Network;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust;
using Oxide.Game.Rust.Cui;
using Rust;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("NTeleportation", "nivex", "1.7.7")]
    [Description("Multiple teleportation systems for admin and players")]
    class NTeleportation : RustPlugin
    {
        [PluginReference]
        private Plugin Clans, Economics, IQEconomic, ServerRewards, Friends, CompoundTeleport, ZoneManager, NoEscape, PopupNotifications, BlockUsers;

        private Dictionary<string, BasePlayer> _ids = new Dictionary<string, BasePlayer>();
        private Dictionary<BasePlayer, string> _players = new Dictionary<BasePlayer, string>();

        private bool newSave;
        private const string NewLine = "\n";
        private const string TPA = "tpa";
        private static readonly string[] nullArg = {};
        private const string PermAdmin = "nteleportation.admin";
        private const string PermRestrictions = "nteleportation.norestrictions";
        private const string ConfigDefaultPermVip = "nteleportation.vip";
        private const string PermHome = "nteleportation.home";
        private const string PermWipeHomes = "nteleportation.wipehomes";
        private const string PermCraftHome = "nteleportation.crafthome";
        private const string PermDeleteHome = "nteleportation.deletehome";
        private const string PermHomeHomes = "nteleportation.homehomes";
        private const string PermImportHomes = "nteleportation.importhomes";
        private const string PermRadiusHome = "nteleportation.radiushome";
        private const string PermCraftTpR = "nteleportation.crafttpr";
        private const string PermTpR = "nteleportation.tpr";
        private const string PermTp = "nteleportation.tp";
        private const string PermDisallowTpToMe = "nteleportation.disallowtptome";
        private const string PermTpT = "nteleportation.tpt";
        private const string PermTpB = "nteleportation.tpb";
        private const string PermTpN = "nteleportation.tpn";
        private const string PermTpL = "nteleportation.tpl";
        private const string PermTpConsole = "nteleportation.tpconsole";
        private const string PermTpRemove = "nteleportation.tpremove";
        private const string PermTpSave = "nteleportation.tpsave";
        private const string PermExempt = "nteleportation.exemptfrominterruptcountdown";
        private const string PermFoundationCheck = "nteleportation.bypassfoundationcheck";
        private const string PermTpMarker = "nteleportation.tpmarker";
        private DynamicConfigFile dataConvert;
        private DynamicConfigFile dataDisabled;
        private DynamicConfigFile dataAdmin;
        private DynamicConfigFile dataHome;
        private DynamicConfigFile dataTPR;
        private DynamicConfigFile dataTPT;
        private Dictionary<ulong, AdminData> _Admin;
        private Dictionary<ulong, HomeData> _Home;
        private Dictionary<ulong, TeleportData> _TPR;
        private Dictionary<string, List<string>> TPT = new Dictionary<string, List<string>>();
        private bool changedAdmin;
        private bool changedHome;
        private bool changedTPR;
        private bool changedTPT;
        private float boundary;
        private readonly Dictionary<ulong, float> TeleportCooldowns = new Dictionary<ulong, float>();
        private readonly Dictionary<ulong, TeleportTimer> TeleportTimers = new Dictionary<ulong, TeleportTimer>();
        private readonly Dictionary<ulong, Timer> PendingRequests = new Dictionary<ulong, Timer>();
        private readonly Dictionary<ulong, BasePlayer> PlayersRequests = new Dictionary<ulong, BasePlayer>();
        private readonly Dictionary<int, string> ReverseBlockedItems = new Dictionary<int, string>();
        private readonly Dictionary<ulong, Vector3> teleporting = new Dictionary<ulong, Vector3>();
        private SortedDictionary<string, Vector3> caves = new SortedDictionary<string, Vector3>();
        private List<MonumentInfoEx> monuments = new List<MonumentInfoEx>();
        private bool outpostEnabled;
        private bool banditEnabled;

        private class MonumentInfoEx
        {
            public MonumentInfo monument;
            public Vector3 position;
            public float radius;
            public string name;
            public string prefab;
            public MonumentInfoEx() { }
            public MonumentInfoEx(MonumentInfo monument, Vector3 position, float radius, string name, string prefab)
            {
                this.monument = monument;
                this.position = position;
                this.radius = radius;
                this.name = name;
                this.prefab = prefab;
            }
            public bool IsInBounds(Vector3 target)
            {
                return monument != null && monument.transform.position.y < 0f && TerrainMeta.HeightMap.GetHeight(target) < 0f && monument.IsInBounds(target);
            }
        }

        #region Configuration

        private static Configuration config;

        public class InterruptSettings
        {
            [JsonProperty(PropertyName = "Interrupt Teleport At Specific Monuments", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Monuments { get; set; } = new List<string>();

            [JsonProperty(PropertyName = "Above Water")]
            public bool AboveWater { get; set; } = true;

            [JsonProperty(PropertyName = "Under Water")]
            public bool UnderWater { get; set; }

            [JsonProperty(PropertyName = "Balloon")]
            public bool Balloon { get; set; } = true;

            [JsonProperty(PropertyName = "Boats")]
            public bool Boats { get; set; }

            [JsonProperty(PropertyName = "Cargo Ship")]
            public bool Cargo { get; set; } = true;

            [JsonProperty(PropertyName = "Cold")]
            public bool Cold { get; set; } = false;

            [JsonProperty(PropertyName = "Excavator")]
            public bool Excavator { get; set; } = false;

            [JsonProperty(PropertyName = "Hot")]
            public bool Hot { get; set; } = false;

            [JsonProperty(PropertyName = "Hostile")]
            public bool Hostile { get; set; } = false;

            [JsonProperty(PropertyName = "Hurt")]
            public bool Hurt { get; set; } = true;

            [JsonProperty(PropertyName = "Junkpiles")]
            public bool Junkpiles { get; set; }

            [JsonProperty(PropertyName = "Lift")]
            public bool Lift { get; set; } = true;

            [JsonProperty(PropertyName = "Monument")]
            public bool Monument { get; set; } = false;

            [JsonProperty(PropertyName = "Ignore Monument Marker Prefab")]
            public bool BypassMonumentMarker { get; set; } = false;

            [JsonProperty(PropertyName = "Mounted")]
            public bool Mounted { get; set; } = true;

            [JsonProperty(PropertyName = "Oil Rig")]
            public bool Oilrig { get; set; } = false;

            [JsonProperty(PropertyName = "Safe Zone")]
            public bool Safe { get; set; } = true;

            [JsonProperty(PropertyName = "Swimming")]
            public bool Swimming { get; set; } = false;
        }

        private object OnPlayerRespawn(BasePlayer player)
        {
            if (player == null) return null;

            var settings = GetSettings("outpost");

            if (settings == null || settings.Location == Vector3.zero) return null;

            if (player.State.unHostileTimestamp > TimeEx.currentTimestamp)
            {
                player.State.unHostileTimestamp = TimeEx.currentTimestamp;
                player.DirtyPlayerState();
                player.ClientRPCPlayer(null, player, "SetHostileLength", 0f);
            }

            return new BasePlayer.SpawnPoint { pos = settings.Location, rot = Quaternion.identity };
        }

        public class PluginSettings
        {
            [JsonProperty(PropertyName = "Delay Saving Data On Server Save")]
            public double SaveDelay { get; set; } = 4.0;
			
            [JsonProperty("TPB")]
            public TPBSettings TPB = new TPBSettings();

            [JsonProperty(PropertyName = "Interrupt TP")]
            public InterruptSettings Interrupt { get; set; } = new InterruptSettings();

            [JsonProperty(PropertyName = "Auto Wake Up After Teleport")]
            public bool AutoWakeUp { get; set; }

            [JsonProperty(PropertyName = "Respawn Players At Outpost")]
            public bool RespawnOutpost { get; set; }

            [JsonProperty(PropertyName = "Block Teleport (NoEscape)")]
            public bool BlockNoEscape { get; set; } = false;

            [JsonProperty(PropertyName = "Block Teleport (ZoneManager)")]
            public bool BlockZoneFlag { get; set; } = false;

            [JsonProperty(PropertyName = "Chat Name")]
            public string ChatName { get; set; } = "<color=red>Teleportation</color> \n\n";

            [JsonProperty(PropertyName = "Chat Steam64ID")]
            public ulong ChatID { get; set; } = 76561199056025689;

            [JsonProperty(PropertyName = "Check Boundaries On Teleport X Y Z")]
            public bool CheckBoundaries { get; set; } = true;

            [JsonProperty(PropertyName = "Check Boundaries Min Height")]
            public float BoundaryMin { get; set; } = -100f;

            [JsonProperty(PropertyName = "Check Boundaries Max Height")]
            public float BoundaryMax { get; set; } = 2000f;

            [JsonProperty(PropertyName = "Check If Inside Rock")]
            public bool Rock { get; set; } = true;

            [JsonProperty(PropertyName = "Height To Prevent Teleporting To/From (0 = disabled)")]
            public float ForcedBoundary { get; set; }

            [JsonProperty(PropertyName = "Data File Directory (Blank = Default)")]
            public string DataFileFolder { get; set; } = string.Empty;

            [JsonProperty(PropertyName = "Draw Sphere On Set Home")]
            public bool DrawHomeSphere { get; set; } = true;

            [JsonProperty(PropertyName = "Homes Enabled")]
            public bool HomesEnabled { get; set; } = true;

            [JsonProperty(PropertyName = "TPR Enabled")]
            public bool TPREnabled { get; set; } = true;

            [JsonProperty(PropertyName = "Strict Foundation Check")]
            public bool StrictFoundationCheck { get; set; } = false;

            [JsonProperty(PropertyName = "Minimum Temp")]
            public float MinimumTemp { get; set; } = 0f;

            [JsonProperty(PropertyName = "Maximum Temp")]
            public float MaximumTemp { get; set; } = 40f;

            [JsonProperty(PropertyName = "Blocked Items", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, string> BlockedItems { get; set; } = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

            [JsonProperty(PropertyName = "Bypass CMD")]
            public string BypassCMD { get; set; } = "pay";

            [JsonProperty(PropertyName = "Use Economics")]
            public bool UseEconomics { get; set; } = false;

            [JsonProperty(PropertyName = "Use Server Rewards")]
            public bool UseServerRewards { get; set; } = false;

            [JsonProperty(PropertyName = "Wipe On Upgrade Or Change")]
            public bool WipeOnUpgradeOrChange { get; set; } = true;

            [JsonProperty(PropertyName = "Auto Generate Outpost Location")]
            public bool AutoGenOutpost { get; set; } = true;

            [JsonProperty(PropertyName = "Outpost Map Prefab", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Outpost { get; set; } = new List<string> { "outpost", "compound" };

            [JsonProperty(PropertyName = "Auto Generate Bandit Location")]
            public bool AutoGenBandit { get; set; } = true;

            [JsonProperty(PropertyName = "Bandit Map Prefab", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Bandit { get; set; } = new List<string> { "bandit_town" };

            [JsonProperty(PropertyName = "Show Time As Seconds Instead")]
            public bool UseSeconds { get; set; } = false;

            [JsonProperty(PropertyName = "Use Quick Teleport")]
            public bool Quick { get; set; } = true;

            [JsonProperty(PropertyName = "Chat Command Color")]
            public string ChatCommandColor = "#FFFF00";

            [JsonProperty(PropertyName = "Chat Command Argument Color")]
            public string ChatCommandArgumentColor = "#FFA500";

            [JsonProperty("Enable Popup Support")]
            public bool UsePopup = false;

            [JsonProperty("Send Messages To Player")]
            public bool SendMessages = true;

            [JsonProperty("Block All Teleporting From Inside Authorized Base")]
            public bool BlockAuthorizedTeleporting = false;

            [JsonProperty("Global Teleport Cooldown")]
            public float Global = 0f;

            [JsonProperty("Global VIP Teleport Cooldown")]
            public float GlobalVIP = 0f;

            [JsonProperty("Play Sounds Before Teleport")]
            public bool PlaySoundsBeforeTeleport = true;

            [JsonProperty("Sound Effects Before Teleport", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> DisappearEffects = new List<string>
            {
                "assets/prefabs/missions/portal/proceduraldungeon/effects/disappear.prefab"
            };

            [JsonProperty("Play Sounds After Teleport")]
            public bool PlaySoundsAfterTeleport = true;

            [JsonProperty("Sound Effects After Teleport", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> ReappearEffects = new List<string>
            {
                "assets/prefabs/missions/portal/proceduraldungeon/effects/appear.prefab"
            };
        }

        public class TPBSettings
        {
            [JsonProperty(PropertyName = "VIP Countdowns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> Countdowns { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 0 } };

            [JsonProperty("Countdown")]
            public int Countdown = 0;

            [JsonProperty("Available After X Seconds")]
            public int Time = 0;
        }

        public class AdminSettings
        {
            [JsonProperty(PropertyName = "Announce Teleport To Target")]
            public bool AnnounceTeleportToTarget { get; set; } = false;

            [JsonProperty(PropertyName = "Usable By Admins")]
            public bool UseableByAdmins { get; set; } = true;

            [JsonProperty(PropertyName = "Usable By Moderators")]
            public bool UseableByModerators { get; set; } = true;

            [JsonProperty(PropertyName = "Location Radius")]
            public int LocationRadius { get; set; } = 25;

            [JsonProperty(PropertyName = "Teleport Near Default Distance")]
            public int TeleportNearDefaultDistance { get; set; } = 30;

            [JsonProperty(PropertyName = "Extra Distance To Block Monument Teleporting")]
            public int ExtraMonumentDistance { get; set; }
        }

        public class HomesSettings
        {
            [JsonProperty(PropertyName = "Homes Limit")]
            public int HomesLimit { get; set; } = 2;

            [JsonProperty(PropertyName = "VIP Homes Limits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPHomesLimits { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "Allow Sethome At Specific Monuments", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> AllowedMonuments { get; set; } = new List<string> { "HQM Quarry", "Stone Quarry", "Sulfur Quarry", "Ice Lake", "Wild Swamp" };

            [JsonProperty(PropertyName = "Allow Sethome At All Monuments")]
            public bool AllowAtAllMonuments { get; set; } = false;

            [JsonProperty(PropertyName = "Allow Sethome On Tugboats")]
            public bool AllowTugboats { get; set; } = true;

            [JsonProperty(PropertyName = "Allow TPB")]
            public bool AllowTPB { get; set; } = true;

            [JsonProperty(PropertyName = "Cooldown")]
            public int Cooldown { get; set; } = 600;

            [JsonProperty(PropertyName = "Countdown")]
            public int Countdown { get; set; } = 15;

            [JsonProperty(PropertyName = "Daily Limit")]
            public int DailyLimit { get; set; } = 5;

            [JsonProperty(PropertyName = "VIP Daily Limits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPDailyLimits { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "VIP Cooldowns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPCooldowns { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "VIP Countdowns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPCountdowns { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "Location Radius")]
            public int LocationRadius { get; set; } = 25;

            [JsonProperty(PropertyName = "Force On Top Of Foundation")]
            public bool ForceOnTopOfFoundation { get; set; } = true;

            [JsonProperty(PropertyName = "Check Foundation For Owner")]
            public bool CheckFoundationForOwner { get; set; } = true;

            [JsonProperty(PropertyName = "Use Friends")]
            public bool UseFriends { get; set; } = true;

            [JsonProperty(PropertyName = "Use Clans")]
            public bool UseClans { get; set; } = true;

            [JsonProperty(PropertyName = "Use Teams")]
            public bool UseTeams { get; set; } = true;

            [JsonProperty(PropertyName = "Usable Out Of Building Blocked")]
            public bool UsableOutOfBuildingBlocked { get; set; } = false;

            [JsonProperty(PropertyName = "Usable Into Building Blocked")]
            public bool UsableIntoBuildingBlocked { get; set; } = false;

            [JsonProperty(PropertyName = "Usable From Safe Zone Only")]
            public bool UsableFromSafeZoneOnly { get; set; } = false;

            [JsonProperty(PropertyName = "Allow Cupboard Owner When Building Blocked")]
            public bool CupOwnerAllowOnBuildingBlocked { get; set; } = true;

            [JsonProperty(PropertyName = "Allow Iceberg")]
            public bool AllowIceberg { get; set; } = false;

            [JsonProperty(PropertyName = "Allow Cave")]
            public bool AllowCave { get; set; }

            [JsonProperty(PropertyName = "Allow Crafting")]
            public bool AllowCraft { get; set; } = false;

            [JsonProperty(PropertyName = "Allow Above Foundation")]
            public bool AllowAboveFoundation { get; set; } = true;

            [JsonProperty(PropertyName = "Check If Home Is Valid On Listhomes")]
            public bool CheckValidOnList { get; set; } = false;

            [JsonProperty(PropertyName = "Pay")]
            public int Pay { get; set; } = 0;

            [JsonProperty(PropertyName = "Bypass")]
            public int Bypass { get; set; } = 0;

            [JsonProperty(PropertyName = "Hours Before Useable After Wipe")]
            public double Hours { get; set; } = 0;
        }

        public class TPTSettings
        {
            [JsonProperty(PropertyName = "Use Friends")]
            public bool UseFriends { get; set; }

            [JsonProperty(PropertyName = "Use Clans")]
            public bool UseClans { get; set; }

            [JsonProperty(PropertyName = "Use Teams")]
            public bool UseTeams { get; set; }

            [JsonProperty(PropertyName = "Allow Cave")]
            public bool AllowCave { get; set; }
            [JsonProperty(PropertyName = "Enabled Color")]
            public string EnabledColor { get; set; } = "green";
            
            [JsonProperty(PropertyName = "Disabled Color")]
            public string DisabledColor { get; set; } = "red";											  
        }

        // Added `TPR => Play Sounds To Request Target` (false)
        // Added `TPR => Play Sounds When Target Accepts` (false)

        public class TPRSettings
        {
            [JsonProperty("Play Sounds To Request Target")]
            public bool PlaySoundsToRequestTarget;

            [JsonProperty("Teleport Request Sound Effects", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> TeleportRequestEffects = new List<string>
            {
                "assets/prefabs/missions/portal/proceduraldungeon/effects/disappear.prefab"
            };

            [JsonProperty("Play Sounds When Target Accepts")]
            public bool PlaySoundsWhenTargetAccepts;

            [JsonProperty("Teleport Accept Sound Effects", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> TeleportAcceptEffects = new List<string>
            {
                "assets/prefabs/missions/portal/proceduraldungeon/effects/appear.prefab"
            };

            [JsonProperty(PropertyName = "Require Player To Be Friend, Clan Mate, Or Team Mate")]
            public bool UseClans_Friends_Teams { get; set; }

            [JsonProperty(PropertyName = "Allow Cave")]
            public bool AllowCave { get; set; }

            [JsonProperty(PropertyName = "Allow TPB")]
            public bool AllowTPB { get; set; } = true;

            [JsonProperty(PropertyName = "Use Blocked Users")]
            public bool UseBlockedUsers { get; set; } = false;

            [JsonProperty(PropertyName = "Cooldown")]
            public int Cooldown { get; set; } = 600;

            [JsonProperty(PropertyName = "Countdown")]
            public int Countdown { get; set; } = 15;

            [JsonProperty(PropertyName = "Daily Limit")]
            public int DailyLimit { get; set; } = 5;

            [JsonProperty(PropertyName = "VIP Daily Limits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPDailyLimits { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "VIP Cooldowns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPCooldowns { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "VIP Countdowns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPCountdowns { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "Enable Request UI")]
            public bool UI { get; set; }

            [JsonProperty(PropertyName = "Request Duration")]
            public int RequestDuration { get; set; } = 30;

            [JsonProperty(PropertyName = "Block TPA On Ceiling")]
            public bool BlockTPAOnCeiling { get; set; } = true;

            [JsonProperty(PropertyName = "Usable Out Of Building Blocked")]
            public bool UsableOutOfBuildingBlocked { get; set; } = false;

            [JsonProperty(PropertyName = "Usable Into Building Blocked")]
            public bool UsableIntoBuildingBlocked { get; set; } = false;

            [JsonProperty(PropertyName = "Allow Cupboard Owner When Building Blocked")]
            public bool CupOwnerAllowOnBuildingBlocked { get; set; } = true;

            [JsonProperty(PropertyName = "Allow Crafting")]
            public bool AllowCraft { get; set; } = false;

            [JsonProperty(PropertyName = "Pay")]
            public int Pay { get; set; } = 0;

            [JsonProperty(PropertyName = "Bypass")]
            public int Bypass { get; set; } = 0;

            [JsonProperty(PropertyName = "Hours Before Useable After Wipe")]
            public double Hours { get; set; } = 0;
        }

        public class TownSettings
        {
            [JsonProperty(PropertyName = "Command Enabled")]
            public bool Enabled { get; set; } = true;

            [JsonProperty(PropertyName = "Set Position From Monument Marker Name")]
            public string MonumentMarkerName { get; set; } = "";

            [JsonProperty(PropertyName = "Set Position From Monument Marker Name Offset")]
            public string MonumentMarkerNameOffset { get; set; } = "0 0 0";

            [JsonProperty(PropertyName = "Allow TPB")]
            public bool AllowTPB { get; set; } = true;

            [JsonProperty(PropertyName = "Allow Cave")]
            public bool AllowCave { get; set; }

            [JsonProperty(PropertyName = "Cooldown")]
            public int Cooldown { get; set; } = 600;

            [JsonProperty(PropertyName = "Countdown")]
            public int Countdown { get; set; } = 15;

            [JsonProperty(PropertyName = "Daily Limit")]
            public int DailyLimit { get; set; } = 5;

            [JsonProperty(PropertyName = "VIP Daily Limits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPDailyLimits { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "VIP Cooldowns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPCooldowns { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "VIP Countdowns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPCountdowns { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "Location")]
            public Vector3 Location { get; set; } = Vector3.zero;

            [JsonProperty(PropertyName = "Locations", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<Vector3> Locations { get; set; } = new List<Vector3>();

            [JsonProperty(PropertyName = "Teleport To Random Location")]
            public bool Random { get; set; } = true;

            [JsonProperty(PropertyName = "Usable Out Of Building Blocked")]
            public bool UsableOutOfBuildingBlocked { get; set; } = false;

            [JsonProperty(PropertyName = "Allow Crafting")]
            public bool AllowCraft { get; set; } = false;

            [JsonProperty(PropertyName = "Pay")]
            public int Pay { get; set; } = 0;

            [JsonProperty(PropertyName = "Bypass")]
            public int Bypass { get; set; } = 0;

            [JsonProperty(PropertyName = "Hours Before Useable After Wipe")]
            public double Hours { get; set; } = 0;

            public bool CanCraft(BasePlayer player, string command)
            {
                return AllowCraft || player.IPlayer.HasPermission($"nteleportation.craft{command}");
            }

            [JsonIgnore]
            public StoredData Teleports = new StoredData();

            [JsonIgnore]
            public string Command { get; set; }
        }

        private class Configuration
        {
            [JsonProperty(PropertyName = "Settings")]
            public PluginSettings Settings = new PluginSettings();

            [JsonProperty(PropertyName = "Admin")]
            public AdminSettings Admin = new AdminSettings();

            [JsonProperty(PropertyName = "Home")]
            public HomesSettings Home = new HomesSettings();

            [JsonProperty(PropertyName = "TPT")]
            public TPTSettings TPT = new TPTSettings();

            [JsonProperty(PropertyName = "TPR")]
            public TPRSettings TPR = new TPRSettings();

            [JsonProperty(PropertyName = "Dynamic Commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, TownSettings> DynamicCommands { get; set; } = DefaultCommands;
        }

        private static Dictionary<string, TownSettings> DefaultCommands = new Dictionary<string, TownSettings>
        {
            ["Town"] = new TownSettings() { Random = false },
            ["Island"] = new TownSettings() { AllowTPB = false },
            ["Outpost"] = new TownSettings(),
            ["Bandit"] = new TownSettings(),
        };

        public void InitializeDynamicCommands()
        {
            foreach (var entry in config.DynamicCommands)
            {
                if (!entry.Value.Enabled)
                {
                    continue;
                }
                else if (entry.Key.Equals("bandit", StringComparison.OrdinalIgnoreCase))
                {
                    if (CompoundTeleport == null || Convert.ToBoolean(CompoundTeleport?.Call("umodversion")))
                    {
                        banditEnabled = true;
                    }
                    else continue;
                }
                else if (entry.Key.Equals("outpost", StringComparison.OrdinalIgnoreCase))
                {
                    if (CompoundTeleport == null || Convert.ToBoolean(CompoundTeleport?.Call("umodversion")))
                    {
                        outpostEnabled = true;
                    }
                    else continue;
                }

                entry.Value.Command = entry.Key;
                RegisterCommand(entry.Key, nameof(CommandCustom));
            }

            RegisterCommand("ntp", nameof(CommandDynamic));
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                Config.Settings.Converters = new JsonConverter[] { new UnityVector3Converter() };
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
                SaveConfig();
            }
            catch (JsonException ex)
            {
                Debug.LogException(ex);
                LoadDefaultConfig();
            }
            config.Settings.ReappearEffects.Remove("");
            config.Settings.DisappearEffects.Remove("");
            config.TPR.TeleportRequestEffects.Remove("");
            config.TPR.TeleportAcceptEffects.Remove("");
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        protected override void LoadDefaultConfig()
        {
            config = new Configuration();
            Puts("Loaded default configuration.");
        }

        #endregion

        private class DisabledData
        {
            [JsonProperty("List of disabled commands")]
            public List<string> DisabledCommands = new List<string>();

            public DisabledData() { }
        }

        DisabledData DisabledCommandData = new DisabledData();

        private class AdminData
        {
            [JsonProperty("pl")]
            public Vector3 PreviousLocation { get; set; }

            [JsonProperty("b")]
            public bool BuildingBlocked { get; set; }

            [JsonProperty("c")]
            public bool AllowCrafting { get; set; }

            [JsonProperty("l")]
            public Dictionary<string, Vector3> Locations { get; set; } = new Dictionary<string, Vector3>(StringComparer.OrdinalIgnoreCase);
        }

        private class HomeData
        {
            public class Entry
            {
                public Vector3 Position;
                public BaseNetworkable Entity;
                public bool isEntity => Entity.IsValid() && !Entity.IsDestroyed;
                public bool wasEntity;
                public Entry() { }
                public Entry(Vector3 Position)
                {
                    this.Position = Position;
                }
                public Vector3 Get()
                {
                    if (isEntity)
                    {
                        return Entity.transform.position + Position;
                    }
                    return Position;
                }
            }

            public class Boat
            {
                public ulong Value;
                public Vector3 Offset;
                public Boat() { }
                public Boat(Entry entry)
                {
                    Offset = entry.Position;
                    Value = entry.Entity.net.ID.Value;
                }
            }

            [JsonProperty("l")]
            public Dictionary<string, Vector3> buildings { get; set; } = new Dictionary<string, Vector3>(StringComparer.OrdinalIgnoreCase);

            [JsonProperty("b")]
            public Dictionary<string, Boat> boats { get; set; } = new Dictionary<string, Boat>(StringComparer.OrdinalIgnoreCase);

            [JsonProperty("t")]
            public TeleportData Teleports { get; set; } = new TeleportData();

            [JsonIgnore]
            private Dictionary<string, Entry> Cache = new Dictionary<string, Entry>();

            [JsonIgnore]
            public Dictionary<string, Entry> Locations
            {
                get
                {
                    if (Cache.Count == 0)
                    {
                        InitializeBuildings();
                        InitializeBoats();
                    }
                    return Cache;
                }
            }

            private void InitializeBuildings()
            {
                foreach (var pair in buildings)
                {
                    Cache[pair.Key] = new Entry(pair.Value);
                }
            }

            private void InitializeBoats()
            {
                foreach (var pair in boats.ToList())
                {
                    var entity = BaseNetworkable.serverEntities.Find(new NetworkableId(pair.Value.Value));
                    if (!entity.IsValid() || entity.IsDestroyed) continue;
                    Cache[pair.Key] = new Entry
                    {
                        Position = pair.Value.Offset,
                        wasEntity = true,
                        Entity = entity
                    };
                }
            }

            public bool TryGetValue(string key, out Entry homeEntry)
            {
                return Locations.TryGetValue(key, out homeEntry);
            }

            public void Set(string key, Entry homeEntry)
            {
                Locations[key] = homeEntry;
                if (homeEntry.isEntity)
                {
                    boats[key] = new Boat(homeEntry);
                }
                else buildings[key] = homeEntry.Get();
            }

            public bool Remove(string key)
            {
                bool removed = boats.Remove(key) || buildings.Remove(key);
                return Locations.Remove(key) || removed;
            }
        }

        public class TeleportData
        {
            [JsonProperty("a")]
            public int Amount { get; set; }

            [JsonProperty("d")]
            public string Date { get; set; }

            [JsonProperty("t")]
            public int Timestamp { get; set; }
        }

        private class TeleportTimer
        {
            public Timer Timer { get; set; }
            public BasePlayer OriginPlayer { get; set; }
            public BasePlayer TargetPlayer { get; set; }
        }

        private List<string> GetMonumentMessages()
        {
            return new List<string>
            {
                "Abandoned Cabins",
                "Abandoned Supermarket",
                "Abandoned Military Base",
                "Airfield",
                "Arctic Research Base",
                "Bandit Camp",
                "Barn",
                "Crow's Nest",
                "Ferry Terminal",
                "Fishing Village",
                "Gas Station",
                "Giant Excavator Pit",
                "Harbor",
                "HQM Quarry",
                "Ice Lake",
                "Junkyard",
                "Large Barn",
                "Large Fishing Village",
                "Launch Site",
                "Lighthouse",
                "Military Tunnel",
                "Mining Outpost",
                "Missile Silo",
                "Mountain",
                "Oil Rig",
                "Large Oil Rig",
                "Outpost",
                "Oxum's Gas Station",
                "Power Plant",
                "Ranch",
                "Radtown",
                "Satellite Dish",
                "Sewer Branch",
                "Stone Quarry",
                "Substation",
                "Sulfur Quarry",
                "The Supermarket",
                "The Dome",
                "Train Tunnel",
                "Train Yard",
                "Underwater Lab",
                "Water Treatment Plant",
                "Water Well",
                "Wild Swamp",
            };
        }

        protected override void LoadDefaultMessages()
        {
            if (!_cmcCompleted)
            {
                timer.Once(1f, LoadDefaultMessages);
                return;
            }

            var monumentMessages = GetMonumentMessages();

            var en = new Dictionary<string, string>
            {
                {"ErrorTPR", "Teleporting to {0} is blocked ({1})"},
                {"AdminTP", "You teleported to {0}!"},
                {"AdminTPTarget", "{0} teleported to you!"},
                {"AdminTPPlayers", "You teleported {0} to {1}!"},
                {"AdminTPPlayer", "{0} teleported you to {1}!"},
                {"AdminTPPlayerTarget", "{0} teleported {1} to you!"},
                {"AdminTPCoordinates", "You teleported to {0}!"},
                {"AdminTPTargetCoordinates", "You teleported {0} to {1}!"},
                {"AdminTPOutOfBounds", "You tried to teleport to a set of coordinates outside the map boundaries!"},
                {"AdminTPBoundaries", "X and Z values need to be between -{0} and {0} while the Y value needs to be between -100 and 2000!"},
                {"AdminTPLocation", "You teleported to {0}!"},
                {"AdminTPLocationSave", "You have saved the current location!"},
                {"AdminTPLocationRemove", "You have removed the location {0}!"},
                {"AdminLocationList", "The following locations are available:"},
                {"AdminLocationListEmpty", "You haven't saved any locations!"},
                {"AdminTPBack", "You've teleported back to your previous location!"},
                {"AdminTPBackSave", "Your previous location has been saved, use /tpb to teleport back!"},
                {"AdminTPTargetCoordinatesTarget", "{0} teleported you to {1}!"},
                {"AdminTPConsoleTP", "You were teleported to {0}"},
                {"AdminTPConsoleTPPlayer", "You were teleported to {0}"},
                {"AdminTPConsoleTPPlayerTarget", "{0} was teleported to you!"},
                {"HomeTP", "You teleported to your home '{0}'!"},
                {"HomeAdminTP", "You teleported to {0}'s home '{1}'!"},
                {"HomeIce", "You can't use home on ice!"},
                {"HomeSave", "You have saved the current location as your home!"},
                {"HomeNoFoundation", "You can only use a home location on a foundation!"},
                {"HomeFoundationNotOwned", "You can't use home on someone else's house."},
                {"HomeFoundationUnderneathFoundation", "You can't use home on a foundation that is underneath another foundation."},
                {"HomeFoundationNotFriendsOwned", "You or a friend need to own the house to use home!"},
                {"HomeRemovedInvalid", "Your home '{0}' was removed because not on a foundation or not owned!"},
                {"HighWallCollision", "High Wall Collision!"},
                {"HomeRemovedDestroyed", "Your home '{0}' was removed because it no longer exists!"},
                {"HomeRemovedInsideBlock", "Your home '{0}' was removed because inside a foundation!"},
                {"HomeRemove", "You have removed your home {0}!"},
                {"HomeDelete", "You have removed {0}'s home '{1}'!"},
                {"HomeList", "The following homes are available:"},
                {"HomeListEmpty", "You haven't saved any homes!"},
                {"HomeMaxLocations", "Unable to set your home here, you have reached the maximum of {0} homes!"},
                {"HomeQuota", "You have set {0} of the maximum {1} homes!"},
                {"HomeTugboatNotAllowed", "You are not allowed to sethome on tugboats."},
                {"HomeTPStarted", "Teleporting to your home {0} in {1} seconds!"},
                {"PayToTown", "Standard payment of {0} applies to all {1} teleports!"},
                {"PayToTPR", "Standard payment of {0} applies to all tprs!"},
                {"HomeTPCooldown", "Your teleport is currently on cooldown. You'll have to wait {0} for your next teleport."},
                {"HomeTPCooldownBypass", "Your teleport was currently on cooldown. You chose to bypass that by paying {0} from your balance."},
                {"HomeTPCooldownBypassF", "Your teleport is currently on cooldown. You do not have sufficient funds - {0} - to bypass."},
                {"HomeTPCooldownBypassP", "You may choose to pay {0} to bypass this cooldown." },
                {"HomeTPCooldownBypassP2", "Type /home NAME {0}." },
                {"HomeTPLimitReached", "You have reached the daily limit of {0} teleports today!"},
                {"HomeTPAmount", "You have {0} home teleports left today!"},
                {"HomesListWiped", "You have wiped all the saved home locations!"},
                {"HomeTPBuildingBlocked", "You can't set your home if you are not allowed to build in this zone!"},
                {"HomeTPSwimming", "You can't set your home while swimming!"},
                {"HomeTPCrafting", "You can't set your home while crafting!"},
                {"Request", "You've requested a teleport to {0}!"},
                {"RequestUI", "<size=14><color=#FFA500>TP Request:\n</color> {0}</size>"},
                {"RequestTarget", "{0} requested to be teleported to you! Use '/tpa' to accept!"},
                {"RequestTargetOff", "Your request has been cancelled as the target is offline now." },
                {"RequestAccept", "<size=12>Accept</size>" },
                {"RequestReject", "<size=12>Reject</size>" },
                {"TPR_NoClan_NoFriend_NoTeam", "This command is only available to friends or teammates or clanmates!"},
                {"PendingRequest", "You already have a request pending, cancel that request or wait until it gets accepted or times out!"},
                {"PendingRequestTarget", "The player you wish to teleport to already has a pending request, try again later!"},
                {"NoPendingRequest", "You have no pending teleport request!"},
                {"Accept", "{0} has accepted your teleport request! Teleporting in {1} seconds!"},
                {"AcceptTarget", "You've accepted the teleport request of {0}!"},
                {"AcceptToggleOff", "You've disabled automatic /tpa!"},
                {"AcceptToggleOn", "You've enabled automatic /tpa!"},
                {"NotAllowed", "You are not allowed to use this command!"},
                {"Success", "You teleported to {0}!"},
                {"SuccessTarget", "{0} teleported to you!"},
                {"BlockedTeleportTarget", "You can't teleport to user \"{0}\", they have you teleport blocked!"},
                {"Cancelled", "Your teleport request to {0} was cancelled!"},
                {"CancelledTarget", "{0} teleport request was cancelled!"},
                {"TPCancelled", "Your teleport was cancelled!"},
                {"TPCancelledTarget", "{0} cancelled teleport!"},
                {"TPYouCancelledTarget", "You cancelled {0} teleport!"},
                {"TimedOut", "{0} did not answer your request in time!"},
                {"TimedOutTarget", "You did not answer {0}'s teleport request in time!"},
                {"TargetDisconnected", "{0} has disconnected, your teleport was cancelled!"},
                {"TPRCooldown", "Your teleport requests are currently on cooldown. You'll have to wait {0} to send your next teleport request."},
                {"TPRCooldownBypass", "Your teleport request was on cooldown. You chose to bypass that by paying {0} from your balance."},
                {"TPRCooldownBypassF", "Your teleport is currently on cooldown. You do not have sufficient funds - {0} - to bypass."},
                {"TPRCooldownBypassP", "You may choose to pay {0} to bypass this cooldown." },
                {"TPMoney", "{0} deducted from your account!"},
                {"TPNoMoney", "You do not have {0} in any account!"},
                {"TPRCooldownBypassP2", "Type /tpr {0}." },
                {"TPRCooldownBypassP2a", "Type /tpr NAME {0}." },
                {"TPRLimitReached", "You have reached the daily limit of {0} teleport requests today!"},
                {"TPRAmount", "You have {0} teleport requests left today!"},
                {"TPRTarget", "Your target is currently not available!"},
                {"TPDead", "You can't teleport while being dead!"},
                {"TPWounded", "You can't teleport while wounded!"},
                {"TPTooCold", "You're too cold to teleport!"},
                {"TPTooHot", "You're too hot to teleport!"},
                {"TPBoat", "You can't teleport while on a boat!"},
                {"TPTugboat", "You can't teleport while on a tugboat!"},
                {"TPHostile", "Can't teleport to outpost or bandit when hostile!"},
                {"TPJunkpile", "You can't teleport from a junkpile!"},
                {"HostileTimer", "Teleport available in {0} minutes."},
                {"TPMounted", "You can't teleport while seated!"},
                {"TPBuildingBlocked", "You can't teleport while in a building blocked area!"},
                {"TPAboveWater", "You can't teleport while above water!"},
                {"TPUnderWater", "You can't teleport while under water!"},
                {"TPTargetBuildingBlocked", "You can't teleport into a building blocked area!"},
                {"TPTargetInsideBlock", "You can't teleport into a foundation!"},
                {"TPTargetInsideEntity", "You can't teleport into another entity!"},
                {"TPTargetInsideRock", "You can't teleport into a rock!"},
                {"TPSwimming", "You can't teleport while swimming!"},
                {"TPCargoShip", "You can't teleport from the cargo ship!"},
                {"TPOilRig", "You can't teleport from the oil rig!"},
                {"TPExcavator", "You can't teleport from the excavator!"},
                {"TPHotAirBalloon", "You can't teleport to or from a hot air balloon!"},
                {"TPLift", "You can't teleport while in an elevator or bucket lift!"},
                {"TPBucketLift", "You can't teleport while in a bucket lift!"},
                {"TPRegLift", "You can't teleport while in an elevator!"},
                {"TPSafeZone", "You can't teleport from a safezone!"},
                {"TPFlagZone", "You can't teleport from this zone!"},
                {"TPNoEscapeBlocked", "You can't teleport while blocked!"},
                {"TPCrafting", "You can't teleport while crafting!"},
                {"TPBlockedItem", "You can't teleport while carrying: {0}!"},
                {"TPHomeSafeZoneOnly", "You can only teleport home from within a safe zone!" },
                {"TooCloseToMon", "You can't teleport so close to the {0}!"},
                {"TooCloseToCave", "You can't teleport so close to a cave!"},
                {"HomeTooCloseToCave", "You can't set home so close to a cave!"},
                {"HomeTooCloseToMon", "You can't set home so close to a monument!"},
                {"CannotTeleportFromHome", "You must leave your base to be able to teleport!"},
                {"WaitGlobalCooldown", "You must wait {0} on your global teleport cooldown!" },
                {"DM_TownTP", "You teleported to {0}!"},
                {"DM_TownTPNoLocation", "<color=yellow>{0}</color> location is currently not set!"},
                {"DM_TownTPDisabled", "<color=yellow>{0}</color> is currently disabled in config file!"},
                {"DM_TownTPLocation", "You have set the <color=yellow>{0}</color> location to {1}!"},
                {"DM_TownTPCreated", "You have created the command: <color=yellow>{0}</color>"},
                {"DM_TownTPRemoved", "You have removed the command: <color=yellow>{0}</color>"},
                {"DM_TownTPDoesNotExist", "Command does not exist: <color=yellow>{0}</color>"},
                {"DM_TownTPExists", "Command <color=yellow>{0}</color> already exists!"},
                {"DM_TownTPLocationsCleared", "You have cleared all locations for {0}!"},
                {"DM_TownTPStarted", "Teleporting to {0} in {1} seconds!"},
                {"DM_TownTPCooldown", "Your teleport is currently on cooldown. You'll have to wait {0} for your next teleport."},
                {"DM_TownTPCooldownBypass", "Your teleport request was on cooldown. You chose to bypass that by paying {0} from your balance."},
                {"DM_TownTPCooldownBypassF", "Your teleport is currently on cooldown. You do not have sufficient funds ({0}) to bypass."},
                {"DM_TownTPCooldownBypassP", "You may choose to pay {0} to bypass this cooldown." },
                {"DM_TownTPCooldownBypassP2", "Type <color=yellow>/{0} {1}</color>" },
                {"DM_TownTPLimitReached", "You have reached the daily limit of {0} teleports today! You'll have to wait {1} for your next teleport."},
                {"DM_TownTPAmount", "You have {0} <color=yellow>{1}</color> teleports left today!"},

                { "Days", "Days" },
                { "Hours", "Hours" },
                { "Minutes", "Minutes" },
                { "Seconds", "Seconds" },

                {"Interrupted", "Your teleport was interrupted!"},
                {"InterruptedTarget", "{0}'s teleport was interrupted!"},
                {"Unlimited", "Unlimited"},
                {
                    "TPInfoGeneral", string.Join(NewLine, new[]
                    {
                        "Please specify the module you want to view the info of.",
                        "The available modules are: ",
                    })
                },
                {
                    "TPHelpGeneral", string.Join(NewLine, new[]
                    {
                        "/tpinfo - Shows limits and cooldowns.",
                        "Please specify the module you want to view the help of.",
                        "The available modules are: ",
                    })
                },
                {
                    "TPHelpadmintp", string.Join(NewLine, new[]
                    {
                        "As an admin you have access to the following commands:",
                        "/tp \"targetplayer\" - Teleports yourself to the target player.",
                        "/tp \"player\" \"targetplayer\" - Teleports the player to the target player.",
                        "/tp x y z - Teleports you to the set of coordinates.",
                        "/tpl - Shows a list of saved locations.",
                        "/tpl \"location name\" - Teleports you to a saved location.",
                        "/tpsave \"location name\" - Saves your current position as the location name.",
                        "/tpremove \"location name\" - Removes the location from your saved list.",
                        "/tpb - Teleports you back to the place where you were before teleporting.",
                        "/home radius \"radius\" - Find all homes in radius.",
                        "/home delete \"player name|id\" \"home name\" - Remove a home from a player.",
                        "/home tp \"player name|id\" \"name\" - Teleports you to the home location with the name 'name' from the player.",
                        "/home homes \"player name|id\" - Shows you a list of all homes from the player."
                    })
                },
                {
                    "TPHelphome", string.Join(NewLine, new[]
                    {
                        "With the following commands you can set your home location to teleport back to:",
                        "/home add \"name\" - Saves your current position as the location name.",
                        "/home list - Shows you a list of all the locations you have saved.",
                        "/home remove \"name\" - Removes the location of your saved homes.",
                        "/home \"name\" - Teleports you to the home location."
                    })
                },
                {
                    "TPHelptpr", string.Join(NewLine, new[]
                    {
                        "With these commands you can request to be teleported to a player or accept someone else's request:",
                        "/tpr \"player name\" - Sends a teleport request to the player.",
                        "/tpa - Accepts an incoming teleport request.",
                        "/tpat - Toggle automatic /tpa on incoming teleport requests.",
                        "/tpc - Cancel teleport or request."
                    })
                },
                {
                    "TPSettingsGeneral", string.Join(NewLine, new[]
                    {
                        "Please specify the module you want to view the settings of. ",
                        "The available modules are:",
                    })
                },
                {
                    "TPSettingshome", string.Join(NewLine, new[]
                    {
                        "Home System has the current settings enabled:",
                        "Time between teleports: {0}",
                        "Daily amount of teleports: {1}",
                        "Amount of saved Home locations: {2}"
                    })
                },
                {
                    "TPSettingsbandit", string.Join(NewLine, new[]
                    {
                        "Bandit System has the current settings enabled:",
                        "Time between teleports: {0}",
                        "Daily amount of teleports: {1}"
                    })
                },
                {
                    "TPSettingsoutpost", string.Join(NewLine, new[]
                    {
                        "Outpost System has the current settings enabled:",
                        "Time between teleports: {0}",
                        "Daily amount of teleports: {1}"
                    })
                },
                {
                    "TPSettingstpr", string.Join(NewLine, new[]
                    {
                        "TPR System has the current settings enabled:",
                        "Time between teleports: {0}",
                        "Daily amount of teleports: {1}"
                    })
                },
                {
                    "TPSettingstown", string.Join(NewLine, new[]
                    {
                        "Town System has the current settings enabled:",
                        "Time between teleports: {0}",
                        "Daily amount of teleports: {1}"
                    })
                },
                {
                    "TPSettingsdynamic", string.Join(NewLine, new[]
                    {
                        "{0} System has the current settings enabled:",
                        "Time between teleports: {1}",
                        "Daily amount of teleports: {2}"
                    })
                },
                
                {"TPT_True", "enabled"},
                {"TPT_False", "disabled"},
                {"TPT_clan", "{1} clan has been {0}."},
                {"TPT_friend", "{1} friend has been {0}."},
                {"TPT_team", "{1} team has been {0}."},
                {"NotValidTPT", "Not valid, player is not"},
                {"NotValidTPTFriend", " a friend!"},
                {"NotValidTPTTeam", " on your team!"},
                {"NotValidTPTClan", " in your clan!"},												  
                {"TPTInfo", "{4} auto accepts teleport requests.\n<color={5}>Green</color> = <color={5}>Enabled</color>\n<color={6}>Red</color> = <color={6}>Disabled</color>\n\n/{0} <color={1}>clan</color> - Toggle {4} for clan members/allies.\n/{0} <color={2}>team</color> - Toggle {4} for teammates.\n/{0} <color={3}>friend</color> - Toggle {4} for friends."},
                
                {"PlayerNotFound", "The specified player couldn't be found please try again!"},
                {"MultiplePlayers", "Found multiple players: {0}"},
                {"CantTeleportToSelf", "You can't teleport to yourself!"},
                {"CantTeleportPlayerToSelf", "You can't teleport a player to himself!"},
                {"CantTeleportPlayerToYourself", "You can't teleport a player to yourself!"},
                {"TeleportPendingTPC", "You can't initiate another teleport while you have a teleport pending! Use /tpc to cancel this."},
                {"TeleportPendingTarget", "You can't request a teleport to someone who's about to teleport!"},
                {"LocationExists", "A location with this name already exists at {0}!"},
                {"LocationExistsNearby", "A location with the name {0} already exists near this position!"},
                {"LocationNotFound", "Couldn't find a location with that name!"},
                {"NoPreviousLocationSaved", "No previous location saved!"},
                {"HomeExists", "You have already saved a home location by this name!"},
                {"HomeExistsNearby", "A home location with the name {0} already exists near this position!"},
                {"HomeNotFound", "Couldn't find your home with that name!"},
                {"InvalidCoordinates", "The coordinates you've entered are invalid!"},
                {"InvalidHelpModule", "Invalid module supplied!"},
                {"InvalidCharacter", "You have used an invalid character, please limit yourself to the letters a to z and numbers."},
                {"NotUseable", "You must wait another {0}after the wipe to use this command." },
                {
                    "SyntaxCommandTP", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tp command as follows:",
                        "/tp \"targetplayer\" - Teleports yourself to the target player.",
                        "/tp \"player\" \"targetplayer\" - Teleports the player to the target player.",
                        "/tp x y z - Teleports you to the set of coordinates.",
                        "/tp \"player\" x y z - Teleports the player to the set of coordinates."
                    })
                },
                {
                    "SyntaxCommandTPL", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tpl command as follows:",
                        "/tpl - Shows a list of saved locations.",
                        "/tpl \"location name\" - Teleports you to a saved location."
                    })
                },
                {
                    "SyntaxCommandTPSave", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tpsave command as follows:",
                        "/tpsave \"location name\" - Saves your current position as 'location name'."
                    })
                },
                {
                    "SyntaxCommandTPRemove", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tpremove command as follows:",
                        "/tpremove \"location name\" - Removes the location with the name 'location name'."
                    })
                },
                {
                    "SyntaxCommandTPN", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tpn command as follows:",
                        "/tpn \"targetplayer\" - Teleports yourself the default distance behind the target player.",
                        "/tpn \"targetplayer\" \"distance\" - Teleports you the specified distance behind the target player."
                    })
                },
                {
                    "SyntaxCommandSetHome", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /home add command as follows:",
                        "/home add \"name\" - Saves the current location as your home with the name 'name'."
                    })
                },
                {
                    "SyntaxCommandRemoveHome", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /home remove command as follows:",
                        "/home remove \"name\" - Removes the home location with the name 'name'."
                    })
                },
                {
                    "SyntaxCommandHome", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /home command as follows:",
                        "/home \"name\" - Teleports yourself to your home with the name 'name'.",
                        "/home \"name\" pay - Teleports yourself to your home with the name 'name', avoiding cooldown by paying for it.",
                        "/home add \"name\" - Saves the current location as your home with the name 'name'.",
                        "/home list - Shows you a list of all your saved home locations.",
                        "/home remove \"name\" - Removes the home location with the name 'name'."
                    })
                },
                {
                    "SyntaxCommandHomeAdmin", string.Join(NewLine, new[]
                    {
                        "/home radius \"radius\" - Shows you a list of all homes in radius(10).",
                        "/home delete \"player name|id\" \"name\" - Removes the home location with the name 'name' from the player.",
                        "/home tp \"player name|id\" \"name\" - Teleports you to the home location with the name 'name' from the player.",
                        "/home homes \"player name|id\" - Shows you a list of all homes from the player."
                    })
                },
                {
                    "SyntaxCommandTown", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /town command as follows:",
                        "/town - Teleports yourself to town.",
                        "/town pay - Teleports yourself to town, paying the penalty."
                    })
                },
                {
                    "SyntaxCommandTownAdmin", string.Join(NewLine, new[]
                    {
                        "/town set - Saves the current location as town.",
                    })
                },
                {
                    "SyntaxCommandOutpost", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /outpost command as follows:",
                        "/outpost - Teleports yourself to the Outpost.",
                        "/outpost pay - Teleports yourself to the Outpost, paying the penalty."
                    })
                },
                {
                    "SyntaxCommandOutpostAdmin", string.Join(NewLine, new[]
                    {
                        "/outpost set - Saves the current location as Outpost.",
                    })
                },
                {
                    "SyntaxCommandBandit", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /bandit command as follows:",
                        "/bandit - Teleports yourself to the Bandit Town.",
                        "/bandit pay - Teleports yourself to the Bandit Town, paying the penalty."
                    })
                },
                {
                    "SyntaxCommandBanditAdmin", string.Join(NewLine, new[]
                    {
                        "/bandit set - Saves the current location as Bandit Town.",
                    })
                },
                {
                    "SyntaxCommandHomeDelete", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /home delete command as follows:",
                        "/home delete \"player name|id\" \"name\" - Removes the home location with the name 'name' from the player."
                    })
                },
                {
                    "SyntaxCommandHomeAdminTP", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /home tp command as follows:",
                        "/home tp \"player name|id\" \"name\" - Teleports you to the home location with the name 'name' from the player."
                    })
                },
                {
                    "SyntaxCommandHomeHomes", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /home homes command as follows:",
                        "/home homes \"player name|id\" - Shows you a list of all homes from the player."
                    })
                },
                {
                    "SyntaxCommandListHomes", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /home list command as follows:",
                        "/home list - Shows you a list of all your saved home locations."
                    })
                },
                {
                    "SyntaxCommandTPR", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tpr command as follows:",
                        "/tpr \"player name\" - Sends out a teleport request to 'player name'."
                    })
                },
                {
                    "SyntaxCommandTPA", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tpa command as follows:",
                        "/tpa - Accepts an incoming teleport request."
                    })
                },
                {
                    "SyntaxCommandTPC", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tpc command as follows:",
                        "/tpc - Cancels an teleport request."
                    })
                },
                {
                    "SyntaxConsoleCommandToPos", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the teleport.topos console command as follows:",
                        " > teleport.topos \"player\" x y z"
                    })
                },
                {
                    "SyntaxConsoleCommandToPlayer", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the teleport.toplayer console command as follows:",
                        " > teleport.toplayer \"player\" \"target player\""
                    })
                },
                {"LogTeleport", "{0} teleported to {1}."},
                {"LogTeleportPlayer", "{0} teleported {1} to {2}."},
                {"LogTeleportBack", "{0} teleported back to previous location."}
            };

            foreach (var key in config.DynamicCommands.Keys)
            {
                en[key] = key;
            }

            foreach (var key in monumentMessages)
            {
                en[key] = key;
            }

            lang.RegisterMessages(en, this, "en");

            var ru = new Dictionary<string, string>
            {
                {"ErrorTPR", "Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑ Ðº {0} Ð±Ð»Ð¾ÐºÐ¸ÑÐ¾Ð²Ð°Ð½ ({1})"},
                {"AdminTP", "ÐÑ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°Ð½Ñ Ðº {0}!"},
                {"AdminTPTarget", "{0} ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°Ð» Ð²Ð°Ñ!"},
                {"AdminTPPlayers", "ÐÑ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°Ð»Ð¸ {0} Ðº {1}!"},
                {"AdminTPPlayer", "{0} ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°Ð» Ð²Ð°Ñ Ðº {1}!"},
                {"AdminTPPlayerTarget", "{0} ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°Ð» {1} Ðº Ð²Ð°Ð¼!"},
                {"AdminTPCoordinates", "ÐÑ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°Ð½Ñ Ðº {0}!"},
                {"AdminTPTargetCoordinates", "ÐÑ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°Ð»Ð¸ {0} Ðº {1}!"},
                {"AdminTPOutOfBounds", "ÐÑ Ð¿ÑÑÐ°Ð»Ð¸ÑÑ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ Ðº ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÐ°Ð¼ Ð²Ð½Ðµ Ð³ÑÐ°Ð½Ð¸Ñ ÐºÐ°ÑÑÑ!"},
                {"AdminTPBoundaries", "ÐÐ½Ð°ÑÐµÐ½Ð¸Ñ X Ð¸ Z Ð´Ð¾Ð»Ð¶Ð½Ñ Ð±ÑÑÑ Ð¼ÐµÐ¶Ð´Ñ -{0} Ð¸ {0}, Ð° Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ Y Ð¼ÐµÐ¶Ð´Ñ -100 Ð¸ 2000!"},
                {"AdminTPLocation", "ÐÑ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°Ð½Ñ Ðº {0}!"},
                {"AdminTPLocationSave", "ÐÑ ÑÐ¾ÑÑÐ°Ð½Ð¸Ð»Ð¸ ÑÐµÐºÑÑÐµÐµ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ!"},
                {"AdminTPLocationRemove", "ÐÑ ÑÐ´Ð°Ð»Ð¸Ð»Ð¸ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ {0}!"},
                {"AdminLocationList", "ÐÐ¾ÑÑÑÐ¿Ð½Ñ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ðµ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ:"},
                {"AdminLocationListEmpty", "ÐÑ Ð½Ðµ ÑÐ¾ÑÑÐ°Ð½Ð¸Ð»Ð¸ Ð½Ð¸ÐºÐ°ÐºÐ¸Ñ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ð¹!"},
                {"AdminTPBack", "ÐÑ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°Ð½Ñ Ð½Ð°Ð·Ð°Ð´, Ð² Ð²Ð°ÑÐµ Ð¿ÑÐµÐ´ÑÐ´ÑÑÐµÐµ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ!"},
                {"AdminTPBackSave", "ÐÐ°ÑÐµ Ð¿ÑÐµÐ´ÑÐ´ÑÑÐµÐµ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ ÑÐ¾ÑÑÐ°Ð½ÐµÐ½Ð¾, Ð¸ÑÐ¿Ð¾Ð»ÑÐ·ÑÐ¹ÑÐµ <color=yellow>/tpb</color>, ÑÑÐ¾Ð±Ñ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ Ð½Ð°Ð·Ð°Ð´!"},
                {"AdminTPTargetCoordinatesTarget", "{0} ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°Ð» Ð²Ð°Ñ Ðº {1}!"},
                {"AdminTPConsoleTP", "ÐÑ Ð±ÑÐ»Ð¸ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°Ð½Ñ Ðº {0}"},
                {"AdminTPConsoleTPPlayer", "ÐÑ Ð±ÑÐ»Ð¸ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°Ð½Ñ Ðº {0}"},
                {"AdminTPConsoleTPPlayerTarget", "{0} Ð±ÑÐ» ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°Ð½ Ðº Ð²Ð°Ð¼!"},
                {"HomeTP", "ÐÑ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°Ð½Ñ Ð² Ð²Ð°Ñ Ð´Ð¾Ð¼ '{0}'!"},
                {"HomeAdminTP", "ÐÑ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°Ð½Ñ Ðº Ð´Ð¾Ð¼Ñ '{1}' Ð¿ÑÐ¸Ð½Ð°Ð´Ð»ÐµÐ¶Ð°ÑÐµÐ¼Ñ {0}!"},
                {"HomeIce", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ Ð·Ð±ÐµÑÐµÐ³ÑÐ¸ Ð¼ÑÑÑÐµ ÑÐ¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ ÑÐº Ð±ÑÐ´Ð¸Ð½Ð¾Ðº Ð½Ð° ÐºÑÐ¸Ð¶Ð°Ð½Ð¾Ð¼Ñ Ð¾Ð·ÐµÑÑ!"},
                {"HomeSave", "ÐÑ ÑÐ¾ÑÑÐ°Ð½Ð¸Ð»Ð¸ ÑÐµÐºÑÑÐµÐµ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ ÐºÐ°Ðº Ð²Ð°Ñ Ð´Ð¾Ð¼!"},
                {"HomeNoFoundation", "ÐÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð² ÐºÐ°ÑÐµÑÑÐ²Ðµ Ð´Ð¾Ð¼Ð° ÑÐ°Ð·ÑÐµÑÐµÐ½Ð¾ ÑÐ¾Ð»ÑÐºÐ¾ Ð½Ð° ÑÑÐ½Ð´Ð°Ð¼ÐµÐ½ÑÐµ!"},
                {"HomeFoundationNotOwned", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ home Ð² ÑÑÐ¶Ð¾Ð¼ Ð´Ð¾Ð¼Ðµ."},
                {"HomeFoundationUnderneathFoundation", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ home Ð½Ð° ÑÑÐ½Ð´Ð°Ð¼ÐµÐ½ÑÐµ, ÐºÐ¾ÑÐ¾ÑÑÐ¹ Ð½Ð°ÑÐ¾Ð´Ð¸ÑÑÑ Ð¿Ð¾Ð´ Ð´ÑÑÐ³Ð¸Ð¼ ÑÑÐ½Ð´Ð°Ð¼ÐµÐ½ÑÐ¾Ð¼."},
                {"HomeFoundationNotFriendsOwned", "ÐÑ, Ð¸Ð»Ð¸ Ð²Ð°Ñ Ð´ÑÑÐ³, Ð´Ð¾Ð»Ð¶Ð½Ñ Ð±ÑÑÑ Ð²Ð»Ð°Ð´ÐµÐ»ÑÑÐµÐ¼ Ð´Ð¾Ð¼Ð°, ÑÑÐ¾Ð±Ñ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ home!"},
                {"HomeRemovedInvalid", "ÐÐ°Ñ Ð´Ð¾Ð¼ '{0}' Ð±ÑÐ» ÑÐ´Ð°Ð»ÑÐ½ Ð¿Ð¾ÑÐ¾Ð¼Ñ, ÑÑÐ¾ Ð½Ðµ Ð½Ð° ÑÑÐ½Ð´Ð°Ð¼ÐµÐ½ÑÐµ, Ð¸Ð»Ð¸ Ñ ÑÑÐ½Ð´Ð°Ð¼ÐµÐ½ÑÐ° Ð½Ð¾Ð²ÑÐ¹ Ð²Ð»Ð°Ð´ÐµÐ»ÐµÑ!"},
                {"HighWallCollision", "Ð¡ÑÐ¾Ð»ÐºÐ½Ð¾Ð²ÐµÐ½Ð¸Ðµ ÐÑÑÐ¾ÐºÐ¸Ñ Ð¡ÑÐµÐ½!"},
                {"HomeRemovedDestroyed", "ÐÐ°Ñ Ð´Ð¾Ð¼ '{0}' ÑÐ´Ð°Ð»ÐµÐ½, ÑÐ°Ðº ÐºÐ°Ðº ÐµÐ³Ð¾ Ð±Ð¾Ð»ÑÑÐµ Ð½Ðµ ÑÑÑÐµÑÑÐ²ÑÐµÑ!"},
                {"HomeRemovedInsideBlock", "ÐÐ°Ñ Ð´Ð¾Ð¼ '{0}' Ð±ÑÐ» ÑÐ´Ð°Ð»ÑÐ½ Ð¿Ð¾ÑÐ¾Ð¼Ñ, ÑÑÐ¾ Ð²Ð½ÑÑÑÐ¸ ÑÑÐ½Ð´Ð°Ð¼ÐµÐ½ÑÐ°!"},
                {"HomeRemove", "ÐÑ ÑÐ´Ð°Ð»Ð¸Ð»Ð¸ ÑÐ²Ð¾Ð¹ Ð´Ð¾Ð¼ {0}!"},
                {"HomeDelete", "ÐÑ ÑÐ´Ð°Ð»Ð¸Ð»Ð¸ Ð´Ð¾Ð¼ '{1}' Ð¿ÑÐ¸Ð½Ð°Ð´Ð»ÐµÐ¶Ð°ÑÐ¸Ð¹ {0}!"},
                {"HomeList", "ÐÐ¾ÑÑÑÐ¿Ð½Ñ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ðµ Ð´Ð¾Ð¼Ð°:"},
                {"HomeListEmpty", "ÐÑ Ð½Ðµ ÑÐ¾ÑÑÐ°Ð½Ð¸Ð»Ð¸ Ð½Ð¸ Ð¾Ð´Ð½Ð¾Ð³Ð¾ Ð´Ð¾Ð¼Ð°!"},
                {"HomeMaxLocations", "ÐÐµÐ²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ ÑÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ Ð·Ð´ÐµÑÑ Ð²Ð°Ñ Ð´Ð¾Ð¼, Ð²Ñ Ð´Ð¾ÑÑÐ¸Ð³Ð»Ð¸ Ð»Ð¸Ð¼Ð¸ÑÐ° Ð² {0} Ð´Ð¾Ð¼Ð¾Ð²!"},
                {"HomeQuota", "ÐÑ ÑÑÑÐ°Ð½Ð¾Ð²Ð¸Ð»Ð¸ {0} Ð¸Ð· {1} Ð¼Ð°ÐºÑÐ¸Ð¼Ð°Ð»ÑÐ½Ð¾ Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½ÑÑ Ð´Ð¾Ð¼Ð¾Ð²!"},
                {"HomeTugboatNotAllowed", "You are not allowed to sethome on tugboats."},
                {"HomeTPStarted", "Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ñ Ð² Ð²Ð°Ñ Ð´Ð¾Ð¼ {0} ÑÐµÑÐµÐ· {1} ÑÐµÐºÑÐ½Ð´!"},
                {"PayToTown", "Ð¡ÑÐ°Ð½Ð´Ð°ÑÑÐ½ÑÐ¹ Ð¿Ð»Ð°ÑÐµÐ¶ {0} ÑÐ°ÑÐ¿ÑÐ¾ÑÑÑÐ°Ð½ÑÐµÑÑÑ Ð½Ð° Ð²ÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑ Ð² Ð³Ð¾ÑÐ¾Ð´!"},
                {"PayToTPR", "Ð¡ÑÐ°Ð½Ð´Ð°ÑÑÐ½ÑÐ¹ Ð¿Ð»Ð°ÑÐµÐ¶ {0} ÑÐ°ÑÐ¿ÑÐ¾ÑÑÑÐ°Ð½ÑÐµÑÑÑ Ð½Ð° Ð²ÑÐµ tpr'Ñ!"},
                {"HomeTPCooldown", "ÐÐ°Ñ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑ Ð¿ÐµÑÐµÐ·Ð°ÑÑÐ¶Ð°ÐµÑÑÑ. ÐÐ°Ð¼ Ð½ÐµÐ¾Ð±ÑÐ¾Ð´Ð¸Ð¼Ð¾ Ð¿Ð¾Ð´Ð¾Ð¶Ð´Ð°ÑÑ {0} Ð´Ð¾ ÑÐ»ÐµÐ´ÑÑÑÐµÐ¹ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ð¸."},
                {"HomeTPCooldownBypass", "ÐÐ°Ñ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑ Ð±ÑÐ» Ð½Ð° Ð¿ÐµÑÐµÐ·Ð°ÑÑÐ´ÐºÐµ. ÐÑ Ð²ÑÐ±ÑÐ°Ð»Ð¸ Ð¸Ð·Ð±ÐµÐ¶Ð°ÑÑ Ð¾Ð¶Ð¸Ð´Ð°Ð½Ð¸Ñ, Ð¾Ð¿Ð»Ð°ÑÐ¸Ð² {0} Ñ Ð²Ð°ÑÐµÐ³Ð¾ Ð±Ð°Ð»Ð°Ð½ÑÐ°."},
                {"HomeTPCooldownBypassF", "ÐÐ°Ñ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑ Ð¿ÐµÑÐµÐ·Ð°ÑÑÐ¶Ð°ÐµÑÑÑ. Ð£ Ð²Ð°Ñ Ð½ÐµÐ´Ð¾ÑÑÐ°ÑÐ¾ÑÐ½Ð¾ ÑÑÐµÐ´ÑÑÐ² - {0} - ÑÑÐ¾Ð±Ñ Ð¸Ð·Ð±ÐµÐ¶Ð°ÑÑ Ð¾Ð¶Ð¸Ð´Ð°Ð½Ð¸Ñ."},
                {"HomeTPCooldownBypassP", "ÐÑ Ð¼Ð¾Ð¶ÐµÑÐµ Ð²ÑÐ±ÑÐ°ÑÑ Ð¾Ð¿Ð»Ð°ÑÐ¸ÑÑ {0} ÑÑÐ¾Ð±Ñ Ð¸Ð·Ð±ÐµÐ¶Ð°ÑÑ Ð¾Ð¶Ð¸Ð´Ð°Ð½Ð¸Ñ Ð¿ÐµÑÐµÐ·Ð°ÑÑÐ´ÐºÐ¸." },
                {"HomeTPCooldownBypassP2", "ÐÐ°Ð¿Ð¸ÑÐ¸ÑÐµ <color=yellow>/home \"Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð´Ð¾Ð¼Ð°\" {0}</color>." },
                {"HomeTPLimitReached", "ÐÑ Ð¸ÑÑÐµÑÐ¿Ð°Ð»Ð¸ ÐµÐ¶ÐµÐ´Ð½ÐµÐ²Ð½ÑÐ¹ Ð»Ð¸Ð¼Ð¸Ñ {0} ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ð¹ ÑÐµÐ³Ð¾Ð´Ð½Ñ!"},
                {"HomeTPAmount", "Ð£ Ð²Ð°Ñ Ð¾ÑÑÐ°Ð»Ð¾ÑÑ {0} ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ð¹ Ð´Ð¾Ð¼Ð¾Ð¹ ÑÐµÐ³Ð¾Ð´Ð½Ñ!"},
                {"HomesListWiped", "ÐÑ Ð¾ÑÐ¸ÑÑÐ¸Ð»Ð¸ Ð²ÑÐµ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ, ÑÐ¾ÑÑÐ°Ð½ÑÐ½Ð½ÑÐµ ÐºÐ°Ðº Ð´Ð¾Ð¼!"},
                {"HomeTPBuildingBlocked", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐ¾ÑÑÐ°Ð½Ð¸ÑÑ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð² ÐºÐ°ÑÐµÑÑÐ²Ðµ Ð´Ð¾Ð¼Ð°, ÐµÑÐ»Ð¸ Ñ Ð²Ð°Ñ Ð½ÐµÑ Ð¿ÑÐ°Ð² Ð½Ð° ÑÑÑÐ¾Ð¸ÑÐµÐ»ÑÑÑÐ²Ð¾ Ð² ÑÑÐ¾Ð¹ Ð·Ð¾Ð½Ðµ!"},
                {"HomeTPSwimming", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÑÑÐ°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÑÑ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð° ÐºÐ°ÑÐµÑÑÐ²Ðµ Ð´Ð¾Ð¼Ð° Ð¿Ð¾ÐºÐ° Ð¿Ð»ÑÐ²ÑÑÐµ!"},
                {"HomeTPCrafting", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÑÑÐ°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÑÑ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð° ÐºÐ°ÑÐµÑÑÐ²Ðµ Ð´Ð¾Ð¼Ð° Ð² Ð¿ÑÐ¾ÑÐµÑÑÐµ ÐºÑÐ°ÑÑÐ°!"},
                {"Request", "ÐÑ Ð·Ð°Ð¿ÑÐ¾ÑÐ¸Ð»Ð¸ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ñ Ðº {0}!"},
                {"RequestUI", "<size=14><color=#FFA500>TP Request:\n</color> {0}</size>"},
                {"RequestTarget", "{0} Ð·Ð°Ð¿ÑÐ¾ÑÐ¸Ð» ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ñ Ðº Ð²Ð°Ð¼! ÐÑÐ¿Ð¾Ð»ÑÐ·ÑÐ¹ÑÐµ <color=yellow>/tpa</color>, ÑÑÐ¾Ð±Ñ Ð¿ÑÐ¸Ð½ÑÑÑ!"},
                {"RequestTargetOff", "ÐÐ°Ñ Ð·Ð°Ð¿ÑÐ¾Ñ Ð±ÑÐ» Ð¾ÑÐ¼ÐµÐ½ÐµÐ½, ÑÐ°Ðº ÐºÐ°Ðº ÑÐµÐ»Ñ ÑÐµÐ¹ÑÐ°Ñ Ð½Ðµ Ð² ÑÐµÑÐ¸." },
                {"RequestAccept", "<size=12>ÐÑÐ¸Ð½ÑÑÑ</size>" },
                {"RequestReject", "<size=12>ÐÑÐºÐ°Ð·Ð°ÑÑÑÑ</size>" },
                {"TPR_NoClan_NoFriend_NoTeam", "Ð­ÑÐ° ÐºÐ¾Ð¼Ð°Ð½Ð´Ð° Ð´Ð¾ÑÑÑÐ¿Ð½Ð° ÑÐ¾Ð»ÑÐºÐ¾ Ð´ÑÑÐ·ÑÑÐ¼, ÑÑÐ°ÑÑÐ½Ð¸ÐºÐ°Ð¼ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ Ð¸Ð»Ð¸ ÐºÐ»Ð°Ð½Ð°!"},
                {"PendingRequest", "Ð£ Ð²Ð°Ñ ÑÐ¶Ðµ ÐµÑÑÑ Ð°ÐºÑÐ¸Ð²Ð½ÑÐ¹ Ð·Ð°Ð¿ÑÐ¾Ñ, Ð¾ÑÐ¼ÐµÐ½Ð¸ÑÐµ ÐµÐ³Ð¾, Ð¾Ð¶Ð¸Ð´Ð°Ð¹ÑÐµ Ð¿Ð¾Ð´ÑÐ²ÐµÑÐ¶Ð´ÐµÐ½Ð¸Ñ, Ð»Ð¸Ð±Ð¾ Ð¾ÑÐ¼ÐµÐ½Ñ Ð¿Ð¾ ÑÐ°Ð¹Ð¼Ð°ÑÑÑ!"},
                {"PendingRequestTarget", "Ð£ Ð¸Ð³ÑÐ¾ÐºÐ°, Ðº ÐºÐ¾ÑÐ¾ÑÐ¾Ð¼Ñ Ð²Ñ ÑÐ¾ÑÐ¸ÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ ÑÐ¶Ðµ ÐµÑÑÑ Ð°ÐºÑÐ¸Ð²Ð½ÑÐ¹ Ð·Ð°Ð¿ÑÐ¾Ñ, Ð¿Ð¾Ð¿ÑÐ¾Ð±ÑÐ¹ÑÐµ Ð¿Ð¾Ð·Ð¶Ðµ!"},
                {"NoPendingRequest", "Ð£ Ð²Ð°Ñ Ð½ÐµÑ Ð°ÐºÑÐ¸Ð²Ð½ÑÑ Ð·Ð°Ð¿ÑÐ¾ÑÐ¾Ð² Ð½Ð° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ñ!"},
                {"Accept", "{0} Ð¿ÑÐ¸Ð½ÑÐ» Ð²Ð°Ñ Ð·Ð°Ð¿ÑÐ¾Ñ! Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ñ ÑÐµÑÐµÐ· {1} ÑÐµÐºÑÐ½Ð´!"},
                {"AcceptTarget", "ÐÑ Ð¿ÑÐ¸Ð½ÑÐ»Ð¸ Ð·Ð°Ð¿ÑÐ¾Ñ Ð½Ð° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ñ {0}!"},
                {"AcceptToggleOff", "ÐÑ Ð¾ÑÐºÐ»ÑÑÐ¸Ð»Ð¸ Ð°Ð²ÑÐ¾Ð¼Ð°ÑÐ¸ÑÐµÑÐºÐ¾Ðµ /tpa!"},
                {"AcceptToggleOn", "ÐÑ Ð²ÐºÐ»ÑÑÐ¸Ð»Ð¸ Ð°Ð²ÑÐ¾Ð¼Ð°ÑÐ¸ÑÐµÑÐºÐ¾Ðµ /tpa!"},
                {"NotAllowed", "ÐÐ°Ð¼ Ð½Ðµ ÑÐ°Ð·ÑÐµÑÐµÐ½Ð¾ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ ÑÑÑ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ!"},
                {"Success", "ÐÑ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°Ð½Ñ Ðº {0}!"},
                {"SuccessTarget", "{0} ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°Ð½ Ðº Ð²Ð°Ð¼!"},
                {"BlockedTeleportTarget", "You can't teleport to user \"{0}\", they have you teleport blocked!"},
                {"Cancelled", "ÐÐ°Ñ Ð·Ð°Ð¿ÑÐ¾Ñ Ð½Ð° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ñ Ðº {0} Ð±ÑÐ» Ð¾ÑÐ¼ÐµÐ½ÑÐ½!"},
                {"CancelledTarget", "ÐÐ°Ð¿ÑÐ¾Ñ Ð½Ð° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ñ {0} Ð±ÑÐ» Ð¾ÑÐ¼ÐµÐ½ÑÐ½!"},
                {"TPCancelled", "ÐÐ°ÑÐ° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ñ Ð¾ÑÐ¼ÐµÐ½ÐµÐ½Ð°!"},
                {"TPCancelledTarget", "{0} Ð¾ÑÐ¼ÐµÐ½Ð¸Ð» ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ñ!"},
                {"TPYouCancelledTarget", "ÐÑ Ð¾ÑÐ¼ÐµÐ½Ð¸Ð»Ð¸ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ñ {0}!"},
                {"TimedOut", "{0} Ð½Ðµ Ð¾ÑÐ²ÐµÑÐ¸Ð» Ð½Ð° Ð²Ð°Ñ Ð·Ð°Ð¿ÑÐ¾Ñ Ð²Ð¾ Ð²ÑÐµÐ¼Ñ!"},
                {"TimedOutTarget", "ÐÑ Ð½Ðµ Ð¾ÑÐ²ÐµÑÐ¸Ð»Ð¸ Ð²Ð¾Ð²ÑÐµÐ¼Ñ Ð½Ð° Ð·Ð°Ð¿ÑÐ¾Ñ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ð¸ Ð¾Ñ {0}!"},
                {"TargetDisconnected", "{0} Ð¾ÑÐºÐ»ÑÑÐ¸Ð»ÑÑ, Ð²Ð°ÑÐ° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ñ Ð¾ÑÐ¼ÐµÐ½ÐµÐ½Ð°!"},
                {"TPRCooldown", "ÐÐ°ÑÐ¸ Ð·Ð°Ð¿ÑÐ¾ÑÑ Ð½Ð° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ñ Ð² Ð´Ð°Ð½Ð½ÑÐ¹ Ð¼Ð¾Ð¼ÐµÐ½Ñ Ð½Ð° Ð¿ÐµÑÐµÐ·Ð°ÑÑÐ´ÐºÐµ. ÐÐ°Ð¼ Ð½ÐµÐ¾Ð±ÑÐ¾Ð´Ð¸Ð¼Ð¾ Ð¿Ð¾Ð´Ð¾Ð¶Ð´Ð°ÑÑ {0} Ð¿ÑÐµÐ¶Ð´Ðµ ÑÐµÐ¼ Ð¾ÑÐ¿ÑÐ°Ð²Ð¸ÑÑ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ð¹ Ð·Ð°Ð¿ÑÐ¾Ñ."},
                {"TPRCooldownBypass", "ÐÐ°ÑÐ¸ Ð·Ð°Ð¿ÑÐ¾ÑÑ Ð½Ð° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ñ Ð±ÑÐ»Ð¸ Ð½Ð° Ð¿ÐµÑÐµÐ·Ð°ÑÑÐ´ÐºÐµ. ÐÑ Ð²ÑÐ±ÑÐ°Ð»Ð¸ Ð¸Ð·Ð±ÐµÐ¶Ð°ÑÑ Ð¾Ð¶Ð¸Ð´Ð°Ð½Ð¸Ñ, Ð¾Ð¿Ð»Ð°ÑÐ¸Ð² {0} Ñ Ð²Ð°ÑÐµÐ³Ð¾ Ð±Ð°Ð»Ð°Ð½ÑÐ°."},
                {"TPRCooldownBypassF", "ÐÐ°ÑÐ¸ Ð·Ð°Ð¿ÑÐ¾ÑÑ Ð½Ð° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ñ Ð² Ð´Ð°Ð½Ð½ÑÐ¹ Ð¼Ð¾Ð¼ÐµÐ½Ñ Ð½Ð° Ð¿ÐµÑÐµÐ·Ð°ÑÑÐ´ÐºÐµ. Ð£ Ð²Ð°Ñ Ð½ÐµÐ´Ð¾ÑÑÐ°ÑÐ¾ÑÐ½Ð¾ ÑÑÐµÐ´ÑÑÐ² - {0} - ÑÑÐ¾Ð±Ñ Ð¸Ð·Ð±ÐµÐ¶Ð°ÑÑ Ð¾Ð¶Ð¸Ð´Ð°Ð½Ð¸Ñ."},
                {"TPRCooldownBypassP", "ÐÑ Ð¼Ð¾Ð¶ÐµÑÐµ Ð²ÑÐ±ÑÐ°ÑÑ Ð¾Ð¿Ð»Ð°ÑÐ¸ÑÑ {0} ÑÑÐ¾Ð±Ñ Ð¸Ð·Ð±ÐµÐ¶Ð°ÑÑ Ð¾Ð¶Ð¸Ð´Ð°Ð½Ð¸Ñ Ð¿ÐµÑÐµÐ·Ð°ÑÑÐ´ÐºÐ¸." },
                {"TPMoney", "{0} ÑÐ¿Ð¸ÑÐ°Ð½Ð¾ Ñ Ð²Ð°ÑÐµÐ³Ð¾ Ð°ÐºÐºÐ°ÑÐ½ÑÐ°!"},
                {"TPNoMoney", "Ð£ Ð²Ð°Ñ Ð½ÐµÑ {0} Ð½Ð¸ Ð½Ð° Ð¾Ð´Ð½Ð¾Ð¼ Ð°ÐºÐºÐ°ÑÐ½ÑÐµ!"},
                {"TPRCooldownBypassP2", "ÐÐ°Ð¿Ð¸ÑÐ¸ÑÐµ <color=yellow>/tpr {0}</color>." },
                {"TPRCooldownBypassP2a", "ÐÐ°Ð¿Ð¸ÑÐ¸ÑÐµ <color=yellow>/tpr \"Ð¸Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÐ°\" {0}</color>." },
                {"TPRLimitReached", "ÐÑ Ð¸ÑÑÐµÑÐ¿Ð°Ð»Ð¸ ÐµÐ¶ÐµÐ´Ð½ÐµÐ²Ð½ÑÐ¹ Ð»Ð¸Ð¼Ð¸Ñ {0} Ð·Ð°Ð¿ÑÐ¾ÑÐ¾Ð² Ð½Ð° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ñ ÑÐµÐ³Ð¾Ð´Ð½Ñ!"},
                {"TPRAmount", "Ð£ Ð²Ð°Ñ Ð¾ÑÑÐ°Ð»Ð¾ÑÑ {0} Ð·Ð°Ð¿ÑÐ¾ÑÐ¾Ð² Ð½Ð° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ñ Ð½Ð° ÑÐµÐ³Ð¾Ð´Ð½Ñ!"},
                {"TPRTarget", "ÐÐ°ÑÐ° ÑÐµÐ»Ñ Ð² Ð´Ð°Ð½Ð½ÑÐ¹ Ð¼Ð¾Ð¼ÐµÐ½Ñ Ð½Ðµ Ð´Ð¾ÑÑÑÐ¿Ð½Ð°!"},
                {"TPDead", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ, Ð¿Ð¾ÐºÐ° Ð¼ÐµÑÑÐ²Ñ!"},
                {"TPWounded", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ, Ð±ÑÐ´ÑÑÐ¸ ÑÐ°Ð½ÐµÐ½ÑÐ¼!"},
                {"TPTooCold", "ÐÐ°Ð¼ ÑÐ»Ð¸ÑÐºÐ¾Ð¼ ÑÐ¾Ð»Ð¾Ð´Ð½Ð¾ Ð´Ð»Ñ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ð¸!"},
                {"TPTooHot", "ÐÐ°Ð¼ ÑÐ»Ð¸ÑÐºÐ¾Ð¼ Ð¶Ð°ÑÐºÐ¾ Ð´Ð»Ñ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ð¸!"},
                {"TPTugboat", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ Ð½Ð° ÑÑÐ¾Ð¹ Ð»Ð¾Ð´ÐºÐµ!"},
                {"TPBoat", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ Ð½Ð°ÑÐ¾Ð´ÑÑÑ Ð½Ð° Ð»Ð¾Ð´ÐºÐµ!"},
                {"TPHostile", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ Ð² ÐÐ¾ÑÐ¾Ð´ NPC Ð¸Ð»Ð¸ ÐÐ°Ð³ÐµÑÑ Ð±Ð°Ð½Ð´Ð¸ÑÐ¾Ð² Ð¿Ð¾ÐºÐ° Ð²ÑÐ°Ð¶Ð´ÐµÐ±Ð½Ñ!"},
                {"TPJunkpile", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ Ñ ÐºÑÑÐ¸ Ð¼ÑÑÐ¾ÑÐ°"},
                {"HostileTimer", "Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑ ÑÑÐ°Ð½ÐµÑ Ð´Ð¾ÑÑÑÐ¿ÐµÐ½ ÑÐµÑÐµÐ· {0} Ð¼Ð¸Ð½ÑÑ."},
                {"TPMounted", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ, ÐºÐ¾Ð³Ð´Ð° ÑÐ¸Ð´Ð¸ÑÐµ!"},
                {"TPBuildingBlocked", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ, Ð½Ð°ÑÐ¾Ð´ÑÑÑ Ð² Ð·Ð¾Ð½Ðµ Ð±Ð»Ð¾ÐºÐ¸ÑÐ¾Ð²ÐºÐ¸ ÑÑÑÐ¾Ð¸ÑÐµÐ»ÑÑÑÐ²Ð°!"},
                {"TPAboveWater", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ Ð½Ð°ÑÐ¾Ð´ÑÑÑ Ð½Ð°Ð´ Ð²Ð¾Ð´Ð¾Ð¹!"},
                {"TPUnderWater", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ Ð¿Ð¾Ð´ Ð²Ð¾Ð´Ð¾Ð¹!"},
                {"TPTargetBuildingBlocked", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ Ð² Ð·Ð¾Ð½Ñ, Ð³Ð´Ðµ Ð±Ð»Ð¾ÐºÐ¸ÑÐ¾Ð²Ð°Ð½Ð¾ ÑÑÑÐ¾Ð¸ÑÐµÐ»ÑÑÑÐ²Ð¾!"},
                {"TPTargetInsideBlock", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ Ð² ÑÑÐ½Ð´Ð°Ð¼ÐµÐ½Ñ!"},
                {"TPTargetInsideRock", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ Ð² ÑÐºÐ°Ð»Ñ!"},
                {"TPSwimming", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ, Ð¿Ð¾ÐºÐ° Ð¿Ð»ÑÐ²ÑÑÐµ!"},
                {"TPCargoShip", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ Ñ Ð³ÑÑÐ·Ð¾Ð²Ð¾Ð³Ð¾ ÐºÐ¾ÑÐ°Ð±Ð»Ñ!"},
                {"TPOilRig", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ Ñ Ð½ÐµÑÑÑÐ½Ð¾Ð¹ Ð²ÑÑÐºÐ¸!"},
                {"TPExcavator", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ Ñ ÑÐºÑÐºÐ°Ð²Ð°ÑÐ¾ÑÐ°!"},
                {"TPHotAirBalloon", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ Ñ, Ð¸Ð»Ð¸ Ð½Ð° Ð²Ð¾Ð·Ð´ÑÑÐ½ÑÐ¹ ÑÐ°Ñ!"},
                {"TPLift", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ Ð½Ð°ÑÐ¾Ð´ÑÑÑ Ð² Ð»Ð¸ÑÑÐµ Ð¸Ð»Ð¸ Ð¿Ð¾Ð´ÑÐµÐ¼Ð½Ð¸ÐºÐµ!"},
                {"TPBucketLift", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ Ð½Ð°ÑÐ¾Ð´ÑÑÑ Ð² ÐºÐ¾Ð²ÑÐµÐ²Ð¾Ð¼ Ð¿Ð¾Ð´ÑÐµÐ¼Ð½Ð¸ÐºÐµ!"},
                {"TPRegLift", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ Ð½Ð°ÑÐ¾Ð´ÑÑÑ Ð² Ð»Ð¸ÑÑÐµ!"},
                {"TPSafeZone", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ Ð¸Ð· Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾Ð¹ Ð·Ð¾Ð½Ñ!"},
                {"TPFlagZone", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ Ð¸Ð· ÑÑÐ¾Ð¹ Ð·Ð¾Ð½Ñ!"},
                {"TPNoEscapeBlocked", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ Ð¿Ð¾ÐºÐ° Ð°ÐºÑÐ¸Ð²Ð½Ð° Ð±Ð»Ð¾ÐºÐ¸ÑÐ¾Ð²ÐºÐ°!"},
                {"TPCrafting", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ Ð² Ð¿ÑÐ¾ÑÐµÑÑÐµ ÐºÑÐ°ÑÑÐ°!"},
                {"TPBlockedItem", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ Ð¿Ð¾ÐºÐ° Ð½ÐµÑÑÑÐµ: {0}!"},
                {"TooCloseToMon", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ ÑÐ°Ðº Ð±Ð»Ð¸Ð·ÐºÐ¾ Ðº {0}!"},
                {"TPHomeSafeZoneOnly", "ÐÑ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ Ð´Ð¾Ð¼Ð¾Ð¹ ÑÐ¾Ð»ÑÐºÐ¾ Ð¸Ð· Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾Ð¹ Ð·Ð¾Ð½Ñ!" },
                {"TooCloseToCave", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ ÑÐ°Ðº Ð±Ð»Ð¸Ð·ÐºÐ¾ Ðº Ð¿ÐµÑÐµÑÐµ!"},
                {"HomeTooCloseToCave", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐ¾ÑÑÐ°Ð½Ð¸ÑÑ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð² ÐºÐ°ÑÐµÑÑÐ²Ðµ Ð´Ð¾Ð¼Ð° ÑÐ°Ðº Ð±Ð»Ð¸Ð·ÐºÐ¾ Ðº Ð¿ÐµÑÐµÑÐµ!"},
                {"HomeTooCloseToMon", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐ¾ÑÑÐ°Ð½Ð¸ÑÑ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð² ÐºÐ°ÑÐµÑÑÐ²Ðµ Ð´Ð¾Ð¼Ð° ÑÐ°Ðº Ð±Ð»Ð¸Ð·ÐºÐ¾ Ðº Ð¼Ð¾Ð½ÑÐ¼ÐµÐ½ÑÑ!"},
                {"CannotTeleportFromHome", "ÐÑ Ð´Ð¾Ð»Ð¶Ð½Ñ Ð²ÑÐ¹ÑÐ¸ Ð¸Ð· Ð²Ð°ÑÐµÐ¹ Ð±Ð°Ð·Ñ, Ð¿ÑÐµÐ¶Ð´Ðµ ÑÐµÐ¼ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ!"},
                {"WaitGlobalCooldown", "ÐÑ Ð´Ð¾Ð»Ð¶Ð½Ñ Ð¿Ð¾Ð´Ð¾Ð¶Ð´Ð°ÑÑ {0}, Ð¿Ð¾ÐºÐ° Ð²Ð°Ñ Ð³Ð»Ð¾Ð±Ð°Ð»ÑÐ½ÑÐ¹ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑ Ð¿ÐµÑÐµÐ·Ð°ÑÑÐ¶Ð°ÐµÑÑÑ!" },

                {"DM_TownTP", "ÐÑ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°Ð½Ñ Ð² {0}!"},
                {"DM_TownTPNoLocation", "ÐÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ <color=yellow>{0}</color> Ð² Ð´Ð°Ð½Ð½ÑÐ¹ Ð¼Ð¾Ð¼ÐµÐ½Ñ Ð½Ðµ ÑÑÑÐ°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¾!"},
                {"DM_TownTPDisabled", "<color=yellow>{0}</color> Ð² Ð´Ð°Ð½Ð½ÑÐ¹ Ð¼Ð¾Ð¼ÐµÐ½Ñ Ð¾ÑÐºÐ»ÑÑÐµÐ½ Ð² ÑÐ°Ð¹Ð»Ðµ Ð½Ð°ÑÑÑÐ¾Ð¹ÐµÐº!"},
                {"DM_TownTPLocation", "ÐÑ ÑÑÑÐ°Ð½Ð¾Ð²Ð¸Ð»Ð¸ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ <color=yellow>{0}</color> Ð² {1}!"},
                {"DM_TownTPCreated", "ÐÑ ÑÐ¾Ð·Ð´Ð°Ð»Ð¸ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ: <color=yellow>{0}</color>"},
                {"DM_TownTPRemoved", "ÐÑ ÑÐ´Ð°Ð»Ð¸Ð»Ð¸ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ: <color=yellow>{0}</color>"},
                {"DM_TownTPDoesNotExist", "ÐÐ¾Ð¼Ð°Ð½Ð´Ð° Ð½Ðµ ÑÑÑÐµÑÑÐ²ÑÐµÑ: <color=yellow>{0}</color>"},
                {"DM_TownTPExists", "ÐÐ¾Ð¼Ð°Ð½Ð´Ð° <color=yellow>{0}</color> ÑÐ¶Ðµ ÑÑÑÑÑÑÐ²ÑÐµÑ!"},
                {"DM_TownTPLocationsCleared", "You have cleared all locations for {0}!"},
                {"DM_TownTPStarted", "Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ñ Ð² {0} ÑÐµÑÐµÐ· {1} ÑÐµÐºÑÐ½Ð´!"},
                {"DM_TownTPCooldown", "ÐÐ°Ñ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑ Ð¿ÐµÑÐµÐ·Ð°ÑÑÐ¶Ð°ÐµÑÑÑ. ÐÐ°Ð¼ Ð½ÐµÐ¾Ð±ÑÐ¾Ð´Ð¸Ð¼Ð¾ Ð¿Ð¾Ð´Ð¾Ð¶Ð´Ð°ÑÑ {0} Ð´Ð¾ ÑÐ»ÐµÐ´ÑÑÑÐµÐ¹ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ð¸."},
                {"DM_TownTPCooldownBypass", "ÐÐ°Ñ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑ Ð±ÑÐ» Ð½Ð° Ð¿ÐµÑÐµÐ·Ð°ÑÑÐ´ÐºÐµ. ÐÑ Ð²ÑÐ±ÑÐ°Ð»Ð¸ Ð¸Ð·Ð±ÐµÐ¶Ð°ÑÑ Ð¾Ð¶Ð¸Ð´Ð°Ð½Ð¸Ñ, Ð¾Ð¿Ð»Ð°ÑÐ¸Ð² {0} Ñ Ð²Ð°ÑÐµÐ³Ð¾ Ð±Ð°Ð»Ð°Ð½ÑÐ°."},
                {"DM_TownTPCooldownBypassF", "ÐÐ°Ñ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑ Ð¿ÐµÑÐµÐ·Ð°ÑÑÐ¶Ð°ÐµÑÑÑ. Ð£ Ð²Ð°Ñ Ð½ÐµÐ´Ð¾ÑÑÐ°ÑÐ¾ÑÐ½Ð¾ ÑÑÐµÐ´ÑÑÐ² ({0}) ÑÑÐ¾Ð±Ñ Ð¸Ð·Ð±ÐµÐ¶Ð°ÑÑ Ð¾Ð¶Ð¸Ð´Ð°Ð½Ð¸Ñ."},
                {"DM_TownTPCooldownBypassP", "ÐÑ Ð¼Ð¾Ð¶ÐµÑÐµ Ð²ÑÐ±ÑÐ°ÑÑ Ð¾Ð¿Ð»Ð°ÑÐ¸ÑÑ {0} ÑÑÐ¾Ð±Ñ Ð¸Ð·Ð±ÐµÐ¶Ð°ÑÑ Ð¾Ð¶Ð¸Ð´Ð°Ð½Ð¸Ñ Ð¿ÐµÑÐµÐ·Ð°ÑÑÐ´ÐºÐ¸." },
                {"DM_TownTPCooldownBypassP2", "ÐÐ²ÐµÐ´Ð¸ÑÐµ <color=yellow>/{0} {1}</color>" },
                {"DM_TownTPLimitReached", "ÐÑ Ð¸ÑÑÐµÑÐ¿Ð°Ð»Ð¸ ÐµÐ¶ÐµÐ´Ð½ÐµÐ²Ð½ÑÐ¹ Ð»Ð¸Ð¼Ð¸Ñ {0} ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ð¹ ÑÐµÐ³Ð¾Ð´Ð½Ñ! ÐÐ°Ð¼ Ð½ÐµÐ¾Ð±ÑÐ¾Ð´Ð¸Ð¼Ð¾ Ð¿Ð¾Ð´Ð¾Ð¶Ð´Ð°ÑÑ {1} Ð´Ð¾ ÑÐ»ÐµÐ´ÑÑÑÐµÐ¹ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ð¸."},
                {"DM_TownTPAmount", "Ð£ Ð²Ð°Ñ Ð¾ÑÑÐ°Ð»Ð¾ÑÑ {0} ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ð¹ <color=yellow>{1}</color> ÑÐµÐ³Ð¾Ð´Ð½Ñ!"},

                {"Days", "Ð´Ð½ÐµÐ¹" },
                {"Hours", "ÑÐ°ÑÐ¾Ð²" },
                {"Minutes", "Ð¼Ð¸Ð½ÑÑ" },
                {"Seconds", "ÑÐµÐºÑÐ½Ð´" },

                {"Interrupted", "ÐÐ°ÑÐ° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ñ Ð±ÑÐ»Ð° Ð¿ÑÐµÑÐ²Ð°Ð½Ð°!"},
                {"InterruptedTarget", "Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ñ {0} Ð±ÑÐ»Ð° Ð¿ÑÐµÑÐ²Ð°Ð½Ð°!"},
                {"Unlimited", "ÐÐµ Ð¾Ð³ÑÐ°Ð½Ð¸ÑÐµÐ½Ð¾"},
                {
                    "TPInfoGeneral", string.Join(NewLine, new[]
                    {
                        "ÐÐ¾Ð¶Ð°Ð»ÑÐ¹ÑÑÐ°, ÑÐºÐ°Ð¶Ð¸ÑÐµ Ð¼Ð¾Ð´ÑÐ»Ñ, Ð¾ ÐºÐ¾ÑÐ¾ÑÐ¾Ð¼ Ð²Ñ ÑÐ¾ÑÐ¸ÑÐµ Ð¿ÑÐ¾ÑÐ¼Ð¾ÑÑÐµÑÑ Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ñ.",
                        "ÐÐ¾ÑÑÑÐ¿Ð½ÑÐµ Ð¼Ð¾Ð´ÑÐ»Ð¸: ",
                    })
                },
                {
                    "TPHelpGeneral", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/tpinfo</color> - ÐÑÐ¾Ð±ÑÐ°Ð¶Ð°ÐµÑ Ð»Ð¸Ð¼Ð¸ÑÑ Ð¸ Ð¿ÐµÑÐµÐ·Ð°ÑÑÐ´ÐºÐ¸.",
                        "ÐÐ¾Ð¶Ð°Ð»ÑÐ¹ÑÑÐ°, ÑÐºÐ°Ð¶Ð¸ÑÐµ Ð¼Ð¾Ð´ÑÐ»Ñ, Ð¿Ð¾ ÐºÐ¾ÑÐ¾ÑÐ¾Ð¼Ñ Ð²Ñ ÑÐ¾ÑÐ¸ÑÐµ Ð¿Ð¾Ð»ÑÑÐ¸ÑÑ Ð¿Ð¾Ð¼Ð¾ÑÑ.",
                        "ÐÐ¾ÑÑÑÐ¿Ð½ÑÐµ Ð¼Ð¾Ð´ÑÐ»Ð¸: ",
                    })
                },
                {
                    "TPHelpadmintp", string.Join(NewLine, new[]
                    {
                        "ÐÐ°Ðº Ð°Ð´Ð¼Ð¸Ð½, Ð²Ñ Ð¸Ð¼ÐµÐµÑÐµ Ð´Ð¾ÑÑÑÐ¿ Ðº ÑÐ»ÐµÐ´ÑÑÑÐ¸Ð¼ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð°Ð¼:",
                        "<color=yellow>/tp \"Ð¸Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÐ°\"</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÑÐµÑ Ð²Ð°Ñ Ðº ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÑ.",
                        "<color=yellow>/tp \"Ð¸Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÐ°\" \"Ð¸Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÐ° 2\"</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÑÐµÑ Ð¸Ð³ÑÐ¾ÐºÐ° Ñ Ð¸Ð¼ÐµÐ½ÐµÐ¼ 'Ð¸Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÐ°' Ðº Ð¸Ð³ÑÐ¾ÐºÑ 'Ð¸Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÐ° 2'.",
                        "<color=yellow>/tp x y z</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÑÐµÑ Ð²Ð°Ñ Ðº ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¼ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÐ°Ð¼.",
                        "<color=yellow>/tpl</color> - ÐÑÐ¾Ð±ÑÐ°Ð¶Ð°ÐµÑ ÑÐ¿Ð¸ÑÐ¾Ðº ÑÐ¾ÑÑÐ°Ð½ÑÐ½Ð½ÑÑ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ð¹.",
                        "<color=yellow>/tpl \"Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ\"</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÑÐµÑ Ð²Ð°Ñ Ð² ÑÐ¾ÑÑÐ°Ð½ÑÐ½Ð½Ð¾Ðµ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ.",
                        "<color=yellow>/tpsave \"Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ\"</color> - Ð¡Ð¾ÑÑÐ°Ð½ÑÐµÑ Ð²Ð°ÑÐµ ÑÐµÐºÑÑÐµÐµ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ñ ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¼ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸ÐµÐ¼.",
                        "<color=yellow>/tpremove \"Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ\"</color> - Ð£Ð´Ð°Ð»ÑÐµÑ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð¸Ð· ÑÐ¿Ð¸ÑÐºÐ° ÑÐ¾ÑÑÐ°Ð½ÑÐ½Ð½ÑÑ.",
                        "<color=yellow>/tpb</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÑÐµÑ Ð²Ð°Ñ Ð½Ð°Ð·Ð°Ð´ Ð½Ð° Ð¼ÐµÑÑÐ¾, Ð³Ð´Ðµ Ð²Ñ Ð±ÑÐ»Ð¸ Ð¿ÐµÑÐµÐ´ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸ÐµÐ¹.",
                        "<color=yellow>/home radius \"ÑÐ°Ð´Ð¸ÑÑ\"</color> - ÐÐ°Ð¹ÑÐ¸ Ð²ÑÐµ Ð´Ð¾Ð¼Ð° Ð² ÑÐ°Ð´Ð¸ÑÑÐµ.",
                        "<color=yellow>/home delete \"Ð¸Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÐ° Ð¸Ð»Ð¸ ID\" \"Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð´Ð¾Ð¼Ð°\"</color> - Ð£Ð´Ð°Ð»ÑÐµÑ Ð´Ð¾Ð¼ Ñ ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¼ Ð¸Ð¼ÐµÐ½ÐµÐ¼ Ð¿ÑÐ¸Ð½Ð°Ð´Ð»ÐµÐ¶Ð°ÑÐ¸Ð¹ ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÑ.",
                        "<color=yellow>/home tp \"Ð¸Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÐ° Ð¸Ð»Ð¸ ID\" \"Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð´Ð¾Ð¼Ð°\"</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÑÐµÑ Ð²Ð°Ñ Ð² Ð´Ð¾Ð¼ Ð¸Ð³ÑÐ¾ÐºÐ° Ñ ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¼ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸ÐµÐ¼ Ð¿ÑÐ¸Ð½Ð°Ð´Ð»ÐµÐ¶Ð°ÑÐ¸Ð¹ ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÑ.",
                        "<color=yellow>/home homes \"Ð¸Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÐ° Ð¸Ð»Ð¸ ID\"</color> - ÐÑÐ¾Ð±ÑÐ°Ð¶Ð°ÐµÑ Ð²Ð°Ð¼ ÑÐ¿Ð¸ÑÐ¾Ðº Ð²ÑÐµÑ Ð´Ð¾Ð¼Ð¾Ð², Ð¿ÑÐ¸Ð½Ð°Ð´Ð»ÐµÐ¶Ð°ÑÐ¸Ñ ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÑ."
                    })
                },
                {
                    "TPHelphome", string.Join(NewLine, new[]
                    {
                        "ÐÑÐ¿Ð¾Ð»ÑÐ·ÑÑ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ, Ð²Ñ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð²Ð°ÑÐµÐ³Ð¾ Ð´Ð¾Ð¼Ð°, ÑÑÐ¾Ð±Ñ Ð·Ð°ÑÐµÐ¼ Ð² Ð½ÐµÐ³Ð¾ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ:",
                        "<color=yellow>/home add \"Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð´Ð¾Ð¼Ð°\"</color> - Ð¡Ð¾ÑÑÐ°Ð½ÑÐµÑ Ð²Ð°ÑÐµ ÑÐµÐºÑÑÐµÐµ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ ÐºÐ°Ðº Ð²Ð°Ñ Ð´Ð¾Ð¼ Ñ ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¼ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸ÐµÐ¼.",
                        "<color=yellow>/home list</color> - ÐÑÐ¾Ð±ÑÐ°Ð¶Ð°ÐµÑ ÑÐ¿Ð¸ÑÐ¾Ðº Ð²ÑÐµÑ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ð¹, ÑÐ¾ÑÑÐ°Ð½ÑÐ½Ð½ÑÑ Ð²Ð°Ð¼Ð¸ ÐºÐ°Ðº Ð´Ð¾Ð¼.",
                        "<color=yellow>/home remove \"Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð´Ð¾Ð¼Ð°\"</color> - Ð£Ð´Ð°Ð»ÑÐµÑ ÑÐ°ÑÐ¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ ÑÐ¾ÑÑÐ°Ð½ÑÐ½Ð½Ð¾Ð³Ð¾ Ð´Ð¾Ð¼Ð° Ñ ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¼ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸ÐµÐ¼.",
                        "<color=yellow>/home \"Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð´Ð¾Ð¼Ð°\"</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÑÐµÑ Ð²Ð°Ñ Ð² Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð´Ð¾Ð¼Ð° Ñ ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¼ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸ÐµÐ¼."
                    })
                },
                {
                    "TPHelptpr", string.Join(NewLine, new[]
                    {
                        "ÐÑÐ¿Ð¾Ð»ÑÐ·ÑÑ ÑÑÐ¸ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ, Ð²Ñ Ð¼Ð¾Ð¶ÐµÑÐµ Ð¾ÑÐ¿ÑÐ°Ð²Ð¸ÑÑ Ð·Ð°Ð¿ÑÐ¾Ñ Ð½Ð° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ñ Ðº Ð¸Ð³ÑÐ¾ÐºÑ, Ð¸Ð»Ð¸ Ð¿ÑÐ¸Ð½ÑÑÑ ÑÐµÐ¹-ÑÐ¾ Ð·Ð°Ð¿ÑÐ¾Ñ:",
                        "<color=yellow>/tpr \"Ð¸Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÐ°\"</color> - ÐÑÐ¿ÑÐ°Ð²Ð»ÑÐµÑ Ð·Ð°Ð¿ÑÐ¾Ñ Ð½Ð° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ñ Ð¸Ð³ÑÐ¾ÐºÑ Ñ ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¼ Ð¸Ð¼ÐµÐ½ÐµÐ¼.",
                        "<color=yellow>/tpa</color> - ÐÑÐ¸Ð½ÑÑÑ Ð²ÑÐ¾Ð´ÑÑÐ¸Ð¹ Ð·Ð°Ð¿ÑÐ¾Ñ Ð½Ð° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ñ.",
                        "<color=yellow>/tpat</color> - ÐÐºÐ»./ÐÑÐºÐ». Ð°Ð²ÑÐ¾Ð¼Ð°ÑÐ¸ÑÐµÑÐºÐ¾Ðµ Ð¿ÑÐ¸Ð½ÑÑÐ¸Ðµ Ð²ÑÐ¾Ð´ÑÑÐ¸Ñ Ð·Ð°Ð¿ÑÐ¾ÑÐ¾Ð² Ð½Ð° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ñ Ðº Ð²Ð°Ð¼ /tpa.",
                        "<color=yellow>/tpc</color> - ÐÑÐ¼ÐµÐ½Ð¸ÑÑ Ð·Ð°Ð¿ÑÐ¾Ñ Ð½Ð° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ñ."
                    })
                },
                {
                    "TPSettingsGeneral", string.Join(NewLine, new[]
                    {
                        "ÐÐ¾Ð¶Ð°Ð»ÑÐ¹ÑÑÐ°, ÑÐºÐ°Ð¶Ð¸ÑÐµ Ð¼Ð¾Ð´ÑÐ»Ñ, Ð½Ð°ÑÑÑÐ¾Ð¹ÐºÐ¸ ÐºÐ¾ÑÐ¾ÑÐ¾Ð³Ð¾ Ð²Ñ ÑÐ¾ÑÐ¸ÑÐµ Ð¿ÑÐ¾ÑÐ¼Ð¾ÑÑÐµÑÑ. ",
                        "ÐÐ¾ÑÑÑÐ¿Ð½ÑÐµ Ð¼Ð¾Ð´ÑÐ»Ð¸:",
                    })
                },
                {
                    "TPSettingshome", string.Join(NewLine, new[]
                    {
                        "Ð¡Ð¸ÑÑÐµÐ¼Ð° Ð´Ð¾Ð¼Ð¾Ð² Ð² Ð´Ð°Ð½Ð½ÑÐ¹ Ð¼Ð¾Ð¼ÐµÐ½Ñ Ð¸Ð¼ÐµÐµÑ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ðµ Ð²ÐºÐ»ÑÑÑÐ½Ð½ÑÐµ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÑ:",
                        "ÐÑÐµÐ¼Ñ Ð¼ÐµÐ¶Ð´Ñ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°Ð¼Ð¸: {0}",
                        "ÐÐ¶ÐµÐ´Ð½ÐµÐ²Ð½ÑÐ¹ Ð»Ð¸Ð¼Ð¸Ñ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ð¹: {1}",
                        "ÐÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ð¾ ÑÐ¾ÑÑÐ°Ð½ÑÐ½Ð½ÑÑ Ð´Ð¾Ð¼Ð¾Ð²: {2}"
                    })
                },
                {
                    "TPSettingsbandit", string.Join(NewLine, new[]
                    {
                        "Ð¡Ð¸ÑÑÐµÐ¼Ð° ÐÐ°Ð³ÐµÑÑ Ð±Ð°Ð½Ð´Ð¸ÑÐ¾Ð² Ð² Ð´Ð°Ð½Ð½ÑÐ¹ Ð¼Ð¾Ð¼ÐµÐ½Ñ Ð¸Ð¼ÐµÐµÑ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ðµ Ð²ÐºÐ»ÑÑÑÐ½Ð½ÑÐµ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÑ:",
                        "ÐÑÐµÐ¼Ñ Ð¼ÐµÐ¶Ð´Ñ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°Ð¼Ð¸: {0}",
                        "ÐÐ¶ÐµÐ´Ð½ÐµÐ²Ð½ÑÐ¹ Ð»Ð¸Ð¼Ð¸Ñ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ð¹: {1}"
                    })
                },
                {
                    "TPSettingsoutpost", string.Join(NewLine, new[]
                    {
                        "Ð¡Ð¸ÑÑÐµÐ¼Ð° ÐÐ¾ÑÐ¾Ð´ NPC Ð² Ð´Ð°Ð½Ð½ÑÐ¹ Ð¼Ð¾Ð¼ÐµÐ½Ñ Ð¸Ð¼ÐµÐµÑ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ðµ Ð²ÐºÐ»ÑÑÑÐ½Ð½ÑÐµ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÑ:",
                        "ÐÑÐµÐ¼Ñ Ð¼ÐµÐ¶Ð´Ñ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°Ð¼Ð¸: {0}",
                        "ÐÐ¶ÐµÐ´Ð½ÐµÐ²Ð½ÑÐ¹ Ð»Ð¸Ð¼Ð¸Ñ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ð¹: {1}"
                    })
                },
                {
                    "TPSettingstpr", string.Join(NewLine, new[]
                    {
                        "Ð¡Ð¸ÑÑÐµÐ¼Ð° TPR Ð² Ð´Ð°Ð½Ð½ÑÐ¹ Ð¼Ð¾Ð¼ÐµÐ½Ñ Ð¸Ð¼ÐµÐµÑ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ðµ Ð²ÐºÐ»ÑÑÑÐ½Ð½ÑÐµ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÑ:",
                        "ÐÑÐµÐ¼Ñ Ð¼ÐµÐ¶Ð´Ñ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°Ð¼Ð¸: {0}",
                        "ÐÐ¶ÐµÐ´Ð½ÐµÐ²Ð½ÑÐ¹ Ð»Ð¸Ð¼Ð¸Ñ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ð¹: {1}"
                    })
                },
                {
                    "TPSettingstown", string.Join(NewLine, new[]
                    {
                        "Ð Ð¡Ð¸ÑÑÐµÐ¼Ðµ ÐÐ¾ÑÐ¾Ð´Ð¾Ð² Ð²ÐºÐ»ÑÑÐµÐ½Ñ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ðµ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÑ:",
                        "ÐÑÐµÐ¼Ñ Ð¼ÐµÐ¶Ð´Ñ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°Ð¼Ð¸: {0}",
                        "ÐÐ¶ÐµÐ´Ð½ÐµÐ²Ð½ÑÐ¹ Ð»Ð¸Ð¼Ð¸Ñ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ð¹: {1}"
                    })
                },
                {
                    "TPSettingsdynamic", string.Join(NewLine, new[]
                    {
                        "Ð Ð¡Ð¸ÑÑÐµÐ¼Ðµ {0} Ð²ÐºÐ»ÑÑÐµÐ½Ñ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ðµ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÑ:",
                        "ÐÑÐµÐ¼Ñ Ð¼ÐµÐ¶Ð´Ñ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°Ð¼Ð¸: {1}",
                        "ÐÐ¶ÐµÐ´Ð½ÐµÐ²Ð½ÑÐ¹ Ð»Ð¸Ð¼Ð¸Ñ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ð¹: {2}"
                    })
                },
                
                {"TPT_True", "Ð²ÐºÐ»ÑÑÐµÐ½Ð¾"},
                {"TPT_False", "Ð²ÑÐºÐ»ÑÑÐµÐ½Ð¾"},
                {"TPT_clan", "{1} clan ÑÐµÐ¿ÐµÑÑ {0}."},
                {"TPT_friend", "{1} friend ÑÐµÐ¿ÐµÑÑ {0}."},
                {"TPT_team", "{1} team ÑÐµÐ¿ÐµÑÑ {0}."},
                {"NotValidTPT", "ÐÐµÐ²ÐµÑÐ½Ð¾, Ð¸Ð³ÑÐ¾Ðº Ð½Ðµ"},
                {"NotValidTPTFriend", " Ð´ÑÑÐ³!"},
                {"NotValidTPTTeam", " Ð² Ð²Ð°ÑÐµÐ¹ ÐºÐ¾Ð¼Ð°Ð½Ð´Ðµ!"},
                {"NotValidTPTClan", " Ð² Ð²Ð°ÑÐµÐ¼ ÐºÐ»Ð°Ð½Ðµ!"},
                // TODO: Fix not being in Russian.
                {"TPTInfo", "{4} auto accepts teleport requests.\n<color={5}>Green</color> = <color={5}>Enabled</color>\n<color={6}>Red</color> = <color={6}>Disabled</color>\n\n/{0} <color={1}>clan</color> - Toggle {4} for clan members/allies.\n/{0} <color={2}>team</color> - Toggle {4} for teammates.\n/{0} <color={3}>friend</color> - Toggle {4} for friends."},
                {"PlayerNotFound", "Ð£ÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¹ Ð¸Ð³ÑÐ¾Ðº Ð½Ðµ Ð¾Ð±Ð½Ð°ÑÑÐ¶ÐµÐ½, Ð¿Ð¾Ð¶Ð°Ð»ÑÐ¹ÑÑÐ° Ð¿Ð¾Ð¿ÑÐ¾Ð±ÑÐ¹ÑÐµ ÐµÑÑ ÑÐ°Ð·!"},
                {"MultiplePlayers", "ÐÐ°Ð¹Ð´ÐµÐ½Ð¾ Ð½ÐµÑÐºÐ¾Ð»ÑÐºÐ¾ Ð¸Ð³ÑÐ¾ÐºÐ¾Ð²: {0}"},
                {"CantTeleportToSelf", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ Ðº ÑÐ°Ð¼Ð¾Ð¼Ñ ÑÐµÐ±Ðµ!"},
                {"CantTeleportPlayerToSelf", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ¾Ð²Ð°ÑÑ Ð¸Ð³ÑÐ¾ÐºÐ° Ðº ÑÐ°Ð¼Ð¾Ð¼Ñ ÑÐµÐ±Ðµ!"},
                {"TeleportPendingTPC", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ Ð¸Ð½Ð¸ÑÐ¸Ð¸ÑÐ¾Ð²Ð°ÑÑ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ñ, Ð¿Ð¾ÐºÐ° Ñ Ð²Ð°Ñ ÐµÑÑÑ Ð°ÐºÑÐ¸Ð²Ð½ÑÐ¹ Ð·Ð°Ð¿ÑÐ¾Ñ! ÐÑÐ¿Ð¾Ð»ÑÐ·ÑÐ¹ÑÐµ <color=yellow>/tpc</color> ÑÑÐ¾Ð±Ñ Ð¾ÑÐ¼ÐµÐ½Ð¸ÑÑ ÐµÐ³Ð¾."},
                {"TeleportPendingTarget", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ Ð¾ÑÐ¿ÑÐ°Ð²Ð¸ÑÑ Ð·Ð°Ð¿ÑÐ¾Ñ Ðº ÑÐ¾Ð¼Ñ, ÐºÑÐ¾ Ð² Ð¿ÑÐ¾ÑÐµÑÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ð¸!"},
                {"LocationExists", "ÐÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ñ ÑÐ°ÐºÐ¸Ð¼ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸ÐµÐ¼ ÑÐ¶Ðµ ÑÑÑÐµÑÑÐ²ÑÐµÑ Ð² {0}!"},
                {"LocationExistsNearby", "ÐÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ñ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸ÐµÐ¼ {0} ÑÐ¶Ðµ ÑÑÑÐµÑÑÐ²ÑÐµÑ ÑÑÐ´Ð¾Ð¼ Ñ ÑÐµÐºÑÑÐµÐ¹ Ð¿Ð¾Ð·Ð¸ÑÐ¸ÐµÐ¹!"},
                {"LocationNotFound", "ÐÐµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð¾ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ñ ÑÐ°ÐºÐ¸Ð¼ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸ÐµÐ¼!"},
                {"NoPreviousLocationSaved", "ÐÑÐµÐ´ÑÐ´ÑÑÐµÐµ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð½Ðµ ÑÐ¾ÑÑÐ°Ð½ÐµÐ½Ð¾!"},
                {"HomeExists", "ÐÑ ÑÐ¶Ðµ ÑÐ¾ÑÑÐ°Ð½Ð¸Ð»Ð¸ Ð´Ð¾Ð¼ Ñ ÑÐ°ÐºÐ¸Ð¼ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸ÐµÐ¼!"},
                {"HomeExistsNearby", "ÐÐ¾Ð¼ Ñ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸ÐµÐ¼ {0} ÑÐ¶Ðµ ÑÑÑÐµÑÑÐ²ÑÐµÑ ÑÑÐ´Ð¾Ð¼ Ñ ÑÐµÐºÑÑÐµÐ¹ Ð¿Ð¾Ð·Ð¸ÑÐ¸ÐµÐ¹!"},
                {"HomeNotFound", "ÐÐ¾Ð¼ Ñ ÑÐ°ÐºÐ¸Ð¼ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸ÐµÐ¼ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½!"},
                {"InvalidCoordinates", "ÐÑ ÑÐºÐ°Ð·Ð°Ð»Ð¸ Ð½ÐµÐ²ÐµÑÐ½ÑÐµ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÑ!"},
                {"InvalidHelpModule", "Ð£ÐºÐ°Ð·Ð°Ð½ Ð½ÐµÐ²ÐµÑÐ½ÑÐ¹ Ð¼Ð¾Ð´ÑÐ»Ñ!"},
                {"InvalidCharacter", "ÐÑ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð»Ð¸ Ð½ÐµÐ´Ð¾Ð¿ÑÑÑÐ¸Ð¼ÑÐ¹ ÑÐ¸Ð¼Ð²Ð¾Ð», Ð¾Ð³ÑÐ°Ð½Ð¸ÑÑÑÐµÑÑ Ð±ÑÐºÐ²Ð°Ð¼Ð¸ Ð¾Ñ a Ð´Ð¾ z Ð¸ ÑÐ¸ÑÑÐ°Ð¼Ð¸."},
                {
                    "SyntaxCommandTP", string.Join(NewLine, new[]
                    {
                        "ÐÑÐ¾Ð¸Ð·Ð¾ÑÐ»Ð° ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐµÑÐºÐ°Ñ Ð¾ÑÐ¸Ð±ÐºÐ°!",
                        "ÐÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ <color=yellow>/tp</color> Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ¾Ð»ÑÐºÐ¾ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ð¼ Ð¾Ð±ÑÐ°Ð·Ð¾Ð¼:",
                        "<color=yellow>/tp \"Ð¸Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÐ°\"</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÑÐµÑ Ð²Ð°Ñ Ðº ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÑ.",
                        "<color=yellow>/tp \"Ð¸Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÐ°\" \"Ð¸Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÐ° 2\"</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÑÐµÑ Ð¸Ð³ÑÐ¾ÐºÐ° Ñ Ð¸Ð¼ÐµÐ½ÐµÐ¼ 'Ð¸Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÐ°' Ðº Ð¸Ð³ÑÐ¾ÐºÑ 'Ð¸Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÐ° 2'.",
                        "<color=yellow>/tp x y z</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÑÐµÑ Ð²Ð°Ñ Ðº ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¼ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÐ°Ð¼.",
                        "<color=yellow>/tp \"Ð¸Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÐ°\" x y z</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÑÐµÑ Ð¸Ð³ÑÐ¾ÐºÐ° Ñ Ð¸Ð¼ÐµÐ½ÐµÐ¼ 'Ð¸Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÐ°' Ðº ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¼ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÐ°Ð¼."
                    })
                },
                {
                    "SyntaxCommandTPL", string.Join(NewLine, new[]
                    {
                        "ÐÑÐ¾Ð¸Ð·Ð¾ÑÐ»Ð° ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐµÑÐºÐ°Ñ Ð¾ÑÐ¸Ð±ÐºÐ°!",
                        "ÐÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ <color=yellow>/tpl</color> Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ¾Ð»ÑÐºÐ¾ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ð¼ Ð¾Ð±ÑÐ°Ð·Ð¾Ð¼:",
                        "<color=yellow>/tpl</color> - ÐÑÐ¾Ð±ÑÐ°Ð¶Ð°ÐµÑ ÑÐ¿Ð¸ÑÐ¾Ðº ÑÐ¾ÑÑÐ°Ð½ÑÐ½Ð½ÑÑ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ð¹.",
                        "<color=yellow>/tpl \"Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ\"</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÑÐµÑ Ð²Ð°Ñ Ð² Ð¼ÐµÑÑÐ¾ Ñ ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¼ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸ÐµÐ¼."
                    })
                },
                {
                    "SyntaxCommandTPSave", string.Join(NewLine, new[]
                    {
                        "ÐÑÐ¾Ð¸Ð·Ð¾ÑÐ»Ð° ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐµÑÐºÐ°Ñ Ð¾ÑÐ¸Ð±ÐºÐ°!",
                        "ÐÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ <color=yellow>/tpsave</color> Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ¾Ð»ÑÐºÐ¾ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ð¼ Ð¾Ð±ÑÐ°Ð·Ð¾Ð¼:",
                        "<color=yellow>/tpsave \"Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ\"</color> - Ð¡Ð¾ÑÑÐ°Ð½ÑÐµÑ Ð²Ð°ÑÐµ ÑÐµÐºÑÑÐµÐµ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ñ ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¼ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸ÐµÐ¼."
                    })
                },
                {
                    "SyntaxCommandTPRemove", string.Join(NewLine, new[]
                    {
                        "ÐÑÐ¾Ð¸Ð·Ð¾ÑÐ»Ð° ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐµÑÐºÐ°Ñ Ð¾ÑÐ¸Ð±ÐºÐ°!",
                        "ÐÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ <color=yellow>/tpremove</color> Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ¾Ð»ÑÐºÐ¾ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ð¼ Ð¾Ð±ÑÐ°Ð·Ð¾Ð¼:",
                        "<color=yellow>/tpremove \"Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ\"</color> - Ð£Ð´Ð°Ð»ÑÐµÑ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ñ ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¼ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸ÐµÐ¼."
                    })
                },
                {
                    "SyntaxCommandTPN", string.Join(NewLine, new[]
                    {
                        "ÐÑÐ¾Ð¸Ð·Ð¾ÑÐ»Ð° ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐµÑÐºÐ°Ñ Ð¾ÑÐ¸Ð±ÐºÐ°!",
                        "ÐÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ <color=yellow>/tpn</color> Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ¾Ð»ÑÐºÐ¾ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ð¼ Ð¾Ð±ÑÐ°Ð·Ð¾Ð¼:",
                        "<color=yellow>/tpn \"Ð¸Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÐ°\"</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÑÐµÑ Ð²Ð°Ñ Ð½Ð° ÑÐ°ÑÑÑÐ¾ÑÐ½Ð¸Ðµ Ð¿Ð¾ ÑÐ¼Ð¾Ð»ÑÐ°Ð½Ð¸Ñ Ð¿Ð¾Ð·Ð°Ð´Ð¸ Ð¸Ð³ÑÐ¾ÐºÐ° Ñ ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¼ Ð¸Ð¼ÐµÐ½ÐµÐ¼.",
                        "<color=yellow>/tpn \"Ð¸Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÐ°\" \"ÑÐ°ÑÑÑÐ¾ÑÐ½Ð¸Ðµ\"</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÑÐµÑ Ð²Ð°Ñ Ð½Ð° ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ðµ ÑÐ°ÑÑÑÐ¾ÑÐ½Ð¸Ðµ Ð¿Ð¾Ð·Ð°Ð´Ð¸ Ð¸Ð³ÑÐ¾ÐºÐ° Ñ ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¼ Ð¸Ð¼ÐµÐ½ÐµÐ¼."
                    })
                },
                {
                    "SyntaxCommandSetHome", string.Join(NewLine, new[]
                    {
                        "ÐÑÐ¾Ð¸Ð·Ð¾ÑÐ»Ð° ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐµÑÐºÐ°Ñ Ð¾ÑÐ¸Ð±ÐºÐ°!",
                        "ÐÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ <color=yellow>/home add</color> Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ¾Ð»ÑÐºÐ¾ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ð¼ Ð¾Ð±ÑÐ°Ð·Ð¾Ð¼:",
                        "<color=yellow>/home add \"Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ\"</color> - Ð¡Ð¾ÑÑÐ°Ð½ÑÐµÑ Ð²Ð°ÑÐµ ÑÐµÐºÑÑÐµÐµ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ ÐºÐ°Ðº Ð²Ð°Ñ Ð´Ð¾Ð¼ Ñ ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¼ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸ÐµÐ¼."
                    })
                },
                {
                    "SyntaxCommandRemoveHome", string.Join(NewLine, new[]
                    {
                        "ÐÑÐ¾Ð¸Ð·Ð¾ÑÐ»Ð° ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐµÑÐºÐ°Ñ Ð¾ÑÐ¸Ð±ÐºÐ°!",
                        "ÐÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ <color=yellow>/home remove</color> Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ¾Ð»ÑÐºÐ¾ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ð¼ Ð¾Ð±ÑÐ°Ð·Ð¾Ð¼:",
                        "<color=yellow>/home remove \"Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ\"</color> - Ð£Ð´Ð°Ð»ÑÐµÑ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð´Ð¾Ð¼Ð° Ñ ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¼ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸ÐµÐ¼."
                    })
                },
                {
                    "SyntaxCommandHome", string.Join(NewLine, new[]
                    {
                        "ÐÑÐ¾Ð¸Ð·Ð¾ÑÐ»Ð° ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐµÑÐºÐ°Ñ Ð¾ÑÐ¸Ð±ÐºÐ°!",
                        "ÐÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ <color=yellow>/home</color> Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ¾Ð»ÑÐºÐ¾ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ð¼ Ð¾Ð±ÑÐ°Ð·Ð¾Ð¼:",
                        "<color=yellow>/home \"Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ\"</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÑÐµÑ Ð²Ð°Ñ Ð² Ð²Ð°Ñ Ð´Ð¾Ð¼ Ñ ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¼ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸ÐµÐ¼.",
                        "<color=yellow>/home \"Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ\" pay</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÑÐµÑ Ð²Ð°Ñ Ð² Ð²Ð°Ñ Ð´Ð¾Ð¼ Ñ ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¼ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸ÐµÐ¼, Ð¸Ð·Ð±ÐµÐ³Ð°Ñ Ð¿ÐµÑÐµÐ·Ð°ÑÑÐ´ÐºÐ¸, Ð·Ð°Ð¿Ð»Ð°ÑÐ¸Ð² Ð·Ð° ÑÑÐ¾.",
                        "<color=yellow>/home add \"Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ\"</color> - Ð¡Ð¾ÑÑÐ°Ð½ÑÐµÑ Ð²Ð°ÑÐµ ÑÐµÐºÑÑÐµÐµ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ ÐºÐ°Ðº Ð²Ð°Ñ Ð´Ð¾Ð¼ Ñ ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¼ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸ÐµÐ¼.",
                        "<color=yellow>/home list</color> - ÐÑÐ¾Ð±ÑÐ°Ð¶Ð°ÐµÑ ÑÐ¿Ð¸ÑÐ¾Ðº Ð²ÑÐµÑ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ð¹, ÑÐ¾ÑÑÐ°Ð½ÑÐ½Ð½ÑÑ Ð²Ð°Ð¼Ð¸ ÐºÐ°Ðº Ð´Ð¾Ð¼.",
                        "<color=yellow>/home remove \"Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ\"</color> - Ð£Ð´Ð°Ð»ÑÐµÑ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð´Ð¾Ð¼Ð° Ñ ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¼ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸ÐµÐ¼."
                    })
                },
                {
                    "SyntaxCommandHomeAdmin", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/home radius \"ÑÐ°Ð´Ð¸ÑÑ\"</color> - ÐÑÐ¾Ð±ÑÐ°Ð¶Ð°ÐµÑ ÑÐ¿Ð¸ÑÐ¾Ðº Ð²ÑÐµÑ Ð´Ð¾Ð¼Ð¾Ð² Ð² ÑÐ°Ð´Ð¸ÑÑÐµ(10).",
                        "<color=yellow>/home delete \"Ð¸Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÐ° Ð¸Ð»Ð¸ ID\" \"Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ\"</color> - Ð£Ð´Ð°Ð»ÑÐµÑ Ð´Ð¾Ð¼ Ñ ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¼ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸ÐµÐ¼, Ð¿ÑÐ¸Ð½Ð°Ð´Ð»ÐµÐ¶Ð°ÑÐ¸Ð¹ ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÑ.",
                        "<color=yellow>/home tp \"Ð¸Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÐ° Ð¸Ð»Ð¸ ID\" \"Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ\"</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÑÐµÑ Ð²Ð°Ñ Ð² Ð´Ð¾Ð¼ Ñ ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¼ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸ÐµÐ¼, Ð¿ÑÐ¸Ð½Ð°Ð´Ð»ÐµÐ¶Ð°ÑÐ¸Ð¹ ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÑ.",
                        "<color=yellow>/home homes \"Ð¸Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÐ° Ð¸Ð»Ð¸ ID\"</color> - ÐÑÐ¾Ð±ÑÐ°Ð¶Ð°ÐµÑ Ð²Ð°Ð¼ ÑÐ¿Ð¸ÑÐ¾Ðº Ð²ÑÐµÑ Ð´Ð¾Ð¼Ð¾Ð², Ð¿ÑÐ¸Ð½Ð°Ð´Ð»ÐµÐ¶Ð°ÑÐ¸Ñ ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÑ."
                    })
                },
                {
                    "SyntaxCommandTown", string.Join(NewLine, new[]
                    {
                        "ÐÑÐ¾Ð¸Ð·Ð¾ÑÐ»Ð° ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐµÑÐºÐ°Ñ Ð¾ÑÐ¸Ð±ÐºÐ°!",
                        "ÐÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ <color=yellow>/town</color> Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ¾Ð»ÑÐºÐ¾ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ð¼ Ð¾Ð±ÑÐ°Ð·Ð¾Ð¼:",
                        "<color=yellow>/town</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÑÐµÑ Ð²Ð°Ñ Ð² ÐÐ¾ÑÐ¾Ð´.",
                        "<color=yellow>/town pay</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÑÐµÑ Ð²Ð°Ñ Ð² ÐÐ¾ÑÐ¾Ð´ Ñ Ð¾Ð¿Ð»Ð°ÑÐ¾Ð¹ ÑÑÑÐ°ÑÐ°."
                    })
                },
                {
                    "SyntaxCommandTownAdmin", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/town set</color> - Ð¡Ð¾ÑÑÐ°Ð½ÑÐµÑ ÑÐµÐºÑÑÐµÐµ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ ÐºÐ°Ðº ÐÐ¾ÑÐ¾Ð´.",
                    })
                },
                {
                    "SyntaxCommandOutpost", string.Join(NewLine, new[]
                    {
                        "ÐÑÐ¾Ð¸Ð·Ð¾ÑÐ»Ð° ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐµÑÐºÐ°Ñ Ð¾ÑÐ¸Ð±ÐºÐ°!",
                        "ÐÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ <color=yellow>/outpost</color> Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ¾Ð»ÑÐºÐ¾ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ð¼ Ð¾Ð±ÑÐ°Ð·Ð¾Ð¼:",
                        "<color=yellow>/outpost</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÑÐµÑ Ð²Ð°Ñ Ð² ÐÐ¾ÑÐ¾Ð´ NPC.",
                        "<color=yellow>/outpost pay</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÑÐµÑ Ð²Ð°Ñ Ð² ÐÐ¾ÑÐ¾Ð´ NPC Ñ Ð¾Ð¿Ð»Ð°ÑÐ¾Ð¹ ÑÑÑÐ°ÑÐ°."
                    })
                },
                {
                    "SyntaxCommandOutpostAdmin", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/outpost set</color> - Ð¡Ð¾ÑÑÐ°Ð½ÑÐµÑ ÑÐµÐºÑÑÐµÐµ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ ÐºÐ°Ðº ÐÐ¾ÑÐ¾Ð´ NPC.",
                    })
                },
                {
                    "SyntaxCommandBandit", string.Join(NewLine, new[]
                    {
                        "ÐÑÐ¾Ð¸Ð·Ð¾ÑÐ»Ð° ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐµÑÐºÐ°Ñ Ð¾ÑÐ¸Ð±ÐºÐ°!",
                        "ÐÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ <color=yellow>/bandit</color> Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ¾Ð»ÑÐºÐ¾ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ð¼ Ð¾Ð±ÑÐ°Ð·Ð¾Ð¼:",
                        "<color=yellow>/bandit</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÑÐµÑ Ð²Ð°Ñ Ð² ÐÐ°Ð³ÐµÑÑ Ð±Ð°Ð½Ð´Ð¸ÑÐ¾Ð².",
                        "<color=yellow>/bandit pay</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÑÐµÑ Ð²Ð°Ñ Ð² ÐÐ°Ð³ÐµÑÑ Ð±Ð°Ð½Ð´Ð¸ÑÐ¾Ð² Ñ Ð¾Ð¿Ð»Ð°ÑÐ¾Ð¹ ÑÑÑÐ°ÑÐ°."
                    })
                },
                {
                    "SyntaxCommandBanditAdmin", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/bandit set</color> - Ð¡Ð¾ÑÑÐ°Ð½ÑÐµÑ ÑÐµÐºÑÑÐµÐµ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ ÐºÐ°Ðº ÐÐ°Ð³ÐµÑÑ Ð±Ð°Ð½Ð´Ð¸ÑÐ¾Ð².",
                    })
                },
                {
                    "SyntaxCommandHomeDelete", string.Join(NewLine, new[]
                    {
                        "ÐÑÐ¾Ð¸Ð·Ð¾ÑÐ»Ð° ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐµÑÐºÐ°Ñ Ð¾ÑÐ¸Ð±ÐºÐ°!",
                        "ÐÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ <color=yellow>/home delete</color> Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ¾Ð»ÑÐºÐ¾ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ð¼ Ð¾Ð±ÑÐ°Ð·Ð¾Ð¼:",
                        "<color=yellow>/home delete \"Ð¸Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÐ° Ð¸Ð»Ð¸ ID\" \"Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ\"</color> - Ð£Ð´Ð°Ð»ÑÐµÑ Ð´Ð¾Ð¼ Ñ ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¼ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸ÐµÐ¼, Ð¿ÑÐ¸Ð½Ð°Ð´Ð»ÐµÐ¶Ð°ÑÐ¸Ð¹ ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÑ."
                    })
                },
                {
                    "SyntaxCommandHomeAdminTP", string.Join(NewLine, new[]
                    {
                        "ÐÑÐ¾Ð¸Ð·Ð¾ÑÐ»Ð° ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐµÑÐºÐ°Ñ Ð¾ÑÐ¸Ð±ÐºÐ°!",
                        "ÐÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ <color=yellow>/home tp</color> Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ¾Ð»ÑÐºÐ¾ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ð¼ Ð¾Ð±ÑÐ°Ð·Ð¾Ð¼:",
                        "<color=yellow>/home tp \"Ð¸Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÐ° Ð¸Ð»Ð¸ ID\" \"Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ\"</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÑÐµÑ Ð²Ð°Ñ Ð² Ð´Ð¾Ð¼ Ð¸Ð³ÑÐ¾ÐºÐ° Ñ ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¼ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸ÐµÐ¼, Ð¿ÑÐ¸Ð½Ð°Ð´Ð»ÐµÐ¶Ð°ÑÐ¸Ð¹ ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÑ."
                    })
                },
                {
                    "SyntaxCommandHomeHomes", string.Join(NewLine, new[]
                    {
                        "ÐÑÐ¾Ð¸Ð·Ð¾ÑÐ»Ð° ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐµÑÐºÐ°Ñ Ð¾ÑÐ¸Ð±ÐºÐ°!",
                        "ÐÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ <color=yellow>/home homes</color> Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ¾Ð»ÑÐºÐ¾ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ð¼ Ð¾Ð±ÑÐ°Ð·Ð¾Ð¼:",
                        "<color=yellow>/home homes \"Ð¸Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÐ° Ð¸Ð»Ð¸ ID\"</color> - ÐÑÐ¾Ð±ÑÐ°Ð¶Ð°ÐµÑ Ð²Ð°Ð¼ ÑÐ¿Ð¸ÑÐ¾Ðº Ð²ÑÐµÑ Ð´Ð¾Ð¼Ð¾Ð², Ð¿ÑÐ¸Ð½Ð°Ð´Ð»ÐµÐ¶Ð°ÑÐ¸Ñ ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÑ."
                    })
                },
                {
                    "SyntaxCommandListHomes", string.Join(NewLine, new[]
                    {
                        "ÐÑÐ¾Ð¸Ð·Ð¾ÑÐ»Ð° ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐµÑÐºÐ°Ñ Ð¾ÑÐ¸Ð±ÐºÐ°!",
                        "ÐÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ <color=yellow>/home list</color> Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ¾Ð»ÑÐºÐ¾ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ð¼ Ð¾Ð±ÑÐ°Ð·Ð¾Ð¼:",
                        "<color=yellow>/home list</color> - ÐÑÐ¾Ð±ÑÐ°Ð¶Ð°ÐµÑ ÑÐ¿Ð¸ÑÐ¾Ðº Ð²ÑÐµÑ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ð¹, ÑÐ¾ÑÑÐ°Ð½ÑÐ½Ð½ÑÑ Ð²Ð°Ð¼Ð¸ ÐºÐ°Ðº Ð´Ð¾Ð¼."
                    })
                },
                {
                    "SyntaxCommandTPR", string.Join(NewLine, new[]
                    {
                        "ÐÑÐ¾Ð¸Ð·Ð¾ÑÐ»Ð° ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐµÑÐºÐ°Ñ Ð¾ÑÐ¸Ð±ÐºÐ°!",
                        "ÐÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ <color=yellow>/tpr</color> Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ¾Ð»ÑÐºÐ¾ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ð¼ Ð¾Ð±ÑÐ°Ð·Ð¾Ð¼:",
                        "<color=yellow>/tpr \"Ð¸Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÐ° Ð¸Ð»Ð¸ ID\"</color> - ÐÑÐ¿ÑÐ°Ð²Ð»ÑÐµÑ ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÑ Ð·Ð°Ð¿ÑÐ¾Ñ Ð½Ð° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ñ."
                    })
                },
                {
                    "SyntaxCommandTPA", string.Join(NewLine, new[]
                    {
                        "ÐÑÐ¾Ð¸Ð·Ð¾ÑÐ»Ð° ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐµÑÐºÐ°Ñ Ð¾ÑÐ¸Ð±ÐºÐ°!",
                        "ÐÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ <color=yellow>/tpa</color> Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ¾Ð»ÑÐºÐ¾ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ð¼ Ð¾Ð±ÑÐ°Ð·Ð¾Ð¼:",
                        "<color=yellow>/tpa</color> - ÐÑÐ¸Ð½ÑÑÑ Ð²ÑÐ¾Ð´ÑÑÐ¸Ð¹ Ð·Ð°Ð¿ÑÐ¾Ñ Ð½Ð° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ñ."
                    })
                },
                {
                    "SyntaxCommandTPC", string.Join(NewLine, new[]
                    {
                        "ÐÑÐ¾Ð¸Ð·Ð¾ÑÐ»Ð° ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐµÑÐºÐ°Ñ Ð¾ÑÐ¸Ð±ÐºÐ°!",
                        "ÐÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ <color=yellow>/tpc</color> Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ¾Ð»ÑÐºÐ¾ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ð¼ Ð¾Ð±ÑÐ°Ð·Ð¾Ð¼:",
                        "<color=yellow>/tpc</color> - ÐÑÐ¼ÐµÐ½Ð¸ÑÑ Ð·Ð°Ð¿ÑÐ¾Ñ Ð½Ð° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÐ¸Ñ."
                    })
                },
                {
                    "SyntaxConsoleCommandToPos", string.Join(NewLine, new[]
                    {
                        "ÐÑÐ¾Ð¸Ð·Ð¾ÑÐ»Ð° ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐµÑÐºÐ°Ñ Ð¾ÑÐ¸Ð±ÐºÐ°!",
                        "ÐÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ ÐºÐ¾Ð½ÑÐ¾Ð»ÑÐ½Ð¾Ð¹ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ <color=orange>teleport.topos</color> Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ¾Ð»ÑÐºÐ¾ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ð¼ Ð¾Ð±ÑÐ°Ð·Ð¾Ð¼:",
                        " > <color=orange>teleport.topos \"Ð¸Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÐ°\" x y z</color>"
                    })
                },
                {
                    "SyntaxConsoleCommandToPlayer", string.Join(NewLine, new[]
                    {
                        "ÐÑÐ¾Ð¸Ð·Ð¾ÑÐ»Ð° ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐµÑÐºÐ°Ñ Ð¾ÑÐ¸Ð±ÐºÐ°!",
                        "ÐÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ ÐºÐ¾Ð½ÑÐ¾Ð»ÑÐ½Ð¾Ð¹ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ <color=orange>teleport.toplayer</color> Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ¾Ð»ÑÐºÐ¾ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ð¼ Ð¾Ð±ÑÐ°Ð·Ð¾Ð¼:",
                        " > <color=orange>teleport.toplayer \"Ð¸Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÐ° Ð¸Ð»Ð¸ ID\" \"Ð¸Ð¼Ñ Ð¸Ð³ÑÐ¾ÐºÐ° 2|id 2\"</color>"
                    })
                },
                {"LogTeleport", "{0} ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°Ð½ Ðº {1}."},
                {"LogTeleportPlayer", "{0} ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°Ð» {1} Ðº {2}."},
                {"LogTeleportBack", "{0} ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°Ð½ Ð½Ð°Ð·Ð°Ð´, Ð² Ð¿ÑÐµÐ´ÑÐ´ÑÑÐµÐµ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ."}
            };

            foreach (var key in config.DynamicCommands.Keys)
            {
                ru[key] = key;
            }

            foreach (var key in monumentMessages)
            {
                ru[key] = key;
            }

            lang.RegisterMessages(ru, this, "ru");

            var uk = new Dictionary<string, string>
            {
                {"ErrorTPR", "Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑ Ð´Ð¾ {0} Ð±Ð»Ð¾ÐºÐ¾Ð²Ð°Ð½Ð¾ ({1})"},
                {"AdminTP", "ÐÐ¸ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¾Ð²Ð°Ð½Ñ Ð´Ð¾ {0}!"},
                {"AdminTPTarget", "{0} ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°Ð² Ð²Ð°Ñ!"},
                {"AdminTPPlayers", "ÐÐ¸ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°Ð»Ð¸ {0} Ð´Ð¾ {1}!"},
                {"AdminTPPlayer", "{0} ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°Ð² Ð²Ð°Ñ Ð´Ð¾ {1}!"},
                {"AdminTPPlayerTarget", "{0} ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°Ð² {1} Ð´Ð¾ Ð²Ð°Ñ!"},
                {"AdminTPCoordinates", "ÐÐ¸ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¾Ð²Ð°Ð½Ñ Ð´Ð¾ {0}!"},
                {"AdminTPTargetCoordinates", "ÐÐ¸ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°Ð»Ð¸ {0} Ð´Ð¾ {1}!"},
                {"AdminTPOutOfBounds", "ÐÐ¸ Ð½Ð°Ð¼Ð°Ð³Ð°Ð»Ð¸ÑÑ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°ÑÐ¸ÑÑ Ð´Ð¾ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°Ñ Ð¿Ð¾Ð·Ð° Ð¼ÐµÐ¶Ð°Ð¼Ð¸ ÐºÐ°ÑÑÐ¸!"},
                {"AdminTPBoundaries", "ÐÐ½Ð°ÑÐµÐ½Ð½Ñ X ÑÐ° Z Ð¿Ð¾Ð²Ð¸Ð½Ð½Ñ Ð±ÑÑÐ¸ Ð¼ÑÐ¶ -{0} ÑÐ° {0}, Ð° Ð·Ð½Ð°ÑÐµÐ½Ð½Ñ Y Ð¼ÑÐ¶ -100 ÑÐ° 2000!"},
                {"AdminTPLocation", "ÐÐ¸ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¾Ð²Ð°Ð½Ñ Ð´Ð¾ {0}!"},
                {"AdminTPLocationSave", "ÐÐ¸ Ð·Ð±ÐµÑÐµÐ³Ð»Ð¸ Ð¼ÑÑÑÐµÐ·Ð½Ð°ÑÐ¾Ð´Ð¶ÐµÐ½Ð½Ñ!"},
                {"AdminTPLocationRemove", "ÐÐ¸ Ð²Ð¸Ð´Ð°Ð»Ð¸Ð»Ð¸ ÑÐ¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ {0}!"},
                {"AdminLocationList", "ÐÐ¾ÑÑÑÐ¿Ð½Ñ ÑÐ°ÐºÑ ÑÐ¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ:"},
                {"AdminLocationListEmpty", "ÐÐ¸ Ð½Ðµ Ð·Ð±ÐµÑÐµÐ³Ð»Ð¸ Ð¶Ð¾Ð´Ð½Ð¸Ñ Ð¼ÑÑÑÑ!"},
                {"AdminTPBack", "ÐÐ¸ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¾Ð²Ð°Ð½Ñ Ð½Ð°Ð·Ð°Ð´, Ñ Ð²Ð°ÑÐµ Ð¿Ð¾Ð¿ÐµÑÐµÐ´Ð½Ñ ÑÐ¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ!"},
                {"AdminTPBackSave", "ÐÐ°ÑÐµ Ð¿Ð¾Ð¿ÐµÑÐµÐ´Ð½Ñ Ð¼ÑÑÑÐµ Ð·Ð±ÐµÑÐµÐ¶ÐµÐ½Ð¾, Ð²Ð¸ÐºÐ¾ÑÐ¸ÑÑÐ¾Ð²ÑÐ¹ÑÐµ <color=yellow>/tpb</color>, ÑÐ¾Ð± ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°ÑÐ¸ÑÑ Ð½Ð°Ð·Ð°Ð´!"},
                {"AdminTPTargetCoordinatesTarget", "{0} ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°Ð² Ð²Ð°Ñ Ð´Ð¾ {1}!"},
                {"AdminTPConsoleTP", "ÐÐ¸ Ð±ÑÐ»Ð¸ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¾Ð²Ð°Ð½Ñ Ð´Ð¾ {0}"},
                {"AdminTPConsoleTPPlayer", "ÐÐ¸ Ð±ÑÐ»Ð¸ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¾Ð²Ð°Ð½Ñ Ð´Ð¾ {0}"},
                {"AdminTPConsoleTPPlayerTarget", "{0} Ð±ÑÐ² ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¾Ð²Ð°Ð½Ð¸Ð¹ Ð´Ð¾ Ð²Ð°Ñ!"},
                {"HomeTP", "ÐÐ¸ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¾Ð²Ð°Ð½Ñ Ð´Ð¾ Ð²Ð°ÑÐ¾Ð³Ð¾ Ð±ÑÐ´Ð¸Ð½ÐºÑ '{0}'!"},
                {"HomeAdminTP", "ÐÐ¸ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¾Ð²Ð°Ð½Ñ Ð´Ð¾ Ð±ÑÐ´Ð¸Ð½ÐºÑ '{1}', ÑÐ¾ Ð½Ð°Ð»ÐµÐ¶Ð¸ÑÑ {0}!"},
                {"HomeIce", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐ¾ÑÑÐ°Ð½Ð¸ÑÑ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð² ÐºÐ°ÑÐµÑÑÐ²Ðµ Ð´Ð¾Ð¼Ð° Ð½Ð° Ð»ÐµÐ´ÑÐ½Ð¾Ð¼ Ð¾Ð·ÐµÑÐµ!"},
                {"HomeSave", "ÐÐ¸ Ð·Ð±ÐµÑÐµÐ³Ð»Ð¸ Ð¿Ð¾ÑÐ¾ÑÐ½Ðµ ÑÐ¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ ÑÐº Ð²Ð°Ñ Ð±ÑÐ´Ð¸Ð½Ð¾Ðº!"},
                {"HomeNoFoundation", "ÐÐ¸ÐºÐ¾ÑÐ¸ÑÑÐ¾Ð²ÑÐ²Ð°ÑÐ¸ Ð¼ÑÑÑÐµÐ·Ð½Ð°ÑÐ¾Ð´Ð¶ÐµÐ½Ð½Ñ ÑÐº Ð±ÑÐ´Ð¸Ð½Ð¾Ðº Ð´Ð¾Ð·Ð²Ð¾Ð»ÐµÐ½Ð¾ ÑÑÐ»ÑÐºÐ¸ Ð½Ð° ÑÑÐ½Ð´Ð°Ð¼ÐµÐ½ÑÑ!"},
                {"HomeFoundationNotOwned", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ Ð²Ð¸ÐºÐ¾ÑÐ¸ÑÑÐ¾Ð²ÑÐ²Ð°ÑÐ¸ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ home Ñ ÑÑÐ¶Ð¾Ð¼Ñ Ð´Ð¾Ð¼Ñ."},
                {"HomeFoundationUnderneathFoundation", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ Ð²Ð¸ÐºÐ¾ÑÐ¸ÑÑÐ¾Ð²ÑÐ²Ð°ÑÐ¸ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ home Ð½Ð° ÑÑÐ½Ð´Ð°Ð¼ÐµÐ½ÑÑ, ÑÐ¾ Ð·Ð½Ð°ÑÐ¾Ð´Ð¸ÑÑÑÑ Ð¿ÑÐ´ ÑÐ½ÑÐ¸Ð¼ ÑÑÐ½Ð´Ð°Ð¼ÐµÐ½ÑÐ¾Ð¼."},
                {"HomeFoundationNotFriendsOwned", "ÐÐ¸, Ð°Ð±Ð¾ Ð²Ð°Ñ Ð´ÑÑÐ³, Ð¿Ð¾Ð²Ð¸Ð½Ð½Ñ Ð±ÑÑÐ¸ Ð²Ð»Ð°ÑÐ½Ð¸ÐºÐ¾Ð¼ Ð±ÑÐ´Ð¸Ð½ÐºÑ, ÑÐ¾Ð± Ð²Ð¸ÐºÐ¾ÑÐ¸ÑÑÐ°ÑÐ¸ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ home!"},
                {"HomeRemovedInvalid", "ÐÐ°Ñ Ð±ÑÐ´Ð¸Ð½Ð¾Ðº '{0}' Ð±ÑÐ² Ð²Ð¸Ð´Ð°Ð»ÐµÐ½Ð¸Ð¹ ÑÐ¾Ð¼Ñ, ÑÐ¾ Ð½Ðµ Ð½Ð° ÑÑÐ½Ð´Ð°Ð¼ÐµÐ½ÑÑ Ð°Ð±Ð¾ Ñ ÑÑÐ½Ð´Ð°Ð¼ÐµÐ½ÑÑ Ð½Ð¾Ð²Ð¸Ð¹ Ð²Ð»Ð°ÑÐ½Ð¸Ðº!"},
                {"HighWallCollision", "ÐÑÑÐºÐ½ÐµÐ½Ð½Ñ ÐÐ¸ÑÐ¾ÐºÐ¸Ñ Ð¡ÑÑÐ½!"},
                {"HomeRemovedDestroyed", "ÐÐ°Ñ Ð±ÑÐ´Ð¸Ð½Ð¾Ðº '{0}' Ð²Ð¸Ð´Ð°Ð»ÐµÐ½Ð¾, Ð¾ÑÐºÑÐ»ÑÐºÐ¸ Ð²ÑÐ½ Ð±ÑÐ»ÑÑÐµ Ð½Ðµ ÑÑÐ½ÑÑ!"},
                {"HomeRemovedInsideBlock", "ÐÐ°Ñ Ð±ÑÐ´Ð¸Ð½Ð¾Ðº '{0}' Ð±ÑÐ² Ð²Ð¸Ð´Ð°Ð»ÐµÐ½Ð¸Ð¹, ÑÐ¾Ð¼Ñ ÑÐ¾ Ð²ÑÐµÑÐµÐ´Ð¸Ð½Ñ ÑÑÐ½Ð´Ð°Ð¼ÐµÐ½ÑÑ!"},
                {"HomeRemove", "ÐÐ¸ Ð²Ð¸Ð´Ð°Ð»Ð¸Ð»Ð¸ ÑÐ²ÑÐ¹ Ð±ÑÐ´Ð¸Ð½Ð¾Ðº {0}!"},
                {"HomeDelete", "ÐÐ¸ Ð²Ð¸Ð´Ð°Ð»Ð¸Ð»Ð¸ Ð±ÑÐ´Ð¸Ð½Ð¾Ðº '{1}', ÑÐ¾ Ð½Ð°Ð»ÐµÐ¶Ð¸ÑÑ {0}!"},
                {"HomeList", "ÐÐ¾ÑÑÑÐ¿Ð½Ñ ÑÐ°ÐºÑ Ð±ÑÐ´Ð¸Ð½ÐºÐ¸:"},
                {"HomeListEmpty", "ÐÐ¸ Ð½Ðµ Ð·Ð±ÐµÑÐµÐ³Ð»Ð¸ Ð¶Ð¾Ð´Ð½Ð¾Ð³Ð¾ Ð±ÑÐ´Ð¸Ð½ÐºÑ!"},
                {"HomeMaxLocations", "ÐÐµÐ¼Ð¾Ð¶Ð»Ð¸Ð²Ð¾ Ð²ÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÐ¸ ÑÑÑ Ð²Ð°Ñ Ð±ÑÐ´Ð¸Ð½Ð¾Ðº, Ð²Ð¸ Ð´Ð¾ÑÑÐ³Ð»Ð¸ Ð»ÑÐ¼ÑÑÑ Ð² {0} Ð±ÑÐ´Ð¸Ð½ÐºÑÐ²!"},
                {"HomeQuota", "ÐÐ¸ Ð²ÑÑÐ°Ð½Ð¾Ð²Ð¸Ð»Ð¸ {0} Ð· {1} Ð¼Ð°ÐºÑÐ¸Ð¼Ð°Ð»ÑÐ½Ð¾ Ð¼Ð¾Ð¶Ð»Ð¸Ð²Ð¸Ñ Ð±ÑÐ´Ð¸Ð½ÐºÑÐ²!"},
                {"HomeTugboatNotAllowed", "You are not allowed to sethome on tugboats."},
                {"HomeTPStarted", "Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÑ Ð´Ð¾ Ð²Ð°ÑÐ¾Ð³Ð¾ Ð±ÑÐ´Ð¸Ð½ÐºÑ {0} ÑÐµÑÐµÐ· {1} ÑÐµÐºÑÐ½Ð´!"},
                {"PayToTown", "Ð¡ÑÐ°Ð½Ð´Ð°ÑÑÐ½Ð¸Ð¹ Ð¿Ð»Ð°ÑÑÐ¶ {0} Ð¿Ð¾ÑÐ¸ÑÑÑÑÑÑÑ Ð½Ð° Ð²ÑÑ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ Ð´Ð¾ Ð¼ÑÑÑÐ°!"},
                {"PayToTPR", "Ð¡ÑÐ°Ð½Ð´Ð°ÑÑÐ½Ð¸Ð¹ Ð¿Ð»Ð°ÑÑÐ¶ {0} Ð¿Ð¾ÑÐ¸ÑÑÑÑÑÑÑ Ð½Ð° Ð²ÑÑ tpr'Ð¸!"},
                {"HomeTPCooldown", "ÐÐ°Ñ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑ Ð¿ÐµÑÐµÐ·Ð°ÑÑÐ´Ð¶Ð°ÑÑÑÑÑ. ÐÐ°Ð¼ Ð½ÐµÐ¾Ð±ÑÑÐ´Ð½Ð¾ Ð¿Ð¾ÑÐµÐºÐ°ÑÐ¸ {0} Ð´Ð¾ Ð½Ð°ÑÑÑÐ¿Ð½Ð¾Ñ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÑ."},
                {"HomeTPCooldownBypass", "ÐÐ°Ñ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑ Ð±ÑÐ² Ð½Ð° Ð¿ÐµÑÐµÐ·Ð°ÑÑÐ´Ð¶ÐµÐ½Ð½Ñ. ÐÐ¸ Ð¾Ð±ÑÐ°Ð»Ð¸ ÑÐ½Ð¸ÐºÐ½ÑÑÐ¸ Ð¾ÑÑÐºÑÐ²Ð°Ð½Ð½Ñ, ÑÐ¿Ð»Ð°ÑÐ¸Ð²ÑÐ¸ {0} Ð· Ð²Ð°ÑÐ¾Ð³Ð¾ Ð±Ð°Ð»Ð°Ð½ÑÑ."},
                {"HomeTPCooldownBypassF", "ÐÐ°Ñ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑ Ð¿ÐµÑÐµÐ·Ð°ÑÑÐ´Ð¶Ð°ÑÑÑÑÑ. Ð£ Ð²Ð°Ñ Ð½ÐµÐ´Ð¾ÑÑÐ°ÑÐ½ÑÐ¾ ÐºÐ¾ÑÑÑÐ² - ÑÐ¾Ð± ÑÐ½Ð¸ÐºÐ½ÑÑÐ¸ Ð¾ÑÑÐºÑÐ²Ð°Ð½Ð½Ñ."},
                {"HomeTPCooldownBypassP", "ÐÐ¸ Ð¼Ð¾Ð¶ÐµÑÐµ Ð²Ð¸Ð±ÑÐ°ÑÐ¸ Ð¾Ð¿Ð»Ð°ÑÐ¸ÑÐ¸ {0} ÑÐ¾Ð± ÑÐ½Ð¸ÐºÐ½ÑÑÐ¸ Ð¾ÑÑÐºÑÐ²Ð°Ð½Ð½Ñ Ð¿ÐµÑÐµÐ·Ð°ÑÑÐ´Ð¶Ð°Ð½Ð½Ñ." },
                {"HomeTPCooldownBypassP2", "ÐÐ²ÐµÐ´ÑÑÑ <color=yellow>/home \"Ð½Ð°Ð·Ð²Ð° Ð±ÑÐ´Ð¸Ð½ÐºÑ\" {0}</color>." },
                {"HomeTPLimitReached", "ÐÐ¸ Ð²Ð¸ÑÐµÑÐ¿Ð°Ð»Ð¸ ÑÐ¾Ð´ÐµÐ½Ð½Ð¸Ð¹ Ð»ÑÐ¼ÑÑ {0} ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÐ¹ ÑÑÐ¾Ð³Ð¾Ð´Ð½Ñ!"},
                {"HomeTPAmount", "Ð£ Ð²Ð°Ñ Ð·Ð°Ð»Ð¸ÑÐ¸Ð»Ð¾ÑÑ {0} ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÐ¹ Ð´Ð¾Ð´Ð¾Ð¼Ñ ÑÑÐ¾Ð³Ð¾Ð´Ð½Ñ!"},
                {"HomesListWiped", "ÐÐ¸ Ð¾ÑÐ¸ÑÑÐ¸Ð»Ð¸ Ð²ÑÑ Ð¼ÑÑÑÑ, Ð·Ð±ÐµÑÐµÐ¶ÐµÐ½Ñ ÑÐº Ð±ÑÐ´Ð¸Ð½Ð¾Ðº!"},
                {"HomeTPBuildingBlocked", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ Ð·Ð±ÐµÑÐµÐ³ÑÐ¸ Ð¼ÑÑÑÐµ ÑÐ¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ ÑÐº Ð±ÑÐ´Ð¸Ð½Ð¾Ðº, ÑÐºÑÐ¾ Ñ Ð²Ð°Ñ Ð½ÐµÐ¼Ð°Ñ Ð¿ÑÐ°Ð² Ð½Ð° Ð±ÑÐ´ÑÐ²Ð½Ð¸ÑÑÐ²Ð¾ Ð² ÑÑÐ¹ Ð·Ð¾Ð½Ñ!"},
                {"HomeTPSwimming", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ Ð²ÑÑÐ°Ð½Ð¾Ð²Ð»ÑÐ²Ð°ÑÐ¸ Ð¼ÑÑÑÐµ ÑÐ¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ Ð² ÑÐºÐ¾ÑÑÑ Ð±ÑÐ´Ð¸Ð½ÐºÑ Ð¿Ð¾ÐºÐ¸ Ð¿Ð»Ð¸Ð²ÐµÑÐµ!"},
                {"HomeTPCrafting", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ Ð²ÑÑÐ°Ð½Ð¾Ð²Ð»ÑÐ²Ð°ÑÐ¸ Ð¼ÑÑÑÐµ ÑÐ¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ ÑÐº Ð±ÑÐ´Ð¸Ð½Ð¾Ðº Ð² Ð¿ÑÐ¾ÑÐµÑÑ ÐºÑÐ°ÑÑÑ!"},
                {"Request", "ÐÐ¸ Ð·Ð°Ð¿ÑÐ¾ÑÐ¸Ð»Ð¸ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÑ Ð´Ð¾ {0}!"},
                {"RequestUI", "<size=14><color=#FFA500>TP Request:</color> {0}</size>"},
                {"RequestTarget", "{0} Ð·Ð°Ð¿ÑÐ¾ÑÐ¸Ð² ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÑ Ð´Ð¾ Ð²Ð°Ñ! ÐÐ¸ÐºÐ¾ÑÐ¸ÑÑÐ¾Ð²ÑÐ¹ÑÐµ <color=yellow>/tpa</color>, ÑÐ¾Ð± Ð¿ÑÐ¸Ð¹Ð½ÑÑÐ¸!"},
                {"RequestTargetOff", "ÐÐ°Ñ Ð·Ð°Ð¿Ð¸Ñ Ð±ÑÐ»Ð¾ ÑÐºÐ°ÑÐ¾Ð²Ð°Ð½Ð¾, Ð¾ÑÐºÑÐ»ÑÐºÐ¸ ÑÑÐ»Ñ Ð·Ð°ÑÐ°Ð· Ð½Ðµ Ð² Ð¼ÐµÑÐµÐ¶Ñ." },
                {"RequestAccept", "<size=12>ÐÑÐ¸Ð½ÑÑÑ</size>" },
                {"RequestReject", "<size=12>ÐÑÐºÐ°Ð·Ð°ÑÑÑÑ</size>" },
                {"TPR_NoClan_NoFriend_NoTeam", "Ð¦Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð° Ð´Ð¾ÑÑÑÐ¿Ð½Ð° Ð»Ð¸ÑÐµ Ð´ÑÑÐ·ÑÐ¼, ÑÑÐ°ÑÐ½Ð¸ÐºÐ°Ð¼ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¸ Ð°Ð±Ð¾ ÐºÐ»Ð°Ð½Ñ!"},
                {"PendingRequest", "Ð£ Ð²Ð°Ñ Ð²Ð¶Ðµ Ñ Ð°ÐºÑÐ¸Ð²Ð½Ð¸Ð¹ Ð·Ð°Ð¿Ð¸Ñ, ÑÐºÐ°ÑÑÐ¹ÑÐµ Ð¹Ð¾Ð³Ð¾, ÑÐµÐºÐ°Ð¹ÑÐµ Ð½Ð° Ð¿ÑÐ´ÑÐ²ÐµÑÐ´Ð¶ÐµÐ½Ð½Ñ, Ð°Ð±Ð¾ ÑÐºÐ°ÑÑÐ²Ð°Ð½Ð½Ñ Ð¿Ð¾ ÑÐ°Ð¹Ð¼ÑÑÑÑ!"},
                {"PendingRequestTarget", "Ð£ Ð³ÑÐ°Ð²ÑÑ, Ð´Ð¾ ÑÐºÐ¾Ð³Ð¾ Ð²Ð¸ ÑÐ¾ÑÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°ÑÐ¸ÑÑ, Ð²Ð¶Ðµ Ñ Ð°ÐºÑÐ¸Ð²Ð½Ð¸Ð¹ Ð·Ð°Ð¿Ð¸Ñ, ÑÐ¿ÑÐ¾Ð±ÑÐ¹ÑÐµ Ð¿ÑÐ·Ð½ÑÑÐµ!"},
                {"NoPendingRequest", "ÐÐ¸ Ð½Ðµ Ð¼Ð°ÑÑÐµ Ð°ÐºÑÐ¸Ð²Ð½Ð¸Ñ Ð·Ð°Ð¿Ð¸ÑÑÐ² Ð½Ð° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÑ!"},
                {"Accept", "{0} Ð¿ÑÐ¸Ð¹Ð½ÑÐ² Ð²Ð°Ñ Ð·Ð°Ð¿Ð¸Ñ! Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÑ ÑÐµÑÐµÐ· {1} ÑÐµÐºÑÐ½Ð´!"},
                {"AcceptTarget", "ÐÐ¸ Ð¾ÑÑÐ¸Ð¼Ð°Ð»Ð¸ Ð·Ð°Ð¿Ð¸Ñ Ð½Ð° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÑ {0}!"},
                {"AcceptToggleOff", "ÐÐ¸ Ð²Ð¸Ð¼ÐºÐ½ÑÐ»Ð¸ Ð°Ð²ÑÐ¾Ð¼Ð°ÑÐ¸ÑÐ½Ðµ /tpa!"},
                {"AcceptToggleOn", "ÐÐ¸ Ð²Ð²ÑÐ¼ÐºÐ½ÑÐ»Ð¸ Ð°Ð²ÑÐ¾Ð¼Ð°ÑÐ¸ÑÐ½Ðµ /tpa!"},
                {"NotAllowed", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ Ð²Ð¸ÐºÐ¾ÑÐ¸ÑÑÐ¾Ð²ÑÐ²Ð°ÑÐ¸ ÑÑ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ!"},
                {"Success", "ÐÐ¸ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¾Ð²Ð°Ð½Ñ Ð´Ð¾ {0}!"},
                {"SuccessTarget", "{0} ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¾Ð²Ð°Ð½Ð¸Ð¹ Ð´Ð¾ Ð²Ð°Ñ!"},
                {"BlockedTeleportTarget", "You can't teleport to user \"{0}\", they have you teleport blocked!"},
                {"Cancelled", "ÐÐ°Ñ Ð·Ð°Ð¿Ð¸Ñ Ð½Ð° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÑ Ð´Ð¾ {0} Ð±ÑÐ»Ð¾ ÑÐºÐ°ÑÐ¾Ð²Ð°Ð½Ð¾!"},
                {"CancelledTarget", "ÐÐ°Ð¿Ð¸Ñ Ð½Ð° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÑ {0} Ð±ÑÐ»Ð¾ ÑÐºÐ°ÑÐ¾Ð²Ð°Ð½Ð¾!"},
                {"TPCancelled", "ÐÐ°Ñ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑ ÑÐºÐ°ÑÐ¾Ð²Ð°Ð½Ð¾!"},
                {"TPCancelledTarget", "{0} ÑÐºÐ°ÑÑÐ²Ð°Ð² ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÑ!"},
                {"TPYouCancelledTarget", "ÐÐ¸ ÑÐºÐ°ÑÑÐ²Ð°Ð»Ð¸ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÑ {0}!"},
                {"TimedOut", "{0} Ð½Ðµ Ð²ÑÐ´Ð¿Ð¾Ð²ÑÐ² Ð½Ð° Ð²Ð°Ñ Ð·Ð°Ð¿Ð¸Ñ Ð¿ÑÐ´ ÑÐ°Ñ!"},
                {"TimedOutTarget", "ÐÐ¸ Ð½Ðµ Ð²ÑÐ°ÑÐ½Ð¾ Ð²ÑÐ´Ð¿Ð¾Ð²ÑÐ»Ð¸ Ð½Ð° Ð·Ð°Ð¿Ð¸Ñ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÑ Ð²ÑÐ´ {0}!"},
                {"TargetDisconnected", "{0} Ð²ÑÐ´ÐºÐ»ÑÑÐ¸Ð²ÑÑ, Ð²Ð°ÑÐ° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÑ ÑÐºÐ°ÑÐ¾Ð²Ð°Ð½Ð°!"},
                {"TPRCooldown", "ÐÐ°ÑÑ Ð·Ð°Ð¿Ð¸ÑÐ¸ Ð½Ð° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÑ Ð½Ð° Ð´Ð°Ð½Ð¸Ð¹ Ð¼Ð¾Ð¼ÐµÐ½Ñ Ð½Ð° Ð¿ÐµÑÐµÐ·Ð°ÑÑÐ´ÑÑ. ÐÐ°Ð¼ Ð½ÐµÐ¾Ð±ÑÑÐ´Ð½Ð¾ Ð·Ð°ÑÐµÐºÐ°ÑÐ¸ Ð½Ð° {0}, Ð¿ÐµÑÑ Ð½ÑÐ¶ Ð½Ð°Ð´ÑÑÐ»Ð°ÑÐ¸ Ð½Ð°ÑÑÑÐ¿Ð½Ð¸Ð¹ Ð·Ð°Ð¿Ð¸Ñ."},
                {"TPRCooldownBypass", "ÐÐ°ÑÑ Ð·Ð°Ð¿Ð¸ÑÐ¸ Ð½Ð° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÑ Ð±ÑÐ»Ð¸ Ð¿ÐµÑÐµÐ·Ð°ÑÑÐ´Ð¶ÐµÐ½Ñ. ÐÐ¸ Ð¾Ð±ÑÐ°Ð»Ð¸ ÑÐ½Ð¸ÐºÐ½ÑÑÐ¸ Ð¾ÑÑÐºÑÐ²Ð°Ð½Ð½Ñ, ÑÐ¿Ð»Ð°ÑÐ¸Ð²ÑÐ¸ {0} Ð· Ð²Ð°ÑÐ¾Ð³Ð¾ Ð±Ð°Ð»Ð°Ð½ÑÑ."},
                {"TPRCooldownBypassF", "ÐÐ°ÑÑ Ð·Ð°Ð¿Ð¸ÑÐ¸ Ð½Ð° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÑ Ð½Ð° Ð´Ð°Ð½Ð¸Ð¹ Ð¼Ð¾Ð¼ÐµÐ½Ñ Ð½Ð° Ð¿ÐµÑÐµÐ·Ð°ÑÑÐ´ÑÑ. Ð£ Ð²Ð°Ñ Ð½ÐµÐ´Ð¾ÑÑÐ°ÑÐ½ÑÐ¾ ÐºÐ¾ÑÑÑÐ² - ÑÐ¾Ð± ÑÐ½Ð¸ÐºÐ½ÑÑÐ¸ Ð¾ÑÑÐºÑÐ²Ð°Ð½Ð½Ñ."},
                {"TPRCooldownBypassP", "ÐÐ¸ Ð¼Ð¾Ð¶ÐµÑÐµ Ð²Ð¸Ð±ÑÐ°ÑÐ¸ Ð¾Ð¿Ð»Ð°ÑÐ¸ÑÐ¸ {0} ÑÐ¾Ð± ÑÐ½Ð¸ÐºÐ½ÑÑÐ¸ Ð¾ÑÑÐºÑÐ²Ð°Ð½Ð½Ñ Ð¿ÐµÑÐµÐ·Ð°ÑÑÐ´Ð¶Ð°Ð½Ð½Ñ." },
                {"TPMoney", "{0} ÑÐ¿Ð¸ÑÐ°Ð½Ð¾ Ð· Ð²Ð°ÑÐ¾Ð³Ð¾ Ð¾Ð±Ð»ÑÐºÐ¾Ð²Ð¾Ð³Ð¾ Ð·Ð°Ð¿Ð¸ÑÑ!"},
                {"TPNoMoney", "Ð£ Ð²Ð°Ñ Ð½ÐµÐ¼Ð°Ñ Ð¶Ð¾Ð´Ð½Ð¾Ð³Ð¾ Ð¾Ð±Ð»ÑÐºÐ¾Ð²Ð¾Ð³Ð¾ Ð·Ð°Ð¿Ð¸ÑÑ {0}!"},
                {"TPRCooldownBypassP2", "ÐÐ°Ð¿Ð¸ÑÑÑÑ <color=yellow>/tpr {0}</color>." },
                {"TPRCooldownBypassP2a", "ÐÐ°Ð¿Ð¸ÑÑÑÑ <color=yellow>/tpr \"ÑÐ¼'Ñ Ð³ÑÐ°Ð²ÑÑ\" {0}</color>." },
                {"TPRLimitReached", "ÐÐ¸ Ð²Ð¸ÑÐµÑÐ¿Ð°Ð»Ð¸ ÑÐ¾Ð´ÐµÐ½Ð½Ð¸Ð¹ Ð»ÑÐ¼ÑÑ {0} Ð·Ð°Ð¿Ð¸ÑÑÐ² Ð½Ð° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÑ ÑÑÐ¾Ð³Ð¾Ð´Ð½Ñ!"},
                {"TPRAmount", "Ð£ Ð²Ð°Ñ Ð·Ð°Ð»Ð¸ÑÐ¸Ð»Ð¾ÑÑ {0} Ð·Ð°Ð¿Ð¸ÑÑÐ² Ð½Ð° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÑ Ð½Ð° ÑÑÐ¾Ð³Ð¾Ð´Ð½Ñ!"},
                {"TPRTarget", "ÐÐ°ÑÐ° Ð¼ÐµÑÐ° Ð·Ð°ÑÐ°Ð· Ð½Ðµ Ð´Ð¾ÑÑÑÐ¿Ð½Ð°!"},
                {"TPDead", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°ÑÐ¸ÑÑ, Ð¿Ð¾ÐºÐ¸ Ð¼ÐµÑÑÐ²Ñ!"},
                {"TPWounded", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°ÑÐ¸ÑÑ, Ð±ÑÐ´ÑÑÐ¸ Ð¿Ð¾ÑÐ°Ð½ÐµÐ½Ð¸Ð¼!"},
                {"TPTooCold", "ÐÐ°Ð¼ Ð½Ð°Ð´ÑÐ¾ ÑÐ¾Ð»Ð¾Ð´Ð½Ð¾ Ð´Ð»Ñ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÑ!"},
                {"TPTooHot", "ÐÐ°Ð¼ Ð´ÑÐ¶Ðµ Ð¶Ð°ÑÐºÐ¾ Ð´Ð»Ñ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÑ!"},
                {"TPTugboat", "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ Ð½Ð° ÑÑÐ¾Ð¹ Ð»Ð¾Ð´ÐºÐµ!"},
                {"TPBoat", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°ÑÐ¸ÑÑ, Ð¿ÐµÑÐµÐ±ÑÐ²Ð°ÑÑÐ¸ Ð½Ð° ÑÐ¾Ð²Ð½Ñ!"},
                {"TPHostile", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°ÑÐ¸ÑÑ Ð² ÐÑÑÑÐ¾ NPC Ð°Ð±Ð¾ Ð¢Ð°Ð±ÑÑ Ð±Ð°Ð½Ð´Ð¸ÑÑÐ², Ð¿Ð¾ÐºÐ¸ Ð²Ð¾ÑÐ¾Ð¶Ñ!"},
                {"TPJunkpile", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°ÑÐ¸ÑÑ Ð· ÐºÑÐ¿Ð¸ ÑÐ¼ÑÑÑÑ"},
                {"HostileTimer", "Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑ Ð±ÑÐ´Ðµ Ð´Ð¾ÑÑÑÐ¿Ð½Ð¸Ð¹ ÑÐµÑÐµÐ· {0} ÑÐ²Ð¸Ð»Ð¸Ð½."},
                {"TPMounted", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°ÑÐ¸ÑÑ, ÐºÐ¾Ð»Ð¸ ÑÐ¸Ð´Ð¸ÑÐµ!"},
                {"TPBuildingBlocked", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°ÑÐ¸ÑÑ, Ð¿ÐµÑÐµÐ±ÑÐ²Ð°ÑÑÐ¸ Ñ Ð·Ð¾Ð½Ñ Ð±Ð»Ð¾ÐºÑÐ²Ð°Ð½Ð½Ñ Ð±ÑÐ´ÑÐ²Ð½Ð¸ÑÑÐ²Ð°!"},
                {"TPAboveWater", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°ÑÐ¸ÑÑ, Ð¿ÐµÑÐµÐ±ÑÐ²Ð°ÑÑÐ¸ Ð½Ð°Ð´ Ð²Ð¾Ð´Ð¾Ñ!"},
                {"TPUnderWater", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°ÑÐ¸ÑÑ Ð¿ÑÐ´ Ð²Ð¾Ð´Ñ!"},
                {"TPTargetBuildingBlocked", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°ÑÐ¸ÑÑ Ð´Ð¾ Ð·Ð¾Ð½Ð¸, Ð´Ðµ Ð±Ð»Ð¾ÐºÐ¾Ð²Ð°Ð½Ð¾ Ð±ÑÐ´ÑÐ²Ð½Ð¸ÑÑÐ²Ð¾!"},
                {"TPTargetInsideBlock", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°ÑÐ¸ÑÑ Ñ ÑÑÐ½Ð´Ð°Ð¼ÐµÐ½Ñ!"},
                {"TPTargetInsideRock", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°ÑÐ¸ÑÑ Ñ ÑÐºÐµÐ»Ñ!"},
                {"TPSwimming", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°ÑÐ¸ÑÑ, Ð¿Ð¾ÐºÐ¸ Ð¿Ð»Ð¸Ð²ÐµÑÐµ!"},
                {"TPCargoShip", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°ÑÐ¸ÑÑ Ð· Ð²Ð°Ð½ÑÐ°Ð¶Ð½Ð¾Ð³Ð¾ ÐºÐ¾ÑÐ°Ð±Ð»Ñ!"},
                {"TPOilRig", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°ÑÐ¸ÑÑ Ð· Ð½Ð°ÑÑÐ¾Ð²Ð¾Ñ Ð²ÐµÐ¶Ñ!"},
                {"TPExcavator", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°ÑÐ¸ Ð· ÐµÐºÑÐºÐ°Ð²Ð°ÑÐ¾ÑÐ°!"},
                {"TPHotAirBalloon", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°ÑÐ¸ÑÑ Ð·, Ð°Ð±Ð¾ Ð½Ð° Ð¿Ð¾Ð²ÑÑÑÑÐ½Ñ ÐºÑÐ»Ñ!"},
                {"TPLift", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°ÑÐ¸ÑÑ, Ð¿ÐµÑÐµÐ±ÑÐ²Ð°ÑÑÐ¸ Ð² Ð»ÑÑÑÑ Ð°Ð±Ð¾ Ð¿ÑÐ´Ð¹Ð¾Ð¼Ð½Ð¸ÐºÑ!"},
                {"TPBucketLift", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°ÑÐ¸ÑÑ, Ð¿ÐµÑÐµÐ±ÑÐ²Ð°ÑÑÐ¸ Ð² ÐºÐ¾Ð²ÑÐ¾Ð²Ð¾Ð¼Ñ Ð¿ÑÐ´Ð¹Ð¾Ð¼Ð½Ð¸ÐºÑ!"},
                {"TPRegLift", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°ÑÐ¸ÑÑ, Ð¿ÐµÑÐµÐ±ÑÐ²Ð°ÑÑÐ¸ Ð² Ð»ÑÑÑÑ!"},
                {"TPSafeZone", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°ÑÐ¸ÑÑ ÑÐ· Ð±ÐµÐ·Ð¿ÐµÑÐ½Ð¾Ñ Ð·Ð¾Ð½Ð¸!"},
                {"TPFlagZone", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°ÑÐ¸ÑÑ ÑÐ· ÑÑÑÑ Ð·Ð¾Ð½Ð¸!"},
                {"TPNoEscapeBlocked", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°ÑÐ¸ÑÑ Ð¿Ð¾ÐºÐ¸ Ð°ÐºÑÐ¸Ð²Ð½Ðµ Ð±Ð»Ð¾ÐºÑÐ²Ð°Ð½Ð½Ñ!"},
                {"TPCrafting", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°ÑÐ¸ÑÑ Ñ Ð¿ÑÐ¾ÑÐµÑÑ ÐºÑÐ°ÑÑÑ!"},
                {"TPBlockedItem", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°ÑÐ¸ÑÑ Ð¿Ð¾ÐºÐ¸ ÑÐ¾ Ð½ÐµÑÐµÑÐµ: {0}!"},
                {"TooCloseToMon", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°ÑÐ¸ÑÑ ÑÐ°Ðº Ð±Ð»Ð¸Ð·ÑÐºÐ¾ Ð´Ð¾ {0}!"},
                {"TPHomeSafeZoneOnly", "ÐÐ¸ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°ÑÐ¸ÑÑ Ð´Ð¾Ð´Ð¾Ð¼Ñ Ð»Ð¸ÑÐµ Ð· Ð±ÐµÐ·Ð¿ÐµÑÐ½Ð¾Ñ Ð·Ð¾Ð½Ð¸!" },
                {"TooCloseToCave", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°ÑÐ¸ÑÑ ÑÐ°Ðº Ð±Ð»Ð¸Ð·ÑÐºÐ¾ Ð´Ð¾ Ð¿ÐµÑÐµÑÐ¸!"},
                {"HomeTooCloseToCave", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ Ð·Ð±ÐµÑÐµÐ³ÑÐ¸ ÑÐ¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ ÑÐº Ð±ÑÐ´Ð¸Ð½Ð¾Ðº ÑÐ°Ðº Ð±Ð»Ð¸Ð·ÑÐºÐ¾ Ð´Ð¾ Ð¿ÐµÑÐµÑÐ¸!"},
                {"HomeTooCloseToMon", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ Ð·Ð±ÐµÑÐµÐ³ÑÐ¸ ÑÐ¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ ÑÐº Ð±ÑÐ´Ð¸Ð½Ð¾Ðº ÑÐ°Ðº Ð±Ð»Ð¸Ð·ÑÐºÐ¾ Ð´Ð¾ Ð¿Ð°Ð¼'ÑÑÐ½Ð¸ÐºÐ°!"},
                {"CannotTeleportFromHome", "ÐÐ¸ Ð¿Ð¾Ð²Ð¸Ð½Ð½Ñ Ð²Ð¸Ð¹ÑÐ¸ Ð· Ð²Ð°ÑÐ¾Ñ Ð±Ð°Ð·Ð¸, Ð¿ÐµÑÑ Ð½ÑÐ¶ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°ÑÐ¸!"},
                {"WaitGlobalCooldown", "ÐÐ¸ Ð¿Ð¾Ð²Ð¸Ð½Ð½Ñ Ð¿Ð¾ÑÐµÐºÐ°ÑÐ¸, Ð¿Ð¾ÐºÐ¸ Ð²Ð°Ñ Ð³Ð»Ð¾Ð±Ð°Ð»ÑÐ½Ð¸Ð¹ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑ Ð¿ÐµÑÐµÐ·Ð°ÑÑÐ´Ð¶Ð°ÑÑÑÑÑ!" },

                {"DM_TownTP", "ÐÐ¸ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¾Ð²Ð°Ð½Ñ Ð² {0}!"},
                {"DM_TownTPNoLocation", "Ð Ð¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ <color=yellow>{0}</color> Ð½Ð° Ð´Ð°Ð½Ð¸Ð¹ Ð¼Ð¾Ð¼ÐµÐ½Ñ Ð½Ðµ Ð²ÑÑÐ°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¾!"},
                {"DM_TownTPDisabled", "<color=yellow>{0}</color> Ð² Ð´Ð°Ð½Ð¸Ð¹ Ð¼Ð¾Ð¼ÐµÐ½Ñ Ð²Ð¸Ð¼ÐºÐ½ÐµÐ½Ð¾ Ñ ÑÐ°Ð¹Ð»Ñ Ð½Ð°Ð»Ð°ÑÑÑÐ²Ð°Ð½Ñ!"},
                {"DM_TownTPLocation", "ÐÐ¸ Ð²ÑÑÐ°Ð½Ð¾Ð²Ð¸Ð»Ð¸ ÑÐ¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ <color=yellow>{0}</color> Ð² {1}!"},
                {"DM_TownTPCreated", "ÐÐ¸ ÑÑÐ²Ð¾ÑÐ¸Ð»Ð¸ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ: <color=yellow>{0}</color>"},
                {"DM_TownTPRemoved", "ÐÐ¸ Ð²Ð¸Ð´Ð°Ð»Ð¸Ð»Ð¸ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ: <color=yellow>{0}</color>"},
                {"DM_TownTPDoesNotExist", "ÐÐ¾Ð¼Ð°Ð½Ð´Ð° Ð½Ðµ ÑÑÐ½ÑÑ: <color=yellow>{0}</color>"},
                {"DM_TownTPExists", "ÐÐ¾Ð¼Ð°Ð½Ð´Ð° <color=yellow>{0}</color> Ð²Ð¶Ðµ ÑÑÐ½ÑÑ!"},
                {"DM_TownTPLocationsCleared", "ÐÐ¸ Ð¾ÑÐ¸ÑÑÐ¸Ð»Ð¸ Ð²ÑÑ Ð¼ÑÑÑÑ Ð´Ð»Ñ {0}!"},
                {"DM_TownTPStarted", "Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÑ Ð² {0} ÑÐµÑÐµÐ· {1} ÑÐµÐºÑÐ½Ð´!"},
                {"DM_TownTPCooldown", "ÐÐ°Ñ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑ Ð¿ÐµÑÐµÐ·Ð°ÑÑÐ´Ð¶Ð°ÑÑÑÑÑ. ÐÐ°Ð¼ Ð½ÐµÐ¾Ð±ÑÑÐ´Ð½Ð¾ Ð¿Ð¾ÑÐµÐºÐ°ÑÐ¸ {0} Ð´Ð¾ Ð½Ð°ÑÑÑÐ¿Ð½Ð¾Ñ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÑ."},
                {"DM_TownTPCooldownBypass", "ÐÐ°Ñ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑ Ð±ÑÐ² Ð½Ð° Ð¿ÐµÑÐµÐ·Ð°ÑÑÐ´Ð¶ÐµÐ½Ð½Ñ. ÐÐ¸ Ð¾Ð±ÑÐ°Ð»Ð¸ ÑÐ½Ð¸ÐºÐ½ÑÑÐ¸ Ð¾ÑÑÐºÑÐ²Ð°Ð½Ð½Ñ, ÑÐ¿Ð»Ð°ÑÐ¸Ð²ÑÐ¸ {0} Ð· Ð²Ð°ÑÐ¾Ð³Ð¾ Ð±Ð°Ð»Ð°Ð½ÑÑ."},
                {"DM_TownTPCooldownBypassF", "ÐÐ°Ñ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑ Ð¿ÐµÑÐµÐ·Ð°ÑÑÐ´Ð¶Ð°ÑÑÑÑÑ. Ð£ Ð²Ð°Ñ Ð½ÐµÐ´Ð¾ÑÑÐ°ÑÐ½ÑÐ¾ ÐºÐ¾ÑÑÑÐ² ({0}), ÑÐ¾Ð± ÑÐ½Ð¸ÐºÐ½ÑÑÐ¸ Ð¾ÑÑÐºÑÐ²Ð°Ð½Ð½Ñ."},
                {"DM_TownTPCooldownBypassP", "ÐÐ¸ Ð¼Ð¾Ð¶ÐµÑÐµ Ð²Ð¸Ð±ÑÐ°ÑÐ¸ Ð¾Ð¿Ð»Ð°ÑÐ¸ÑÐ¸ {0} ÑÐ¾Ð± ÑÐ½Ð¸ÐºÐ½ÑÑÐ¸ Ð¾ÑÑÐºÑÐ²Ð°Ð½Ð½Ñ Ð¿ÐµÑÐµÐ·Ð°ÑÑÐ´Ð¶Ð°Ð½Ð½Ñ." },
                {"DM_TownTPCooldownBypassP2", "ÐÐ²ÐµÐ´ÑÑÑ <color=yellow>/{0} {1}</color>" },
                {"DM_TownTPLimitReached", "ÐÐ¸ Ð²Ð¸ÑÐµÑÐ¿Ð°Ð»Ð¸ ÑÐ¾Ð´ÐµÐ½Ð½Ð¸Ð¹ Ð»ÑÐ¼ÑÑ {0} ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÐ¹ ÑÑÐ¾Ð³Ð¾Ð´Ð½Ñ! ÐÐ¸ Ð¿Ð¾Ð²Ð¸Ð½Ð½Ñ Ð¿Ð¾ÑÐµÐºÐ°ÑÐ¸ {1} Ð´Ð¾ Ð½Ð°ÑÑÑÐ¿Ð½Ð¾Ñ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÑ."},
                {"DM_TownTPAmount", "Ð£ Ð²Ð°Ñ Ð·Ð°Ð»Ð¸ÑÐ¸Ð»Ð¾ÑÑ {0} ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÐ¹ <color=yellow>{1}</color> ÑÑÐ¾Ð³Ð¾Ð´Ð½Ñ!"},

                {"Days", "Ð´Ð½ÑÐ²" },
                {"Hours", "Ð³Ð¾Ð´Ð¸Ð½" },
                {"Minutes", "ÑÐ²Ð¸Ð»Ð¸Ð½" },
                {"Seconds", "ÑÐµÐºÑÐ½Ð´" },

                {"Interrupted", "ÐÐ°ÑÑ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÑ Ð±ÑÐ»Ð¾ Ð¿ÐµÑÐµÑÐ²Ð°Ð½Ð¾!"},
                {"InterruptedTarget", "Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÑ {0} Ð±ÑÐ»Ð° Ð¿ÐµÑÐµÑÐ²Ð°Ð½Ð°!"},
                {"Unlimited", "ÐÐµ Ð¾Ð±Ð¼ÐµÐ¶ÐµÐ½Ð¾"},
                {
                    "TPInfoGeneral", string.Join(NewLine, new[]
                    {
                        "ÐÑÐ´Ñ Ð»Ð°ÑÐºÐ°, Ð²ÐºÐ°Ð¶ÑÑÑ Ð¼Ð¾Ð´ÑÐ»Ñ, Ð¿ÑÐ¾ ÑÐºÐ¸Ð¹ Ð²Ð¸ ÑÐ¾ÑÐµÑÐµ Ð¿ÐµÑÐµÐ³Ð»ÑÐ½ÑÑÐ¸ ÑÐ½ÑÐ¾ÑÐ¼Ð°ÑÑÑ.",
                        "ÐÐ¾ÑÑÑÐ¿Ð½Ñ Ð¼Ð¾Ð´ÑÐ»Ñ: ",
                    })
                },
                {
                    "TPHelpGeneral", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/tpinfo</color> - ÐÑÐ´Ð¾Ð±ÑÐ°Ð¶Ð°Ñ Ð»ÑÐ¼ÑÑÐ¸ ÑÐ° Ð¿ÐµÑÐµÐ·Ð°ÑÑÐ´Ð¶ÐµÐ½Ð½Ñ.",
                        "ÐÑÐ´Ñ Ð»Ð°ÑÐºÐ°, Ð²ÐºÐ°Ð¶ÑÑÑ Ð¼Ð¾Ð´ÑÐ»Ñ, Ð·Ð° ÑÐºÐ¸Ð¼ Ð²Ð¸ ÑÐ¾ÑÐµÑÐµ Ð¾ÑÑÐ¸Ð¼Ð°ÑÐ¸ Ð´Ð¾Ð¿Ð¾Ð¼Ð¾Ð³Ñ.",
                        "ÐÐ¾ÑÑÑÐ¿Ð½Ñ Ð¼Ð¾Ð´ÑÐ»Ñ: ",
                    })
                },
                {
                    "TPHelpadmintp", string.Join(NewLine, new[]
                    {
                        "Ð¯Ðº Ð°Ð´Ð¼ÑÐ½, Ð²Ð¸ Ð¼Ð°ÑÑÐµ Ð´Ð¾ÑÑÑÐ¿ Ð´Ð¾ Ð½Ð°ÑÑÑÐ¿Ð½Ð¸Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´:",
                        "<color=yellow>/tp \"ÑÐ¼'Ñ Ð³ÑÐ°Ð²ÑÑ\"</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÑÑ Ð²Ð°Ñ Ð´Ð¾ Ð²ÐºÐ°Ð·Ð°Ð½Ð¾Ð³Ð¾ Ð³ÑÐ°Ð²ÑÑ.",
                        "<color=yellow>/tp \"ÑÐ¼'Ñ Ð³ÑÐ°Ð²ÑÑ\" \"ÑÐ¼'Ñ Ð³ÑÐ°Ð²ÑÑ 2\"</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÑÑ Ð³ÑÐ°Ð²ÑÑ Ð· ÑÐ¼'ÑÐ¼ 'ÑÐ¼'Ñ Ð³ÑÐ°Ð²ÑÑ' Ð´Ð¾ Ð³ÑÐ°Ð²ÑÑ 'ÑÐ¼'Ñ Ð³ÑÐ°Ð²ÑÑ 2'.",
                        "<color=yellow>/tp x y z</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÑÑ Ð²Ð°Ñ Ð´Ð¾ Ð·Ð°Ð·Ð½Ð°ÑÐµÐ½Ð¸Ñ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°Ñ.",
                        "<color=yellow>/tpl</color> - ÐÑÐ´Ð¾Ð±ÑÐ°Ð¶Ð°Ñ ÑÐ¿Ð¸ÑÐ¾Ðº Ð·Ð±ÐµÑÐµÐ¶ÐµÐ½Ð¸Ñ Ð¿Ð¾Ð·Ð¸ÑÑÐ¹.",
                        "<color=yellow>/tpl \"Ð½Ð°Ð·Ð²Ð° ÑÐ¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ\"</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÑÑ Ð²Ð°Ñ Ñ Ð·Ð±ÐµÑÐµÐ¶ÐµÐ½Ðµ Ð¼ÑÑÑÐµÐ·Ð½Ð°ÑÐ¾Ð´Ð¶ÐµÐ½Ð½Ñ.",
                        "<color=yellow>/tpsave \"Ð½Ð°Ð·Ð²Ð° ÑÐ¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ\"</color> - ÐÐ±ÐµÑÑÐ³Ð°Ñ Ð²Ð°ÑÐµ Ð¿Ð¾ÑÐ¾ÑÐ½Ðµ ÑÐ¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ Ð· Ð²ÐºÐ°Ð·Ð°Ð½Ð¾Ñ Ð½Ð°Ð·Ð²Ð¾Ñ.",
                        "<color=yellow>/tpremove \"Ð½Ð°Ð·Ð²Ð° ÑÐ¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ\"</color> - ÐÐ¸Ð´Ð°Ð»ÑÑ ÑÐ¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ Ð·Ñ ÑÐ¿Ð¸ÑÐºÑ Ð·Ð±ÐµÑÐµÐ¶ÐµÐ½Ð¸Ñ.",
                        "<color=yellow>/tpb</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÑÑ Ð²Ð°Ñ Ð½Ð°Ð·Ð°Ð´ Ð½Ð° Ð¼ÑÑÑÐµ, Ð´Ðµ Ð²Ð¸ Ð±ÑÐ»Ð¸ Ð¿ÐµÑÐµÐ´ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÑÑ.",
                        "<color=yellow>/home radius \"ÑÐ°Ð´ÑÑÑ\"</color> - ÐÐ½Ð°Ð¹ÑÐ¸ Ð²ÑÑ Ð±ÑÐ´Ð¸Ð½ÐºÐ¸ Ð² ÑÐ°Ð´ÑÑÑÑ.",
                        "<color=yellow>/home delete \"ÑÐ¼'Ñ Ð³ÑÐ°Ð²ÑÑ Ð°Ð±Ð¾ ID\" \"Ð½Ð°Ð·Ð²Ð° Ð±ÑÐ´Ð¸Ð½ÐºÑ\"</color> - ÐÐ¸Ð´Ð°Ð»ÑÑ Ð±ÑÐ´Ð¸Ð½Ð¾Ðº ÑÐ· Ð²ÐºÐ°Ð·Ð°Ð½Ð¸Ð¼ ÑÐ¼'ÑÐ¼, ÑÐ¾ Ð½Ð°Ð»ÐµÐ¶Ð¸ÑÑ Ð²ÐºÐ°Ð·Ð°Ð½Ð¾Ð¼Ñ Ð³ÑÐ°Ð²ÑÑ.",
                        "<color=yellow>/home tp \"ÑÐ¼'Ñ Ð³ÑÐ°Ð²ÑÑ Ð°Ð±Ð¾ ID\" \"Ð½Ð°Ð·Ð²Ð° Ð±ÑÐ´Ð¸Ð½ÐºÑ\"</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÑÑ Ð²Ð°Ñ Ð´Ð¾ Ð±ÑÐ´Ð¸Ð½ÐºÑ Ð³ÑÐ°Ð²ÑÑ ÑÐ· Ð·Ð°Ð·Ð½Ð°ÑÐµÐ½Ð¾Ñ Ð½Ð°Ð·Ð²Ð¾Ñ, ÑÐ¾ Ð½Ð°Ð»ÐµÐ¶Ð¸ÑÑ Ð²ÐºÐ°Ð·Ð°Ð½Ð¾Ð¼Ñ Ð³ÑÐ°Ð²ÑÑ.",
                        "<color=yellow>/home homes \"ÑÐ¼'Ñ Ð³ÑÐ°Ð²ÑÑ Ð°Ð±Ð¾ ID\"</color> - ÐÑÐ´Ð¾Ð±ÑÐ°Ð¶Ð°Ñ ÑÐ¿Ð¸ÑÐ¾Ðº ÑÑÑÑ Ð±ÑÐ´Ð¸Ð½ÐºÑÐ², ÑÐ¾ Ð½Ð°Ð»ÐµÐ¶Ð°ÑÑ Ð·Ð°Ð·Ð½Ð°ÑÐµÐ½Ð¾Ð¼Ñ Ð³ÑÐ°Ð²ÑÐµÐ²Ñ."
                    })
                },
                {
                    "TPHelphome", string.Join(NewLine, new[]
                    {
                        "ÐÐ¸ÐºÐ¾ÑÐ¸ÑÑÐ¾Ð²ÑÑÑÐ¸ Ð½Ð°ÑÑÑÐ¿Ð½Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¸, Ð²Ð¸ Ð¼Ð¾Ð¶ÐµÑÐµ Ð²ÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÐ¸ Ð¼ÑÑÑÐµ ÑÐ¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ Ð²Ð°ÑÐ¾Ð³Ð¾ Ð±ÑÐ´Ð¸Ð½ÐºÑ, ÑÐ¾Ð± Ð¿Ð¾ÑÑÐ¼ Ð´Ð¾ Ð½ÑÐ¾Ð³Ð¾ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°ÑÐ¸ÑÑ:",
                        "<color=yellow>/home add \"Ð½Ð°Ð·Ð²Ð° Ð±ÑÐ´Ð¸Ð½ÐºÑ\"</color> - ÐÐ±ÐµÑÑÐ³Ð°Ñ Ð²Ð°ÑÐµ Ð¿Ð¾ÑÐ¾ÑÐ½Ðµ ÑÐ¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ ÑÐº Ð²Ð°Ñ Ð±ÑÐ´Ð¸Ð½Ð¾Ðº ÑÐ· Ð·Ð°Ð·Ð½Ð°ÑÐµÐ½Ð¾Ñ Ð½Ð°Ð·Ð²Ð¾Ñ.",
                        "<color=yellow>/home list</color> - ÐÑÐ´Ð¾Ð±ÑÐ°Ð¶Ð°Ñ ÑÐ¿Ð¸ÑÐ¾Ðº ÑÑÑÑ Ð¼ÑÑÑÑ ÑÐ¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ, Ð·Ð±ÐµÑÐµÐ¶ÐµÐ½Ð¸Ñ Ð²Ð°Ð¼Ð¸ ÑÐº Ð±ÑÐ´Ð¸Ð½Ð¾Ðº.",
                        "<color=yellow>/home remove \"Ð½Ð°Ð·Ð²Ð° Ð±ÑÐ´Ð¸Ð½ÐºÑ\"</color> - ÐÐ¸Ð´Ð°Ð»ÑÑ ÑÐ¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ Ð·Ð±ÐµÑÐµÐ¶ÐµÐ½Ð¾Ð³Ð¾ Ð±ÑÐ´Ð¸Ð½ÐºÑ Ð· Ð²ÐºÐ°Ð·Ð°Ð½Ð¾Ñ Ð½Ð°Ð·Ð²Ð¾Ñ.",
                        "<color=yellow>/home \"Ð½Ð°Ð·Ð²Ð° Ð±ÑÐ´Ð¸Ð½ÐºÑ\"</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÑÑ Ð²Ð°Ñ Ñ Ð¼ÑÑÑÐµÐ·Ð½Ð°ÑÐ¾Ð´Ð¶ÐµÐ½Ð½Ñ Ð±ÑÐ´Ð¸Ð½ÐºÑ Ð· Ð²ÐºÐ°Ð·Ð°Ð½Ð¾Ñ Ð½Ð°Ð·Ð²Ð¾Ñ."
                    })
                },
                {
                    "TPHelptpr", string.Join(NewLine, new[]
                    {
                        "ÐÐ¸ÐºÐ¾ÑÐ¸ÑÑÐ¾Ð²ÑÑÑÐ¸ ÑÑ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¸, Ð²Ð¸ Ð¼Ð¾Ð¶ÐµÑÐµ Ð½Ð°Ð´ÑÑÐ»Ð°ÑÐ¸ Ð·Ð°Ð¿Ð¸Ñ Ð½Ð° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÑ Ð´Ð¾ Ð³ÑÐ°Ð²ÑÑ Ð°Ð±Ð¾ Ð¿ÑÐ¸Ð¹Ð½ÑÑÐ¸ ÑÐ¸Ð¹ÑÑ Ð·Ð°Ð¿Ð¸Ñ:",
                        "<color=yellow>/tpr \"ÑÐ¼'Ñ Ð³ÑÐ°Ð²ÑÑ\"</color> - ÐÐ°Ð´ÑÐ¸Ð»Ð°Ñ Ð·Ð°Ð¿Ð¸Ñ Ð½Ð° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÑ Ð³ÑÐ°Ð²ÑÑ ÑÐ· Ð·Ð°Ð·Ð½Ð°ÑÐµÐ½Ð¸Ð¼ ÑÐ¼'ÑÐ¼.",
                        "<color=yellow>/tpa</color> - ÐÑÐ¸Ð¹Ð½ÑÑÐ¸ Ð·Ð°Ð¿Ð¸Ñ Ð½Ð° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÑ.",
                        "<color=yellow>/tpat</color> - Ð£Ð²ÑÐ¼Ðº./ÐÐ¸Ð¼Ðº. Ð°Ð²ÑÐ¾Ð¼Ð°ÑÐ¸ÑÐ½Ðµ Ð¿ÑÐ¸Ð¹Ð½ÑÑÑÑ Ð·Ð°Ð¿Ð¸ÑÑÐ² Ð½Ð° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÑ Ð´Ð¾ Ð²Ð°Ñ /tpa.",
                        "<color=yellow>/tpc</color> - Ð¡ÐºÐ°ÑÑÐ²Ð°ÑÐ¸ Ð·Ð°Ð¿Ð¸Ñ Ð½Ð° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÑ."
                    })
                },
                {
                    "TPSettingsGeneral", string.Join(NewLine, new[]
                    {
                        "ÐÑÐ´Ñ Ð»Ð°ÑÐºÐ°, Ð²ÐºÐ°Ð¶ÑÑÑ Ð¼Ð¾Ð´ÑÐ»Ñ, Ð½Ð°Ð»Ð°ÑÑÑÐ²Ð°Ð½Ð½Ñ ÑÐºÐ¾Ð³Ð¾ Ð¿Ð¾ÑÑÑÐ±Ð½Ð¾ Ð¿ÐµÑÐµÐ³Ð»ÑÐ½ÑÑÐ¸.",
                        "ÐÐ¾ÑÑÑÐ¿Ð½Ñ Ð¼Ð¾Ð´ÑÐ»Ñ:",
                    })
                },
                {
                    "TPSettingshome", string.Join(NewLine, new[]
                    {
                        "Ð¡Ð¸ÑÑÐµÐ¼Ð° Ð±ÑÐ´Ð¸Ð½ÐºÑÐ² Ð½Ð° Ð´Ð°Ð½Ð¸Ð¹ Ð¼Ð¾Ð¼ÐµÐ½Ñ Ð¼Ð°Ñ ÑÐ°ÐºÑ Ð²ÐºÐ»ÑÑÐµÐ½Ñ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¸:",
                        "Ð§Ð°Ñ Ð¼ÑÐ¶ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°Ð¼Ð¸: {0}",
                        "Ð©Ð¾Ð´ÐµÐ½Ð½Ð¸Ð¹ Ð»ÑÐ¼ÑÑ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÐ¹: {1}",
                        "ÐÑÐ»ÑÐºÑÑÑÑ Ð·Ð±ÐµÑÐµÐ¶ÐµÐ½Ð¸Ñ Ð±ÑÐ´Ð¸Ð½ÐºÑÐ²: {2}"
                    })
                },
                {
                    "TPSettingsbandit", string.Join(NewLine, new[]
                    {
                        "Ð¡Ð¸ÑÑÐµÐ¼Ð° Ð¢Ð°Ð±ÑÑ Ð±Ð°Ð½Ð´Ð¸ÑÑÐ² Ð½Ð°ÑÐ°Ð·Ñ Ð¼Ð°Ñ ÑÐ°ÐºÑ Ð²ÐºÐ»ÑÑÐµÐ½Ñ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¸:",
                        "Ð§Ð°Ñ Ð¼ÑÐ¶ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°Ð¼Ð¸: {0}",
                        "Ð©Ð¾Ð´ÐµÐ½Ð½Ð¸Ð¹ Ð»ÑÐ¼ÑÑ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÐ¹: {1}"
                    })
                },
                {
                    "TPSettingsoutpost", string.Join(NewLine, new[]
                    {
                        "Ð¡Ð¸ÑÑÐµÐ¼Ð° ÐÑÑÑÐ¾ NPC Ð² Ð´Ð°Ð½Ð¸Ð¹ Ð¼Ð¾Ð¼ÐµÐ½Ñ Ð¼Ð°Ñ Ð½Ð°ÑÑÑÐ¿Ð½Ñ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¸:",
                        "Ð§Ð°Ñ Ð¼ÑÐ¶ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°Ð¼Ð¸: {0}",
                        "Ð©Ð¾Ð´ÐµÐ½Ð½Ð¸Ð¹ Ð»ÑÐ¼ÑÑ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÐ¹: {1}"
                    })
                },
                {
                    "TPSettingstpr", string.Join(NewLine, new[]
                    {
                        "Ð¡Ð¸ÑÑÐµÐ¼Ð° TPR Ð² Ð´Ð°Ð½Ð¸Ð¹ Ð¼Ð¾Ð¼ÐµÐ½Ñ Ð¼Ð°Ñ Ð½Ð°ÑÑÑÐ¿Ð½Ñ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¸:",
                        "Ð§Ð°Ñ Ð¼ÑÐ¶ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°Ð¼Ð¸: {0}",
                        "Ð©Ð¾Ð´ÐµÐ½Ð½Ð¸Ð¹ Ð»ÑÐ¼ÑÑ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÐ¹: {1}"
                    })
                },
                {
                    "TPSettingstown", string.Join(NewLine, new[]
                    {
                        "Ð£ Ð¡Ð¸ÑÑÐµÐ¼Ñ ÐÑÑÑ Ð²ÐºÐ»ÑÑÐµÐ½Ñ ÑÐ°ÐºÑ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¸:",
                        "Ð§Ð°Ñ Ð¼ÑÐ¶ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°Ð¼Ð¸: {0}",
                        "Ð©Ð¾Ð´ÐµÐ½Ð½Ð¸Ð¹ Ð»ÑÐ¼ÑÑ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÐ¹: {1}"
                    })
                },
                {
                    "TPSettingsdynamic", string.Join(NewLine, new[]
                    {
                        "Ð£ ÑÐ¸ÑÑÐµÐ¼Ñ {0} Ð²ÐºÐ»ÑÑÐµÐ½Ñ ÑÐ°ÐºÑ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¸:",
                        "Ð§Ð°Ñ Ð¼ÑÐ¶ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°Ð¼Ð¸: {1}",
                        "Ð©Ð¾Ð´ÐµÐ½Ð½Ð¸Ð¹ Ð»ÑÐ¼ÑÑ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÐ¹: {2}"
                    })
                },
                
                {"TPT_True", "enabled"},
                {"TPT_False", "disabled"},
                {"TPT_clan", "{1} clan has been {0}."},
                {"TPT_friend", "{1} friend has been {0}."},
                {"TPT_team", "{1} team has been {0}."},
                {"NotValidTPT", "Not valid, player is not"},
                {"NotValidTPTFriend", " a friend!"},
                {"NotValidTPTTeam", " on your team!"},
                {"NotValidTPTClan", " in your clan!"},
												  
                {"TPTInfo", "{4} auto accepts teleport requests.\n<color={5}>Green</color> = <color={5}>Enabled</color>\n<color={6}>Red</color> = <color={6}>Disabled</color>\n\n/{0} <color={1}>clan</color> - Toggle {4} for clan members/allies.\n/{0} <color={2}>team</color> - Toggle {4} for teammates.\n/{0} <color={3}>friend</color> - Toggle {4} for friends."},
                				
                {"PlayerNotFound", "ÐÐºÐ°Ð·Ð°Ð½Ð¾Ð³Ð¾ Ð³ÑÐ°Ð²ÑÑ Ð½Ðµ Ð²Ð¸ÑÐ²Ð»ÐµÐ½Ð¾, Ð±ÑÐ´Ñ Ð»Ð°ÑÐºÐ°, ÑÐ¿ÑÐ¾Ð±ÑÐ¹ÑÐµ ÑÐµ ÑÐ°Ð·!"},
                {"MultiplePlayers", "ÐÐ½Ð°Ð¹Ð´ÐµÐ½Ð¾ Ð´ÐµÐºÑÐ»ÑÐºÐ° Ð³ÑÐ°Ð²ÑÑÐ²: {0}"},
                {"CantTeleportToSelf", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°ÑÐ¸ÑÑ Ð´Ð¾ ÑÐµÐ±Ðµ!"},
                {"CantTeleportPlayerToSelf", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°ÑÐ¸ Ð³ÑÐ°Ð²ÑÑ Ð´Ð¾ ÑÐµÐ±Ðµ!"},
                {"TeleportPendingTPC", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐ½ÑÑÑÑÐ²Ð°ÑÐ¸ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÑ, Ð¿Ð¾ÐºÐ¸ Ð²Ð¸ Ð¼Ð°ÑÑÐµ Ð°ÐºÑÐ¸Ð²Ð½Ð¸Ð¹ Ð·Ð°Ð¿Ð¸Ñ! ÐÐ¸ÐºÐ¾ÑÐ¸ÑÑÐ¾Ð²ÑÐ¹ÑÐµ <color=yellow>/tpc</color>, ÑÐ¾Ð± ÑÐºÐ°ÑÑÐ²Ð°ÑÐ¸ Ð¹Ð¾Ð³Ð¾."},
                {"TeleportPendingTarget", "ÐÐ¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ Ð½Ð°Ð´ÑÑÐ»Ð°ÑÐ¸ Ð·Ð°Ð¿Ð¸Ñ Ð´Ð¾ ÑÐ¾Ð³Ð¾, ÑÑÐ¾ Ð² Ð¿ÑÐ¾ÑÐµÑÑ ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÑ!"},
                {"LocationExists", "Ð Ð¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ Ð· ÑÐ°ÐºÐ¾Ñ Ð½Ð°Ð·Ð²Ð¾Ñ Ð²Ð¶Ðµ ÑÑÐ½ÑÑ Ð² {0}!"},
                {"LocationExistsNearby", "Ð Ð¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ Ð· Ð½Ð°Ð·Ð²Ð¾Ñ {0} Ð²Ð¶Ðµ ÑÑÐ½ÑÑ Ð¿Ð¾ÑÑÐ´ ÑÐ· Ð¿Ð¾ÑÐ¾ÑÐ½Ð¾Ñ Ð¿Ð¾Ð·Ð¸ÑÑÑÑ!"},
                {"LocationNotFound", "ÐÐµ Ð·Ð½Ð°Ð¹Ð´ÐµÐ½Ð¾ Ð¼ÑÑÑÐµÐ·Ð½Ð°ÑÐ¾Ð´Ð¶ÐµÐ½Ð½Ñ Ð· ÑÐ°ÐºÐ¾Ñ Ð½Ð°Ð·Ð²Ð¾Ñ!"},
                {"NoPreviousLocationSaved", "ÐÐ¾Ð¿ÐµÑÐµÐ´Ð½Ñ ÑÐ¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ Ð½Ðµ Ð·Ð±ÐµÑÐµÐ¶ÐµÐ½Ðµ!"},
                {"HomeExists", "ÐÐ¸ Ð²Ð¶Ðµ Ð·Ð±ÐµÑÐµÐ³Ð»Ð¸ Ð±ÑÐ´Ð¸Ð½Ð¾Ðº ÑÐ· ÑÐ°ÐºÐ¾Ñ Ð½Ð°Ð·Ð²Ð¾Ñ!"},
                {"HomeExistsNearby", "ÐÑÐ´Ð¸Ð½Ð¾Ðº Ð· Ð½Ð°Ð·Ð²Ð¾Ñ {0} Ð²Ð¶Ðµ ÑÑÐ½ÑÑ Ð¿Ð¾ÑÑÐ´ ÑÐ· Ð¿Ð¾ÑÐ¾ÑÐ½Ð¾Ñ Ð¿Ð¾Ð·Ð¸ÑÑÑÑ!"},
                {"HomeNotFound", "ÐÑÐ´Ð¸Ð½Ð¾Ðº Ð· ÑÐ°ÐºÐ¾Ñ Ð½Ð°Ð·Ð²Ð¾Ñ Ð½Ðµ Ð·Ð½Ð°Ð¹Ð´ÐµÐ½Ð¾!"},
                {"InvalidCoordinates", "ÐÐ¸ Ð²ÐºÐ°Ð·Ð°Ð»Ð¸ Ð½ÐµÐ¿ÑÐ°Ð²Ð¸Ð»ÑÐ½Ñ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÐ¸!"},
                {"InvalidHelpModule", "ÐÐºÐ°Ð·Ð°Ð½Ð¾ Ð½ÐµÐ¿ÑÐ°Ð²Ð¸Ð»ÑÐ½Ð¸Ð¹ Ð¼Ð¾Ð´ÑÐ»Ñ!"},
                {"InvalidCharacter", "ÐÐ¸ Ð²Ð¸ÐºÐ¾ÑÐ¸ÑÑÐ¾Ð²ÑÐ²Ð°Ð»Ð¸ Ð½ÐµÐ¿ÑÐ¸Ð¿ÑÑÑÐ¸Ð¼Ð¸Ð¹ ÑÐ¸Ð¼Ð²Ð¾Ð», Ð¾Ð±Ð¼ÐµÐ¶ÑÐµÑÑ Ð»ÑÑÐµÑÐ°Ð¼Ð¸ Ð²ÑÐ´ a Ð´Ð¾ z ÑÐ° ÑÐ¸ÑÑÐ°Ð¼Ð¸."},
                {
                    "SyntaxCommandTP", string.Join(NewLine, new[]
                    {
                        "Ð¡ÑÐ°Ð»Ð°ÑÑ ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐ½Ð° Ð¿Ð¾Ð¼Ð¸Ð»ÐºÐ°!",
                        "ÐÐ¸ÐºÐ¾ÑÐ¸ÑÑÐ°Ð½Ð½Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¸ <color=yellow>/tp</color> Ð¼Ð¾Ð¶Ð»Ð¸Ð²Ðµ Ð»Ð¸ÑÐµ ÑÐ°Ðº:",
                        "<color=yellow>/tp \"ÑÐ¼'Ñ Ð³ÑÐ°Ð²ÑÑ\"</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÑÑ Ð²Ð°Ñ Ð´Ð¾ Ð²ÐºÐ°Ð·Ð°Ð½Ð¾Ð³Ð¾ Ð³ÑÐ°Ð²ÑÑ.",
                        "<color=yellow>/tp \"ÑÐ¼'Ñ Ð³ÑÐ°Ð²ÑÑ\" \"ÑÐ¼'Ñ Ð³ÑÐ°Ð²ÑÑ 2\"</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÑÑ Ð³ÑÐ°Ð²ÑÑ Ð· ÑÐ¼'ÑÐ¼ 'ÑÐ¼'Ñ Ð³ÑÐ°Ð²ÑÑ' Ð´Ð¾ Ð³ÑÐ°Ð²ÑÑ 'ÑÐ¼'Ñ Ð³ÑÐ°Ð²ÑÑ 2'.",
                        "<color=yellow>/tp x y z</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÑÑ Ð²Ð°Ñ Ð´Ð¾ Ð·Ð°Ð·Ð½Ð°ÑÐµÐ½Ð¸Ñ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°Ñ.",
                        "<color=yellow>/tp \"ÑÐ¼'Ñ Ð³ÑÐ°Ð²ÑÑ\" x y z</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÑÑ Ð³ÑÐ°Ð²ÑÑ Ð· ÑÐ¼'ÑÐ¼ 'ÑÐ¼'Ñ Ð³ÑÐ°Ð²ÑÑ' Ð´Ð¾ Ð·Ð°Ð·Ð½Ð°ÑÐµÐ½Ð¸Ñ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°Ñ."
                    })
                },
                {
                    "SyntaxCommandTPL", string.Join(NewLine, new[]
                    {
                        "Ð¡ÑÐ°Ð»Ð°ÑÑ ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐ½Ð° Ð¿Ð¾Ð¼Ð¸Ð»ÐºÐ°!",
                        "ÐÐ¸ÐºÐ¾ÑÐ¸ÑÑÐ°Ð½Ð½Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¸ <color=yellow>/tpl</color> Ð¼Ð¾Ð¶Ð»Ð¸Ð²Ðµ Ð»Ð¸ÑÐµ ÑÐ°Ðº:",
                        "<color=yellow>/tpl</color> - ÐÑÐ´Ð¾Ð±ÑÐ°Ð¶Ð°Ñ ÑÐ¿Ð¸ÑÐ¾Ðº Ð·Ð±ÐµÑÐµÐ¶ÐµÐ½Ð¸Ñ Ð¿Ð¾Ð·Ð¸ÑÑÐ¹.",
                        "<color=yellow>/tpl \"Ð½Ð°Ð·Ð²Ð° ÑÐ¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ\"</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÑÑ Ð²Ð°Ñ Ñ Ð¼ÑÑÑÐµ ÑÐ· Ð·Ð°Ð·Ð½Ð°ÑÐµÐ½Ð¾Ñ Ð½Ð°Ð·Ð²Ð¾Ñ."
                    })
                },
                {
                    "SyntaxCommandTPSave", string.Join(NewLine, new[]
                    {
                        "Ð¡ÑÐ°Ð»Ð°ÑÑ ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐ½Ð° Ð¿Ð¾Ð¼Ð¸Ð»ÐºÐ°!",
                        "ÐÐ¸ÐºÐ¾ÑÐ¸ÑÑÐ°Ð½Ð½Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¸ <color=yellow>/tpsave</color> Ð¼Ð¾Ð¶Ð»Ð¸Ð²Ðµ Ð»Ð¸ÑÐµ ÑÐ°Ðº:",
                        "<color=yellow>/tpsave \"Ð½Ð°Ð·Ð²Ð° ÑÐ¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ\"</color> - ÐÐ±ÐµÑÑÐ³Ð°Ñ Ð²Ð°ÑÐµ Ð¿Ð¾ÑÐ¾ÑÐ½Ðµ ÑÐ¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ Ð· Ð²ÐºÐ°Ð·Ð°Ð½Ð¾Ñ Ð½Ð°Ð·Ð²Ð¾Ñ."
                    })
                },
                {
                    "SyntaxCommandTPRemove", string.Join(NewLine, new[]
                    {
                        "Ð¡ÑÐ°Ð»Ð°ÑÑ ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐ½Ð° Ð¿Ð¾Ð¼Ð¸Ð»ÐºÐ°!",
                        "ÐÐ¸ÐºÐ¾ÑÐ¸ÑÑÐ°Ð½Ð½Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¸ <color=yellow>/tpremove</color> Ð¼Ð¾Ð¶Ð»Ð¸Ð²Ðµ Ð»Ð¸ÑÐµ ÑÐ°Ðº:",
                        "<color=yellow>/tpremove \"Ð½Ð°Ð·Ð²Ð° ÑÐ¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ\"</color> - ÐÐ¸Ð´Ð°Ð»ÑÑ ÑÐ¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ Ð·Ð° Ð²ÐºÐ°Ð·Ð°Ð½Ð¾Ñ Ð½Ð°Ð·Ð²Ð¾Ñ."
                    })
                },
                {
                    "SyntaxCommandTPN", string.Join(NewLine, new[]
                    {
                        "Ð¡ÑÐ°Ð»Ð°ÑÑ ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐ½Ð° Ð¿Ð¾Ð¼Ð¸Ð»ÐºÐ°!",
                        "ÐÐ¸ÐºÐ¾ÑÐ¸ÑÑÐ°Ð½Ð½Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¸ <color=yellow>/tpn</color> Ð¼Ð¾Ð¶Ð»Ð¸Ð²Ðµ Ð»Ð¸ÑÐµ ÑÐ°Ðº:",
                        "<color=yellow>/tpn \"ÑÐ¼'Ñ Ð³ÑÐ°Ð²ÑÑ\"</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÑÑ Ð²Ð°Ñ Ð½Ð° Ð²ÑÐ´ÑÑÐ°Ð½Ñ Ð·Ð° Ð·Ð°Ð¼Ð¾Ð²ÑÑÐ²Ð°Ð½Ð½ÑÐ¼ Ð¿Ð¾Ð·Ð°Ð´Ñ Ð³ÑÐ°Ð²ÑÑ ÑÐ· Ð·Ð°Ð·Ð½Ð°ÑÐµÐ½Ð¸Ð¼ ÑÐ¼'ÑÐ¼.",
                        "<color=yellow>/tpn \"ÑÐ¼'Ñ Ð³ÑÐ°Ð²ÑÑ\" \"Ð²ÑÐ´ÑÑÐ°Ð½Ñ\"</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÑÑ Ð²Ð°Ñ Ð½Ð° Ð²ÐºÐ°Ð·Ð°Ð½Ñ Ð²ÑÐ´ÑÑÐ°Ð½Ñ Ð¿Ð¾Ð·Ð°Ð´Ñ Ð³ÑÐ°Ð²ÑÑ ÑÐ· Ð²ÐºÐ°Ð·Ð°Ð½Ð¸Ð¼ ÑÐ¼'ÑÐ¼."
                    })
                },
                {
                    "SyntaxCommandSetHome", string.Join(NewLine, new[]
                    {
                        "Ð¡ÑÐ°Ð»Ð°ÑÑ ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐ½Ð° Ð¿Ð¾Ð¼Ð¸Ð»ÐºÐ°!",
                        "ÐÐ¸ÐºÐ¾ÑÐ¸ÑÑÐ°Ð½Ð½Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¸ <color=yellow>/home add</color> Ð¼Ð¾Ð¶Ð»Ð¸Ð²Ðµ Ð»Ð¸ÑÐµ ÑÐ°Ðº:",
                        "<color=yellow>/home add \"Ð½Ð°Ð·Ð²Ð°\"</color> - ÐÐ±ÐµÑÑÐ³Ð°Ñ Ð²Ð°ÑÐµ Ð¿Ð¾ÑÐ¾ÑÐ½Ðµ ÑÐ¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ ÑÐº Ð²Ð°Ñ Ð±ÑÐ´Ð¸Ð½Ð¾Ðº ÑÐ· Ð·Ð°Ð·Ð½Ð°ÑÐµÐ½Ð¾Ñ Ð½Ð°Ð·Ð²Ð¾Ñ."
                    })
                },
                {
                    "SyntaxCommandRemoveHome", string.Join(NewLine, new[]
                    {
                        "Ð¡ÑÐ°Ð»Ð°ÑÑ ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐ½Ð° Ð¿Ð¾Ð¼Ð¸Ð»ÐºÐ°!",
                        "ÐÐ¸ÐºÐ¾ÑÐ¸ÑÑÐ°Ð½Ð½Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¸ <color=yellow>/home remove</color> Ð¼Ð¾Ð¶Ð»Ð¸Ð²Ðµ Ð»Ð¸ÑÐµ ÑÐ°Ðº:",
                        "<color=yellow>/home remove \"Ð½Ð°Ð·Ð²Ð°\"</color> - ÐÐ¸Ð´Ð°Ð»ÑÑ ÑÐ¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ Ð±ÑÐ´Ð¸Ð½ÐºÑ Ð· Ð²ÐºÐ°Ð·Ð°Ð½Ð¾Ñ Ð½Ð°Ð·Ð²Ð¾Ñ."
                    })
                },
                {
                    "SyntaxCommandHome", string.Join(NewLine, new[]
                    {
                        "Ð¡ÑÐ°Ð»Ð°ÑÑ ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐ½Ð° Ð¿Ð¾Ð¼Ð¸Ð»ÐºÐ°!",
                        "ÐÐ¸ÐºÐ¾ÑÐ¸ÑÑÐ°Ð½Ð½Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¸ <color=yellow>/home</color> Ð¼Ð¾Ð¶Ð»Ð¸Ð²Ðµ Ð»Ð¸ÑÐµ ÑÐ°Ðº:",
                        "<color=yellow>/home \"Ð½Ð°Ð·Ð²Ð°\"</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÑÑ Ð²Ð°Ñ Ñ Ð²Ð°Ñ Ð±ÑÐ´Ð¸Ð½Ð¾Ðº ÑÐ· Ð·Ð°Ð·Ð½Ð°ÑÐµÐ½Ð¾Ñ Ð½Ð°Ð·Ð²Ð¾Ñ.",
                        "<color=yellow>/home \"Ð½Ð°Ð·Ð²Ð°\" pay</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÑÑ Ð²Ð°Ñ Ñ Ð²Ð°Ñ Ð±ÑÐ´Ð¸Ð½Ð¾Ðº ÑÐ· Ð·Ð°Ð·Ð½Ð°ÑÐµÐ½Ð¾Ñ Ð½Ð°Ð·Ð²Ð¾Ñ, ÑÐ½Ð¸ÐºÐ°ÑÑÐ¸ Ð¿ÐµÑÐµÐ·Ð°ÑÑÐ´ÐºÐ¸, Ð·Ð°Ð¿Ð»Ð°ÑÐ¸Ð²ÑÐ¸ Ð·Ð° ÑÐµ.",
                        "<color=yellow>/home add \"Ð½Ð°Ð·Ð²Ð°\"</color> - ÐÐ±ÐµÑÑÐ³Ð°Ñ Ð²Ð°ÑÐµ Ð¿Ð¾ÑÐ¾ÑÐ½Ðµ ÑÐ¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ ÑÐº Ð²Ð°Ñ Ð±ÑÐ´Ð¸Ð½Ð¾Ðº ÑÐ· Ð·Ð°Ð·Ð½Ð°ÑÐµÐ½Ð¾Ñ Ð½Ð°Ð·Ð²Ð¾Ñ.",
                        "<color=yellow>/home list</color> - ÐÑÐ´Ð¾Ð±ÑÐ°Ð¶Ð°Ñ ÑÐ¿Ð¸ÑÐ¾Ðº ÑÑÑÑ Ð¼ÑÑÑÑ ÑÐ¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ, Ð·Ð±ÐµÑÐµÐ¶ÐµÐ½Ð¸Ñ Ð²Ð°Ð¼Ð¸ ÑÐº Ð±ÑÐ´Ð¸Ð½Ð¾Ðº.",
                        "<color=yellow>/home remove \"Ð½Ð°Ð·Ð²Ð°\"</color> - ÐÐ¸Ð´Ð°Ð»ÑÑ ÑÐ¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ Ð±ÑÐ´Ð¸Ð½ÐºÑ Ð· Ð²ÐºÐ°Ð·Ð°Ð½Ð¾Ñ Ð½Ð°Ð·Ð²Ð¾Ñ."
                    })
                },
                {
                    "SyntaxCommandHomeAdmin", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/home radius \"ÑÐ°Ð´ÑÑÑ\"</color> - ÐÑÐ´Ð¾Ð±ÑÐ°Ð¶Ð°Ñ ÑÐ¿Ð¸ÑÐ¾Ðº ÑÑÑÑ Ð±ÑÐ´Ð¸Ð½ÐºÑÐ² Ñ ÑÐ°Ð´ÑÑÑÑ(10).",
                        "<color=yellow>/home delete \"ÑÐ¼'Ñ Ð³ÑÐ°Ð²ÑÑ Ð°Ð±Ð¾ ID\" \"Ð½Ð°Ð·Ð²Ð°\"</color> - ÐÐ¸Ð´Ð°Ð»ÑÑ Ð±ÑÐ´Ð¸Ð½Ð¾Ðº ÑÐ· Ð·Ð°Ð·Ð½Ð°ÑÐµÐ½Ð¾Ñ Ð½Ð°Ð·Ð²Ð¾Ñ, ÑÐ¾ Ð½Ð°Ð»ÐµÐ¶Ð¸ÑÑ Ð²ÐºÐ°Ð·Ð°Ð½Ð¾Ð¼Ñ Ð³ÑÐ°Ð²ÑÑ.",
                        "<color=yellow>/home tp \"ÑÐ¼'Ñ Ð³ÑÐ°Ð²ÑÑ Ð°Ð±Ð¾ ID\" \"Ð½Ð°Ð·Ð²Ð°\"</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÑÑ Ð²Ð°Ñ Ð´Ð¾ Ð±ÑÐ´Ð¸Ð½ÐºÑ ÑÐ· Ð·Ð°Ð·Ð½Ð°ÑÐµÐ½Ð¾Ñ Ð½Ð°Ð·Ð²Ð¾Ñ, ÑÐ¾ Ð½Ð°Ð»ÐµÐ¶Ð¸ÑÑ Ð²ÐºÐ°Ð·Ð°Ð½Ð¾Ð¼Ñ Ð³ÑÐ°Ð²ÑÑ.",
                        "<color=yellow>/home homes \"ÑÐ¼'Ñ Ð³ÑÐ°Ð²ÑÑ Ð°Ð±Ð¾ ID\"</color> - ÐÑÐ´Ð¾Ð±ÑÐ°Ð¶Ð°Ñ ÑÐ¿Ð¸ÑÐ¾Ðº ÑÑÑÑ Ð±ÑÐ´Ð¸Ð½ÐºÑÐ², ÑÐ¾ Ð½Ð°Ð»ÐµÐ¶Ð°ÑÑ Ð²ÐºÐ°Ð·Ð°Ð½Ð¾Ð¼Ñ Ð³ÑÐ°Ð²ÑÑ."
                    })
                },
                {
                    "SyntaxCommandTown", string.Join(NewLine, new[]
                    {
                        "Ð¡ÑÐ°Ð»Ð°ÑÑ ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐ½Ð° Ð¿Ð¾Ð¼Ð¸Ð»ÐºÐ°!",
                        "ÐÐ¸ÐºÐ¾ÑÐ¸ÑÑÐ°Ð½Ð½Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¸ <color=yellow>/town</color> Ð¼Ð¾Ð¶Ð»Ð¸Ð²Ðµ Ð»Ð¸ÑÐµ ÑÐ°Ðº:",
                        "<color=yellow>/town</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÑÑ Ð²Ð°Ñ Ð´Ð¾ Ð¼ÑÑÑÐ°.",
                        "<color=yellow>/town pay</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÑÑ Ð²Ð°Ñ Ð´Ð¾ Ð¼ÑÑÑÐ° Ð· Ð¾Ð¿Ð»Ð°ÑÐ¾Ñ ÑÑÑÐ°ÑÑ."
                    })
                },
                {
                    "SyntaxCommandTownAdmin", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/town set</color> - ÐÐ±ÐµÑÑÐ³Ð°Ñ Ð¿Ð¾ÑÐ¾ÑÐ½Ðµ ÑÐ¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ ÑÐº ÐÑÑÑÐ¾.",
                    })
                },
                {
                    "SyntaxCommandOutpost", string.Join(NewLine, new[]
                    {
                        "Ð¡ÑÐ°Ð»Ð°ÑÑ ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐ½Ð° Ð¿Ð¾Ð¼Ð¸Ð»ÐºÐ°!",
                        "ÐÐ¸ÐºÐ¾ÑÐ¸ÑÑÐ°Ð½Ð½Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¸ <color=yellow>/outpost</color> Ð¼Ð¾Ð¶Ð»Ð¸Ð²Ðµ Ð»Ð¸ÑÐµ ÑÐ°Ðº:",
                        "<color=yellow>/outpost</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¸ÑÑÐµÑ Ð²Ð°Ñ Ð² ÐÐ¾ÑÐ¾Ð´ NPC.",
                        "<color=yellow>/outpost pay</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÑÑ Ð²Ð°Ñ Ñ ÐÑÑÑÐ¾ NPC Ð· Ð¾Ð¿Ð»Ð°ÑÐ¾Ñ ÑÑÑÐ°ÑÑ."
                    })
                },
                {
                    "SyntaxCommandOutpostAdmin", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/outpost set</color> - ÐÐ±ÐµÑÑÐ³Ð°Ñ Ð¿Ð¾ÑÐ¾ÑÐ½Ðµ ÑÐ¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ ÑÐº ÐÑÑÑÐ¾ NPC.",
                    })
                },
                {
                    "SyntaxCommandBandit", string.Join(NewLine, new[]
                    {
                        "Ð¡ÑÐ°Ð»Ð°ÑÑ ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐ½Ð° Ð¿Ð¾Ð¼Ð¸Ð»ÐºÐ°!",
                        "ÐÐ¸ÐºÐ¾ÑÐ¸ÑÑÐ°Ð½Ð½Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¸ <color=yellow>/bandit</color> Ð¼Ð¾Ð¶Ð»Ð¸Ð²Ðµ Ð»Ð¸ÑÐµ ÑÐ°Ðº:",
                        "<color=yellow>/bandit</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÑÑ Ð²Ð°Ñ Ð´Ð¾ Ð¢Ð°Ð±Ð¾ÑÑ Ð±Ð°Ð½Ð´Ð¸ÑÑÐ².",
                        "<color=yellow>/bandit pay</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÑÑ Ð²Ð°Ñ Ð´Ð¾ Ð¢Ð°Ð±Ð¾ÑÑ Ð±Ð°Ð½Ð´Ð¸ÑÑÐ² Ð· Ð¾Ð¿Ð»Ð°ÑÐ¾Ñ ÑÑÑÐ°ÑÑ."
                    })
                },
                {
                    "SyntaxCommandBanditAdmin", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/bandit set</color> - ÐÐ±ÐµÑÑÐ³Ð°Ñ Ð¿Ð¾ÑÐ¾ÑÐ½Ðµ ÑÐ¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ ÑÐº Ð¢Ð°Ð±ÑÑ Ð±Ð°Ð½Ð´Ð¸ÑÑÐ².",
                    })
                },
                {
                    "SyntaxCommandHomeDelete", string.Join(NewLine, new[]
                    {
                        "Ð¡ÑÐ°Ð»Ð°ÑÑ ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐ½Ð° Ð¿Ð¾Ð¼Ð¸Ð»ÐºÐ°!",
                        "ÐÐ¸ÐºÐ¾ÑÐ¸ÑÑÐ°Ð½Ð½Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¸ <color=yellow>/home delete</color> Ð¼Ð¾Ð¶Ð»Ð¸Ð²Ðµ Ð»Ð¸ÑÐµ ÑÐ°Ðº:",
                        "<color=yellow>/home delete \"ÑÐ¼'Ñ Ð³ÑÐ°Ð²ÑÑ Ð°Ð±Ð¾ ID\" \"Ð½Ð°Ð·Ð²Ð°\"</color> - ÐÐ¸Ð´Ð°Ð»ÑÑ Ð±ÑÐ´Ð¸Ð½Ð¾Ðº ÑÐ· Ð·Ð°Ð·Ð½Ð°ÑÐµÐ½Ð¾Ñ Ð½Ð°Ð·Ð²Ð¾Ñ, ÑÐ¾ Ð½Ð°Ð»ÐµÐ¶Ð¸ÑÑ Ð²ÐºÐ°Ð·Ð°Ð½Ð¾Ð¼Ñ Ð³ÑÐ°Ð²ÑÑ."
                    })
                },
                {
                    "SyntaxCommandHomeAdminTP", string.Join(NewLine, new[]
                    {
                        "Ð¡ÑÐ°Ð»Ð°ÑÑ ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐ½Ð° Ð¿Ð¾Ð¼Ð¸Ð»ÐºÐ°!",
                        "ÐÐ¸ÐºÐ¾ÑÐ¸ÑÑÐ°Ð½Ð½Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¸ <color=yellow>/home tp</color> Ð¼Ð¾Ð¶Ð»Ð¸Ð²Ðµ Ð»Ð¸ÑÐµ ÑÐ°Ðº:",
                        "<color=yellow>/home tp \"ÑÐ¼'Ñ Ð³ÑÐ°Ð²ÑÑ Ð°Ð±Ð¾ ID\" \"Ð½Ð°Ð·Ð²Ð°\"</color> - Ð¢ÐµÐ»ÐµÐ¿Ð¾ÑÑÑÑ Ð²Ð°Ñ Ð´Ð¾ Ð±ÑÐ´Ð¸Ð½ÐºÑ Ð³ÑÐ°Ð²ÑÑ ÑÐ· Ð·Ð°Ð·Ð½Ð°ÑÐµÐ½Ð¾Ñ Ð½Ð°Ð·Ð²Ð¾Ñ, ÑÐ¾ Ð½Ð°Ð»ÐµÐ¶Ð¸ÑÑ Ð²ÐºÐ°Ð·Ð°Ð½Ð¾Ð¼Ñ Ð³ÑÐ°Ð²ÑÑ."
                    })
                },
                {
                    "SyntaxCommandHomeHomes", string.Join(NewLine, new[]
                    {
                        "Ð¡ÑÐ°Ð»Ð°ÑÑ ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐ½Ð° Ð¿Ð¾Ð¼Ð¸Ð»ÐºÐ°!",
                        "ÐÐ¸ÐºÐ¾ÑÐ¸ÑÑÐ°Ð½Ð½Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¸ <color=yellow>/home homes</color> Ð¼Ð¾Ð¶Ð»Ð¸Ð²Ðµ Ð»Ð¸ÑÐµ ÑÐ°Ðº:",
                        "<color=yellow>/home homes \"ÑÐ¼'Ñ Ð³ÑÐ°Ð²ÑÑ Ð°Ð±Ð¾ ID\"</color> - ÐÑÐ´Ð¾Ð±ÑÐ°Ð¶Ð°Ñ ÑÐ¿Ð¸ÑÐ¾Ðº ÑÑÑÑ Ð±ÑÐ´Ð¸Ð½ÐºÑÐ², ÑÐ¾ Ð½Ð°Ð»ÐµÐ¶Ð°ÑÑ Ð²ÐºÐ°Ð·Ð°Ð½Ð¾Ð¼Ñ Ð³ÑÐ°Ð²ÑÑ."
                    })
                },
                {
                    "SyntaxCommandListHomes", string.Join(NewLine, new[]
                    {
                        "Ð¡ÑÐ°Ð»Ð°ÑÑ ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐ½Ð° Ð¿Ð¾Ð¼Ð¸Ð»ÐºÐ°!",
                        "ÐÐ¸ÐºÐ¾ÑÐ¸ÑÑÐ°Ð½Ð½Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¸ <color=yellow>/home list</color> Ð¼Ð¾Ð¶Ð»Ð¸Ð²Ðµ Ð»Ð¸ÑÐµ ÑÐ°Ðº:",
                        "<color=yellow>/home list</color> - ÐÑÐ´Ð¾Ð±ÑÐ°Ð¶Ð°Ñ ÑÐ¿Ð¸ÑÐ¾Ðº ÑÑÑÑ Ð¼ÑÑÑÑ ÑÐ¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ, Ð·Ð±ÐµÑÐµÐ¶ÐµÐ½Ð¸Ñ Ð²Ð°Ð¼Ð¸ ÑÐº Ð±ÑÐ´Ð¸Ð½Ð¾Ðº."
                    })
                },
                {
                    "SyntaxCommandTPR", string.Join(NewLine, new[]
                    {
                        "Ð¡ÑÐ°Ð»Ð°ÑÑ ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐ½Ð° Ð¿Ð¾Ð¼Ð¸Ð»ÐºÐ°!",
                        "ÐÐ¸ÐºÐ¾ÑÐ¸ÑÑÐ°Ð½Ð½Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¸ <color=yellow>/tpr</color> Ð¼Ð¾Ð¶Ð»Ð¸Ð²Ðµ Ð»Ð¸ÑÐµ ÑÐ°Ðº:",
                        "<color=yellow>/tpr \"ÑÐ¼'Ñ Ð³ÑÐ°Ð²ÑÑ Ð°Ð±Ð¾ ID\"</color> - ÐÐ°Ð´ÑÐ¸Ð»Ð°Ñ Ð²ÐºÐ°Ð·Ð°Ð½Ð¾Ð¼Ñ Ð³ÑÐ°Ð²ÑÐµÐ²Ñ Ð·Ð°Ð¿Ð¸Ñ Ð½Ð° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÑ."
                    })
                },
                {
                    "SyntaxCommandTPA", string.Join(NewLine, new[]
                    {
                        "ÐÑÐ´Ð±ÑÐ»Ð°ÑÑ ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐ½Ð° Ð¿Ð¾Ð¼Ð¸Ð»ÐºÐ°!",
                        "ÐÐ¸ÐºÐ¾ÑÐ¸ÑÑÐ°Ð½Ð½Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¸ <color=yellow>/tpa</color> Ð¼Ð¾Ð¶Ð»Ð¸Ð²Ðµ Ð»Ð¸ÑÐµ ÑÐ°ÐºÐ¸Ð¼ ÑÐ¸Ð½Ð¾Ð¼:",
                        "<color=yellow>/tpa</color> - ÐÑÐ¸Ð¹Ð½ÑÑÐ¸ Ð²ÑÑÐ´Ð½Ð¸Ð¹ Ð·Ð°Ð¿Ð¸Ñ Ð½Ð° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÑ."
                    })
                },
                {
                    "SyntaxCommandTPC", string.Join(NewLine, new[]
                    {
                        "ÐÑÐ´Ð±ÑÐ»Ð°ÑÑ ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐ½Ð° Ð¿Ð¾Ð¼Ð¸Ð»ÐºÐ°!",
                        "ÐÐ¸ÐºÐ¾ÑÐ¸ÑÑÐ°Ð½Ð½Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¸ <color=yellow>/tpc</color> Ð¼Ð¾Ð¶Ð»Ð¸Ð²Ðµ Ð»Ð¸ÑÐµ ÑÐ°ÐºÐ¸Ð¼ ÑÐ¸Ð½Ð¾Ð¼:",
                        "<color=yellow>/tpc</color> - Ð¡ÐºÐ°ÑÑÐ²Ð°ÑÐ¸ Ð·Ð°Ð¿Ð¸Ñ Ð½Ð° ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ°ÑÑÑ."
                    })
                },
                {
                    "SyntaxConsoleCommandToPos", string.Join(NewLine, new[]
                    {
                        "ÐÑÐ´Ð±ÑÐ»Ð°ÑÑ ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐ½Ð° Ð¿Ð¾Ð¼Ð¸Ð»ÐºÐ°!",
                        "ÐÐ¸ÐºÐ¾ÑÐ¸ÑÑÐ°Ð½Ð½Ñ ÐºÐ¾Ð½ÑÐ¾Ð»ÑÐ½Ð¾Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¸ <color=orange>teleport.topos</color> Ð¼Ð¾Ð¶Ð»Ð¸Ð²Ðµ Ð»Ð¸ÑÐµ ÑÐ°ÐºÐ¸Ð¼ ÑÐ¸Ð½Ð¾Ð¼:",
                        " > <color=orange>teleport.topos \"ÑÐ¼'Ñ Ð³ÑÐ°Ð²ÑÑ\" x y z</color>"
                    })
                },
                {
                    "SyntaxConsoleCommandToPlayer", string.Join(NewLine, new[]
                    {
                        "ÐÑÐ´Ð±ÑÐ»Ð°ÑÑ ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐ½Ð° Ð¿Ð¾Ð¼Ð¸Ð»ÐºÐ°!",
                        "ÐÐ¸ÐºÐ¾ÑÐ¸ÑÑÐ°Ð½Ð½Ñ ÐºÐ¾Ð½ÑÐ¾Ð»ÑÐ½Ð¾Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¸ <color=orange>teleport.toplayer</color> Ð¼Ð¾Ð¶Ð»Ð¸Ð²Ðµ Ð»Ð¸ÑÐµ ÑÐ°ÐºÐ¸Ð¼ ÑÐ¸Ð½Ð¾Ð¼:",
                        " > <color=orange>teleport.toplayer \"ÑÐ¼'Ñ Ð³ÑÐ°Ð²ÑÑ Ð°Ð±Ð¾ ID\" \"ÑÐ¼'Ñ Ð³ÑÐ°Ð²ÑÑ 2|id 2\"</color>"
                    })
                },
                {"LogTeleport", "{0} ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¾Ð²Ð°Ð½Ð¾ Ð´Ð¾ {1}."},
                {"LogTeleportPlayer", "{0} ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÑÐ²Ð°Ð² {1} Ð´Ð¾ {2}."},
                {"LogTeleportBack", "{0} ÑÐµÐ»ÐµÐ¿Ð¾ÑÑÐ¾Ð²Ð°Ð½Ð¸Ð¹ Ð½Ð°Ð·Ð°Ð´, Ð´Ð¾ Ð¿Ð¾Ð¿ÐµÑÐµÐ´Ð½ÑÐ¾Ð³Ð¾ ÑÐ¾Ð·ÑÐ°ÑÑÐ²Ð°Ð½Ð½Ñ."}
            };

            foreach (var key in config.DynamicCommands.Keys)
            {
                uk[key] = key;
            }

            foreach (var key in monumentMessages)
            {
                uk[key] = key;
            }

            lang.RegisterMessages(uk, this, "uk");
        }

        private void Init()
        {
            Unsubscribe(nameof(OnPlayerRespawn));
            Unsubscribe(nameof(OnPlayerViolation));
            Unsubscribe(nameof(OnEntityTakeDamage));
            Unsubscribe(nameof(OnPlayerSleepEnded));
            Unsubscribe(nameof(OnPlayerDisconnected));
            InitializeDynamicCommands();
        }

        private string OnPlayerConnected(BasePlayer player)
        {
            var uid = UnityEngine.Random.Range(1000, 9999).ToString();
            var names = BasePlayer.activePlayerList.Select(x => x.displayName);

            while (_ids.ContainsKey(uid) || names.Any(name => name.Contains(uid)))
            {
                uid = UnityEngine.Random.Range(1000, 9999).ToString();
            }

            _ids[uid] = player;
            _players[player] = uid;

            return uid;
        }

        private Dictionary<string, StoredData> _DynamicData = new Dictionary<string, StoredData>();

        public class StoredData
        {
            public Dictionary<ulong, TeleportData> TPData = new Dictionary<ulong, TeleportData>();
            public bool Changed = true;
        }

        private void LoadDataAndPerms()
        {
            dataAdmin = GetFile("Admin");
            try { _Admin = dataAdmin.ReadObject<Dictionary<ulong, AdminData>>(); } catch (Exception ex) { Puts("Admin datafile: {0}", ex); }
            if (_Admin == null) { _Admin = new Dictionary<ulong, AdminData>(); changedAdmin = true; }

            dataHome = GetFile("Home");
            try { _Home = dataHome.ReadObject<Dictionary<ulong, HomeData>>(); } catch (Exception ex) { Puts("Home datafile: {0}", ex); }
            if (_Home == null) { _Home = new Dictionary<ulong, HomeData>(); changedHome = true; }
            if (!config.Home.AllowTugboats) _Home.Values.ToList().ForEach(homeData => { if (homeData?.boats?.Count > 0) { homeData.boats.Clear(); changedHome = true; } });

            dataTPT = GetFile("TPT");
            try { TPT = dataTPT.ReadObject<Dictionary<string, List<string>>>(); } catch { }
            if (TPT == null) { new Dictionary<string, List<string>>(); changedTPT = true; }

            foreach (var entry in config.DynamicCommands)
            {
                if (!entry.Value.Enabled) continue;

                var dcf = GetFile(entry.Key);
                Dictionary<ulong, TeleportData> data = null;

                try
                {
                    data = dcf.ReadObject<Dictionary<ulong, TeleportData>>();
                }
                catch
                {

                }

                if (data == null)
                {
                    data = new Dictionary<ulong, TeleportData>();
                }

                GetSettings(entry.Key).Teleports = _DynamicData[entry.Key] = new StoredData
                {
                    TPData = data,
                    Changed = true
                };
            }

            dataTPR = GetFile("TPR");
            try { _TPR = dataTPR.ReadObject<Dictionary<ulong, TeleportData>>(); } catch (Exception ex) { Puts("TPR: {0}", ex); }
            if (_TPR == null) { _TPR = new Dictionary<ulong, TeleportData>(); changedTPR = true; }

            dataDisabled = GetFile("DisabledCommands");
            try { DisabledCommandData = dataDisabled.ReadObject<DisabledData>(); } catch (Exception ex) { Puts("DC: {0}", ex); }
            if (DisabledCommandData == null) { DisabledCommandData = new DisabledData(); }

            permission.RegisterPermission("nteleportation.locationradiusbypass", this);
            permission.RegisterPermission("nteleportation.ignoreglobalcooldown", this);
            permission.RegisterPermission("nteleportation.norestrictions", this);
            permission.RegisterPermission("nteleportation.globalcooldownvip", this);
            permission.RegisterPermission("nteleportation.tugboatsinterruptbypass", this);
            permission.RegisterPermission("nteleportation.tugboatssethomebypass", this);
            permission.RegisterPermission(PermAdmin, this);
            permission.RegisterPermission(PermFoundationCheck, this);
            permission.RegisterPermission(PermDeleteHome, this);
            permission.RegisterPermission(PermHome, this);
            permission.RegisterPermission(PermHomeHomes, this);
            permission.RegisterPermission(PermImportHomes, this);
            permission.RegisterPermission(PermRadiusHome, this);
            permission.RegisterPermission(PermDisallowTpToMe, this);
            permission.RegisterPermission(PermTp, this);
            permission.RegisterPermission(PermTpB, this);
            permission.RegisterPermission(PermTpR, this);
            permission.RegisterPermission(PermTpConsole, this);
            permission.RegisterPermission(PermTpT, this);
            permission.RegisterPermission(PermTpN, this);
            permission.RegisterPermission(PermTpL, this);
            permission.RegisterPermission(PermTpRemove, this);
            permission.RegisterPermission(PermTpSave, this);
            permission.RegisterPermission(PermWipeHomes, this);
            permission.RegisterPermission(PermCraftHome, this);
            permission.RegisterPermission(PermCraftTpR, this);
            permission.RegisterPermission(PermExempt, this);
            permission.RegisterPermission(PermTpMarker, this);

            CheckPerms(config.Home.VIPCooldowns);
            CheckPerms(config.Home.VIPCountdowns);
            CheckPerms(config.Home.VIPDailyLimits);
            CheckPerms(config.Home.VIPHomesLimits);
            CheckPerms(config.TPR.VIPCooldowns);
            CheckPerms(config.TPR.VIPCountdowns);
            CheckPerms(config.TPR.VIPDailyLimits);
            CheckPerms(config.Settings.TPB.Countdowns);

            foreach (var entry in config.DynamicCommands)
            {
                RegisterCommand(entry.Key, entry.Value, false);
            }
        }

        private bool CanBypassRestrictions(string userid) => permission.UserHasPermission(userid, "nteleportation.norestrictions");

        private void RegisterCommand(string command, string callback, string perm = null)
        {
            if (!string.IsNullOrEmpty(command) && !command.Equals("null", StringComparison.OrdinalIgnoreCase))
            {
                AddCovalenceCommand(command, callback, perm);
            }
        }

        private void UnregisterCommand(string command)
        {
            covalence.UnregisterCommand(command, this);
        }

        private void RegisterCommand(string key, TownSettings settings, bool justCreated)
        {
            CheckPerms(settings.VIPCooldowns);
            CheckPerms(settings.VIPCountdowns);
            CheckPerms(settings.VIPDailyLimits);

            string tpPerm = $"{Name}.tp{key}".ToLower();
            string craftPerm = $"{Name}.craft{key}".ToLower();

            if (!permission.PermissionExists(tpPerm, this))
            {
                permission.RegisterPermission(tpPerm, this);
            }

            if (!permission.PermissionExists(craftPerm))
            {
                permission.RegisterPermission(craftPerm, this);
            }

            if (justCreated)
            {
                settings.Teleports = _DynamicData[key] = new StoredData();
            }
        }

        private DynamicConfigFile GetFile(string name)
        {
            var fileName = string.IsNullOrEmpty(config.Settings.DataFileFolder) ? $"{Name}{name}" : $"{config.Settings.DataFileFolder}{Path.DirectorySeparatorChar}{name}";
            var file = Interface.Oxide.DataFileSystem.GetFile(fileName);
            file.Settings.ReferenceLoopHandling = ReferenceLoopHandling.Ignore;
            file.Settings.Converters = new JsonConverter[] { new UnityVector3Converter(), new CustomComparerDictionaryCreationConverter<string>(StringComparer.OrdinalIgnoreCase) };
            return file;
        }

        private void SetGlobalCooldown(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, "nteleportation.ignoreglobalcooldown"))
            {
                return;
            }
            if (config.Settings.GlobalVIP > 0f && permission.UserHasPermission(player.UserIDString, "nteleportation.globalcooldownvip"))
            {
                ulong userid = player.userID;
                TeleportCooldowns[userid] = Time.time + config.Settings.GlobalVIP;
                timer.Once(config.Settings.GlobalVIP, () => TeleportCooldowns.Remove(userid));
            }
            else if (config.Settings.Global > 0f)
            {
                ulong userid = player.userID;
                TeleportCooldowns[userid] = Time.time + config.Settings.Global;
                timer.Once(config.Settings.Global, () => TeleportCooldowns.Remove(userid));
            }
        }

        private float GetGlobalCooldown(BasePlayer player)
        {
            float cooldown;
            if (!TeleportCooldowns.TryGetValue(player.userID, out cooldown))
            {
                return 0f;
            }

            return cooldown - Time.time;
        }

        private bool IsEmptyMap()
        {
            foreach (var b in BuildingManager.server.buildingDictionary)
            {
                if (b.Value.HasDecayEntities() && b.Value.decayEntities.ToList().Exists(de => de != null && de.OwnerID.IsSteamId()))
                {
                    return false;
                }
            }
            return true;
        }

        private void CheckNewSave()
        {
            if (!newSave && !IsEmptyMap())
            {
                return;
            }

            bool changed = false;
            bool cleared = false;

            if (config.Settings.WipeOnUpgradeOrChange)
            {
                if (_Home.Count > 0)
                {
                    cleared = true;
                    _Home.Clear();
                    changedHome = true;
                }

                if (_TPR.Count > 0)
                {
                    cleared = true;
                    _TPR.Clear();
                    changedTPR = true;
                }

                foreach (var entry in config.DynamicCommands.ToList())
                {
                    if (entry.Value.Location != Vector3.zero || entry.Value.Locations.Count > 0)
                    {
                        entry.Value.Location = Vector3.zero;
                        entry.Value.Locations.Clear();
                        cleared = true;
                    }
                }

                if (cleared) Puts("Rust was upgraded or map changed - clearing homes and all locations!");
            }
            else
            {
                Puts("Rust was upgraded or map changed - homes, town, islands, outpost, bandit, etc may be invalid!");
            }

            foreach (var entry in config.DynamicCommands.ToList())
            {
                if (!string.IsNullOrEmpty(entry.Value.MonumentMarkerName))
                {
                    if (TrySetNewTownPosition(entry.Value))
                    {
                        changed = true;
                    }
                }
            }

            if (cleared || changed)
            {
                SaveConfig();
            }
        }

        bool TrySetNewTownPosition(TownSettings town)
        {
            foreach (var prefab in World.Serialization.world.prefabs)
            {
                if (prefab.id == 1724395471 && prefab.category == town.MonumentMarkerName)
                {
                    var pos = new Vector3(prefab.position.x, prefab.position.y, prefab.position.z);
                    try { pos += town.MonumentMarkerNameOffset.ToVector3(); } catch { }
                    if (pos.y < TerrainMeta.HeightMap.GetHeight(pos))
                    {
                        Puts("Invalid position set under the map for {0} {1}", prefab.category, pos);
                        Puts("You can specify an offset in the config to correct this:");
                        Puts("Set Position From Monument Marker Name Offset");
                        Puts("e.g: 0 15 0");
                        return false;
                    }
                    else
                    {
                        Puts($"Set {prefab.category} teleport position to: {pos}");
                        town.Locations.Clear();
                        town.Location = pos;
                        town.Locations.Add(pos);
                        return true;
                    }
                }
            }
            return false;
        }

        void OnServerInitialized()
        {
            if (config.Settings.Interrupt.Hurt || config.Settings.Interrupt.Cold || config.Settings.Interrupt.Hot)
            {
                Subscribe(nameof(OnEntityTakeDamage));
            }

            if (config.Settings.RespawnOutpost)
            {
                Subscribe(nameof(OnPlayerRespawn));
            }

            Subscribe(nameof(OnPlayerSleepEnded));
            Subscribe(nameof(OnPlayerDisconnected));

            boundary = TerrainMeta.Size.x / 2;

            foreach (var item in config.Settings.BlockedItems)
            {
                var definition = ItemManager.FindItemDefinition(item.Key);
                if (definition == null)
                {
                    Puts("Blocked item not found: {0}", item.Key);
                    continue;
                }
                ReverseBlockedItems[definition.itemid] = item.Value;
            }

            LoadDataAndPerms();
            CheckNewSave();
            AddCovalenceCommands();
            foreach (var player in BasePlayer.activePlayerList) OnPlayerConnected(player);
            _cmc = ServerMgr.Instance.StartCoroutine(SetupMonuments());
        }

        private void AddCovalenceCommands()
        {
            if (config.Settings.TPREnabled)
            {
                AddCovalenceCommand("tpr", nameof(CommandTeleportRequest));
            }
            if (config.Settings.HomesEnabled)
            {
                AddCovalenceCommand("home", nameof(CommandHome));
                AddCovalenceCommand("sethome", nameof(CommandSetHome));
                AddCovalenceCommand("listhomes", nameof(CommandListHomes));
                AddCovalenceCommand("removehome", nameof(CommandRemoveHome));
                AddCovalenceCommand("radiushome", nameof(CommandHomeRadius));
                AddCovalenceCommand("deletehome", nameof(CommandHomeDelete));
                AddCovalenceCommand("tphome", nameof(CommandHomeAdminTP));
                AddCovalenceCommand("homehomes", nameof(CommandHomeHomes));
            }
            AddCovalenceCommand("tnt", nameof(CommandToggle));
            AddCovalenceCommand("tp", nameof(CommandTeleport));
            AddCovalenceCommand("tpn", nameof(CommandTeleportNear));
            AddCovalenceCommand("tpl", nameof(CommandTeleportLocation));
            AddCovalenceCommand("tpsave", nameof(CommandSaveTeleportLocation));
            AddCovalenceCommand("tpremove", nameof(CommandRemoveTeleportLocation));
            AddCovalenceCommand("tpb", nameof(CommandTeleportBack));
            AddCovalenceCommand("tpa", nameof(CommandTeleportAccept));
            AddCovalenceCommand("tpat", nameof(CommandTeleportAcceptToggle));
            AddCovalenceCommand("tpt", nameof(CommandTeleportAcceptToggle));
            AddCovalenceCommand("atp", nameof(CommandTeleportAcceptToggle));
            AddCovalenceCommand("wipehomes", nameof(CommandWipeHomes));
            AddCovalenceCommand("tphelp", nameof(CommandTeleportHelp));
            AddCovalenceCommand("tpinfo", nameof(CommandTeleportInfo));
            AddCovalenceCommand("tpc", nameof(CommandTeleportCancel));
            AddCovalenceCommand("teleport.toplayer", nameof(CommandTeleportII));
            AddCovalenceCommand("teleport.topos", nameof(CommandTeleportII));
            AddCovalenceCommand("teleport.importhomes", nameof(CommandImportHomes));
            AddCovalenceCommand("spm", nameof(CommandSphereMonuments));
            AddCovalenceCommand("nteleportationinfo", nameof(CommandPluginInfo));
        }

        void OnNewSave(string strFilename)
        {
            newSave = true;
        }

        void OnServerSave()
        {
            if (config.Settings.SaveDelay > 0)
            {
                timer.Once((float)config.Settings.SaveDelay, SaveAllInstant);
            }
            else
            {
                SaveAllInstant();
            }
        }

        void SaveAllInstant()
        {
            SaveTeleportsAdmin();
            SaveTeleportsHome();
            SaveTeleportsTPR();
            SaveTeleportsTPT();
            SaveTeleportsTown();
        }

        void OnServerShutdown() => SaveAllInstant();

        void Unload()
        {
            SaveAllInstant();
            foreach (BasePlayer current in BasePlayer.activePlayerList)
            {
                DestroyTeleportRequestCUI(current);
            }
            if (_cmc != null)
            {
                ServerMgr.Instance.StopCoroutine(_cmc);
                _cmc = null;
            }
        }

        void OnEntityTakeDamage(BasePlayer player, HitInfo hitInfo)
        {
            if (player == null || player.IsNpc || !player.userID.IsSteamId() || hitInfo == null) return;
            if (hitInfo.damageTypes.Has(DamageType.Fall) && teleporting.ContainsKey(player.userID))
            {
                hitInfo.damageTypes = new DamageTypeList();
                RemoveProtections(player.userID);
                if (teleporting.Count == 0) Unsubscribe(nameof(OnPlayerViolation));
                return;
            }
            if (hitInfo.damageTypes.Has(DamageType.Suicide) && insideTerrainViolations.Contains(player.userID))
            {
                hitInfo.damageTypes = new DamageTypeList();
                return;
            }
            if (permission.UserHasPermission(player.userID.ToString(), PermExempt)) return;
            TeleportTimer teleportTimer;
            if (!TeleportTimers.TryGetValue(player.userID, out teleportTimer)) return;
            DamageType major = hitInfo.damageTypes.GetMajorityDamageType();

            NextTick(() =>
            {
                if (!player || !hitInfo.hasDamage) return;
                if (major == DamageType.Cold)
                {
                    if (config.Settings.Interrupt.Cold && player.metabolism.temperature.value <= config.Settings.MinimumTemp)
                    {
                        SendInterruptMessage(teleportTimer, player, "TPTooCold");
                    }
                }
                else if (major == DamageType.Heat)
                {
                    if (config.Settings.Interrupt.Hot && player.metabolism.temperature.value >= config.Settings.MaximumTemp)
                    {
                        SendInterruptMessage(teleportTimer, player, "TPTooHot");
                    }
                }
                else if (config.Settings.Interrupt.Hurt)
                {
                    SendInterruptMessage(teleportTimer, player, "Interrupted");
                }
            });
        }

        private void SendInterruptMessage(TeleportTimer teleportTimer, BasePlayer player, string key)
        {
            PrintMsgL(teleportTimer.OriginPlayer, key);
            if (teleportTimer.TargetPlayer != null)
            {
                PrintMsgL(teleportTimer.TargetPlayer, "InterruptedTarget", teleportTimer.OriginPlayer?.displayName);
            }
            teleportTimer.Timer.Destroy();
            TeleportTimers.Remove(player.userID);
        }

        private List<ulong> insideTerrainViolations = new List<ulong>();

        object OnPlayerViolation(BasePlayer player, AntiHackType type, float amount)
        {
            if (type == AntiHackType.InsideTerrain && teleporting.ContainsKey(player.userID))
            {
                if (!insideTerrainViolations.Contains(player.userID))
                {
                    insideTerrainViolations.Add(player.userID);
                }
                return false;
            }

            return null;
        }

        void OnPlayerSleepEnded(BasePlayer player)
        {
            if (!player || !teleporting.ContainsKey(player.userID)) return;
            ulong userID = player.userID;
            timer.Once(3f, () =>
            {
                RemoveProtections(userID);
                if (teleporting.Count == 0) Unsubscribe(nameof(OnPlayerViolation));
            });
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            if (!player) return;
            Timer reqTimer;
            if (PendingRequests.TryGetValue(player.userID, out reqTimer))
            {
                var originPlayer = PlayersRequests[player.userID];
                if (originPlayer)
                {
                    PlayersRequests.Remove(originPlayer.userID);
                    PrintMsgL(originPlayer, "RequestTargetOff");
                }
                reqTimer.Destroy();
                PendingRequests.Remove(player.userID);
                PlayersRequests.Remove(player.userID);
            }
            TeleportTimer teleportTimer;
            if (TeleportTimers.TryGetValue(player.userID, out teleportTimer))
            {
                teleportTimer.Timer.Destroy();
                TeleportTimers.Remove(player.userID);
            }
            RemoveProtections(player.userID);
        }

        private void SaveTeleportsAdmin()
        {
            if (_Admin == null || !changedAdmin) return;
            dataAdmin.WriteObject(_Admin);
            changedAdmin = false;
        }

        private void SaveTeleportsHome()
        {
            if (_Home == null || !changedHome) return;
            dataHome.WriteObject(_Home);
            changedHome = false;
        }

        private void SaveTeleportsTPR()
        {
            if (_TPR == null || !changedTPR) return;
            dataTPR.WriteObject(_TPR);
            changedTPR = false;
        }

        private void SaveTeleportsTPT()
        {
            if (TPT == null || !changedTPT) return;
            dataTPT.WriteObject(TPT);
            changedTPT = false;
        }

        private void SaveTeleportsTown()
        {
            foreach (var entry in _DynamicData.ToList())
            {
                if (entry.Value.Changed)
                {
                    var fileName = string.IsNullOrEmpty(config.Settings.DataFileFolder) ? $"{Name}{entry.Key}" : $"{config.Settings.DataFileFolder}{Path.DirectorySeparatorChar}{entry.Key}";
                    Interface.Oxide.DataFileSystem.WriteObject(fileName, entry.Value.TPData);
                    entry.Value.Changed = false;
                }
            }
        }

        private void SaveLocation(BasePlayer player, Vector3 position, bool build = true, bool craft = true)
        {
            if (player == null || _Admin == null || !IsAllowed(player, PermTpB)) return;
            AdminData adminData;
            if (!_Admin.TryGetValue(player.userID, out adminData) || adminData == null)
                _Admin[player.userID] = adminData = new AdminData();
            adminData.PreviousLocation = position;
            adminData.BuildingBlocked = build;
            adminData.AllowCrafting = craft;
            changedAdmin = true;
            PrintMsgL(player, "AdminTPBackSave");
        }

        private void RemoveLocation(BasePlayer player)
        {
            AdminData adminData;
            if (!_Admin.TryGetValue(player.userID, out adminData))
                return;
            adminData.PreviousLocation = Vector3.zero;
            changedAdmin = true;
        }

        private Coroutine _cmc;
        private bool _cmcCompleted;

        private IEnumerator SetupMonuments()
        {
            int checks = 0;
            foreach (var prefab in World.Serialization.world.prefabs)
            {
                if (prefab.id == 1724395471 && prefab.category != "IGNORE_MONUMENT")
                {
                    yield return CalculateMonumentSize(null, new Vector3(prefab.position.x, prefab.position.y, prefab.position.z), prefab.category, "monument_marker");
                }
                if (++checks >= 1000)
                {
                    yield return CoroutineEx.waitForSeconds(0.0025f);
                    checks = 0;
                }
            }
            foreach (var monument in UnityEngine.Object.FindObjectsOfType<MonumentInfo>())
            {
                if (monument.name.Contains("monument_marker"))
                {
                    foreach (var m in monuments)
                    {
                        if (m.monument == null && monument.transform.position == m.position)
                        {
                            m.monument = monument;
                            break;
                        }
                    }
                    continue;
                }
                var monPos = monument.transform.position;
                var name = monument.displayPhrase.english.TrimEnd();
                if (string.IsNullOrEmpty(name))
                {
                    if (monument.name.Contains("cave"))
                    {
                        name = monument.name.Contains("cave_small") ? "Small Cave" : monument.name.Contains("cave_medium") ? "Medium Cave" : "Large Cave";
                    }
                    else name = monument.name;
                }
                if (name.Contains("/"))
                {
                    name = monument.name.Substring(monument.name.LastIndexOf("/") + 1).Replace(".prefab", "");
                }
                if (monument.name.Contains("cave"))
                {
                    name += UnityEngine.Random.Range(1000, 9999);
#if DEBUG
                    Puts($"Adding Cave: {name}, pos: {monPos}");
#endif
                    caves[name] = monPos;
                }
                else if (config.Settings.Outpost.Exists(monument.name.Contains))
                {
                    yield return SetupOutpost(monument);
                }
                else if (config.Settings.Bandit.Exists(monument.name.Contains))
                {
                    yield return SetupBandit(monument);
                }
                else if (monument.Bounds.extents.Max() > 0f)
                {
                    var dist = monument.Bounds.extents.Max() + config.Admin.ExtraMonumentDistance;
#if DEBUG
                    Puts($"Adding Monument: {name}, pos: {monPos}, size: {dist}");
#endif
                    monuments.Add(new MonumentInfoEx(monument, monument.transform.position, dist, monument.displayPhrase.english.Trim(), monument.name));
                }
                else yield return CalculateMonumentSize(monument, monument.transform.position, string.IsNullOrEmpty(monument.displayPhrase.english.Trim()) ? monument.name : monument.displayPhrase.english.Trim(), monument.name);
            }
            _cmcCompleted = true;
            _cmc = null;
        }

        private IEnumerator SetupOutpost(MonumentInfo monument)
        {
            var outpost = GetSettings("outpost");

            if (outpost == null)
            {
                outpostEnabled = false;
                yield break;
            }

            if (config.Settings.AutoGenOutpost && outpost.Location != Vector3.zero && outpost.Locations.Exists(a => OutOfRange(monument, a, config.Settings.AutoGenOutpost)))
            {
#if DEBUG
                Puts("Invalid Outpost location detected");
#endif
                outpost.Location = Vector3.zero;
                outpost.Locations = new List<Vector3>();
            }
            if (config.Settings.AutoGenOutpost && outpost.Location == Vector3.zero)
            {
#if DEBUG
                Puts("  Looking for Outpost target");
#endif
                bool changedOutpost = false;
                var ents = Pool.GetList<BaseEntity>();
                float radius = monument.Bounds.size.Max();
                Vis.Entities(monument.transform.position, radius, ents);
                foreach (BaseEntity entity in ents)
                {
                    if (entity.OwnerID.IsSteamId() || OutOfRange(monument, entity.transform.position, entity is BaseChair))
                    {
                        continue;
                    }
                    if (entity.prefabID == 3858860623 || entity.prefabID == 1729604075 || entity is NPCMissionProvider || entity is Workbench)
                    {
                        outpost.Location = entity.transform.position + entity.transform.forward + new Vector3(0f, 1f, 0f);
                        if (!outpost.Locations.Contains(outpost.Location)) outpost.Locations.Add(outpost.Location);
                        changedOutpost = true;
#if DEBUG
                        Puts("  Adding Outpost target {0}", outpost.Location);
#endif
                    }
                    else if (entity is BaseChair)
                    {
                        outpost.Location = entity.transform.position + entity.transform.right + new Vector3(0f, 1f, 0f);
                        if (!outpost.Locations.Contains(outpost.Location)) outpost.Locations.Add(outpost.Location);
                        changedOutpost = true;
#if DEBUG
                        Puts("  Adding Outpost target {0}", outpost.Location);
#endif
                    }
                }
                if (changedOutpost) SaveConfig();
                Pool.FreeList(ref ents);
            }

            if (outpost.Location == Vector3.zero)
            {
                outpostEnabled = false;
            }
            else if (!outpost.Locations.Contains(outpost.Location))
            {
                outpost.Locations.Add(outpost.Location);
            }

            yield return null;
        }

        private IEnumerator SetupBandit(MonumentInfo monument)
        {
            var bandit = GetSettings("bandit");

            if (bandit == null)
            {
                banditEnabled = false;
                yield break;
            }

            float radius = monument.Bounds.size.Max();

            if (config.Settings.AutoGenBandit && bandit.Location != Vector3.zero && bandit.Locations.Exists(a => OutOfRange(monument, a, config.Settings.AutoGenBandit)))
            {
#if DEBUG
                Puts("Invalid Bandit location detected");
#endif
                bandit.Location = Vector3.zero;
                bandit.Locations = new List<Vector3>();
            }
            if (config.Settings.AutoGenBandit && bandit.Location == Vector3.zero)
            {
#if DEBUG
                Puts("  Looking for BanditTown target");
#endif
                bool changedBandit = false;
                var ents = Pool.GetList<BaseEntity>();
                Vis.Entities(monument.transform.position, radius, ents);
                foreach (BaseEntity entity in ents)
                {
                    if (entity.OwnerID.IsSteamId() || OutOfRange(monument, entity.transform.position, entity is BaseChair))
                    {
                        continue;
                    }
                    if (entity.prefabID == 3858860623 || entity.prefabID == 1729604075 || entity is NPCMissionProvider || entity is Workbench)
                    {
                        bandit.Location = entity.transform.position + entity.transform.forward + new Vector3(0f, 1f, 0f);
                        if (!bandit.Locations.Contains(bandit.Location)) bandit.Locations.Add(bandit.Location);
                        changedBandit = true;
#if DEBUG
                        Puts("  Adding BanditTown target {0}", bandit.Location);
#endif
                    }
                    else if (entity is BaseChair)
                    {
                        bandit.Location = entity.transform.position + entity.transform.forward + new Vector3(0f, 1f, 0f);
                        if (!bandit.Locations.Contains(bandit.Location)) bandit.Locations.Add(bandit.Location);
                        changedBandit = true;
#if DEBUG
                        Puts("  Adding BanditTown target {0}", bandit.Location);
#endif
                    }
                }
                Pool.FreeList(ref ents);
                if (changedBandit) SaveConfig();
            }

            if (bandit.Location == Vector3.zero)
            {
                banditEnabled = false;
            }
            else if (!bandit.Locations.Contains(bandit.Location))
            {
                bandit.Locations.Add(bandit.Location);
            }

            yield return null;
        }

        public IEnumerator CalculateMonumentSize(MonumentInfo monument, Vector3 from, string text, string prefab)
        {
            int checks = 0;
            float radius = 15f;
            while (radius < World.Size / 2f)
            {
                int pointsOfTopology = 0;
                foreach (var to in GetCircumferencePositions(from, radius, 30f))
                {
                    if (ContainsTopology(TerrainTopology.Enum.Building | TerrainTopology.Enum.Monument, to, 5f))
                    {
                        pointsOfTopology++;
                    }
                    if (++checks >= 25)
                    {
                        yield return CoroutineEx.waitForSeconds(0.0025f);
                        checks = 0;
                    }
                }
                if (pointsOfTopology < 4)
                {
                    break;
                }
                radius += 15f;
            }
            monuments.Add(new MonumentInfoEx(monument, from, radius, text, prefab));

#if DEBUG
            Puts($"Adding Monument: {text}, pos: {from}, size: {radius}");
#endif
        }

        public List<Vector3> GetCircumferencePositions(Vector3 center, float radius, float next)
        {
            float degree = 0f;
            float angleInRadians = 2f * Mathf.PI;
            List<Vector3> positions = new List<Vector3>();

            while (degree < 360)
            {
                float radian = (angleInRadians / 360) * degree;
                float x = center.x + radius * Mathf.Cos(radian);
                float z = center.z + radius * Mathf.Sin(radian);
                Vector3 a = new Vector3(x, 0f, z);

                positions.Add(a.WithY(TerrainMeta.HeightMap.GetHeight(a)));

                degree += next;
            }

            return positions;
        }

        private bool TeleportInForcedBoundary(params BasePlayer[] players)
        {
            if (config.Settings.ForcedBoundary != 0f)
            {
                foreach (var player in players)
                {
                    if (!CanBypassRestrictions(player.UserIDString) && player.transform.localPosition.y >= config.Settings.ForcedBoundary)
                    {
                        PrintMsgL(player, "TPFlagZone");
                        return false;
                    }
                }
            }
            return true;
        }

        private void TeleportRequestUI(BasePlayer player, string displayName)
        {
            if (!config.TPR.UI || string.IsNullOrEmpty(displayName)) return;
            var elements = new CuiElementContainer();
            elements.Add(new CuiPanel { CursorEnabled = false, Image = { Color = "0 0 0 0.75" }, RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-154.835 87.648", OffsetMax = "135.234 155.152" } }, "Overlay", "TPR_MAIN_UI", "TPR_MAIN_UI");
            elements.Add(new CuiElement { Name = "TPR_INFO_LBL", Parent = "TPR_MAIN_UI", DestroyUi = "TPR_INFO_LBL", Components = { new CuiTextComponent { Text = _("RequestUI", player, displayName), Font = "robotocondensed-regular.ttf", Align = TextAnchor.UpperCenter }, new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-142.335 -3.676", OffsetMax = "142.335 30.076" } } });
            elements.Add(new CuiButton { Button = { Command = "ntp.accept", Color = "0 0.78 0 0.75" }, Text = { Text = _("RequestAccept", player), Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" }, RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-138.395 -28.883", OffsetMax = "-28.406 -8.589" } }, "TPR_MAIN_UI", "TPR_ACCEPT_BTN", "TPR_ACCEPT_BTN");
            elements.Add(new CuiButton { Button = { Command = "ntp.reject", Color = "0.78 0 0 0.75" }, Text = { Text = _("RequestReject", player), Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" }, RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "29.305 -28.883", OffsetMax = "139.295 -8.589" } }, "TPR_MAIN_UI", "TPR_REJECT_BTN", "TPR_REJECT_BTN");
            timer.Once(config.TPR.RequestDuration, () => DestroyTeleportRequestCUI(player));
            CuiHelper.AddUi(player, elements);
        }

        public void DestroyTeleportRequestCUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "TPR_MAIN_UI");
        }

        [ConsoleCommand("ntp.accept")]
        private void ccmdAccept(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            DestroyTeleportRequestCUI(player);
            CommandTeleportAccept(player.IPlayer, "tpa", new string[0]);
        }

        [ConsoleCommand("ntp.reject")]
        private void ccmdReject(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            DestroyTeleportRequestCUI(player);
            CommandTeleportCancel(player.IPlayer, "tpc", new string[0]);
        }

        private bool OutOfRange(MonumentInfo m, Vector3 a, bool checkHeight) => checkHeight && Mathf.Abs(a.y - TerrainMeta.HeightMap.GetHeight(a)) > 5f || m.Distance(a) > m.Bounds.extents.Max() * 0.5f;

        private void CommandToggle(IPlayer user, string command, string[] args)
        {
            if (!user.IsAdmin) return;

            if (args.Length == 0)
            {
                user.Reply("tnt commandname");
                return;
            }

            string arg = args[0].ToLower();

            if (arg == command.ToLower()) return;

            if (!DisabledCommandData.DisabledCommands.Contains(arg))
                DisabledCommandData.DisabledCommands.Add(arg);
            else DisabledCommandData.DisabledCommands.Remove(arg);

            dataDisabled.WriteObject(DisabledCommandData);
            user.Reply("{0} {1}", DisabledCommandData.DisabledCommands.Contains(arg) ? "Disabled:" : "Enabled:", arg);
        }

        private void CommandTeleport(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!user.IsServer && (!IsAllowedMsg(player, PermTp) || !TeleportInForcedBoundary(player))) return;
            BasePlayer target;
            float x, y, z;
            switch (args.Length)
            {
                case 1:
                    if (player == null) return;
                    target = FindPlayersSingle(args[0], player);
                    if (target == null) return;
                    if (target == player)
                    {
#if DEBUG
                        Puts("Debug mode - allowing self teleport.");
#else
                        PrintMsgL(player, "CantTeleportToSelf");
                        return;
#endif
                    }
                    Teleport(player, target);
                    PrintMsgL(player, "AdminTP", target.displayName);
                    Puts(_("LogTeleport", null, player.displayName, target.displayName));
                    if (config.Admin.AnnounceTeleportToTarget)
                        PrintMsgL(target, "AdminTPTarget", player.displayName);
                    break;
                case 2:
                    var origin = FindPlayersSingle(args[0], player);
                    target = FindPlayersSingle(args[1], player);
                    if (target == null && origin != null)
                    {
                        var loc = GetAdminLocation(args[1]);
                        if (loc != Vector3.zero)
                        {
                            Teleport(origin, loc, IsAllowed(origin, PermTp));
                            return;
                        }
                    }
                    if (origin == null || target == null) return;
                    if (target == origin)
                    {
                        PrintMsgL(player, "CantTeleportPlayerToSelf");
                        return;
                    }
                    if (permission.UserHasPermission(target.UserIDString, PermDisallowTpToMe))
                    {
                        PrintMsgL(player, "CantTeleportPlayerToYourself");
                        return;
                    }
                    Teleport(origin, target);
                    Puts(_("LogTeleportPlayer", null, user.Name, origin.displayName, target.displayName));
                    if (player == null) return;
                    PrintMsgL(player, "AdminTPPlayers", origin.displayName, target.displayName);
                    PrintMsgL(origin, "AdminTPPlayer", player.displayName, target.displayName);
                    if (config.Admin.AnnounceTeleportToTarget)
                        PrintMsgL(target, "AdminTPPlayerTarget", player.displayName, origin.displayName);
                    break;
                case 3:
                    if (player == null) return;
                    if (!float.TryParse(args[0].Replace(",", string.Empty), out x) || !float.TryParse(args[1].Replace(",", string.Empty), out y) || !float.TryParse(args[2], out z))
                    {
                        PrintMsgL(player, "InvalidCoordinates");
                        return;
                    }
                    if (config.Settings.CheckBoundaries && !CheckBoundaries(x, y, z))
                    {
                        PrintMsgL(player, "AdminTPOutOfBounds");
                        PrintMsgL(player, "AdminTPBoundaries", boundary);
                        return;
                    }
                    Teleport(player, x, y, z);
                    PrintMsgL(player, "AdminTPCoordinates", player.transform.position);
                    Puts(_("LogTeleport", null, player.displayName, player.transform.position));
                    break;
                case 4:
                    target = FindPlayersSingle(args[0], player);
                    if (target == null) return;
                    if (player != null && permission.UserHasPermission(target.UserIDString, PermDisallowTpToMe) && target != player)
                    {
                        PrintMsgL(player, "CantTeleportPlayerToYourself");
                        return;
                    }
                    if (!float.TryParse(args[1].Replace(",", string.Empty), out x) || !float.TryParse(args[2].Replace(",", string.Empty), out y) || !float.TryParse(args[3], out z))
                    {
                        PrintMsgL(player, "InvalidCoordinates");
                        return;
                    }
                    if (config.Settings.CheckBoundaries && !CheckBoundaries(x, y, z))
                    {
                        PrintMsgL(player, "AdminTPOutOfBounds");
                        PrintMsgL(player, "AdminTPBoundaries", boundary);
                        return;
                    }
                    Teleport(target, x, y, z);
                    if (player == null) return;
                    if (player == target)
                    {
                        PrintMsgL(player, "AdminTPCoordinates", player.transform.position);
                        Puts(_("LogTeleport", null, player.displayName, player.transform.position));
                    }
                    else
                    {
                        PrintMsgL(player, "AdminTPTargetCoordinates", target.displayName, player.transform.position);
                        if (config.Admin.AnnounceTeleportToTarget)
                            PrintMsgL(target, "AdminTPTargetCoordinatesTarget", player.displayName, player.transform.position);
                        Puts(_("LogTeleportPlayer", null, player.displayName, target.displayName, player.transform.position));
                    }
                    break;
                default:
                    PrintMsgL(player, "SyntaxCommandTP");
                    break;
            }
        }

        private Vector3 GetAdminLocation(string value)
        {
            foreach (var adminData in _Admin.Values)
            {
                Vector3 loc;
                if (adminData.Locations.TryGetValue(value, out loc))
                {
                    return loc;
                }
            }
            return Vector3.zero;
        }

        private void CommandTeleportNear(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermTpN)) return;
            switch (args.Length)
            {
                case 1:
                case 2:
                    var target = FindPlayersSingle(args[0], player);
                    if (target == null) return;
                    if (target == player)
                    {
#if DEBUG
                        Puts("Debug mode - allowing self teleport.");
#else
                        PrintMsgL(player, "CantTeleportToSelf");
                        return;
#endif
                    }
                    int distance = 0;
                    if (args.Length != 2 || !int.TryParse(args[1], out distance))
                        distance = config.Admin.TeleportNearDefaultDistance;
                    float x = UnityEngine.Random.Range(-distance, distance);
                    var z = (float)Math.Sqrt(Math.Pow(distance, 2) - Math.Pow(x, 2));
                    var destination = target.transform.position;
                    destination.x -= x;
                    destination.z -= z;
                    Teleport(player, GetGroundBuilding(destination), true);
                    PrintMsgL(player, "AdminTP", target.displayName);
                    Puts(_("LogTeleport", null, player.displayName, target.displayName));
                    if (config.Admin.AnnounceTeleportToTarget)
                        PrintMsgL(target, "AdminTPTarget", player.displayName);
                    break;
                default:
                    PrintMsgL(player, "SyntaxCommandTPN");
                    break;
            }
        }

        private void CommandTeleportLocation(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermTpL)) return;
            AdminData adminData;
            if (!_Admin.TryGetValue(player.userID, out adminData) || adminData.Locations.Count <= 0)
            {
                PrintMsgL(player, "AdminLocationListEmpty");
                return;
            }
            switch (args.Length)
            {
                case 0:
                    PrintMsgL(player, "AdminLocationList");
                    foreach (var location in adminData.Locations)
                        PrintMsgL(player, $"{location.Key} {location.Value}");
                    break;
                case 1:
                    Vector3 loc;
                    if (!adminData.Locations.TryGetValue(args[0], out loc))
                    {
                        PrintMsgL(player, "LocationNotFound");
                        return;
                    }
                    Teleport(player, loc, true);
                    PrintMsgL(player, "AdminTPLocation", args[0]);
                    break;
                default:
                    PrintMsgL(player, "SyntaxCommandTPL");
                    break;
            }
        }

        private void CommandSaveTeleportLocation(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermTpSave)) return;
            if (args.Length != 1)
            {
                PrintMsgL(player, "SyntaxCommandTPSave");
                return;
            }
            AdminData adminData;
            if (!_Admin.TryGetValue(player.userID, out adminData))
                _Admin[player.userID] = adminData = new AdminData();
            Vector3 location;
            if (adminData.Locations.TryGetValue(args[0], out location))
            {
                PrintMsgL(player, "LocationExists", location);
                return;
            }
            var positionCoordinates = player.transform.position;
            if (!CanBypassRestrictions(player.UserIDString) && !permission.UserHasPermission(player.UserIDString, "nteleportation.locationradiusbypass"))
            {
                foreach (var loc in adminData.Locations)
                {
                    if ((positionCoordinates - loc.Value).magnitude < config.Admin.LocationRadius)
                    {
                        PrintMsgL(player, "LocationExistsNearby", loc.Key);
                        return;
                    }
                }
            }
            adminData.Locations[args[0]] = positionCoordinates;
            PrintMsgL(player, "AdminTPLocationSave");
            changedAdmin = true;
        }

        private void CommandRemoveTeleportLocation(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermTpRemove)) return;
            if (args.Length != 1)
            {
                PrintMsgL(player, "SyntaxCommandTPRemove");
                return;
            }
            AdminData adminData;
            if (!_Admin.TryGetValue(player.userID, out adminData) || adminData.Locations.Count <= 0)
            {
                PrintMsgL(player, "AdminLocationListEmpty");
                return;
            }
            if (adminData.Locations.Remove(args[0]))
            {
                PrintMsgL(player, "AdminTPLocationRemove", args[0]);
                changedAdmin = true;
                return;
            }
            PrintMsgL(player, "LocationNotFound");
        }

        private void CommandTeleportBack(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermTpB)) return;
            if (args.Length != 0)
            {
                PrintMsgL(player, "SyntaxCommandTPB");
                return;
            }
            AdminData adminData;
            if (!_Admin.TryGetValue(player.userID, out adminData) || adminData.PreviousLocation == Vector3.zero)
            {
                PrintMsgL(player, "NoPreviousLocationSaved");
                return;
            }
            if (TeleportTimers.ContainsKey(player.userID))
            {
                PrintMsgL(player, "TeleportPendingTPC");
                return;
            }
            if (!TeleportInForcedBoundary(player))
            {
                return;
            }
            if (!CanBypassRestrictions(player.UserIDString))
            {
                var err = CanPlayerTeleport(player, adminData.PreviousLocation, player.transform.position);
                if (err != null)
                {
                    SendReply(player, err);
                    return;
                }
                err = CheckPlayer(player, adminData.BuildingBlocked, adminData.AllowCrafting, true, "tpb", true);
                if (err != null)
                {
                    PrintMsgL(player, err);
                    return;
                }
            }
            var countdown = GetLower(player, config.Settings.TPB.Countdowns, config.Settings.TPB.Countdown);
            if (countdown > 0f)
            {
                TeleportBack(player, adminData, countdown);
                return;
            }
            Teleport(player, adminData.PreviousLocation, false);
            adminData.PreviousLocation = Vector3.zero;
            changedAdmin = true;
            PrintMsgL(player, "AdminTPBack");
            Puts(_("LogTeleportBack", null, player.displayName));
        }

        private void TeleportBack(BasePlayer player, AdminData adminData, int countdown)
        {
            string err = null;
            var location = adminData.PreviousLocation;
            TeleportTimers[player.userID] = new TeleportTimer
            {
                OriginPlayer = player,

                Timer = timer.Once(countdown, () =>
                {
#if DEBUG
                    Puts("Calling CheckPlayer from cmdChatHomeTP");
#endif
                    if (!CanBypassRestrictions(player.UserIDString))
                    {
                        err = CheckPlayer(player, config.Home.UsableOutOfBuildingBlocked, CanCraftHome(player), true, "home");
                        if (err != null)
                        {
                            PrintMsgL(player, "Interrupted");
                            PrintMsgL(player, err);
                            TeleportTimers.Remove(player.userID);
                            return;
                        }
                        err = CanPlayerTeleport(player, location, player.transform.position);
                        if (err != null)
                        {
                            PrintMsgL(player, "Interrupted");
                            PrintMsgL(player, err);
                            TeleportTimers.Remove(player.userID);
                            return;
                        }
                        err = CheckItems(player);
                        if (err != null)
                        {
                            PrintMsgL(player, "Interrupted");
                            PrintMsgL(player, "TPBlockedItem", err);
                            TeleportTimers.Remove(player.userID);
                            return;
                        }
                        err = IsInsideEntity(location, player.userID, "tpb");
                        if (err != null)
                        {
                            PrintMsgL(player, "Interrupted");
                            PrintMsgL(player, err);
                            TeleportTimers.Remove(player.userID);
                            return;
                        }
                        if (!TeleportInForcedBoundary(player))
                        {
                            return;
                        }
                    }
                    Teleport(player, location, false);
                    adminData.PreviousLocation = Vector3.zero;
                    changedAdmin = true;
                    PrintMsgL(player, "AdminTPBack");
                    Puts(_("LogTeleportBack", null, player.displayName));
                    TeleportTimers.Remove(player.userID);
                })
            };
            PrintMsgL(player, "DM_TownTPStarted", location, countdown);
        }

        private void CommandSetHome(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermHome)) return;
            if (!config.Settings.HomesEnabled) { user.Reply("Homes are not enabled in the config."); return; }
            if (args.Length != 1)
            {
                PrintMsgL(player, "SyntaxCommandSetHome");
                return;
            }
            string err = null;
            HomeData homeData;
            if (!_Home.TryGetValue(player.userID, out homeData))
                _Home[player.userID] = homeData = new HomeData();
            var limit = GetHigher(player, config.Home.VIPHomesLimits, config.Home.HomesLimit, true);
            if (!args[0].Replace("_", "").All(char.IsLetterOrDigit))
            {
                PrintMsgL(player, "InvalidCharacter");
                return;
            }
            HomeData.Entry homeEntry;
            if (homeData.TryGetValue(args[0], out homeEntry))
            {
                PrintMsgL(player, "HomeExists", homeEntry.Get());
                return;
            }
            var position = player.transform.position;
            if (!CanBypassRestrictions(player.UserIDString))
            {
                var getUseableTime = GetUseableTime(config.Home.Hours);
                if (getUseableTime > 0.0)
                {
                    PrintMsgL(player, "NotUseable", FormatTime(player, getUseableTime));
                    return;
                }
                err = CheckPlayer(player, false, CanCraftHome(player), true, "sethome");
                if (err != null)
                {
                    PrintMsgL(player, err);
                    return;
                }
                if (!player.CanBuild())
                {
                    PrintMsgL(player, "HomeTPBuildingBlocked");
                    return;
                }
                if (limit > 0 && homeData.Locations.Count >= limit)
                {
                    PrintMsgL(player, "HomeMaxLocations", limit);
                    return;
                }
                if (config.Home.LocationRadius > 0 && !permission.UserHasPermission(player.UserIDString, "nteleportation.locationradiusbypass"))
                {
                    foreach (var loc in homeData.Locations)
                    {
                        if ((position - loc.Value.Get()).magnitude < config.Home.LocationRadius)
                        {
                            PrintMsgL(player, "HomeExistsNearby", loc.Key);
                            return;
                        }
                    }
                }
                err = CanPlayerTeleport(player, position);
                if (err != null)
                {
                    SendReply(player, err);
                    return;
                }
                err = CheckFoundation(player.userID, position, "sethome");
                if (err != null)
                {
                    PrintMsgL(player, err);
                    return;
                }
            }
            if (player.IsAdmin && config.Settings.DrawHomeSphere) player.SendConsoleCommand("ddraw.sphere", 30f, Color.blue, position, 2.5f);
            var entity = player.GetParentEntity() as Tugboat;
            if (entity != null)
            {
                if (!config.Home.AllowTugboats && !permission.UserHasPermission(player.UserIDString, "nteleportation.tugboatssethomebypass") && !CanBypassRestrictions(player.UserIDString))
                {
                    PrintMsgL(player, "HomeTugboatNotAllowed");
                    return;
                }
                homeData.Set(args[0], new HomeData.Entry
                {
                    Position = position - entity.transform.position,
                    wasEntity = true,
                    Entity = entity
                });
            }
            else homeData.Set(args[0], new HomeData.Entry(position));
            changedHome = true;
            PrintMsgL(player, "HomeSave");
            PrintMsgL(player, "HomeQuota", homeData.Locations.Count, limit);
            Interface.CallHook("OnHomeAdded", player, position, args[0]);
        }

        private void CommandRemoveHome(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            if (!config.Settings.HomesEnabled) { user.Reply("Homes are not enabled in the config."); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermHome)) return;
            if (player.IsAdmin && args.Length == 2 && args[0] == "all")
            {
                float radius;
                if (float.TryParse(args[1], out radius))
                {
                    int amount = 0;
                    foreach (var home in _Home.ToList())
                    {
                        foreach (var location in home.Value.Locations.ToList())
                        {
                            var position = location.Value.Get();
                            if (Vector3Ex.Distance2D(position, player.transform.position) < radius)
                            {
                                string username = covalence.Players.FindPlayerById(home.Key.ToString())?.Name ?? "N/A";
                                Puts("{0} ({1}) removed home from {2} ({3}) at {4}", player.displayName, player.userID, username, home.Key, position);
                                player.SendConsoleCommand("ddraw.text", 30f, Color.red, position, "X");
                                home.Value.Remove(location.Key);
                                amount++;
                            }
                        }
                    }

                    user.Reply($"Removed {amount} homes within {radius} meters");
                }
                else user.Reply("/removehome all <radius>");

                return;
            }
            if (args.Length != 1)
            {
                PrintMsgL(player, "SyntaxCommandRemoveHome");
                return;
            }
            HomeData homeData;
            if (!_Home.TryGetValue(player.userID, out homeData) || homeData.Locations.Count <= 0)
            {
                PrintMsgL(player, "HomeListEmpty");
                return;
            }
            HomeData.Entry homeEntry;
            if (homeData.TryGetValue(args[0], out homeEntry))
            {
                Interface.CallHook("OnHomeRemoved", player, homeEntry.Get(), args[0]);
                homeData.Remove(args[0]);
                changedHome = true;
                PrintMsgL(player, "HomeRemove", args[0]);
            }
            else PrintMsgL(player, "HomeNotFound");
        }

        private void CommandHome(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            if (!config.Settings.HomesEnabled) { user.Reply("Homes are not enabled in the config."); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermHome)) return;
            if (args.Length == 0)
            {
                PrintMsgL(player, "SyntaxCommandHome");
                if (IsAllowed(player)) PrintMsgL(player, "SyntaxCommandHomeAdmin");
                return;
            }
            switch (args[0].ToLower())
            {
                case "add":
                    CommandSetHome(user, command, args.Skip(1).ToArray());
                    break;
                case "list":
                    CommandListHomes(user, command, args.Skip(1).ToArray());
                    break;
                case "remove":
                    CommandRemoveHome(user, command, args.Skip(1).ToArray());
                    break;
                case "radius":
                    CommandHomeRadius(user, command, args.Skip(1).ToArray());
                    break;
                case "delete":
                    CommandHomeDelete(user, command, args.Skip(1).ToArray());
                    break;
                case "tp":
                    CommandHomeAdminTP(user, command, args.Skip(1).ToArray());
                    break;
                case "homes":
                    CommandHomeHomes(user, command, args.Skip(1).ToArray());
                    break;
                case "wipe":
                    CommandWipeHomes(user, command, args.Skip(1).ToArray());
                    break;
                default:
                    cmdChatHomeTP(player, command, args);
                    break;
            }
        }

        private void CommandHomeRadius(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermRadiusHome)) return;
            float radius;
            if (args.Length != 1 || !float.TryParse(args[0], out radius)) radius = 10;
            var found = false;
            foreach (var homeData in _Home)
            {
                var toRemove = new List<string>();
                var target = RustCore.FindPlayerById(homeData.Key)?.displayName ?? homeData.Key.ToString();
                foreach (var location in homeData.Value.Locations)
                {
                    var position = location.Value.Get();
                    if ((player.transform.position - position).magnitude <= radius)
                    {
                        string err = null;
                        if (!location.Value.isEntity)
                        {
                            err = location.Value.wasEntity ? "HomeRemovedDestroyed" : CheckFoundation(homeData.Key, position, "radius");
                        }
                        if (err != null)
                        {
                            SendHomeError(player, toRemove, err, location.Key, position, err == "HomeRemovedDestroyed");
                            found = true;
                            continue;
                        }
                        if (player.IsAdmin)
                        {
                            var entity = GetFoundationOwned(position, homeData.Key);
                            if (entity == null)
                            {
                                player.SendConsoleCommand("ddraw.text", 30f, Color.blue, position, $"<size=20>{target} - {location.Key} {position}</size>");
                            }
                            else
                            {
                                player.SendConsoleCommand("ddraw.text", 30f, Color.blue, entity.CenterPoint() + new Vector3(0, .5f), $"<size=20>{target} - {location.Key} {position}</size>");
                                DrawBox(player, entity.CenterPoint(), entity.transform.rotation, entity.bounds.size);
                            }
                        }
                        PrintMsg(player, $"{target} - {location.Key} {position}");
                        found = true;
                    }
                }
                foreach (var key in toRemove)
                {
                    homeData.Value.Remove(key);
                    changedHome = true;
                }
            }
            if (!found)
                PrintMsgL(player, "HomeNoFound");
        }

        private void SendHomeError(BasePlayer player, List<string> toRemove, string err, string homeName, Vector3 position, bool wasEntity, bool send = true)
        {
            Interface.CallHook("OnHomeRemoved", player, position, homeName);
            if (toRemove != null)
            {
                toRemove.Add(homeName);
            }
            if (!send)
            {
                return;
            }
            if (!wasEntity)
            {
                PrintMsgL(player, "HomeRemovedInvalid", $"{homeName} {position} ({PhoneController.PositionToGridCoord(position)})");
                PrintMsgL(player, err);
            }
            else PrintMsgL(player, "HomeRemovedDestroyed", homeName);
        }

        private void CommandHomeDelete(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowed(player, PermDeleteHome)) return;
            if (args.Length != 2)
            {
                PrintMsgL(player, "SyntaxCommandHomeDelete");
                return;
            }
            var userId = FindPlayersSingleId(args[0], player);
            if (userId <= 0) return;
            HomeData targetHome;
            if (!_Home.TryGetValue(userId, out targetHome) || !targetHome.Remove(args[1]))
            {
                PrintMsgL(player, "HomeNotFound");
                return;
            }
            changedHome = true;
            PrintMsgL(player, "HomeDelete", args[0], args[1]);
        }

        private void CommandHomeAdminTP(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermAdmin)) return;
            if (args.Length != 2)
            {
                PrintMsgL(player, "SyntaxCommandHomeAdminTP");
                return;
            }
            var userId = FindPlayersSingleId(args[0], player);
            if (userId <= 0) return;
            HomeData targetHome;
            HomeData.Entry homeEntry;
            if (!_Home.TryGetValue(userId, out targetHome) || !targetHome.TryGetValue(args[1], out homeEntry))
            {
                PrintMsgL(player, "HomeNotFound");
                return;
            }
            Teleport(player, homeEntry.Get(), true);
            PrintMsgL(player, "HomeAdminTP", args[0], args[1]);
        }

        // Check that plugins are available and enabled for CheckEconomy()
        private bool UseEconomy()
        {
            return (config.Settings.UseEconomics && (Economics != null || IQEconomic != null)) || (config.Settings.UseServerRewards && ServerRewards != null);
        }

        // Check balance on multiple plugins and optionally withdraw money from the player
        private bool CheckEconomy(BasePlayer player, double bypass, bool withdraw = false, bool deposit = false)
        {
            if (player == null)
            {
                return false;
            }
            if (CanBypassRestrictions(player.UserIDString)) return true;
            bool foundmoney = false;
            // Check Economics first.  If not in use or balance low, check ServerRewards below
            if (config.Settings.UseEconomics)
            {
                if (Economics != null)
                {
                    var balance = (double)Economics?.CallHook("Balance", player.UserIDString);

                    if (balance >= bypass)
                    {
                        foundmoney = true;
                        if (withdraw)
                        {
                            return Convert.ToBoolean(Economics?.CallHook("Withdraw", player.userID, bypass));
                        }
                        else if (deposit)
                        {
                            Economics?.CallHook("Deposit", player.userID, bypass);
                        }
                    }
                }
                else if (IQEconomic != null)
                {
                    var balance = (int)IQEconomic?.CallHook("API_GET_BALANCE", player.userID);
                    if (balance >= bypass)
                    {
                        foundmoney = true;
                        if (withdraw)
                        {
                            return Convert.ToBoolean(IQEconomic?.CallHook("API_REMOVE_BALANCE", player.userID, (int)bypass));
                        }
                        else if (deposit)
                        {
                            Economics?.CallHook("API_SET_BALANCE", player.userID, bypass);
                        }
                    }
                }
            }

            // No money via Economics, or plugin not in use.  Try ServerRewards.
            if (!foundmoney && config.Settings.UseServerRewards && ServerRewards != null)
            {
                object bal = ServerRewards?.Call("CheckPoints", player.userID);
                var balance = Convert.ToDouble(bal);
                if (balance >= bypass)
                {
                    foundmoney = true;
                    if (withdraw)
                    {
                        return Convert.ToBoolean(ServerRewards?.Call("TakePoints", player.userID, (int)bypass));
                    }
                    else if (deposit)
                    {
                        ServerRewards?.Call("AddPoints", player.userID, (int)bypass);
                    }
                }
            }

            // Just checking balance without withdrawal - did we find anything?
            return foundmoney;
        }

        private void cmdChatHomeTP(BasePlayer player, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { player.ChatMessage("Disabled command."); return; }
            if (!IsAllowedMsg(player, PermHome)) return;
            bool paidmoney = false;
            if (!config.Settings.HomesEnabled) { player.ChatMessage("Homes are not enabled in the config."); return; }
            if (args.Length < 1)
            {
                PrintMsgL(player, "SyntaxCommandHome");
                return;
            }
            HomeData homeData;
            if (!_Home.TryGetValue(player.userID, out homeData) || homeData.Locations.Count <= 0)
            {
                PrintMsgL(player, "HomeListEmpty");
                return;
            }
            HomeData.Entry homeEntry;
            if (!homeData.TryGetValue(args[0], out homeEntry))
            {
                PrintMsgL(player, "HomeNotFound");
                return;
            }
            int limit = 0;
            string err = null;
            var position = homeEntry.Get();
            var timestamp = Facepunch.Math.Epoch.Current;
            if (!CanBypassRestrictions(player.UserIDString))
            {
                if (!TeleportInForcedBoundary(player))
                {
                    return;
                }
                float globalCooldownTime = GetGlobalCooldown(player);
                if (globalCooldownTime > 0f)
                {
                    PrintMsgL(player, "WaitGlobalCooldown", FormatTime(player, (int)globalCooldownTime));
                    return;
                }
                if (config.Settings.BlockAuthorizedTeleporting && player.IsBuildingAuthed())
                {
                    PrintMsgL(player, "CannotTeleportFromHome");
                    return;
                }
                err = CheckPlayer(player, config.Home.UsableOutOfBuildingBlocked, CanCraftHome(player), true, "home");
                if (err != null)
                {
                    PrintMsgL(player, err);
                    return;
                }
                if (config.Settings.BlockNoEscape && Convert.ToBoolean(NoEscape?.Call("IsBlockedZone", position)))
                {
                    PrintMsgL(player, "TPNoEscapeBlocked");
                    return;
                }
                if (!homeEntry.isEntity)
                {
                    err = homeEntry.wasEntity ? "HomeRemovedDestroyed" : CheckFoundation(player.userID, position, "home");
                }
                if (err == null)
                {
                    err = CheckTargetLocation(player, position, config.Home.UsableIntoBuildingBlocked, config.Home.CupOwnerAllowOnBuildingBlocked);
                }
                if (err != null)
                {
                    SendHomeError(player, null, err, args[0], position, err == "HomeRemovedDestroyed");
                    homeData.Remove(args[0]);
                    changedHome = true;
                    return;
                }
                var cooldown = GetLower(player, config.Home.VIPCooldowns, config.Home.Cooldown);
                var remain = cooldown - (timestamp - homeData.Teleports.Timestamp);
                if (cooldown > 0 && timestamp - homeData.Teleports.Timestamp < cooldown)
                {
                    var cmdSent = args.Length >= 2 ? args[1].ToLower() : string.Empty;

                    if (!string.IsNullOrEmpty(config.Settings.BypassCMD) && !paidmoney)
                    {
                        if (cmdSent == config.Settings.BypassCMD.ToLower() && config.Home.Bypass > -1)
                        {
                            bool foundmoney = CheckEconomy(player, config.Home.Bypass);

                            if (foundmoney)
                            {
                                CheckEconomy(player, config.Home.Bypass, true);
                                paidmoney = true;

                                if (config.Home.Bypass > 0)
                                {
                                    PrintMsgL(player, "HomeTPCooldownBypass", config.Home.Bypass);
                                }

                                if (config.Home.Pay > 0)
                                {
                                    PrintMsgL(player, "PayToHome", config.Home.Pay);
                                }
                            }
                            else
                            {
                                PrintMsgL(player, "HomeTPCooldownBypassF", config.Home.Bypass);
                                return;
                            }
                        }
                        else if (UseEconomy())
                        {
                            if (config.Home.Bypass > 0)
                            {
                                PrintMsgL(player, "HomeTPCooldown", FormatTime(player, remain));
                                PrintMsgL(player, "HomeTPCooldownBypassP", config.Home.Bypass);
                                PrintMsgL(player, "HomeTPCooldownBypassP2", config.Settings.BypassCMD);
                                return;
                            }
                        }
                        else
                        {
                            PrintMsgL(player, "HomeTPCooldown", FormatTime(player, remain));
                            return;
                        }
                    }
                    else
                    {
                        PrintMsgL(player, "HomeTPCooldown", FormatTime(player, remain));
                        return;
                    }
                }
                var currentDate = DateTime.Now.ToString("d");
                if (homeData.Teleports.Date != currentDate)
                {
                    homeData.Teleports.Amount = 0;
                    homeData.Teleports.Date = currentDate;
                }
                limit = GetHigher(player, config.Home.VIPDailyLimits, config.Home.DailyLimit, true);
                if (limit > 0 && homeData.Teleports.Amount >= limit)
                {
                    PrintMsgL(player, "HomeTPLimitReached", limit);
                    return;
                }
                err = CanPlayerTeleport(player, position, player.transform.position);
                if (err != null)
                {
                    SendReply(player, err);
                    return;
                }
                err = CheckItems(player);
                if (err != null)
                {
                    PrintMsgL(player, "TPBlockedItem", err);
                    return;
                }
                if (config.Home.UsableFromSafeZoneOnly && !player.InSafeZone())
                {
                    PrintMsgL(player, "TPHomeSafeZoneOnly");
                    return;
                }
            }
            if (TeleportTimers.ContainsKey(player.userID))
            {
                PrintMsgL(player, "TeleportPendingTPC");
                return;
            }
            var countdown = GetLower(player, config.Home.VIPCountdowns, config.Home.Countdown);
            TeleportTimers[player.userID] = new TeleportTimer
            {
                OriginPlayer = player,
                Timer = timer.Once(countdown, () =>
                {
#if DEBUG
                    Puts("Calling CheckPlayer from cmdChatHomeTP");
#endif
                    position = homeEntry.Get();
                    if (!CanBypassRestrictions(player.UserIDString))
                    {
                        if (!TeleportInForcedBoundary(player))
                        {
                            return;
                        }
                        err = CheckPlayer(player, config.Home.UsableOutOfBuildingBlocked, CanCraftHome(player), true, "home");
                        if (err != null)
                        {
                            PrintMsgL(player, "Interrupted");
                            PrintMsgL(player, err);
                            if (paidmoney)
                            {
                                paidmoney = false;
                                CheckEconomy(player, config.Home.Bypass, false, true);
                            }
                            TeleportTimers.Remove(player.userID);
                            return;
                        }
                        err = CanPlayerTeleport(player, position, player.transform.position);
                        if (err != null)
                        {
                            PrintMsgL(player, "Interrupted");
                            PrintMsgL(player, err);
                            if (paidmoney)
                            {
                                paidmoney = false;
                                CheckEconomy(player, config.Home.Bypass, false, true);
                            }
                            TeleportTimers.Remove(player.userID);
                            return;
                        }
                        err = CheckItems(player);
                        if (err != null)
                        {
                            PrintMsgL(player, "Interrupted");
                            PrintMsgL(player, "TPBlockedItem", err);
                            if (paidmoney)
                            {
                                paidmoney = false;
                                CheckEconomy(player, config.Home.Bypass, false, true);
                            }
                            TeleportTimers.Remove(player.userID);
                            return;
                        }
                        if (!homeEntry.isEntity)
                        {
                            err = homeEntry.wasEntity ? "HomeRemovedDestroyed" : CheckFoundation(player.userID, position, "home");
                        }
                        if (err == null)
                        {
                            err = CheckTargetLocation(player, position, config.Home.UsableIntoBuildingBlocked, config.Home.CupOwnerAllowOnBuildingBlocked);
                        }
                        if (err != null)
                        {
                            SendHomeError(player, null, err, args[0], position, err == "HomeRemovedDestroyed");
                            homeData.Remove(args[0]);
                            changedHome = true;
                            if (paidmoney)
                            {
                                paidmoney = false;
                                CheckEconomy(player, config.Home.Bypass, false, true);
                            }
                            return;
                        }
                        if (UseEconomy())
                        {
                            if (config.Home.Pay < 0)
                            {
                                TeleportTimers.Remove(player.userID);
                                PrintMsgL(player, "DM_TownTPDisabled", "/home");
                                return;
                            }
                            else if (config.Home.Pay > 0)
                            {
                                if (!CheckEconomy(player, config.Home.Pay))
                                {
                                    TeleportTimers.Remove(player.userID);
                                    PrintMsgL(player, "TPNoMoney", config.Home.Pay);
                                    return;
                                }

                                if (!paidmoney)
                                {
                                    PrintMsgL(player, "TPMoney", (double)config.Home.Pay);
                                }

                                paidmoney = CheckEconomy(player, config.Home.Pay, true);
                            }
                        }
                    }
                    Teleport(player, position, config.Home.AllowTPB, config.Home.UsableOutOfBuildingBlocked, CanCraftHome(player));
                    homeData.Teleports.Amount++;
                    homeData.Teleports.Timestamp = timestamp;
                    changedHome = true;
                    PrintMsgL(player, "HomeTP", args[0]);
                    if (limit > 0) PrintMsgL(player, "HomeTPAmount", limit - homeData.Teleports.Amount);
                    TeleportTimers.Remove(player.userID);
                })
            };

            if (countdown > 0)
            {
                PrintMsgL(player, "HomeTPStarted", args[0], countdown);
            }
        }

        private void CommandListHomes(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!config.Settings.HomesEnabled) { user.Reply("Homes are not enabled in the config."); return; }
            if (!IsAllowedMsg(player, PermHome)) return;
            if (args.Length != 0)
            {
                PrintMsgL(player, "SyntaxCommandListHomes");
                return;
            }
            HomeData homeData;
            if (!_Home.TryGetValue(player.userID, out homeData) || homeData.Locations.Count <= 0)
            {
                PrintMsgL(player, "HomeListEmpty");
                return;
            }
            PrintMsgL(player, "HomeList");
            ValidateHomes(player, homeData, true, false);
            foreach (var location in homeData.Locations)
                PrintMsgL(player, $"{location.Key} {location.Value.Get()} {PhoneController.PositionToGridCoord(location.Value.Get())}");
        }

        private void ValidateHomes(BasePlayer player, HomeData homeData, bool showRemoved, bool showLoc)
        {
            if (config.Home.CheckValidOnList)
            {
                string err = null;
                var toRemove = new List<string>();
                foreach (var location in homeData.Locations)
                {
                    var position = location.Value.Get();
                    if (!location.Value.isEntity)
                    {
                        err = location.Value.wasEntity ? "HomeRemovedDestroyed" : CheckFoundation(player.userID, position, "validate");
                    }
                    if (err != null)
                    {
                        SendHomeError(player, toRemove, err, location.Key, position, err == "HomeRemovedDestroyed", showRemoved);
                    }
                    else if (showLoc) PrintMsgL(player, $"{location.Key} {position} {PhoneController.PositionToGridCoord(position)}");
                }
                foreach (var key in toRemove)
                {
                    homeData.Remove(key);
                    changedHome = true;
                }
            }
        }

        private void CommandHomeHomes(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermHomeHomes)) return;
            if (args.Length != 1)
            {
                PrintMsgL(player, "SyntaxCommandHomeHomes");
                return;
            }
            var userId = FindPlayersSingleId(args[0], player);
            if (userId <= 0) return;
            HomeData homeData;
            if (!_Home.TryGetValue(userId, out homeData) || homeData.Locations.Count <= 0)
            {
                PrintMsgL(player, "HomeListEmpty");
                return;
            }
            PrintMsgL(player, "HomeList");
            var toRemove = new List<string>();
            foreach (var location in homeData.Locations)
            {
                var position = location.Value.Get();
                string err = null;
                if (!location.Value.isEntity)
                {
                    err = location.Value.wasEntity ? "HomeRemovedDestroyed" : CheckFoundation(userId, position, "homes");
                }
                if (err != null)
                {
                    SendHomeError(player, toRemove, err, location.Key, position, err == "HomeRemovedDestroyed");
                }
                else PrintMsgL(player, $"{location.Key} {position} ({PhoneController.PositionToGridCoord(position)})");
            }
            foreach (var key in toRemove)
            {
                homeData.Remove(key);
                changedHome = true;
            }
        }

        private void CommandTeleportAcceptToggle(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!player || !IsAllowedMsg(player, PermTpT))

                return;
            if (args.Length < 1)
            {
                PrintMsgL(player, "TPTInfo", command, IsEnabled(player.UserIDString, "clan") ? config.TPT.EnabledColor : config.TPT.DisabledColor, 
                    IsEnabled(player.UserIDString, "team") ? config.TPT.EnabledColor : config.TPT.DisabledColor, 
                    IsEnabled(player.UserIDString, "friend") ? config.TPT.EnabledColor : config.TPT.DisabledColor,
                    command.ToUpper(), config.TPT.EnabledColor, config.TPT.DisabledColor);
                return;
            }
            switch (args[0].ToLower())
            {
                case "friend":
                case "clan":
                case "team":
                {
                    ToggleTPTEnabled(player, args[0].ToLower(), command);
                    return;
                }
            }
            PrintMsgL(player, "TPTInfo", command, IsEnabled(player.UserIDString, "clan") ? config.TPT.EnabledColor : config.TPT.DisabledColor, 
                IsEnabled(player.UserIDString, "team") ? config.TPT.EnabledColor : config.TPT.DisabledColor, 
                IsEnabled(player.UserIDString, "friend") ? config.TPT.EnabledColor : config.TPT.DisabledColor,
                command.ToUpper(), config.TPT.EnabledColor, config.TPT.DisabledColor);
        }

        public bool IsOnSameTeam(ulong playerId, ulong targetId)
        {
            RelationshipManager.PlayerTeam team;
            return RelationshipManager.ServerInstance.playerToTeam.TryGetValue(playerId, out team) && team.members.Contains(targetId);
        }

        private bool AreFriends(string playerId, string targetId)
        {
            return Friends != null && Convert.ToBoolean(Friends?.Call("AreFriends", playerId, targetId));
        }
        private bool IsFriend(string playerId, string targetId)
        {
            return Friends != null && Convert.ToBoolean(Friends?.Call("IsFriend", playerId, targetId));
        }

        private bool IsInSameClan(string playerId, string targetId)
        {
            return Clans != null && Convert.ToBoolean(Clans?.Call("IsMemberOrAlly", playerId, targetId));
        }

        private object OnTeleportRequested(BasePlayer target, BasePlayer player)
        {
            if (!permission.UserHasPermission(target.UserIDString, PermTpT) || !permission.UserHasPermission(player.UserIDString, PermTpT))// || !TPT.ContainsKey(target.UserIDString))
            {
                return null;
            }
            
            if ((config.TPT.UseClans && IsInSameClan(player.UserIDString, target.UserIDString) && !TPT.ContainsKey(target.UserIDString)) 
                || (config.TPT.UseClans && IsEnabled(target.UserIDString, "clan") && IsInSameClan(player.UserIDString, target.UserIDString)))
            {
                CommandTeleportAccept(target.IPlayer, TPA, nullArg);
            }
            else if ((config.TPT.UseFriends && IsFriend(player.UserIDString, target.UserIDString) && !TPT.ContainsKey(target.UserIDString))
                     || (config.TPT.UseFriends && IsEnabled(target.UserIDString, "friend") && IsFriend(player.UserIDString, target.UserIDString)))
            {
                CommandTeleportAccept(target.IPlayer, TPA, nullArg);
            }
            else if ((config.TPT.UseTeams && IsOnSameTeam(player.userID, target.userID) && !TPT.ContainsKey(target.UserIDString))
                     || (config.TPT.UseTeams && IsEnabled(target.UserIDString, "team") && IsOnSameTeam(player.userID, target.userID)))
            {
                CommandTeleportAccept(target.IPlayer, TPA, nullArg);
            }

            return true;
        }
        
        bool IsEnabled(string targetId, string value)
        {
            if (TPT.ContainsKey(targetId) && TPT[targetId].Contains(value))
            {
                return false;
            }
            return true;
        }
        
        void ToggleTPTEnabled(BasePlayer target, string value, string command)
        {
            List<string> list;
            if (!TPT.TryGetValue(target.UserIDString, out list))
            {
                TPT[target.UserIDString] = list = new List<string>();
            }
            if (list.Contains(value))
            {
                list.Remove(value);
                if (list.IsEmpty()) TPT.Remove(target.UserIDString);
            }
            else
            {
                list.Add(value);
            }
            string status = lang.GetMessage($"TPT_{!list.Contains(value)}", this, target.UserIDString);
            string message = string.Format(lang.GetMessage($"TPT_{value}", this, target.UserIDString), status, command.ToUpper());
            PrintMsg(target, message);
            changedTPT = true;
        }

        private string GetMultiplePlayers(List<BasePlayer> players)
        {
            var list = new List<string>();

            foreach (var player in players)
            {
                string id;
                if (!_players.TryGetValue(player, out id))
                {
                    id = OnPlayerConnected(player);
                }

                list.Add(string.Format("<color={0}>{1}</color> - {2}", config.Settings.ChatCommandArgumentColor, id, player.displayName));
            }

            return string.Join(", ", list.ToArray());
        }

        private double GetUseableTime(double hours) => hours <= 0.0 ? 0.0 : TimeSpan.FromHours(hours - DateTime.UtcNow.Subtract(SaveRestore.SaveCreatedTime).TotalHours).TotalSeconds;

        private void CommandTeleportRequest(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermTpR)) return;
            if (!config.Settings.TPREnabled) { user.Reply("TPR is not enabled in the config."); return; }
            if (args.Length == 0)
            {
                PrintMsgL(player, "SyntaxCommandTPR");
                return;
            }
            var targets = FindPlayers(args[0]);
            if (targets.Count <= 0)
            {
                PrintMsgL(player, "PlayerNotFound");
                return;
            }
            BasePlayer target = null;
            if (args.Length >= 2)
            {
                if (targets.Count > 1)
                {
                    PrintMsgL(player, "MultiplePlayers", GetMultiplePlayers(targets));
                    return;
                }
                else target = targets[0];
            }
            else
            {
                if (targets.Count > 1)
                {
                    PrintMsgL(player, "MultiplePlayers", GetMultiplePlayers(targets));
                    return;
                }

                target = targets[0];
            }

            if (target == player)
            {
#if DEBUG
                Puts("Debug mode - allowing self teleport.");
#else
                PrintMsgL(player, "CantTeleportToSelf");
                return;
#endif
            }
#if DEBUG
            Puts("Calling CheckPlayer from cmdChatTeleportRequest");
#endif
            if (!TeleportInForcedBoundary(player, target))
            {
                return;
            }

            if (IsBlockedUser(player.userID, target.userID))
            {
                PrintMsgL(player, "BlockedTeleportTarget", target.displayName.Sanitize());
                return;
            }
            TeleportData tprData;
            if (!_TPR.TryGetValue(player.userID, out tprData))
                _TPR[player.userID] = tprData = new TeleportData();
            if (!CanBypassRestrictions(player.UserIDString))
            {
                var getUseableTime = GetUseableTime(config.TPR.Hours);
                if (getUseableTime > 0.0)
                {
                    PrintMsgL(player, "NotUseable", FormatTime(player, getUseableTime));
                    return;
                }
                string err = null;
                float globalCooldownTime = GetGlobalCooldown(player);
                if (globalCooldownTime > 0f)
                {
                    PrintMsgL(player, "WaitGlobalCooldown", FormatTime(player, (int)globalCooldownTime));
                    return;
                }
                if (config.Settings.BlockAuthorizedTeleporting && player.IsBuildingAuthed())
                {
                    PrintMsgL(player, "CannotTeleportFromHome");
                    return;
                }
                err = CheckPlayer(player, config.TPR.UsableOutOfBuildingBlocked, CanCraftTPR(player), true, "tpr");
                if (err != null)
                {
                    PrintMsgL(player, err);
                    return;
                }
                var err2 = CheckPlayer(target, config.TPR.UsableIntoBuildingBlocked, CanCraftTPR(target), true, "tpr");
                if (err2 != null)
                {
                    string error = string.Format(lang.GetMessage("ErrorTPR", this, player.UserIDString), target.displayName, lang.GetMessage(err2, this, player.UserIDString));
                    PrintMsg(player, error);
                    return;
                }
                err = CheckTargetLocation(target, target.transform.position, config.TPR.UsableIntoBuildingBlocked, config.TPR.CupOwnerAllowOnBuildingBlocked);
                if (err != null)
                {
                    PrintMsgL(player, err);
                    return;
                }
                var timestamp = Facepunch.Math.Epoch.Current;
                var currentDate = DateTime.Now.ToString("d");

                if (tprData.Date != currentDate)
                {
                    tprData.Amount = 0;
                    tprData.Date = currentDate;
                }

                var cooldown = GetLower(player, config.TPR.VIPCooldowns, config.TPR.Cooldown);
                if (cooldown > 0 && timestamp - tprData.Timestamp < cooldown)
                {
                    var cmdSent = args.Length >= 2 ? args[1].ToLower() : string.Empty;

                    if (!string.IsNullOrEmpty(config.Settings.BypassCMD))
                    {
                        if (cmdSent == config.Settings.BypassCMD.ToLower() && config.TPR.Bypass > -1)
                        {
                            if (CheckEconomy(player, config.TPR.Bypass))
                            {
                                CheckEconomy(player, config.TPR.Bypass, true);

                                if (config.TPR.Bypass > 0)
                                {
                                    PrintMsgL(player, "TPRCooldownBypass", config.TPR.Bypass);
                                }

                                if (config.TPR.Pay > 0)
                                {
                                    PrintMsgL(player, "PayToTPR", config.TPR.Pay);
                                }
                            }
                            else
                            {
                                PrintMsgL(player, "TPRCooldownBypassF", config.TPR.Bypass);
                                return;
                            }
                        }
                        else if (UseEconomy())
                        {
                            var remain = cooldown - (timestamp - tprData.Timestamp);
                            PrintMsgL(player, "TPRCooldown", FormatTime(player, remain));
                            if (config.TPR.Bypass > -1)
                            {
                                if (config.TPR.Bypass > 0)
                                {
                                    PrintMsgL(player, "TPRCooldownBypassP", config.TPR.Bypass);

                                    if (config.TPR.Pay > 0)
                                    {
                                        PrintMsgL(player, "PayToTPR", config.TPR.Pay);
                                    }

                                    PrintMsgL(player, "TPRCooldownBypassP2a", config.Settings.BypassCMD);
                                    return;
                                }
                            }
                            else return;
                        }
                        else
                        {
                            var remain = cooldown - (timestamp - tprData.Timestamp);
                            PrintMsgL(player, "TPRCooldown", FormatTime(player, remain));
                            return;
                        }
                    }
                    else
                    {
                        var remain = cooldown - (timestamp - tprData.Timestamp);
                        PrintMsgL(player, "TPRCooldown", FormatTime(player, remain));
                        return;
                    }
                }
                var limit = GetHigher(player, config.TPR.VIPDailyLimits, config.TPR.DailyLimit, true);
                if (limit > 0 && tprData.Amount >= limit)
                {
                    PrintMsgL(player, "TPRLimitReached", limit);
                    return;
                }
                err = CanPlayerTeleport(player, player.transform.position, target.transform.position);
                if (err != null)
                {
                    SendReply(player, err);
                    return;
                }
                err = CanPlayerTeleport(target, target.transform.position, player.transform.position);
                if (err != null)
                {
                    PrintMsgL(player, string.IsNullOrEmpty(err) ? "TPRTarget" : err);
                    return;
                }
                err = CheckItems(player);
                if (err != null)
                {
                    PrintMsgL(player, "TPBlockedItem", err);
                    return;
                }
            }
            if (TeleportTimers.ContainsKey(player.userID))
            {
                PrintMsgL(player, "TeleportPendingTPC");
                return;
            }
            if (TeleportTimers.ContainsKey(target.userID))
            {
                PrintMsgL(player, "TeleportPendingTarget");
                return;
            }
            if (PlayersRequests.ContainsKey(player.userID))
            {
                PrintMsgL(player, "PendingRequest");
                return;
            }
            if (PlayersRequests.ContainsKey(target.userID))
            {
                PrintMsgL(player, "PendingRequestTarget");
                return;
            }

            if (!config.TPR.UseClans_Friends_Teams || IsInSameClan(player.UserIDString, target.UserIDString) || AreFriends(player.UserIDString, target.UserIDString) || IsOnSameTeam(player.userID, target.userID) || CanBypassRestrictions(player.UserIDString))
            {
                PlayersRequests[player.userID] = target;
                PlayersRequests[target.userID] = player;
                PendingRequests[target.userID] = timer.Once(config.TPR.RequestDuration, () => { RequestTimedOut(player, target); });
                PrintMsgL(player, "Request", target.displayName);
                PrintMsgL(target, "RequestTarget", player.displayName);
                if (config.TPR.PlaySoundsToRequestTarget)
                {
                    SendEffect(target, config.TPR.TeleportRequestEffects);
                }
                if (Interface.CallHook("OnTeleportRequested", target, player) == null)
                {
                    TeleportRequestUI(target, player.displayName);
                }
            }
            else
            {
                PrintMsgL(player, "TPR_NoClan_NoFriend_NoTeam");
            }
        }

        private void CommandTeleportAccept(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            if (!config.Settings.TPREnabled) { user.Reply("TPR is not enabled in the config."); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermTpR)) return;
            DestroyTeleportRequestCUI(player);
            if (args.Length != 0)
            {
                PrintMsgL(player, "SyntaxCommandTPA");
                return;
            }
            Timer reqTimer;
            if (!PendingRequests.TryGetValue(player.userID, out reqTimer))
            {
                PrintMsgL(player, "NoPendingRequest");
                DestroyTeleportRequestCUI(player);
                return;
            }
#if DEBUG
            Puts("Calling CheckPlayer from cmdChatTeleportAccept");
#endif
            string err = null;
            var originPlayer = PlayersRequests[player.userID];
            if (originPlayer == null)
            {
                PrintMsgL(player, "NoPendingRequest");
                return;
            }
            if (!CanBypassRestrictions(player.UserIDString))
            {
                if (!TeleportInForcedBoundary(originPlayer, player))
                {
                    return;
                }
                err = CheckPlayer(player, config.TPR.UsableIntoBuildingBlocked, CanCraftTPR(player), false, "tpa");
                if (err != null)
                {
                    PrintMsgL(player, err);
                    return;
                }
                err = CheckPlayer(originPlayer, config.TPR.UsableOutOfBuildingBlocked, CanCraftTPR(originPlayer), true, "tpa");
                if (err != null)
                {
                    PrintMsgL(originPlayer, err);
                    return;
                }
                err = CheckTargetLocation(originPlayer, player.transform.position, config.TPR.UsableIntoBuildingBlocked, config.TPR.CupOwnerAllowOnBuildingBlocked);
                if (err != null)
                {
                    PrintMsgL(player, err);
                    return;
                }
                err = CanPlayerTeleport(player, originPlayer.transform.position, player.transform.position);
                if (err != null)
                {
                    SendReply(player, err);
                    return;
                }
                if (config.TPR.BlockTPAOnCeiling)
                {
                    BaseEntity entity;
                    if (IsStandingOnEntity(player.transform.position, Layers.Mask.Construction, out entity, new string[2] { "floor", "roof" }))
                    {
                        PrintMsgL(player, "HomeNoFoundation");
                        return;
                    }
                    if (IsBlockedOnIceberg(player.transform.position))
                    {
                        PrintMsgL(player, "HomeIce");
                        return;
                    }
                }
                float globalCooldownTime = GetGlobalCooldown(player);
                if (globalCooldownTime > 0f)
                {
                    PrintMsgL(player, "WaitGlobalCooldown", FormatTime(player, (int)globalCooldownTime));
                    return;
                }
                if (config.Settings.BlockAuthorizedTeleporting && player.IsBuildingAuthed())
                {
                    PrintMsgL(player, "CannotTeleportFromHome");
                    return;
                }
            }
            var countdown = GetLower(originPlayer, config.TPR.VIPCountdowns, config.TPR.Countdown);
            PrintMsgL(originPlayer, "Accept", player.displayName, countdown);
            PrintMsgL(player, "AcceptTarget", originPlayer.displayName);
            if (config.TPR.PlaySoundsWhenTargetAccepts)
            {
                SendEffect(originPlayer, config.TPR.TeleportAcceptEffects);
            }
            var timestamp = Facepunch.Math.Epoch.Current;
            TeleportTimers[originPlayer.userID] = new TeleportTimer
            {
                OriginPlayer = originPlayer,
                TargetPlayer = player,
                Timer = timer.Once(countdown, () =>
                {
#if DEBUG
                    Puts("Calling CheckPlayer from cmdChatTeleportAccept timer loop");
#endif
                    if (!CanBypassRestrictions(player.UserIDString))
                    {
                        if (!TeleportInForcedBoundary(originPlayer, player))
                        {
                            return;
                        }
                        if (config.Settings.BlockAuthorizedTeleporting && player.IsBuildingAuthed())
                        {
                            PrintMsgL(player, "CannotTeleportFromHome");
                            return;
                        }
                        err = CheckPlayer(originPlayer, config.TPR.UsableOutOfBuildingBlocked, CanCraftTPR(originPlayer), true, "tpa") ?? CheckPlayer(player, false, CanCraftTPR(player), true, "tpa");
                        if (err != null)
                        {
                            PrintMsgL(player, "InterruptedTarget", originPlayer.displayName);
                            PrintMsgL(originPlayer, "Interrupted");
                            PrintMsgL(originPlayer, err);
                            TeleportTimers.Remove(originPlayer.userID);
                            return;
                        }
                        err = CheckTargetLocation(originPlayer, player.transform.position, config.TPR.UsableIntoBuildingBlocked, config.TPR.CupOwnerAllowOnBuildingBlocked);
                        if (err != null)
                        {
                            PrintMsgL(player, err);
                            PrintMsgL(originPlayer, "Interrupted");
                            PrintMsgL(originPlayer, err);
                            TeleportTimers.Remove(originPlayer.userID);
                            return;
                        }
                        err = CanPlayerTeleport(originPlayer, player.transform.position, originPlayer.transform.position);
                        if (err != null)
                        {
                            SendReply(player, err);
                            PrintMsgL(originPlayer, "Interrupted");
                            SendReply(originPlayer, err);
                            TeleportTimers.Remove(originPlayer.userID);
                            return;
                        }
                        err = CheckItems(originPlayer);
                        if (err != null)
                        {
                            PrintMsgL(player, "InterruptedTarget", originPlayer.displayName);
                            PrintMsgL(originPlayer, "Interrupted");
                            PrintMsgL(originPlayer, "TPBlockedItem", err);
                            TeleportTimers.Remove(originPlayer.userID);
                            return;
                        }
                        if (UseEconomy())
                        {
                            if (config.TPR.Pay > -1)
                            {
                                if (!CheckEconomy(originPlayer, config.TPR.Pay))
                                {
                                    if (config.TPR.Pay > 0)
                                    {
                                        PrintMsgL(originPlayer, "TPNoMoney", config.TPR.Pay);
                                    }

                                    PrintMsgL(player, "InterruptedTarget", originPlayer.displayName);
                                    TeleportTimers.Remove(originPlayer.userID);
                                    return;
                                }
                                else
                                {
                                    CheckEconomy(originPlayer, config.TPR.Pay, true);

                                    if (config.TPR.Pay > 0)
                                    {
                                        PrintMsgL(originPlayer, "TPMoney", (double)config.TPR.Pay);
                                    }
                                }
                            }
                        }
                    }
                    Teleport(originPlayer, player.transform.position, config.TPR.AllowTPB, config.TPR.UsableOutOfBuildingBlocked, CanCraftTPR(player));
                    var tprData = _TPR[originPlayer.userID];
                    tprData.Amount++;
                    tprData.Timestamp = timestamp;
                    changedTPR = true;
                    PrintMsgL(player, "SuccessTarget", originPlayer.displayName);
                    PrintMsgL(originPlayer, "Success", player.displayName);
                    var limit = GetHigher(originPlayer, config.TPR.VIPDailyLimits, config.TPR.DailyLimit, true);
                    if (limit > 0) PrintMsgL(originPlayer, "TPRAmount", limit - tprData.Amount);
                    TeleportTimers.Remove(originPlayer.userID);
                })
            };
            reqTimer.Destroy();
            PendingRequests.Remove(player.userID);
            PlayersRequests.Remove(player.userID);
            PlayersRequests.Remove(originPlayer.userID);
        }

        private void CommandWipeHomes(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermWipeHomes)) return;
            if (_Home.Count > 0) Puts("{0} ({1}) wiped homes", player.displayName, player.userID);
            _Home.Clear();
            changedHome = true;
            PrintMsgL(player, "HomesListWiped");
        }

        private void CommandTeleportHelp(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!player || !player.IsConnected || player.IsSleeping()) return;
            if (!config.Settings.HomesEnabled && !config.Settings.TPREnabled && !IsAllowedMsg(player)) return;
            if (args.Length == 1)
            {
                var key = $"TPHelp{args[0].ToLower()}";
                var msg = _(key, player);
                if (key.Equals(msg))
                    PrintMsgL(player, "InvalidHelpModule");
                else
                    PrintMsg(player, msg);
            }
            else
            {
                var msg = _("TPHelpGeneral", player);
                if (IsAllowed(player))
                    msg += NewLine + "/tphelp AdminTP";
                if (config.Settings.HomesEnabled)
                    msg += NewLine + "/tphelp Home";
                if (config.Settings.TPREnabled)
                    msg += NewLine + "/tphelp TPR";
                PrintMsg(player, msg);
            }
        }

        private List<string> _tpid = new List<string> { "home", "bandit", "outpost", "tpr", "town" };

        private void CommandTeleportInfo(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!player || !player.IsConnected || player.IsSleeping() || !TeleportInForcedBoundary(player)) return;
            if (args.Length == 1)
            {
                var module = args[0].ToLower();
                var settings = GetSettings(module);
                var msg = _(_tpid.Contains(module) || settings == null ? $"TPSettings{module}" : "TPSettingsdynamic", player);
                var timestamp = Facepunch.Math.Epoch.Current;
                var currentDate = DateTime.Now.ToString("d");
                int limit;
                int cooldown;

                switch (module)
                {
                    case "home":
                        if (!IsAllowedMsg(player, PermHome)) return;
                        limit = GetHigher(player, config.Home.VIPDailyLimits, config.Home.DailyLimit, true);
                        cooldown = GetLower(player, config.Home.VIPCooldowns, config.Home.Cooldown);
                        int homeLimits = GetHigher(player, config.Home.VIPHomesLimits, config.Home.HomesLimit, true);
                        PrintMsg(player, string.Format(msg, FormatTime(player, cooldown), limit > 0 ? limit.ToString() : _("Unlimited", player), homeLimits));
                        HomeData homeData;
                        if (!_Home.TryGetValue(player.userID, out homeData))
                            _Home[player.userID] = homeData = new HomeData();
                        if (homeData.Teleports.Date != currentDate)
                        {
                            homeData.Teleports.Amount = 0;
                            homeData.Teleports.Date = currentDate;
                        }
                        if (limit > 0) PrintMsgL(player, "HomeTPAmount", limit - homeData.Teleports.Amount);
                        if (cooldown > 0 && timestamp - homeData.Teleports.Timestamp < cooldown)
                        {
                            var remain = cooldown - (timestamp - homeData.Teleports.Timestamp);
                            PrintMsgL(player, "HomeTPCooldown", FormatTime(player, remain));
                        }
                        break;
                    case "tpr":
                        if (!IsAllowedMsg(player, PermTpR)) return;
                        limit = GetHigher(player, config.TPR.VIPDailyLimits, config.TPR.DailyLimit, true);
                        cooldown = GetLower(player, config.TPR.VIPCooldowns, config.TPR.Cooldown);
                        PrintMsg(player, string.Format(msg, FormatTime(player, cooldown), limit > 0 ? limit.ToString() : _("Unlimited", player)));
                        TeleportData tprData;
                        if (!_TPR.TryGetValue(player.userID, out tprData))
                            _TPR[player.userID] = tprData = new TeleportData();
                        if (tprData.Date != currentDate)
                        {
                            tprData.Amount = 0;
                            tprData.Date = currentDate;
                        }
                        if (limit > 0) PrintMsgL(player, "TPRAmount", limit - tprData.Amount);
                        if (cooldown > 0 && timestamp - tprData.Timestamp < cooldown)
                        {
                            var remain = cooldown - (timestamp - tprData.Timestamp);
                            PrintMsgL(player, "TPRCooldown", FormatTime(player, remain));
                        }
                        break;
                    default: // town island outpost bandit etc
                        if (settings == null)
                        {
                            PrintMsgL(player, "InvalidHelpModule");
                            break;
                        }

                        limit = GetHigher(player, settings.VIPDailyLimits, settings.DailyLimit, true);
                        cooldown = GetLower(player, settings.VIPCooldowns, settings.Cooldown);
                        if (_tpid.Contains(module)) PrintMsg(player, string.Format(msg, FormatTime(player, cooldown), limit > 0 ? limit.ToString() : _("Unlimited", player)));
                        else PrintMsg(player, string.Format(msg, module.SentenceCase(), FormatTime(player, cooldown), limit > 0 ? limit.ToString() : _("Unlimited", player)));
                        TeleportData tpData;
                        if (!settings.Teleports.TPData.TryGetValue(player.userID, out tpData))
                            settings.Teleports.TPData[player.userID] = tpData = new TeleportData();
                        if (tpData.Date != currentDate)
                        {
                            tpData.Amount = 0;
                            tpData.Date = currentDate;
                        }
                        var language = lang.GetMessage(settings.Command, this, user.Id);
                        if (limit > 0) PrintMsgL(player, "DM_TownTPAmount", limit - tpData.Amount, language);
                        if (!string.IsNullOrEmpty(config.Settings.BypassCMD) && cooldown > 0 && timestamp - tpData.Timestamp < cooldown)
                        {
                            if (Interface.CallHook("OnTeleportCooldownNotify", player) != null)
                            {
                                break;
                            }

                            var remain = cooldown - (timestamp - tpData.Timestamp);
                            PrintMsgL(player, "DM_TownTPCooldown", FormatTime(player, remain));

                            if (settings.Bypass > 0)
                            {
                                PrintMsgL(player, "DM_TownTPCooldownBypassP", settings.Bypass);
                                PrintMsgL(player, "DM_TownTPCooldownBypassP2", language, config.Settings.BypassCMD);
                            }
                        }
                        break;
                }
            }
            else
            {
                var msg = _("TPInfoGeneral", player);
                if (config.Settings.HomesEnabled && IsAllowed(player, PermHome))
                    msg += NewLine + "/tpinfo Home";
                if (config.Settings.TPREnabled && IsAllowed(player, PermTpR))
                    msg += NewLine + "/tpinfo TPR";
                foreach (var entry in config.DynamicCommands)
                {
                    if (entry.Value.Enabled)
                    {
                        if (command == "bandit" && !banditEnabled) continue;
                        if (command == "outpost" && !outpostEnabled) continue;
                        if (!IsAllowed(player, $"{Name}.tp{entry.Key}")) continue;
                        msg += NewLine + $"/tpinfo {entry.Key}";
                    }
                }
                PrintMsgL(player, msg);
            }
        }

        private void CommandTeleportCancel(IPlayer user, string command, string[] args)
        {
            var player = user.Object as BasePlayer;
            if (!player || !player.IsConnected || player.IsSleeping()) return;
            DestroyTeleportRequestCUI(player);
            if (args.Length != 0)
            {
                PrintMsgL(player, "SyntaxCommandTPC");
                return;
            }
            TeleportTimer teleportTimer;
            if (TeleportTimers.TryGetValue(player.userID, out teleportTimer))
            {
                teleportTimer.Timer?.Destroy();
                PrintMsgL(player, "TPCancelled");
                PrintMsgL(teleportTimer.TargetPlayer, "TPCancelledTarget", player.displayName);
                TeleportTimers.Remove(player.userID);
                return;
            }
            foreach (var keyValuePair in TeleportTimers)
            {
                if (keyValuePair.Value.TargetPlayer != player) continue;
                keyValuePair.Value.Timer?.Destroy();
                PrintMsgL(keyValuePair.Value.OriginPlayer, "TPCancelledTarget", player.displayName);
                PrintMsgL(player, "TPYouCancelledTarget", keyValuePair.Value.OriginPlayer.displayName);
                TeleportTimers.Remove(keyValuePair.Key);
                return;
            }
            BasePlayer target;
            if (!PlayersRequests.TryGetValue(player.userID, out target))
            {
                PrintMsgL(player, "NoPendingRequest");
                return;
            }
            Timer reqTimer;
            if (PendingRequests.TryGetValue(player.userID, out reqTimer))
            {
                reqTimer.Destroy();
                PendingRequests.Remove(player.userID);
            }
            else if (PendingRequests.TryGetValue(target.userID, out reqTimer))
            {
                reqTimer.Destroy();
                PendingRequests.Remove(target.userID);
                var temp = player;
                player = target;
                target = temp;
            }
            PlayersRequests.Remove(target.userID);
            PlayersRequests.Remove(player.userID);
            PrintMsgL(player, "Cancelled", target.displayName);
            PrintMsgL(target, "CancelledTarget", player.displayName);
        }

        private void CommandDynamic(IPlayer user, string command, string[] args)
        {
            if (!user.HasPermission(PermAdmin) || args.Length != 2 || args[0].Equals("list", StringComparison.OrdinalIgnoreCase))
            {
                CommandTeleportInfo(user, command, args.Skip(1).ToArray());
                return;
            }

            var value = args[1].ToLower();

            if (args[0].Equals("add", StringComparison.OrdinalIgnoreCase))
            {
                TownSettings settings;
                if (GetSettings(value) == null)
                {
                    config.DynamicCommands.Add(value, settings = new TownSettings());
                    RegisterCommand(value, settings, true);
                    RegisterCommand(value, nameof(CommandCustom));
                    PrintMsgL(user, "DM_TownTPCreated", value);
                    SaveConfig();
                }
                else PrintMsgL(user, "DM_TownTPExists", value);
            }
            else if (args[0].Equals("remove", StringComparison.OrdinalIgnoreCase))
            {
                var key = config.DynamicCommands.Keys.FirstOrDefault(x => x.Equals(value, StringComparison.OrdinalIgnoreCase));

                if (!string.IsNullOrEmpty(key))
                {
                    PrintMsgL(user, "DM_TownTPRemoved", key);
                    config.DynamicCommands.Remove(key);
                    UnregisterCommand(value);
                    SaveConfig();
                }
                else PrintMsgL(user, "DM_TownTPDoesNotExist", value);
            }
            else CommandTeleportInfo(user, command, args);
        }

        private void CommandCustom(IPlayer user, string command, string[] args)
        {
            CommandTown(user, command, args);
        }

        private TownSettings GetSettings(string command, ulong userid = 0uL)
        {
            if (command.Equals("home", StringComparison.OrdinalIgnoreCase) && _Home.ContainsKey(userid))
            {
                return new TownSettings
                {
                    VIPCooldowns = config.Home.VIPCooldowns,
                    Cooldown = config.Home.Cooldown,
                    Countdown = config.Home.Countdown,
                    Teleports = new StoredData
                    {
                        TPData = new Dictionary<ulong, TeleportData>
                        {
                            [userid] = _Home[userid].Teleports
                        }
                    }
                };
            }

            if (command.Equals("tpr", StringComparison.OrdinalIgnoreCase) && _TPR.ContainsKey(userid))
            {
                return new TownSettings
                {
                    VIPCooldowns = config.TPR.VIPCooldowns,
                    Cooldown = config.TPR.Cooldown,
                    Countdown = config.TPR.Countdown,
                    Teleports = new StoredData
                    {
                        TPData = new Dictionary<ulong, TeleportData>
                        {
                            [userid] = _TPR[userid]
                        }
                    }
                };
            }

            foreach (var x in config.DynamicCommands)
            {
                if (x.Key.Equals(command, StringComparison.OrdinalIgnoreCase))
                {
                    return x.Value;
                }
            }

            return null;
        }

        private bool IsServerCommand(IPlayer user, string command, string[] args)
        {
            if (!user.IsServer)
            {
                return false;
            }
            var settings = GetSettings(command);
            if (settings == null)
            {
                user.Reply($"Command '{command}' not found in config.");
                return false;
            }
            if (args.Length == 0)
            {
                string positions = string.Join(", ", settings.Locations.ToArray());
                user.Reply($"{command} locations: {positions}");
                return true;
            }
            if (args[0] == "clear")
            {
                settings.Location = Vector3.zero;
                settings.Locations.Clear();
                user.Reply($"{command} locations have been cleared.");
            }
            else
            {
                try
                {
                    var vector = string.Join(" ", args).ToVector3();
                    if (vector == Vector3.zero)
                    {
                        throw new InvalidCastException("vector");
                    }
                    if (!settings.Locations.Contains(vector))
                    {
                        settings.Locations.Insert(0, vector);
                        user.Reply($"{command} location manually set to: " + vector);
                    }
                    else user.Reply($"{command} location was already set to: " + vector);
                    settings.Location = vector;
                }
                catch
                {
                    user.Reply($"Invalid position specified ({string.Join(" ", args)})");
                    return true;
                }
            }
            if (command == "bandit")
            {
                banditEnabled = settings.Locations.Count > 0;
            }
            if (command == "outpost")
            {
                outpostEnabled = settings.Locations.Count > 0;
            }
            SaveConfig();
            return true;
        }

        private void CommandTown(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command)) { user.Reply("Disabled command: " + command); return; }
            if (IsServerCommand(user, command, args)) return;
            var player = user.Object as BasePlayer;
#if DEBUG
            Puts($"cmdChatTown: command={command}");
#endif
            if (!IsAllowedMsg(player, $"{Name}.tp{command}".ToLower()) || !TeleportInForcedBoundary(player)) return;

            if (!CanBypassRestrictions(player.UserIDString))
            {
                float globalCooldownTime = GetGlobalCooldown(player);
                if (globalCooldownTime > 0f)
                {
                    PrintMsgL(player, "WaitGlobalCooldown", FormatTime(player, (int)globalCooldownTime));
                    return;
                }

                if (config.Settings.BlockAuthorizedTeleporting && player.IsBuildingAuthed())
                {
                    PrintMsgL(player, "CannotTeleportFromHome");
                    return;
                }
            }

            var settings = GetSettings(command);

            if (settings == null)
            {
                return;
            }

            var language = lang.GetMessage(settings.Command, this, user.Id);

            // For admin using set, add, clear or show command locations
            if (args.Length >= 1 && IsAllowed(player, PermAdmin))
            {
                var param = args[0].ToLower();

                if (param.Equals("clear"))
                {
                    settings.Location = Vector3.zero;
                    settings.Locations.Clear();
                    SaveConfig();
                    PrintMsgL(player, "DM_TownTPLocationsCleared", language);
                    return;
                }
                else if (param.Equals("set"))
                {
                    if (settings.Locations.Count > 0)
                    {
                        settings.Locations.RemoveAt(0);
                    }
                    var position = player.transform.position;
                    settings.Locations.Insert(0, settings.Location = position);
                    SaveConfig();
                    PrintMsgL(player, "DM_TownTPLocation", language, position);
                    return;
                }
                else if (param.Equals("add"))
                {
                    var position = player.transform.position;
                    int num = settings.Locations.RemoveAll(x => Vector3.Distance(position, x) < 25f);
                    settings.Locations.Add(position);
                    SaveConfig();
                    PrintMsgL(player, "DM_TownTPLocation", language, position);
                    return;
                }
                else if (args[0].Equals("show", StringComparison.OrdinalIgnoreCase))
                {
                    settings.Locations.ForEach(x => player.SendConsoleCommand("ddraw.text", 30f, Color.green, x, command));
                    return;
                }
            }

            bool paidmoney = false;

            // Is command usage enabled?
            if (!settings.Enabled)
            {
                PrintMsgL(player, "DM_TownTPDisabled", language.SentenceCase());
                return;
            }

            if (settings.Location != Vector3.zero && !settings.Locations.Contains(settings.Location))
            {
                settings.Locations.Add(settings.Location);
            }

            // Is location set?
            if (settings.Locations.Count == 0)
            {
                PrintMsgL(player, "DM_TownTPNoLocation", language.SentenceCase());
                return;
            }

            // Are they trying to bypass cooldown or did they just type something else?
            if (args.Length == 1 && !string.IsNullOrEmpty(config.Settings.BypassCMD) && args[0].ToLower() != config.Settings.BypassCMD.ToLower() && !args[0].All(char.IsDigit))
            {
                string com = command ?? "town";
                string msg = "SyntaxCommand" + char.ToUpper(com[0]) + com.Substring(1);
                PrintMsgL(player, msg);
                if (IsAllowed(player)) PrintMsgL(player, msg + "Admin");
                return;
            }

            TeleportData teleportData;
            if (!settings.Teleports.TPData.TryGetValue(player.userID, out teleportData))
            {
                settings.Teleports.TPData[player.userID] = teleportData = new TeleportData();
            }
            int limit = 0;
            var timestamp = Facepunch.Math.Epoch.Current;
            var currentDate = DateTime.Now.ToString("d");

            // Setup vars for checks below
            string err = null;
            if (!CanBypassRestrictions(player.UserIDString))
            {
                var getUseableTime = GetUseableTime(settings.Hours);
                if (getUseableTime > 0.0)
                {
                    PrintMsgL(player, "NotUseable", FormatTime(player, getUseableTime));
                    return;
                }
                err = CheckPlayer(player, settings.UsableOutOfBuildingBlocked, settings.CanCraft(player, command), true, command);
                if (err != null)
                {
                    PrintMsgL(player, err);
                    return;
                }
                var cooldown = GetLower(player, settings.VIPCooldowns, settings.Cooldown);

                if (teleportData.Date != currentDate)
                {
                    teleportData.Amount = 0;
                    teleportData.Date = currentDate;
                }
                limit = GetHigher(player, settings.VIPDailyLimits, settings.DailyLimit, true);
#if DEBUG
                Puts("Calling CheckPlayer from cmdChatTown");
#endif

                // Check and process cooldown, bypass, and payment for all modes
                if (cooldown > 0 && timestamp - teleportData.Timestamp < cooldown)
                {
                    var cmdSent = args.Length >= 1 ? args[0].ToLower() : string.Empty;

                    if (!string.IsNullOrEmpty(config.Settings.BypassCMD))
                    {
                        if (cmdSent == config.Settings.BypassCMD.ToLower() && settings.Bypass > -1)
                        {
                            bool foundmoney = CheckEconomy(player, settings.Bypass);

                            if (foundmoney)
                            {
                                CheckEconomy(player, settings.Bypass, true);
                                paidmoney = true;

                                if (settings.Bypass > 0)
                                {
                                    PrintMsgL(player, "DM_TownTPCooldownBypass", settings.Bypass);
                                }

                                if (settings.Pay > 0)
                                {
                                    PrintMsgL(player, "PayToTown", settings.Pay, language);
                                }
                            }
                            else
                            {
                                PrintMsgL(player, "DM_TownTPCooldownBypassF", settings.Bypass);
                                return;
                            }
                        }
                        else if (UseEconomy())
                        {
                            if (Interface.CallHook("OnTeleportCooldownNotify", player) != null)
                            {
                                return;
                            }
                            var remain = cooldown - (timestamp - teleportData.Timestamp);
                            PrintMsgL(player, "DM_TownTPCooldown", FormatTime(player, remain));
                            if (settings.Bypass > -1)
                            {
                                PrintMsgL(player, "DM_TownTPCooldownBypassP", settings.Bypass);
                                PrintMsgL(player, "DM_TownTPCooldownBypassP2", language, config.Settings.BypassCMD);
                            }
                            return;
                        }
                        else
                        {
                            if (Interface.CallHook("OnTeleportCooldownNotify", player) != null)
                            {
                                return;
                            }
                            var remain = cooldown - (timestamp - teleportData.Timestamp);
                            PrintMsgL(player, "DM_TownTPCooldown", FormatTime(player, remain));
                            return;
                        }
                    }
                    else
                    {
                        if (Interface.CallHook("OnTeleportCooldownNotify", player) != null)
                        {
                            return;
                        }
                        var remain = cooldown - (timestamp - teleportData.Timestamp);
                        PrintMsgL(player, "DM_TownTPCooldown", FormatTime(player, remain));
                        return;
                    }
                }

                if (limit > 0 && teleportData.Amount >= limit)
                {
                    var left = FormatTime(player, (int)SecondsUntilTomorrow());
                    PrintMsgL(player, "DM_TownTPLimitReached", limit, left);
                    return;
                }
            }
            if (TeleportTimers.ContainsKey(player.userID))
            {
                PrintMsgL(player, "TeleportPendingTPC");
                return;
            }

            Vector3 location;
            int index;
            if (args.Length == 1 && int.TryParse(args[0], out index))
            {
                index = Mathf.Clamp(index, 0, settings.Locations.Count - 1);
                location = settings.Locations[index];
            }
            else if (settings.Random)
            {
                location = settings.Locations.GetRandom();
            }
            else location = settings.Locations.First();

            if (!CanBypassRestrictions(player.UserIDString))
            {
                err = CanPlayerTeleport(player, location, player.transform.position);
                if (err != null)
                {
                    SendReply(player, err);
                    return;
                }
                err = CheckItems(player);
                if (err != null)
                {
                    PrintMsgL(player, "TPBlockedItem", err);
                    return;
                }
            }
            int countdown = GetLower(player, settings.VIPCountdowns, settings.Countdown);
            TeleportTimers[player.userID] = new TeleportTimer
            {
                OriginPlayer = player,
                Timer = timer.Once(countdown, () =>
                {
#if DEBUG
                    Puts($"Calling CheckPlayer from cmdChatTown {command} timer loop");
#endif
                    if (!CanBypassRestrictions(player.UserIDString))
                    {
                        if (!TeleportInForcedBoundary(player))
                        {
                            return;
                        }
                        if (config.Settings.BlockAuthorizedTeleporting && player.IsBuildingAuthed())
                        {
                            PrintMsgL(player, "CannotTeleportFromHome");
                            return;
                        }
                        err = CheckPlayer(player, settings.UsableOutOfBuildingBlocked, settings.CanCraft(player, command.ToLower()), true, command.ToLower(), settings.AllowCave);
                        if (err != null)
                        {
                            Interrupt(player, paidmoney, settings.Bypass);
                            PrintMsgL(player, err);
                            return;
                        }
                        err = CanPlayerTeleport(player, location, player.transform.position);
                        if (err != null)
                        {
                            Interrupt(player, paidmoney, settings.Bypass);
                            PrintMsgL(player, err);
                            return;
                        }
                        err = CheckItems(player);
                        if (err != null)
                        {
                            Interrupt(player, paidmoney, settings.Bypass);
                            PrintMsgL(player, "TPBlockedItem", err);
                            return;
                        }
                        if (settings.Locations.Count == 0)
                        {
                            Interrupt(player, paidmoney, settings.Bypass);
                            return;
                        }
                        if (UseEconomy())
                        {
                            if (settings.Pay < 0)
                            {
                                return;
                            }
                            if (settings.Pay > 0 && !CheckEconomy(player, settings.Pay))
                            {
                                Interrupt(player, false, 0);
                                PrintMsgL(player, "TPNoMoney", settings.Pay);
                                return;
                            }
                            if (settings.Pay > -1 && !paidmoney)
                            {
                                CheckEconomy(player, settings.Pay, true);

                                if (settings.Pay > 0)
                                {
                                    PrintMsgL(player, "TPMoney", (double)settings.Pay);
                                }
                            }
                        }
                    }
                    Teleport(player, location, settings.AllowTPB, settings.UsableOutOfBuildingBlocked, settings.CanCraft(player, command));
                    teleportData.Amount++;
                    teleportData.Timestamp = timestamp;
                    settings.Teleports.Changed = true;
                    PrintMsgL(player, "DM_TownTP", language);
                    if (limit > 0) PrintMsgL(player, "DM_TownTPAmount", limit - teleportData.Amount, language);
                    TeleportTimers.Remove(player.userID);
                })
            };

            if (countdown > 0)
            {
                PrintMsgL(player, "DM_TownTPStarted", language, countdown);
            }
        }

        private double SecondsUntilTomorrow()
        {
            var tomorrow = DateTime.Now.AddDays(1).Date;
            return (tomorrow - DateTime.Now).TotalSeconds;
        }

        private void Interrupt(BasePlayer player, bool paidmoney, double bypass)
        {
            PrintMsgL(player, "Interrupted");
            if (paidmoney)
            {
                CheckEconomy(player, bypass, false, true);
            }
            TeleportTimers.Remove(player.userID);
        }

        private void CommandTeleportII(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!user.IsAdmin && !IsAllowedMsg(player, PermTpConsole)) return;

            List<BasePlayer> players;
            switch (command)
            {
                case "teleport.topos":
                    if (args.Length < 4)
                    {
                        user.Reply(_("SyntaxConsoleCommandToPos", player));
                        return;
                    }
                    players = FindPlayers(args[0], true);
                    if (players.Count <= 0)
                    {
                        user.Reply(_("PlayerNotFound", player));
                        return;
                    }
                    if (players.Count > 1)
                    {
                        user.Reply(_("MultiplePlayers", player, GetMultiplePlayers(players)));
                        return;
                    }
                    var targetPlayer = players.First();
                    players.Clear();
                    float x;
                    if (!float.TryParse(args[1], out x)) x = -10000f;
                    float y;
                    if (!float.TryParse(args[2], out y)) y = -10000f;
                    float z;
                    if (!float.TryParse(args[3], out z)) z = -10000f;
                    if (!CheckBoundaries(x, y, z))
                    {
                        user.Reply(_("AdminTPOutOfBounds", player) + System.Environment.NewLine + _("AdminTPBoundaries", player, boundary));
                        return;
                    }
                    Teleport(targetPlayer, x, y, z);
                    if (config.Admin.AnnounceTeleportToTarget)
                        PrintMsgL(targetPlayer, "AdminTPConsoleTP", targetPlayer.transform.position);
                    user.Reply(_("AdminTPTargetCoordinates", player, targetPlayer.displayName, targetPlayer.transform.position));
                    Puts(_("LogTeleportPlayer", null, player?.displayName, targetPlayer.displayName, targetPlayer.transform.position));
                    break;
                case "teleport.toplayer":
                    if (args.Length < 2)
                    {
                        user.Reply(_("SyntaxConsoleCommandToPlayer", player));
                        return;
                    }
                    players = FindPlayers(args[0], true);
                    if (players.Count <= 0)
                    {
                        user.Reply(_("PlayerNotFound", player));
                        return;
                    }
                    if (players.Count > 1)
                    {
                        user.Reply(_("MultiplePlayers", player, GetMultiplePlayers(players)));
                        return;
                    }
                    var originPlayer = players.First();
                    players = FindPlayers(args[1], true);
                    if (players.Count <= 0)
                    {
                        user.Reply(_("PlayerNotFound", player));
                        return;
                    }
                    if (players.Count > 1)
                    {
                        user.Reply(_("MultiplePlayers", player, GetMultiplePlayers(players)));
                        players.Clear();
                        return;
                    }
                    targetPlayer = players.First();
                    if (targetPlayer == originPlayer)
                    {
                        players.Clear();
                        user.Reply(_("CantTeleportPlayerToSelf", player));
                        return;
                    }
                    players.Clear();
                    Teleport(originPlayer, targetPlayer);
                    user.Reply(_("AdminTPPlayers", player, originPlayer.displayName, targetPlayer.displayName));
                    PrintMsgL(originPlayer, "AdminTPConsoleTPPlayer", targetPlayer.displayName);
                    if (config.Admin.AnnounceTeleportToTarget)
                        PrintMsgL(targetPlayer, "AdminTPConsoleTPPlayerTarget", originPlayer.displayName);
                    Puts(_("LogTeleportPlayer", null, player?.displayName, originPlayer.displayName, targetPlayer.displayName));
                    break;
            }
        }

        private void CommandSphereMonuments(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!player || !player.IsAdmin) return;
            foreach (var mi in monuments)
            {
                player.SendConsoleCommand("ddraw.sphere", 30f, Color.red, mi.position, mi.radius);
                player.SendConsoleCommand("ddraw.text", 30f, Color.blue, mi.position, $"<size=22>{mi.name}</size>");
            }
            foreach (var cave in caves)
            {
                string name = cave.Key.Contains(":") ? cave.Key.Substring(0, cave.Key.LastIndexOf(":")) : cave.Key.TrimEnd();
                player.SendConsoleCommand("ddraw.sphere", 30f, Color.black, cave.Value, 25f);
                player.SendConsoleCommand("ddraw.text", 30f, Color.cyan, cave.Value, $"<size=22>{name}</size>");
            }
        }

        private void CommandImportHomes(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;

            if (!user.IsAdmin && !IsAllowedMsg(player, PermImportHomes))
            {
                user.Reply(_("NotAllowed", player));
                return;
            }
            var fileName = string.IsNullOrEmpty(config.Settings.DataFileFolder) ? "m-Teleportation" : $"{config.Settings.DataFileFolder}{Path.DirectorySeparatorChar}m-Teleportation";
            var datafile = Interface.Oxide.DataFileSystem.GetFile(fileName);
            if (!datafile.Exists())
            {
                user.Reply("No m-Teleportation.json exists.");
                return;
            }
            datafile.Load();
            var allHomeData = datafile["HomeData"] as Dictionary<string, object>;
            if (allHomeData == null)
            {
                user.Reply(_("HomeListEmpty", player));
                return;
            }
            var count = 0;
            foreach (var kvp in allHomeData)
            {
                var homeDataOld = kvp.Value as Dictionary<string, object>;
                if (homeDataOld == null) continue;
                if (!homeDataOld.ContainsKey("HomeLocations")) continue;
                var homeList = homeDataOld["HomeLocations"] as Dictionary<string, object>;
                if (homeList == null) continue;
                var userId = Convert.ToUInt64(kvp.Key);
                HomeData homeData;
                if (!_Home.TryGetValue(userId, out homeData))
                    _Home[userId] = homeData = new HomeData();
                var target = RustCore.FindPlayerById(userId);
                foreach (var kvp2 in homeList)
                {
                    var positionData = kvp2.Value as Dictionary<string, object>;
                    if (positionData == null) continue;
                    if (!positionData.ContainsKey("x") || !positionData.ContainsKey("y") || !positionData.ContainsKey("z")) continue;
                    var position = new Vector3(Convert.ToSingle(positionData["x"]), Convert.ToSingle(positionData["y"]), Convert.ToSingle(positionData["z"]));
                    homeData.Set(kvp2.Key, new HomeData.Entry(position));
                    changedHome = true;
                    count++;
                    Interface.CallHook("OnHomeAdded", target, position, kvp2.Key);
                }
            }
            user.Reply(string.Format("Imported {0} homes.", count));
            if (!user.IsServer) Puts("Imported {0} homes.", count);
        }

        private void RequestTimedOut(BasePlayer player, BasePlayer target)
        {
            PlayersRequests.Remove(player.userID);
            PlayersRequests.Remove(target.userID);
            PendingRequests.Remove(target.userID);
            PrintMsgL(player, "TimedOut", target.displayName);
            PrintMsgL(target, "TimedOutTarget", player.displayName);
        }

        private void CommandPluginInfo(IPlayer user, string command, string[] args)
        {
            if (!user.IsServer) return;
            user.Reply($"01. {permission.GetPermissionGroups("nteleportation.tp").Count()}");
            user.Reply($"02. {permission.GetPermissionGroups("nteleportation.admin").Count()}");
            user.Reply($"03. {permission.GetPermissionUsers("nteleportation.tp").Count()}");
            user.Reply($"04. {permission.GetPermissionUsers("nteleportation.admin").Count()}");
            user.Reply($"05. {permission.GroupHasPermission("admin", "nteleportation.tp")}");
            user.Reply($"06. {permission.GroupHasPermission("admin", "nteleportation.admin")}");
            user.Reply($"07. {permission.GroupHasPermission("default", "nteleportation.tp")}");
            user.Reply($"08. {permission.GroupHasPermission("default", "nteleportation.admin")}");
            user.Reply($"09. {BasePlayer.activePlayerList.Count(x => x?.Connection?.authLevel > 0)}");
            user.Reply($"10. {BasePlayer.activePlayerList.Count(x => IsAllowed(x))}");
            user.Reply($"11. {BasePlayer.activePlayerList.Count}");
        }

        #region Util

        private readonly System.Text.StringBuilder _sb = new System.Text.StringBuilder();

        private string FormatTime(BasePlayer player, double seconds) // Credits MoNaH
        {
            if (config.Settings.UseSeconds) return $"{seconds} {_("Seconds", player)}";

            TimeSpan _ts = TimeSpan.FromSeconds(seconds);

            _sb.Length = 0;

            if (_ts.TotalDays >= 1)
            {
                _sb.Append($"<color={config.Settings.ChatCommandArgumentColor}>{_ts.Days}</color> {_("Days", player)} ");
            }

            if (_ts.TotalHours >= 1)
            {
                _sb.Append($"<color={config.Settings.ChatCommandArgumentColor}>{_ts.Hours}</color> {_("Hours", player)} ");
            }

            if (_ts.TotalMinutes >= 1)
            {
                _sb.Append($"<color={config.Settings.ChatCommandArgumentColor}>{_ts.Minutes}</color> {_("Minutes", player)} ");
            }

            _sb.Append($"<color={config.Settings.ChatCommandArgumentColor}>{_ts.Seconds}</color> {_("Seconds", player)} ");

            return _sb.ToString();
        }

        #endregion

        #region Teleport

        public void Teleport(BasePlayer player, BasePlayer target, bool build = true, bool craft = true) => Teleport(player, target.transform.position, true, build, craft);

        public void Teleport(BasePlayer player, float x, float y, float z, bool build = true, bool craft = true) => Teleport(player, new Vector3(x, y, z), true, build, craft);

        [HookMethod("Teleport")]
        public void Teleport(BasePlayer player, Vector3 newPosition, bool allowTPB, bool build = true, bool craft = true)
        {
            if (!player.IsValid() || Vector3.Distance(newPosition, Vector3.zero) < 5f) return;
            if (allowTPB)
            {
                if (config.Settings.TPB.Time > 0)
                {
                    RemoveLocation(player);
                    Vector3 position = player.transform.position;
                    timer.In(config.Settings.TPB.Time, () => SaveLocation(player, position, build, craft));
                }
                else SaveLocation(player, player.transform.position, build, craft);
            }

            if (config.Settings.PlaySoundsBeforeTeleport)
            {
                SendEffect(player, config.Settings.DisappearEffects);
            }

            newPosition.y += 0.1f;

            teleporting[player.userID] = newPosition;

            Subscribe(nameof(OnPlayerViolation));

            var oldPosition = player.transform.position;

            // credits to @ctv and @Def for their assistance

            player.PauseFlyHackDetection(5f);
            player.PauseSpeedHackDetection(5f);
            player.UpdateActiveItem(default(ItemId));
            player.EnsureDismounted();
            player.Server_CancelGesture();

            if (player.HasParent())
            {
                player.SetParent(null, true, true);
            }

            if (player.IsConnected)
            {
                StartSleeping(player);
                player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
                player.ClientRPCPlayer(null, player, config.Settings.Quick ? "StartLoading_Quick" : "StartLoading", arg1: true);
            }

            player.Teleport(newPosition);

            if (player.IsConnected)
            {
                if (!player._limitedNetworking)
                {
                    player.UpdateNetworkGroup();
                    player.SendNetworkUpdateImmediate(false);
                }

                player.ClearEntityQueue(null);
                player.SendFullSnapshot();
                if (config.Settings.AutoWakeUp && player.IsOnGround())
                {
                    NextTick(player.EndSleeping);
                }
            }

            if (!player._limitedNetworking)
            {
                player.ForceUpdateTriggers();
            }

            timer.Once(3f, () => RemoveProtections(player.userID));

            SetGlobalCooldown(player);

            if (config.Settings.PlaySoundsAfterTeleport)
            {
                SendEffect(player, config.Settings.ReappearEffects);
            }

            Interface.CallHook("OnPlayerTeleported", player, oldPosition, newPosition);
        }

        public void RemoveProtections(ulong userid)
        {
            teleporting.Remove(userid);
            insideTerrainViolations.Remove(userid);
        }

        public void StartSleeping(BasePlayer player) // custom as to not cancel crafting, or remove player from vanish
        {
            if (!player.IsSleeping())
            {
                Interface.CallHook("OnPlayerSleep", player);
                player.SetPlayerFlag(BasePlayer.PlayerFlags.Sleeping, b: true);
                player.sleepStartTime = Time.time;
                BasePlayer.sleepingPlayerList.Add(player);
                player.CancelInvoke("InventoryUpdate");
                player.CancelInvoke("TeamUpdate");
                player.inventory.loot.Clear();
                player.inventory.containerMain.OnChanged();
                player.inventory.containerBelt.OnChanged();
                player.inventory.containerWear.OnChanged();
                player.Invoke("TurnOffAllLights", 0f);
                if (!player._limitedNetworking)
                {
                    player.EnablePlayerCollider();
                    player.RemovePlayerRigidbody();
                }
                else player.RemoveFromTriggers();
                player.SetServerFall(wantsOn: true);
            }
        }

        private void OnMapMarkerAdded(BasePlayer player, ProtoBuf.MapNote note)
        {
            if (player.IsAlive() && permission.UserHasPermission(player.UserIDString, PermTpMarker))
            {
                float y = TerrainMeta.HeightMap.GetHeight(note.worldPosition);
                if (player.IsFlying) y = Mathf.Max(y, player.transform.position.y);
                player.Teleport(note.worldPosition + new Vector3(0f, y, 0f));
            }
        }

        #endregion

        #region Checks
        private string CanPlayerTeleport(BasePlayer player, params Vector3[] vectors)
        {
            if (CanBypassRestrictions(player.UserIDString)) return null;
            foreach (var to in vectors)
            {
                var err = Interface.Oxide.CallHook("CanTeleport", player, to) as string;
                if (!string.IsNullOrEmpty(err)) return err;
            }
            return null;
        }

        private bool CanCraftHome(BasePlayer player)
        {
            return config.Home.AllowCraft || permission.UserHasPermission(player.UserIDString, PermCraftHome) || CanBypassRestrictions(player.UserIDString);
        }

        private bool CanCraftTPR(BasePlayer player)
        {
            return config.TPR.AllowCraft || permission.UserHasPermission(player.UserIDString, PermCraftTpR) || CanBypassRestrictions(player.UserIDString);
        }

        private List<string> monumentExceptions = new List<string> { "outpost", "bandit", "substation", "swamp", "compound.prefab" };

        private bool IsInAllowedMonument(Vector3 target, string mode)
        {
            foreach (var mi in monuments)
            {                
                if (config.Settings.Interrupt.BypassMonumentMarker && mi.prefab.Contains("monument_marker"))
                {
                    continue;
                }
                if (Vector3Ex.Distance2D(target, mi.position) <= mi.radius || mi.IsInBounds(target))
                {
                    if (monumentExceptions.Exists(mi.name.ToLower().Contains))
                    {
                        return true;
                    }
                    return !config.Settings.Interrupt.Monument || mode != "sethome" && config.Settings.Interrupt.Monuments.Exists(value => mi.name.Contains(value, CompareOptions.OrdinalIgnoreCase));
                }
            }
            return false;
        }

        private string NearMonument(Vector3 target, bool check, string mode)
        {
            foreach (var mi in monuments)
            {
                if (monumentExceptions.Exists(mi.name.ToLower().Contains)) continue;
                if (!check && config.Settings.Interrupt.BypassMonumentMarker && mi.prefab.Contains("monument_marker")) continue;

                float dist = Vector3Ex.Distance2D(target, mi.position);
#if DEBUG
                Puts($"Checking {mi.name} dist: {dist}, realdistance: {mi.radius}, size: {mi.monument?.Bounds.size.Max()}");
#endif
                if (dist <= mi.radius || mi.IsInBounds(target))
                {
                    if (config.Home.AllowedMonuments.Any(m => mi.name.Equals(m, StringComparison.OrdinalIgnoreCase)))
                    {
                        return null;
                    }

                    if (config.Settings.Interrupt.Monuments.Count > 0 && mode != "sethome")
                    {
                        if (config.Settings.Interrupt.Monuments.Exists(value => mi.name.Contains(value, CompareOptions.OrdinalIgnoreCase)))
                        {
#if DEBUG
                            Puts($"{target} in range of {mi.name}");
#endif
                            return mi.name;
                        }

#if DEBUG
                        Puts($"{target} is not blocked from {mi.name}");
#endif
                        return null;
                    }
#if DEBUG
                    Puts($"{target} in range of {mi.name}");
#endif
                    return mi.name;
                }
            }

            return null;
        }

        private string CheckPlayer(BasePlayer player, bool build = false, bool craft = false, bool origin = true, string mode = "home", bool allowcave = true)
        {
            if (CanBypassRestrictions(player.UserIDString)) return null;
            if (config.Settings.Interrupt.Oilrig || config.Settings.Interrupt.Excavator || config.Settings.Interrupt.Monument || mode == "sethome")
            {
                string monname = !config.Settings.Interrupt.Safe && player.InSafeZone() ? null : NearMonument(player.transform.position, false, mode);

                if (!string.IsNullOrEmpty(monname))
                {
                    if (mode == "sethome")
                    {
                        if (config.Home.AllowAtAllMonuments || config.Home.AllowedMonuments.Exists(value => monname.Contains(value, CompareOptions.OrdinalIgnoreCase)))
                        {
                            return null;
                        }

                        return "HomeTooCloseToMon";
                    }
                    else
                    {
                        if (config.Settings.Interrupt.Oilrig && monname.Contains("Oil Rig"))
                        {
                            return "TPOilRig";
                        }

                        if (config.Settings.Interrupt.Excavator && monname.Contains("Excavator"))
                        {
                            return "TPExcavator";
                        }

                        if (config.Settings.Interrupt.Monument)
                        {
                            if (config.Home.AllowedMonuments.Exists(value => monname.Contains(value, CompareOptions.OrdinalIgnoreCase)))
                            {
                                return null;
                            }

                            if (monname.Contains(":")) monname = monname.Substring(0, monname.IndexOf(":"));
                            return _("TooCloseToMon", player, _(monname, player));
                        }
                    }
                }
            }

#if DEBUG
            Puts($"CheckPlayer(): called mode is {mode}");
#endif
            switch (mode)
            {
                case "tpt":
                    allowcave = config.TPT.AllowCave;
                    break;
                case "home":
                    allowcave = config.Home.AllowCave;
                    break;
                case "tpa":
                case "tpr":
                    allowcave = config.TPR.AllowCave;
                    break;
                default:
#if DEBUG
                    Puts("Skipping cave check...");
#endif
                    break;
            }
            if (!allowcave)
            {
#if DEBUG
                Puts("Checking cave distance...");
#endif
                if (IsInCave(player.transform.position))
                {
                    return "TooCloseToCave";
                }
            }

            if (config.Settings.Interrupt.Hostile && (mode == "bandit" || mode == "outpost" || mode == "town") && player.IsHostile())
            {
                return "TPHostile";
            }

            if (config.Settings.Interrupt.Junkpiles && IsOnJunkPile(player))
            {
                return "TPJunkpile";
            }

            if (config.Settings.Interrupt.Hurt && origin && player.IsWounded())
            {
                return "TPWounded";
            }

            if (config.Settings.Interrupt.Cold && player.metabolism.temperature.value <= config.Settings.MinimumTemp)
            {
                return "TPTooCold";
            }

            if (config.Settings.Interrupt.Hot && player.metabolism.temperature.value >= config.Settings.MaximumTemp)
            {
                return "TPTooHot";
            }

            if (config.Settings.Interrupt.Swimming && player.IsSwimming())
            {
                return "TPSwimming";
            }

            if (config.Settings.Interrupt.Cargo && player.GetComponentInParent<CargoShip>())
            {
                return "TPCargoShip";
            }

            if (config.Settings.Interrupt.Balloon && player.GetComponentInParent<HotAirBalloon>())
            {
                return "TPHotAirBalloon";
            }

            if (config.Settings.Interrupt.Lift && player.GetComponentInParent<Lift>())
            {
                return "TPBucketLift";
            }

            if (config.Settings.Interrupt.Lift && GetLift(player.transform.position))
            {
                return "TPRegLift";
            }

            if (config.Settings.Interrupt.Safe && player.InSafeZone())
            {
                return "TPSafeZone";
            }

            if (!craft && player.inventory.crafting.queue.Count > 0)
            {
                return "TPCrafting";
            }

            if (player.IsDead())
            {
                return "TPDead";
            }

            if (!build && !player.CanBuild())
            {
                return "TPBuildingBlocked";
            }

            if (config.Settings.BlockZoneFlag && ZoneManager != null && Convert.ToBoolean(ZoneManager?.Call("PlayerHasFlag", player, "notp")))
            {
                return "TPFlagZone";
            }

            if (config.Settings.BlockNoEscape && NoEscape != null && Convert.ToBoolean(NoEscape?.Call("IsBlocked", player)))
            {
                return "TPNoEscapeBlocked";
            }

            var entity = GetStandingOnEntity<BaseMountable>(player, Layers.Mask.Vehicle_Detailed | Layers.Mask.Vehicle_Large);

            if (entity is BaseMountable)
            {
                if (entity is Tugboat)
                {
                    return !config.Home.AllowTugboats && !permission.UserHasPermission(player.UserIDString, "nteleportation.tugboatsinterruptbypass") ? "TPTugboat" : null;
                }

                if (config.Settings.Interrupt.Boats && entity is BaseBoat)
                {
                    return "TPBoat";
                }

                if (config.Settings.Interrupt.Mounted)
                {
                    return "TPMounted";
                }
            }

            if (IsWaterBlockedAbove(player, entity))
            {
                return "TPAboveWater";
            }
            
            if (config.Settings.Interrupt.UnderWater && Math.Round(player.transform.position.y, 2) < Math.Round(TerrainMeta.WaterMap.GetHeight(player.transform.position), 2) && !IsInAllowedMonument(player.transform.position, mode))
            {
                return "TPUnderWater";
            }
            
            return null;
        }

        private bool IsWaterBlockedAbove(BasePlayer player, BaseEntity entity)
        {
            if (!config.Settings.Interrupt.AboveWater || !AboveWater(player.transform.position))
            {
                return false;
            }
            if ((config.Home.AllowTugboats || permission.UserHasPermission(player.UserIDString, "nteleportation.tugboatsinterruptbypass")) && entity is Tugboat)
            {
                return false;
            }
            if (!config.Settings.Interrupt.Boats && entity != null && entity.ShortPrefabName != "tugboat" && entity is BaseBoat)
            {
                return false;
            }
            return true;
        }

        private string CheckTargetLocation(BasePlayer player, Vector3 targetLocation, bool usableIntoBuildingBlocked, bool cupOwnerAllowOnBuildingBlocked)
        {
            if (CanBypassRestrictions(player.UserIDString)) return null;
            // ubb == UsableIntoBuildingBlocked
            // obb == CupOwnerAllowOnBuildingBlocked
            bool denied = false;
            foreach (var entity in FindEntitiesOfType<BaseEntity>(targetLocation, 3f, Layers.Mask.Construction | Layers.Mask.Vehicle_Large))
            {
                if (entity is Tugboat)
                {
                    if (usableIntoBuildingBlocked || player.CanBuild(entity.WorldSpaceBounds())) return null;
                    return "TPTargetBuildingBlocked";
                }
                if (!(entity is BuildingBlock))
                {
                    continue;
                }
                var block = entity as BuildingBlock;
                if (CheckCupboardBlock(block, player, cupOwnerAllowOnBuildingBlocked))
                {
                    denied = false;
#if DEBUG
                    Puts("Cupboard either owned or there is no cupboard");
#endif
                }
                else if (usableIntoBuildingBlocked && player.userID != block.OwnerID)
                {
                    denied = false;
#if DEBUG
                    Puts("Player does not own block, but UsableIntoBuildingBlocked=true");
#endif
                }
                else if (player.userID == block.OwnerID)
                {
#if DEBUG
                    Puts("Player owns block");
#endif

                    if (!player.IsBuildingBlocked(targetLocation, new Quaternion(), block.bounds))
                    {
#if DEBUG
                        Puts("Player not BuildingBlocked. Likely unprotected building.");
#endif
                        denied = false;
                        break;
                    }
                    else if (usableIntoBuildingBlocked)
                    {
#if DEBUG
                        Puts("Player not blocked because UsableIntoBuildingBlocked=true");
#endif
                        denied = false;
                        break;
                    }
                    else
                    {
#if DEBUG
                        Puts("Player owns block but blocked by UsableIntoBuildingBlocked=false");
#endif
                        denied = true;
                        break;
                    }
                }
                else
                {
#if DEBUG
                    Puts("Player blocked");
#endif
                    denied = true;
                    break;
                }
            }

            return denied ? "TPTargetBuildingBlocked" : null;
        }

        // Check that a building block is owned by/attached to a cupboard, allow tp if not blocked unless allowed by config
        private bool CheckCupboardBlock(BuildingBlock block, BasePlayer player, bool cupOwnerAllowOnBuildingBlocked)
        {
            // obb == CupOwnerAllowOnBuildingBlocked
            var building = block.GetBuilding();
            if (building != null)
            {
#if DEBUG
                Puts("Found building, checking privileges...");
                Puts($"Building ID: {building.ID}");
#endif
                // cupboard overlap.  Check privs.
                if (building.buildingPrivileges == null)
                {
#if DEBUG
                    Puts("No cupboard found, allowing teleport");
#endif
                    return true;
                }

                foreach (var priv in building.buildingPrivileges)
                {
                    if (priv.IsAuthed(player))
                    {
#if DEBUG
                        Puts("Player is authorized to the cupboard");
#endif
                        return true;
                    }
                }

                if (player.userID == block.OwnerID)
                {
                    if (cupOwnerAllowOnBuildingBlocked)
                    {
#if DEBUG
                        // player set the cupboard and is allowed in by config
                        Puts("Player owns cupboard with no auth, but allowed by CupOwnerAllowOnBuildingBlocked=true");
#endif
                        return true;
                    }
#if DEBUG
                    // player set the cupboard but is blocked by config
                    Puts("Player owns cupboard with no auth, but blocked by CupOwnerAllowOnBuildingBlocked=false");
#endif
                    return false;
                }

#if DEBUG
                // player not authed
                Puts("Player does not own cupboard and is not authorized");
#endif
                return false;
            }
#if DEBUG
            Puts("No cupboard or building found - we cannot tell the status of this block");
#endif
            return true;
        }

        private string CheckItems(BasePlayer player)
        {
            foreach (var blockedItem in ReverseBlockedItems)
            {
                if (player.inventory.FindItemByItemID(blockedItem.Key) != null)
                {
                    return blockedItem.Value;
                }
            }
            return null;
        }

        private Collider[] colBuffer = new Collider[8192];

        private List<T> FindEntitiesOfType<T>(Vector3 a, float n, int m = -1) where T : BaseNetworkable
        {
            int hits = Physics.OverlapSphereNonAlloc(a, n, colBuffer, m, QueryTriggerInteraction.Collide);
            List<T> entities = new List<T>();
            for (int i = 0; i < hits; i++)
            {
                var entity = colBuffer[i]?.ToBaseEntity();
                if (entity is T) entities.Add(entity as T);
                colBuffer[i] = null;
            }
            return entities;
        }

        private bool IsInsideEntity(Vector3 a)
        {
            bool faces = Physics.queriesHitBackfaces;
            Physics.queriesHitBackfaces = true;
            RaycastHit hit;
            bool isHit = Physics.Raycast(a + new Vector3(0f, 0.015f, 0f), Vector3.up, out hit, 7f, Layers.Mask.Construction | Layers.Mask.Deployed, QueryTriggerInteraction.Ignore);
            Physics.queriesHitBackfaces = faces;
            if (isHit)
            {
                var e = hit.GetEntity();
                if (e == null || e.PrefabName.Contains("floor.grill"))
                {
                    return false;
                }
                if (e is BuildingBlock)
                {
                    return e.ShortPrefabName.Contains("foundation");
                }
                if (e is SimpleBuildingBlock || e is IceFence || e is ElectricBattery || e is Door || e is BaseOven)
                {
                    return Math.Round(a.y, 2) < Math.Round(hit.point.y, 2);
                }
            }
            return false;
        }

        private string IsInsideEntity(Vector3 targetLocation, ulong userid, string mode)
        {
            if (IsInsideEntity(targetLocation))
            {
                return "TPTargetInsideEntity";
            }
            if (config.Settings.Rock && NearMonument(targetLocation, true, mode) == null && Exploits.TestInsideRock(targetLocation))
            {
                LogToFile("exploiters", $"{userid} sethome inside a rock at {targetLocation}", this, true);
                PrintMsgL(userid, "TPTargetInsideRock");
                return "TPTargetInsideRock";
            }
            return null;
        }

        private bool UnderneathFoundation(Vector3 a)
        {
            RaycastHit hit;
            if (Physics.Raycast(a + new Vector3(0f, 3f, 0f), Vector3.down, out hit, 5f, Layers.Mask.Construction, QueryTriggerInteraction.Ignore))
            {
                var e = hit.GetEntity();

                if (e is BuildingBlock && e.ShortPrefabName.Contains("foundation"))
                {
                    return Math.Round(a.y, 2) < Math.Round(hit.point.y, 2);
                }
            }
            return false;
        }

        private string CheckFoundation(ulong userid, Vector3 position, string mode)
        {
            if (CanBypassRestrictions(userid.ToString())) return null;
            string insideErr = IsInsideEntity(position, userid, mode);
            if (insideErr != null)
            {
                return insideErr;
            }
            if (IsBlockedOnIceberg(position))
            {
                return "HomeIce";
            }
            if (!config.Home.ForceOnTopOfFoundation || permission.UserHasPermission(userid.ToString(), PermFoundationCheck))
            {
                return null;
            }
            if (UnderneathFoundation(position))
            {
                return "HomeFoundationUnderneathFoundation";
            }
            BaseEntity entity;
            if (!IsStandingOnEntity(position, Layers.Mask.Construction | Layers.Mask.Vehicle_Large, out entity, !config.Home.AllowAboveFoundation ? new string[2] { "foundation", "tugboat" } : new string[3] { "floor", "foundation", "tugboat" }))
            {
                return "HomeNoFoundation";
            }
            if (!config.Home.CheckFoundationForOwner || entity is Tugboat || IsAlly(userid, entity.OwnerID))
            {
                return null;
            }
            return "HomeFoundationNotFriendsOwned";
        }

        private bool IsBlockedOnIceberg(Vector3 position)
        {
            if (!config.Home.AllowIceberg) return false;
            RaycastHit hit;
            if (!Physics.SphereCast(position + new Vector3(0f, 1f), 1f, Vector3.down, out hit, 250f, Layers.Mask.Terrain | Layers.Mask.World)) return false;
            return hit.collider.name.Contains("ice_sheet") || hit.collider.name.Contains("iceberg");
        }

        private BuildingBlock GetFoundationOwned(Vector3 position, ulong userID)
        {
            BaseEntity entity;
            if (!IsStandingOnEntity(position, Layers.Mask.Construction, out entity, new string[1] { "foundation" }) || !PassesStrictCheck(entity, position)) return null;
            if (!config.Home.CheckFoundationForOwner || IsAlly(userID, entity.OwnerID)) return entity as BuildingBlock;
            return null;
        }

        private bool IsAlly(ulong playerId, ulong targetId)
        {
            if (playerId == targetId)
            {
                return true;
            }
            if (config.Home.UseTeams)
            {
                RelationshipManager.PlayerTeam team;
                if (RelationshipManager.ServerInstance.playerToTeam.TryGetValue(playerId, out team) && team.members.Contains(targetId))
                {
                    return true;
                }
            }
            if (config.Home.UseClans && Clans != null && Clans.IsLoaded && Convert.ToBoolean(Clans?.Call("IsClanMember", playerId.ToString(), targetId.ToString())))
            {
                return true;
            }
            if (config.Home.UseFriends && Friends != null && Friends.IsLoaded && Convert.ToBoolean(Friends?.Call("AreFriends", playerId.ToString(), targetId.ToString())))
            {
                return true;
            }
            return false;
        }

        bool IsBlockedUser(ulong playerid, ulong targetid)
        {
            if (config.TPR.UseBlockedUsers && BlockUsers != null && BlockUsers.IsLoaded)
            {
#if DEBUG
                Puts("Is user blocked? {0} / {1}", playerid, targetid);
#endif
                if (Convert.ToBoolean(BlockUsers?.CallHook("IsBlockedUser", targetid, playerid)))
                {
#if DEBUG
                    Puts("  BlockUsers plugin returned true");
#endif
                    return true;
                }
#if DEBUG
                Puts("  BlockUsers plugin returned false");
#endif
            }
            return false;
        }

        private bool PassesStrictCheck(BaseEntity entity, Vector3 position)
        {
            if (!config.Settings.StrictFoundationCheck || entity is Tugboat)
            {
                return true;
            }
#if DEBUG
            Puts($"PassesStrictCheck() called for {entity.ShortPrefabName}");
#endif
            Vector3 center = entity.CenterPoint();

            if (IsExternalWallOverlapped(center, position)) return false;
#if DEBUG
            Puts($"  Checking block: {entity.name} @ center {center}, pos: {position}");
#endif
            if (entity.PrefabName.Contains("triangle.prefab"))
            {
                if (Math.Abs(center.x - position.x) < 0.46f && Math.Abs(center.z - position.z) < 0.46f)
                {
#if DEBUG
                    Puts($"    Found: {entity.ShortPrefabName} @ center: {center}, pos: {position}");
#endif
                    return true;
                }
            }
            else if (entity.PrefabName.Contains("foundation.prefab") || entity.PrefabName.Contains("floor.prefab"))
            {
                if (Math.Abs(center.x - position.x) < 0.7f && Math.Abs(center.z - position.z) < 0.7f)
                {
#if DEBUG
                    Puts($"    Found: {entity.ShortPrefabName} @ center: {center}, pos: {position}");
#endif
                    return true;
                }
            }

            return false;
        }

        private bool IsExternalWallOverlapped(Vector3 center, Vector3 position)
        {
            foreach (var wall in FindEntitiesOfType<BaseEntity>(center, 1.5f))
            {
                if (wall.PrefabName.Contains("external.high"))
                {
#if DEBUG
                    Puts($"    Found: {wall.PrefabName} @ center {center}, pos {position}");
#endif
                    return true;
                }
            }
            return false;
        }

        private T FindEntity<T>(BaseEntity entity) where T : BaseEntity
        {
            if (entity == null)
            {
                return null;
            }
            if (entity is T)
            {
                return entity as T;
            }
            if (!entity.HasParent())
            {
                return null;
            }
            var parent = entity.GetParentEntity();
            while (parent != null)
            {
                if (parent is T)
                {
                    return parent as T;
                }
                parent = parent.GetParentEntity();
            }
            return null;
        }

        private T GetStandingOnEntity<T>(BasePlayer player, int layerMask) where T : BaseEntity
        {
            if (player.HasParent())
            {
                var parent = FindEntity<T>(player.GetParentEntity());
                if (parent != null)
                {
                    return parent;
                }
            }
            if (player.isMounted)
            {
                var mounted = FindEntity<T>(player.GetMounted());
                if (mounted != null)
                {
                    return mounted;
                }
            }
            return GetStandingOnEntity<T>(player.transform.position, layerMask);
        }

        private T GetStandingOnEntity<T>(Vector3 a, int layerMask) where T : BaseEntity
        {
            RaycastHit hit;
            if (Physics.Raycast(a + new Vector3(0f, 0.1f, 0f), Vector3.down, out hit, 1f, layerMask, QueryTriggerInteraction.Ignore))
            {
                var entity = hit.GetEntity();
                if (entity is T) return entity as T;
            }
            return null;
        }

        private bool IsStandingOnEntity(Vector3 a, int layerMask, out BaseEntity entity, string[] prefabs)
        {
            entity = GetStandingOnEntity<BaseEntity>(a, layerMask);
            if (entity == null || !PassesStrictCheck(entity, a)) return false;
            return Array.Exists(prefabs, entity.ShortPrefabName.Contains);
        }

        private bool CheckBoundaries(float x, float y, float z)
        {
            return x <= boundary && x >= -boundary && y <= config.Settings.BoundaryMax && y >= config.Settings.BoundaryMin && z <= boundary && z >= -boundary;
        }

        private Vector3 GetGroundBuilding(Vector3 a)
        {
            a.y = TerrainMeta.HeightMap.GetHeight(a);
            RaycastHit hit;
            if (Physics.Raycast(a.WithY(200f), Vector3.down, out hit, Mathf.Infinity, Layers.Mask.Terrain | Layers.Mask.World | Layers.Mask.Construction | Layers.Mask.Deployed | Layers.Mask.Vehicle_Large, QueryTriggerInteraction.Ignore))
            {
                a.y = Mathf.Max(hit.point.y, a.y);
            }
            return a;
        }

        public bool AboveWater(Vector3 a)
        {
            return TerrainMeta.HeightMap.GetHeight(a) - TerrainMeta.WaterMap.GetHeight(a) < 0;
        }

        private static bool ContainsTopology(TerrainTopology.Enum mask, Vector3 position, float radius)
        {
            return (TerrainMeta.TopologyMap.GetTopology(position, radius) & (int)mask) != 0;
        }

        private bool IsInCave(Vector3 a)
        {
            return GamePhysics.CheckSphere<TerrainCollisionTrigger>(a, 5f, 262144, QueryTriggerInteraction.Collide) && ContainsTopology(TerrainTopology.Enum.Monument, a, 5f);
        }

        private bool GetLift(Vector3 position)
        {
            return FindEntitiesOfType<ProceduralLift>(position, 0.5f).Count > 0;
        }

        private bool IsOnJunkPile(BasePlayer player)
        {
            return player.GetParentEntity() is JunkPile || FindEntitiesOfType<JunkPile>(player.transform.position, 3f, Layers.Mask.World).Count > 0;
        }

        private bool IsAllowed(BasePlayer player, string perm = null)
        {
            if (!player || !player.IsConnected)
            {
                return false;
            }

            if (!string.IsNullOrEmpty(perm) && permission.UserHasPermission(player.UserIDString, perm))
            {
                return !player.IsSleeping();
            }

            if (player.net.connection.authLevel == 1)
            {
                return config.Admin.UseableByModerators;
            }
            else if (player.net.connection.authLevel >= 2)
            {
                return config.Admin.UseableByAdmins;
            }

            return false;
        }

        private bool IsAllowedMsg(BasePlayer player, string perm = null)
        {
            if (IsAllowed(player, perm)) return true;
            PrintMsgL(player, "NotAllowed");
            return false;
        }

        private Effect reusableSoundEffectInstance = new Effect();

        private void SendEffect(BasePlayer player, List<string> effects)
        {
            if (effects.Count != 0)
            {
                reusableSoundEffectInstance.Init(Effect.Type.Generic, player, 0, Vector3.zero, Vector3.forward, player.limitNetworking ? player.Connection : null);
                reusableSoundEffectInstance.pooledString = effects.GetRandom();
                if (string.IsNullOrEmpty(reusableSoundEffectInstance.pooledString))
                {
                    return;
                }
                if (player.limitNetworking)
                {
                    EffectNetwork.Send(reusableSoundEffectInstance, player.Connection);
                }
                else EffectNetwork.Send(reusableSoundEffectInstance);
            }
        }

        private int GetHigher(BasePlayer player, Dictionary<string, int> limits, int limit, bool unlimited)
        {
            if (unlimited && limit == 0) return limit;

            foreach (var l in limits)
            {
                if (permission.UserHasPermission(player.UserIDString, l.Key))
                {
                    if (unlimited && l.Value == 0) return l.Value;

                    limit = Math.Max(l.Value, limit);
                }
            }
            return limit;
        }

        private int GetLower(BasePlayer player, Dictionary<string, int> times, int time)
        {
            foreach (var l in times)
            {
                if (permission.UserHasPermission(player.UserIDString, l.Key))
                {
                    time = Math.Min(l.Value, time);
                }
            }
            return time;
        }

        private void CheckPerms(Dictionary<string, int> limits)
        {
            foreach (var limit in limits)
            {
                if (!permission.PermissionExists(limit.Key))
                {
                    permission.RegisterPermission(limit.Key, this);
                }
            }
        }
        #endregion

        #region Message
        private string _(string msgId, BasePlayer player, params object[] args)
        {
            var msg = lang.GetMessage(msgId, this, player?.UserIDString);
            return args.Length > 0 ? string.Format(msg, args) : msg;
        }

        private void PrintMsgL(IPlayer user, string msgId, params object[] args)
        {
            if (user.IsServer)
            {
                user.Reply(string.Format(lang.GetMessage(msgId, this, user.Id), args));
            }
            else PrintMsgL(user.Object as BasePlayer, msgId, args);
        }

        private void PrintMsgL(BasePlayer player, string msgId, params object[] args)
        {
            if (player == null) return;
            PrintMsg(player, _(msgId, player, args));
        }

        private void PrintMsgL(ulong userid, string msgId, params object[] args)
        {
            var player = BasePlayer.FindAwakeOrSleeping(userid.ToString());
            if (player == null) return;
            PrintMsgL(player, msgId, args);
        }

        private void PrintMsg(BasePlayer player, string message)
        {
            if (player == null || string.IsNullOrEmpty(message)) return;
            if (config.Settings.UsePopup)
            {
                PopupNotifications?.Call("CreatePopupNotification", config.Settings.ChatName + message, player);
            }
            if (config.Settings.SendMessages)
            {
                Player.Message(player, $"{config.Settings.ChatName}{message}", config.Settings.ChatID);
            }
        }

        #endregion

        #region DrawBox
        private static void DrawBox(BasePlayer player, Vector3 center, Quaternion rotation, Vector3 size)
        {
            size /= 2;
            var point1 = RotatePointAroundPivot(new Vector3(center.x + size.x, center.y + size.y, center.z + size.z), center, rotation);
            var point2 = RotatePointAroundPivot(new Vector3(center.x + size.x, center.y - size.y, center.z + size.z), center, rotation);
            var point3 = RotatePointAroundPivot(new Vector3(center.x + size.x, center.y + size.y, center.z - size.z), center, rotation);
            var point4 = RotatePointAroundPivot(new Vector3(center.x + size.x, center.y - size.y, center.z - size.z), center, rotation);
            var point5 = RotatePointAroundPivot(new Vector3(center.x - size.x, center.y + size.y, center.z + size.z), center, rotation);
            var point6 = RotatePointAroundPivot(new Vector3(center.x - size.x, center.y - size.y, center.z + size.z), center, rotation);
            var point7 = RotatePointAroundPivot(new Vector3(center.x - size.x, center.y + size.y, center.z - size.z), center, rotation);
            var point8 = RotatePointAroundPivot(new Vector3(center.x - size.x, center.y - size.y, center.z - size.z), center, rotation);

            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point1, point2);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point1, point3);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point1, point5);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point4, point2);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point4, point3);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point4, point8);

            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point5, point6);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point5, point7);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point6, point2);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point8, point6);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point8, point7);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point7, point3);
        }

        private static Vector3 RotatePointAroundPivot(Vector3 point, Vector3 pivot, Quaternion rotation)
        {
            return rotation * (point - pivot) + pivot;
        }
        #endregion

        #region FindPlayer
        private ulong FindPlayersSingleId(string nameOrIdOrIp, BasePlayer player)
        {
            var targets = FindPlayers(nameOrIdOrIp, true);
            if (targets.Count > 1)
            {
                PrintMsgL(player, "MultiplePlayers", GetMultiplePlayers(targets));
                return 0;
            }
            ulong userId;
            if (targets.Count <= 0)
            {
                if (ulong.TryParse(nameOrIdOrIp, out userId)) return userId;
                PrintMsgL(player, "PlayerNotFound");
                return 0;
            }
            else
                userId = targets.First().userID;

            return userId;
        }

        private BasePlayer FindPlayersSingle(string value, BasePlayer player)
        {
            if (string.IsNullOrEmpty(value)) return null;
            BasePlayer target;
            if (_ids.TryGetValue(value, out target) && target.IsValid())
            {
                return target;
            }
            var targets = FindPlayers(value, true);
            if (targets.Count <= 0)
            {
                PrintMsgL(player, "PlayerNotFound");
                return null;
            }
            if (targets.Count > 1)
            {
                PrintMsgL(player, "MultiplePlayers", GetMultiplePlayers(targets));
                return null;
            }

            return targets.First();
        }

        private List<BasePlayer> FindPlayers(string arg, bool all = false)
        {
            var players = new List<BasePlayer>();

            if (string.IsNullOrEmpty(arg))
            {
                return players;
            }

            BasePlayer target;
            if (_ids.TryGetValue(arg, out target) && target.IsValid())
            {
                if (all || target.IsConnected)
                {
                    players.Add(target);
                    return players;
                }
            }

            foreach (var user in all ? BasePlayer.allPlayerList : BasePlayer.activePlayerList)
            {
                if (user == null || string.IsNullOrEmpty(user.displayName) || players.Contains(user))
                {
                    continue;
                }

                if (user.UserIDString == arg || user.displayName.Contains(arg, CompareOptions.OrdinalIgnoreCase))
                {
                    players.Add(user);
                }
            }

            return players;
        }
        #endregion

        private class UnityVector3Converter : JsonConverter
        {
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                var vector = (Vector3)value;
                writer.WriteValue($"{vector.x} {vector.y} {vector.z}");
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                if (reader.TokenType == JsonToken.String)
                {
                    var values = reader.Value.ToString().Trim().Split(' ');
                    return new Vector3(Convert.ToSingle(values[0]), Convert.ToSingle(values[1]), Convert.ToSingle(values[2]));
                }
                var o = JObject.Load(reader);
                return new Vector3(Convert.ToSingle(o["x"]), Convert.ToSingle(o["y"]), Convert.ToSingle(o["z"]));
            }

            public override bool CanConvert(Type objectType)
            {
                return objectType == typeof(Vector3);
            }
        }

        private class CustomComparerDictionaryCreationConverter<T> : CustomCreationConverter<IDictionary>
        {
            private readonly IEqualityComparer<T> comparer;

            public CustomComparerDictionaryCreationConverter(IEqualityComparer<T> comparer)
            {
                if (comparer == null)
                    throw new ArgumentNullException(nameof(comparer));
                this.comparer = comparer;
            }

            public override bool CanConvert(Type objectType)
            {
                return HasCompatibleInterface(objectType) && HasCompatibleConstructor(objectType);
            }

            private static bool HasCompatibleInterface(Type objectType)
            {
                return objectType.GetInterfaces().Where(i => HasGenericTypeDefinition(i, typeof(IDictionary<,>))).Any(i => typeof(T).IsAssignableFrom(i.GetGenericArguments().First()));
            }

            private static bool HasGenericTypeDefinition(Type objectType, Type typeDefinition)
            {
                return objectType.GetTypeInfo().IsGenericType && objectType.GetGenericTypeDefinition() == typeDefinition;
            }

            private static bool HasCompatibleConstructor(Type objectType)
            {
                return objectType.GetConstructor(new[] { typeof(IEqualityComparer<T>) }) != null;
            }

            public override IDictionary Create(Type objectType)
            {
                return Activator.CreateInstance(objectType, comparer) as IDictionary;
            }
        }

        public class Exploits
        {
            public static bool TestInsideRock(Vector3 a)
            {
                if (ContainsTopology(TerrainTopology.Enum.Monument, a, 25f))
                {
                    return false;
                }
                bool faces = Physics.queriesHitBackfaces;
                Physics.queriesHitBackfaces = true;
                bool flag = IsRockFaceUpwards(a);
                Physics.queriesHitBackfaces = faces;
                return flag || IsRockFaceDownwards(a);
            }

            private static bool IsRockFaceDownwards(Vector3 a)
            {
                Vector3 b = a + new Vector3(0f, 30f, 0f);
                Vector3 d = a - b;
                var hits = Physics.RaycastAll(b, d, d.magnitude, Layers.World);
                return Array.Exists(hits, hit => IsRock(hit.collider.name));
            }

            private static bool IsRockFaceUpwards(Vector3 point)
            {
                RaycastHit hit;
                return Physics.Raycast(point, Vector3.up, out hit, 30f, Layers.Mask.World) && IsRock(hit.collider.name);
            }

            private static bool IsRock(string name) => name.Contains("rock", CompareOptions.OrdinalIgnoreCase) || name.Contains("formation", CompareOptions.OrdinalIgnoreCase) || name.Contains("cliff", CompareOptions.OrdinalIgnoreCase);
        }

        [HookMethod("SendHelpText")]
        private void SendHelpText(BasePlayer player)
        {
            PrintMsgL(player, "<size=14>NTeleportation</size> by <color=#ce422b>Nogrod</color>\n<color=#ffd479>/sethome NAME</color> - Set home on current foundation\n<color=#ffd479>/home NAME</color> - Go to one of your homes\n<color=#ffd479>/home list</color> - List your homes\n<color=#ffd479>/town</color> - Go to town, if set\n/tpb - Go back to previous location\n/tpr PLAYER - Request teleport to PLAYER\n/tpa - Accept teleport request");
        }

        private bool API_HavePendingRequest(BasePlayer player)
        {
            return PendingRequests.ContainsKey(player.userID) || PlayersRequests.ContainsKey(player.userID) || TeleportTimers.ContainsKey(player.userID);
        }

        private bool API_HaveAvailableHomes(BasePlayer player)
        {
            HomeData homeData;
            if (!_Home.TryGetValue(player.userID, out homeData))
            {
                _Home[player.userID] = homeData = new HomeData();
            }

            ValidateHomes(player, homeData, false, false);

            var limit = GetHigher(player, config.Home.VIPHomesLimits, config.Home.HomesLimit, true);
            var result = homeData.Locations.Count < limit || limit == 0;

            homeData.Locations.Clear();

            return result;
        }

        private Dictionary<string, Vector3> API_GetHomes(BasePlayer player)
        {
            HomeData homeData;
            if (!_Home.TryGetValue(player.userID, out homeData))
            {
                _Home[player.userID] = homeData = new HomeData();
            }

            ValidateHomes(player, homeData, false, false);

            var result = homeData.Locations.ToDictionary(pair => pair.Key, pair => pair.Value.Get());

            homeData.Locations.Clear();

            return result;
        }

        private List<Vector3> API_GetLocations(string command)
        {
            var settings = GetSettings(command);

            if (settings == null)
            {
                return new List<Vector3>();
            }

            return settings.Locations;
        }

        private Dictionary<string, List<Vector3>> API_GetAllLocations()
        {
            var dict = new Dictionary<string, List<Vector3>>();

            foreach (var dc in config.DynamicCommands)
            {
                dict[dc.Key] = dc.Value.Locations;
            }

            return dict;
        }

        private int GetLimitRemaining(BasePlayer player, string type)
        {
            if (player == null || string.IsNullOrEmpty(type)) return -1;
            var settings = GetSettings(type, player.userID);
            if (settings == null) return -1;
            var currentDate = DateTime.Now.ToString("d");
            var limit = GetHigher(player, settings.VIPDailyLimits, settings.DailyLimit, true);
            TeleportData data;
            if (!settings.Teleports.TPData.TryGetValue(player.userID, out data))
            {
                settings.Teleports.TPData[player.userID] = data = new TeleportData();
            }
            if (data.Date != currentDate)
            {
                data.Amount = 0;
                data.Date = currentDate;
            }
            if (limit > 0)
            {
                return limit - data.Amount;
            }
            return 0;
        }

        private int GetCooldownRemaining(BasePlayer player, string type)
        {
            if (player == null || string.IsNullOrEmpty(type)) return -1;
            var settings = GetSettings(type, player.userID);
            if (settings == null) return -1;
            var currentDate = DateTime.Now.ToString("d");
            var timestamp = Facepunch.Math.Epoch.Current;
            var cooldown = GetLower(player, settings.VIPCooldowns, settings.Cooldown);
            TeleportData data;
            if (!settings.Teleports.TPData.TryGetValue(player.userID, out data))
            {
                settings.Teleports.TPData[player.userID] = data = new TeleportData();
            }
            if (data.Date != currentDate)
            {
                data.Amount = 0;
                data.Date = currentDate;
            }
            if (cooldown > 0 && timestamp - data.Timestamp < cooldown)
            {
                return cooldown - (timestamp - data.Timestamp);
            }
            return 0;
        }

        private int GetCountdownRemaining(BasePlayer player, string type)
        {
            if (player == null || string.IsNullOrEmpty(type))
            {
                return -1;
            }

            TownSettings settings = GetSettings(type, player.userID);
            if (settings == null)
            {
                return -1;
            }

            return GetLower(player, settings.VIPCountdowns, settings.Countdown);
        }
    }
}

// --- End of file: NTeleportation.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/AntiRB.cs ---
// --- Original Local Path: BeeRust/AntiRB.cs ---

using System.Collections.Generic;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;
using System;

namespace Oxide.Plugins
{
    [Info("AntiRB", "King", "1.0.0")]
    public class AntiRB : RustPlugin
    {
                        [PluginReference] private Plugin
        NoEscape = null, Clans = null, MenuAlerts = null, ImageLibrary = null;

        private static AntiRB plugin = null;
        public Dictionary<string, double> _cooldown = new Dictionary<string, double>();

        #region [Data]
        private class Data
        {
            public readonly BasePlayer _player;
            public readonly Single _cooldown;
            public readonly Boolean _coin;

            public Data(BasePlayer player, Single cooldown, Boolean isRaidCoin = false)
            {
                _player = player;
                _cooldown = Time.time + cooldown;
                _coin = isRaidCoin;
            }
        }

        private List<Data> _data = new List<Data>();
        #endregion

        #region [Oxide]
        private void OnServerInitialized()
        {
            plugin = this;

            ImageLibrary?.Call("AddImage", "https://i.imgur.com/i7QkC5B.png", "Point_Image");
            ImageLibrary?.Call("AddImage", "https://i.postimg.cc/7696CGRZ/dollar-2.png", "AntiRB_Image");
            ImageLibrary?.Call("AddImage", "https://i.postimg.cc/nVKJCPNH/imgonline-com-ua-Resize-YN5d-Vq-C7x1.png", "AntiR_B_Image");
            ImageLibrary?.Call("AddImage", "https://i.postimg.cc/dQr2b8pk/bet.png", "XUron_Image");       

            if (!NoEscape) PrintWarning("NOESCAPE IS NOT INSTALLED.");

            GameObject obj = new GameObject();
            if (config._SettingsAntiRBChinook.useChinook)
                AntiRBComp = obj.AddComponent<AntiRBComponent>();
            if (config._SettingsChinookPoint.useChinook)
                ChinookPointComp = obj.AddComponent<ChinookPointComponent>();

            timer.Every(1, TimeHandle);
        }

        private void Unload()
        {
            _data?.ForEach(data =>
            {
                if (data._coin)
                    rust.RunServerCommand($"oxide.usergroup remove {data._player.userID} antirb");
            });

            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                MenuAlerts?.Call("RemoveAlertMenu", player, $"{Name}.Coin");
                MenuAlerts?.Call("RemoveAlertMenu", player, $"{Name}.Point");
            }

            UnityEngine.Object.Destroy(AntiRBComp);
            UnityEngine.Object.Destroy(ChinookPointComp);

            plugin = null;
        }
        #endregion

        private void TimeHandle()
        {
            List<Data> toRemove = Pool.GetList<Data>();

            _data?.ForEach(data =>
            {
                if (Time.time - data._cooldown >= 0)
                {
                    if (data._coin)
                        rust.RunServerCommand($"oxide.usergroup remove {data._player.userID} antirb");

                    toRemove.Add(data);
                }
            });

            toRemove.ForEach(data => _data.Remove(data));
            
            Pool.FreeList(ref toRemove);
        }

        #region [Rust]
        object OnItemAction(Item item, String action, BasePlayer player)
        {
            if (action != "unwrap") return null;

            if (item.info.shortname == config._SettingsAntiRB.ShortName && item.skin == config._SettingsAntiRB.SkinID)
            {
                String clan = ClanTag(player);
                if (_cooldown.ContainsKey(clan))
                {
                    Double time = _cooldown[clan] - CurrentTime();
                    if (time <= 0)
                        _cooldown.Remove(clan);
                    else
                    {
                        player.ChatMessage($"ÐÑ ÑÐ¶Ðµ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð»Ð¸ ÑÑÐ¾Ñ Ð¿ÑÐµÐ´Ð¼ÐµÑ,Ð¿Ð¾Ð²ÑÐ¾ÑÐ½Ð¾ Ð²Ñ ÑÐ¼Ð¾Ð¶ÐµÑÐµ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ ÐµÐ³Ð¾ ÑÐµÑÐµÐ· {TimeSpan.FromSeconds(time).ToShortString()}!");
                        return false;
                    }
                }

                Server.Broadcast($"ÐÐ³ÑÐ¾Ðº <color=green>{player.displayName}</color> Ð°ÐºÑÐ¸Ð²Ð¸ÑÐ¾Ð²Ð°Ð» Ð°Ð½ÑÐ¸-ÑÐ± Ð¼Ð¾Ð½ÐµÑÑ!");
                rust.RunServerCommand($"oxide.usergroup add {player.userID} antirb");

                UnblockedPlayer(player);
                _data.Add(new Data(player, config._SettingsAntiRB.timeActiveAntiRB, true));
                if (!_cooldown.ContainsKey(clan))
                    _cooldown.Add(clan, CurrentTime() + config._cooldown);
                if (item.amount > 1) item.amount--;
                else item.RemoveFromContainer();
                return false;
            }

            if (item.info.shortname == config._SettingsDamageCoin.ShortName && item.skin == config._SettingsDamageCoin.SkinID)
            {
                Server.Broadcast($"ÐÐ³ÑÐ¾Ðº <color=green>{player.displayName}</color> Ð°ÐºÑÐ¸Ð²Ð¸ÑÐ¾Ð²Ð°Ð» Ð¼Ð¾Ð½ÐµÑÑ Ð´Ð¾Ð¿Ð¾Ð»Ð½Ð¸ÑÐµÐ»ÑÐ½Ð¾Ð³Ð¾ ÑÑÐ¾Ð½Ð°!");

                _data.Add(new Data(player, config._SettingsDamageCoin.timeActiveDamageCoin, false));
                if (item.amount > 1) item.amount--;
                else item.RemoveFromContainer();
                return false;
            }

            if (item.info.shortname == config._SettingsChinookPoint.ShortName && item.skin == config._SettingsChinookPoint.SkinID)
            {
                String clan = ClanTag(player);
                if (string.IsNullOrEmpty(clan))
                {
                    player.ChatMessage($"ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ Ð°ÐºÑÐ¸Ð²Ð¸ÑÐ¾Ð²Ð°ÑÑ ÑÐ¸ÐºÐµÑ Ð½Ð° {config._SettingsChinookPoint.howPoint} Ð¾ÑÐºÐ¾Ð². Ð§ÑÐ¾Ð±Ñ Ð°ÐºÑÐ¸Ð²Ð¸ÑÐ¾Ð²Ð°ÑÑ ÑÐ¾Ð·Ð´Ð°Ð¹ÑÐµ ÐºÐ»Ð°Ð½!");
                    return false;
                }

                Clans?.Call("GiveClanPoints", clan, config._SettingsChinookPoint.howPoint);
                player.ChatMessage($"ÐÑ ÑÑÐ¿ÐµÑÐ½Ð¾ Ð°ÐºÑÐ¸Ð²Ð¸ÑÐ¾Ð²Ð°Ð»Ð¸ ÑÐ¸ÐºÐµÑ Ð½Ð° {config._SettingsChinookPoint.howPoint} Ð¾ÑÐºÐ¾Ð².");
                if (item.amount > 1) item.amount--;
                else item.RemoveFromContainer();
                return false;
            }

            return null;
        }

		private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
		{
			if (entity == null || info?.InitiatorPlayer == null) return;

            BasePlayer player = info.InitiatorPlayer;
            if (player == null) return;
			
			Data find = _data.Find(x => x._player == player);
            if (find == null) return;

            if (entity is BuildingBlock || entity is Door || entity is SimpleBuildingBlock)
                info.damageTypes.ScaleAll(1.0f * config._SettingsDamageCoin.DamageCoinPerc);
		}

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player == null || !player.userID.IsSteamId()) return;

            if (AntiRBComp != null && AntiRBComp.IsStartEvent && AntiRBComp.IsStartHacked)
            {
                MenuAlerts?.Call("SendAlertMenu", player, Facepunch.Math.Epoch.Current - AntiRBComp.CurrentTime, (Int32)config._SettingsAntiRBChinook.timeOpen, $"CHINOOK COIN", $"ÐÐ²Ð°Ð´ÑÐ°Ñ: {GetGrid(AntiRBComp.transform.position)}", false, "AntiRB_Image", $"{Name}.Coin");
            }

            if (ChinookPointComp != null && ChinookPointComp.IsStartEvent && ChinookPointComp.IsStartHacked)
            {
                MenuAlerts?.Call("SendAlertMenu", player, Facepunch.Math.Epoch.Current - ChinookPointComp.CurrentTime, (Int32)config._SettingsAntiRBChinook.timeOpen, $"CHINOOK POINT", $"ÐÐ²Ð°Ð´ÑÐ°Ñ: {GetGrid(ChinookPointComp.transform.position)}", false, "Point_Image", $"{Name}.Point");
            }
        }

        private void OnCrateHack(HackableLockedCrate crate)
        {
            if (crate == null || crate.OwnerID == 0) return;

            if (AntiRBComp != null && AntiRBComp.IsStartEvent && AntiRBComp.CrateEntity == crate)
            {
                AntiRBComp.IsStartHacked = true;
                foreach (BasePlayer player in BasePlayer.activePlayerList)
                {
                    MenuAlerts?.Call("SendAlertMenu", player, Facepunch.Math.Epoch.Current, (Int32)config._SettingsAntiRBChinook.timeOpen, $"CHINOOK COIN", $"ÐÐ²Ð°Ð´ÑÐ°Ñ: {GetGrid(AntiRBComp.transform.position)}", false, "AntiRB_Image", $"{Name}.Coin");
                }
                Server.Broadcast($"<color=#ffde5a>ÐÐÐÐÐÐÐÐ!</color>\n<size=12>ÐÐ°ÑÐ°Ð»ÑÑ Ð²Ð·Ð»Ð¾Ð¼ ÑÐ¸Ð½ÑÐºÐ° Ñ Ð¼Ð¾Ð½ÐµÑÐ°Ð¼Ð¸");
            }

            if (ChinookPointComp != null && ChinookPointComp.IsStartEvent && ChinookPointComp.CrateEntity == crate)
            {
                ChinookPointComp.IsStartHacked = true;
                foreach (BasePlayer player in BasePlayer.activePlayerList)
                {
                    MenuAlerts?.Call("SendAlertMenu", player, Facepunch.Math.Epoch.Current, (Int32)config._SettingsAntiRBChinook.timeOpen, $"CHINOOK POINT", $"ÐÐ²Ð°Ð´ÑÐ°Ñ: {GetGrid(ChinookPointComp.transform.position)}", false, "Point_Image", $"{Name}.Point");
                }
                Server.Broadcast($"<color=#ffde5a>ÐÐÐÐÐÐÐÐ!</color>\n<size=12>ÐÐ°ÑÐ°Ð»ÑÑ Ð²Ð·Ð»Ð¾Ð¼ ÑÐ¸Ð½ÑÐºÐ° Ñ Ð¾ÑÐºÐ°Ð¼Ð¸");
            }
        }

        private void OnEntityKill(HackableLockedCrate crate)
        {
            if (crate == null || crate.OwnerID == 0) return;

            if (AntiRBComp != null && AntiRBComp.IsStartEvent && AntiRBComp.CrateEntity == crate)
            {
                AntiRBComp.EndedEvent();
            }

            if (ChinookPointComp != null && ChinookPointComp.IsStartEvent && ChinookPointComp.CrateEntity == crate)
            {
                ChinookPointComp.EndedEvent();
            }
        }
        #endregion

        #region [AntiRB || Damage Chinook]
        private AntiRBComponent AntiRBComp = null;

        private class AntiRBComponent : FacepunchBehaviour
        {
            private Int32 TotalTime = 0;
            public Int32 CurrentTime = 0;

            public Boolean IsStartHacked = false;
            public Boolean IsStartEvent = false;
            public HackableLockedCrate CrateEntity = null;

            private void Awake()
            {
                gameObject.layer = (Int32)Rust.Layer.Reserved1;
                enabled = false;
                InvokeRepeating(UpdateTime, 1f, 1);
            }

            public void DestroyComp() => OnDestroy();
            private void OnDestroy()
            {
                RemoveChinook();
                Destroy(this);
            }

            private void UpdateTime()
            {
                if (!IsStartEvent)
                {
                    TotalTime++;
                    if (TotalTime >= plugin.config._SettingsAntiRBChinook.eventCooldown)
                    {
                        StartEvent();
                    }
                }
                else if (IsStartHacked)
                {
                    CurrentTime++;
                    if (CurrentTime >= plugin.config._SettingsAntiRBChinook.timeOpen + plugin.config._SettingsAntiRBChinook.eventDestoroyTime)
                    {
                        EndedEvent();
                    }
                }
            }

            public void StartEvent()
            {
                transform.position = plugin.config._SettingsAntiRBChinook.chinookPosition;

                if (transform.position == Vector3.zero) return;

                SpawnChinook();

                TotalTime = 0;
                IsStartEvent = true;
                plugin.Server.Broadcast($"<color=#ffde5a>ÐÐÐÐÐÐÐÐ!</color>\n<size=12>ÐÐ°ÑÐ°Ð»ÑÑ Ð¸Ð²ÐµÐ½Ñ <color=#ffde5a>CHINOOK COIN</color>.\nÐÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð¾ÑÐ¼ÐµÑÐµÐ½Ð¾ Ð½Ð° ÐºÐ°ÑÑÐµ.");
            }

            public void EndedEvent()
            {
                IsStartHacked = false;
                IsStartEvent = false;
                TotalTime = 0;
                CurrentTime = 0;

                RemoveChinook();

                foreach (BasePlayer player in BasePlayer.activePlayerList)
                {
                    plugin.MenuAlerts?.Call("RemoveAlertMenu", player, $"{plugin.Name}");
                }
                plugin.Server.Broadcast($"<color=#ffde5a>ÐÐÐÐÐÐÐÐ!</color>\n<size=12>ÐÐ°ÐºÐ¾Ð½ÑÐ¸Ð»ÑÑ Ð¸Ð²ÐµÐ½Ñ <color=#ffde5a>CHINOOK COIN</color>.\nÐ¡Ð»ÐµÐ´ÑÑÑÐ¸Ð¹ Ð¸Ð²ÐµÐ½Ñ Ð±ÑÐ´ÐµÑ ÑÐµÑÐµÐ· {TimeExtensions.FormatShortTime(TimeSpan.FromSeconds(plugin.config._SettingsAntiRBChinook.eventCooldown))}");
            }

            private void SpawnChinook()
            {
                CrateEntity = GameManager.server.CreateEntity("assets/prefabs/deployable/chinooklockedcrate/codelockedhackablecrate.prefab", transform.position, Quaternion.Euler(0f, UnityEngine.Random.Range(0f, 360f), 0f), true) as HackableLockedCrate;
                CrateEntity.enableSaving = false;
                CrateEntity.OwnerID = 231313354353;
                CrateEntity.Spawn();
                CrateEntity.inventory.itemList.Clear();
                plugin.FillingChinookItem(CrateEntity);
                CrateEntity.inventory.capacity = CrateEntity.inventory.itemList.Count;
                CrateEntity.inventory.MarkDirty();
                CrateEntity.SendNetworkUpdate();
                CrateEntity.hackSeconds = HackableLockedCrate.requiredHackSeconds - plugin.config._SettingsAntiRBChinook.timeOpen;
            }

            private void RemoveChinook()
            {
                if (CrateEntity != null && !CrateEntity.IsDestroyed)
                    CrateEntity.Kill();
            }
        }
        #endregion

        #region [ChinookPoint]
        private ChinookPointComponent ChinookPointComp = null;

        private class ChinookPointComponent : FacepunchBehaviour
        {
            private Int32 TotalTime = 0;
            public Int32 CurrentTime = 0;

            public Boolean IsStartHacked = false;
            public Boolean IsStartEvent = false;
            public HackableLockedCrate CrateEntity = null;

            private void Awake()
            {
                gameObject.layer = (Int32)Rust.Layer.Reserved1;
                enabled = false;
                InvokeRepeating(UpdateTime, 1f, 1);
            }

            public void DestroyComp() => OnDestroy();
            private void OnDestroy()
            {
                RemoveChinook();
                Destroy(this);
            }

            private void UpdateTime()
            {
                if (!IsStartEvent)
                {
                    TotalTime++;
                    if (TotalTime >= plugin.config._SettingsChinookPoint.eventCooldown)
                    {
                        StartEvent();
                    }
                }
                else if (IsStartHacked)
                {
                    CurrentTime++;
                    if (CurrentTime >= plugin.config._SettingsChinookPoint.timeOpen + plugin.config._SettingsChinookPoint.eventDestoroyTime)
                    {
                        EndedEvent();
                    }
                }
            }

            public void StartEvent()
            {
                transform.position = plugin.config._SettingsChinookPoint.chinookPosition;

                if (transform.position == Vector3.zero) return;

                SpawnChinook();

                TotalTime = 0;
                IsStartEvent = true;
                plugin.Server.Broadcast($"<color=#ffde5a>ÐÐÐÐÐÐÐÐ!</color>\n<size=12>ÐÐ°ÑÐ°Ð»ÑÑ Ð¸Ð²ÐµÐ½Ñ <color=#ffde5a>CHINOOK POINT</color>.\nÐÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð¾ÑÐ¼ÐµÑÐµÐ½Ð¾ Ð½Ð° ÐºÐ°ÑÑÐµ.");
            }

            public void EndedEvent()
            {
                IsStartHacked = false;
                IsStartEvent = false;
                TotalTime = 0;
                CurrentTime = 0;

                RemoveChinook();

                foreach (BasePlayer player in BasePlayer.activePlayerList)
                {
                    plugin.MenuAlerts?.Call("RemoveAlertMenu", player, $"{plugin.Name}");
                }
                plugin.Server.Broadcast($"<color=#ffde5a>ÐÐÐÐÐÐÐÐ!</color>\n<size=12>ÐÐ°ÐºÐ¾Ð½ÑÐ¸Ð»ÑÑ Ð¸Ð²ÐµÐ½Ñ <color=#ffde5a>CHINOOK POINT</color>.\nÐ¡Ð»ÐµÐ´ÑÑÑÐ¸Ð¹ Ð¸Ð²ÐµÐ½Ñ Ð±ÑÐ´ÐµÑ ÑÐµÑÐµÐ· {TimeExtensions.FormatShortTime(TimeSpan.FromSeconds(plugin.config._SettingsChinookPoint.eventCooldown))}");
            }

            private void SpawnChinook()
            {
                CrateEntity = GameManager.server.CreateEntity("assets/prefabs/deployable/chinooklockedcrate/codelockedhackablecrate.prefab", transform.position, Quaternion.Euler(0f, UnityEngine.Random.Range(0f, 360f), 0f), true) as HackableLockedCrate;
                CrateEntity.enableSaving = false;
                CrateEntity.OwnerID = 231313354353;
                CrateEntity.Spawn();
                CrateEntity.inventory.itemList.Clear();
                Item netItem = ItemManager.CreateByName(plugin.config._SettingsChinookPoint.ShortName, 1, plugin.config._SettingsChinookPoint.SkinID);
                netItem.name = $"ÐÐ¸Ð»ÐµÑ Ð½Ð° {plugin.config._SettingsChinookPoint.howPoint} Ð¾ÑÐºÐ¾Ð².";
                netItem.MoveToContainer(CrateEntity.inventory);
                CrateEntity.inventory.capacity = CrateEntity.inventory.itemList.Count;
                CrateEntity.inventory.MarkDirty();
                CrateEntity.SendNetworkUpdate();
                CrateEntity.hackSeconds = HackableLockedCrate.requiredHackSeconds - plugin.config._SettingsChinookPoint.timeOpen;
            }

            private void RemoveChinook()
            {
                if (CrateEntity != null && !CrateEntity.IsDestroyed)
                    CrateEntity.Kill();
            }
        }
        #endregion

        #region [Functional]
        static readonly DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        static Double CurrentTime() => DateTime.UtcNow.Subtract(epoch).TotalSeconds;
        public String ClanTag(BasePlayer player) => Clans?.Call<String>("GetClanTag", player.userID);
        private void UnblockedPlayer(BasePlayer player) => NoEscape?.Call("UnblockedPlayer", player);
        #endregion

        #region [FillingChinook]
        private void FillingChinookItem(LootContainer LootContainer)
        {
            if (LootContainer == null) return;
            Int32 i = Core.Random.Range(0, 2);

            switch (i)
            {
                case 0:
                {
                    Item netItem = ItemManager.CreateByName(config._SettingsAntiRB.ShortName, 1, config._SettingsAntiRB.SkinID);
                    netItem.name = "ÐÐ½ÑÐ¸ ÑÐ± Ð¼Ð¾Ð½ÐµÑÐ°";
                    netItem.MoveToContainer(LootContainer.inventory);
                    break;
                }
                case 1:
                {
                    Item netItem = ItemManager.CreateByName(config._SettingsDamageCoin.ShortName, 1, config._SettingsDamageCoin.SkinID);
                    netItem.name = "ÐÐ²Ð¾Ð¹Ð½Ð¾Ð¹ ÑÑÐ¾Ð½ Ð¼Ð¾Ð½ÐµÑÐ°";
                    netItem.MoveToContainer(LootContainer.inventory);
                    break;
                }
            }
        }
        #endregion

        #region [ChatCommand]
        [ChatCommand("chinook")]
        private void NewChinookPosition(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin) return;

            if (args.Length == 0)
            {
                    player.ChatMessage("ÐÐ¾ÑÑÑÐ¿Ð½ÑÐµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ:"
                                       + "\n/chinook antirb start - ÐÐ°ÑÐ°ÑÑ Ð°Ð½ÑÐ¸ÑÐ± ÑÐ¸Ð½ÑÐº" 
                                       + "\n/chinook antirb stop - ÐÐ°ÐºÐ¾Ð½ÑÐ¸ÑÑ Ð°Ð½ÑÐ¸ÑÐ± ÑÐ¸Ð½ÑÐº"
                                       + "\n/chinook antirb position - Ð£ÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ ÑÐ¸Ð½ÑÐºÐ°"
                                       + "\n/chinook point start - ÐÐ°ÑÐ°ÑÑ Ð¸Ð²ÐµÐ½Ñ ÑÐ¸Ð½ÑÐº Ñ Ð¾ÑÐºÐ°Ð¼Ð¸" 
                                       + "\n/chinook point stop - ÐÐ°ÐºÐ¾Ð½ÑÐ¸ÑÑ Ð¸Ð²ÐµÐ½Ñ ÑÐ¸Ð½ÑÐº Ñ Ð¾ÑÐºÐ°Ð¼Ð¸"
                                       + "\n/chinook point position - Ð£ÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ Ð¼ÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ ÑÐ¸Ð½ÑÐºÐ° Ñ Ð¾ÑÐºÐ°Ð¼Ð¸");
                return;
            }

            if (args[0] == "antirb")
            {
                if (args[1] == "start")
                {
                    if (AntiRBComp == null || AntiRBComp.IsStartEvent) return;

                    AntiRBComp.StartEvent();
                    player.ChatMessage("ÐÑ ÑÑÐ¿ÐµÑÐ½Ð¾ Ð½Ð°ÑÐ°Ð»Ð¸ Ð¸Ð²ÐµÐ½Ñ Ð°Ð½ÑÐ¸ ÑÐ±.");
                }
                else if (args[1] == "stop")
                {
                    if (AntiRBComp == null || !AntiRBComp.IsStartEvent) return;

                    AntiRBComp.EndedEvent();
                    player.ChatMessage("ÐÑ ÑÑÐ¿ÐµÑÐ½Ð¾ Ð¾ÑÑÐ°Ð½Ð¾Ð²Ð¸Ð»Ð¸ Ð¸Ð²ÐµÐ½Ñ Ð°Ð½ÑÐ¸ ÑÐ±.");
                }
                else if (args[1] == "position")
                {
                    config._SettingsAntiRBChinook.chinookPosition = player.GetNetworkPosition();
                    SaveConfig();
                    player.ChatMessage("ÐÑ ÑÑÐ¿ÐµÑÐ½Ð¾ ÑÑÑÐ°Ð½Ð¾Ð²Ð¸Ð»Ð¸ Ð½Ð¾Ð²Ð¾Ðµ Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ Ð´Ð»Ñ ÑÐ¸Ð½ÑÐºÐ°!");
                }
            }
            else if (args[0] == "point")
            {
                if (args[1] == "start")
                {
                    if (ChinookPointComp == null || ChinookPointComp.IsStartEvent) return;

                    ChinookPointComp.StartEvent();
                    player.ChatMessage("ÐÑ ÑÑÐ¿ÐµÑÐ½Ð¾ Ð½Ð°ÑÐ°Ð»Ð¸ Ð¸Ð²ÐµÐ½Ñ ÑÐ¸Ð½ÑÐº Ñ Ð¾ÑÐºÐ°Ð¼Ð¸.");
                }
                else if (args[1] == "stop")
                {
                    if (ChinookPointComp == null || !ChinookPointComp.IsStartEvent) return;

                    ChinookPointComp.EndedEvent();
                    player.ChatMessage("ÐÑ ÑÑÐ¿ÐµÑÐ½Ð¾ Ð¾ÑÑÐ°Ð½Ð¾Ð²Ð¸Ð»Ð¸ Ð¸Ð²ÐµÐ½Ñ ÑÐ¸Ð½ÑÐº Ñ Ð¾ÑÐºÐ°Ð¼Ð¸.");
                }
                else if (args[1] == "position")
                {
                    config._SettingsChinookPoint.chinookPosition = player.GetNetworkPosition();
                    SaveConfig();
                    player.ChatMessage("ÐÑ ÑÑÐ¿ÐµÑÐ½Ð¾ ÑÑÑÐ°Ð½Ð¾Ð²Ð¸Ð»Ð¸ Ð½Ð¾Ð²Ð¾Ðµ Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ Ð´Ð»Ñ ÑÐ¸Ð½ÑÐºÐ° Ñ Ð¾ÑÐºÐ°Ð¼Ð¸!");
                }
            }
        }
        #endregion

        #region [Positon]
        public string GetGrid(Vector3 pos)
        {
            char letter = 'A';
            Single x = Mathf.Floor((pos.x + (ConVar.Server.worldsize / 2)) / 146.3f) % 26;
            Single z = (Mathf.Floor(ConVar.Server.worldsize / 146.3f)) - Mathf.Floor((pos.z + (ConVar.Server.worldsize / 2)) / 146.3f);
            letter = (char)(((Int32)letter) + x);
            return $"{letter}{z}";
        }
        #endregion

        #region [FormatTime]
        private static class TimeExtensions
        {
            public static string FormatShortTime(TimeSpan time)
            {
                string result = string.Empty;
                if (time.Days != 0) result += $"{time.Days}Ð´ ";
                if (time.Hours != 0) result += $"{time.Hours}Ñ ";
                if (time.Minutes != 0) result += $"{time.Minutes}Ð¼ ";
                if (time.Seconds != 0) result += $"{time.Seconds}Ñ ";
                return result;
            }
            private static string Format(Int32 units, string form1, string form2, string form3)
            {
                Int32 tmp = units % 10;
                if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9) return $"{units} {form1}";
                if (tmp >= 2 && tmp <= 4) return $"{units} {form2}";
                return $"{units} {form3}";
            }
        }
        #endregion

        #region [Config]
        private PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();

            if (config.PluginVersion < Version)
                UpdateConfigValues();

            Config.WriteObject(config, true);
        }

        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (config.PluginVersion < Version)
            {
                config.PluginVersion = Version;
                if (Version == new VersionNumber(1, 0, 0))
                {
                    //
                }

                PrintWarning("Config checked completed!");
            }
            config.PluginVersion = Version;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        public class SettingsAntiRBChinook
        {
            [JsonProperty("ÐÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ ÑÑÐ¾Ñ Ð²Ð°ÑÐ¸Ð°Ð½Ñ ÑÐ¸Ð½ÑÐºÐ° ?")]
            public Boolean useChinook;

            [JsonProperty("ÐÑÐµÐ¼Ñ Ð¾ÑÐºÑÑÑÐ¸Ñ ÑÐ¸Ð½ÑÐºÐ° (Ð² ÑÐµÐºÑÐ½Ð´Ð°Ñ)")]
            public Int32 timeOpen;

            [JsonProperty("Ð Ð°Ð· Ð²Ð¾ ÑÐºÐ¾Ð»ÑÐºÐ¾ Ð±ÑÐ´ÐµÑ Ð·Ð°Ð¿ÑÑÐºÐ°ÑÑÑÑ Ð¸Ð²ÐµÐ½Ñ (Ð² ÑÐµÐºÑÐ½Ð´Ð°Ñ)")]
            public Int32 eventCooldown;

            [JsonProperty("Ð§ÐµÑÐµÐ· ÑÐºÐ¾Ð»ÑÐºÐ¾ Ð·Ð°ÐºÐ°Ð½ÑÐ¸Ð²Ð°ÑÑ Ð¸Ð²ÐµÐ½Ñ ÐµÑÐ»Ð¸ ÑÐ¸Ð½ÑÐº Ð½Ð¸ÐºÑÐ¾ Ð½Ðµ Ð·Ð°Ð»ÑÑÐ°Ð» (Ð² ÑÐµÐºÑÐ½Ð´Ð°Ñ)")]
            public Int32 eventDestoroyTime;

            [JsonProperty("ÐÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ ÑÐ¸Ð½ÑÐºÐ° ( ÐÐµ ÑÐºÐ°Ð·ÑÐ²Ð°ÑÑ )")]
            public Vector3 chinookPosition;
        }

        public class SettingsChinookPoint
        {
            [JsonProperty("ÐÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ ÑÑÐ¾Ñ Ð²Ð°ÑÐ¸Ð°Ð½Ñ ÑÐ¸Ð½ÑÐºÐ° ?")]
            public Boolean useChinook;
            
            [JsonProperty("ÐÑÐµÐ¼Ñ Ð¾ÑÐºÑÑÑÐ¸Ñ ÑÐ¸Ð½ÑÐºÐ° (Ð² ÑÐµÐºÑÐ½Ð´Ð°Ñ)")]
            public Int32 timeOpen;

            [JsonProperty("Ð Ð°Ð· Ð²Ð¾ ÑÐºÐ¾Ð»ÑÐºÐ¾ Ð±ÑÐ´ÐµÑ Ð·Ð°Ð¿ÑÑÐºÐ°ÑÑÑÑ Ð¸Ð²ÐµÐ½Ñ (Ð² ÑÐµÐºÑÐ½Ð´Ð°Ñ)")]
            public Int32 eventCooldown;

            [JsonProperty("Ð§ÐµÑÐµÐ· ÑÐºÐ¾Ð»ÑÐºÐ¾ Ð·Ð°ÐºÐ°Ð½ÑÐ¸Ð²Ð°ÑÑ Ð¸Ð²ÐµÐ½Ñ ÐµÑÐ»Ð¸ ÑÐ¸Ð½ÑÐº Ð½Ð¸ÐºÑÐ¾ Ð½Ðµ Ð·Ð°Ð»ÑÑÐ°Ð» (Ð² ÑÐµÐºÑÐ½Ð´Ð°Ñ)")]
            public Int32 eventDestoroyTime;

            [JsonProperty("ÐÐµÑÑÐ¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ ÑÐ¸Ð½ÑÐºÐ° ( ÐÐµ ÑÐºÐ°Ð·ÑÐ²Ð°ÑÑ )")]
            public Vector3 chinookPosition;

            [JsonProperty("ShortName")]
            public String ShortName;

            [JsonProperty("SkinID")]
            public ulong SkinID;

            [JsonProperty("Ð¡ÐºÐ¾Ð»ÑÐºÐ¾ Ð¾ÑÐºÐ¾Ð² Ð´Ð°Ð²Ð°ÑÑ Ð·Ð° Ð°ÐºÑÐ¸Ð²Ð°ÑÐ¸Ñ ÑÐ¸ÐºÐµÑÐ°")]
            public Int32 howPoint;
        }

        public class SettingsAntiRB
        {
            [JsonProperty("ShortName")]
            public String ShortName;

            [JsonProperty("SkinID")]
            public ulong SkinID;

            [JsonProperty("ÐÑÐµÐ¼Ñ Ð´ÐµÐ¹ÑÑÐ²Ð¸Ñ Ð¼Ð¾Ð½ÐµÑÑ")]
            public Single timeActiveAntiRB;
        }

        public class SettingsDamageCoin
        {
            [JsonProperty("ShortName")]
            public String ShortName;

            [JsonProperty("SkinID")]
            public ulong SkinID;

            [JsonProperty("ÐÑÐµÐ¼Ñ Ð´ÐµÐ¹ÑÑÐ²Ð¸Ñ Ð¼Ð¾Ð½ÐµÑÑ")]
            public Single timeActiveDamageCoin;

            [JsonProperty("ÐÐ° ÑÐºÐ¾Ð»ÑÐºÐ¾ ÑÐ¼Ð½Ð¾Ð¶Ð°ÑÑ ÑÑÐ¾Ð½ Ð¿Ð¾ Ð¿Ð¾ÑÑÑÐ¾Ð¹ÐºÐ°Ð¼")]
            public Single DamageCoinPerc;
        }

        private class PluginConfig
        {
            [JsonProperty("ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ¸ Ð°Ð½ÑÐ¸-ÑÐ± Ð¼Ð¾Ð½ÐµÑÑ")]
            public SettingsAntiRB _SettingsAntiRB = new SettingsAntiRB();

            [JsonProperty("ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ¸ ÑÐ¸Ð½ÑÐºÐ° Ñ Ð¾ÑÐºÐ°Ð¼Ð¸ ÐºÐ»Ð°Ð½Ð°")]
            public SettingsChinookPoint _SettingsChinookPoint = new SettingsChinookPoint();

            [JsonProperty("ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ¸ ÑÐ¸Ð½ÑÐºÐ° Ñ Ð°Ð½ÑÐ¸ ÑÐ± Ð¸ Ð¼Ð¾Ð½ÐµÑÐºÐ¸ Ð½Ð° ÑÑÐ¾Ð½")]
            public SettingsAntiRBChinook _SettingsAntiRBChinook = new SettingsAntiRBChinook();

            [JsonProperty("ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ¸ Ð¼Ð¾Ð½ÐµÑÑ Ð½Ð° ÑÐ²ÐµÐ»ÐµÐ½Ð¸Ñ ÑÑÐ¾Ð½Ð° Ð¿Ð¾ Ð¿Ð¾ÑÑÑÐ¾Ð¹ÐºÐ°Ð¼")]
            public SettingsDamageCoin _SettingsDamageCoin = new SettingsDamageCoin();

            [JsonProperty("ÐÐµÑÐµÐ·Ð°ÑÑÐ´ÐºÐ° Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ñ Ð°Ð½ÑÐ¸-ÑÐ± Ð¼Ð¾Ð½ÐµÑÑ")]
            public Int32 _cooldown;

            [JsonProperty("Config version")]
            public VersionNumber PluginVersion = new VersionNumber();

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    _SettingsAntiRB = new SettingsAntiRB
                    {
                        ShortName = "xmas.present.small",
                        SkinID = 2000,
                        timeActiveAntiRB = 20f,
                    },
                    _SettingsChinookPoint = new SettingsChinookPoint
                    {
                        useChinook = true,
                        timeOpen = 300,
                        eventCooldown = 800,
                        eventDestoroyTime = 300,
                        chinookPosition = Vector3.zero,
                        ShortName = "xmas.present.small",
                        SkinID = 1995,
                        howPoint = 200,
                    },
                    _SettingsAntiRBChinook = new SettingsAntiRBChinook
                    {
                        useChinook = true,
                        timeOpen = 300,
                        eventCooldown = 600,
                        eventDestoroyTime = 300,
                        chinookPosition = Vector3.zero,
                    },
                    _SettingsDamageCoin = new SettingsDamageCoin
                    {
                        ShortName = "xmas.present.small",
                        SkinID = 1997,
                        timeActiveDamageCoin = 20f,
                        DamageCoinPerc = 2f,
                    },
                    _cooldown = 3600,
                    PluginVersion = new VersionNumber()
                };
            }
        }
        #endregion
    }
}

// --- End of file: AntiRB.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/IQReportSystem.cs ---
// --- Original Local Path: BeeRust/IQReportSystem.cs ---

using Time = UnityEngine.Time;
using System.Collections;
using Oxide.Core;
using UnityEngine.Networking;
using System;
using Oxide.Core.Plugins;
using System.Text;
using Net = Network.Net;
using Oxide.Core.Libraries;
using Facepunch.Utility;
using Object = System.Object;
using System.Text.RegularExpressions;
using System.Collections.Generic;
using ConVar;
using UnityEngine;
using Oxide.Core.Libraries.Covalence;
using UnityEngine.UI;
using System.Linq;
using Newtonsoft.Json.Linq;
using Oxide.Game.Rust.Cui;
using Network;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("IQReportSystem", "Mercury", "2.13.72")]
    [Description("One love IQReportSystem")]
    internal class IQReportSystem : RustPlugin
    {



        private Boolean IsFriendSendReport(UInt64 userID, UInt64 targetID) => config.ReferenceSettings.FriendsSetting.SendReportFriend && IsFriends(userID, targetID);

        private void DrawUI_ModeratorStatistics(BasePlayer Moderator)
        {
            if (!ModeratorInformations.ContainsKey(Moderator.userID))
                ModeratorInformations.Add(Moderator.userID, new ModeratorInformation());

            String Interface = InterfaceBuilder.GetInterface($"{InterfaceBuilder.UI_LAYER}_PROFILE_MODERATION_INFO_PANEL");
            if (Interface == null) return;

            Interface = Interface.Replace("%TITLE_PROFILE_MODERATOR_STATISTICS_TITLE%",
                GetLang("TITLE_PROFILE_MODERATOR_STATISTICS_TITLE", Moderator.UserIDString));
            Interface = Interface.Replace("%TITLE_PROFILE_MODERATOR_STATISTICS_TITLE_QUALITY_ASSESSMENT%",
                GetLang("TITLE_PROFILE_MODERATOR_STATISTICS_TITLE_QUALITY_ASSESSMENT", Moderator.UserIDString));

            CuiHelper.DestroyUi(Moderator, InterfaceBuilder.UI_REPORT_MODERATOR_STATISTICS);
            CuiHelper.AddUi(Moderator, Interface);

            ModeratorInformation ModeratorInformation = ModeratorInformations[Moderator.userID];
            Int32 AllScoreModerator = ModeratorInformation.GetAverageRaiting();

            DrawUI_ModeratorStitistics_Banner(Moderator, "-96.947 -98", "91.72 -44",
                GetLang("TITLE_PROFILE_MODERATOR_STATISTICS_TITLE_CHECKED", Moderator.UserIDString), $"{ModeratorInformation.AmountChecked}",
                GetLang("TITLE_PROFILE_MODERATOR_STATISTICS_DESCRIPTION_BANS_AND_CHECHKED", Moderator.UserIDString));

            DrawUI_ModeratorStitistics_Banner(Moderator, "-96.947 -166.733", "91.72 -112",
                GetLang("TITLE_PROFILE_MODERATOR_STATISTICS_TITLE_BANS", Moderator.UserIDString), $"{ModeratorInformation.AmountBans}",
                GetLang("TITLE_PROFILE_MODERATOR_STATISTICS_DESCRIPTION_BANS_AND_CHECHKED", Moderator.UserIDString));

            DrawUI_ModeratorStitistics_Banner(Moderator, "-96.947 -273.667", "91.72 -219.667",
                GetLang("TITLE_PROFILE_MODERATOR_STATISTICS_TITLE_ALLSCORE", Moderator.UserIDString), $"{AllScoreModerator}",
                CountRaiting: AllScoreModerator);

            DrawUI_ModeratorStitistics_Banner(Moderator, "-97 -342.533", "91.667 -288.533",
                GetLang("TITLE_PROFILE_MODERATOR_STATISTICS_TITLE_ONE_ACHIVE", Moderator.UserIDString), $"{ModeratorInformation.GetAverageRaitingAchive(ModeratorInformation.OneScore)}",
                GetLang("TITLE_PROFILE_MODERATOR_STATISTICS_DESCRIPTION_ONE_ACHIVE", Moderator.UserIDString));

            DrawUI_ModeratorStitistics_Banner(Moderator, "-97 -411.533", "91.667 -357.533",
                GetLang("TITLE_PROFILE_MODERATOR_STATISTICS_TITLE_TWO_ACHIVE", Moderator.UserIDString), $"{ModeratorInformation.GetAverageRaitingAchive(ModeratorInformation.TwoScore)}",
                GetLang("TITLE_PROFILE_MODERATOR_STATISTICS_DESCRIPTION_TWO_ACHIVE", Moderator.UserIDString));

            DrawUI_ModeratorStitistics_Banner(Moderator, "-96.947 -479.667", "91.72 -425.667",
                GetLang("TITLE_PROFILE_MODERATOR_STATISTICS_TITLE_THREE_ACHIVE", Moderator.UserIDString), $"{ModeratorInformation.GetAverageRaitingAchive(ModeratorInformation.ThreeScore)}",
                GetLang("TITLE_PROFILE_MODERATOR_STATISTICS_DESCRIPTION_THREE_ACHIVE", Moderator.UserIDString));
        }


        private void SendVK(String Message)
        {
            if (String.IsNullOrWhiteSpace(config.NotifyVKSettings.VKTokenGroup) || String.IsNullOrWhiteSpace(config.NotifyVKSettings.VKChatID)) return;

            while (Message.Contains("#"))
                Message = Message.Replace("#", "%23");

            RequestVK(Message);
        }

        private void DrawUI_ModeratorStitistics_Banner_RaitingImage(BasePlayer Moderator, Int32 X)
        {
            String Interface = InterfaceBuilder.GetInterface($"{InterfaceBuilder.UI_LAYER}_PROFILE_BANNER_TEMPLATE_ADDITIONAL_IMG");
            if (Interface == null) return;

            Interface = Interface.Replace("%OFFSET_MIN%", $"{-59.851 + (X * 12)} -13.933");
            Interface = Interface.Replace("%OFFSET_MAX%", $"{-49.184 + (X * 12)} -3.933");

            CuiHelper.AddUi(Moderator, Interface);
        }
        private List<Fields> DT_StartCheck(BasePlayer Target, BasePlayer Moderator, Boolean IsConsole = false)
        {
            String ModeratorName = !IsConsole && Moderator != null ? Moderator.displayName : "Console";
            String ModeratorID = !IsConsole && Moderator != null ? Moderator.UserIDString : "Console";

            List<Fields> fields = new List<Fields>
            {
                new Fields(LanguageEn ? "A new player check has been launched :" : "ÐÐ°Ð¿ÑÑÐµÐ½Ð° Ð½Ð¾Ð²Ð°Ñ Ð¿ÑÐ¾Ð²ÐµÑÐºÐ° Ð¸Ð³ÑÐ¾ÐºÐ° :", "", false),
                new Fields("", "", false),
                new Fields(LanguageEn ? "Moderator Information :" : "ÐÐ½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ñ Ð¾ Ð¼Ð¾Ð´ÐµÑÐ°ÑÐ¾ÑÐµ :", "", false),
                new Fields("", "", false),
                new Fields(LanguageEn ? "Nick" : "ÐÐ¸Ðº", $"{ModeratorName}", true),
                new Fields("Steam64ID", $"[{ModeratorID}](https://steamcommunity.com/profiles/{ModeratorID})", true),
                new Fields("", "", false),
                new Fields(LanguageEn ? "Information about the suspect :" : "ÐÐ½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ñ Ð¾ Ð¿Ð¾Ð´Ð¾Ð·ÑÐµÐ²Ð°ÐµÐ¼Ð¾Ð¼ :", "", false),
                new Fields("", "", false),
                new Fields(LanguageEn ? "Nick" : "ÐÐ¸Ðº", $"{Target.displayName}", true),
                new Fields("Steam64ID", $"[{Target.userID}](https://steamcommunity.com/profiles/{Target.userID})", true),
            };

            return fields;
        }

        private IEnumerator StartAfkCheck(BasePlayer Target, BasePlayer Moderator, Boolean IsConsole = false, Boolean SkipAFK = false)
        {
            UInt64 TargetID = Target.userID;
            if (!IsValidStartChecked(Target, Moderator, IsConsole)) yield break;

            if (!PlayerChecks.ContainsKey(TargetID))
            {
                PlayerChecks.Add(Target.userID, new ProcessCheckRepository
                {
                    DiscordTarget = String.Empty,
                    DisplayName = Target.displayName,
                    ModeratorID = !IsConsole ? Moderator.userID : 0
                });
            }
            else
            {
                PlayerChecks[TargetID].DisplayName = Target.displayName;
                PlayerChecks[TargetID].ModeratorID = !IsConsole ? Moderator.userID : 0;
                PlayerChecks[TargetID].DiscordTarget = String.Empty;
            }

            if (!SkipAFK)
            {
                if (!IsConsole && Moderator != null)
                    SendChat(GetLang("FUNCIONAL_MESSAGE_CHECK_AFK_STARTING", Moderator.UserIDString), Moderator);
                else Puts(LanguageEn ? "We start checking the player on AFK" : "ÐÐ°ÑÐ¸Ð½Ð°ÐµÐ¼ Ð¿ÑÐ¾Ð²ÐµÑÐºÑ Ð¸Ð³ÑÐ¾ÐºÐ° Ð½Ð° AFK");

                Int32 NoAFK_Amount = 0;
                for (Int32 TryCheck = 1; TryCheck < 6; TryCheck++)
                {
                    if (Target == null)
                    {
                        if (!IsConsole && Moderator != null)
                            SendChat(GetLang("FUNCIONAL_MESSAGE_CHECK_AFK_PLAYER_LEAVE", Moderator.UserIDString), Moderator);
                        else Puts(LanguageEn ? "The player left the server at the stage of checking for AFK. Check canceled, try again later" : "ÐÐ³ÑÐ¾Ðº Ð¿Ð¾ÐºÐ¸Ð½ÑÐ» ÑÐµÑÐ²ÐµÑ Ð½Ð° ÑÑÐ°Ð´Ð¸Ð¸ Ð¿ÑÐ¾Ð²ÐµÑÐºÐ¸ Ð½Ð° AFK. ÐÑÐ¾Ð²ÐµÑÐºÐ° Ð¾ÑÐ¼ÐµÐ½ÐµÐ½Ð°, Ð¿Ð¾Ð²ÑÐ¾ÑÐ¸ÑÐµ Ð¿Ð¾Ð¿ÑÑÐºÑ Ð¿Ð¾Ð·Ð¶Ðµ");

                        StopCheckedPlayer(TargetID, Moderator, true);
                        yield break;
                    }

                    if (!IsConsole)
                        if (Moderator == null)
                        {
                            PrintWarning(LanguageEn
                                ? $"The moderator who called the player {Target.displayName}({Target.UserIDString}) - left the server, interrupting the check AFK!"
                                : $"ÐÐ¾Ð´ÐµÑÐ°ÑÐ¾Ñ Ð²ÑÐ·Ð²Ð°Ð²ÑÐ¸Ð¹ Ð¸Ð³ÑÐ¾ÐºÐ° {Target.displayName}({Target.UserIDString}) - Ð¿Ð¾ÐºÐ¸Ð½ÑÐ» ÑÐµÑÐ²ÐµÑ, Ð¿ÑÐµÑÐ²Ð°Ð² Ð¿ÑÐ¾Ð²ÐµÑÐºÑ Ð½Ð° AFK!");
                            StopCheckedPlayer(TargetID, Moderator, true);
                            yield break;
                        }

                    if (Target.IdleTime < 10)
                        NoAFK_Amount++;

                    if (!IsConsole && Moderator != null)
                        SendChat(GetLang("FUNCIONAL_MESSAGE_CHECK_AFK_TRY", Moderator.UserIDString, TryCheck), Moderator);
                    else Puts(LanguageEn ? $"Checking a player for AFK. Attemp : {TryCheck}" : $"ÐÑÐ¾Ð²ÐµÑÑÐµÐ¼ Ð¸Ð³ÑÐ¾ÐºÐ° Ð½Ð° AFK. ÐÐ¾Ð¿ÑÑÐºÐ° : {TryCheck}");
                    yield return CoroutineEx.waitForSeconds(5f);
                }

                if (NoAFK_Amount <= 3)
                {
                    if (!IsConsole && Moderator != null)
                        SendChat(GetLang("FUNCIONAL_MESSAGE_CHECK_AFK_PLAYER_AFK", Moderator.UserIDString), Moderator);
                    else Puts(LanguageEn ? $"Check has not been started. The player is in AFK, please try again later" : "ÐÑÐ¾Ð²ÐµÑÐºÐ° Ð½Ðµ Ð±ÑÐ»Ð° Ð·Ð°Ð¿ÑÑÐµÐ½Ð°. ÐÐ³ÑÐ¾Ðº Ð½Ð°ÑÐ¾Ð´Ð¸ÑÑÑ Ð² AFK, Ð¿Ð¾Ð¶Ð°Ð»ÑÐ¹ÑÑÐ° Ð¿Ð¾Ð²ÑÐ¾ÑÐ¸ÑÐµ Ð¿Ð¾Ð¿ÑÑÐºÑ Ð¿Ð¾Ð·Ð¶Ðµ");

                    StopCheckedPlayer(TargetID, Moderator, true);
                    yield break;
                }
            }

            StartCheckedPlayer(Target, Moderator, IsConsole);
        }
        private Dictionary<BasePlayer, Coroutine> AfkCheckRoutine = new Dictionary<BasePlayer, Coroutine>();


        private void StartPluginLoad()
        {
            _ = this;

            //AddCommands
            cmd.AddChatCommand(config.CommandForContact, this, nameof(ChatCommandDiscord));
            cmd.AddConsoleCommand(config.CommandForContact, this, nameof(ConsoleCommandDiscord));

            //Validate DataFile
            foreach (BasePlayer player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);

            //Load your images here
            ImageUi.Initialize();
            ImageUi.DownloadImages();

            //Starting IQFakeActive
            StartSysncFakeActive();
        }


        private class ImageUi
        {
            private static Coroutine coroutineImg = null;
            private static Dictionary<String, String> Images = new Dictionary<String, String>();

            private static List<String> KeyImages = new List<String>();

            public static void DownloadImages() { coroutineImg = ServerMgr.Instance.StartCoroutine(AddImage()); }

            private static IEnumerator AddImage()
            {
                if (_ == null)
                    yield break;
                _.PrintWarning("ÐÐµÐ½ÐµÑÐ¸ÑÑÐµÐ¼ Ð¸Ð½ÑÐµÑÑÐµÐ¹Ñ, Ð¾Ð¶Ð¸Ð´Ð°Ð¹ÑÐµ ~10-15 ÑÐµÐºÑÐ½Ð´!");
                foreach (String URL in KeyImages)
                {
                    String KeyName = URL;
                    if (KeyName == null) throw new ArgumentNullException(nameof(KeyName));

                    UnityWebRequest www = UnityWebRequestTexture.GetTexture(URL);
                    yield return www.SendWebRequest();

                    if (www.isNetworkError || www.isHttpError)
                    {
                        _.PrintWarning($"Image download error! Error: {www.error}, Image name: {KeyName}");
                        www.Dispose();
                        coroutineImg = null;
                        yield break;
                    }

                    Texture2D texture = DownloadHandlerTexture.GetContent(www);
                    if (texture != null)
                    {
                        Byte[] bytes = texture.EncodeToPNG();

                        String image = FileStorage.server.Store(bytes, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID).ToString();
                        if (!Images.ContainsKey(KeyName))
                            Images.Add(KeyName, image);
                        else
                            Images[KeyName] = image;

                        UnityEngine.Object.DestroyImmediate(texture);
                    }

                    www.Dispose();
                    yield return CoroutineEx.waitForSeconds(0.02f);
                }

                yield return CoroutineEx.waitForSeconds(0.02f);
                coroutineImg = null;

                _interface = new InterfaceBuilder();
                _.PrintWarning("ÐÐ½ÑÐµÑÑÐµÐ¹Ñ ÑÑÐ¿ÐµÑÐ½Ð¾ Ð·Ð°Ð³ÑÑÐ¶ÐµÐ½!");
            }

            public static string GetImage(String ImgKey)
            {
                if (Images.ContainsKey(ImgKey))
                    return Images[ImgKey];
                return _.GetImage("LOADING");
            }
            public static void Initialize()
            {
                KeyImages = new List<String>();
                Images = new Dictionary<string, string>();

                Configuration.Images ImagesPlugin = config.ImagesSettings;

                if (!KeyImages.Contains(ImagesPlugin.Background))
                    KeyImages.Add(ImagesPlugin.Background);

                if (!KeyImages.Contains(ImagesPlugin.PageDown))
                    KeyImages.Add(ImagesPlugin.PageDown);

                if (!KeyImages.Contains(ImagesPlugin.PageUp))
                    KeyImages.Add(ImagesPlugin.PageUp);

                if (!KeyImages.Contains(ImagesPlugin.Search))
                    KeyImages.Add(ImagesPlugin.Search);

                if (!KeyImages.Contains(ImagesPlugin.AvatarBlur))
                    KeyImages.Add(ImagesPlugin.AvatarBlur);


                if (!KeyImages.Contains(ImagesPlugin.ReasonModeratorAndRaiting))
                    KeyImages.Add(ImagesPlugin.ReasonModeratorAndRaiting);

                if (!KeyImages.Contains(ImagesPlugin.PlayerAlerts))
                    KeyImages.Add(ImagesPlugin.PlayerAlerts);


                if (!KeyImages.Contains(ImagesPlugin.StatisticsBlockSettings.BlockStatsModeration))
                    KeyImages.Add(ImagesPlugin.StatisticsBlockSettings.BlockStatsModeration);

                if (!KeyImages.Contains(ImagesPlugin.StatisticsBlockSettings.BlockStatsRaitingModeration))
                    KeyImages.Add(ImagesPlugin.StatisticsBlockSettings.BlockStatsRaitingModeration);

                if (!KeyImages.Contains(ImagesPlugin.StatisticsBlockSettings.RaitingImage))
                    KeyImages.Add(ImagesPlugin.StatisticsBlockSettings.RaitingImage);



                if (!KeyImages.Contains(ImagesPlugin.PlayerListBlockSettings.PoopUpBackgorund))
                    KeyImages.Add(ImagesPlugin.PlayerListBlockSettings.PoopUpBackgorund);

                if (!KeyImages.Contains(ImagesPlugin.PlayerListBlockSettings.PoopUpReasonBackgorund))
                    KeyImages.Add(ImagesPlugin.PlayerListBlockSettings.PoopUpReasonBackgorund);



                if (!KeyImages.Contains(ImagesPlugin.LeftBlockSettings.ButtonBackgorund))
                    KeyImages.Add(ImagesPlugin.LeftBlockSettings.ButtonBackgorund);

                if (!KeyImages.Contains(ImagesPlugin.LeftBlockSettings.ModerationIcon))
                    KeyImages.Add(ImagesPlugin.LeftBlockSettings.ModerationIcon);

                if (!KeyImages.Contains(ImagesPlugin.LeftBlockSettings.ReportIcon))
                    KeyImages.Add(ImagesPlugin.LeftBlockSettings.ReportIcon);



                if (!KeyImages.Contains(ImagesPlugin.ModerationBlockSettings.ModeratorPoopUPBackgorund))
                    KeyImages.Add(ImagesPlugin.ModerationBlockSettings.ModeratorPoopUPBackgorund);

                if (!KeyImages.Contains(ImagesPlugin.ModerationBlockSettings.ModeratorPoopUPTextBackgorund))
                    KeyImages.Add(ImagesPlugin.ModerationBlockSettings.ModeratorPoopUPTextBackgorund);

                if (!KeyImages.Contains(ImagesPlugin.ModerationBlockSettings.ModeratorPoopUPPanelBackgorund))
                    KeyImages.Add(ImagesPlugin.ModerationBlockSettings.ModeratorPoopUPPanelBackgorund);



                if (!KeyImages.Contains(ImagesPlugin.ModeratorMenuCheckedSettings.ModeratorCheckedBackground))
                    KeyImages.Add(ImagesPlugin.ModeratorMenuCheckedSettings.ModeratorCheckedBackground);

                if (!KeyImages.Contains(ImagesPlugin.ModeratorMenuCheckedSettings.ModeratorCheckedStopButton))
                    KeyImages.Add(ImagesPlugin.ModeratorMenuCheckedSettings.ModeratorCheckedStopButton);

                if (!KeyImages.Contains(ImagesPlugin.ModeratorMenuCheckedSettings.ModeratorVerdictButton))
                    KeyImages.Add(ImagesPlugin.ModeratorMenuCheckedSettings.ModeratorVerdictButton);

                if (!KeyImages.Contains(ImagesPlugin.ModeratorMenuCheckedSettings.SteamIcoPlayer))
                    KeyImages.Add(ImagesPlugin.ModeratorMenuCheckedSettings.SteamIcoPlayer);

                if (!KeyImages.Contains(ImagesPlugin.ModeratorMenuCheckedSettings.PirateIcoPlayer))
                    KeyImages.Add(ImagesPlugin.ModeratorMenuCheckedSettings.PirateIcoPlayer);


                if (!KeyImages.Contains(ImagesPlugin.PlayerMenuRaitingSettings.PlayerMenuRaitingBackground))
                    KeyImages.Add(ImagesPlugin.PlayerMenuRaitingSettings.PlayerMenuRaitingBackground);


            }
            public static void Unload()
            {
                coroutineImg = null;
                foreach (KeyValuePair<String, String> item in Images)
                    FileStorage.server.RemoveExact(UInt32.Parse(item.Value), FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID, 0U);

                KeyImages.Clear();
                KeyImages = null;
                Images.Clear();
                Images = null;
            }
        }


        public List<FakePlayer> PlayerBases = new List<FakePlayer>();

        private void StartCheckedPlayer(BasePlayer Target, BasePlayer Moderator, Boolean IsConsole = false)
        {
            if (!IsConsole)
            {
                if (Moderator == null)
                {
                    PrintWarning(LanguageEn
                        ? $"The moderator who called the player {Target.displayName}({Target.UserIDString}) - left the server, interrupting start checking!"
                        : $"ÐÐ¾Ð´ÐµÑÐ°ÑÐ¾Ñ Ð²ÑÐ·Ð²Ð°Ð²ÑÐ¸Ð¹ Ð¸Ð³ÑÐ¾ÐºÐ° {Target.displayName}({Target.UserIDString}) - Ð¿Ð¾ÐºÐ¸Ð½ÑÐ» ÑÐµÑÐ²ÐµÑ, Ð¿ÑÐµÑÐ²Ð°Ð² Ð·Ð°Ð¿ÑÑÐº Ð¿ÑÐ¾Ð²ÐµÑÐºÐ¸!");
                    StopCheckedPlayer(Target.userID, Moderator);
                    return;
                }

                DrawUI_Moderator_Checked_Menu(Moderator, Target.userID);
            }

            PlayerChecks[Target.userID].DisplayName = Target.displayName;

            UInt64 ModratorID = !IsConsole ? Moderator.userID : 0;
            StartCheckRCC(Target.userID, ModratorID);
            StartCheckOzProtect(Target.userID, ModratorID);
            DrawUI_Player_Alert(Target);

            if (config.CheckControllerSettings.UseDemo)
                Target.StartDemoRecording();

            StopDamageAdd(Target);

            if (config.NotifyChatSettings.UseNotifyCheck)
            {
                if (!IsConsole && Moderator != null)
                {
                    foreach (BasePlayer player in BasePlayer.activePlayerList)
                        SendChat(GetLang("NOTIFY_PLAYERS_START_CHECK_MODERATOR", player.UserIDString, Moderator.displayName, PlayerChecks[Target.userID].DisplayName), player);
                }
                else
                {
                    foreach (BasePlayer player in BasePlayer.activePlayerList)
                        SendChat(GetLang("NOTIFY_PLAYERS_START_CHECK_NOT_MODERATOR", player.UserIDString, Target.displayName), player);
                }
            }

            Configuration.NotifyDiscord.Webhooks.TemplatesNotify TemplateDiscord = config.NotifyDiscordSettings.WebhooksList.NotifyStartCheck;

            if (!String.IsNullOrWhiteSpace(TemplateDiscord.WebhookNotify))
            {
                List<Fields> fields = DT_StartCheck(Target, Moderator, IsConsole);
                SendDiscord(TemplateDiscord.WebhookNotify, fields, GetAuthorDiscord(TemplateDiscord), TemplateDiscord.Color);
            }

            SendVK(VKT_StartCheck(Target, Moderator, IsConsole));

            if (!IsConsole && Moderator != null)
                SendChat(GetLang("FUNCIONAL_MESSAGE_CHECK_START", Moderator.UserIDString), Moderator);
            else Puts(LanguageEn ? "The check is started, the player is notified!" : "ÐÑÐ¾Ð²ÐµÑÐºÐ° Ð·Ð°Ð¿ÑÑÐµÐ½Ð°, Ð¸Ð³ÑÐ¾Ðº ÑÐ²ÐµÐ´Ð¾Ð¼Ð»ÐµÐ½!");

            if (config.ReportSendControllerSettings.NoRepeatReport)
            {
                PlayerRepository repository = PlayerRepositories.FirstOrDefault(x => x.Value.IsRepeatReported(Target.userID)).Value;
                if (repository != null)
                    repository.ReportedList.Remove(Target.userID);
            }

            Interface.Call("OnStartedChecked", Target, Moderator, IsConsole);
        }
        private static IQReportSystem _;


        private void DrawUI_Reason_Raiting_Or_Moderator_Menu(BasePlayer moderator, String Text, String ParentUI, String NameLayer, String OffsetMin, String OffsetMax, String Command)
        {
            String Interface = InterfaceBuilder.GetInterface($"{InterfaceBuilder.UI_LAYER}_REASON_MENU_LABEL");
            if (Interface == null) return;

            Interface = Interface.Replace("%PARENT_UI%", ParentUI);
            Interface = Interface.Replace("%REASON_NAME%", NameLayer);
            Interface = Interface.Replace("%OFFSET_MIN%", OffsetMin);
            Interface = Interface.Replace("%OFFSET_MAX%", OffsetMax);
            Interface = Interface.Replace("%TEXT_TITLE%", Text);
            Interface = Interface.Replace("%COMMAND_REASON%", Command);

            CuiHelper.AddUi(moderator, Interface);
        }

        private void DrawUI_ModeratorStitistics_Banner(BasePlayer Moderator, String OffsetMin, String OffsetMax, String TitleBanner, String ArgBanner, String AdditionalText = "", Int32 CountRaiting = -1)
        {
            String Interface = InterfaceBuilder.GetInterface($"{InterfaceBuilder.UI_LAYER}_PROFILE_BANNER_TEMPLATE");
            if (Interface == null) return;

            Interface = Interface.Replace("%OFFSET_MIN%", OffsetMin);
            Interface = Interface.Replace("%OFFSET_MAX%", OffsetMax);
            Interface = Interface.Replace("%TITLE_BANNER%", TitleBanner);
            Interface = Interface.Replace("%ARGS_BANNER%", ArgBanner);

            CuiHelper.AddUi(Moderator, Interface);

            if (!String.IsNullOrWhiteSpace(AdditionalText))
            {
                DrawUI_ModeratorStitistics_Banner_AdditionalText(Moderator, AdditionalText);
                return;
            }

            if (CountRaiting < 0) return;

            for (Int32 Raiting = 0; Raiting < CountRaiting; Raiting++)
                DrawUI_ModeratorStitistics_Banner_RaitingImage(Moderator, Raiting);
        }
        private static Double CurrentTime => Facepunch.Math.Epoch.Current;

        private Boolean IsCombatBlock(BasePlayer Target)
        {
            if (!NoEscape) return false;
            if (!config.ReferenceSettings.NoEscapeSetting.NoCheckedCombatBlock) return false;
            Boolean IsCombatBlock = (Boolean)NoEscape.CallHook("IsCombatBlocked", Target);

            return IsCombatBlock;
        }
        public Boolean HasImage(String imageName) => (Boolean)ImageLibrary?.Call("HasImage", imageName);

        public class OzResponse
        {
            public int unixtime { get; set; }
            public string reason { get; set; }
            public string proofid { get; set; }
            public bool pirate { get; set; }
            public bool active { get; set; }
            public bool reliable { get; set; }
            public bool unnecessary { get; set; }
            public OzServer server { get; set; }
            public string admin { get; set; }
            public int game { get; set; }
            public string date { get; set; }
            public int bantime { get; set; }
        }
        private class Configuration
        {
            [JsonProperty(LanguageEn ? "Setting up compatibility with IQReportSystemr" : "ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ° ÑÐ¾Ð²Ð¼ÐµÑÑÐ¸Ð¼Ð¾ÑÑÐµÐ¹ Ñ IQReportSystem")]
            public References ReferenceSettings = new References();

            [JsonProperty(LanguageEn ? "Color setting" : "ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ° ÑÐ²ÐµÑÐ¾Ð²")]
            public Colors ColorsSettings = new Colors();
            [JsonProperty(LanguageEn ? "Setting images" : "ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ° Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ð¹")]
            public Images ImagesSettings = new Images();
            [JsonProperty(LanguageEn ? "List of reports and reasons for blocking" : "Ð¡Ð¿Ð¸ÑÐ¾Ðº Ð¶Ð°Ð»Ð¾Ð± Ð¸ Ð¿ÑÐ¸ÑÐ¸Ð½ Ð±Ð»Ð¾ÐºÐ¸ÑÐ¾Ð²ÐºÐ¸")]
            public List<ReasonReport> ReasonList = new List<ReasonReport>();
            [JsonProperty(LanguageEn ? "Setting up sending complaints via F7 or the RUST game menu" : "ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ° Ð¾ÑÐ¿ÑÐ°Ð²ÐºÐ¸ Ð¶Ð°Ð»Ð¾Ð± ÑÐµÑÐµÐ· F7 Ð¸Ð»Ð¸ Ð¸Ð³ÑÐ¾Ð²Ð¾Ðµ Ð¼ÐµÐ½Ñ RUST")]
            public ReportF7AndGameMenu ReportF7AndGameMenuSettings = new ReportF7AndGameMenu();
            [JsonProperty(LanguageEn ? "Setting up the Player check process" : "ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ° Ð¿ÑÐ¾ÑÐµÑÑÐ° Ð¿ÑÐ¾Ð²ÐµÑÐºÐ¸ Ð¸Ð³ÑÐ¾ÐºÐ°")]
            public CheckController CheckControllerSettings = new CheckController();
            [JsonProperty(LanguageEn ? "Setting up moderator notifications and the maximum number of reports" : "ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ° ÑÐ²ÐµÐ´Ð¾Ð¼Ð»ÐµÐ½Ð¸Ñ Ð¼Ð¾Ð´ÐµÑÐ°ÑÐ¾ÑÐ¾Ð² Ð¸ Ð¼Ð°ÐºÑÐ¸Ð¼Ð°Ð»ÑÐ½Ð¾Ð³Ð¾ ÐºÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ð° ÑÐµÐ¿Ð¾ÑÑÐ¾Ð²")]
            public ReportContollerModeration ReportContollerModerationSettings = new ReportContollerModeration();
            [JsonProperty(LanguageEn ? "Setting up sending complaints by players" : "ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ° Ð¾ÑÐ¿ÑÐ°Ð²ÐºÐ¸ Ð¶Ð°Ð»Ð¾Ð± Ð¸Ð³ÑÐ¾ÐºÐ°Ð¼Ð¸")]
            public ReportSendController ReportSendControllerSettings = new ReportSendController();
            [JsonProperty(LanguageEn ? "Additional verdict setting" : "ÐÐ¾Ð¿Ð¾Ð»Ð½Ð¸ÑÐµÐ»ÑÐ½Ð°Ñ Ð½Ð°ÑÑÑÐ¾Ð¹ÐºÐ° Ð²ÑÐ½ÐµÑÐµÐ½Ð¸Ñ Ð²ÐµÑÐ´Ð¸ÐºÑÐ°")]
            public VerdictController VerdictControllerSettings = new VerdictController();
            [JsonProperty(LanguageEn ? "Configuring notifications for all players about actions in the plugin" : "ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ° ÑÐ²ÐµÐ´Ð¾Ð¼Ð»ÐµÐ½Ð¸Ð¹ Ð´Ð»Ñ Ð²ÑÐµÑ Ð¸Ð³ÑÐ¾ÐºÐ¾Ð² Ð¾ Ð´ÐµÐ¹ÑÑÐ²Ð¸ÑÑ Ð² Ð¿Ð»Ð°Ð³Ð¸Ð½Ðµ")]
            public NotifyChat NotifyChatSettings = new NotifyChat();
            [JsonProperty(LanguageEn ? "Setting up notifications in Discord" : "ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ° ÑÐ²ÐµÐ´Ð¾Ð¼Ð»ÐµÐ½Ð¸Ð¹ Ð² Discord")]
            public NotifyDiscord NotifyDiscordSettings = new NotifyDiscord();
            [JsonProperty(LanguageEn ? "Setting up notifications in VK" : "ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ° ÑÐ²ÐµÐ´Ð¾Ð¼Ð»ÐµÐ½Ð¸Ð¹ Ð² VK")]
            public NotifyVK NotifyVKSettings = new NotifyVK();
            [JsonProperty(LanguageEn ? "Command to send data when calling for verification (console and chat)" : "ÐÐ¾Ð¼Ð°Ð½Ð´Ð° Ð´Ð»Ñ Ð¾ÑÐ¿ÑÐ°Ð²ÐºÐ¸ Ð´Ð°Ð½Ð½ÑÑ Ð¿ÑÐ¸ Ð²ÑÐ·Ð¾Ð²Ðµ Ð½Ð° Ð¿ÑÐ¾Ð²ÐµÑÐºÑ (ÐºÐ¾Ð½ÑÐ¾Ð»ÑÐ½Ð°Ñ Ð¸ ÑÐ°ÑÐ¾Ð²Ð°Ñ)")]
            public String CommandForContact;

            internal class VerdictController
            {
                [JsonProperty(LanguageEn ? "Banned all the `Friends` of a player who has been given a verdict by a moderator (true - yes/false - no)" : "ÐÐ»Ð¾ÐºÐ¸ÑÐ¾Ð²Ð°ÑÑ Ð²ÑÐµÑ `ÐÑÑÐ·ÐµÐ¹` Ð¸Ð³ÑÐ¾ÐºÐ°, ÐºÐ¾ÑÐ¾ÑÐ¾Ð¼Ñ Ð²ÑÐ½ÐµÑ Ð²ÐµÑÐ´Ð¸ÐºÑ Ð¼Ð¾Ð´ÐµÑÐ°ÑÐ¾Ñ (true - Ð´Ð°/false - Ð½ÐµÑ)")]
                public Boolean UseBanAllTeam;
                [JsonProperty(LanguageEn ? "Index from the list of complaints when blocking a player's `Friends` (From your list - starts from 0)" : "ÐÐ½Ð´ÐµÐºÑ Ð¸Ð· ÑÐ¿Ð¸ÑÐºÐ° Ð¶Ð°Ð»Ð¾Ð± Ð¿ÑÐ¸ Ð±Ð»Ð¾ÐºÐ¸ÑÐ¾Ð²ÐºÐ¸ `ÐÑÑÐ·ÐµÐ¹` Ð¸Ð³ÑÐ¾ÐºÐ°  (ÐÐ· Ð²Ð°ÑÐµÐ³Ð¾ ÑÐ¿Ð¸ÑÐºÐ° - Ð½Ð°ÑÐ¸Ð½Ð°ÐµÑÑÑ Ð¾Ñ 0)")]
                public Int32 IndexBanReason;
            }
            internal class CheckController
            {
                [JsonProperty(LanguageEn ? "Use sound notification for players when calling for verification (true - yes / false - no) [You must upload sound files to the IQSystem/IQReportSystem/Sounds folder]" : "ÐÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ Ð·Ð²ÑÐºÐ¾Ð²Ð¾Ðµ Ð¾Ð¿Ð¾Ð²ÐµÑÐµÐ½Ð¸Ðµ Ð´Ð»Ñ Ð¸Ð³ÑÐ¾ÐºÐ¾Ð² Ð¿ÑÐ¸ Ð²ÑÐ·Ð¾Ð²Ðµ Ð½Ð° Ð¿ÑÐ¾Ð²ÐµÑÐºÑ (true - Ð´Ð°/false - Ð½ÐµÑ) [ÐÑ Ð´Ð¾Ð»Ð¶Ð½Ñ Ð·Ð°Ð³ÑÑÐ·Ð¸ÑÑ ÑÐ°Ð¹Ð»Ñ ÑÐ¾ Ð·Ð²ÑÐºÐ¾Ð¼ Ð² Ð¿Ð°Ð¿ÐºÑ IQSystem/IQReportSystem/Sounds]")]
                public Boolean UseSoundAlert;
                [JsonProperty(LanguageEn ? "Record a demos of the player during his check" : "ÐÐ°Ð¿Ð¸ÑÑÐ²Ð°ÑÑ Ð´ÐµÐ¼Ð¾ Ð¸Ð³ÑÐ¾ÐºÐ° Ð²Ð¾ Ð²ÑÐµÐ¼Ñ ÐµÐ³Ð¾ Ð¿ÑÐ¾Ð²ÐµÑÐºÐ¸")]
                public Boolean UseDemo;
                [JsonProperty(LanguageEn ? "Use AFK validation before calling for check (true - yes / false - no)" : "ÐÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ Ð¿ÑÐ¾Ð²ÐµÑÐºÑ Ð½Ð° AFK Ð¿ÐµÑÐµÐ´ Ð²ÑÐ·Ð¾Ð²Ð¾Ð¼ Ð½Ð° Ð¿ÑÐ¾Ð²ÐµÑÐºÑ (true - Ð´Ð°/false - Ð½ÐµÑ)")]
                public Boolean UseCheckAFK;
                [JsonProperty(LanguageEn ? "Cancel check for a player automatically with saving reports if he left the server for 15 minutes or more (true - yes/false - no)" : "ÐÑÐ¼ÐµÐ½ÑÑÑ Ð¿ÑÐ¾Ð²ÐµÑÐºÑ Ð¸Ð³ÑÐ¾ÐºÑ Ð°Ð²ÑÐ¾Ð¼Ð°ÑÐ¸ÑÐµÑÐºÐ¸ Ñ ÑÐ¾ÑÑÐ°Ð½ÐµÐ½Ð¸ÐµÐ¼ ÑÐµÐ¿Ð¾ÑÑÐ¾Ð² ÐµÑÐ»Ð¸ Ð¾Ð½ Ð¿Ð¾ÐºÐ¸Ð½ÑÐ» ÑÐµÑÐ²ÐµÑ Ð½Ð° 15 Ð¼Ð¸Ð½ÑÑ Ð¸ Ð±Ð¾Ð»ÐµÐµ (true - Ð´Ð°/false - Ð½ÐµÑ)")]
                public Boolean StopCheckLeavePlayer;

                [JsonProperty(LanguageEn ? "Use tracking of crafting of invaders by the player (will notify the moderator about it) (true - yes / false - no)" : "ÐÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ Ð¾ÑÑÐ»ÐµÐ¶Ð¸Ð²Ð°Ð½Ð¸Ðµ ÐºÑÐ°ÑÑÐ° Ð¿ÑÐµÐ´Ð¼ÐµÑÐ¾Ð² Ð¸Ð³ÑÐ¾ÐºÐ¾Ð¼ (Ð±ÑÐ´ÐµÑ ÑÐ²ÐµÐ´Ð¾Ð¼Ð»ÑÑÑ Ð¼Ð¾Ð´ÐµÑÐ°ÑÐ¾ÑÐ° Ð¾Ð± ÑÑÐ¾Ð¼) (true - Ð´Ð°/false - Ð½ÐµÑ)")]
                public Boolean TrackCrafting;
                [JsonProperty(LanguageEn ? "Use tracking of messages sent to the chat by the player (will notify the moderator about it) (true - yes / false - no)" : "ÐÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ Ð¾ÑÑÐ»ÐµÐ¶Ð¸Ð²Ð°Ð½Ð¸Ðµ Ð¾ÑÐ¿ÑÐ°Ð²ÐºÐ¸ ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ð¹ Ð² ÑÐ°Ñ Ð¸Ð³ÑÐ¾ÐºÐ¾Ð¼ (Ð±ÑÐ´ÐµÑ ÑÐ²ÐµÐ´Ð¾Ð¼Ð»ÑÑÑ Ð¼Ð¾Ð´ÐµÑÐ°ÑÐ¾ÑÐ° Ð¾Ð± ÑÑÐ¾Ð¼) (true - Ð´Ð°/false - Ð½ÐµÑ)")]
                public Boolean TrackChat;
                [JsonProperty(LanguageEn ? "Use player command usage tracking (will notify the moderator about it) (true - yes / false - no)" : "ÐÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ Ð¾ÑÑÐ»ÐµÐ¶Ð¸Ð²Ð°Ð½Ð¸Ðµ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´ Ð¸Ð³ÑÐ¾ÐºÐ¾Ð¼ (Ð±ÑÐ´ÐµÑ ÑÐ²ÐµÐ´Ð¾Ð¼Ð»ÑÑÑ Ð¼Ð¾Ð´ÐµÑÐ°ÑÐ¾ÑÐ° Ð¾Ð± ÑÑÐ¾Ð¼) (true - Ð´Ð°/false - Ð½ÐµÑ)")]
                public Boolean TrackCommand;
            }

            internal class ReportContollerModeration
            {
                [JsonProperty(LanguageEn ? "Maximum number of reports to display the player in the moderator menu and moderator notifications" : "ÐÐ°ÐºÑÐ¸Ð¼Ð°Ð»ÑÐ½Ð¾Ðµ ÐºÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ð¾ ÑÐµÐ¿Ð¾ÑÑÐ¾Ð² Ð´Ð»Ñ Ð¾ÑÐ¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ Ð¸Ð³ÑÐ¾ÐºÐ° Ð² Ð¼ÐµÐ½Ñ Ð¼Ð¾Ð´ÐµÑÐ°ÑÐ¾ÑÐ° Ð¸ ÑÐ²ÐµÐ´Ð¾Ð¼Ð»ÐµÐ½Ð¸Ñ Ð¼Ð¾Ð´ÐµÑÐ°ÑÐ¾ÑÐ°")]
                public Int32 ReportCountTrigger;
                [JsonProperty(LanguageEn ? "Setting up moderator notifications about the maximum number of player reports" : "ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ° ÑÐ²ÐµÐ´Ð¾Ð¼Ð»ÐµÐ½Ð¸Ñ Ð¼Ð¾Ð´ÐµÑÐ°ÑÐ¾ÑÐ° Ð¾ Ð¼Ð°ÐºÑÐ¸Ð¼Ð°Ð»ÑÐ½Ð¾Ð¼ ÐºÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ðµ ÑÐµÐ¿Ð¾ÑÑÐ¾Ð² Ð¸Ð³ÑÐ¾ÐºÐ°")]
                public AlertModeration AlertModerationSettings = new AlertModeration();
                internal class AlertModeration
                {
                    [JsonProperty(LanguageEn ? "Notify the moderator that the player has scored the maximum number of reports" : "Ð£Ð²ÐµÐ´Ð¾Ð¼Ð»ÑÑÑ Ð¼Ð¾Ð´ÐµÑÐ°ÑÐ¾ÑÐ° Ð¾ ÑÐ¾Ð¼, ÑÑÐ¾ Ð¸Ð³ÑÐ¾Ðº Ð½Ð°Ð±ÑÐ°Ð» Ð¼Ð°ÐºÑÐ¸Ð¼Ð°Ð»ÑÐ½Ð¾Ðµ ÐºÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ð¾ ÑÐµÐ¿Ð¾ÑÑÐ¾Ð²")]
                    public Boolean AlertModerator;
                    [JsonProperty(LanguageEn ? "Enable an audio notification to the moderator during the notification of the number of reports" : "ÐÐºÐ»ÑÑÐ°ÑÑ Ð·Ð²ÑÐºÐ¾Ð²Ð¾Ðµ ÑÐ²ÐµÐ´Ð¾Ð¼Ð»ÐµÐ½Ð¸Ðµ Ð¼Ð¾Ð´ÐµÑÐ°ÑÐ¾ÑÑ Ð²Ð¾ Ð²ÑÐµÐ¼Ñ ÑÐ²ÐµÐ´Ð¾Ð¼Ð»ÐµÐ½Ð¸Ñ Ð¾ ÐºÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ðµ ÑÐµÐ¿Ð¾ÑÑÐ¾Ð²")]
                    public Boolean AlertSound;
                    [JsonProperty(LanguageEn ? "The path to the notification sound (this is the path of the prefab of the game - you can see here : https://github.com/OrangeWulf/Rust-Docs/blob/master/Extended/Effects.md)" : "ÐÑÑÑ Ð´Ð¾ Ð·Ð²ÑÐºÐ° ÑÐ²ÐµÐ´Ð¾Ð¼Ð»ÐµÐ½Ð¸Ñ (ÑÑÐ¾ Ð¿ÑÑÑ Ð¿ÑÐµÑÐ°Ð±Ð° Ð¸Ð³ÑÑ - Ð¿Ð¾ÑÐ¼Ð¾ÑÑÐµÑÑ Ð¼Ð¾Ð¶Ð½Ð¾ ÑÑÑ : https://github.com/OrangeWulf/Rust-Docs/blob/master/Extended/Effects.md)")]
                    public String PathSound;
                }
            }
            internal class ReportSendController
            {
                [JsonProperty(LanguageEn ? "Prohibit a player from sending a complaint against one player several times (true - yes/false - no)" : "ÐÐ°Ð¿ÑÐµÑÐ¸ÑÑ Ð¸Ð³ÑÐ¾ÐºÑ Ð½ÐµÑÐºÐ¾Ð»ÑÐºÐ¾ ÑÐ°Ð· Ð¾ÑÐ¿ÑÐ°Ð²Ð»ÑÑÑ Ð¶Ð°Ð»Ð¾Ð±Ñ Ð½Ð° Ð¾Ð´Ð½Ð¾Ð³Ð¾ Ð¸Ð³ÑÐ¾ÐºÐ° (true - Ð´Ð°/false - Ð½ÐµÑ)")]
                public Boolean NoRepeatReport;
                [JsonProperty(LanguageEn ? "Cooldown before sending a complaint to the players (in seconds) (if you don't need a recharge, leave 0)" : "ÐÐµÑÐµÐ·Ð°ÑÑÐ´ÐºÐ° Ð¿ÐµÑÐµÐ´ Ð¾ÑÐ¿ÑÐ°Ð²ÐºÐ¾Ð¹ Ð¶Ð°Ð»Ð¾Ð±Ñ Ð½Ð° Ð¸Ð³ÑÐ¾ÐºÐ¾Ð² (Ð² ÑÐµÐºÑÐ½Ð´Ð°Ñ) (ÐµÑÐ»Ð¸ Ð²Ð°Ð¼ Ð½Ðµ Ð½ÑÐ¶Ð½Ð° Ð¿ÐµÑÐµÐ·Ð°ÑÑÐ´ÐºÐ° - Ð¾ÑÑÐ°Ð²ÑÑÐµ 0)")]
                public Int32 CooldownReport;
                [JsonProperty(LanguageEn ? "Use cooldown before sending a complaint only for a repeated complaint against one player (true) otherwise for all players (false)" : "ÐÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ Ð¿ÐµÑÐµÐ·Ð°ÑÑÐ´ÐºÑ Ð¿ÐµÑÐµÐ´ Ð¾ÑÐ¿ÑÐ°Ð²ÐºÐ¾Ð¹ Ð¶Ð°Ð»Ð¾Ð±Ñ ÑÐ¾Ð»ÑÐºÐ¾ Ð½Ð° Ð¿Ð¾Ð²ÑÐ¾ÑÐ½ÑÑ Ð¶Ð°Ð»Ð¾Ð±Ñ Ð½Ð° Ð¾Ð´Ð½Ð¾Ð³Ð¾ Ð¸Ð³ÑÐ¾ÐºÐ° (true) Ð¸Ð½Ð°ÑÐµ Ð½Ð° Ð²ÑÐµÑ Ð¸Ð³ÑÐ¾ÐºÐ¾Ð² (false)")]
                public Boolean CooldownRepeatOrAll;
            }
            internal class ReportF7AndGameMenu
            {
                [JsonProperty(LanguageEn ? "Use sending report via F7 and the RUST game menu (true - yes/false - no)" : "ÐÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ Ð¾ÑÐ¿ÑÐ°Ð²ÐºÑ Ð¶Ð°Ð»Ð¾Ð± ÑÐµÑÐµÐ· F7 Ð¸ Ð¸Ð³ÑÐ¾Ð²Ð¾Ðµ Ð¼ÐµÐ½Ñ RUST (true - Ð´Ð°/false - Ð½ÐµÑ)")]
                public Boolean UseFunction;
                [JsonProperty(LanguageEn ? "Index from the list of complaints when sent via F7 and the RUST game menu (From your list - starts from 0)" : "ÐÐ½Ð´ÐµÐºÑ Ð¸Ð· ÑÐ¿Ð¸ÑÐºÐ° Ð¶Ð°Ð»Ð¾Ð± Ð¿ÑÐ¸ Ð¾ÑÐ¿ÑÐ°Ð²ÐºÐµ ÑÐµÑÐµÐ· F7 Ð¸ Ð¸Ð³ÑÐ¾Ð²Ð¾Ðµ Ð¼ÐµÐ½Ñ RUST (ÐÐ· Ð²Ð°ÑÐµÐ³Ð¾ ÑÐ¿Ð¸ÑÐºÐ° - Ð½Ð°ÑÐ¸Ð½Ð°ÐµÑÑÑ Ð¾Ñ 0)")]
                public Int32 DefaultIndexReason;
            }
            internal class NotifyChat
            {
                [JsonProperty(LanguageEn ? "Notify players when a moderator has started checking a player (configurable in the language file)" : "Ð£Ð²ÐµÐ´Ð¾Ð¼Ð»ÑÑÑ Ð¸Ð³ÑÐ¾ÐºÐ¾Ð² Ð¾ ÑÐ¾Ð¼, ÑÑÐ¾ Ð¼Ð¾Ð´ÐµÑÐ°ÑÐ¾Ñ Ð½Ð°ÑÐ°Ð» Ð¿ÑÐ¾Ð²ÐµÑÐºÑ Ð¸Ð³ÑÐ¾ÐºÐ° (Ð½Ð°ÑÑÑÐ°Ð¸Ð²Ð°ÐµÑÑÑ Ð² ÑÐ·ÑÐºÐ¾Ð²Ð¾Ð¼ ÑÐ°Ð¹Ð»Ðµ)")]
                public Boolean UseNotifyCheck;
                [JsonProperty(LanguageEn ? "Notify players when a moderator has finished checking a player (configurable in the language file)" : "Ð£Ð²ÐµÐ´Ð¾Ð¼Ð»ÑÑÑ Ð¸Ð³ÑÐ¾ÐºÐ¾Ð² Ð¾ ÑÐ¾Ð¼, ÑÑÐ¾ Ð¼Ð¾Ð´ÐµÑÐ°ÑÐ¾Ñ Ð·Ð°Ð²ÐµÑÑÐ¸Ð» Ð¿ÑÐ¾Ð²ÐµÑÐºÑ Ð¸Ð³ÑÐ¾ÐºÐ° (Ð½Ð°ÑÑÑÐ°Ð¸Ð²Ð°ÐµÑÑÑ Ð² ÑÐ·ÑÐºÐ¾Ð²Ð¾Ð¼ ÑÐ°Ð¹Ð»Ðµ)")]
                public Boolean UseNotifyStopCheck;
                [JsonProperty(LanguageEn ? "Notify players that the moderator has completed the verification of the player and issued a verdict (banned) (configurable in the language file)" : "Ð£Ð²ÐµÐ´Ð¾Ð¼Ð»ÑÑÑ Ð¸Ð³ÑÐ¾ÐºÐ¾Ð² Ð¾ ÑÐ¾Ð¼, ÑÑÐ¾ Ð¼Ð¾Ð´ÐµÑÐ°ÑÐ¾Ñ Ð·Ð°Ð²ÐµÑÑÐ¸Ð» Ð¿ÑÐ¾Ð²ÐµÑÐºÑ Ð¸Ð³ÑÐ¾ÐºÐ° Ð¸ Ð²ÑÐ½ÐµÑ Ð²ÐµÑÐ´Ð¸ÐºÑ (Ð·Ð°Ð±Ð°Ð½Ð¸Ð») (Ð½Ð°ÑÑÑÐ°Ð¸Ð²Ð°ÐµÑÑÑ Ð² ÑÐ·ÑÐºÐ¾Ð²Ð¾Ð¼ ÑÐ°Ð¹Ð»Ðµ)")]
                public Boolean UseNotifyVerdictCheck;
            }

            internal class NotifyVK
            {
                [JsonProperty(LanguageEn ? "Token from the VK group (you can find it in the community settings)" : "Ð¢Ð¾ÐºÐµÐ½ Ð¾Ñ Ð³ÑÑÐ¿Ð¿Ñ ÐÐ (Ð²Ñ Ð¼Ð¾Ð¶ÐµÑÐµ Ð½Ð°Ð¹ÑÐ¸ ÐµÐ³Ð¾ Ð² Ð½Ð°ÑÑÑÐ¾Ð¹ÐºÐ°Ñ ÑÐ¾Ð¾Ð±ÑÐµÑÑÐ²Ð°)")]
                public String VKTokenGroup;
                [JsonProperty(LanguageEn ? "ID of the conversation the bot is invited to (countdown starts from 1 - every new conversation +1)" : "ID Ð±ÐµÑÐµÐ´Ñ Ð² ÐºÐ¾ÑÐ¾ÑÑÑ Ð¿ÑÐ¸Ð³Ð»Ð°ÑÐµÐ½ Ð±Ð¾Ñ (Ð¾ÑÑÑÐµÑ Ð½Ð°ÑÐ¸Ð½Ð°ÐµÑÑÑ Ñ 1 - ÐºÐ°Ð¶Ð´ÑÑ Ð½Ð¾Ð²ÑÑ Ð±ÐµÑÐµÐ´Ñ +1)")]
                public String VKChatID;
            }

            internal class NotifyDiscord
            {
                [JsonProperty(LanguageEn ? "Set up WebHooks to send to Discord (if you don't need this feature - leave the field blank)" : "ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ° WebHooks Ð´Ð»Ñ Ð¾ÑÐ¿ÑÐ°Ð²ÐºÐ¸ Ð² Discord (ÐµÑÐ»Ð¸ Ð²Ð°Ð¼ Ð½Ðµ Ð½ÑÐ¶Ð½Ð° ÑÑÐ° ÑÑÐ½ÐºÑÐ¸Ñ - Ð¾ÑÑÐ°Ð²ÑÑÐµ Ð¿Ð¾Ð»Ðµ Ð¿ÑÑÑÑÐ¼)")]
                public Webhooks WebhooksList = new Webhooks();
                internal class Webhooks
                {
                    internal class TemplatesNotify
                    {
                        [JsonProperty("Webhook")]
                        public String WebhookNotify;
                        [JsonProperty(LanguageEn ? "Discord message color (Can be found on the website - https://old.message.style/dashboard in the JSON section)" : "Ð¦Ð²ÐµÑ ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ñ Ð² Discord (ÐÐ¾Ð¶Ð½Ð¾ Ð½Ð°Ð¹ÑÐ¸ Ð½Ð° ÑÐ°Ð¹ÑÐµ - https://old.message.style/dashboard Ð² ÑÐ°Ð·Ð´ÐµÐ»Ðµ JSON)")]
                        public Int32 Color;
                        [JsonProperty(LanguageEn ? "Title message" : "ÐÐ°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ñ")]
                        public String AuthorName;
                        [JsonProperty(LanguageEn ? "Link to the icon for the avatar of the message" : "Ð¡ÑÑÐ»ÐºÐ° Ð½Ð° Ð¸ÐºÐ¾Ð½ÐºÑ Ð´Ð»Ñ Ð°Ð²Ð°ÑÐ°ÑÐºÐ¸ ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ñ")]
                        public String IconURL;

                    }

                    [JsonProperty(LanguageEn ? "WebHook : Setting up sending information about the start of a check" : "WebHook : ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ° Ð¾ÑÐ¿ÑÐ°Ð²ÐºÐ¸ Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ð¸ Ð¾ Ð½Ð°ÑÐ°Ð»Ðµ Ð¿ÑÐ¾Ð²ÐµÑÐºÐ¸")]
                    public TemplatesNotify NotifyStartCheck = new TemplatesNotify();

                    [JsonProperty(LanguageEn ? "WebHook : Setting up sending information about the stop of a check" : "WebHook : ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ° Ð¾ÑÐ¿ÑÐ°Ð²ÐºÐ¸ Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ð¸ Ð¾ Ð·Ð°Ð²ÐµÑÑÐµÐ½Ð¸Ð¸ Ð¿ÑÐ¾Ð²ÐµÑÐºÐ¸")]
                    public TemplatesNotify NotifyStopCheck = new TemplatesNotify();

                    [JsonProperty(LanguageEn ? "WebHook : Settings for sending player contact information (when a player sends their Discord)" : "WebHook : ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ° Ð¾ÑÐ¿ÑÐ°Ð²ÐºÐ¸ Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ð¸ Ð¾ ÐºÐ¾Ð½ÑÐ°ÐºÑÐ°Ñ Ð¸Ð³ÑÐ¾ÐºÐ° (ÐºÐ¾Ð³Ð´Ð° Ð¸Ð³ÑÐ¾Ðº Ð¾ÑÐ¿ÑÐ°Ð²Ð»ÑÐµÑ ÑÐ²Ð¾Ð¹ Discord)")]
                    public TemplatesNotify NotifyContacts = new TemplatesNotify();

                    [JsonProperty(LanguageEn ? "WebHook : Setting up sending information about player complaints" : "WebHook : ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ° Ð¾ÑÐ¿ÑÐ°Ð²ÐºÐ¸ Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ð¸ Ð¾ Ð¶Ð°Ð»Ð¾Ð±Ð°Ñ Ð¸Ð³ÑÐ¾ÐºÐ¾Ð²")]
                    public TemplatesNotify NotifySendReport = new TemplatesNotify();

                    [JsonProperty(LanguageEn ? "WebHook : Setting up sending information when a player has exceeded the maximum number of complaints" : "WebHook : ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ° Ð¾ÑÐ¿ÑÐ°Ð²ÐºÐ¸ Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ð¸ ÐºÐ¾Ð³Ð´Ð° Ð¸Ð³ÑÐ¾Ðº Ð¿ÑÐµÐ²ÑÑÐ¸Ð» Ð¼Ð°ÐºÑÐ¸Ð¼Ð°Ð»ÑÐ½Ð¾Ðµ ÐºÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ð¾ Ð¶Ð°Ð»Ð¾Ð±")]
                    public TemplatesNotify NotifyMaxReport = new TemplatesNotify();

                    [JsonProperty(LanguageEn ? "WebHook : Setting up sending information about changing the status of the player and moderator" : "WebHook : ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ° Ð¾ÑÐ¿ÑÐ°Ð²ÐºÐ¸ Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ð¸ Ð¾ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ð¸ ÑÑÐ°ÑÑÑÐ° Ð¸Ð³ÑÐ¾ÐºÐ° Ð¸ Ð¼Ð¾Ð´ÐµÑÐ°ÑÐ¾ÑÐ°")]
                    public TemplatesNotify NotifyStatusPlayerOrModerator = new TemplatesNotify();
                }
            }
            internal class ReasonReport
            {
                [JsonProperty(LanguageEn ? "Reason" : "ÐÑÐ¸ÑÐ¸Ð½Ð°")]
                public LangText Title;
                [JsonProperty(LanguageEn ? "The command from your ban system to block the user ({0} - will be replaced by the player's ID)" : "ÐÐ¾Ð¼Ð°Ð½Ð´Ð° Ð²Ð°ÑÐµÐ¹ Ð±Ð°Ð½-ÑÐ¸ÑÑÐµÐ¼Ñ Ð½Ð° Ð±Ð»Ð¾ÐºÐ¸ÑÐ¾Ð²ÐºÑ Ð¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»Ñ ({0} - Ð·Ð°Ð¼ÐµÐ½Ð¸ÑÑÑ Ð½Ð° ID Ð¸Ð³ÑÐ¾ÐºÐ°)")]
                public String BanCommand;
                [JsonProperty(LanguageEn ? "Hide this reason from the player (true) (will only be seen by the moderator when passing a verdict)" : "Ð¡ÐºÑÑÑÑ Ð´Ð°Ð½Ð½ÑÑ Ð¿ÑÐ¸ÑÐ¸Ð½Ñ Ð¾Ñ Ð¸Ð³ÑÐ¾ÐºÐ° (true) (Ð±ÑÐ´ÐµÑ Ð²Ð¸Ð´ÐµÑÑ ÑÐ¾Ð»ÑÐºÐ¾ Ð¼Ð¾Ð´ÐµÑÐ°ÑÐ¾Ñ Ð¿ÑÐ¸ Ð²ÑÐ½ÐµÑÐµÐ½Ð¸Ð¸ Ð²ÐµÑÐ´Ð¸ÐºÑÐ°)")]
                public Boolean HideUser;
            }
            internal class Images
            {
                [JsonProperty(LanguageEn ? "Reports section images" : "ÐÐ·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ ÑÐ°Ð·Ð´ÐµÐ»Ð° Ð´Ð»Ñ Ð¶Ð°Ð»Ð¾Ð±")]
                public PlayerListBlock PlayerListBlockSettings = new PlayerListBlock();

                [JsonProperty(LanguageEn ? "Images of the statistics section" : "ÐÐ·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ ÑÐ°Ð·Ð´ÐµÐ»Ð° ÑÑÐ°ÑÐ¸ÑÑÐ¸ÐºÐ¸")]
                public StatisticsBlock StatisticsBlockSettings = new StatisticsBlock();

                [JsonProperty(LanguageEn ? "Left menu images" : "ÐÐ·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ Ð»ÐµÐ²Ð¾Ð³Ð¾ Ð¼ÐµÐ½Ñ")]
                public LeftBlock LeftBlockSettings = new LeftBlock();

                [JsonProperty(LanguageEn ? "Moderation section images" : "ÐÐ·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ ÑÐ°Ð·Ð´ÐµÐ»Ð° Ð¼Ð¾Ð´ÐµÑÐ°ÑÐ¸Ð¸")]
                public ModerationBlock ModerationBlockSettings = new ModerationBlock();
                [JsonProperty(LanguageEn ? "Moderator menu images when checking" : "ÐÐ·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ Ð¼ÐµÐ½Ñ Ð¼Ð¾Ð´ÐµÑÐ°ÑÐ¾ÑÐ° Ð¿ÑÐ¸ Ð¿ÑÐ¾Ð²ÐµÑÐºÐ¸")]
                public ModeratorMenuChecked ModeratorMenuCheckedSettings = new ModeratorMenuChecked();

                [JsonProperty(LanguageEn ? "Images of the player rating menu quality of the moderator's work" : "ÐÐ·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ Ð¼ÐµÐ½Ñ Ð¾ÑÐµÐ½ÐºÐ¸ Ð¸Ð³ÑÐ¾ÐºÐ¾Ð¼ ÐºÐ°ÑÐµÑÑÐ²Ð¾ ÑÐ°Ð±Ð¾ÑÑ Ð¼Ð¾Ð´ÐµÑÐ°ÑÐ¾ÑÐ°")]
                public PlayerMenuRaiting PlayerMenuRaitingSettings = new PlayerMenuRaiting();

                [JsonProperty(LanguageEn ? "PNG of the menu background (1382x950)" : "PNG Ð·Ð°Ð´Ð½ÐµÐ³Ð¾ ÑÐ¾Ð½Ð° Ð¼ÐµÐ½Ñ (1382x950)")]
                public String Background;
                [JsonProperty(LanguageEn ? "PNG down arrows (page flipping) (10x5)" : "PNG ÑÑÑÐµÐ»ÐºÐ¸ Ð²Ð½Ð¸Ð·(Ð¿ÐµÑÐµÐ»Ð¸ÑÑÑÐ²Ð°Ð½Ð¸Ðµ ÑÑÑÐ°Ð½Ð¸Ñ) (10x5)")]
                public String PageDown;
                [JsonProperty(LanguageEn ? "PNG up arrows (page flipping) (10x5)" : "PNG ÑÑÑÐµÐ»ÐºÐ¸ Ð²Ð²ÐµÑÑ(Ð¿ÐµÑÐµÐ»Ð¸ÑÑÑÐ²Ð°Ð½Ð¸Ðµ ÑÑÑÐ°Ð½Ð¸Ñ) (10x5)")]
                public String PageUp;
                [JsonProperty(LanguageEn ? "PNG icon search (16x16)" : "PNG Ð¸ÐºÐ¾Ð½ÐºÐ¸ Ð¿Ð¾Ð¸ÑÐºÐ° (16x16)")]
                public String Search;
                [JsonProperty(LanguageEn ? "PNG : Icon for adjusting avatar (64x64)" : "PNG : ÐÐºÐ¾Ð½ÐºÐ° Ð´Ð»Ñ ÐºÐ¾ÑÑÐµÐºÑÐ¸ÑÐ¾Ð²ÐºÐ¸ Ð°Ð²ÑÐ°ÑÐºÐ¸ (64x64)")]
                public String AvatarBlur;
                [JsonProperty(LanguageEn ? "PNG : Icon for moderation verdict or rating (307x36)" : "PNG : ÐÐºÐ¾Ð½ÐºÐ° Ð´Ð»Ñ Ð²ÐµÑÐ´Ð¸ÐºÑÐ° Ð¼Ð¾Ð´ÐµÑÐ°ÑÐ¸Ð¸ Ð¸Ð»Ð¸ ÑÐµÐ¹ÑÐ¸Ð½Ð³Ð° (307x36)")]
                public String ReasonModeratorAndRaiting;
                [JsonProperty(LanguageEn ? "PNG : Image on the player's screen with text about the start of the checks (1450x559)" : "PNG : ÐÐ·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ðµ Ð½Ð° ÑÐºÑÐ°Ð½Ðµ Ð¸Ð³ÑÐ¾ÐºÐ° Ñ ÑÐµÐºÑÑÐ¾Ð¼ Ð¾ Ð½Ð°ÑÐ°Ð»Ðµ Ð¿ÑÐ¾Ð²ÐµÑÐºÐ¸ (1450x559)")]
                public String PlayerAlerts;

                internal class PlayerMenuRaiting
                {
                    [JsonProperty(LanguageEn ? "PNG : Menu background when evaluating a reviewer (307x98)" : "PNG : ÐÐ°Ð´Ð½Ð¸Ð¹ ÑÐ¾Ð½ Ð¼ÐµÐ½Ñ Ð¿ÑÐ¸ Ð¾ÑÐµÐ½ÐºÐµ Ð¿ÑÐ¾Ð²ÐµÑÑÑÑÐµÐ³Ð¾ (307x98)")]
                    public String PlayerMenuRaitingBackground;
                }
                internal class ModeratorMenuChecked
                {
                    [JsonProperty(LanguageEn ? "PNG : Menu background when checking player (307x148)" : "PNG : ÐÐ°Ð´Ð½Ð¸Ð¹ ÑÐ¾Ð½ Ð¼ÐµÐ½Ñ Ð¿ÑÐ¸ Ð¿ÑÐ¾Ð²ÐµÑÐºÐ¸ Ð¸Ð³ÑÐ¾ÐºÐ° (307x148)")]
                    public String ModeratorCheckedBackground;
                    [JsonProperty(LanguageEn ? "PNG : End test button (128x40)" : "PNG : ÐÐ½Ð¾Ð¿ÐºÐ° Ð·Ð°Ð²ÐµÑÑÐµÐ½Ð¸Ñ Ð¿ÑÐ¾Ð²ÐµÑÐºÐ¸ (128x40)")]
                    public String ModeratorCheckedStopButton;
                    [JsonProperty(LanguageEn ? "PNG : Verdict button (128x40)" : "PNG : ÐÐ½Ð¾Ð¿ÐºÐ° Ð²ÐµÑÐ´Ð¸ÐºÑÐ° (128x40)")]
                    public String ModeratorVerdictButton;
                    [JsonProperty(LanguageEn ? "PNG : `Licenses` icon (if Lumia support is enabled) (16x16)" : "PNG : ÐÐºÐ¾Ð½ÐºÐ° `ÐÐ¸ÑÐµÐ½Ð·Ð¸Ð¸` (ÐµÑÐ»Ð¸ Ð²ÐºÐ»ÑÑÐµÐ½Ð° Ð¿Ð¾Ð´Ð´ÐµÑÐ¶ÐºÐ° Luma) (16x16)")]
                    public String SteamIcoPlayer;
                    [JsonProperty(LanguageEn ? "PNG : `Pirate` icon (if Lumia support is enabled) (16x16)" : "PNG : ÐÐºÐ¾Ð½ÐºÐ° `ÐÐ¸ÑÐ°Ñ` (ÐµÑÐ»Ð¸ Ð²ÐºÐ»ÑÑÐµÐ½Ð° Ð¿Ð¾Ð´Ð´ÐµÑÐ¶ÐºÐ° Luma) (16x16)")]
                    public String PirateIcoPlayer;
                }
                internal class ModerationBlock
                {
                    [JsonProperty(LanguageEn ? "PNG : Player information popup background (831x599)" : "PNG : ÐÐ°Ð´Ð½Ð¸Ð¹ ÑÐ¾Ð½ Ð²ÑÐ¿Ð»ÑÐ²Ð°ÑÑÐµÐ³Ð¾ Ð¾ÐºÐ½Ð° Ñ Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸ÐµÐ¹ Ð¾ Ð¸Ð³ÑÐ¾ÐºÐµ (831x599)")]
                    public String ModeratorPoopUPBackgorund;
                    [JsonProperty(LanguageEn ? "PNG : Element background for text (155x22)" : "PNG : ÐÐ°Ð´Ð½Ð¸Ð¹ ÑÐ¾Ð½ ÑÐ»ÐµÐ¼ÐµÐ½ÑÐ° Ð´Ð»Ñ ÑÐµÐºÑÑÐ° (155x22)")]
                    public String ModeratorPoopUPTextBackgorund;
                    [JsonProperty(LanguageEn ? "PNG : Information panel background (196x240)" : "PNG : ÐÐ°Ð´Ð½Ð¸Ð¹ ÑÐ¾Ð½ Ð¿Ð°Ð½ÐµÐ»Ð¸ Ñ Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸ÐµÐ¹ (196x240)")]
                    public String ModeratorPoopUPPanelBackgorund;
                }

                internal class LeftBlock
                {
                    [JsonProperty(LanguageEn ? "PNG : Icon for sidebar button (192x55)" : "PNG : ÐÐºÐ¾Ð½ÐºÐ° Ð´Ð»Ñ ÐºÐ½Ð¾Ð¿ÐºÐ¸ Ð² Ð±Ð¾ÐºÐ¾Ð²Ð¾Ð¼ Ð¼ÐµÐ½Ñ (192x55)")]
                    public String ButtonBackgorund;
                    [JsonProperty(LanguageEn ? "PNG : Icon for the button in `reports` (32x32)" : "PNG : ÐÐºÐ¾Ð½ÐºÐ° Ð´Ð»Ñ ÐºÐ½Ð¾Ð¿ÐºÐ¸ Ð² `Ð¶Ð°Ð»Ð¾Ð±Ñ`(32x32)")]
                    public String ReportIcon;
                    [JsonProperty(LanguageEn ? "PNG : Icon for the button in `moderation` (32x32)" : "PNG : ÐÐºÐ¾Ð½ÐºÐ° Ð´Ð»Ñ ÐºÐ½Ð¾Ð¿ÐºÐ¸ Ð² `Ð¼Ð¾Ð´ÐµÑÐ°ÑÐ¸Ñ`(32x32)")]
                    public String ModerationIcon;
                }

                internal class PlayerListBlock
                {
                    [JsonProperty(LanguageEn ? "PNG : Cause selection popup background (567x599)" : "PNG : ÐÐ°Ð´Ð½Ð¸Ð¹ ÑÐ¾Ð½ Ð²ÑÐ¿Ð»ÑÐ²Ð°ÑÑÐµÐ³Ð¾ ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ñ Ñ Ð²ÑÐ±Ð¾ÑÐ¾Ð¼ Ð¿ÑÐ¸ÑÐ¸Ð½Ñ (567x599)")]
                    public String PoopUpBackgorund;
                    [JsonProperty(LanguageEn ? "PNG : Reason background in popup (463x87)" : "PNG : ÐÐ°Ð´Ð½Ð¸Ð¹ ÑÐ¾Ð½ Ð¿ÑÐ¸ÑÐ¸Ð½Ñ Ð² Ð²ÑÐ¿Ð»ÑÐ²Ð°ÑÑÐµÐ¼ Ð¾ÐºÐ½Ðµ (463x87)")]
                    public String PoopUpReasonBackgorund;
                }

                internal class StatisticsBlock
                {
                    [JsonProperty(LanguageEn ? "PNG Background of the statistics block (283x81)" : "PNG ÐÐ°Ð´Ð½Ð¸Ð¹ ÑÐ¾Ð½ Ð±Ð»Ð¾ÐºÐ° ÑÑÐ°ÑÐ¸ÑÑÐ¸ÐºÐ¸ (283x81)")]
                    public String BlockStatsModeration;
                    [JsonProperty(LanguageEn ? "PNG Background of the rating block in statistics (65x28)" : "PNG ÐÐ°Ð´Ð½Ð¸Ð¹ ÑÐ¾Ð½ Ð±Ð»Ð¾ÐºÐ° ÑÐµÐ¹ÑÐ¸Ð½Ð³Ð° Ð² ÑÑÐ°ÑÐ¸ÑÑÐ¸ÐºÐµ (65x28)")]
                    public String BlockStatsRaitingModeration;
                    [JsonProperty(LanguageEn ? "PNG : Rating icon in statistics (16x15)" : "PNG : ÐÐºÐ¾Ð½ÐºÐ° ÑÐµÐ¹ÑÐ¸Ð½Ð³Ð° Ð² ÑÑÐ°ÑÐ¸ÑÑÐ¸ÐºÐµ (16x15)")]
                    public String RaitingImage;
                }
            }

            internal class Colors
            {
                [JsonProperty(LanguageEn ? "RGBA of the main text color" : "RGBA Ð¾ÑÐ½Ð¾Ð²Ð½Ð¾Ð³Ð¾ ÑÐ²ÐµÑÐ° ÑÐµÐºÑÑÐ°")]
                public String MainColorText;
                [JsonProperty(LanguageEn ? "RGBA of additional text color" : "RGBA Ð´Ð¾Ð¿Ð¾Ð»Ð½Ð¸ÑÐµÐ»ÑÐ½Ð¾Ð³Ð¾ ÑÐ²ÐµÑÐ° ÑÐµÐºÑÑÐ°")]
                public String AdditionalColorText;
                [JsonProperty(LanguageEn ? "RGBA additional color of elements (Buttons, dies)" : "RGBA Ð´Ð¾Ð¿Ð¾Ð»Ð½Ð¸ÑÐµÐ»ÑÐ½ÑÐ¹ ÑÐ²ÐµÑ ÑÐ»ÐµÐ¼ÐµÐ½ÑÐ¾Ð² (ÐÐ½Ð¾Ð¿ÐºÐ¸, Ð¿Ð»Ð°ÑÐºÐ¸)")]
                public String AdditionalColorElements;
                [JsonProperty(LanguageEn ? "RGBA additional color of elements (Buttons, dies) #2" : "RGBA Ð´Ð¾Ð¿Ð¾Ð»Ð½Ð¸ÑÐµÐ»ÑÐ½ÑÐ¹ ÑÐ²ÐµÑ ÑÐ»ÐµÐ¼ÐµÐ½ÑÐ¾Ð² (ÐÐ½Ð¾Ð¿ÐºÐ¸, Ð¿Ð»Ð°ÑÐºÐ¸) #2")]
                public String AdditionalColorElementsTwo;
                [JsonProperty(LanguageEn ? "RGBA additional color of elements (Buttons, dies) #3" : "RGBA Ð´Ð¾Ð¿Ð¾Ð»Ð½Ð¸ÑÐµÐ»ÑÐ½ÑÐ¹ ÑÐ²ÐµÑ ÑÐ»ÐµÐ¼ÐµÐ½ÑÐ¾Ð² (ÐÐ½Ð¾Ð¿ÐºÐ¸, Ð¿Ð»Ð°ÑÐºÐ¸) #3")]
                public String AdditionalColorElementsThree;
                [JsonProperty(LanguageEn ? "RGBA the main color" : "RGBA Ð¾ÑÐ½Ð¾Ð²Ð½Ð¾Ð¹ ÑÐ²ÐµÑ")]
                public String MainColor;
            }
            internal class References
            {
                [JsonProperty(LanguageEn ? "IQFakeActive : Use collaboration (true - yes/false - no)" : "IQFakeActive : ÐÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ ÑÐ¾Ð²Ð¼ÐµÑÑÐ½ÑÑ ÑÐ°Ð±Ð¾ÑÑ (true - Ð´Ð°/false - Ð½ÐµÑ)")]
                public Boolean IQFakeActiveUse;
                [JsonProperty(LanguageEn ? "Setting up IQChat" : "ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ° IQChat")]
                public IQChatReference IQChatSetting = new IQChatReference();
                [JsonProperty(LanguageEn ? "Setting up NoEscape" : "ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ° NoEscape")]
                public NoEscapeReference NoEscapeSetting = new NoEscapeReference();
                [JsonProperty(LanguageEn ? "Duels : Reschedule the player's check if he is in a duel (true - yes/false - no)" : "Duels : ÐÐµÑÐµÐ½ÐµÑÑÐ¸ Ð¿ÑÐ¾Ð²ÐµÑÐºÑ Ð¸Ð³ÑÐ¾ÐºÐ° ÐµÑÐ»Ð¸ Ð¾Ð½ Ð½Ð° Ð´ÑÑÐ»Ð¸ (true - Ð´Ð°/false - Ð½ÐµÑ)")]
                public Boolean NoCheckedDuel;
                [JsonProperty(LanguageEn ? "Setting up Friends" : "ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ° Friends")]
                public FriendsReference FriendsSetting = new FriendsReference();
                [JsonProperty(LanguageEn ? "Setting up Clans" : "ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ° Clans")]
                public ClansReference ClansSetting = new ClansReference();
                [JsonProperty(LanguageEn ? "Setting up MultiFighting (Luma)" : "ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ° MultiFighting (Luma)")]
                public MultiFighting MultiFightingSetting = new MultiFighting();
                [JsonProperty(LanguageEn ? "Setting up StopDamageMan" : "ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ° StopDamageMan")]
                public StopDamageMan StopDamageManSetting = new StopDamageMan();

                [JsonProperty(LanguageEn ? "Setting up RCC support" : "ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ° Ð¿Ð¾Ð´Ð´ÐµÑÐ¶ÐºÐ¸ RCC")]
                public RustCheatCheck RCCSettings = new RustCheatCheck();
                [JsonProperty(LanguageEn ? "Setting up OzProtect support" : "ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ° Ð¿Ð¾Ð´Ð´ÐµÑÐ¶ÐºÐ¸ OzProtect")]
                public OzProtectCheck OzProtectSettings = new OzProtectCheck();

                internal class MultiFighting
                {
                    [JsonProperty(LanguageEn ? "MultiFighting (Luma) : Display an icon with the player status - `Steam` / `Pirate`" : "MultiFighting (Luma) : ÐÑÐ¾Ð±ÑÐ°Ð¶Ð°ÑÑ Ð¸ÐºÐ¾Ð½ÐºÑ ÑÐ¾ ÑÑÐ°ÑÑÑÐ¾Ð¼ Ð¸Ð³ÑÐ¾ÐºÐ° - `Steam` / `ÐÐ¸ÑÐ°Ñ`")]
                    public Boolean UseSteamCheck;
                }

                internal class StopDamageMan
                {
                    [JsonProperty(LanguageEn ? "StopDamageMan : Disable player damage during check" : "StopDamageMan : ÐÑÐºÐ»ÑÑÐ°ÑÑ Ð¸Ð³ÑÐ¾ÐºÑ ÑÑÐ¾Ð½ Ð²Ð¾ Ð²ÑÐµÐ¼Ñ Ð¿ÑÐ¾Ð²ÐµÑÐºÐ¸")]
                    public Boolean UseStopDamage;
                }

                internal class RustCheatCheck
                {
                    [JsonProperty(LanguageEn ? "RCC key (if you don't need RCC support, leave the key blank)" : "ÐÐ»ÑÑ RCC (ÐµÑÐ»Ð¸ Ð²Ð°Ð¼ Ð½Ðµ Ð½ÑÐ¶Ð½Ð° Ð¿Ð¾Ð´Ð´ÐµÑÐ¶ÐºÐ° RCC - Ð¾ÑÑÐ°Ð²ÑÑÐµ ÐºÐ»ÑÑ Ð¿ÑÑÑÑÐ¼)")]
                    public String RCCKey;
                }

                internal class OzProtectCheck
                {
                    [JsonProperty(LanguageEn ? "OzProtect key (if you don't need OzProtect support, leave the key blank)" : "ÐÐ»ÑÑ OzProtect (ÐµÑÐ»Ð¸ Ð²Ð°Ð¼ Ð½Ðµ Ð½ÑÐ¶Ð½Ð° Ð¿Ð¾Ð´Ð´ÐµÑÐ¶ÐºÐ° OzProtect - Ð¾ÑÑÐ°Ð²ÑÑÐµ ÐºÐ»ÑÑ Ð¿ÑÑÑÑÐ¼)")]
                    public String OzProtectKey;
                }

                internal class IQChatReference
                {
                    [JsonProperty(LanguageEn ? "IQChat : Custom prefix in chat" : "IQChat : ÐÐ°ÑÑÐ¾Ð¼Ð½ÑÐ¹ Ð¿ÑÐµÑÐ¸ÐºÑ Ð² ÑÐ°ÑÐµ")]
                    public String CustomPrefix;
                    [JsonProperty(LanguageEn ? "IQChat : Custom chat avatar (If required)" : "IQChat : ÐÐ°ÑÑÐ¾Ð¼Ð½ÑÐ¹ Ð°Ð²Ð°ÑÐ°Ñ Ð² ÑÐ°ÑÐµ(ÐÑÐ»Ð¸ ÑÑÐµÐ±ÑÐµÑÑÑ)")]
                    public String CustomAvatar;
                    [JsonProperty(LanguageEn ? "IQChat : Use UI notification (true - yes/false - no)" : "IQChat : ÐÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ UI ÑÐ²ÐµÐ´Ð¾Ð¼Ð»ÐµÐ½Ð¸Ðµ (true - Ð´Ð°/false - Ð½ÐµÑ)")]
                    public Boolean UIAlertUse;
                }

                internal class NoEscapeReference
                {
                    [JsonProperty(LanguageEn ? "NoEscape : Reschedule a player's check if he has a `Raid-Block` (true - yes/false - no)" : "NoEscape : ÐÐµÑÐµÐ½ÐµÑÑÐ¸ Ð¿ÑÐ¾Ð²ÐµÑÐºÑ Ð¸Ð³ÑÐ¾ÐºÐ° ÐµÑÐ»Ð¸ Ñ Ð½ÐµÐ³Ð¾ ÐµÑÑÑ `Raid-ÐÐ»Ð¾Ðº` (true - Ð´Ð°/false - Ð½ÐµÑ)")]
                    public Boolean NoCheckedRaidBlock;
                    [JsonProperty(LanguageEn ? "NoEscape : Reschedule a player's check if he has a `Combat-Block` (true - yes/false - no)" : "NoEscape : ÐÐµÑÐµÐ½ÐµÑÑÐ¸ Ð¿ÑÐ¾Ð²ÐµÑÐºÑ Ð¸Ð³ÑÐ¾ÐºÐ° ÐµÑÐ»Ð¸ Ñ Ð½ÐµÐ³Ð¾ ÐµÑÑÑ `ÐÐ¾Ð¼Ð±Ð°Ñ-ÐÐ»Ð¾Ðº` (true - Ð´Ð°/false - Ð½ÐµÑ)")]
                    public Boolean NoCheckedCombatBlock;
                }

                internal class FriendsReference
                {
                    [JsonProperty(LanguageEn ? "Friends : Prohibit players in the team from sending reports to each other (true - yes/false - no)" : "Friends : ÐÐ°Ð¿ÑÐµÑÐ¸ÑÑ Ð¸Ð³ÑÐ¾ÐºÐ°Ð¼ Ð² ÐºÐ¾Ð¼Ð°Ð½Ð´Ðµ Ð¾ÑÐ¿ÑÐ°Ð²Ð»ÑÑÑ ÑÐµÐ¿Ð¾ÑÑÑ Ð´ÑÑÐ³ Ð½Ð° Ð´ÑÑÐ³Ð° (true - Ð´Ð°/false - Ð½ÐµÑ)")]
                    public Boolean SendReportFriend;
                    [JsonProperty(LanguageEn ? "Friends : Prohibit the moderator from checking his teammate (true - yes/false - no)" : "Friends : ÐÐ°Ð¿ÑÐµÑÐ¸ÑÑ Ð¼Ð¾Ð´ÐµÑÐ°ÑÐ¾ÑÑ Ð¿ÑÐ¾Ð²ÐµÑÑÑÑ ÑÐ²Ð¾ÐµÐ³Ð¾ ÑÐ¸Ð¼Ð¼ÐµÐ¹ÑÐ° (true - Ð´Ð°/false - Ð½ÐµÑ)")]
                    public Boolean StartCheckedFriend;
                }

                internal class ClansReference
                {
                    [JsonProperty(LanguageEn ? "Clans : Prohibit players in the same clan from sending reports to each other (true - yes/false - no)" : "Clans : ÐÐ°Ð¿ÑÐµÑÐ¸ÑÑ Ð¸Ð³ÑÐ¾ÐºÐ°Ð¼ Ð² Ð¾Ð´Ð½Ð¾Ð¼ ÐºÐ»Ð°Ð½Ðµ Ð¾ÑÐ¿ÑÐ°Ð²Ð»ÑÑÑ ÑÐµÐ¿Ð¾ÑÑÑ Ð´ÑÑÐ³ Ð½Ð° Ð´ÑÑÐ³Ð° (true - Ð´Ð°/false - Ð½ÐµÑ)")]
                    public Boolean SendReportClan;
                    [JsonProperty(LanguageEn ? "Clans : Prohibit the moderator from checking the members of his clan (true - yes/false - no)" : "Clans : ÐÐ°Ð¿ÑÐµÑÐ¸ÑÑ Ð¼Ð¾Ð´ÐµÑÐ°ÑÐ¾ÑÑ Ð¿ÑÐ¾Ð²ÐµÑÑÑÑ ÑÑÐ°ÑÑÐ½Ð¸ÐºÐ¾Ð² ÑÐ²Ð¾ÐµÐ³Ð¾ ÐºÐ»Ð°Ð½Ð° (true - Ð´Ð°/false - Ð½ÐµÑ)")]
                    public Boolean StartCheckedClan;
                }
            }

            internal class LangText
            {
                [JsonProperty(LanguageEn ? "Reason title russian" : "ÐÑÐ¸ÑÐ¸Ð½Ð° Ð½Ð° ÑÑÑÑÐºÐ¾Ð¼")]
                public String LanguageRU;
                [JsonProperty(LanguageEn ? "Reason title english" : "ÐÑÐ¸ÑÐ¸Ð½Ð° Ð½Ð° Ð°Ð½Ð³Ð»Ð¸Ð¹ÑÐºÐ¾Ð¼")]
                public String LanguageEN;

                public String GetReasonTitle(UInt64 TargetID) =>
                    _.lang.GetLanguage(TargetID.ToString()).Equals("ru") ? LanguageRU : LanguageEN;
            }

            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    CommandForContact = "discord",
                    VerdictControllerSettings = new VerdictController()
                    {
                        UseBanAllTeam = false,
                        IndexBanReason = 5,
                    },
                    CheckControllerSettings = new CheckController
                    {
                        StopCheckLeavePlayer = false,
                        UseDemo = true,
                        UseSoundAlert = false,
                        UseCheckAFK = true,
                        TrackCrafting = false,
                        TrackChat = false,
                        TrackCommand = false,
                    },
                    NotifyChatSettings = new NotifyChat()
                    {
                        UseNotifyCheck = true,
                        UseNotifyStopCheck = true,
                        UseNotifyVerdictCheck = true,
                    },
                    NotifyVKSettings = new NotifyVK()
                    {
                        VKTokenGroup = "",
                        VKChatID = ""
                    },
                    NotifyDiscordSettings = new NotifyDiscord()
                    {
                        WebhooksList = new NotifyDiscord.Webhooks()
                        {
                            NotifySendReport = new NotifyDiscord.Webhooks.TemplatesNotify()
                            {
                                WebhookNotify = "",
                                Color = 16728083,
                                AuthorName = LanguageEn ? "NEW REPORT" : "ÐÐÐÐÐ¯ ÐÐÐÐÐÐ",
                                IconURL = "https://i.imgur.com/2N5je4x.jpg",
                            },
                            NotifyContacts = new NotifyDiscord.Webhooks.TemplatesNotify()
                            {
                                WebhookNotify = "",
                                Color = 13850622,
                                AuthorName = LanguageEn ? "PROVIDED CONTACTS" : "ÐÐ ÐÐÐÐ¡Ð¢ÐÐÐÐÐÐÐ«Ð ÐÐÐÐ¢ÐÐÐ¢Ð«",
                                IconURL = "https://i.imgur.com/bGJtYB5.jpg",
                            },
                            NotifyStartCheck = new NotifyDiscord.Webhooks.TemplatesNotify
                            {
                                WebhookNotify = "",
                                Color = 16755200,
                                AuthorName = LanguageEn ? "PLAYER CHECK" : "ÐÐ ÐÐÐÐ ÐÐ ÐÐÐ ÐÐÐ",
                                IconURL = "https://i.imgur.com/2N5je4x.jpg",
                            },
                            NotifyStopCheck = new NotifyDiscord.Webhooks.TemplatesNotify()
                            {
                                WebhookNotify = "",
                                Color = 7846721,
                                AuthorName = LanguageEn ? "COMPLETE CHECK" : "ÐÐÐÐÐ Ð¨ÐÐÐÐÐ¯ ÐÐ ÐÐÐÐ ÐÐ",
                                IconURL = "https://i.imgur.com/VKwsjXO.jpg",
                            },
                            NotifyMaxReport = new NotifyDiscord.Webhooks.TemplatesNotify()
                            {
                                WebhookNotify = "",
                                Color = 16728083,
                                AuthorName = LanguageEn ? "MAXIMUM NUMBER OF COMPLAINTS" : "ÐÐÐÐ¡ÐÐÐÐÐ¬ÐÐÐ ÐÐÐÐÐ§ÐÐ¡Ð¢ÐÐ ÐÐÐÐÐ",
                                IconURL = "https://i.imgur.com/2N5je4x.jpg",
                            },
                            NotifyStatusPlayerOrModerator = new NotifyDiscord.Webhooks.TemplatesNotify()
                            {
                                WebhookNotify = "",
                                Color = 16752000,
                                AuthorName = LanguageEn ? "CONNECTION STATUS CHANGES" : "ÐÐÐÐÐÐÐÐÐ¯ Ð¡Ð¢ÐÐ¢Ð£Ð¡Ð ÐÐÐÐÐÐ®Ð§ÐÐÐÐ¯",
                                IconURL = "https://i.imgur.com/2N5je4x.jpg",
                            }
                        }
                    },
                    ReasonList = new List<ReasonReport>()
                    {
                        new ReasonReport
                        {
                            Title = new LangText()
                            {
                                LanguageRU = "ÐÐ¾Ð´Ð¾Ð·ÑÐ¸ÑÐµÐ»ÑÐ½ÑÐ¹",
                                LanguageEN = "Suspicious"
                            },
                            BanCommand = "ban {0} 1d {1}",
                            HideUser = false,
                        },
                        new ReasonReport
                        {
                            Title = new LangText()
                            {
                                LanguageRU = "ÐÐ°ÐºÑÐ¾ÑÑ",
                                LanguageEN = "Macros"
                            },
                            BanCommand = "ban {0} 14d {1}",
                            HideUser = false,
                        },
                        new ReasonReport
                        {
                            Title = new LangText()
                            {
                                LanguageRU = "Ð§Ð¸ÑÐµÑ",
                                LanguageEN = "Cheater"
                            },
                            BanCommand = "ban {0} {1}",
                            HideUser = false,
                        },
                        new ReasonReport
                        {
                            Title = new LangText()
                            {
                                LanguageRU = "3+",
                                LanguageEN = "3+"
                            },
                            BanCommand = "ban {0} 7d {1}",
                            HideUser = false,
                        },
                        new ReasonReport
                        {
                            Title = new LangText()
                            {
                                LanguageRU = "ÐÑÐºÐ°Ð· Ð¾Ñ Ð¿ÑÐ¾Ð²ÐµÑÐºÐ¸",
                                LanguageEN = "Refusal to check"
                            },
                            BanCommand = "ban {0} 7d {1}",
                            HideUser = true,
                        },
                        new ReasonReport
                        {
                            Title = new LangText()
                            {
                                LanguageRU = "ÐÐ³ÑÐ° Ñ Ð½Ð°ÑÑÑÐ¸ÑÐµÐ»ÐµÐ¼",
                                LanguageEN = "Playing with the intruder"
                            },
                            BanCommand = "ban {0} 3d {1}",
                            HideUser = false,
                        },
                    },
                    ReportF7AndGameMenuSettings = new ReportF7AndGameMenu()
                    {
                        UseFunction = true,
                        DefaultIndexReason = 2,
                    },
                    ReportSendControllerSettings = new ReportSendController()
                    {
                        CooldownRepeatOrAll = false,
                        CooldownReport = 300,
                        NoRepeatReport = true,
                    },
                    ReportContollerModerationSettings = new ReportContollerModeration()
                    {
                        ReportCountTrigger = 1,
                        AlertModerationSettings = new ReportContollerModeration.AlertModeration
                        {
                            AlertModerator = true,
                            AlertSound = true,
                            PathSound = "assets/prefabs/npc/autoturret/effects/targetacquired.prefab"
                        }
                    },
                    ColorsSettings = new Colors()
                    {
                        MainColorText = "1 1 1 1",
                        AdditionalColorText = "1 1 1 0.7",
                        AdditionalColorElements = "0.2006497 0.2276834 0.254717 1",
                        MainColor = "0.1294118 0.145098 0.1607843 1",
                        AdditionalColorElementsTwo = "0.281085 0.2712709 0.4528302 1",
                        AdditionalColorElementsThree = "0.3058824 0.7764706 0.9921569 1",
                    },
                    ImagesSettings = new Images
                    {
                        Background = "https://i.postimg.cc/fbBsG7hv/0N6OgXu.png",
                        PageDown = "https://i.postimg.cc/P5qnmpDp/fYZKtuF.png",
                        PageUp = "https://i.postimg.cc/Vkv2SyyX/P17Rrjp.png",
                        Search = "https://i.postimg.cc/GhGxqqk6/yVBF1X7.png",
                        AvatarBlur = "https://i.postimg.cc/Jh2X1kNb/111.png",
                        ReasonModeratorAndRaiting = "https://i.postimg.cc/PrQ8Ccbf/Reason-Moderator.png",
                        PlayerAlerts = "https://i.postimg.cc/TYfJNnCw/XMeNBAj.png",

                        PlayerMenuRaitingSettings = new Images.PlayerMenuRaiting()
                        {
                            PlayerMenuRaitingBackground = "https://i.postimg.cc/xTfL3n1N/lLOWzFo.png",
                        },

                        ModeratorMenuCheckedSettings = new Images.ModeratorMenuChecked()
                        {
                            ModeratorCheckedBackground = "https://i.postimg.cc/P58JmRY8/nBXA5xm.png",
                            ModeratorCheckedStopButton = "https://i.postimg.cc/76PqQsG9/osbdHca.png",
                            ModeratorVerdictButton = "https://i.postimg.cc/85CVb79n/1vthtRD.png",
                            SteamIcoPlayer = "https://i.postimg.cc/fymZV66w/htRHWNV.png",
                            PirateIcoPlayer = "https://i.postimg.cc/XvP0QjWj/GLZQK5a.png",
                        },

                        ModerationBlockSettings = new Images.ModerationBlock()
                        {
                            ModeratorPoopUPBackgorund = "https://i.postimg.cc/CK9xdHzs/aqjRQqw.png",
                            ModeratorPoopUPTextBackgorund = "https://i.postimg.cc/Ss7bKv23/ZYEcVG2.png",
                            ModeratorPoopUPPanelBackgorund = "https://i.postimg.cc/3NcSrXBz/1eSlL3s.png",
                        },

                        LeftBlockSettings = new Images.LeftBlock
                        {
                            ButtonBackgorund = "https://i.postimg.cc/QMhb3YDH/wgYl90C.png",
                            ReportIcon = "https://i.postimg.cc/bJ2H07HV/mayvxja.png",
                            ModerationIcon = "https://i.postimg.cc/ZnxNV49H/UXhlKHq.png",
                        },

                        PlayerListBlockSettings = new Images.PlayerListBlock()
                        {
                            PoopUpBackgorund = "https://i.postimg.cc/bJQSwpRP/6TGBXIv.png",
                            PoopUpReasonBackgorund = "https://i.postimg.cc/ncV9n898/eq76Zc0.png",
                        },
                        StatisticsBlockSettings = new Images.StatisticsBlock
                        {
                            BlockStatsModeration = "https://i.postimg.cc/brwYfhC3/iPobuoo.png",
                            BlockStatsRaitingModeration = "https://i.postimg.cc/dVysYn6P/B17soOi.png",
                            RaitingImage = "https://i.postimg.cc/Wpdb82Z1/2Vo6MQ8.png",
                        }
                    },
                    ReferenceSettings = new References
                    {
                        IQFakeActiveUse = false,
                        StopDamageManSetting = new References.StopDamageMan()
                        {
                            UseStopDamage = false,
                        },
                        MultiFightingSetting = new References.MultiFighting()
                        {
                            UseSteamCheck = false,
                        },
                        IQChatSetting = new References.IQChatReference
                        {
                            CustomPrefix = "[<color=#FF4B42>IQReportSystem</color>]\n",
                            CustomAvatar = "0",
                            UIAlertUse = false,
                        },
                        NoEscapeSetting = new References.NoEscapeReference()
                        {
                            NoCheckedRaidBlock = true,
                            NoCheckedCombatBlock = false,
                        },
                        NoCheckedDuel = true,
                        FriendsSetting = new References.FriendsReference()
                        {
                            SendReportFriend = true,
                            StartCheckedFriend = true,
                        },
                        ClansSetting = new References.ClansReference()
                        {
                            SendReportClan = true,
                            StartCheckedClan = true,
                        },
                        RCCSettings = new References.RustCheatCheck()
                        {
                            RCCKey = "",
                        },
                        OzProtectSettings = new References.OzProtectCheck()
                        {
                            OzProtectKey = "",
                        }
                    }
                };
            }
        }

        private String VKT_PlayerSendContact(BasePlayer Sender, String Contact)
        {
            String Message = LanguageEn
                ? $"â£ PLAYER CONTACTS â£\nInformation about the sender:\nâ¢ Nickname: {Sender.displayName}\nâ¢ Steam64ID: {Sender.userID} (https://steamcommunity.com/profiles/{Sender.userID})\nContact information: {Contact}"
                : $"â£ ÐÐÐÐ¢ÐÐÐ¢Ð« ÐÐÐ ÐÐÐ â£\nÐÐ½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ñ Ð¾Ð± Ð¾ÑÐ¿ÑÐ°Ð²Ð¸ÑÐµÐ»Ðµ :\nâ¢ ÐÐ¸Ðº : {Sender.displayName}\nâ¢ Steam64ID : {Sender.userID} (https://steamcommunity.com/profiles/{Sender.userID})\nÐÐ¾Ð½ÑÐ°ÐºÑÑ Ð´Ð»Ñ ÑÐ²ÑÐ·Ð¸ : {Contact}";

            return Message;
        }
        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["TITLE_NAME_REPORT_SYSTEM"] = "<b>IQReportSystem.</b>",
                ["TITLE_CLOSE_BUTTON_REPORT"] = "<b>X</b>",
                ["TITLE_PLAYER_LIST"] = "<b>Players list</b>",
                ["TITLE_PLAYER_NICK_NAME"] = "NICK NAME",
                ["TITLE_PLAYER_STEAMID"] = "STEAMID",
                ["TITLE_PLAYER_REPORTS"] = "REPORTS",
                ["TITLE_LEFT_MENU_BUTTON_REPORTS"] = "Reports",
                ["TITLE_LEFT_MENU_BUTTON_MODERATION"] = "Moderations",
                ["TITLE_POOPUP_MODERATION_LAST_CHECK_TITLE"] = "Last verifier",
                ["TITLE_POOPUP_MODERATION_AMOUNT_CHECK_TITLE"] = "Number of checks",
                ["TITLE_POOPUP_MODERATION_REPORTS_TITLE"] = "Reports",
                ["TITLE_POOPUP_MODERATION_NO_CHECKED"] = "Has not verified",
                ["TITLE_POOPUP_MODERATION_HISTORY_REPORTS_TITLE"] = "History reports",
                ["TITLE_POOPUP_MODERATION_INFO_BLOCK_EMPTY"] = "Information empty",
                ["TITLE_POOPUP_MODERATION_INFO_CHECK_SERVERS_RCC"] = "Checkeds",
                ["TITLE_POOPUP_MODERATION_INFO_BANS_SERVERS_RCC"] = "Banneds",
                ["TITLE_POOPUP_MODERATION_INFO_BANS_SERVERS_OZPROTECT"] = "Banneds",
                ["TITLE_POOPUP_MODERATION_INFO_BUTTON_START_CHECK"] = "<b>CHECK</b>",
                ["TITLE_PLAYER_HEADER_TITLE_SEND_REPORT"] = "<b>Send report</b>",
                ["TITLE_PLAYER_HEADER_TITLE_DESC_SEND_REPORT"] = "Select a player to",
                ["TITLE_PLAYER_HEADER_TITLE_SEARCH_PLAYER"] = "Find players",
                ["TITLE_PROFILE_INFO_CHECKED"] = "Checked : {0}",
                ["TITLE_PROFILE_MODERATOR_STATISTICS_TITLE_CHECKED"] = "Checkeds",
                ["TITLE_PROFILE_MODERATOR_STATISTICS_TITLE"] = "Statistics",
                ["TITLE_PROFILE_MODERATOR_STATISTICS_TITLE_QUALITY_ASSESSMENT"] = "Quality assessment",
                ["TITLE_PROFILE_MODERATOR_STATISTICS_TITLE_BANS"] = "Banneds",
                ["TITLE_POOPUP_MODERATION_INFO_TEAMS_NAME_PLAYER"] = "Teammates",
                ["TITLE_PROFILE_MODERATOR_STATISTICS_TITLE_ALLSCORE"] = "Raiting",
                ["TITLE_PROFILE_MODERATOR_STATISTICS_TITLE_ONE_ACHIVE"] = "Communicative",
                ["TITLE_PROFILE_MODERATOR_STATISTICS_TITLE_TWO_ACHIVE"] = "Competent",
                ["TITLE_PROFILE_MODERATOR_STATISTICS_TITLE_THREE_ACHIVE"] = "Fast",
                ["TITLE_PROFILE_MODERATOR_STATISTICS_DESCRIPTION_BANS_AND_CHECHKED"] = "all time",
                ["TITLE_PROFILE_MODERATOR_STATISTICS_DESCRIPTION_ONE_ACHIVE"] = "don't be rude",
                ["TITLE_PROFILE_MODERATOR_STATISTICS_DESCRIPTION_TWO_ACHIVE"] = "prove yourself",
                ["TITLE_PROFILE_MODERATOR_STATISTICS_DESCRIPTION_THREE_ACHIVE"] = "don't delay",
                ["TITLE_PROFILE_MODERATOR_CHECKED_MENU_TITLE_BUTTON_RESULT"] = "VERDICT",
                ["TITLE_PROFILE_MODERATOR_CHECKED_MENU_TITLES"] = "Reviewer menu",
                ["TITLE_PROFILE_MODERATOR_CHECKED_MENU_TITLE_BUTTON_STOP"] = "STOP",
                ["TITLE_PROFILE_MODERATOR_CHECKED_MENU_TITLE_STATUS"] = "STATUS : {0}",
                ["TITLE_PROFILE_MODERATOR_CHECKED_MENU_TITLE_STATUS_DEFAULT"] = "ONLINE",
                ["TITLE_PROFILE_MODERATOR_CHECKED_MENU_TITLE_DISCORD"] = "DISCORD : {0}",
                ["TITLE_PROFILE_MODERATOR_CHECKED_MENU_TITLE_DISCORD_EMPTY"] = "NOT PROVIDED",
                ["TITLE_RAITING_WORK_MODERATOR_TITLE"] = "Evaluate the reviewer",
                ["TITLE_RAITING_WORK_MODERATOR_WHO_MODERATOR"] = "You were checked : {0}",
                ["TITLE_RAITING_WORK_MODERATOR_WHO_MODERATOR_NOT_NAME"] = "MODERATOR",
                ["FUNCIONAL_MESSAGE_NO_SEND_RAITING_FOR_MODERATOR"] = "The player refrained from evaluating your check",
                ["TITLE_PLAYER_ALERT_INFORMATION_TITLE"] = "<b><size=34><color=#70C3F8>YOU HAVE BEEN CALLED FOR A CHECK</color></size></b>",
                ["TITLE_PLAYER_ALERT_INFORMATION_DESCRIPTION"] = "<b><size=14>You have exceeded the maximum allowable number of reports!" +
                                                                 "\nProvide your <color=#70C3F8>Discord</color> for our moderation to contact you." +
                                                                 "\nIn case of <color=#70C3F8>ignoring</color> this message - you will receive <color=#70C3F8>banneds</color> on the server!" +
                                                                 "\n\nCommand to send : <color=#70C3F8>/discord YourName#0000</color></size></b>",

                ["FUNCIONAL_MESSAGE_CHECK_AFK_STARTING"] = "We start checking the player on AFK",
                ["FUNCIONAL_MESSAGE_CHECK_AFK_TRY"] = "Checking a player for AFK\nAttemp : {0}",
                ["FUNCIONAL_MESSAGE_CHECK_START"] = "The check is started, the player is notified!",
                ["FUNCIONAL_MESSAGE_CHECK_AFK_PLAYER_AFK"] = "Check has not been started!\nThe player is in AFK, please try again later",
                ["FUNCIONAL_MESSAGE_CHECK_AFK_PLAYER_LEAVE"] = "Player left the server while checking for AFK\nChecking cancelled, please try again later",
                ["FUNCIONAL_MESSAGE_CHECK_AFK_PLAYER_SEND_CHAT"] = "The player wrote a message in the chat\nMessage : {0}",
                ["FUNCIONAL_MESSAGE_CHECK_AFK_PLAYER_SEND_COMMAND"] = "The player used the command\nCommand : {0}",
                ["FUNCIONAL_MESSAGE_CHECK_AFK_PLAYER_START_CRAFTING"] = "The player has just crafted an item",
                ["FUNCIONAL_MESSAGE_CHECK_AFK_PLAYER_CANCELLED_CRAFTING"] = "Player just canceled item crafting",
                ["FUNCIONAL_MESSAGE_NO_SEND_RAITING"] = "You refrained from rating the moderator",
                ["FUNCIONAL_MESSAGE_SEND_RAITING"] = "Thanks!\nYour rating has been successfully submitted\nWe care about the quality of moderation work",
                ["FUNCIONAL_MESSAGE_SEND_RAITING_FOR_MODERATOR"] = "The player has rated your check",
                ["FUNCIONAL_SEND_DISCORD_NULL_DS"] = "You have not entered your <color=#70C3F8>Discord</color>",
                ["FUNCIONAL_SEND_DISCORD_NO_REGEX_DS"] = "Enter correct <color=#70C3F8>Discord</color>",
                ["FUNCIONAL_SEND_DISCORD_SUCCESS"] = "You have successfully submitted your <color=#70C3F8>Discord</color>\nContact : {0}",
                ["FUNCIONAL_SEND_DISCORD_SUCCESS_ALERT_MODERATOR"] = "The player sent you his <color=#70C3F8>Discord</color>\nContact : {0}",
                ["FUNCIONAL_CHANGE_STATUS_PLAYER_ALERT_MODERATOR"] = "The player's connection status has changed from server to : {0}\nWait for it for 15 minutes, otherwise issue a block for refusing to check",
                ["FUNCIONAL_CHANGE_STATUS_PLAYER_ONLINE_ALERT_MODERATOR"] = "The player has connected to the server\nCheck continued",
                ["FUNCIONAL_CHANGE_STATUS_PLAYER_ONLINE_ALERT_PLAYER"] = "Connected!\nChecking continued, the moderator is waiting for your contact!",
                ["FUNCIONAL_CHANGE_STATUS_MODERATOR_DISCONNECTED"] = "The moderator has left the server\nWait 10 minutes - verification will continue after it is connected\nOtherwise, the check will be canceled automatically.",
                ["FUNCIONAL_CHANGE_STATUS_MODERATOR_RECONNECTED"] = "Moderator reconnected to the server\nChecked continued",
                ["FUNCIONAL_CHANGE_STATUS_MODERATOR_DISCONNECTED_FULL_LEAVE"] = "Moderator failed to connect\nCheck has been canceled\nWe're sorry, have fun",
                ["FUNCIONAL_MODERATOR_VERDICT_RESULT"] = "You finished checking with a verdict : {0}\nAppropriate action has been taken against the player",
                ["FUNCIONAL_SEND_REPORT_SUCCESS"] = "You have successfully reported player {0}",
                ["FUNCIONAL_NO_DUPLE_SEND_REPORT"] = "You have already sent a complaint about this player!\nWait for it to be checked",
                ["FUNCIONAL_COOLDOWN_REPORT"] = "You have already sent a complaint!\nWait {0} seconds before resending",
                ["FUNCIONAL_PLAYER_STOP_DAMAGE_MAN_ADD"] = "Damage is disabled for you during the check - you can't deal damage to players, buildings, etc.",

                ["NOTIFY_PLAYERS_START_CHECK_MODERATOR"] = "Moderator {0} called player {1} to check\nYou can send a report using /report",
                ["NOTIFY_PLAYERS_START_CHECK_NOT_MODERATOR"] = "Player {0} was called for check\nYou can send a report using /report",
                ["NOTIFY_PLAYERS_STOP_CHECK_MODERATOR"] = "Moderator {0} finished checking player {1}\nUse of prohibited software - not detected",
                ["NOTIFY_PLAYERS_STOP_CHECK_NOT_MODERATOR"] = "Checking of player {0} completed\nUse of prohibited software - not detected",
                ["NOTIFY_PLAYERS_STOP_CHECK_VERDICT_MODERATOR"] = "Moderator {0} finished checking player {1} with verdict {2}\nAppropriate action has been taken against the player.",
                ["NOTIFY_PLAYERS_STOP_CHECK_VERDICT_NOT_MODERATOR"] = "Verification of player {0} completed with verdict {1}\nAppropriate action has been taken against the player.",
                ["NOTIFY_MODERATOR_RAIDBLOCK_PLAYER"] = "The check was canceled automatically with complaints saved\nReason : the player has an active raid-block",
                ["NOTIFY_MODERATOR_ITS_PLAYER_CHECKED"] = "This player has already been called for checked",
                ["NOTIFY_MODERATOR_COMBATBLOCK_PLAYER"] = "The check was canceled automatically with complaints saved\nReason : the player has an active combat-block",
                ["NOTIFY_MODERATOR_DUEL_PLAYER"] = "The check was canceled automatically with complaints saved\nReason : the player is in a duel",
                ["NOTIFY_MODERATOR_FRIEND_PLAYER"] = "The check was canceled automatically with complaints saved\nReason : the player is your teammate",
                ["NOTIFY_MODERATOR_MAX_REPORT"] = "Player {0} has exceeded the number of reports, call him for check!\nNumber of reports : {1}",

            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["TITLE_NAME_REPORT_SYSTEM"] = "<b>IQReportSystem.</b>",
                ["TITLE_CLOSE_BUTTON_REPORT"] = "<b>X</b>",
                ["TITLE_PLAYER_LIST"] = "<b>Ð¡Ð¿Ð¸ÑÐ¾Ðº Ð¸Ð³ÑÐ¾ÐºÐ¾Ð²</b>",
                ["TITLE_PLAYER_NICK_NAME"] = "NICK NAME",
                ["TITLE_PLAYER_STEAMID"] = "STEAMID",
                ["TITLE_PLAYER_REPORTS"] = "ÐÐÐÐÐ",
                ["TITLE_LEFT_MENU_BUTTON_REPORTS"] = "ÐÐ°Ð»Ð¾Ð±Ñ",
                ["TITLE_LEFT_MENU_BUTTON_MODERATION"] = "ÐÐ¾Ð´ÐµÑÐ°ÑÐ¸Ñ",
                ["TITLE_POOPUP_MODERATION_LAST_CHECK_TITLE"] = "ÐÐ¾ÑÐ»ÐµÐ´Ð½Ð¸Ð¹ Ð¿ÑÐ¾Ð²ÐµÑÑÑÑÐ¸Ð¹",
                ["TITLE_POOPUP_MODERATION_AMOUNT_CHECK_TITLE"] = "ÐÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ð¾ Ð¿ÑÐ¾Ð²ÐµÑÐ¾Ðº",
                ["TITLE_POOPUP_MODERATION_REPORTS_TITLE"] = "ÐÐ°Ð»Ð¾Ð±(/Ñ)",
                ["TITLE_POOPUP_MODERATION_NO_CHECKED"] = "ÐÐµ Ð±ÑÐ» Ð¿ÑÐ¾Ð²ÐµÑÐµÐ½",
                ["TITLE_POOPUP_MODERATION_HISTORY_REPORTS_TITLE"] = "ÐÑÑÐ¾ÑÐ¸Ñ Ð¶Ð°Ð»Ð¾Ð±",
                ["TITLE_POOPUP_MODERATION_INFO_BLOCK_EMPTY"] = "ÐÐ½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ð¸ Ð½ÐµÑ",
                ["TITLE_POOPUP_MODERATION_INFO_CHECK_SERVERS_RCC"] = "ÐÑÐ¾Ð²ÐµÑÑÐ»ÑÑ",
                ["TITLE_POOPUP_MODERATION_INFO_BANS_SERVERS_RCC"] = "ÐÐ°Ð±Ð°Ð½ÐµÐ½",
                ["TITLE_POOPUP_MODERATION_INFO_BANS_SERVERS_OZPROTECT"] = "ÐÐ°Ð±Ð°Ð½ÐµÐ½",
                ["TITLE_POOPUP_MODERATION_INFO_TEAMS_NAME_PLAYER"] = "Ð¢Ð¸Ð¼Ð¼ÐµÐ¹ÑÑ",
                ["TITLE_POOPUP_MODERATION_INFO_BUTTON_START_CHECK"] = "<b>ÐÐ ÐÐÐÐ ÐÐ¢Ð¬</b>",
                ["TITLE_PLAYER_HEADER_TITLE_SEND_REPORT"] = "<b>ÐÑÐ¿ÑÐ°Ð²Ð¸ÑÑ Ð¶Ð°Ð»Ð¾Ð±Ñ</b>",
                ["TITLE_PLAYER_HEADER_TITLE_DESC_SEND_REPORT"] = "ÐÑÐ±ÐµÑÐ¸ÑÐµ Ð¸Ð³ÑÐ¾ÐºÐ° ÑÑÐ¾Ð±Ñ",
                ["TITLE_PLAYER_HEADER_TITLE_SEARCH_PLAYER"] = "ÐÐ¾Ð¸ÑÐº Ð¸Ð³ÑÐ¾ÐºÐ¾Ð²",
                ["TITLE_PROFILE_INFO_CHECKED"] = "ÐÑÐ¾Ð²ÐµÑÐµÐ½ : {0}",
                ["TITLE_PROFILE_MODERATOR_STATISTICS_TITLE_CHECKED"] = "ÐÑÐ¾Ð²ÐµÑÐ¾Ðº",
                ["TITLE_PROFILE_MODERATOR_STATISTICS_TITLE"] = "Ð¡ÑÐ°ÑÐ¸ÑÑÐ¸ÐºÐ°",
                ["TITLE_PROFILE_MODERATOR_STATISTICS_TITLE_QUALITY_ASSESSMENT"] = "ÐÑÐµÐ½ÐºÐ° ÐºÐ°ÑÐµÑÑÐ²Ð°",
                ["TITLE_PROFILE_MODERATOR_STATISTICS_TITLE_BANS"] = "ÐÐ»Ð¾ÐºÐ¸ÑÐ¾Ð²Ð¾Ðº",
                ["TITLE_PROFILE_MODERATOR_STATISTICS_TITLE_ALLSCORE"] = "ÐÐ±ÑÐ¸Ð¹ Ð±Ð°Ð»Ð»",
                ["TITLE_PROFILE_MODERATOR_STATISTICS_TITLE_ONE_ACHIVE"] = "ÐÐ±ÑÐ¸ÑÐµÐ»ÑÐ½ÑÐ¹",
                ["TITLE_PROFILE_MODERATOR_STATISTICS_TITLE_TWO_ACHIVE"] = "ÐÐ¾Ð¼Ð¿ÐµÑÐµÐ½ÑÐ½ÑÐ¹",
                ["TITLE_PROFILE_MODERATOR_STATISTICS_TITLE_THREE_ACHIVE"] = "ÐÑÑÑÑÑÐ¹",
                ["TITLE_PROFILE_MODERATOR_STATISTICS_DESCRIPTION_BANS_AND_CHECHKED"] = "Ð·Ð° Ð²ÑÐµ Ð²ÑÐµÐ¼Ñ",
                ["TITLE_PROFILE_MODERATOR_STATISTICS_DESCRIPTION_ONE_ACHIVE"] = "Ð½Ðµ Ð³ÑÑÐ±Ð¸ÑÐµ",
                ["TITLE_PROFILE_MODERATOR_STATISTICS_DESCRIPTION_TWO_ACHIVE"] = "Ð¿ÑÐ¾ÑÐ²Ð¸ÑÐµ ÑÐµÐ±Ñ",
                ["TITLE_PROFILE_MODERATOR_STATISTICS_DESCRIPTION_THREE_ACHIVE"] = "Ð½Ðµ Ð¼ÐµÐ´Ð»Ð¸ÑÐµ",
                ["TITLE_PROFILE_MODERATOR_CHECKED_MENU_TITLE_BUTTON_RESULT"] = "ÐÐÐ ÐÐÐÐ¢",
                ["TITLE_PROFILE_MODERATOR_CHECKED_MENU_TITLES"] = "ÐÐµÐ½Ñ Ð¿ÑÐ¾Ð²ÐµÑÑÑÑÐµÐ³Ð¾",
                ["TITLE_PROFILE_MODERATOR_CHECKED_MENU_TITLE_BUTTON_STOP"] = "CÐ¢ÐÐ",
                ["TITLE_PROFILE_MODERATOR_CHECKED_MENU_TITLE_STATUS"] = "STATUS : {0}",
                ["TITLE_PROFILE_MODERATOR_CHECKED_MENU_TITLE_STATUS_DEFAULT"] = "ONLINE",
                ["TITLE_PROFILE_MODERATOR_CHECKED_MENU_TITLE_DISCORD"] = "DISCORD : {0}",
                ["TITLE_PROFILE_MODERATOR_CHECKED_MENU_TITLE_DISCORD_EMPTY"] = "ÐÐ ÐÐ ÐÐÐÐ¡Ð¢ÐÐÐÐÐ",
                ["TITLE_RAITING_WORK_MODERATOR_TITLE"] = "ÐÑÐµÐ½Ð¸ÑÐµ Ð¿ÑÐ¾Ð²ÐµÑÑÑÑÐµÐ³Ð¾",
                ["TITLE_RAITING_WORK_MODERATOR_WHO_MODERATOR"] = "ÐÐ°Ñ Ð¿ÑÐ¾Ð²ÐµÑÑÐ» : {0}",
                ["TITLE_RAITING_WORK_MODERATOR_WHO_MODERATOR_NOT_NAME"] = "ÐÐÐÐÐ ÐÐ¢ÐÐ ",
                ["TITLE_PLAYER_ALERT_INFORMATION_TITLE"] = "<b><size=34><color=#70C3F8>ÐÐÐ¡ ÐÐ«ÐÐÐÐÐ ÐÐ ÐÐ ÐÐÐÐ ÐÐ£</color></size></b>",
                ["TITLE_PLAYER_ALERT_INFORMATION_DESCRIPTION"] = "<b><size=14>ÐÑ Ð¿ÑÐµÐ²ÑÑÐ¸Ð»Ð¸ Ð¼Ð°ÐºÑÐ¸Ð¼Ð°Ð»ÑÐ½Ð¾-Ð´Ð¾Ð¿ÑÑÑÐ¸Ð¼Ð¾Ðµ ÐºÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ð¾ Ð¶Ð°Ð»Ð¾Ð±!" +
                                                                 "\nÐÑÐµÐ´Ð¾ÑÑÐ°Ð²ÑÑÐµ Ð²Ð°Ñ <color=#70C3F8>Discord</color> Ð´Ð»Ñ ÑÐ¾Ð³Ð¾ ÑÑÐ¾Ð±Ñ Ñ Ð²Ð°Ð¼Ð¸ ÑÐ²ÑÐ·Ð°Ð»Ð°ÑÑ Ð½Ð°ÑÐ° Ð¼Ð¾Ð´ÐµÑÐ°ÑÐ¸Ñ." +
                                                                 "\nÐ ÑÐ»ÑÑÐ°Ðµ <color=#70C3F8>Ð¸Ð³Ð½Ð¾ÑÐ¸ÑÐ¾Ð²Ð°Ð½Ð¸Ñ</color> Ð´Ð°Ð½Ð½Ð¾Ð³Ð¾ ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ñ - Ð²Ñ Ð¿Ð¾Ð»ÑÑÐ¸ÑÐµ <color=#70C3F8>Ð±Ð»Ð¾ÐºÐ¸ÑÐ¾Ð²ÐºÑ</color> Ð½Ð° ÑÐµÑÐ²ÐµÑÐµ!" +
                                                                 "\n\nÐÐ¾Ð¼Ð°Ð½Ð´Ð° Ð´Ð»Ñ Ð¾ÑÐ¿ÑÐ°Ð²ÐºÐ¸ : <color=#70C3F8>/discord YourName#0000</color></size></b>",

                ["FUNCIONAL_MESSAGE_CHECK_AFK_STARTING"] = "ÐÐ°ÑÐ¸Ð½Ð°ÐµÐ¼ Ð¿ÑÐ¾Ð²ÐµÑÐºÑ Ð¸Ð³ÑÐ¾ÐºÐ° Ð½Ð° AFK",
                ["FUNCIONAL_MESSAGE_CHECK_AFK_TRY"] = "ÐÑÐ¾Ð²ÐµÑÑÐµÐ¼ Ð¸Ð³ÑÐ¾ÐºÐ° Ð½Ð° AFK\nÐÐ¾Ð¿ÑÑÐºÐ° : {0}",
                ["FUNCIONAL_MESSAGE_CHECK_START"] = "ÐÑÐ¾Ð²ÐµÑÐºÐ° Ð·Ð°Ð¿ÑÑÐµÐ½Ð°, Ð¸Ð³ÑÐ¾Ðº ÑÐ²ÐµÐ´Ð¾Ð¼Ð»ÐµÐ½!",
                ["FUNCIONAL_MESSAGE_CHECK_AFK_PLAYER_AFK"] = "ÐÑÐ¾Ð²ÐµÑÐºÐ° Ð½Ðµ Ð±ÑÐ»Ð° Ð·Ð°Ð¿ÑÑÐµÐ½Ð°!\nÐÐ³ÑÐ¾Ðº Ð½Ð°ÑÐ¾Ð´Ð¸ÑÑÑ Ð² AFK, Ð¿Ð¾Ð¶Ð°Ð»ÑÐ¹ÑÑÐ° Ð¿Ð¾Ð²ÑÐ¾ÑÐ¸ÑÐµ Ð¿Ð¾Ð¿ÑÑÐºÑ Ð¿Ð¾Ð·Ð¶Ðµ",
                ["FUNCIONAL_MESSAGE_CHECK_AFK_PLAYER_LEAVE"] = "ÐÐ³ÑÐ¾Ðº Ð¿Ð¾ÐºÐ¸Ð½ÑÐ» ÑÐµÑÐ²ÐµÑ Ð½Ð° ÑÑÐ°Ð´Ð¸Ð¸ Ð¿ÑÐ¾Ð²ÐµÑÐºÐ¸ Ð½Ð° AFK\nÐÑÐ¾Ð²ÐµÑÐºÐ° Ð¾ÑÐ¼ÐµÐ½ÐµÐ½Ð°, Ð¿Ð¾Ð²ÑÐ¾ÑÐ¸ÑÐµ Ð¿Ð¾Ð¿ÑÑÐºÑ Ð¿Ð¾Ð·Ð¶Ðµ",
                ["FUNCIONAL_MESSAGE_CHECK_AFK_PLAYER_SEND_CHAT"] = "ÐÐ³ÑÐ¾Ðº Ð½Ð°Ð¿Ð¸ÑÐ°Ð» ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ðµ Ð² ÑÐ°Ñ\nÐ¡Ð¾Ð¾Ð±ÑÐµÐ½Ð¸Ðµ : {0}",
                ["FUNCIONAL_MESSAGE_CHECK_AFK_PLAYER_SEND_COMMAND"] = "ÐÐ³ÑÐ¾Ðº Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð» ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ\nÐÐ¾Ð¼Ð°Ð½Ð´Ð° : {0}",
                ["FUNCIONAL_MESSAGE_CHECK_AFK_PLAYER_START_CRAFTING"] = "ÐÐ³ÑÐ¾Ðº ÑÐ¾Ð»ÑÐºÐ¾ ÑÑÐ¾ Ð¿Ð¾ÑÑÐ°Ð²Ð¸Ð» Ð¿ÑÐµÐ´Ð¼ÐµÑ Ð½Ð° ÐºÑÐ°ÑÑ",
                ["FUNCIONAL_MESSAGE_CHECK_AFK_PLAYER_CANCELLED_CRAFTING"] = "ÐÐ³ÑÐ¾Ðº ÑÐ¾Ð»ÑÐºÐ¾ ÑÑÐ¾ Ð¾ÑÐ¼ÐµÐ½Ð¸Ð» ÐºÑÐ°ÑÑ Ð¿ÑÐµÐ´Ð¼ÐµÑÐ°",
                ["FUNCIONAL_MESSAGE_NO_SEND_RAITING"] = "ÐÑ Ð²Ð¾Ð·Ð´ÐµÑÐ¶Ð°Ð»Ð¸ÑÑ Ð¾Ñ Ð¾ÑÐµÐ½ÐºÐ¸ Ð¼Ð¾Ð´ÐµÑÐ°ÑÐ¾ÑÐ°",
                ["FUNCIONAL_MESSAGE_NO_SEND_RAITING_FOR_MODERATOR"] = "ÐÐ³ÑÐ¾Ðº Ð²Ð¾Ð·Ð´ÐµÑÐ¶Ð°Ð»ÑÑ Ð¾Ñ Ð¾ÑÐµÐ½ÐºÐ¸ Ð²Ð°ÑÐµÐ¹ Ð¿ÑÐ¾Ð²ÐµÑÐºÐ¸",
                ["FUNCIONAL_MESSAGE_SEND_RAITING"] = "Ð¡Ð¿Ð°ÑÐ¸Ð±Ð¾!\nÐÐ°ÑÐ° Ð¾ÑÐµÐ½ÐºÐ° ÑÑÐ¿ÐµÑÐ½Ð¾ Ð¾ÑÐ¿ÑÐ°Ð²Ð»ÐµÐ½Ð°\nÐÐ°Ð¼ Ð²Ð°Ð¶Ð½Ð¾ ÐºÐ°ÑÐµÑÑÐ²Ð¾ ÑÐ°Ð±Ð¾ÑÑ Ð¼Ð¾Ð´ÐµÑÐ°ÑÐ¸Ð¸",
                ["FUNCIONAL_MESSAGE_SEND_RAITING_FOR_MODERATOR"] = "ÐÐ³ÑÐ¾Ðº Ð¾ÑÐµÐ½Ð¸Ð» Ð²Ð°ÑÑ Ð¿ÑÐ¾Ð²ÐµÑÐºÑ",
                ["FUNCIONAL_SEND_DISCORD_NULL_DS"] = "ÐÑ Ð½Ðµ Ð²Ð²ÐµÐ»Ð¸ ÑÐ²Ð¾Ð¹ <color=#70C3F8>Discord</color>",
                ["FUNCIONAL_SEND_DISCORD_NO_REGEX_DS"] = "ÐÐ²ÐµÐ´Ð¸ÑÐµ ÐºÐ¾ÑÑÐµÐºÑÐ½ÑÐ¹ <color=#70C3F8>Discord</color>",
                ["FUNCIONAL_SEND_DISCORD_SUCCESS"] = "ÐÑ ÑÑÐ¿ÐµÑÐ½Ð¾ Ð¾ÑÐ¿ÑÐ°Ð²Ð¸Ð»Ð¸ ÑÐ²Ð¾Ð¹ <color=#70C3F8>Discord</color>\nÐÐ¾Ð½ÑÐ°ÐºÑ : {0}",
                ["FUNCIONAL_SEND_DISCORD_SUCCESS_ALERT_MODERATOR"] = "ÐÐ³ÑÐ¾Ðº Ð¿ÑÐ¸ÑÐ»Ð°Ð» Ð²Ð°Ð¼ ÑÐ²Ð¾Ð¹ <color=#70C3F8>Discord</color>\nÐÐ¾Ð½ÑÐ°ÐºÑ : {0}",
                ["FUNCIONAL_CHANGE_STATUS_PLAYER_ALERT_MODERATOR"] = "Ð£ Ð¸Ð³ÑÐ¾ÐºÐ° Ð¸Ð·Ð¼ÐµÐ½Ð¸Ð»ÑÑ ÑÑÐ°ÑÑÑ ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ñ Ñ ÑÐµÑÐ²ÐµÑÐ¾Ð¼ Ð½Ð° : {0}\nÐÐ¶Ð¸Ð´Ð°Ð¹ÑÐµ ÐµÐ³Ð¾ 15 Ð¼Ð¸Ð½ÑÑ, Ð² Ð¸Ð½Ð¾Ð¼ ÑÐ»ÑÑÐ°Ðµ Ð²ÑÐ´Ð°Ð²Ð°Ð¹ÑÐµ Ð±Ð»Ð¾ÐºÐ¸ÑÐ¾Ð²ÐºÑ Ð·Ð° Ð¾ÑÐºÐ°Ð· Ð¾Ñ Ð¿ÑÐ¾Ð²ÐµÑÐºÐ¸",
                ["FUNCIONAL_CHANGE_STATUS_PLAYER_ONLINE_ALERT_MODERATOR"] = "ÐÐ³ÑÐ¾Ðº Ð¿Ð¾Ð´ÐºÐ»ÑÑÐ¸Ð»ÑÑ Ðº ÑÐµÑÐ²ÐµÑÑ\nÐÑÐ¾Ð²ÐµÑÐºÐ° Ð¿ÑÐ¾Ð´Ð¾Ð»Ð¶ÐµÐ½Ð°",
                ["FUNCIONAL_CHANGE_STATUS_PLAYER_ONLINE_ALERT_PLAYER"] = "Ð¡ Ð¿Ð¾Ð´ÐºÐ»ÑÑÐµÐ½Ð¸ÐµÐ¼!\nÐÑÐ¾Ð²ÐµÑÐºÐ° Ð¿ÑÐ¾Ð´Ð¾Ð»Ð¶ÐµÐ½Ð°, Ð¼Ð¾Ð´ÐµÑÐ°ÑÐ¾Ñ Ð¾Ð¶Ð¸Ð´Ð°ÐµÑ Ð²Ð°Ñ ÐºÐ¾Ð½ÑÐ°ÐºÑ!",
                ["FUNCIONAL_CHANGE_STATUS_MODERATOR_DISCONNECTED"] = "ÐÐ¾Ð´ÐµÑÐ°ÑÐ¾Ñ Ð¿Ð¾ÐºÐ¸Ð½ÑÐ» ÑÐµÑÐ²ÐµÑ\nÐÐ¶Ð¸Ð´Ð°Ð¹ÑÐµ 10 Ð¼Ð¸Ð½ÑÑ - Ð¿ÑÐ¾Ð²ÐµÑÐºÐ° Ð¿ÑÐ¾Ð´Ð¾Ð»Ð¶Ð¸ÑÑÑ Ð¿Ð¾ÑÐ»Ðµ ÐµÐ³Ð¾ Ð¿Ð¾Ð´ÐºÐ»ÑÑÐµÐ½Ð¸Ñ\nÐ Ð¸Ð½Ð¾Ð¼ ÑÐ»ÑÑÐ°Ðµ Ð¿ÑÐ¾Ð²ÐµÑÐºÐ° Ð±ÑÐ´ÐµÑ Ð¾ÑÐ¼ÐµÐ½ÐµÐ½Ð° Ð°Ð²ÑÐ¾Ð¼Ð°ÑÐ¸ÑÐµÑÐºÐ¸",
                ["FUNCIONAL_CHANGE_STATUS_MODERATOR_DISCONNECTED_FULL_LEAVE"] = "ÐÐ¾Ð´ÐµÑÐ°ÑÐ¾Ñ Ð½Ðµ ÑÑÐ¿ÐµÐ» Ð¿Ð¾Ð´ÐºÐ»ÑÑÐ¸ÑÑÑÑ\nÐÑÐ¾Ð²ÐµÑÐºÐ° Ð±ÑÐ»Ð° Ð¾ÑÐ¼ÐµÐ½ÐµÐ½Ð°\nÐÑÐ¸Ð½Ð¾ÑÐ¸Ð¼ Ð¸Ð·Ð²Ð¸Ð½ÐµÐ½Ð¸Ñ, Ð¿ÑÐ¸ÑÑÐ½Ð¾Ð¹ Ð¸Ð³ÑÑ",
                ["FUNCIONAL_CHANGE_STATUS_MODERATOR_RECONNECTED"] = "ÐÐ¾Ð´ÐµÑÐ°ÑÐ¾Ñ Ð¿ÐµÑÐµÐ¿Ð¾Ð´ÐºÐ»ÑÑÐ¸Ð»ÑÑ Ð½Ð° ÑÐµÑÐ²ÐµÑ\nÐÑÐ¾Ð²ÐµÑÐºÐ° Ð¿ÑÐ¾Ð´Ð¾Ð»Ð¶ÐµÐ½Ð°",
                ["FUNCIONAL_MODERATOR_VERDICT_RESULT"] = "ÐÑ Ð·Ð°ÐºÐ¾Ð½ÑÐ¸Ð»Ð¸ Ð¿ÑÐ¾Ð²ÐµÑÐºÑ Ñ Ð²ÐµÑÐ´Ð¸ÐºÑÐ¾Ð¼ : {0}\nÐ Ð¸Ð³ÑÐ¾ÐºÑ Ð¿ÑÐ¸Ð¼ÐµÐ½ÐµÐ½Ñ ÑÐ¾Ð¾ÑÐ²ÐµÑÑÐ²ÑÑÑÐ¸Ðµ Ð¼ÐµÑÑ",
                ["FUNCIONAL_SEND_REPORT_SUCCESS"] = "ÐÑ ÑÑÐ¿ÐµÑÐ½Ð¾ Ð¾ÑÐ¿ÑÐ°Ð²Ð¸Ð»Ð¸ Ð¶Ð°Ð»Ð¾Ð±Ñ Ð½Ð° Ð¸Ð³ÑÐ¾ÐºÐ° {0}",
                ["FUNCIONAL_NO_DUPLE_SEND_REPORT"] = "ÐÑ ÑÐ¶Ðµ Ð¾ÑÐ¿ÑÐ°Ð²Ð»ÑÐ»Ð¸ Ð¶Ð°Ð»Ð¾Ð±Ñ Ð½Ð° ÑÑÐ¾Ð³Ð¾ Ð¸Ð³ÑÐ¾ÐºÐ°!\nÐÐ¶Ð¸Ð´Ð°Ð¹ÑÐµ ÐºÐ¾Ð³Ð´Ð° ÐµÐ³Ð¾ Ð¿ÑÐ¾Ð²ÐµÑÑÑ",
                ["FUNCIONAL_COOLDOWN_REPORT"] = "ÐÑ ÑÐ¶Ðµ Ð¾ÑÐ¿ÑÐ°Ð²Ð»ÑÐ»Ð¸ Ð¶Ð°Ð»Ð¾Ð±Ñ!\nÐÐ¶Ð¸Ð´Ð°Ð¹ÑÐµ {0} ÑÐµÐºÑÐ½Ð´ Ð¿ÐµÑÐµÐ´ Ð¿Ð¾Ð²ÑÐ¾ÑÐ½Ð¾Ð¹ Ð¾ÑÐ¿ÑÐ°Ð²ÐºÐ¾Ð¹",
                ["FUNCIONAL_PLAYER_STOP_DAMAGE_MAN_ADD"] = "ÐÐ° Ð²ÑÐµÐ¼Ñ Ð¿ÑÐ¾Ð²ÐµÑÐºÐ¸ Ð²Ð°Ð¼ Ð¾ÑÐºÐ»ÑÑÐµÐ½ ÑÑÐ¾Ð½ - Ð²Ñ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ Ð½Ð°Ð½Ð¾ÑÐ¸ÑÑ ÑÑÐ¾Ð½ Ð¿Ð¾ Ð¸Ð³ÑÐ¾ÐºÐ°Ð¼, Ð¿Ð¾ÑÑÑÐ¾Ð¹ÐºÐ°Ð¼ Ð¸ Ñ.Ð´",

                ["NOTIFY_PLAYERS_START_CHECK_MODERATOR"] = "ÐÐ¾Ð´ÐµÑÐ°ÑÐ¾Ñ {0} Ð²ÑÐ·Ð²Ð°Ð» Ð½Ð° Ð¿ÑÐ¾Ð²ÐµÑÐºÑ Ð¸Ð³ÑÐ¾ÐºÐ° {1}\nÐÑÐ¿ÑÐ°Ð²Ð¸ÑÑ Ð¶Ð°Ð»Ð¾Ð±Ñ Ð¼Ð¾Ð¶Ð½Ð¾ Ñ Ð¿Ð¾Ð¼Ð¾ÑÑÑ /report",
                ["NOTIFY_PLAYERS_START_CHECK_NOT_MODERATOR"] = "ÐÐ³ÑÐ¾ÐºÐ° {0} Ð²ÑÐ·Ð²Ð°Ð»Ð¸ Ð½Ð° Ð¿ÑÐ¾Ð²ÐµÑÐºÑ\nÐÑÐ¿ÑÐ°Ð²Ð¸ÑÑ Ð¶Ð°Ð»Ð¾Ð±Ñ Ð¼Ð¾Ð¶Ð½Ð¾ Ñ Ð¿Ð¾Ð¼Ð¾ÑÑÑ /report",
                ["NOTIFY_PLAYERS_STOP_CHECK_MODERATOR"] = "ÐÐ¾Ð´ÐµÑÐ°ÑÐ¾Ñ {0} Ð·Ð°Ð²ÐµÑÑÐ¸Ð» Ð¿ÑÐ¾Ð²ÐµÑÐºÑ Ð¸Ð³ÑÐ¾ÐºÐ° {1}\nÐÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ Ð·Ð°Ð¿ÑÐµÑÐµÐ½Ð½Ð¾Ð³Ð¾ ÐÐ - Ð½Ðµ Ð¾Ð±Ð½Ð°ÑÑÐ¶ÐµÐ½Ð¾",
                ["NOTIFY_PLAYERS_STOP_CHECK_NOT_MODERATOR"] = "ÐÑÐ¾Ð²ÐµÑÐºÐ° Ð¸Ð³ÑÐ¾ÐºÐ° {0} Ð·Ð°Ð²ÐµÑÑÐµÐ½Ð°\nÐÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ Ð·Ð°Ð¿ÑÐµÑÐµÐ½Ð½Ð¾Ð³Ð¾ ÐÐ - Ð½Ðµ Ð¾Ð±Ð½Ð°ÑÑÐ¶ÐµÐ½Ð¾",
                ["NOTIFY_PLAYERS_STOP_CHECK_VERDICT_MODERATOR"] = "ÐÐ¾Ð´ÐµÑÐ°ÑÐ¾Ñ {0} Ð·Ð°Ð²ÐµÑÑÐ¸Ð» Ð¿ÑÐ¾Ð²ÐµÑÐºÑ Ð¸Ð³ÑÐ¾ÐºÐ° {1} Ñ Ð²ÐµÑÐ´Ð¸ÐºÑÐ¾Ð¼ {2}\nÐ Ð¸Ð³ÑÐ¾ÐºÑ Ð¿ÑÐ¸Ð¼ÐµÐ½ÐµÐ½Ñ ÑÐ¾Ð¾ÑÐ²ÐµÑÑÐ²ÑÑÑÐ¸Ðµ Ð¼ÐµÑÑ",
                ["NOTIFY_PLAYERS_STOP_CHECK_VERDICT_NOT_MODERATOR"] = "ÐÑÐ¾Ð²ÐµÑÐºÐ° Ð¸Ð³ÑÐ¾ÐºÐ° {0} Ð·Ð°Ð²ÐµÑÑÐµÐ½Ð° Ñ Ð²ÐµÑÐ´Ð¸ÐºÑÐ¾Ð¼ {1}\nÐ Ð¸Ð³ÑÐ¾ÐºÑ Ð¿ÑÐ¸Ð¼ÐµÐ½ÐµÐ½Ñ ÑÐ¾Ð¾ÑÐ²ÐµÑÑÐ²ÑÑÑÐ¸Ðµ Ð¼ÐµÑÑ",
                ["NOTIFY_MODERATOR_RAIDBLOCK_PLAYER"] = "ÐÑÐ¾Ð²ÐµÑÐºÐ° Ð¾ÑÐ¼ÐµÐ½ÐµÐ½Ð° Ð°Ð²ÑÐ¾Ð¼Ð°ÑÐ¸ÑÐµÑÐºÐ¸ Ñ ÑÐ¾ÑÑÐ°Ð½ÐµÐ½Ð¸ÐµÐ¼ Ð¶Ð°Ð»Ð¾Ð±\nÐÑÐ¸ÑÐ¸Ð½Ð° : Ñ Ð¸Ð³ÑÐ¾ÐºÐ° Ð°ÐºÑÐ¸Ð²Ð½ÑÐ¹ ÑÐµÐ¹Ð´-Ð±Ð»Ð¾Ðº",
                ["NOTIFY_MODERATOR_ITS_PLAYER_CHECKED"] = "ÐÐ°Ð½Ð½Ð¾Ð³Ð¾ Ð¸Ð³ÑÐ¾ÐºÐ° ÑÐ¶Ðµ Ð²ÑÐ·Ð²Ð°Ð»Ð¸ Ð½Ð° Ð¿ÑÐ¾Ð²ÐµÑÐºÑ",
                ["NOTIFY_MODERATOR_COMBATBLOCK_PLAYER"] = "ÐÑÐ¾Ð²ÐµÑÐºÐ° Ð¾ÑÐ¼ÐµÐ½ÐµÐ½Ð° Ð°Ð²ÑÐ¾Ð¼Ð°ÑÐ¸ÑÐµÑÐºÐ¸ Ñ ÑÐ¾ÑÑÐ°Ð½ÐµÐ½Ð¸ÐµÐ¼ Ð¶Ð°Ð»Ð¾Ð±\nÐÑÐ¸ÑÐ¸Ð½Ð° : Ñ Ð¸Ð³ÑÐ¾ÐºÐ° Ð°ÐºÑÐ¸Ð²Ð½ÑÐ¹ ÐºÐ¾Ð¼Ð±Ð°Ñ-Ð±Ð»Ð¾Ðº",
                ["NOTIFY_MODERATOR_DUEL_PLAYER"] = "ÐÑÐ¾Ð²ÐµÑÐºÐ° Ð¾ÑÐ¼ÐµÐ½ÐµÐ½Ð° Ð°Ð²ÑÐ¾Ð¼Ð°ÑÐ¸ÑÐµÑÐºÐ¸ Ñ ÑÐ¾ÑÑÐ°Ð½ÐµÐ½Ð¸ÐµÐ¼ Ð¶Ð°Ð»Ð¾Ð±\nÐÑÐ¸ÑÐ¸Ð½Ð° : Ð¸Ð³ÑÐ¾Ðº Ð½Ð°ÑÐ¾Ð´Ð¸ÑÑÑ Ð½Ð° Ð´ÑÑÐ»Ð¸",
                ["NOTIFY_MODERATOR_FRIEND_PLAYER"] = "ÐÑÐ¾Ð²ÐµÑÐºÐ° Ð¾ÑÐ¼ÐµÐ½ÐµÐ½Ð° Ð°Ð²ÑÐ¾Ð¼Ð°ÑÐ¸ÑÐµÑÐºÐ¸ Ñ ÑÐ¾ÑÑÐ°Ð½ÐµÐ½Ð¸ÐµÐ¼ Ð¶Ð°Ð»Ð¾Ð±\nÐÑÐ¸ÑÐ¸Ð½Ð° : Ð¸Ð³ÑÐ¾Ðº ÑÐ²Ð»ÑÐµÑÑÑ Ð²Ð°ÑÐ¸Ð¼ ÑÐ¸Ð¼Ð¼ÐµÐ¹ÑÐ¾Ð¼",
                ["NOTIFY_MODERATOR_MAX_REPORT"] = "ÐÐ³ÑÐ¾Ðº {0} Ð¿ÑÐµÐ²ÑÑÐ¸Ð» ÐºÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ð¾ ÑÐµÐ¿Ð¾ÑÑÐ¾Ð², Ð²ÑÐ·Ð¾Ð²Ð¸ÑÐµ ÐµÐ³Ð¾ Ð½Ð° Ð¿ÑÐ¾Ð²ÐµÑÐºÑ!\nÐÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ð¾ ÑÐµÐ¿Ð¾ÑÑÐ¾Ð² : {1}",

            }, this, "ru");
        }

        void OnPlayerCommand(BasePlayer player, string command, string[] args)
        {
            if (!PlayerChecks.ContainsKey(player.userID)) return;

            if (config.CheckControllerSettings.TrackCommand)
            {
                BasePlayer Moderator = BasePlayer.FindByID(PlayerChecks[player.userID].ModeratorID);
                if (Moderat