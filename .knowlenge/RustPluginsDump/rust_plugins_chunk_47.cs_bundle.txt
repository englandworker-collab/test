or != null)
                    SendChat(GetLang("FUNCIONAL_MESSAGE_CHECK_AFK_PLAYER_SEND_COMMAND", Moderator.UserIDString, command), Moderator);
            }

            player.ResetInputIdleTime();
        }

        private void Unload()
        {
            WriteData();

            InterfaceBuilder.DestroyAll();
            ImageUi.Unload();

            if (config.CheckControllerSettings.UseSoundAlert)
            {
                if (RoutineSounds != null && RoutineSounds.Count != 0)
                {
                    foreach (KeyValuePair<BasePlayer, Coroutine> routineSound in RoutineSounds.Where(x => x.Value != null))
                        ServerMgr.Instance.StopCoroutine(routineSound.Value);
                }

                SpeakerEntityMgr.Shutdown();
            }

            if (AfkCheckRoutine != null && AfkCheckRoutine.Count != 0)
            {
                foreach (KeyValuePair<BasePlayer, Coroutine> coroutineList in AfkCheckRoutine.Where(x => x.Value != null))
                    ServerMgr.Instance.StopCoroutine(coroutineList.Value);

                AfkCheckRoutine.Clear();
                AfkCheckRoutine = null;
            }

            if (PlayerRepositories != null && PlayerRepositories.Count != 0)
            {
                PlayerRepositories.Clear();
                PlayerRepositories = null;
            }

            if (TimerWaitChecked != null && TimerWaitChecked.Count != 0)
            {
                foreach (Timer timer in TimerWaitChecked.Values.Where(t => !t.Destroyed))
                    timer.Destroy();

                TimerWaitChecked.Clear();
                TimerWaitChecked = null;
            }

            if (config.CheckControllerSettings.StopCheckLeavePlayer)
            {
                if (TimerWaitPlayer != null && TimerWaitPlayer.Count != 0)
                {
                    foreach (Timer timer in TimerWaitPlayer.Values.Where(t => !t.Destroyed))
                        timer.Destroy();

                    TimerWaitPlayer.Clear();
                    TimerWaitPlayer = null;
                }
            }

            _interface = null;
            _ = null;
        }



        private static StringBuilder sb = new StringBuilder();

        private void DrawUI_PlayerPanel(BasePlayer player, Int32 Page = 0, Boolean IsModerator = false, String SearchName = "")
        {
            String Interface = InterfaceBuilder.GetInterface($"{InterfaceBuilder.UI_LAYER}_PANEL_PLAYERS");
            if (Interface == null) return;

            Interface = Interface.Replace("%TITLE_PLAYER_LIST%", GetLang("TITLE_PLAYER_LIST", player.UserIDString));

            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_REPORT_PLAYER_PANEL);
            CuiHelper.AddUi(player, Interface);

            DrawUI_PageController(player, Page, IsModerator, SearchName);
        }



        private void SendReportPlayer(BasePlayer Sender, UInt64 TargetID, Int32 ReasonIndex)
        {
            CuiHelper.DestroyUi(Sender, "BLURED_POOP_UP");
            CuiHelper.DestroyUi(Sender, InterfaceBuilder.UI_REPORT_POOPUP_PLAYER);

            if (PlayerRepositories.ContainsKey(Sender.userID))
            {
                if (PlayerRepositories[Sender.userID].IsRepeatReported(TargetID))
                {
                    SendChat(GetLang("FUNCIONAL_NO_DUPLE_SEND_REPORT", Sender.UserIDString), Sender);
                    return;
                }

                if (PlayerRepositories[Sender.userID].IsCooldown(TargetID))
                {
                    SendChat(GetLang("FUNCIONAL_COOLDOWN_REPORT", Sender.UserIDString, PlayerRepositories[Sender.userID].GetCooldownLeft(TargetID)), Sender);
                    return;
                }
            }

            PlayerInformations[Sender.userID].SendReports++;

            PlayerInformations[TargetID].Reports++;

            Configuration.ReasonReport Reason = config.ReasonList.Where(reasonReport => !reasonReport.HideUser).ToList()[ReasonIndex];
            PlayerInformations[TargetID].ReasonHistory.Add(Reason.Title);

            GetPlayerCheckServerRCC(TargetID);
            GetPlayerCheckServerOzProtect(TargetID);

            BasePlayer Target = BasePlayer.FindByID(TargetID);
            if (Target != null)
                SendChat(GetLang("FUNCIONAL_SEND_REPORT_SUCCESS", Sender.UserIDString, Target.displayName), Sender);

            Configuration.NotifyDiscord.Webhooks.TemplatesNotify TemplateDiscord = config.NotifyDiscordSettings.WebhooksList.NotifySendReport;

            if (!String.IsNullOrWhiteSpace(TemplateDiscord.WebhookNotify))
            {
                List<Fields> fields = DT_PlayerSendReport(Sender, TargetID, LanguageEn ? Reason.Title.LanguageEN : Reason.Title.LanguageRU);
                SendDiscord(TemplateDiscord.WebhookNotify, fields, GetAuthorDiscord(TemplateDiscord), TemplateDiscord.Color);
            }

            SendVK(VKT_PlayerSendReport(Sender, TargetID, LanguageEn ? Reason.Title.LanguageEN : Reason.Title.LanguageRU));


            AddCooldown(Sender.userID, TargetID);

            if (PlayerInformations[TargetID].Reports >= config.ReportContollerModerationSettings.ReportCountTrigger && Target != null)
            {
                foreach (BasePlayer mList in BasePlayer.activePlayerList.Where(m => permission.UserHasPermission(m.UserIDString, ModeratorPermissions)))
                    AlertModerator(mList, Target.displayName, PlayerInformations[TargetID].Reports);

                AlertMaxReportDiscord(Target.displayName, PlayerInformations[TargetID].Reports, TargetID);
            }

            Interface.Call("OnSendedReport", Sender, TargetID, LanguageEn ? Reason.Title.LanguageEN : Reason.Title.LanguageRU);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();



        object OnPlayerChat(BasePlayer player, String message, Chat.ChatChannel channel)
        {
            if (!PlayerChecks.ContainsKey(player.userID)) return null;

            if (config.CheckControllerSettings.TrackChat)
            {
                BasePlayer Moderator = BasePlayer.FindByID(PlayerChecks[player.userID].ModeratorID);
                if (Moderator != null)
                    SendChat(GetLang("FUNCIONAL_MESSAGE_CHECK_AFK_PLAYER_SEND_CHAT", Moderator.UserIDString, message), Moderator);
            }

            player.ResetInputIdleTime();
            return null;
        }
        private List<byte[]> FromSaveData(byte[] bytes)
        {
            List<int> dataSize = new List<int>();
            List<byte[]> dataBytes = new List<byte[]>();

            int offset = 0;
            while (true)
            {
                dataSize.Add(BitConverter.ToInt32(bytes, offset));
                offset += 4;

                int sum = dataSize.Sum();
                if (sum == bytes.Length - offset)
                {
                    break;
                }

                if (sum > bytes.Length - offset)
                {
                    throw new ArgumentOutOfRangeException(nameof(dataSize),
                        $"Voice Data is outside the saved range {dataSize.Sum()} > {bytes.Length - offset}");
                }
            }

            foreach (int size in dataSize)
            {
                dataBytes.Add(bytes.Skip(offset).Take(size).ToArray());
                offset += size;
            }

            return dataBytes;
        }

        private List<String> GetServersCheckRCC(UInt64 TargetID)
        {
            if (String.IsNullOrWhiteSpace(config.ReferenceSettings.RCCSettings.RCCKey)) return null;
            return !RCC_LocalRepository.ContainsKey(TargetID) ? new List<String>() : RCC_LocalRepository[TargetID].LastChecksServers;
        }

        private String GetClanTag(String userID)
        {
            if (Clans)
                return (String)Clans.Call("GetClanOf", userID);
            else return null;
        }
        private void DrawUI_ShowPoopUP_Reason(BasePlayer player, String userID)
        {
            Int32 Y = 0;
            foreach (Configuration.ReasonReport reasonReport in config.ReasonList.Where(reasonReport => !reasonReport.HideUser).Take(4))
            {
                String Interface = InterfaceBuilder.GetInterface($"{InterfaceBuilder.UI_LAYER}_TEMPLATE_POOPUP_REASON");
                if (Interface == null) return;

                Interface = Interface.Replace("%OFFSET_MIN%", $"-154.667 {25 - (Y * 63)}");
                Interface = Interface.Replace("%OFFSET_MAX%", $"154.667 {83 - (Y * 63)}");
                Interface = Interface.Replace("%REASON%", reasonReport.Title.GetReasonTitle(player.userID));
                Interface = Interface.Replace("%POOPUP_REASON%", ImageUi.GetImage(config.ImagesSettings.PlayerListBlockSettings.PoopUpReasonBackgorund));
                Interface = Interface.Replace("%COMMAND%", $"report.panel send.player.report {userID} {Y}");

                CuiHelper.AddUi(player, Interface);

                Y++;
            }
        }

        private void RegisteredPlayer(BasePlayer player)
        {
            if (!PlayerInformations.ContainsKey(player.userID))
                PlayerInformations.Add(player.userID, new PlayerInformation());

            if (IsModerator(player))
            {
                if (!ModeratorInformations.ContainsKey(player.userID))
                    ModeratorInformations.Add(player.userID, new ModeratorInformation());
            }
            else
            {
                if (ModeratorInformations.ContainsKey(player.userID))
                    ModeratorInformations.Remove(player.userID);
            }
        }
        private void DrawUI_Moderator_Button(BasePlayer moderator, String Command = "")
        {
            String Interface = InterfaceBuilder.GetInterface($"{InterfaceBuilder.UI_LAYER}_MODERATOR_MENU_CHECKED_BUTTON_VERDICT");
            if (Interface == null) return;

            Interface = Interface.Replace("%TITLE_PROFILE_MODERATOR_CHECKED_MENU_TITLE_BUTTON_RESULT%", GetLang("TITLE_PROFILE_MODERATOR_CHECKED_MENU_TITLE_BUTTON_RESULT", moderator.UserIDString));
            Interface = Interface.Replace("%COMMAND_VERDICT%", Command);

            CuiHelper.DestroyUi(moderator, "ButtonVerdictCheck");
            CuiHelper.AddUi(moderator, Interface);
        }



        private void SendVerdictPlayer(UInt64 TargetID, BasePlayer Moderator, Configuration.ReasonReport Verdict)
        {
            Unsubscribe("OnPlayerBanned");
            Unsubscribe("OnPlayerDisconnected");

            String VerdictReason = Verdict.Title.GetReasonTitle(TargetID);

            BasePlayer Target = BasePlayer.FindByID(TargetID);
            if (Target != null)
            {
                if (config.VerdictControllerSettings.UseBanAllTeam)
                {
                    if (Target.Team.members.Count >= 1)
                    {
                        if (config.ReasonList.Count >= config.VerdictControllerSettings.IndexBanReason)
                        {
                            Configuration.ReasonReport ReasonTeamBan = config.ReasonList[config.VerdictControllerSettings.IndexBanReason];
                            foreach (UInt64 TeamMembersIDS in Target.Team.members.Where(x => x != TargetID))
                            {
                                String VerdictReasonTeam = Verdict.Title.GetReasonTitle(TeamMembersIDS);
                                Server.Command(String.Format(ReasonTeamBan.BanCommand, TeamMembersIDS, VerdictReasonTeam));
                                BasePlayer TargetTeam = BasePlayer.FindByID(TeamMembersIDS);
                                if (TargetTeam != null)
                                    TargetTeam.Kick(VerdictReasonTeam);
                            }
                        }
                    }
                }
            }

            Server.Command(String.Format(Verdict.BanCommand, TargetID, VerdictReason));
            if (Target != null)
                Target.Kick(VerdictReason);

            StopDamageRemove(TargetID);

            BanPlayerRCC(TargetID, VerdictReason);
            BanPlayerOzProtect(TargetID, Moderator == null ? 0 : Moderator.userID, VerdictReason);

            if (Moderator != null)
            {
                SendChat(GetLang("FUNCIONAL_MODERATOR_VERDICT_RESULT", Moderator.UserIDString, Verdict.Title.GetReasonTitle(TargetID)), Moderator);

                CuiHelper.DestroyUi(Moderator, InterfaceBuilder.UI_REPORT_MODERATOR_MENU_CHECKED);
                ModeratorInformations[Moderator.userID].AmountChecked++;
                PlayerInformations[TargetID].LastModerator = Moderator.displayName;
            }

            if (config.NotifyChatSettings.UseNotifyVerdictCheck)
            {
                if (Moderator != null)
                {
                    foreach (BasePlayer player in BasePlayer.activePlayerList)
                        SendChat(GetLang("NOTIFY_PLAYERS_STOP_CHECK_VERDICT_MODERATOR", player.UserIDString, Moderator.displayName, PlayerChecks[TargetID].DisplayName, VerdictReason), player);
                }
                else
                {
                    foreach (BasePlayer player in BasePlayer.activePlayerList)
                        SendChat(GetLang("NOTIFY_PLAYERS_STOP_CHECK_NOT_MODERATOR", player.UserIDString, PlayerChecks[TargetID].DisplayName, VerdictReason), player);
                }
            }

            Configuration.NotifyDiscord.Webhooks.TemplatesNotify TemplateDiscord = config.NotifyDiscordSettings.WebhooksList.NotifyStopCheck;

            if (!String.IsNullOrWhiteSpace(TemplateDiscord.WebhookNotify))
            {
                List<Fields> fields = DT_StopCheck(TargetID, Moderator, Verdict: Verdict);
                SendDiscord(TemplateDiscord.WebhookNotify, fields, GetAuthorDiscord(TemplateDiscord), TemplateDiscord.Color);
            }

            SendVK(VKT_StopCheck(TargetID, Moderator, Verdict: Verdict));

            if (PlayerChecks.ContainsKey(TargetID))
                PlayerChecks.Remove(TargetID);

            Interface.Call("OnVerdictChecked", TargetID, Moderator, VerdictReason, Verdict.BanCommand);

            Subscribe("OnPlayerBanned");
            Subscribe("OnPlayerDisconnected");
        }
        private void AlertModerator(BasePlayer Moderator, String PlayerName, Int32 ReportCount)
        {
            if (!config.ReportContollerModerationSettings.AlertModerationSettings.AlertModerator) return;
            SendChat(GetLang("NOTIFY_MODERATOR_MAX_REPORT", Moderator.UserIDString, PlayerName, ReportCount), Moderator);

            RunEffect(Moderator);
        }
        private List<Fields> DT_PlayerMaxReport(String PlayerName, Int32 Reports, UInt64 TargetID)
        {
            List<Fields> fields = new List<Fields>
            {
                new Fields(LanguageEn ? "Information about the suspect :" : "Информация о подозреваемом :", "", false),
                new Fields("", "", false),
                new Fields(LanguageEn ? "Nick" : "Ник", $"{PlayerName}", true),
                new Fields("Steam64ID", $"[{TargetID}](https://steamcommunity.com/profiles/{TargetID})", true),
                new Fields(LanguageEn ? "Count reports" : "Количество репортов", $"{Reports}", true),
            };

            return fields;
        }

        internal class LocalRepositoryRCC
        {
            public List<String> LastChecksServers = new List<String>();
            public List<String> LastBansServers = new List<String>();
        }



        private void StopCheckedPlayer(UInt64 TargetID, BasePlayer Moderator, Boolean AutoStop = false, Boolean IsConsole = false)
        {
            if (!PlayerChecks.ContainsKey(TargetID)) return;
            StopDamageRemove(TargetID);

            BasePlayer Target = BasePlayer.FindByID(TargetID);

            if (Target != null)
            {
                if (config.CheckControllerSettings.UseDemo)
                    Target.StopDemoRecording();

                if (!AutoStop)
                    DrawUI_Raiting_Menu_Player(Target, PlayerChecks[TargetID].ModeratorID);
                CuiHelper.DestroyUi(Target, InterfaceBuilder.UI_REPORT_PLAYER_ALERT);

                if (AfkCheckRoutine.ContainsKey(Target))
                {
                    if (AfkCheckRoutine[Target] != null)
                    {
                        ServerMgr.Instance.StopCoroutine(AfkCheckRoutine[Target]);
                        AfkCheckRoutine[Target] = null;
                    }

                    AfkCheckRoutine.Remove(Target);
                }
            }

            if (!IsConsole)
            {
                if (Moderator != null)
                {
                    CuiHelper.DestroyUi(Moderator, InterfaceBuilder.UI_REPORT_MODERATOR_MENU_CHECKED);
                    ModeratorInformations[Moderator.userID].AmountChecked++;
                    PlayerInformations[TargetID].LastModerator = Moderator.displayName;
                }
            }
            else Puts(LanguageEn ? "Player checked completed" : "Проверка игрока завершена");

            if (!AutoStop)
            {
                if (config.NotifyChatSettings.UseNotifyStopCheck)
                {
                    if (Moderator != null || !IsConsole)
                    {
                        foreach (BasePlayer player in BasePlayer.activePlayerList)
                            SendChat(GetLang("NOTIFY_PLAYERS_STOP_CHECK_MODERATOR", player.UserIDString, Moderator.displayName, PlayerChecks[TargetID].DisplayName), player);
                    }
                    else
                    {
                        foreach (BasePlayer player in BasePlayer.activePlayerList)
                            SendChat(GetLang("NOTIFY_PLAYERS_STOP_CHECK_NOT_MODERATOR", player.UserIDString, PlayerChecks[TargetID].DisplayName), player);
                    }
                }

                PlayerInformations[TargetID].AmountChecked++;
                PlayerInformations[TargetID].Reports = 0;
            }

            Configuration.NotifyDiscord.Webhooks.TemplatesNotify TemplateDiscord = config.NotifyDiscordSettings.WebhooksList.NotifyStopCheck;

            if (!String.IsNullOrWhiteSpace(TemplateDiscord.WebhookNotify))
            {
                List<Fields> fields = DT_StopCheck(TargetID, Moderator, AutoStop, IsConsole);
                SendDiscord(TemplateDiscord.WebhookNotify, fields, GetAuthorDiscord(TemplateDiscord), TemplateDiscord.Color);
            }

            SendVK(VKT_StopCheck(TargetID, Moderator, AutoStop, IsConsole));


            if (PlayerChecks.ContainsKey(TargetID))
                PlayerChecks.Remove(TargetID);

            Interface.Call("OnStoppedChecked", Target, Moderator, AutoStop, IsConsole);
        }

        public class NpcSound
        {
            [JsonConverter(typeof(SoundFileConverter))]
            public List<byte[]> Data = new List<byte[]>();
        }

        private Boolean IsClansSendReport(String userID, String targetID) => config.ReferenceSettings.ClansSetting.SendReportClan && IsClans(userID, targetID);

        private void DrawUI_Raiting_Menu_Stars(BasePlayer player, Int32 SelectedAmount, UInt64 ModeratorID)
        {
            for (Int32 X = 0; X < 5; X++)
            {
                String Interface =
                    InterfaceBuilder.GetInterface($"{InterfaceBuilder.UI_LAYER}_RAITING_MENU_PLAYER_STARS");
                if (Interface == null) return;

                Interface = Interface.Replace("%OFFSET_MIN%", $"{-88.247 + (X * 15)} -22");
                Interface = Interface.Replace("%OFFSET_MAX%", $"{-77.58 + (X * 15)} -12");
                Interface = Interface.Replace("%COLOR_STARS%", SelectedAmount >= X ? "1 1 1 1" : "1 1 1 0.5");
                Interface = Interface.Replace("%COMMAND_STARS%", SelectedAmount >= 0 ? "" : $"report.panel select.raiting.star {X} {ModeratorID}");

                CuiHelper.AddUi(player, Interface);
            }
        }


        private String GetImage(String fileName, UInt64 skin = 0)
        {
            var imageId = (String)plugins.Find("ImageLibrary").CallHook("GetImage", fileName, skin);
            if (!string.IsNullOrEmpty(imageId))
                return imageId;
            return String.Empty;
        }
        private List<Fields> DT_PlayerSendContact(BasePlayer Sender, String Contact)
        {
            List<Fields> fields = new List<Fields>
            {
                new Fields(LanguageEn ? "Information about the sender :" : "Информация об отправителе :", "", false),
                new Fields("", "", false),
                new Fields(LanguageEn ? "Nick" : "Ник", $"{Sender.displayName}", true),
                new Fields("Steam64ID", $"[{Sender.userID}](https://steamcommunity.com/profiles/{Sender.userID})", true),
                new Fields(LanguageEn ? "Contacts for communication :" : "Контакты для связи :", Contact, false),
            };

            return fields;
        }

        private List<String> GetTeamsNames(BasePlayer Target)
        {
            List<String> TeamsName = new List<String>();

            if (Target.Team == null)
                return TeamsName;

            foreach (UInt64 teamMember in Target.Team.members)
            {
                IPlayer TeamPlayer = covalence.Players.FindPlayerById(teamMember.ToString());
                TeamsName.Add(TeamPlayer.Name);
            }

            return TeamsName;
        }
        private class InterfaceBuilder
        {

            public static InterfaceBuilder Instance;

            public const String UI_LAYER = "UI_IQREPORT_INTERFACE";

            public const String UI_REPORT_PANEL = "UI_REPORT_PANEL";
            public const String UI_REPORT_LEFT_PANEL = "UI_REPORT_LEFT_PANEL";
            public const String UI_REPORT_PLAYER_PANEL = "UI_REPORT_PLAYER_PANEL";
            public const String UI_REPORT_POOPUP_PLAYER = "UI_REPORT_POOPUP_PLAYER";
            public const String UI_REPORT_POOPUP_MODERATOR = "UI_REPORT_POOPUP_MODERATOR";
            public const String UI_REPORT_MODERATOR_STATISTICS = "UI_REPORT_MODERATOR_STATISTICS";
            public const String UI_REPORT_MODERATOR_MENU_CHECKED = "UI_REPORT_MODERATOR_MENU_CHECKED";
            public const String UI_REPORT_RAITING_PLAYER_PANEL = "UI_REPORT_RAITING_PLAYER_PANEL";
            public const String UI_REPORT_PLAYER_ALERT = "UI_REPORT_PLAYER_ALERT";

            public Dictionary<String, String> Interfaces;



            public InterfaceBuilder()
            {
                Instance = this;
                Interfaces = new Dictionary<String, String>();

                Building_Bacgkround();

                Building_Panel_Players();
                Building_PageController();
                Building_PlayerTemplate();
                Building_PoopUp_Player();
                Building_PoopUp_Reason();

                Building_PlayerTemplate_Moderator();
                Building_Left_Menu();
                Building_Button_Template();
                Building_PoopUP_Moderator();
                Building_PoopUP_Moderator_InfoBlock();
                Building_Text_Template_Moderator_Block_Info();

                Building_HeaderPanel_Search();

                Building_Profile_Moderator_Stats();
                Building_Profile_Template_Banner();
                Building_Profile_Template_Banner_AdditionalImg();
                Building_Profile_Template_Banner_AdditionalText();

                Building_Moderator_Menu();
                Building_ModeratorMenuChecked_InfoDiscord();
                Building_ModeratorMenuChecked_InfoOnline();
                Building_ModeratorMenu_Verdict_Button();

                Building_Raiting_Menu();
                Building_Raiting_Select_Button();

                Building_DropList_Reasons();

                Building_Player_Alert();

                Building_PlayerTemplate_Moderator_IsSteam();
            }

            public static void AddInterface(String name, String json)
            {
                if (Instance.Interfaces.ContainsKey(name))
                {
                    _.PrintError($"Error! Tried to add existing cui elements! -> {name}");
                    return;
                }

                Instance.Interfaces.Add(name, json);
            }

            public static String GetInterface(String name)
            {
                String json = String.Empty;
                if (Instance.Interfaces.TryGetValue(name, out json) == false)
                {
                    _.PrintWarning($"Warning! UI elements not found by name! -> {name}");
                }

                return json;
            }

            public static void DestroyAll()
            {
                for (Int32 i = 0; i < BasePlayer.activePlayerList.Count; i++)
                {
                    BasePlayer player = BasePlayer.activePlayerList[i];
                    CuiHelper.DestroyUi(player, UI_REPORT_PANEL);
                    CuiHelper.DestroyUi(player, UI_REPORT_MODERATOR_MENU_CHECKED);
                    CuiHelper.DestroyUi(player, UI_REPORT_RAITING_PLAYER_PANEL);
                    CuiHelper.DestroyUi(player, UI_REPORT_PLAYER_ALERT);
                }
            }



            private void Building_Bacgkround()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    Image = { Color = "0 0 0 0" },
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-459.836 -316.661", OffsetMax = "461.497 316.672" }
                }, "Overlay", UI_REPORT_PANEL);

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "-100 -100", AnchorMax = "100 100" },
                    Button = { Close = UI_REPORT_PANEL, Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, UI_REPORT_PANEL);

                container.Add(new CuiElement
                {
                    Name = "PNG_BACKGORUND",
                    Parent = UI_REPORT_PANEL,
                    Components = {
                        new CuiRawImageComponent { Color = config.ColorsSettings.MainColor, Png = ImageUi.GetImage(config.ImagesSettings.Background) },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "TitleUi",
                    Parent = UI_REPORT_PANEL,
                    Components = {
                        new CuiTextComponent { Text = "%TITLE_NAME_REPORT_SYSTEM%", Font = "robotocondensed-regular.ttf", FontSize = 18, Align = TextAnchor.MiddleCenter, Color = config.ColorsSettings.MainColorText },
                        new CuiRectTransformComponent { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "38.729 242.115", OffsetMax = "180.962 276.152" }
                    }
                });


                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = "0 0 0 0" },
                    RectTransform = { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-265.273 -93.21", OffsetMax = "224.909 -28.371" }
                }, UI_REPORT_PANEL, "HeaderUI");

                container.Add(new CuiElement
                {
                    Name = "HeaderActionTitle",
                    Parent = "HeaderUI",
                    Components = {
                        new CuiTextComponent { Text = "%TITLE_PLAYER_HEADER_TITLE_SEND_REPORT%", Font = "robotocondensed-regular.ttf", FontSize = 18, Align = TextAnchor.UpperLeft, Color = config.ColorsSettings.MainColorText },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-219.38 -21.383", OffsetMax = "-33.953 4.111" }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "HeaderActionDescription",
                    Parent = "HeaderUI",
                    Components = {
                        new CuiTextComponent { Text = "%TITLE_PLAYER_HEADER_TITLE_DESC_SEND_REPORT%", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.UpperLeft, Color = config.ColorsSettings.AdditionalColorText },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-219.382 0", OffsetMax = "-78.111 19.541" }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "HeaderSearchIcon",
                    Parent = "HeaderUI",
                    Components = {
                        new CuiRawImageComponent { Color = config.ColorsSettings.MainColorText, Png = ImageUi.GetImage(config.ImagesSettings.Search)},
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "136.333 -6.555", OffsetMax = "147 4.111" }
                    }
                });



                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = "0 0 0 0" },
                    RectTransform = { AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "-235.758 -288.171", OffsetMax = "-28.338 288.296" }
                }, UI_REPORT_PANEL, "ProfilePanel");

                container.Add(new CuiElement
                {
                    Name = "AvatarUser",
                    Parent = "ProfilePanel",
                    Components = {
                        new CuiRawImageComponent { Color = "1 1 1 1", Png = "%AVATAR_PLAYER%"},
                        new CuiRectTransformComponent { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-66.328 -51.299", OffsetMax = "-23.661 -8.632" }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "CircleBlock",
                    Parent = "AvatarUser",
                    Components = {
                        new CuiRawImageComponent { Color = config.ColorsSettings.MainColor, Png = ImageUi.GetImage(config.ImagesSettings.AvatarBlur)},
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1"}
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "Nick",
                    Parent = "ProfilePanel",
                    Components = {
                        new CuiTextComponent { Text = "%NICK_PROFILE%", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.UpperLeft, Color = config.ColorsSettings.MainColorText },
                        new CuiRectTransformComponent { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-19.057 -34.221", OffsetMax = "82.475 -15.099" }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "CheckedCount",
                    Parent = "ProfilePanel",
                    Components = {
                        new CuiTextComponent { Text = "%TITLE_PROFILE_INFO_CHECKED%", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.UpperLeft, Color = config.ColorsSettings.AdditionalColorText },
                        new CuiRectTransformComponent { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-19.057 -45.295", OffsetMax = "75.057 -29.372" }
                    }
                });



                container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Close = UI_REPORT_PANEL },
                    Text = { Text = "%TITLE_CLOSE_BUTTON_REPORT%", Font = "robotocondensed-regular.ttf", FontSize = 17, Align = TextAnchor.MiddleCenter, Color = config.ColorsSettings.MainColorText },
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "405.267 265.067", OffsetMax = "426.6 286.4" }
                }, UI_REPORT_PANEL, "CloseReportPanel");

                AddInterface($"{UI_LAYER}_BACKGORUND", container.ToJson());
            }

            private void Building_HeaderPanel_Search()
            {
                CuiElementContainer container = new CuiElementContainer();

                String NickName = "";
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "152.257 -9.983", OffsetMax = "245.09 7.539" },
                    Image = { Color = "0 0 0 0" }
                }, "HeaderUI", "InputPanelSearch" + ".Input");

                container.Add(new CuiElement
                {
                    Parent = "InputPanelSearch" + ".Input",
                    Name = "InputPanelSearch" + ".Input.Current",
                    Components =
                    {
                        new CuiInputFieldComponent { Text = "%TITLE_PLAYER_HEADER_TITLE_SEARCH_PLAYER%", FontSize = 14, Command = $"report.panel search.player %ISMODERATOR% {NickName}", Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft, Color = config.ColorsSettings.AdditionalColorText, CharsLimit = 13, NeedsKeyboard = true},
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                    }
                });

                AddInterface($"{UI_LAYER}_SEARCH_HEADER", container.ToJson());
            }


            private void Building_Profile_Moderator_Stats()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = "0 0 0 0" },
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-103.71 -288.233", OffsetMax = "103.71 224.667" }
                }, "ProfilePanel", UI_REPORT_MODERATOR_STATISTICS);

                container.Add(new CuiElement
                {
                    Name = "TitleStatistics",
                    Parent = UI_REPORT_MODERATOR_STATISTICS,
                    Components = {
                        new CuiTextComponent { Text = "%TITLE_PROFILE_MODERATOR_STATISTICS_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 18, Align = TextAnchor.UpperLeft, Color = config.ColorsSettings.MainColorText },
                        new CuiRectTransformComponent { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-93.211 -40.281", OffsetMax = "91.72 -13.052" }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "TitleRaiting",
                    Parent = UI_REPORT_MODERATOR_STATISTICS,
                    Components = {
                        new CuiTextComponent { Text = "%TITLE_PROFILE_MODERATOR_STATISTICS_TITLE_QUALITY_ASSESSMENT%", Font = "robotocondensed-regular.ttf", FontSize = 18, Align = TextAnchor.UpperLeft, Color = config.ColorsSettings.MainColorText },
                        new CuiRectTransformComponent { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-93.211 -210.095", OffsetMax = "91.72 -182.865" }
                    }
                });

                AddInterface($"{UI_LAYER}_PROFILE_MODERATION_INFO_PANEL", container.ToJson());
            }

            private void Building_Profile_Template_Banner()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "CheckedPanel",
                    Parent = UI_REPORT_MODERATOR_STATISTICS,
                    Components = {
                        new CuiRawImageComponent { Color = config.ColorsSettings.AdditionalColorElements, Png = ImageUi.GetImage(config.ImagesSettings.StatisticsBlockSettings.BlockStatsModeration) },
                        new CuiRectTransformComponent { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "%OFFSET_MIN%", OffsetMax = "%OFFSET_MAX%"}
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "TitleChecked",
                    Parent = "CheckedPanel",
                    Components = {
                        new CuiTextComponent { Text = "%TITLE_BANNER%", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.UpperLeft, Color = config.ColorsSettings.MainColorText },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-61.855 -4.697", OffsetMax = "28.225 13.377" }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "CountPanelChecked",
                    Parent = "CheckedPanel",
                    Components = {
                        new CuiRawImageComponent { Color = config.ColorsSettings.AdditionalColorElementsTwo, Png = ImageUi.GetImage(config.ImagesSettings.StatisticsBlockSettings.BlockStatsRaitingModeration) },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "33.733 -9.333", OffsetMax = "77.067 9.333"}
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "CountInfoChecked",
                    Parent = "CountPanelChecked",
                    Components = {
                        new CuiTextComponent { Text = "%ARGS_BANNER%", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = config.ColorsSettings.MainColorText },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-21.667 -9.333", OffsetMax = "21.667 9.333" }
                    }
                });

                AddInterface($"{UI_LAYER}_PROFILE_BANNER_TEMPLATE", container.ToJson());
            }

            private void Building_Profile_Template_Banner_AdditionalText()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "TitleCheckedAllTime",
                    Parent = "CheckedPanel",
                    Components = {
                        new CuiTextComponent { Text = "%ADDITIONAL_TEXT%", Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.LowerLeft, Color = config.ColorsSettings.AdditionalColorText },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-61.853 -13.21", OffsetMax = "28.224 2.408" }
                    }
                });

                AddInterface($"{UI_LAYER}_PROFILE_BANNER_TEMPLATE_ADDITIONAL_TEXT", container.ToJson());
            }

            private void Building_Profile_Template_Banner_AdditionalImg()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "RateImageOne",
                    Parent = "CheckedPanel",
                    Components = {
                        new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage(config.ImagesSettings.StatisticsBlockSettings.RaitingImage) },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "%OFFSET_MIN%", OffsetMax = "%OFFSET_MAX%" }
                    }
                });

                AddInterface($"{UI_LAYER}_PROFILE_BANNER_TEMPLATE_ADDITIONAL_IMG", container.ToJson());
            }




            private void Building_Panel_Players()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = "0.8 0 0 0" },
                    RectTransform =
                    {
                        AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-265.271 -288.173",
                        OffsetMax = "224.909 223.454"
                    }
                }, UI_REPORT_PANEL, UI_REPORT_PLAYER_PANEL);

                container.Add(new CuiElement
                {
                    Name = "ActionSearch",
                    Parent = UI_REPORT_PLAYER_PANEL,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = "%TITLE_PLAYER_LIST%", Font = "robotocondensed-regular.ttf", FontSize = 18,
                            Align = TextAnchor.UpperLeft, Color = config.ColorsSettings.MainColorText
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-219.215 212.58", OffsetMax = "56.36 244.753"
                        }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "ActionPageNext",
                    Parent = UI_REPORT_PLAYER_PANEL,
                    Components =
                    {
                        new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage(config.ImagesSettings.PageUp)},
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "170.993 231.02",
                            OffsetMax = "177.66 234.353"
                        }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "ActionPageBack",
                    Parent = UI_REPORT_PLAYER_PANEL,
                    Components =
                    {
                        new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage(config.ImagesSettings.PageDown) },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "210.38 231.02",
                            OffsetMax = "217.047 234.353"
                        }
                    }
                });

                AddInterface($"{UI_LAYER}_PANEL_PLAYERS", container.ToJson());
            }

            private void Building_PageController()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "ActionPageCount",
                    Parent = UI_REPORT_PLAYER_PANEL,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = "%AMOUNT_PAGE%", Font = "robotocondensed-regular.ttf", FontSize = 14,
                            Align = TextAnchor.MiddleCenter, Color = config.ColorsSettings.MainColorText
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "177.659 224.774", OffsetMax = "210.381 242.86"
                        }
                    }
                });

                container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = "%COMMAND_PAGE_NEXT%" },
                    Text = { Text = "", Font = "robotocondensed-regular.ttf", FontSize = 40, Align = TextAnchor.MiddleCenter, Color = "0 0 0 0" },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" }
                }, "ActionPageNext", "ButtonNextPage");

                container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = "%COMMAND_PAGE_BACK%" },
                    Text = { Text = "", Font = "robotocondensed-regular.ttf", FontSize = 40, Align = TextAnchor.MiddleCenter, Color = "0 0 0 0" },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" }
                }, "ActionPageBack", "ButtonBackPage");

                AddInterface($"{UI_LAYER}_PANEL_PLAYERS_PAGE_CONTROLLER", container.ToJson());
            }



            private void Building_PlayerTemplate()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = "0 0 0 0" },
                    RectTransform =
                    {
                        AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "%OFFSET_MIN%", OffsetMax = "%OFFSET_MAX%"
                    }
                }, UI_REPORT_PLAYER_PANEL, "PlayerPanel");

                container.Add(new CuiElement
                {
                    Name = "AvatarPlayer",
                    Parent = "PlayerPanel",
                    Components =
                    {
                        new CuiRawImageComponent { Color = "1 1 1 1", Png = "%STEAMID%"},
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-64.621 -18", OffsetMax = "-28.621 18"
                        }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "BlurAvatar",
                    Parent = "AvatarPlayer",
                    Components =
                    {
                        new CuiRawImageComponent { Color = config.ColorsSettings.MainColor, Png = ImageUi.GetImage(config.ImagesSettings.AvatarBlur)},
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0", AnchorMax = "1 1"
                        }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "NickName",
                    Parent = "PlayerPanel",
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = "%NICK%", Font = "robotocondensed-regular.ttf", FontSize = 16,
                            Align = TextAnchor.MiddleLeft, Color = config.ColorsSettings.MainColorText
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-25.326 -2.931", OffsetMax = "64.621 18"
                        }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "NickNameTitle",
                    Parent = "PlayerPanel",
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = "%TITLE_PLAYER_NICK_NAME%", Font = "robotocondensed-regular.ttf", FontSize = 16,
                            Align = TextAnchor.LowerLeft, Color = config.ColorsSettings.AdditionalColorText
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-25.326 -18", OffsetMax = "64.621 3.419"

                        }
                    }
                });

                container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = "%COMMAND%" },
                    Text = { Text = "", Font = "robotocondensed-regular.ttf", FontSize = 40, Align = TextAnchor.MiddleCenter, Color = "0 0 0 0" },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" }
                }, "PlayerPanel", "SelectUserForReport");

                AddInterface($"{UI_LAYER}_TEMPLATE_PLAYER", container.ToJson());
            }



            private void Building_PoopUp_Player()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    Image = { Color = "0 0 0 0.3", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-432.189 -288.171", OffsetMax = "432.345 288.295" }
                }, UI_REPORT_PANEL, "BLURED_POOP_UP");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Close = "UI_REPORT_PANEL_CLOSE", Command = "report.panel close.poopup", Color = "0 0 0 0" },
                    Text = { Text = "", Font = "robotocondensed-regular.ttf", FontSize = 13, Align = TextAnchor.MiddleCenter, Color = "0 0 0 0" }
                }, "BLURED_POOP_UP", "UI_REPORT_PANEL_CLOSE");

                container.Add(new CuiElement
                {
                    Name = UI_REPORT_POOPUP_PLAYER,
                    Parent = UI_REPORT_PANEL,
                    Components =
                    {
                        new CuiRawImageComponent { Color = config.ColorsSettings.MainColor, Png = "%POOPUP_BACKGORUND%" },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-188.596 -199.069", OffsetMax = "189.404 200.264"
                        }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "PoopUpAvatar",
                    Parent = UI_REPORT_POOPUP_PLAYER,
                    Components =
                    {
                        new CuiRawImageComponent { Color = "1 1 1 1", Png = "%AVATAR%"},
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-152.467 113.8",
                            OffsetMax = "-109.8 156.467"
                        }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "PoopUpCircle",
                    Parent = "PoopUpAvatar",
                    Components =
                    {
                        new CuiRawImageComponent { Color = config.ColorsSettings.MainColor, Png = ImageUi.GetImage(config.ImagesSettings.AvatarBlur) },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-21.333 -21.333",
                            OffsetMax = "21.333 21.333"
                        }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "PoopUpNickTitle",
                    Parent = UI_REPORT_POOPUP_PLAYER,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = "%TITLE_PLAYER_NICK_NAME%", Font = "robotocondensed-regular.ttf", FontSize = 14,
                            Align = TextAnchor.MiddleLeft, Color = config.ColorsSettings.AdditionalColorText
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-100.512 119.715", OffsetMax = "-25.968 138.818"
                        }
                    }
                });

                container.Add(new CuiElement
                {
                    Parent = UI_REPORT_POOPUP_PLAYER,
                    Name = "PoopUpNickName",
                    Components =
                    {
                        new CuiInputFieldComponent {  Text = "%NICK_NAME%", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleLeft, Color = config.ColorsSettings.MainColorText, NeedsKeyboard = true, LineType = InputField.LineType.SingleLine, ReadOnly = true},
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-100.511 132.242", OffsetMax = "-13.007 154.291" }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "PoopUpSteamIDTitle",
                    Parent = UI_REPORT_POOPUP_PLAYER,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = "%TITLE_PLAYER_STEAMID%", Font = "robotocondensed-regular.ttf", FontSize = 14,
                            Align = TextAnchor.MiddleLeft, Color = config.ColorsSettings.AdditionalColorText
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "34.94 119.715", OffsetMax = "155.553 138.816"
                        }
                    }
                });

                container.Add(new CuiElement
                {
                    Parent = UI_REPORT_POOPUP_PLAYER,
                    Name = "PoopUpSteamID",
                    Components =
                    {
                        new CuiInputFieldComponent {  Text = "%STEAMID%", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleLeft, Color = config.ColorsSettings.MainColorText, NeedsKeyboard = true, LineType = InputField.LineType.SingleLine, ReadOnly = true},
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "34.938 132.242", OffsetMax = "155.545 154.291" }
                    }
                });

                AddInterface($"{UI_LAYER}_TEMPLATE_POOPUP", container.ToJson());
            }

            private void Building_PoopUp_Reason()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "PoopUpReason",
                    Parent = UI_REPORT_POOPUP_PLAYER,
                    Components =
                    {
                        new CuiRawImageComponent { Color = config.ColorsSettings.AdditionalColorElements, Png = "%POOPUP_REASON%" },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "%OFFSET_MIN%", OffsetMax = "%OFFSET_MAX%"
                        }
                    }
                });

                container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = "%COMMAND%" },
                    Text = { Text = "%REASON%", Font = "robotocondensed-regular.ttf", FontSize = 16, Align = TextAnchor.MiddleCenter, Color = config.ColorsSettings.MainColorText },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" }
                }, "PoopUpReason", "ReasonButton");

                AddInterface($"{UI_LAYER}_TEMPLATE_POOPUP_REASON", container.ToJson());
            }


            private void Building_PlayerTemplate_Moderator()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = "0 0 0 0" },
                    RectTransform =
                    {
                        AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "%OFFSET_MIN%", OffsetMax = "%OFFSET_MAX%"
                    }
                }, UI_REPORT_PLAYER_PANEL, "PlayerPanel_Moderator");

                container.Add(new CuiElement
                {
                    Name = "AvatarPlayer",
                    Parent = "PlayerPanel_Moderator",
                    Components =
                    {
                        new CuiRawImageComponent { Color = "1 1 1 1", Png = "%AVATAR%"},
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-219.213 -18",
                            OffsetMax = "-183.213 18"
                        }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "PoopUpCircle",
                    Parent = "AvatarPlayer",
                    Components =
                    {
                        new CuiRawImageComponent { Color = config.ColorsSettings.MainColor, Png = ImageUi.GetImage(config.ImagesSettings.AvatarBlur) },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0", AnchorMax = "1 1"
                        }
                    }
                });


                container.Add(new CuiElement
                {
                    Name = "NickName",
                    Parent = "PlayerPanel_Moderator",
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = "%NAME%", Font = "robotocondensed-regular.ttf", FontSize = 15,
                            Align = TextAnchor.MiddleLeft, Color = config.ColorsSettings.MainColorText
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-180.04 -2.931",
                            OffsetMax = "-99.628 18"
                        }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "NickNameTitle",
                    Parent = "PlayerPanel_Moderator",
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = "%TITLE_PLAYER_NICK_NAME%", Font = "robotocondensed-regular.ttf", FontSize = 16,
                            Align = TextAnchor.LowerLeft, Color = config.ColorsSettings.AdditionalColorText
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-180.04 -18",
                            OffsetMax = "-90.093 3.419"
                        }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "SteamIDPlayer",
                    Parent = "PlayerPanel_Moderator",
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = "%STEAMID%", Font = "robotocondensed-regular.ttf", FontSize = 15,
                            Align = TextAnchor.MiddleLeft, Color = config.ColorsSettings.MainColorText
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-29.44 -2.931",
                            OffsetMax = "96.628 18"
                        }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "SteamIDTitle",
                    Parent = "PlayerPanel_Moderator",
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = "%TITLE_PLAYER_STEAMID%", Font = "robotocondensed-regular.ttf", FontSize = 15,
                            Align = TextAnchor.LowerLeft, Color = config.ColorsSettings.AdditionalColorText
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-29.439 -18",
                            OffsetMax = "93.627 3.419"
                        }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "ReportCount",
                    Parent = "PlayerPanel_Moderator",
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = "%REPORT_COUNTS%", Font = "robotocondensed-regular.ttf", FontSize = 15,
                            Align = TextAnchor.MiddleLeft, Color = config.ColorsSettings.MainColorText
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "155.371 -2.931",
                            OffsetMax = "210.229 18"
                        }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "ReportTitle",
                    Parent = "PlayerPanel_Moderator",
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = "%TITLE_PLAYER_REPORTS%", Font = "robotocondensed-regular.ttf", FontSize = 15,
                            Align = TextAnchor.LowerLeft, Color = config.ColorsSettings.AdditionalColorText
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "155.372 -18",
                            OffsetMax = "210.228 3.419"
                        }
                    }
                });

                container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = "%COMMAND%" },
                    Text = { Text = "", Font = "robotocondensed-regular.ttf", FontSize = 40, Align = TextAnchor.MiddleCenter, Color = "0 0 0 0" },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" }
                }, "PlayerPanel_Moderator", "SelectUserForReport");

                AddInterface($"{UI_LAYER}_TEMPLATE_PLAYER_MODERATOR", container.ToJson());
            }

            private void Building_PlayerTemplate_Moderator_IsSteam()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "IconStatusIsSteam",
                    Parent = "AvatarPlayer",
                    Components = {
                        new CuiRawImageComponent { Color = config.ColorsSettings.AdditionalColorElementsTwo, Png = "%STATUS_PLAYER%"},
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-18 7.333", OffsetMax = "-7.333 18" }
                    }
                });

                AddInterface($"{UI_LAYER}_TEMPLATE_PLAYER_MODERATOR_ISSTEAM", container.ToJson());
            }



            private void Building_Left_Menu()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = "0.8018868 0.2988163 0.2988163 0" },
                    RectTransform =
                    {
                        AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "28.493 -288.171", OffsetMax = "195.397 226.156"
                    }
                }, UI_REPORT_PANEL, UI_REPORT_LEFT_PANEL);

                AddInterface($"{UI_LAYER}_LEFT_MENU", container.ToJson());
            }

            private void Building_Button_Template()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "ReportPanelButton",
                    Parent = UI_REPORT_LEFT_PANEL,
                    Components =
                    {
                        new CuiRawImageComponent { Color = "%COLOR_BUTTON%", Png = ImageUi.GetImage(config.ImagesSettings.LeftBlockSettings.ButtonBackgorund) },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "%OFFSET_MIN%", OffsetMax = "%OFFSET_MAX%"
                        }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "LogoButtonReport",
                    Parent = "ReportPanelButton",
                    Components =
                    {
                        new CuiRawImageComponent
                            { Color = config.ColorsSettings.MainColorText, Png = "%ICON_BUTTON%" },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5",  OffsetMin = "-46 -6.333", OffsetMax = "-35.333 4.333"
                        }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "LabelText",
                    Parent = "ReportPanelButton",
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = "%TITLE_BUTTON%", Font = "robotocondensed-regular.ttf", FontSize = 14,
                            Align = TextAnchor.MiddleLeft, Color = config.ColorsSettings.MainColorText
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-19.893 -17", OffsetMax = "62.667 17"
                        }
                    }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%COMMAND_BUTTON%", Color = "0 0 0 0" },
                    Text = { Text = "", Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.MiddleLeft, Color = "0 0 0 0" }
                }, "ReportPanelButton", "Button_Take");

                AddInterface($"{UI_LAYER}_LEFT_MENU_BUTTON", container.ToJson());
            }



            private void Building_PoopUP_Moderator()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    Image = { Color = "0 0 0 0.3", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-432.189 -288.171", OffsetMax = "432.345 288.295" }
                }, UI_REPORT_PANEL, "BLURED_POOP_UP");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Close = "UI_REPORT_PANEL_CLOSE", Command = "report.panel close.poopup", Color = "0 0 0 0" },
                    Text = { Text = "", Font = "robotocondensed-regular.ttf", FontSize = 13, Align = TextAnchor.MiddleCenter, Color = "0 0 0 0" }
                }, "BLURED_POOP_UP", "UI_REPORT_PANEL_CLOSE");

                container.Add(new CuiElement
                {
                    Name = UI_REPORT_POOPUP_MODERATOR,
                    Parent = UI_REPORT_PANEL,
                    Components =
                    {
                        new CuiRawImageComponent { Color = config.ColorsSettings.MainColor, Png = ImageUi.GetImage(config.ImagesSettings.ModerationBlockSettings.ModeratorPoopUPBackgorund) },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-276.596 -199.667",
                            OffsetMax = "277.404 199.667"
                        }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "PoopUpAvatar",
                    Parent = UI_REPORT_POOPUP_MODERATOR,
                    Components =
                    {
                        new CuiRawImageComponent { Color = "1 1 1 1", Png = "%AVATAR%"},
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-235.533 111.867",
                            OffsetMax = "-192.867 154.533"
                        }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "PoopUpCircle",
                    Parent = "PoopUpAvatar",
                    Components =
                    {
                        new CuiRawImageComponent { Color = config.ColorsSettings.MainColor, Png = ImageUi.GetImage(config.ImagesSettings.AvatarBlur) },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-21.333 -21.333",
                            OffsetMax = "21.333 21.333"
                        }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "PoopUpNickTitle",
                    Parent = UI_REPORT_POOPUP_MODERATOR,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = "%TITLE_PLAYER_NICK_NAME%", Font = "robotocondensed-regular.ttf", FontSize = 16,
                            Align = TextAnchor.MiddleLeft, Color = config.ColorsSettings.AdditionalColorText
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-181.087 113.197", OffsetMax = "-93.58 134.67"
                        }
                    }
                });

                container.Add(new CuiElement
                {
                    Parent = UI_REPORT_POOPUP_MODERATOR,
                    Name = "PoopUpNickName",
                    Components =
                    {
                        new CuiInputFieldComponent {  Text = "%PLAYER_NAME%", Font = "robotocondensed-regular.ttf", FontSize = 16, Align = TextAnchor.UpperLeft, Color = config.ColorsSettings.MainColorText, NeedsKeyboard = true, LineType = InputField.LineType.SingleLine, ReadOnly = true},
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-181.085 125.843", OffsetMax = "-93.581 147.891" }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "PoopUpSteamIDTitle",
                    Parent = UI_REPORT_POOPUP_MODERATOR,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = "%TITLE_PLAYER_STEAMID%", Font = "robotocondensed-regular.ttf", FontSize = 16,
                            Align = TextAnchor.MiddleLeft, Color = config.ColorsSettings.AdditionalColorText
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-62.837 113.197",
                            OffsetMax = "57.776 134.67"
                        }
                    }
                });

                container.Add(new CuiElement
                {
                    Parent = UI_REPORT_POOPUP_MODERATOR,
                    Name = "PoopUpSteamID",
                    Components =
                    {
                        new CuiInputFieldComponent {  Text = "%PLAYER_USERID%", Font = "robotocondensed-regular.ttf", FontSize = 16, Align = TextAnchor.UpperLeft, Color = config.ColorsSettings.MainColorText, NeedsKeyboard = true, LineType = InputField.LineType.SingleLine, ReadOnly = true},
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-62.837 125.842", OffsetMax = "63.77 147.891" }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "CheckStatus",
                    Parent = UI_REPORT_POOPUP_MODERATOR,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = "%LAST_MODER_CHECK_NAME%", Font = "robotocondensed-regular.ttf", FontSize = 13,
                            Align = TextAnchor.MiddleLeft, Color = config.ColorsSettings.MainColorText
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-232.803 56.229", OffsetMax = "-84.33 78.645"
                        }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "CheckStatusTitle",
                    Parent = UI_REPORT_POOPUP_MODERATOR,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = "%TITLE_POOPUP_MODERATION_LAST_CHECK_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 13,
                            Align = TextAnchor.MiddleLeft, Color = config.ColorsSettings.AdditionalColorText
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-232.807 42.76", OffsetMax = "-84.327 64.845"
                        }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "AmountCheck",
                    Parent = UI_REPORT_POOPUP_MODERATOR,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = "%AMOUNT_CHECK%", Font = "robotocondensed-regular.ttf", FontSize = 13,
                            Align = TextAnchor.MiddleLeft, Color = config.ColorsSettings.MainColorText
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-67.037 56.231", OffsetMax = "81.437 78.649"
                        }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "AmountCheckTitle",
                    Parent = UI_REPORT_POOPUP_MODERATOR,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = "%TITLE_POOPUP_MODERATION_AMOUNT_CHECK_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 13,
                            Align = TextAnchor.MiddleLeft, Color = config.ColorsSettings.AdditionalColorText
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-67.037 42.76", OffsetMax = "81.437 64.845"
                        }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "AmountReport",
                    Parent = UI_REPORT_POOPUP_MODERATOR,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = "%AMOUNT_REPORTS%", Font = "robotocondensed-regular.ttf", FontSize = 13,
                            Align = TextAnchor.MiddleLeft, Color = config.ColorsSettings.MainColorText
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "99.963 56.233", OffsetMax = "248.437 78.647"
                        }
                    }
                });
                //diavel
                container.Add(new CuiElement
                {
                    Name = "AmountReportTitle",
                    Parent = UI_REPORT_POOPUP_MODERATOR,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = "%TITLE_POOPUP_MODERATION_REPORTS_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 13,
                            Align = TextAnchor.MiddleLeft, Color = config.ColorsSettings.AdditionalColorText
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "99.963 42.76", OffsetMax = "248.437 64.845"
                        }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "StartCheckPlayerButton",
                    Parent = UI_REPORT_POOPUP_MODERATOR,
                    Components = {
                        new CuiRawImageComponent { Color = config.ColorsSettings.AdditionalColorElements, Png = ImageUi.GetImage(config.ImagesSettings.LeftBlockSettings.ButtonBackgorund)},
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "107.4 116.2", OffsetMax = "232.733 150.2" }
                    }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Close = UI_REPORT_PANEL, Command = "%COMMAND_START%", Color = "0 0 0 0" },
                    Text = { Text = "%TITLE_POOPUP_MODERATION_INFO_BUTTON_START_CHECK%", Font = "robotocondensed-regular.ttf", FontSize = 13, Align = TextAnchor.MiddleCenter, Color = config.ColorsSettings.MainColorText }
                }, "StartCheckPlayerButton", "StartFuncCheckPlayer");

                AddInterface($"{UI_LAYER}_POOPUP_MODERATOR", container.ToJson());
            }

            private void Building_PoopUP_Moderator_InfoBlock()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "HistoryReportsPanel",
                    Parent = UI_REPORT_POOPUP_MODERATOR,
                    Components =
                    {
                        new CuiRawImageComponent { Color = config.ColorsSettings.MainColor, Png = ImageUi.GetImage(config.ImagesSettings.ModerationBlockSettings.ModeratorPoopUPPanelBackgorund) },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "%OFFSET_MIN%", OffsetMax = "%OFFSET_MAX%"
                        }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "TitleHistory",
                    Parent = "HistoryReportsPanel",
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = "%TITLE_PANEL%", Font = "robotocondensed-regular.ttf", FontSize = 14,
                            Align = TextAnchor.MiddleCenter, Color = config.ColorsSettings.MainColorText
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-65.333 55.413",
                            OffsetMax = "65.333 80"
                        }
                    }
                });

                AddInterface($"{UI_LAYER}_POOPUP_MODERATOR_INFO_BLOCK", container.ToJson());
            }

            private void Building_Text_Template_Moderator_Block_Info()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "PanelText",
                    Parent = "HistoryReportsPanel",
                    Components =
                    {
                        new CuiRawImageComponent { Color = config.ColorsSettings.AdditionalColorElements, Png = ImageUi.GetImage(config.ImagesSettings.ModerationBlockSettings.ModeratorPoopUPTextBackgorund) },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "%OFFSET_MIN%", OffsetMax = "%OFFSET_MAX%"
                        }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "Title",
                    Parent = "PanelText",
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = "%REASON_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 10,
                            Align = TextAnchor.MiddleCenter, Color = config.ColorsSettings.MainColorText
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0", AnchorMax = "1 1"
                        }
                    }
                });

                AddInterface($"{UI_LAYER}_POOPUP_MODERATOR_INFO_BLOCK_TEXT_TEMPLATE", container.ToJson());
            }



            private void Building_Moderator_Menu()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = UI_REPORT_MODERATOR_MENU_CHECKED,
                    Parent = "Overlay",
                    Components =
                    {
                        new CuiRawImageComponent { Color = config.ColorsSettings.MainColor, Png = ImageUi.GetImage(config.ImagesSettings.ModeratorMenuCheckedSettings.ModeratorCheckedBackground) },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "208.933 17.8", OffsetMax = "413.6 116.467"
                        }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "BackgroundButtonStop",
                    Parent = UI_REPORT_MODERATOR_MENU_CHECKED,
                    Components =
                    {
                        new CuiRawImageComponent
                            { Color = config.ColorsSettings.AdditionalColorElementsThree, Png = ImageUi.GetImage(config.ImagesSettings.ModeratorMenuCheckedSettings.ModeratorCheckedStopButton) },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-88.6 -41.2",
                            OffsetMax = "-3.267 -14.533"
                        }
                    }
                });

                container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = "%COMMAND_STOP_CHECKED%" },
                    Text =
                    {
                        Text = "%TITLE_PROFILE_MODERATOR_CHECKED_MENU_TITLE_BUTTON_STOP%", Font = "robotocondensed-regular.ttf", FontSize = 12,
                        Align = TextAnchor.MiddleCenter, Color = config.ColorsSettings.MainColorText
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-42.667 -13.333",
                        OffsetMax = "42.667 13.333"
                    }
                }, "BackgroundButtonStop", "ButtonStopCheck");

                container.Add(new CuiElement
                {
                    Name = "BackgroundButtonVerdict",
                    Parent = UI_REPORT_MODERATOR_MENU_CHECKED,
                    Components =
                    {
                        new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage(config.ImagesSettings.ModeratorMenuCheckedSettings.ModeratorVerdictButton) },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "1.133 -41.2",
                            OffsetMax = "86.467 -14.533"
                        }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "TitleMenu",
                    Parent = UI_REPORT_MODERATOR_MENU_CHECKED,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = "%TITLE_PROFILE_MODERATOR_CHECKED_MENU_TITLES%", Font = "robotocondensed-regular.ttf", FontSize = 14,
                            Align = TextAnchor.MiddleLeft, Color = config.ColorsSettings.MainColorText
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-88.6 27.387",
                            OffsetMax = "51.764 44.213"
                        }
                    }
                });

                AddInterface($"{UI_LAYER}_MODERATOR_MENU_CHECKED", container.ToJson());
            }

            private void Building_ModeratorMenu_Verdict_Button()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = "%COMMAND_VERDICT%" },
                    Text =
                    {
                        Text = "%TITLE_PROFILE_MODERATOR_CHECKED_MENU_TITLE_BUTTON_RESULT%", Font = "robotocondensed-regular.ttf", FontSize = 12,
                        Align = TextAnchor.MiddleCenter, Color = config.ColorsSettings.MainColorText
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-42.667 -13.333",
                        OffsetMax = "42.667 13.333"
                    }
                }, "BackgroundButtonVerdict", "ButtonVerdictCheck");

                AddInterface($"{UI_LAYER}_MODERATOR_MENU_CHECKED_BUTTON_VERDICT", container.ToJson());
            }
            private void Building_ModeratorMenuChecked_InfoOnline()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "InfoStatus",
                    Parent = UI_REPORT_MODERATOR_MENU_CHECKED,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = "%TITLE_PROFILE_MODERATOR_CHECKED_MENU_TITLE_STATUS%", Font = "robotocondensed-regular.ttf", FontSize = 10,
                            Align = TextAnchor.MiddleLeft, Color = config.ColorsSettings.MainColorText
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-88.6 -6.946",
                            OffsetMax = "51.764 9.88"
                        }
                    }
                });

                AddInterface($"{UI_LAYER}_ONLINE_STATUS_CHECKED_MODERATOR", container.ToJson());
            }
            private void Building_ModeratorMenuChecked_InfoDiscord()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Parent = UI_REPORT_MODERATOR_MENU_CHECKED,
                    Name = "InfoDiscord",
                    Components =
                    {
                        new CuiInputFieldComponent {  Text = "%TITLE_PROFILE_MODERATOR_CHECKED_MENU_TITLE_DISCORD%", Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = config.ColorsSettings.MainColorText, NeedsKeyboard = true, LineType = InputField.LineType.SingleLine, ReadOnly = true },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-88.6 8.454", OffsetMax = "51.764 25.28" }
                    }
                });

                AddInterface($"{UI_LAYER}_DISCORD_STATUS_CHECKED_MODERATOR", container.ToJson());
            }
            private void Building_DropList_Reasons()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "%REASON_NAME%",
                    Parent = "%PARENT_UI%",
                    Components =
                    {
                        new CuiRawImageComponent { Color = config.ColorsSettings.MainColor, Png = ImageUi.GetImage(config.ImagesSettings.ReasonModeratorAndRaiting) },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "%OFFSET_MIN%", OffsetMax = "%OFFSET_MAX%"
                        }
                    }
                });

                container.Add(new CuiButton
                {
                    Button = { Color = "1 1 1 0", Command = "%COMMAND_REASON%" },
                    Text =
                    {
                        Text = "%TEXT_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 14,
                        Align = TextAnchor.MiddleCenter, Color = config.ColorsSettings.MainColorText
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-102.333 -12", OffsetMax = "102.333 12"
                    }
                }, "%REASON_NAME%", "SelectReason");

                AddInterface($"{UI_LAYER}_REASON_MENU_LABEL", container.ToJson());
            }



            private void Building_Raiting_Menu()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = UI_REPORT_RAITING_PLAYER_PANEL,
                    Parent = "Overlay",
                    Components =
                    {
                        new CuiRawImageComponent { Color = config.ColorsSettings.MainColor, Png = ImageUi.GetImage(config.ImagesSettings.PlayerMenuRaitingSettings.PlayerMenuRaitingBackground) },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "208.933 17.8", OffsetMax = "413.6 83.133"
                        }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "TitleRating",
                    Parent = UI_REPORT_RAITING_PLAYER_PANEL,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = "%TITLE_RAITING_WORK_MODERATOR_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 14,
                            Align = TextAnchor.UpperLeft, Color = config.ColorsSettings.MainColorText
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-88.245 6.375",
                            OffsetMax = "43.845 24.358"
                        }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "InfoNameModer",
                    Parent = UI_REPORT_RAITING_PLAYER_PANEL,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = "%TITLE_RAITING_WORK_MODERATOR_WHO_MODERATOR%", Font = "robotocondensed-regular.ttf", FontSize = 10,
                            Align = TextAnchor.UpperLeft, Color = config.ColorsSettings.MainColorText
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-88.245 -9.691",
                            OffsetMax = "33.845 5.291"
                        }
                    }
                });

                container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = "%COMMAND_CLOSE%" },
                    Text =
                    {
                        Text = "%TITLE_CLOSE_BUTTON_REPORT%", Font = "robotocondensed-regular.ttf", FontSize = 14,
                        Align = TextAnchor.MiddleCenter, Color = config.ColorsSettings.MainColorText
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "77.088 9.376",
                        OffsetMax = "94.246 24.832"
                    }
                }, UI_REPORT_RAITING_PLAYER_PANEL, "NoRaitingClose");

                AddInterface($"{UI_LAYER}_RAITING_MENU_PLAYER", container.ToJson());
            }

            private void Building_Raiting_Select_Button()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "RaitingPng",
                    Parent = UI_REPORT_RAITING_PLAYER_PANEL,
                    Components =
                    {
                        new CuiRawImageComponent { Color = "%COLOR_STARS%", Png = ImageUi.GetImage(config.ImagesSettings.StatisticsBlockSettings.RaitingImage)},
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "%OFFSET_MIN%", OffsetMax = "%OFFSET_MAX%"
                        }
                    }
                });

                container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = "%COMMAND_STARS%" },
                    Text =
                    {
                        Text = "", Font = "robotocondensed-regular.ttf", FontSize = 14,
                        Align = TextAnchor.MiddleCenter, Color = "0 0 0 0"
                    },
                    RectTransform =
                    {
                        AnchorMin = "0 0", AnchorMax = "1 1"
                    }
                }, "RaitingPng", "RaitingPng_Command");

                AddInterface($"{UI_LAYER}_RAITING_MENU_PLAYER_STARS", container.ToJson());
            }



            private void Building_Player_Alert()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = UI_REPORT_PLAYER_ALERT,
                    Parent = "Overlay",
                    Components = {
                        new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage(config.ImagesSettings.PlayerAlerts) },
                        new CuiRectTransformComponent { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-483.3344863 -372.66", OffsetMax = "483.333 0.00744861" }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "LabelInfo",
                    Parent = UI_REPORT_PLAYER_ALERT,
                    Components = {
                        new CuiTextComponent { Text = "%TITLE_TEXT%", Font = "robotocondensed-regular.ttf", FontSize = 48, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 137.231", OffsetMax = "0 -175.898" },
                        new CuiOutlineComponent { Color = "0 0 0 1", Distance = "-0.5 0.5" }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "LabelDescription",
                    Parent = UI_REPORT_PLAYER_ALERT,
                    Components = {
                        new CuiTextComponent { Text = "%DESCRIPTION_TEXT%", Font = "robotocondensed-regular.ttf", FontSize = 20, Align = TextAnchor.UpperCenter, Color = "1 1 1 1" },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 39.676", OffsetMax = "0 -228.2044869" },
                        new CuiOutlineComponent { Color = "0 0 0 1", Distance = "-0.5 0.5" }
                    }
                });

                AddInterface($"{UI_LAYER}_PLAYER_ALERT", container.ToJson());
            }

        }

        private void GetPlayerCheckServerRCC(UInt64 TargetID)
        {
            if (String.IsNullOrWhiteSpace(config.ReferenceSettings.RCCSettings.RCCKey)) return;
            if (RCC_LocalRepository.ContainsKey(TargetID)) return;

            String API = $"https://rustcheatcheck.ru/panel/api?action=getInfo&key={config.ReferenceSettings.RCCSettings.RCCKey}&player={TargetID}";
            try
            {
                webrequest.Enqueue(API, null, (code, response) =>
                {
                    Response resources = JsonConvert.DeserializeObject<Response>(response);
                    if (resources.last_check == null)
                        return;

                    RCC_LocalRepository.Add(TargetID, new LocalRepositoryRCC());
                    RCC_LocalRepository[TargetID].LastChecksServers.AddRange(resources.last_check.Select(resource => resource.serverName));
                    RCC_LocalRepository[TargetID].LastBansServers.AddRange(resources.bans.Select(resource => resource.serverName));

                }, this);
            }
            catch (Exception ex)
            {
                PrintError(LanguageEn ? "RCC : We couldn't find player information with RCC, please check if your key is up to date or if RCC is available" : "RCC : Мы не смогли найти информацию об игроке с помощью RCC, проверьте актуальность вашего ключа или доступность RCC");
            }
        }


        [ConsoleCommand("iqrs")]
        private void ConsoleCommandReport(ConsoleSystem.Arg arg) ///iqrs call SteamID
        {
            if (!arg.HasArgs(1)) return;
            String Actions = arg.Args[0];
            BasePlayer player = arg.Player();
            if (player != null)
                if (!IsModerator(player))
                    return;

            Boolean IsConsole = player == null;
            BasePlayer Target = null;
            UInt64 UserIDPlayer = 0;
            if (!Actions.Contains("report"))
            {
                if (!arg.HasArgs(2)) return;
                String NameOrID = arg.Args[1];
                UserIDPlayer = Convert.ToUInt64(NameOrID.IsSteamId() ? NameOrID : covalence.Players.FindPlayer(NameOrID)?.Id);
                Target = BasePlayer.Find(NameOrID);

                if (Target == null)
                {
                    if (!Actions.Contains("dismiss"))
                    {
                        if (player != null)
                            player.ConsoleMessage(LanguageEn
                                ? "The player is not on the server or you have entered incorrect data"
                                : "Игрока нет на сервере или вы указали неверные данные");
                        else
                            Puts(LanguageEn
                                ? "The player is not on the server or you have entered incorrect data"
                                : "Игрока нет на сервере или вы указали неверные данные");
                        return;
                    }
                }
            }

            switch (Actions)
            {
                case "give":
                    {
                        if (!arg.HasArgs(3)) return;
                        if (!IsConsole && !player.IsAdmin) return;
                        Int32 AmountGive;
                        if (!Int32.TryParse(arg.Args[2], out AmountGive))
                        {
                            PrintWarning(LanguageEn ? "You have entered a letter as quantity! Only numbers are supported" : "Вы ввели в качестве количества буквы! Поддерживаются только цифры");
                            return;
                        }

                        if (AmountGive <= 0)
                        {
                            PrintWarning(LanguageEn ? "Value cannot be less than or equal to zero." : "Значение не может быть меньше или равно нулю");
                            return;
                        }

                        if (!PlayerInformations.ContainsKey(UserIDPlayer))
                        {
                            PrintWarning(LanguageEn ? "The player is not in the complaint system database" : "Игрока нет в базе данных системы жалоб");
                            return;
                        }

                        PlayerInformations[UserIDPlayer].Reports += AmountGive;
                        Puts(LanguageEn ? $"Player {UserIDPlayer} has been successfully awarded {AmountGive} reports. Total amount: {PlayerInformations[UserIDPlayer].Reports}" : $"Игроку {UserIDPlayer} успешно было начислено {AmountGive} репортов. Общее количество {PlayerInformations[UserIDPlayer].Reports}");
                        break;
                    }
                case "remove":
                    {
                        if (!arg.HasArgs(3)) return;
                        if (!IsConsole && !player.IsAdmin) return;
                        Int32 AmountRemove;
                        if (!Int32.TryParse(arg.Args[2], out AmountRemove))
                        {
                            PrintWarning(LanguageEn ? "You have entered a letter as quantity! Only numbers are supported" : "Вы ввели в качестве количества буквы! Поддерживаются только цифры");
                            return;
                        }

                        if (AmountRemove <= 0)
                        {
                            PrintWarning(LanguageEn ? "Value cannot be less than or equal to zero." : "Значение не может быть меньше или равно нулю");
                            return;
                        }

                        if (!PlayerInformations.ContainsKey(UserIDPlayer))
                        {
                            PrintWarning(LanguageEn ? "The player is not in the complaint system database" : "Игрока нет в базе данных системы жалоб");
                            return;
                        }

                        PlayerInformations[UserIDPlayer].Reports -= PlayerInformations[UserIDPlayer].Reports <= AmountRemove ? PlayerInformations[UserIDPlayer].Reports : AmountRemove;
                        Puts(LanguageEn ? $"Player {UserIDPlayer} has been successfully remove {AmountRemove} reports. Total amount: {PlayerInformations[UserIDPlayer].Reports}" : $"Игроку {UserIDPlayer} успешно было удалено {AmountRemove} репортов. Общее количество {PlayerInformations[UserIDPlayer].Reports}");
                        break;
                    }
                case "call":
                    {
                        if (!IsConsole && (!player.IsAdmin || !IsModerator(player))) return;

                        if (AfkCheckRoutine.ContainsKey(Target))
                        {
                            if (AfkCheckRoutine[Target] != null)
                            {
                                ServerMgr.Instance.StopCoroutine(AfkCheckRoutine[Target]);
                                AfkCheckRoutine[Target] = null;

                                if (PlayerChecks.ContainsKey(Target.userID))
                                    PlayerChecks.Remove(Target.userID);
                            }
                        }

                        Coroutine routineAFK = ServerMgr.Instance.StartCoroutine(StartAfkCheck(Target, player, IsConsole, !config.CheckControllerSettings.UseCheckAFK));

                        if (!AfkCheckRoutine.ContainsKey(Target))
                            AfkCheckRoutine.Add(Target, routineAFK);
                        else AfkCheckRoutine[Target] = routineAFK;

                        break;
                    }
                case "dismiss":
                    {
                        if (!IsConsole && (!player.IsAdmin || !IsModerator(player))) return;

                        StopCheckedPlayer(UserIDPlayer, player, IsConsole: IsConsole);
                        break;
                    }
                case "report.list":
                case "reports":
                    {
                        if (!IsConsole && !player.IsAdmin) return;

                        IOrderedEnumerable<BasePlayer> moderatorSortedList = BasePlayer.activePlayerList
                            .Where(x => PlayerInformations[x.userID].Reports >=
                                        config.ReportContollerModerationSettings.ReportCountTrigger)
                            .OrderByDescending(x => PlayerInformations[x.userID].Reports);

                        Int32 Number = 1;
                        String PlayersInfo = String.Empty;
                        foreach (BasePlayer pList in moderatorSortedList)
                        {
                            PlayersInfo += $"{Number}. {pList.displayName} ({pList.userID}) : {PlayerInformations[pList.userID].Reports} ";
                            PlayersInfo += LanguageEn ? "reports\n" : "жалоб\n";
                            Number++;
                        }

                        if (String.IsNullOrWhiteSpace(PlayersInfo))
                            PlayersInfo = LanguageEn ? "There are no players with complaints" : "Игроков с жалобами нет";

                        if (IsConsole)
                            Puts(LanguageEn ? $"Players with complaints :\n{PlayersInfo}" : $"Игроки с жалобами :\n{PlayersInfo}");
                        else PrintToConsole(player, !lang.GetLanguage(player.UserIDString).Equals("ru") ? $"Players with complaints :\n{PlayersInfo}" : $"Игроки с жалобами :\n{PlayersInfo}");
                        break;
                    }
            }
        }

        private IEnumerator SendSounds(BasePlayer player, String clipName, SpeakerEntityMgr.SpeakerEntity speakerEntity)
        {
            NpcSound sound = LoadDataSound(clipName);
            if (sound == null)
            {
                if (RoutineSounds[player] != null)
                    ServerMgr.Instance.StopCoroutine(RoutineSounds[player]);

                speakerEntity?.Kill();
                yield break;
            }
            yield return CoroutineEx.waitForSeconds(0.1f);

            foreach (byte[] data in sound.Data)
            {
                if (speakerEntity == null)
                {
                    break;
                }

                SendSound(speakerEntity.UID_SPEAKER, data);
                yield return CoroutineEx.waitForSeconds(0.07f);
            }

            if (RoutineSounds[player] != null)
                ServerMgr.Instance.StopCoroutine(RoutineSounds[player]);
            yield break;
        }

        public class OzServer
        {
            public string name { get; set; }
            public string ico { get; set; }
            public string overlay { get; set; }
            public string desc { get; set; }
            public string site { get; set; }
            public bool pirate { get; set; }
            public int game { get; set; }
            public string ip { get; set; }
        }




        public Dictionary<BasePlayer, Coroutine> RoutineSounds = new Dictionary<BasePlayer, Coroutine>();



        private void DrawUI_LeftMenu(BasePlayer player, Boolean IsModerator = false)
        {
            String Interface = InterfaceBuilder.GetInterface($"{InterfaceBuilder.UI_LAYER}_LEFT_MENU");
            if (Interface == null) return;

            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_REPORT_LEFT_PANEL);
            CuiHelper.AddUi(player, Interface);

            DrawUI_LeftMenu_Button(player, GetLang("TITLE_LEFT_MENU_BUTTON_REPORTS", player.UserIDString),
                ImageUi.GetImage(config.ImagesSettings.LeftBlockSettings.ReportIcon),
                IsModerator ? config.ColorsSettings.AdditionalColorElements : "0 0 0 0", "-70.333 -34", "55 0",
                IsModerator ? $"report.panel select.type.mod {true}" : "");

            if (_.IsModerator(player))
                DrawUI_LeftMenu_Button(player, GetLang("TITLE_LEFT_MENU_BUTTON_MODERATION", player.UserIDString),
                    ImageUi.GetImage(config.ImagesSettings.LeftBlockSettings.ModerationIcon),
                    IsModerator ? "0 0 0 0" : config.ColorsSettings.AdditionalColorElements, "-70.333 -71.267",
                    "55 -37.267", IsModerator ? "" : $"report.panel select.type.mod {false}");
        }




        private Boolean IsRaidBlock(BasePlayer Target)
        {
            if (!config.ReferenceSettings.NoEscapeSetting.NoCheckedRaidBlock) return false;
            if (!NoEscape)
            {
                String ret = Interface.Call("CanTeleport", Target) as String;
                return ret != null;
            }
            Boolean IsRaidBlock = (Boolean)NoEscape.CallHook("IsRaidBlocked", Target);

            return IsRaidBlock;
        }

        private NpcSound LoadDataSound(String name)
        {
            NpcSound cache = CachedSound[name];
            if (cache != null)
                return cache;

            if (Interface.Oxide.DataFileSystem.ExistsDatafile("IQSystem/IQReportSystem/Sounds/" + name))
            {
                NpcSound data = Interface.GetMod().DataFileSystem.ReadObject<NpcSound>("IQSystem/IQReportSystem/Sounds/" + name);
                if (data == null)
                    return null;

                CachedSound[name] = data;
                return data;
            }
            else
            {
                PrintWarning(LanguageEn ? $"Could not find file named {name}. It should be located along the path: IQSystem/IQReportSystem/Sounds/{name}.json" : $"Не удалось найти файл с названием {name}. Он должен быть расположен по пути : IQSystem/IQReportSystem/Sounds/{name}.json");
                return null;
            }
        }



        private void DrawUI_PageController(BasePlayer player, Int32 Page, Boolean IsModerator, String SearchName = "")
        {
            List<FakePlayer> fakePlayers = null;
            List<BasePlayer> playerList = null;
            Int32 AllCountPlayers = 0;
            Int32 MaxPlayerPage = IsModerator ? 7 : 27;

            if (IsModerator)  //
            {
                List<BasePlayer> moderatorSortedList = BasePlayer.activePlayerList.Where(x => x.userID != player.userID && !permission.UserHasPermission(x.UserIDString, HideMenuPermissions) && !PlayerChecks.ContainsKey(x.userID) && PlayerInformations[x.userID].Reports >= config.ReportContollerModerationSettings.ReportCountTrigger && x.displayName.ToLower().Contains(SearchName.ToLower())).OrderByDescending(x => PlayerInformations[x.userID].Reports).ToList();
                playerList = moderatorSortedList.Skip(Page * MaxPlayerPage).Take(MaxPlayerPage).ToList();

                AllCountPlayers = moderatorSortedList.Count;
            }
            else
            {
                if (IQFakeActive && config.ReferenceSettings.IQFakeActiveUse)
                {
                    List<FakePlayer> fakePlayersSorted = PlayerBases.Where(x => x.UserID != player.userID && !permission.UserHasPermission(x.UserID.ToString(), HideMenuPermissions) && x.DisplayName.ToLower().Contains(SearchName.ToLower())).ToList();
                    fakePlayers = fakePlayersSorted.Skip(Page * MaxPlayerPage).Take(MaxPlayerPage).ToList();

                    AllCountPlayers = fakePlayersSorted.Count;
                }
                else // 
                {
                    List<BasePlayer> sortedPlayers = BasePlayer.activePlayerList.Where(x => x.userID != player.userID && !permission.UserHasPermission(x.UserIDString, HideMenuPermissions) && x.displayName.ToLower().Contains(SearchName.ToLower()) && (!IsFriendSendReport(player.userID, x.userID) || !IsClansSendReport(player.UserIDString, x.UserIDString))).ToList();
                    playerList = sortedPlayers.Skip(Page * MaxPlayerPage).Take(MaxPlayerPage).ToList();

                    AllCountPlayers = sortedPlayers.Count;
                }
            }

            String Interface = InterfaceBuilder.GetInterface($"{InterfaceBuilder.UI_LAYER}_PANEL_PLAYERS_PAGE_CONTROLLER");
            if (Interface == null) return;

            Interface = Interface.Replace("%AMOUNT_PAGE%", $"{Page}");
            Interface = Interface.Replace("%COMMAND_PAGE_NEXT%", AllCountPlayers < MaxPlayerPage ? "" : $"report.panel page.controller {(AllCountPlayers >= (Page + 1) * MaxPlayerPage ? (Page + 1) : 0)} {IsModerator}");
            Interface = Interface.Replace("%COMMAND_PAGE_BACK%", AllCountPlayers < MaxPlayerPage ? "" : $"report.panel page.controller {(Page <= 0 ? AllCountPlayers / MaxPlayerPage : Page - 1)} {IsModerator}");

            CuiHelper.DestroyUi(player, "ActionPageCount");
            CuiHelper.DestroyUi(player, "ButtonNextPage");
            CuiHelper.DestroyUi(player, "ButtonBackPage");
            CuiHelper.AddUi(player, Interface);

            ShowPlayersList(player, playerList, fakePlayers, IsModerator);
        }
        private Dictionary<UInt64, PlayerRepository> PlayerRepositories = new Dictionary<UInt64, PlayerRepository>();

        private List<String> GetServersBansOzProtect(UInt64 TargetID)
        {
            if (String.IsNullOrWhiteSpace(config.ReferenceSettings.OzProtectSettings.OzProtectKey)) return null;
            return !OzProtect_LocalRepository.ContainsKey(TargetID) ? new List<String>() : OzProtect_LocalRepository[TargetID].LastBansServers;
        }


        public void StartSysncFakeActive()
        {
            if (!IQFakeActive) return;
            IQFakeActive?.Call("SyncReserved");
        }

        private void StopDamageRemove(UInt64 playerID)
        {
            if (StopDamageMan == null) return;
            if (!config.ReferenceSettings.StopDamageManSetting.UseStopDamage) return;

            StopDamageMan.CallHook("RemovePlayerSDM", playerID);
        }

        private void DrawUI_LeftMenu_Button(BasePlayer player, String TitleButton, String IconButton, String ColorButton, String OffsetMin, String OffsetMax, String Command)
        {
            String Interface = InterfaceBuilder.GetInterface($"{InterfaceBuilder.UI_LAYER}_LEFT_MENU_BUTTON");
            if (Interface == null) return;

            Interface = Interface.Replace("%OFFSET_MIN%", OffsetMin);
            Interface = Interface.Replace("%OFFSET_MAX%", OffsetMax);
            Interface = Interface.Replace("%TITLE_BUTTON%", TitleButton);
            Interface = Interface.Replace("%ICON_BUTTON%", IconButton);
            Interface = Interface.Replace("%COLOR_BUTTON%", ColorButton);
            Interface = Interface.Replace("%COMMAND_BUTTON%", Command);

            CuiHelper.AddUi(player, Interface);
        }
        private Boolean IsFriends(UInt64 userID, UInt64 targetID)
        {
            if (!Friends)
                return RelationshipManager.ServerInstance.playerToTeam.ContainsKey(userID) && RelationshipManager.ServerInstance.playerToTeam[userID].members.Contains(targetID);
            return (Boolean)Friends?.Call("HasFriend", userID, targetID);
        }



        private void DrawUI_Raiting_Menu_Player(BasePlayer player, UInt64 ModeratorID)
        {
            String Interface = InterfaceBuilder.GetInterface($"{InterfaceBuilder.UI_LAYER}_RAITING_MENU_PLAYER");
            if (Interface == null) return;

            IPlayer iModerator = covalence.Players.FindPlayerById(ModeratorID.ToString());
            String ModeratorName = iModerator == null ? GetLang("TITLE_RAITING_WORK_MODERATOR_WHO_MODERATOR_NOT_NAME", player.UserIDString) : iModerator.Name;

            Interface = Interface.Replace("%TITLE_CLOSE_BUTTON_REPORT%", GetLang("TITLE_CLOSE_BUTTON_REPORT", player.UserIDString));
            Interface = Interface.Replace("%TITLE_RAITING_WORK_MODERATOR_TITLE%", GetLang("TITLE_RAITING_WORK_MODERATOR_TITLE", player.UserIDString));
            Interface = Interface.Replace("%TITLE_RAITING_WORK_MODERATOR_WHO_MODERATOR%", GetLang("TITLE_RAITING_WORK_MODERATOR_WHO_MODERATOR", player.UserIDString, ModeratorName.ToUpper()));
            Interface = Interface.Replace("%COMMAND_CLOSE%", $"report.panel close.select.raiting {ModeratorID}");

            CuiHelper.AddUi(player, Interface);

            DrawUI_Raiting_Menu_Stars(player, -1, ModeratorID);
        }
        private class PlayerInformation
        {
            public Int32 Reports;
            public Int32 SendReports;
            public Int32 AmountChecked;
            public String LastModerator;

            public List<Configuration.LangText> ReasonHistory = new List<Configuration.LangText>();
        }



        public class SpeakerEntityMgr
        {
            private static List<SpeakerEntity> _Entities = new List<SpeakerEntity>();
            public static SpeakerEntity Create(BasePlayer listeners)
            {
                var speaker = new SpeakerEntity();
                speaker.SetListeners(listeners);
                _Entities.Add(speaker);

                return speaker;
            }
            public static void Shutdown()
            {
                if (_Entities != null && _Entities.Count != 0)
                    _Entities.ForEach(entity => _.NextTick(() => { entity?.Kill(); }));
            }
            public static void Kill(SpeakerEntity entity)
            {
                _Entities.Remove(entity);
            }

            public class SpeakerEntity
            {
                public UInt64 UID_SPEAKER = Network.Net.sv.TakeUID();
                private UInt64 UID_CHAIR = Network.Net.sv.TakeUID();
                public BasePlayer Listeners { get; private set; }
                public void SetListeners(BasePlayer listeners)
                {
                    Listeners = listeners;
                }
                public void SendEntitities()
                {
                    SendEntity(GetEntityChair);
                    SendEntity(GetEntitySpeaker);
                }
                private ProtoBuf.Entity GetEntitySpeaker(BasePlayer player) =>
                    new ProtoBuf.Entity()
                    {
                        baseNetworkable = new ProtoBuf.BaseNetworkable()
                        {
                            prefabID = player.prefabID,
                            @group = BaseNetworkable.GlobalNetworkGroup.ID,
                            uid = new NetworkableId(UID_SPEAKER),
                        },
                        baseEntity = new ProtoBuf.BaseEntity()
                        {
                            flags = 0,
                            pos = new Vector3(0, 0, 0),
                            rot = new Vector3(0, 0, 0),
                            skinid = 0,
                            time = Time.time,
                        },
                        baseCombat = new ProtoBuf.BaseCombat()
                        {
                            health = 10000,
                            state = (Int32)BaseCombatEntity.LifeState.Alive
                        },
                        basePlayer = new ProtoBuf.BasePlayer()
                        {
                            health = 10000,
                            modelState = new ModelState()
                            {
                                mounted = true,
                                onground = true,
                                ducked = true,
                                prone = true
                            },
                            userid = UID_SPEAKER,
                            name = "VOICE_P",
                            playerFlags = (Int32)0,
                            mounted = new NetworkableId(UID_CHAIR),
                        },
                        parent = new ProtoBuf.ParentInfo()
                        {
                            uid = new NetworkableId(UID_CHAIR),
                            bone = 0
                        }
                    };

                private ProtoBuf.Entity GetEntityChair(BasePlayer player) =>
                    new ProtoBuf.Entity()
                    {
                        baseNetworkable = new ProtoBuf.BaseNetworkable()
                        {
                            prefabID = 624857933, // static chair
                            @group = BaseNetworkable.GlobalNetworkGroup.ID,
                            uid = new NetworkableId(UID_CHAIR),
                        },
                        baseEntity = new ProtoBuf.BaseEntity()
                        {
                            flags = 0,
                            pos = new Vector3(0, 0.5f, -2.3f),
                            rot = new Vector3(90, 180, 180),
                            skinid = 0,
                            time = Time.time,
                        },
                        parent = new ProtoBuf.ParentInfo()
                        {
                            uid = player.net.ID,
                            bone = 2822582055 // head
                        }
                    };

                public void Kill()
                {
                    DestroyEntity(UID_SPEAKER);
                    DestroyEntity(UID_CHAIR);

                    SpeakerEntityMgr.Kill(this);
                }

                private void SendEntity(Func<BasePlayer, ProtoBuf.Entity> entityGetter)
                {
                    NetWrite write = Network.Net.sv.StartWrite();

                    write.PacketID(Message.Type.Entities);
                    write.UInt32(++Listeners.net.connection.validate.entityUpdates);
                    entityGetter(Listeners)?.WriteToStream(write);
                    write.Send(new SendInfo(Listeners.net.connection));
                }

                private void DestroyEntity(UInt64 uid)
                {
                    NetWrite write = Network.Net.sv.StartWrite();

                    write.PacketID(Message.Type.EntityDestroy);
                    write.UInt64(uid);
                    write.Send(new SendInfo(Listeners.Connection) { priority = Priority.Immediate });
                }
            }
        }



        private void DrawUI_TemplatePlayer_Moderator(BasePlayer player, Int32 Y, String UserID, String NickName)
        {
            String Interface = InterfaceBuilder.GetInterface($"{InterfaceBuilder.UI_LAYER}_TEMPLATE_PLAYER_MODERATOR");
            if (Interface == null) return;

            Interface = Interface.Replace("%AVATAR%", GetImage(UserID));
            Interface = Interface.Replace("%NAME%", NickName.Length > 7 ? NickName.Substring(0, 7).ToUpper() + ".." : NickName.ToUpper());
            Interface = Interface.Replace("%STEAMID%", UserID);
            Interface = Interface.Replace("%OFFSET_MIN%", $"-219.212 {174.147 - (Y * 62)}");
            Interface = Interface.Replace("%OFFSET_MAX%", $"219.215 {210.147 - (Y * 62)}");
            Interface = Interface.Replace("%REPORT_COUNTS%", $"{PlayerInformations[UInt64.Parse(UserID)].Reports}");
            Interface = Interface.Replace("%COMMAND%", $"report.panel select.player {UserID} true");

            Interface = Interface.Replace("%TITLE_PLAYER_NICK_NAME%", GetLang("TITLE_PLAYER_NICK_NAME", player.UserIDString));
            Interface = Interface.Replace("%TITLE_PLAYER_STEAMID%", GetLang("TITLE_PLAYER_STEAMID", player.UserIDString));
            Interface = Interface.Replace("%TITLE_PLAYER_REPORTS%", GetLang("TITLE_PLAYER_REPORTS", player.UserIDString));

            CuiHelper.AddUi(player, Interface);

            if (config.ReferenceSettings.MultiFightingSetting.UseSteamCheck && MultiFighting != null)
                DrawUI_TemplatePlayer_Moderator_IsSteam(player, UserID);
        }

        private readonly Dictionary<UInt64, ProcessCheckRepository> PlayerChecks = new Dictionary<UInt64, ProcessCheckRepository>();

        public class OzResult
        {
            public string status { get; set; }
            public List<OzResponse> response { get; set; }
        }
        private const String HideMenuPermissions = "iqreportsystem.hidemenu";

        private void DrawUI_TemplatePlayer_Moderator_IsSteam(BasePlayer player, String UserID)
        {
            String Interface = InterfaceBuilder.GetInterface($"{InterfaceBuilder.UI_LAYER}_TEMPLATE_PLAYER_MODERATOR_ISSTEAM");
            if (Interface == null) return;

            Interface = Interface.Replace("%STATUS_PLAYER%", IsSteam(UserID) ? ImageUi.GetImage(config.ImagesSettings.ModeratorMenuCheckedSettings.SteamIcoPlayer) : ImageUi.GetImage(config.ImagesSettings.ModeratorMenuCheckedSettings.PirateIcoPlayer));

            CuiHelper.AddUi(player, Interface);
        }

        private void RunEffect(BasePlayer Moderator)
        {
            if (!config.ReportContollerModerationSettings.AlertModerationSettings.AlertSound || String.IsNullOrWhiteSpace(config.ReportContollerModerationSettings.AlertModerationSettings.PathSound)) return;
            Effect effect = new Effect(config.ReportContollerModerationSettings.AlertModerationSettings.PathSound, Moderator, 0, new Vector3(), new Vector3());
            EffectNetwork.Send(effect, Moderator.Connection);
        }

        void OnPlayerBanned(string name, ulong id, string address, string reason) => StopCheckedPlayer(id, null, IsConsole: true);

        private void DrawUI_Player_Alert(BasePlayer player)
        {
            String Interface = InterfaceBuilder.GetInterface($"{InterfaceBuilder.UI_LAYER}_PLAYER_ALERT");
            if (Interface == null) return;

            Interface = Interface.Replace("%TITLE_TEXT%", GetLang("TITLE_PLAYER_ALERT_INFORMATION_TITLE", player.UserIDString));
            Interface = Interface.Replace("%DESCRIPTION_TEXT%", GetLang("TITLE_PLAYER_ALERT_INFORMATION_DESCRIPTION", player.UserIDString));

            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_REPORT_PLAYER_ALERT);
            CuiHelper.AddUi(player, Interface);

            if (!config.CheckControllerSettings.UseSoundAlert) return;
            NextTick(() => { SoundPlay(player); });
        }




        private static Configuration config = new Configuration();



        private void SendPlayerDiscord(BasePlayer player, String Discord)
        {
            if (player == null) return;
            if (!PlayerChecks.ContainsKey(player.userID)) return;

            if (Discord == null)
            {
                SendChat(GetLang("FUNCIONAL_SEND_DISCORD_NULL_DS", player.UserIDString), player);
                return;
            }

            if (String.IsNullOrWhiteSpace(Discord))
            {
                SendChat(GetLang("FUNCIONAL_SEND_DISCORD_NULL_DS", player.UserIDString), player);
                return;
            }
            Regex regex = new Regex(@"^(?!(here|everyone))^(?!.*(discord|```))(?:[\w\.]{2,32}#\d{4}|\@[\w\.]{1,32}|[\w\.]{1,32})$");

            if (!regex.IsMatch(Discord))
            {
                SendChat(GetLang("FUNCIONAL_SEND_DISCORD_NO_REGEX_DS", player.UserIDString), player);
                return;
            }

            PlayerChecks[player.userID].DiscordTarget = Discord;

            SendChat(GetLang("FUNCIONAL_SEND_DISCORD_SUCCESS", player.UserIDString, Discord), player);

            BasePlayer Moderator = BasePlayer.FindByID(PlayerChecks[player.userID].ModeratorID);
            if (Moderator != null)
            {
                DrawUI_Moderator_Checked_Menu_Discord(Moderator, Discord);
                SendChat(GetLang("FUNCIONAL_SEND_DISCORD_SUCCESS_ALERT_MODERATOR", Moderator.UserIDString, Discord), Moderator);
            }
            else Puts(LanguageEn ? $"The player sent you his Discord. Contact : {Discord}" : $"Игрок прислал вам свой Discord. Контакт : {Discord}");

            Configuration.NotifyDiscord.Webhooks.TemplatesNotify TemplateDiscord = config.NotifyDiscordSettings.WebhooksList.NotifyContacts;
            if (!String.IsNullOrWhiteSpace(TemplateDiscord.WebhookNotify))
            {
                List<Fields> fields = DT_PlayerSendContact(player, Discord);
                SendDiscord(TemplateDiscord.WebhookNotify, fields, GetAuthorDiscord(TemplateDiscord), TemplateDiscord.Color);
            }

            SendVK(VKT_PlayerSendContact(player, Discord));

            Interface.Call("OnSendedContacts", player, Discord);
        }



        public Boolean IsDuel(UInt64 userID)
        {
            if (!config.ReferenceSettings.NoCheckedDuel) return false;
            if (EventHelper)
            {
                if ((Boolean)EventHelper.CallHook("EMAtEvent", userID))
                    return true;
            }

            if (Battles)
                return (Boolean)Battles?.Call("IsPlayerOnBattle", userID);
            if (Duel) return (Boolean)Duel?.Call("IsPlayerOnActiveDuel", BasePlayer.FindByID(userID));
            if (Duelist) return (Boolean)Duelist?.Call("inEvent", BasePlayer.FindByID(userID));
            if (ArenaTournament) return ArenaTournament.Call<Boolean>("IsOnTournament", userID);
            return false;
        }

        private void OnPlayerDisconnected(BasePlayer player, String reason)
        {
            CheckStatusPlayer(player, reason);

            if (IsModerator(player))
                CheckStatusModerator(player, reason);
        }
        private Boolean IsClansStartChecked(String userID, String targetID) => config.ReferenceSettings.ClansSetting.StartCheckedClan && IsClans(userID, targetID);

        private readonly Regex _avatarRegex = new Regex(@"<avatarFull><!\[CDATA\[(.*)\]\]></avatarFull>", RegexOptions.Compiled);



        private Boolean IsSteam(String id)
        {
            if (MultiFighting == null) return true;

            BasePlayer player = BasePlayer.Find(id);
            if (player == null)
                return false;

            Object obj = MultiFighting.CallHook("IsSteam", player.Connection);
            if (obj is Boolean)
                return (Boolean)obj;

            return false;
        }



        public Boolean IsValidStartChecked(BasePlayer Target, BasePlayer Moderator, Boolean IsConsole = false)
        {
            if (PlayerChecks.ContainsKey(Target.userID))
            {
                if (IsConsole)
                    Puts(LanguageEn ? "This player has already been called for checked" : "Данного игрока уже вызвали на проверку");
                else if (Moderator != null)
                    SendChat(GetLang("NOTIFY_MODERATOR_ITS_PLAYER_CHECKED", Moderator.UserIDString), Moderator);
                return false;
            }

            if (IsRaidBlock(Target))
            {
                if (IsConsole)
                    Puts(LanguageEn ? "The check was canceled automatically with complaints saved! Reason : the player has an active raid-block" : "Проверка отменена автоматически с сохранением жалоб! Причина : у игрока активный рейд-блок");
                else if (Moderator != null)
                    SendChat(GetLang("NOTIFY_MODERATOR_RAIDBLOCK_PLAYER", Moderator.UserIDString), Moderator);
                return false;
            }

            if (IsCombatBlock(Target))
            {
                if (IsConsole)
                    Puts(LanguageEn ? "The check was canceled automatically with complaints saved! Reason : the player has an active combat-block" : "Проверка отменена автоматически с сохранением жалоб! Причина : у игрока активный комбат-блок");
                else if (Moderator != null)
                    SendChat(GetLang("NOTIFY_MODERATOR_COMBATBLOCK_PLAYER", Moderator.UserIDString), Moderator);
                return false;
            }

            if (IsDuel(Target.userID))
            {
                if (IsConsole)
                    Puts(LanguageEn ? "The check is canceled automatically with complaints saved! Reason : the player is in a duel" : "Проверка отменена автоматически с сохранением жалоб! Причина : игрок находится на дуэли");
                else if (Moderator != null)
                    SendChat(GetLang("NOTIFY_MODERATOR_DUEL_PLAYER", Moderator.UserIDString), Moderator);
                return false;
            }

            if (Moderator != null && !IsConsole)
            {
                if (IsFriendStartChecked(Moderator.userID, Target.userID))
                {
                    SendChat(GetLang("NOTIFY_MODERATOR_FRIEND_PLAYER", Moderator.UserIDString), Moderator);
                    return false;
                }
                if (IsClansStartChecked(Moderator.UserIDString, Target.UserIDString))
                {
                    SendChat(GetLang("NOTIFY_MODERATOR_FRIEND_PLAYER", Moderator.UserIDString), Moderator);
                    return false;
                }
            }

            return true;
        }



        private void DrawUI_ShowPoopUP(BasePlayer player, String displayName, String userID)
        {
            String Interface = InterfaceBuilder.GetInterface($"{InterfaceBuilder.UI_LAYER}_TEMPLATE_POOPUP");
            if (Interface == null) return;

            Interface = Interface.Replace("%POOPUP_BACKGORUND%", ImageUi.GetImage(config.ImagesSettings.PlayerListBlockSettings.PoopUpBackgorund));
            Interface = Interface.Replace("%AVATAR%", GetImage(userID));
            Interface = Interface.Replace("%NICK_NAME%", displayName.Length > 7 ? displayName.Substring(0, 7).ToUpper() + ".." : displayName.ToUpper());
            Interface = Interface.Replace("%STEAMID%", userID);

            Interface = Interface.Replace("%TITLE_PLAYER_NICK_NAME%", GetLang("TITLE_PLAYER_NICK_NAME", player.UserIDString));
            Interface = Interface.Replace("%TITLE_PLAYER_STEAMID%", GetLang("TITLE_PLAYER_STEAMID", player.UserIDString));

            CuiHelper.AddUi(player, Interface);

            DrawUI_ShowPoopUP_Reason(player, userID);
        }
        public string GetLang(string LangKey, string userID = null, params object[] args)
        {
            sb.Clear();
            if (args != null)
            {
                sb.AppendFormat(lang.GetMessage(LangKey, this, userID), args);
                return sb.ToString();
            }
            return lang.GetMessage(LangKey, this, userID);
        }





        private String VKT_ChangeStatus(Boolean IsModerator, String PlayerName, String UserID, String StatusConnection)
        {
            String Message = String.Empty;
            if (IsModerator)
                Message = LanguageEn ? $"▣ CONNECTION STATUS ▣\nInformation about the moderator:\n• Nickname: {PlayerName}\n• Steam64ID: {UserID} (https://steamcommunity.com/profiles/{UserID})\n• Status: {StatusConnection}" : $"▣ СТАТУС ПОДКЛЮЧЕНИЯ ▣\nИнформация о модераторе :\n• Ник : {PlayerName}\n• Steam64ID : {UserID} (https://steamcommunity.com/profiles/{UserID})\n• Статус : {StatusConnection}";
            else Message = LanguageEn ? $"▣ CONNECTION STATUS ▣\nInformation about the suspect:\n• Nickname: {PlayerName}\n• Steam64ID: {UserID} (https://steamcommunity.com/profiles/{UserID})\n• Status: {StatusConnection}" : $"▣ СТАТУС ПОДКЛЮЧЕНИЯ ▣\nИнформация о подозреваемом :\n• Ник : {PlayerName}\n• Steam64ID : {UserID} (https://steamcommunity.com/profiles/{UserID})\n• Статус : {StatusConnection}";

            return Message;
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            SteamAvatarAdd(player.UserIDString);
            RegisteredPlayer(player);

            CheckStatusPlayer(player);

            if (IsModerator(player))
                CheckStatusModerator(player);
        }
        /// <summary>
        /// Обновление 2.0.x
        /// - Добавлена поддержка нового формата Discord (с сохранением старого)
        /// - Перенес картинки UI с imgur на другой фото-обменник
        /// </summary>


        private const Boolean LanguageEn = false;
        private readonly Hash<String, NpcSound> CachedSound = new Hash<String, NpcSound>();



        private void ShowPlayersList(BasePlayer player, List<BasePlayer> playersList, List<FakePlayer> fakePlayers, Boolean IsModerator = false)
        {
            Int32 X = 0, Y = 0;
            if (fakePlayers != null)
            {
                foreach (FakePlayer fList in fakePlayers)
                {
                    DrawUI_TemplatePlayer(player, X, Y, fList.DisplayName, fList.UserID.ToString());

                    X++;
                    if (X != 3) continue;
                    X = 0;
                    Y++;
                }
            }
            else
            {
                foreach (BasePlayer pList in playersList)
                {
                    if (IsModerator)
                    {
                        DrawUI_TemplatePlayer_Moderator(player, Y, pList.UserIDString, CorrectedClanName(pList));
                        Y++;
                    }
                    else
                    {
                        DrawUI_TemplatePlayer(player, X, Y, CorrectedClanName(pList), pList.UserIDString);

                        X++;
                        if (X != 3) continue;
                        X = 0;
                        Y++;
                    }
                }
            }
        }
        private void GetPlayerCheckServerOzProtect(UInt64 TargetID)
        {
            if (String.IsNullOrWhiteSpace(config.ReferenceSettings.OzProtectSettings.OzProtectKey)) return;
            if (OzProtect_LocalRepository.ContainsKey(TargetID)) return;

            String API = $"https://api.ozliginus.ru/methods/ozprotect.getbans?steamid={TargetID}&ozprotectid={config.ReferenceSettings.OzProtectSettings.OzProtectKey}";
            try
            {
                webrequest.Enqueue(API, null, (code, response) =>
                {
                    OzResult resources = JsonConvert.DeserializeObject<OzResult>(response);
                    if (resources.response == null || !resources.status.Equals("success"))
                        return;

                    OzProtect_LocalRepository.Add(TargetID, new LocalRepositoryOzProtect());
                    foreach (OzResponse ozResponse in resources.response)
                    {
                        if (!OzProtect_LocalRepository[TargetID].LastBansServers.Contains(ozResponse.server.name))
                            OzProtect_LocalRepository[TargetID].LastBansServers.Add(ozResponse.server.name);
                    }

                }, this);
            }
            catch (Exception e)
            {
                PrintError(LanguageEn ? "OzProtect : We couldn't find player information with OzProtect, please check if your key is up to date or if OzProtect is available" : "OzProtect : Мы не смогли найти информацию об игроке с помощью OzProtect, проверьте актуальность вашего ключа или доступность OzProtect");
            }
        }

        private void DrawUI_TemplatePlayer(BasePlayer player, Int32 X, Int32 Y, String NickName, String UserID)
        {
            String Interface = InterfaceBuilder.GetInterface($"{InterfaceBuilder.UI_LAYER}_TEMPLATE_PLAYER");
            if (Interface == null) return;

            Interface = Interface.Replace("%STEAMID%", GetImage(UserID));
            Interface = Interface.Replace("%NICK%", NickName.Length > 7 ? NickName.Substring(0, 7).ToUpper() + ".." : NickName.ToUpper());
            Interface = Interface.Replace("%OFFSET_MIN%", $"{-219.214 + (X * 160)} {174.147 - (Y * 50)}");
            Interface = Interface.Replace("%OFFSET_MAX%", $"{-89.973 + (X * 160)} {210.147 - (Y * 50)}");
            Interface = Interface.Replace("%COMMAND%", $"report.panel select.player {UserID} false");

            Interface = Interface.Replace("%TITLE_PLAYER_NICK_NAME%", GetLang("TITLE_PLAYER_NICK_NAME", player.UserIDString));

            CuiHelper.AddUi(player, Interface);
        }
        private void CheckStatusPlayer(BasePlayer player, String ReasonDisconnected = null)
        {
            if (player == null) return;

            if (!PlayerChecks.ContainsKey(player.userID)) return;

            Boolean IsConsole = PlayerChecks[player.userID].ModeratorID == 0;
            BasePlayer Moderator = BasePlayer.FindByID(PlayerChecks[player.userID].ModeratorID);
            Configuration.NotifyDiscord.Webhooks.TemplatesNotify TemplateDiscord = config.NotifyDiscordSettings.WebhooksList.NotifyStatusPlayerOrModerator;

            if (Moderator == null && !IsConsole)
            {
                SendChat(GetLang("FUNCIONAL_CHANGE_STATUS_MODERATOR_DISCONNECTED", player.UserIDString), player);

                Timer WaitModerator = timer.Once(600f, () =>
                {
                    StopCheckedPlayer(player.userID, null, true);
                    SendChat(GetLang("FUNCIONAL_CHANGE_STATUS_MODERATOR_DISCONNECTED_FULL_LEAVE", player.UserIDString), player);
                });

                if (!TimerWaitChecked.ContainsKey(player.userID))
                    TimerWaitChecked.Add(player.userID, WaitModerator);
                else TimerWaitChecked[player.userID] = WaitModerator;

                return;
            }

            if (ReasonDisconnected != null)
            {
                if (config.CheckControllerSettings.StopCheckLeavePlayer)
                {
                    Timer WaitPlayer = timer.Once(900, () => { StopCheckedPlayer(player.userID, Moderator, true); });

                    if (!TimerWaitPlayer.ContainsKey(player.userID))
                        TimerWaitPlayer.Add(player.userID, WaitPlayer);
                    else TimerWaitPlayer[player.userID] = WaitPlayer;
                }

                if (IsConsole)
                {
                    Puts(LanguageEn ? $"The player's connection status has changed from server to : {ReasonDisconnected}" : $"У игрока изменился статус соединения с сервером на : {ReasonDisconnected}");
                    return;
                }
                DrawUI_Moderator_Checked_Menu_Status(Moderator, ReasonDisconnected);
                SendChat(GetLang("FUNCIONAL_CHANGE_STATUS_PLAYER_ALERT_MODERATOR", Moderator.UserIDString, ReasonDisconnected), Moderator);

                if (!String.IsNullOrWhiteSpace(TemplateDiscord.WebhookNotify))
                {
                    List<Fields> fields = DT_ChangeStatus(false, player.displayName, player.UserIDString, ReasonDisconnected);
                    SendDiscord(TemplateDiscord.WebhookNotify, fields, GetAuthorDiscord(TemplateDiscord), TemplateDiscord.Color);
                }

                SendVK(VKT_ChangeStatus(false, player.displayName, player.UserIDString, ReasonDisconnected));

                StopDamageRemove(player.userID);
                return;
            }

            if (!player.IsConnected) return;

            player.Invoke(() =>
            {
                SendChat(GetLang("FUNCIONAL_CHANGE_STATUS_PLAYER_ONLINE_ALERT_PLAYER", player.UserIDString), player);
                DrawUI_Player_Alert(player);

                if (config.CheckControllerSettings.UseDemo)
                    player.StartDemoRecording();

                if (IsConsole)
                {
                    Puts(LanguageEn ? "The player has connected to the server. Check continued" : "Игрок подключился к серверу. Проверка продолжена");
                    return;
                }
                if (Moderator == null) return;
                DrawUI_Moderator_Checked_Menu_Status(Moderator, GetLang("TITLE_PROFILE_MODERATOR_CHECKED_MENU_TITLE_STATUS_DEFAULT", Moderator.UserIDString));
                SendChat(GetLang("FUNCIONAL_CHANGE_STATUS_PLAYER_ONLINE_ALERT_MODERATOR", Moderator.UserIDString), Moderator);

                StopDamageAdd(player);
            }, 3f);

            if (!String.IsNullOrWhiteSpace(TemplateDiscord.WebhookNotify))
            {
                List<Fields> fields = DT_ChangeStatus(false, player.displayName, player.UserIDString, "Online");
                SendDiscord(TemplateDiscord.WebhookNotify, fields, GetAuthorDiscord(TemplateDiscord), TemplateDiscord.Color);
            }

            SendVK(VKT_ChangeStatus(false, player.displayName, player.UserIDString, "Online"));


            if (!TimerWaitPlayer.ContainsKey(player.userID)) return;
            if (TimerWaitPlayer[player.userID].Destroyed) return;

            TimerWaitPlayer[player.userID].Destroy();
            TimerWaitPlayer.Remove(player.userID);
        }

        private void BanPlayerRCC(UInt64 TargetID, String ReasonBan)
        {
            if (String.IsNullOrWhiteSpace(config.ReferenceSettings.RCCSettings.RCCKey)) return;
            String API = $"https://rustcheatcheck.ru/panel/api?action=addBan&key={config.ReferenceSettings.RCCSettings.RCCKey}&player={TargetID}&reason={ReasonBan}";
            try
            {
                webrequest.Enqueue(API, null, (code, response) => { }, this);
            }
            catch (Exception e)
            {
                PrintError(LanguageEn ? "RCC : We were unable to block the player using RCC, please check if your key is up to date or if RCC is available" : "RCC : Мы не смогли заблокировать игрока с помощью RCC, проверьте актуальность вашего ключа или доступность RCC");
            }
        }

        private const String ModeratorPermissions = "iqreportsystem.moderation";

        public class Fields
        {
            public String name { get; set; }
            public String value { get; set; }
            public bool inline { get; set; }
            public Fields(String name, String value, bool inline)
            {
                this.name = name;
                this.value = value;
                this.inline = inline;
            }
        }


        private static InterfaceBuilder _interface;

        private void DrawUI_ModeratorStitistics_Banner_AdditionalText(BasePlayer Moderator, String AdditionalText)
        {
            String Interface = InterfaceBuilder.GetInterface($"{InterfaceBuilder.UI_LAYER}_PROFILE_BANNER_TEMPLATE_ADDITIONAL_TEXT");
            if (Interface == null) return;

            Interface = Interface.Replace("%ADDITIONAL_TEXT%", AdditionalText);

            CuiHelper.AddUi(Moderator, Interface);
        }




        private void Init() => ReadData();

        object OnItemCraft(ItemCraftTask task, BasePlayer player, Item item)
        {
            if (!PlayerChecks.ContainsKey(player.userID)) return null;

            if (config.CheckControllerSettings.TrackCrafting)
            {
                BasePlayer Moderator = BasePlayer.FindByID(PlayerChecks[player.userID].ModeratorID);
                if (Moderator != null)
                    SendChat(GetLang("FUNCIONAL_MESSAGE_CHECK_AFK_PLAYER_START_CRAFTING", Moderator.UserIDString),
                        Moderator);
            }

            player.ResetInputIdleTime();
            return null;
        }

        private void SendSound(UInt64 netId, byte[] data)
        {
            if (!Net.sv.IsConnected())
                return;

            foreach (BasePlayer current in BasePlayer.activePlayerList.Where(current => current.IsConnected))
            {
                NetWrite netWrite = Net.sv.StartWrite();
                netWrite.PacketID(Message.Type.VoiceData);
                netWrite.UInt64(netId);
                netWrite.BytesWithSize(data);
                netWrite.Send(new SendInfo(current.Connection) { priority = Priority.Immediate });
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();

                if (config.NotifyVKSettings.VKTokenGroup == null)
                    config.NotifyVKSettings.VKTokenGroup = "";

                if (config.NotifyVKSettings.VKChatID == null)
                    config.NotifyVKSettings.VKChatID = "";
            }
            catch
            {
                PrintWarning(LanguageEn ? $"Error #58 reading configuration'oxide/config/{Name}', create a new configuration!" : $"Ошибка #58 чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        public Boolean IsFake(UInt64 userID)
        {
            if (!IQFakeActive || !config.ReferenceSettings.IQFakeActiveUse) return false;
            return (Boolean)IQFakeActive?.Call("IsFake", userID);
        }

        private String VKT_StopCheck(UInt64 TargetID, BasePlayer Moderator, Boolean AutoStop = false, Boolean IsConsole = false, Configuration.ReasonReport Verdict = null)
        {
            String ModeratorName = !IsConsole && Moderator != null ? Moderator.displayName : "Console";
            String ModeratorID = !IsConsole && Moderator != null ? Moderator.UserIDString : "Console";
            String Message = String.Empty;

            if (AutoStop)
            {
                Message = LanguageEn
                    ? $"▣ PLAYER CHECK AUTOMATICALLY COMPLETED ▣\nInformation about the moderator:\n• Nickname: {ModeratorName}\n• Steam64ID: {ModeratorID} (https://steamcommunity.com/profiles/{ModeratorID})\nInformation about the suspect:\n• Nickname: {PlayerChecks[TargetID].DisplayName}\n• Steam64ID: {TargetID} (https://steamcommunity.com/profiles/{TargetID})\nResult: The player's reports are not reset"
                    : $"▣ ПРОВЕРКА ИГРОКА ЗАВЕРШЕНА АВТОМАТИЧЕСКИ ▣\nИнформация о модераторе :\n• Ник : {ModeratorName}\n• Steam64ID : {ModeratorID} (https://steamcommunity.com/profiles/{ModeratorID})\nИнформация о подозреваемом :\n• Ник : {PlayerChecks[TargetID].DisplayName}\n• Steam64ID : {TargetID} (https://steamcommunity.com/profiles/{TargetID})\nРезультат : Репорты игрока не сброшены";
            }
            else
            {
                Message = LanguageEn
                    ? $"▣ PLAYER CHECK COMPLETED ▣\nInformation about the moderator:\n• Nickname: {ModeratorName}\n• Steam64ID: {ModeratorID} (https://steamcommunity.com/profiles/{ModeratorID})\nInformation about the suspect:\n• Nickname: {PlayerChecks[TargetID].DisplayName}\n• Steam64ID: {TargetID} (https://steamcommunity.com/profiles/{TargetID})\nResult: {(Verdict == null ? "No violations found" : Verdict.Title.LanguageEN)}"
                    : $"▣ ПРОВЕРКА ИГРОКА ЗАВЕРШЕНА ▣\nИнформация о модераторе :\n• Ник : {ModeratorName}\n• Steam64ID : {ModeratorID} (https://steamcommunity.com/profiles/{ModeratorID})\nИнформация о подозреваемом :\n• Ник : {PlayerChecks[TargetID].DisplayName}\n• Steam64ID : {TargetID} (https://steamcommunity.com/profiles/{TargetID})\nРезультат : {(Verdict == null ? "Нарушений не выявлено" : Verdict.Title.LanguageRU)}";
            }

            return Message;
        }

        void SyncReservedFinish(String JSON)
        {
            if (!config.ReferenceSettings.IQFakeActiveUse) return;
            List<FakePlayer> ContentDeserialize = JsonConvert.DeserializeObject<List<FakePlayer>>(JSON);
            PlayerBases = ContentDeserialize;

            foreach (FakePlayer fakePlayer in PlayerBases)
                SteamAvatarAdd(fakePlayer.UserID.ToString());

            PrintWarning("IQReportSystem - успешно синхронизирована с IQFakeActive");
            PrintWarning("=============SYNC==================");
        }

        private void DrawUI_PoopUp_Moderator_Panel_Info(BasePlayer player, BasePlayer Target, String TitlePanel, List<Configuration.LangText> InfoList, String OffsetMin, String OffsetMax, List<String> AlternativeInfoList = null)
        {
            String Interface = InterfaceBuilder.GetInterface($"{InterfaceBuilder.UI_LAYER}_POOPUP_MODERATOR_INFO_BLOCK");
            if (Interface == null) return;

            Interface = Interface.Replace("%TITLE_PANEL%", TitlePanel);
            Interface = Interface.Replace("%OFFSET_MIN%", OffsetMin);
            Interface = Interface.Replace("%OFFSET_MAX%", OffsetMax);

            CuiHelper.AddUi(player, Interface);

            if (AlternativeInfoList != null)
            {
                if (AlternativeInfoList.Count == 0)
                {
                    DrawUI_PoopUp_Moderator_InfoText(player, 0, GetLang("TITLE_POOPUP_MODERATION_INFO_BLOCK_EMPTY", player.UserIDString));
                    return;
                }
                for (Int32 Y = 0; Y < AlternativeInfoList.Count; Y++)
                    DrawUI_PoopUp_Moderator_InfoText(player, Y, AlternativeInfoList[Y]);

                return;
            }

            if (InfoList.Count == 0)
            {
                DrawUI_PoopUp_Moderator_InfoText(player, 0, GetLang("TITLE_POOPUP_MODERATION_INFO_BLOCK_EMPTY", player.UserIDString));
                return;
            }

            for (Int32 Y = 0; Y < InfoList.Count; Y++)
                DrawUI_PoopUp_Moderator_InfoText(player, Y, InfoList[Y].GetReasonTitle(player.userID));
        }

        internal class LocalRepositoryOzProtect
        {
            public List<String> LastBansServers = new List<String>();
        }
        private void DrawUI_PoopUp_Moderator_InfoText(BasePlayer player, Int32 Y, String Text)
        {
            String Interface = InterfaceBuilder.GetInterface($"{InterfaceBuilder.UI_LAYER}_POOPUP_MODERATOR_INFO_BLOCK_TEXT_TEMPLATE");
            if (Interface == null) return;

            Interface = Interface.Replace("%REASON_TITLE%", Text);
            Interface = Interface.Replace("%OFFSET_MIN%", $"-51.667 {35.133 - (Y * 20)}");
            Interface = Interface.Replace("%OFFSET_MAX%", $"51.667 {49.8 - (Y * 20)}");

            CuiHelper.AddUi(player, Interface);
        }

        private void DrawUI_Moderator_Checked_Menu_Discord(BasePlayer moderator, String Discord)
        {
            String Interface = InterfaceBuilder.GetInterface($"{InterfaceBuilder.UI_LAYER}_DISCORD_STATUS_CHECKED_MODERATOR");
            if (Interface == null) return;

            Interface = Interface.Replace("%TITLE_PROFILE_MODERATOR_CHECKED_MENU_TITLE_DISCORD%", GetLang("TITLE_PROFILE_MODERATOR_CHECKED_MENU_TITLE_DISCORD", moderator.UserIDString, Discord));

            CuiHelper.DestroyUi(moderator, "InfoDiscord");
            CuiHelper.AddUi(moderator, Interface);
        }

        private class ProcessCheckRepository
        {
            public String DiscordTarget;
            public String DisplayName;

            public UInt64 ModeratorID;
        }


        public String FindFakeName(ulong userID)
        {
            if (!IQFakeActive || !config.ReferenceSettings.IQFakeActiveUse) return "PLAYER";
            return (string)IQFakeActive?.Call("FindFakeName", userID);
        }

        public class Authors
        {
            public String name { get; set; }
            public String url { get; set; }
            public String icon_url { get; set; }
            public String proxy_icon_url { get; set; }
            public Authors(String name, String url, String icon_url, String proxy_icon_url)
            {
                this.name = name;
                this.url = url;
                this.icon_url = icon_url;
                this.proxy_icon_url = proxy_icon_url;
            }
        }
        private List<Fields> DT_PlayerSendReport(BasePlayer Sender, UInt64 TargetID, String Reason)
        {
            List<Fields> fields = new List<Fields>
            {
                new Fields(LanguageEn ? "New complaint received :" : "Получена новая жалоба :", "", false),
                new Fields("", "", false),
                new Fields(LanguageEn ? "Information about the sender :" : "Информация об отправителе :", "", false),
                new Fields("", "", false),
                new Fields(LanguageEn ? "Nick" : "Ник", $"{Sender.displayName}", true),
                new Fields("Steam64ID", $"[{Sender.userID}](https://steamcommunity.com/profiles/{Sender.userID})", true),
                new Fields("", "", false),
                new Fields(LanguageEn ? "Information about the suspect :" : "Информация о подозреваемом :", "", false),
                new Fields("", "", false),
                new Fields(LanguageEn ? "Nick" : "Ник", $"{covalence.Players.FindPlayerById(TargetID.ToString()).Name ?? "EMPTY"}", true),
                new Fields("Steam64ID", $"[{TargetID}](https://steamcommunity.com/profiles/{TargetID})", true),
                new Fields(LanguageEn ? "Reason for complaint :" : "Причина жалобы :", Reason, false),
            };

            return fields;
        }


        private void SendDiscord(String Webhook, List<Fields> fields, Authors Authors, Int32 Color)
        {
            if (Webhook == null || String.IsNullOrWhiteSpace(Webhook)) return;
            FancyMessage newMessage = new FancyMessage(null, false, new FancyMessage.Embeds[1] { new FancyMessage.Embeds(null, Color, fields, Authors) });

            Request($"{Webhook}", newMessage.toJSON());
        }

        private Authors GetAuthorDiscord(Configuration.NotifyDiscord.Webhooks.TemplatesNotify templatesNotify) => new Authors(templatesNotify.AuthorName, null, templatesNotify.IconURL, null);

        private void Request(String url, String payload, Action<Int32> callback = null)
        {
            Dictionary<String, String> header = new Dictionary<String, String>();
            header.Add("Content-Type", "application/json");
            webrequest.Enqueue(url, payload, (code, response) =>
            {
                if (code != 200 && code != 204)
                {
                    if (response != null)
                    {
                        try
                        {
                            JObject json = JObject.Parse(response);
                            if (code == 429)
                            {
                                Single seconds = Single.Parse(Math.Ceiling((Double)(Int32)json["retry_after"] / 1000).ToString());
                            }
                            else
                            {
                                PrintWarning($" Discord rejected that payload! Responded with \"{json["message"].ToString()}\" Code: {code}");
                            }
                        }
                        catch
                        {
                            PrintWarning($"Failed to get a valid response from discord! Error: \"{response}\" Code: {code}");
                        }
                    }
                    else
                    {
                        PrintWarning($"Discord didn't respond (down?) Code: {code}");
                    }
                }
                try
                {
                    callback?.Invoke(code);
                }
                catch (Exception ex) { }

            }, this, RequestMethod.POST, header, timeout: 10F);
        }

        private List<Fields> DT_StopCheck(UInt64 TargetID, BasePlayer Moderator, Boolean AutoStop = false, Boolean IsConsole = false, Configuration.ReasonReport Verdict = null)
        {
            String ModeratorName = !IsConsole && Moderator != null ? Moderator.displayName : "Console";
            String ModeratorID = !IsConsole && Moderator != null ? Moderator.UserIDString : "Console";
            List<Fields> fields;

            if (AutoStop)
            {
                fields = new List<Fields>
                {
                    new Fields(LanguageEn ? "Player verification is completed automatically :" : "Проверка игрока завершена автоматически :", "", false),
                    new Fields("", "", false),
                    new Fields(LanguageEn ? "Suspect Information:" : "Информация о подозреваемом :", "", false),
                    new Fields("", "", false),
                    new Fields(LanguageEn ? "Nick" : "Ник", $"{PlayerChecks[TargetID].DisplayName}", true),
                    new Fields("SteamID", $"{TargetID}", true),
                    new Fields("Результат", LanguageEn ? "The player's reports are not reset" : "Репорты игрока не сброшены", false),
                };
            }
            else
            {
                fields = new List<Fields>
                {
                    new Fields(LanguageEn ? "Player check completed :" : "Завершена проверка игрока :", "", false),
                    new Fields("", "", false),
                    new Fields(LanguageEn ? "Moderator Information :" : "Информация о модераторе :", "", false),
                    new Fields("", "", false),
                    new Fields(LanguageEn ? "Nick" : "Ник", $"{ModeratorName}", true),
                    new Fields("Steam64ID", $"[{ModeratorID}](https://steamcommunity.com/profiles/{ModeratorID})", true),
                    new Fields("", "", false),
                    new Fields(LanguageEn ? "Suspect Information:" : "Информация о подозреваемом :", "", false),
                    new Fields("", "", false),
                    new Fields(LanguageEn ? "Nick" : "Ник", $"{PlayerChecks[TargetID].DisplayName}", true),
                    new Fields("SteamID", $"{TargetID}", true),
                    new Fields("Результат", $"{(Verdict == null ? (LanguageEn ? "No violations found" : "Нарушений не выявлено") : LanguageEn ? Verdict.Title.LanguageEN : Verdict.Title.LanguageRU)}", false),
                };
            }

            return fields;
        }

        [PluginReference] Plugin IQChat, ImageLibrary, IQFakeActive, NoEscape, EventHelper, Battles, Duel, Duelist, ArenaTournament, Friends, Clans, MultiFighting, StopDamageMan;

        private void AddCooldown(UInt64 SenderID, UInt64 TargetID)
        {
            if (config.ReportSendControllerSettings.CooldownReport == 0 && !config.ReportSendControllerSettings.NoRepeatReport) return;
            if (!PlayerRepositories.ContainsKey(SenderID))
            {
                PlayerRepositories.Add(SenderID, new PlayerRepository
                {
                    ReportedList = new Dictionary<UInt64, Double>(),
                    Cooldown = 0
                });
            }

            PlayerRepositories[SenderID].AddCooldown(TargetID);
        }
        private void OnServerInitialized()
        {
            PreLoadedPlugin();
            StartPluginLoad();

            if (IQFakeActive && config.ReferenceSettings.IQFakeActiveUse)
            {
                foreach (FakePlayer fakePlayer in PlayerBases)
                    SteamAvatarAdd(fakePlayer.UserID.ToString());
            }

            permission.RegisterPermission(ModeratorPermissions, this);
            permission.RegisterPermission(HideMenuPermissions, this);

            if (!config.CheckControllerSettings.UseSoundAlert) return;

            LoadDataSound("ALERT_REPORT_EN");
            LoadDataSound("ALERT_REPORT_RU");
        }




        private void OnPlayerReported(BasePlayer reporter, String targetName, String targetId, String subject, String message, String type)
        {
            if (!config.ReportF7AndGameMenuSettings.UseFunction) return;
            if (!type.Equals("cheat")) return;
            SendReportPlayer(reporter, UInt64.Parse(targetId), config.ReportF7AndGameMenuSettings.DefaultIndexReason);
        }
        private Boolean IsFriendStartChecked(UInt64 userID, UInt64 targetID) => config.ReferenceSettings.FriendsSetting.StartCheckedFriend && IsFriends(userID, targetID);
        private Dictionary<UInt64, ModeratorInformation> ModeratorInformations = new Dictionary<UInt64, ModeratorInformation>();



        [ChatCommand("report")]
        private void ChatCommandReport(BasePlayer player, String cmd, String[] args)
        {
            if (player == null) return;
            if (_interface == null) return;
            DrawUI_Report_Panel(player);
        }



        private void CheckStatusModerator(BasePlayer Moderator, String ReasonDisconnected = null)
        {
            if (Moderator == null) return;
            KeyValuePair<UInt64, ProcessCheckRepository> ModeratorCheckeds = PlayerChecks.FirstOrDefault(m => m.Value.ModeratorID.Equals(Moderator.userID));
            if (ModeratorCheckeds.Value == null) return;

            Configuration.NotifyDiscord.Webhooks.TemplatesNotify TemplateDiscord = config.NotifyDiscordSettings.WebhooksList.NotifyStatusPlayerOrModerator;

            UInt64 TargetID = ModeratorCheckeds.Key;
            BasePlayer Target = BasePlayer.FindByID(TargetID);

            if (ReasonDisconnected != null)
            {
                if (Target == null)
                {
                    StopCheckedPlayer(TargetID, Moderator);
                    return;
                }

                SendChat(GetLang("FUNCIONAL_CHANGE_STATUS_MODERATOR_DISCONNECTED", Target.UserIDString), Target);

                Timer WaitModerator = timer.Once(600f, () =>
                {
                    StopCheckedPlayer(Target.userID, null, true);
                    SendChat(GetLang("FUNCIONAL_CHANGE_STATUS_MODERATOR_DISCONNECTED_FULL_LEAVE", Target.UserIDString), Target);
                });

                if (!TimerWaitChecked.ContainsKey(Target.userID))
                    TimerWaitChecked.Add(Target.userID, WaitModerator);
                else TimerWaitChecked[Target.userID] = WaitModerator;

                if (!String.IsNullOrWhiteSpace(TemplateDiscord.WebhookNotify))
                {
                    List<Fields> fields = DT_ChangeStatus(true, Moderator.displayName, Moderator.UserIDString, ReasonDisconnected);
                    SendDiscord(TemplateDiscord.WebhookNotify, fields, GetAuthorDiscord(TemplateDiscord), TemplateDiscord.Color);
                }

                SendVK(VKT_ChangeStatus(true, Moderator.displayName, Moderator.UserIDString, ReasonDisconnected));
                return;
            }

            if (!TimerWaitChecked.ContainsKey(TargetID)) return;
            if (TimerWaitChecked[TargetID].Destroyed) return;

            TimerWaitChecked[TargetID].Destroy();
            TimerWaitChecked.Remove(TargetID);

            DrawUI_Moderator_Checked_Menu(Moderator, TargetID);

            String TargetStatus = GetLang("TITLE_PROFILE_MODERATOR_CHECKED_MENU_TITLE_STATUS_DEFAULT", Moderator.UserIDString);
            if (Target == null || !Target.IsConnected)
            {
                TargetStatus = "Disconnected";
                SendChat(GetLang("FUNCIONAL_CHANGE_STATUS_PLAYER_ALERT_MODERATOR", Moderator.UserIDString, TargetStatus), Moderator);
            }

            DrawUI_Moderator_Checked_Menu_Status(Moderator, TargetStatus);
            DrawUI_Moderator_Checked_Menu_Discord(Moderator, String.IsNullOrWhiteSpace(PlayerChecks[TargetID].DiscordTarget) ? GetLang("TITLE_PROFILE_MODERATOR_CHECKED_MENU_TITLE_DISCORD_EMPTY", Moderator.UserIDString) : PlayerChecks[TargetID].DiscordTarget);

            if (Target != null)
                SendChat(GetLang("FUNCIONAL_CHANGE_STATUS_MODERATOR_RECONNECTED", Target.UserIDString), Target);

            if (!String.IsNullOrWhiteSpace(TemplateDiscord.WebhookNotify))
            {
                List<Fields> fields = DT_ChangeStatus(true, Moderator.displayName, Moderator.UserIDString, "Online");
                SendDiscord(TemplateDiscord.WebhookNotify, fields, GetAuthorDiscord(TemplateDiscord), TemplateDiscord.Color);
            }

            SendVK(VKT_ChangeStatus(true, Moderator.displayName, Moderator.UserIDString, "Online"));

        }
        private void StartCheckRCC(UInt64 TargetID, UInt64 ModerID)
        {
            if (String.IsNullOrWhiteSpace(config.ReferenceSettings.RCCSettings.RCCKey)) return;
            String API = $"https://rustcheatcheck.ru/panel/api?action=addPlayer&key={config.ReferenceSettings.RCCSettings.RCCKey}&player={TargetID}";
            if (ModerID != 0)
                API += $"&moder={ModerID}";

            try
            {
                webrequest.Enqueue(API, null, (code, response) => { }, this);
            }
            catch (Exception e)
            {
                PrintError(LanguageEn ? "RCC : We were unable to get the player to check with RCC, please check if your key is up to date or if RCC is available" : "RCC : Мы не смогли вызвать игрока на проверку с помощью RCC, проверьте актуальность вашего ключа или доступность RCC");
            }
        }


        public class FancyMessage
        {
            public String content { get; set; }
            public Boolean tts { get; set; }
            public Embeds[] embeds { get; set; }

            public class Embeds
            {
                public String title { get; set; }
                public Int32 color { get; set; }
                public List<Fields> fields { get; set; }
                public Authors author { get; set; }

                public Embeds(String title, Int32 color, List<Fields> fields, Authors author)
                {
                    this.title = title;
                    this.color = color;
                    this.fields = fields;
                    this.author = author;

                }
            }

            public FancyMessage(String content, bool tts, Embeds[] embeds)
            {
                this.content = content;
                this.tts = tts;
                this.embeds = embeds;
            }

            public String toJSON() => JsonConvert.SerializeObject(this);
        }

        private void RequestVK(String Message)
        {
            try
            {
                webrequest.Enqueue(GetUrlVK(Message), null, (code, response) => { }, this, RequestMethod.GET, timeout: 10F);
            }
            catch (Exception ex)
            {
                PrintWarning(LanguageEn ? "Check the correctness of the entered data for VK! Vkontakte returns an error of your data!" : "Проверьте корректность введенных данных для ВК! Вконтакте возвращает ошибку ваших данных!");
            }
        }
        private class PlayerRepository
        {
            public Boolean IsCooldown(UInt64 TargetID)
            {
                if (config.ReportSendControllerSettings.CooldownRepeatOrAll)
                {
                    if (IsReportedPlayer(TargetID))
                        return ReportedList[TargetID] > CurrentTime;
                }
                else return Cooldown > CurrentTime;

                return false;
            }

            public Int32 GetCooldownLeft(UInt64 TargetID)
            {
                if (config.ReportSendControllerSettings.CooldownRepeatOrAll)
                {
                    if (IsReportedPlayer(TargetID))
                        return Convert.ToInt32(ReportedList[TargetID] - CurrentTime);
                }
                else return Convert.ToInt32(Cooldown - CurrentTime);

                return 0;
            }
            public Dictionary<UInt64, Double> ReportedList = new Dictionary<UInt64, Double>();

            private Boolean IsReportedPlayer(UInt64 TargetID) => ReportedList.ContainsKey(TargetID);

            public void AddCooldown(UInt64 TargetID)
            {
                Int32 TimeCooldown = Convert.ToInt32(config.ReportSendControllerSettings.CooldownReport + CurrentTime);

                if (config.ReportSendControllerSettings.CooldownRepeatOrAll ||
                    config.ReportSendControllerSettings.NoRepeatReport)
                {
                    if (IsReportedPlayer(TargetID))
                        ReportedList[TargetID] = TimeCooldown;
                    else ReportedList.Add(TargetID, TimeCooldown);
                }
                else Cooldown = TimeCooldown;
            }
            public Double Cooldown;
            public Boolean IsRepeatReported(UInt64 TargetID) => config.ReportSendControllerSettings.NoRepeatReport && IsReportedPlayer(TargetID);
        }



        private void DrawUI_PoopUp_Moderator(BasePlayer player, BasePlayer Target)
        {
            String Interface = InterfaceBuilder.GetInterface($"{InterfaceBuilder.UI_LAYER}_POOPUP_MODERATOR");
            if (Interface == null) return;

            PlayerInformation InformationTarget = PlayerInformations[Target.userID];
            String LastModerator = String.IsNullOrWhiteSpace(InformationTarget.LastModerator) ? GetLang("TITLE_POOPUP_MODERATION_NO_CHECKED", player.UserIDString) : InformationTarget.LastModerator;
            String AmountCheck = InformationTarget.AmountChecked == 0 ? GetLang("TITLE_POOPUP_MODERATION_NO_CHECKED", player.UserIDString) : InformationTarget.AmountChecked.ToString();

            Interface = Interface.Replace("%TITLE_POOPUP_MODERATION_REPORTS_TITLE%", GetLang("TITLE_POOPUP_MODERATION_REPORTS_TITLE", player.UserIDString));
            Interface = Interface.Replace("%TITLE_POOPUP_MODERATION_AMOUNT_CHECK_TITLE%", GetLang("TITLE_POOPUP_MODERATION_AMOUNT_CHECK_TITLE", player.UserIDString));
            Interface = Interface.Replace("%TITLE_POOPUP_MODERATION_LAST_CHECK_TITLE%", GetLang("TITLE_POOPUP_MODERATION_LAST_CHECK_TITLE", player.UserIDString));
            Interface = Interface.Replace("%TITLE_PLAYER_STEAMID%", GetLang("TITLE_PLAYER_STEAMID", player.UserIDString));
            Interface = Interface.Replace("%TITLE_PLAYER_NICK_NAME%", GetLang("TITLE_PLAYER_NICK_NAME", player.UserIDString));
            Interface = Interface.Replace("%TITLE_POOPUP_MODERATION_INFO_BUTTON_START_CHECK%", GetLang("TITLE_POOPUP_MODERATION_INFO_BUTTON_START_CHECK", player.UserIDString));

            Interface = Interface.Replace("%PLAYER_NAME%", Target.displayName.Length > 7 ? Target.displayName.Substring(0, 7).ToUpper() + ".." : Target.displayName.ToUpper());
            Interface = Interface.Replace("%PLAYER_USERID%", Target.UserIDString);
            Interface = Interface.Replace("%AMOUNT_REPORTS%", InformationTarget.Reports.ToString());
            Interface = Interface.Replace("%AMOUNT_CHECK%", AmountCheck);
            Interface = Interface.Replace("%LAST_MODER_CHECK_NAME%", LastModerator);
            Interface = Interface.Replace("%AVATAR%", GetImage(Target.UserIDString));
            Interface = Interface.Replace("%COMMAND_START%", $"report.panel start.check.player {Target.UserIDString}");

            CuiHelper.AddUi(player, Interface);

            ///История жалоб
            DrawUI_PoopUp_Moderator_Panel_Info(player, Target, GetLang("TITLE_POOPUP_MODERATION_HISTORY_REPORTS_TITLE", player.UserIDString), InformationTarget.ReasonHistory.Take(6).ToList(), "-232.807 -141.2", "-102.14 18.8");

            if (!String.IsNullOrEmpty(config.ReferenceSettings.RCCSettings.RCCKey))
            {
                ///История проверок на серверах [RCC]
                DrawUI_PoopUp_Moderator_Panel_Info(player, Target,
                    GetLang("TITLE_POOPUP_MODERATION_INFO_CHECK_SERVERS_RCC", player.UserIDString), null,
                    "-65.333 -141.2", "65.333 18.8", GetServersCheckRCC(Target.userID).Take(6).ToList());

                ///История банов на серверах [RCC]
                DrawUI_PoopUp_Moderator_Panel_Info(player, Target,
                    GetLang("TITLE_POOPUP_MODERATION_INFO_BANS_SERVERS_RCC", player.UserIDString), null,
                    "102.833 -141.2", "233.5 18.8", GetServersBansRCC(Target.userID).Take(6).ToList());

                return;
            }

            if (!String.IsNullOrWhiteSpace(config.ReferenceSettings.OzProtectSettings.OzProtectKey))
            {
                ///Тиммейты игрока
                DrawUI_PoopUp_Moderator_Panel_Info(player, Target,
                    GetLang("TITLE_POOPUP_MODERATION_INFO_TEAMS_NAME_PLAYER", player.UserIDString), null,
                    "-65.333 -141.2", "65.333 18.8", GetTeamsNames(Target).Take(6).ToList());

                ///История банов на серверах [OzProtect]
                DrawUI_PoopUp_Moderator_Panel_Info(player, Target,
                    GetLang("TITLE_POOPUP_MODERATION_INFO_BANS_SERVERS_OZPROTECT", player.UserIDString), null,
                    "102.833 -141.2", "233.5 18.8", GetServersBansOzProtect(Target.userID).Take(6).ToList());

                return;
            }

            ///Тиммейты игрока
            DrawUI_PoopUp_Moderator_Panel_Info(player, Target,
                GetLang("TITLE_POOPUP_MODERATION_INFO_TEAMS_NAME_PLAYER", player.UserIDString), null,
                "-65.333 -141.2", "65.333 18.8", GetTeamsNames(Target).Take(6).ToList());
        }

        private void ReadData()
        {
            PlayerInformations = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<UInt64, PlayerInformation>>("IQSystem/IQReportSystem/PlayerInformations");
            ModeratorInformations = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<UInt64, ModeratorInformation>>("IQSystem/IQReportSystem/ModeratorInformations");
        }
        private Dictionary<UInt64, Timer> TimerWaitPlayer = new Dictionary<UInt64, Timer>();

        void OnItemCraftCancelled(ItemCraftTask task, ItemCrafter crafter)
        {
            BasePlayer player = crafter.owner;
            if (player == null) return;

            if (!PlayerChecks.ContainsKey(player.userID)) return;

            if (config.CheckControllerSettings.TrackCrafting)
            {
                BasePlayer Moderator = BasePlayer.FindByID(PlayerChecks[player.userID].ModeratorID);
                if (Moderator != null)
                    SendChat(GetLang("FUNCIONAL_MESSAGE_CHECK_AFK_PLAYER_CANCELLED_CRAFTING", Moderator.UserIDString), Moderator);
            }

            player.ResetInputIdleTime(); ;
        }

        private String VKT_PlayerSendReport(BasePlayer Sender, UInt64 TargetID, String Reason)
        {
            String Message = LanguageEn ? $"▣ NEW COMPLAINT ▣" +
                                          $"\nInformation about the sender:\n• Nickname: {Sender.displayName}\n• Steam64ID: {Sender.userID} (https://steamcommunity.com/profiles/{Sender.userID})" +
                                          $"\nInformation about the suspect:\n• Nickname: {covalence.Players.FindPlayerById(TargetID.ToString()).Name ?? "EMPTY"}\n• Steam64ID: {TargetID} (https://steamcommunity.com/profiles/{TargetID})" +
                                          $"\nComplaint reason: {Reason}" : $"▣ НОВАЯ ЖАЛОБА ▣" +
                                                                            $"\nИнформация об отправителе :\n• Ник : {Sender.displayName}\n• Steam64ID : {Sender.userID} (https://steamcommunity.com/profiles/{Sender.userID})" +
                                                                            $"\nИнформация о подозреваемом :\n• Ник : {covalence.Players.FindPlayerById(TargetID.ToString()).Name ?? "EMPTY"}\n• Steam64ID : {TargetID} (https://steamcommunity.com/profiles/{TargetID})" +
                                                                            $"\nПричина жалобы : {Reason}";

            return Message;
        }

        private void WriteData()
        {
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQSystem/IQReportSystem/PlayerInformations", PlayerInformations);
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQSystem/IQReportSystem/ModeratorInformations", ModeratorInformations);
        }



        private Dictionary<UInt64, PlayerInformation> PlayerInformations = new Dictionary<UInt64, PlayerInformation>();

        private class ModeratorInformation
        {
            public Int32 AmountChecked = 0;
            public Int32 AmountBans = 0;
            public Int32 AverageRaiting = 0;
            public List<Int32> OneScore = new List<Int32>();
            public List<Int32> TwoScore = new List<Int32>();
            public List<Int32> ThreeScore = new List<Int32>();

            public Int32 GetAverageRaiting()
            {
                Int32 AchiveRaitingOne = GetAverageRaitingAchive(OneScore);
                Int32 AchiveRaitingTwo = GetAverageRaitingAchive(TwoScore);
                Int32 AchiveRaitingThree = GetAverageRaitingAchive(ThreeScore);

                Int32 FullRaiting = AchiveRaitingOne + AchiveRaitingTwo + AchiveRaitingThree;

                AverageRaiting = FullRaiting / 3;
                return AverageRaiting;
            }
            public Int32 GetAverageRaitingAchive(List<Int32> Score)
            {
                Int32 AverageRaitingAchive = 0;
                Int32 RaitingFull = Score.Sum();

                Int32 FormulDivision = Score.Count == 0 ? 1 : Score.Count;
                AverageRaitingAchive = RaitingFull / FormulDivision;
                return AverageRaitingAchive;
            }
        }
        private void SoundPlay(BasePlayer player)
        {
            SpeakerEntityMgr.SpeakerEntity speaker = SpeakerEntityMgr.Create(player);

            speaker.SendEntitities();
            String SoundName = lang.GetLanguage(player.UserIDString).Equals("ru") ? "ALERT_REPORT_RU" : "ALERT_REPORT_EN";

            Coroutine routine = ServerMgr.Instance.StartCoroutine(SendSounds(player, SoundName, speaker));

            if (!RoutineSounds.ContainsKey(player))
                RoutineSounds.Add(player, routine);
            else
            {
                if (RoutineSounds[player] != null)
                    ServerMgr.Instance.StopCoroutine(RoutineSounds[player]);

                RoutineSounds[player] = routine;
            }
            timer.Once(15f, () =>
            {
                speaker.Kill();

                if (RoutineSounds[player] != null)
                    ServerMgr.Instance.StopCoroutine(RoutineSounds[player]);
            });
        }

        private void StartCheckOzProtect(UInt64 TargetID, UInt64 ModerID)
        {
            if (ModerID == 0) return;
            if (String.IsNullOrWhiteSpace(config.ReferenceSettings.OzProtectSettings.OzProtectKey)) return;
            String API = $"https://api.ozliginus.ru/methods/ozprotect.call?checking={ModerID}&suspect={TargetID}&ozprotectid={config.ReferenceSettings.OzProtectSettings.OzProtectKey}&minutes=30";

            try
            {
                webrequest.Enqueue(API, null, (code, response) => { }, this);
            }
            catch (Exception e)
            {
                PrintError(LanguageEn ? "OzProtect : We were unable to get the player to check with OzProtect, please check if your key is up to date or if OzProtect is available" : "OzProtect : Мы не смогли вызвать игрока на проверку с помощью OzProtect, проверьте актуальность вашего ключа или доступность OzProtect");
            }
        }
        private Dictionary<UInt64, Timer> TimerWaitChecked = new Dictionary<UInt64, Timer>();

        private class Response
        {
            public List<String> last_ip;
            public String last_nick;
            public List<UInt64> another_accs;
            public List<last_checks> last_check;
            public class last_checks
            {
                public UInt64 moderSteamID;
                public String serverName;
                public Int32 time;
            }
            public List<RustCCBans> bans;
            public class RustCCBans
            {
                public Int32 banID;
                public String reason;
                public String serverName;
                public Int32 OVHserverID;
                public Int32 banDate;
            }
        }






        private void DrawUI_Report_Panel(BasePlayer player)
        {
            String Interface = InterfaceBuilder.GetInterface($"{InterfaceBuilder.UI_LAYER}_BACKGORUND");
            if (Interface == null) return;

            Interface = Interface.Replace("%TITLE_PLAYER_HEADER_TITLE_SEND_REPORT%", GetLang("TITLE_PLAYER_HEADER_TITLE_SEND_REPORT", player.UserIDString));
            Interface = Interface.Replace("%TITLE_PLAYER_HEADER_TITLE_DESC_SEND_REPORT%", GetLang("TITLE_PLAYER_HEADER_TITLE_DESC_SEND_REPORT", player.UserIDString));
            Interface = Interface.Replace("%TITLE_PROFILE_INFO_CHECKED%", GetLang("TITLE_PROFILE_INFO_CHECKED", player.UserIDString, PlayerInformations[player.userID].AmountChecked));
            Interface = Interface.Replace("%NICK_PROFILE%", player.displayName.Length > 7 ? player.displayName.Substring(0, 7).ToUpper() + ".." : player.displayName.ToUpper());
            Interface = Interface.Replace("%AVATAR_PLAYER%", _.GetImage(player.UserIDString));
            Interface = Interface.Replace("%TITLE_NAME_REPORT_SYSTEM%", GetLang("TITLE_NAME_REPORT_SYSTEM", player.UserIDString));
            Interface = Interface.Replace("%TITLE_CLOSE_BUTTON_REPORT%", GetLang("TITLE_CLOSE_BUTTON_REPORT", player.UserIDString));

            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_REPORT_PANEL);
            CuiHelper.AddUi(player, Interface);

            DrawUI_PlayerPanel(player);
            DrawUI_LeftMenu(player);
            DrawUI_HeaderUI_Search(player);

            if (IsModerator(player))
                DrawUI_ModeratorStatistics(player);
        }


        private void BanPlayerOzProtect(UInt64 TargetID, UInt64 ModerID, String ReasonBan)
        {
            if (String.IsNullOrWhiteSpace(config.ReferenceSettings.OzProtectSettings.OzProtectKey)) return;
            String API = $"https://api.ozliginus.ru/methods/ozprotect.useredit?admin={ModerID}&steamid={TargetID}&method=ban&reason={ReasonBan}&ozprotectid={config.ReferenceSettings.OzProtectSettings.OzProtectKey}";
            try
            {
                webrequest.Enqueue(API, null, (code, response) => { }, this);
            }
            catch (Exception e)
            {
                PrintError(LanguageEn ? "OzProtect : We were unable to block the player using OzProtect, please check if your key is up to date or if OzProtect is available" : "OzProtect : Мы не смогли заблокировать игрока с помощью OzProtect, проверьте актуальность вашего ключа или доступность OzProtect");
            }
        }
        private void DrawUI_HeaderUI_Search(BasePlayer player, Boolean IsModerator = false)
        {
            String Interface = InterfaceBuilder.GetInterface($"{InterfaceBuilder.UI_LAYER}_SEARCH_HEADER");
            if (Interface == null) return;

            Interface = Interface.Replace("%ISMODERATOR%", $"{IsModerator}");
            Interface = Interface.Replace("%TITLE_PLAYER_HEADER_TITLE_SEARCH_PLAYER%", GetLang("TITLE_PLAYER_HEADER_TITLE_SEARCH_PLAYER", player.UserIDString));

            CuiHelper.DestroyUi(player, "InputPanelSearch" + ".Input");
            CuiHelper.AddUi(player, Interface);
        }

        private String GetUrlVK(String Message)
        {
            String ApiKey = config.NotifyVKSettings.VKTokenGroup;
            Int32 RandomID = Oxide.Core.Random.Range(0, 99999);
            Int32 PeerID = 2000000000 + Convert.ToInt32(config.NotifyVKSettings.VKChatID);

            String url = $"https://api.vk.com/method/messages.send?chat_id=1&random_id={RandomID}&peer_id={PeerID}&message={Message}&access_token={ApiKey}&v=5.131";
            return url;
        }

        private String CorrectedClanName(BasePlayer player)
        {
            String ClanTag = GetClanTag(player.UserIDString);
            String pattern = @"\[.*?\]";

            String CorrectedResult = ClanTag == null || String.IsNullOrWhiteSpace(ClanTag)
                ? player.displayName
                : Regex.Replace(player.displayName, pattern, String.Empty);

            if (String.IsNullOrWhiteSpace(CorrectedResult) || CorrectedResult == null)
                CorrectedResult = player.displayName;

            return CorrectedResult;
        }



        private List<Fields> DT_ChangeStatus(Boolean IsModerator, String PlayerName, String UserID, String StatusConnection)
        {
            List<Fields> fields;
            if (IsModerator)
            {
                fields = new List<Fields>
                {
                    new Fields(LanguageEn ? "Moderator Information :" : "Информация о модераторе :", "", false),
                    new Fields("", "", false),
                    new Fields(LanguageEn ? "Nick" : "Ник", $"{PlayerName}", true),
                    new Fields("Steam64ID", $"[{UserID}](https://steamcommunity.com/profiles/{UserID})", true),
                    new Fields(LanguageEn ? "Status" : "Статус", $"{StatusConnection}", true),
                };
            }
            else
            {
                fields = new List<Fields>
                {
                    new Fields(LanguageEn ? "Information about the suspect :" : "Информация о подозреваемом :", "", false),
                    new Fields("", "", false),
                    new Fields(LanguageEn ? "Nick" : "Ник", $"{PlayerName}", true),
                    new Fields("Steam64ID", $"[{UserID}](https://steamcommunity.com/profiles/{UserID})", true),
                    new Fields(LanguageEn ? "Status" : "Статус", $"{StatusConnection}", true),
                };
            }

            return fields;
        }
        protected override void SaveConfig() => Config.WriteObject(config);



        private void SendRaitingModerator(UInt64 ModeratorID, Int32 IndexAchive, Int32 StarAmount)
        {
            if (!ModeratorInformations.ContainsKey(ModeratorID)) return;

            ModeratorInformation ModeratorInfo = ModeratorInformations[ModeratorID];
            List<Int32> ListScore = IndexAchive == 1 ? ModeratorInfo.OneScore :
                IndexAchive == 2 ? ModeratorInfo.TwoScore :
                IndexAchive == 3 ? ModeratorInfo.ThreeScore : null;

            ListScore?.Add(StarAmount);

            Interface.Call("OnSendedFeedbackChecked", ModeratorID, IndexAchive, StarAmount);
        }
        private void SteamAvatarAdd(String userid)
        {
            if (ImageLibrary == null)
                return;
            if (HasImage(userid))
                return;
            webrequest.Enqueue($"https://steamcommunity.com/profiles/{userid}?xml=1", null,
                (code, response) =>
                {
                    if (response == null || code != 200)
                        return;

                    String avatarUrl = _avatarRegex.Match(response).Groups[1].ToString();
                    if (!String.IsNullOrEmpty(avatarUrl))
                    {
                        ImageLibrary?.Call("AddImage", avatarUrl, userid);
                    }
                }, this);
        }



        private void StopDamageAdd(BasePlayer player)
        {
            if (StopDamageMan == null) return;
            if (!config.ReferenceSettings.StopDamageManSetting.UseStopDamage) return;

            StopDamageMan.CallHook("AddPlayerSDM", player);
            SendChat(GetLang("FUNCIONAL_PLAYER_STOP_DAMAGE_MAN_ADD", player.UserIDString), player);
        }
        private Boolean IsClans(String userID, String targetID)
        {
            if (!Clans) return false;
            if (!Clans.Author.Contains("dcode"))
            {
                Object result = Clans.Call("IsClanMember", userID, targetID);
                if (result == null)
                    return false;

                return (Boolean)result;
            }
            String TagUserID = (String)Clans.Call("GetClanOf", userID);
            String TagTargetID = (String)Clans.Call("GetClanOf", targetID);
            return TagUserID == TagTargetID;
        }

        private void SendChat(String Message, BasePlayer player, ConVar.Chat.ChatChannel channel = ConVar.Chat.ChatChannel.Global)
        {
            if (IQChat)
                if (config.ReferenceSettings.IQChatSetting.UIAlertUse)
                    IQChat?.Call("API_ALERT_PLAYER_UI", player, Message);
                else IQChat?.Call("API_ALERT_PLAYER", player, Message, config.ReferenceSettings.IQChatSetting.CustomPrefix, config.ReferenceSettings.IQChatSetting.CustomAvatar);
            else player.SendConsoleCommand("chat.add", channel, 0, Message);
        }

        private void DrawUI_Moderator_Checked_Menu_Status(BasePlayer moderator, String Status)
        {
            String Interface = InterfaceBuilder.GetInterface($"{InterfaceBuilder.UI_LAYER}_ONLINE_STATUS_CHECKED_MODERATOR");
            if (Interface == null) return;

            Interface = Interface.Replace("%TITLE_PROFILE_MODERATOR_CHECKED_MENU_TITLE_STATUS%", GetLang("TITLE_PROFILE_MODERATOR_CHECKED_MENU_TITLE_STATUS", moderator.UserIDString, Status));

            CuiHelper.DestroyUi(moderator, "InfoStatus");
            CuiHelper.AddUi(moderator, Interface);
        }



        private void AlertMaxReportDiscord(String PlayerName, Int32 ReportCount, UInt64 TargetID)
        {
            Configuration.NotifyDiscord.Webhooks.TemplatesNotify TemplateDiscord = config.NotifyDiscordSettings.WebhooksList.NotifyMaxReport;

            if (!String.IsNullOrWhiteSpace(TemplateDiscord.WebhookNotify))
            {
                List<Fields> fields = DT_PlayerMaxReport(PlayerName, ReportCount, TargetID);
                SendDiscord(TemplateDiscord.WebhookNotify, fields, GetAuthorDiscord(TemplateDiscord), TemplateDiscord.Color);
            }

            SendVK(VKT_PlayerMaxReport(PlayerName, ReportCount, TargetID));
        }

        [ConsoleCommand("report.panel")]
        private void FuncionalCommandReport(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            String ActionPanel = arg.Args[0];

            switch (ActionPanel)
            {
                case "page.controller":
                    {
                        Int32 Page = Int32.Parse(arg.Args[1]);

                        Boolean IsModeratorParam;
                        if (!Boolean.TryParse(arg.Args[2], out IsModeratorParam)) return;

                        DrawUI_PlayerPanel(player, Page, IsModeratorParam);
                        break;
                    }

                case "close.poopup": //report.panel close.poopup
                    {
                        CuiHelper.DestroyUi(player, "BLURED_POOP_UP");
                        CuiHelper.DestroyUi(player, InterfaceBuilder.UI_REPORT_POOPUP_MODERATOR);
                        CuiHelper.DestroyUi(player, InterfaceBuilder.UI_REPORT_POOPUP_PLAYER);
                        break;
                    }


                case "select.player":
                    {
                        UInt64 userID;
                        if (!UInt64.TryParse(arg.Args[1], out userID)) return;

                        Boolean IsModerator;
                        if (!Boolean.TryParse(arg.Args[2], out IsModerator)) return;

                        BasePlayer Target = IsFake(userID) ? null : BasePlayer.FindByID(userID);
                        String displayName = Target == null ? FindFakeName(userID) : Target.displayName;

                        if (IsModerator)
                        {
                            if (Target == null)
                            {
                                CuiHelper.DestroyUi(player, "BLURED_POOP_UP");
                                CuiHelper.DestroyUi(player, InterfaceBuilder.UI_REPORT_POOPUP_MODERATOR);
                                DrawUI_PlayerPanel(player, 0, true);
                                return;
                            }
                            DrawUI_PoopUp_Moderator(player, Target);
                            return;
                        }
                        DrawUI_ShowPoopUP(player, displayName, userID.ToString());
                        break;
                    }



                case "send.player.report"://report.panel send.player.report userID Reason
                    {
                        UInt64 TargetID;
                        if (!UInt64.TryParse(arg.Args[1], out TargetID))
                        {
                            CuiHelper.DestroyUi(player, "BLURED_POOP_UP");
                            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_REPORT_POOPUP_PLAYER);
                            return;
                        }

                        if (IsFake(TargetID))
                        {
                            CuiHelper.DestroyUi(player, "BLURED_POOP_UP");
                            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_REPORT_POOPUP_PLAYER);
                            return;
                        }

                        BasePlayer Target = BasePlayer.FindByID(TargetID);
                        if (Target == null)
                        {
                            CuiHelper.DestroyUi(player, "BLURED_POOP_UP");
                            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_REPORT_POOPUP_PLAYER);
                            return;
                        }

                        Int32 ReasonIndex;
                        if (!Int32.TryParse(arg.Args[2], out ReasonIndex))
                        {
                            CuiHelper.DestroyUi(player, "BLURED_POOP_UP");
                            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_REPORT_POOPUP_PLAYER);
                            return;
                        }

                        SendReportPlayer(player, TargetID, ReasonIndex);
                        break;
                    }



                case "select.type.mod": //report.panel select.type.mod boolean
                    {
                        if (!IsModerator(player)) return;

                        Boolean IsModeratorParam;
                        if (!Boolean.TryParse(arg.Args[1], out IsModeratorParam)) return;

                        IsModeratorParam = !IsModeratorParam;

                        DrawUI_LeftMenu(player, IsModeratorParam);
                        DrawUI_PlayerPanel(player, 0, IsModeratorParam);
                        DrawUI_HeaderUI_Search(player, IsModeratorParam);
                        break;
                    }



                case "start.check.player": //report.panel start.check.player ID
                    {
                        if (!IsModerator(player)) return;

                        UInt64 TargetID;
                        if (!UInt64.TryParse(arg.Args[1], out TargetID))
                        {
                            CuiHelper.DestroyUi(player, "BLURED_POOP_UP");
                            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_REPORT_POOPUP_MODERATOR);
                            return;
                        }

                        BasePlayer Target = BasePlayer.FindByID(TargetID);
                        if (Target == null)
                        {
                            CuiHelper.DestroyUi(player, "BLURED_POOP_UP");
                            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_REPORT_POOPUP_MODERATOR);
                            return;
                        }

                        if (AfkCheckRoutine.ContainsKey(Target))
                        {
                            if (AfkCheckRoutine[Target] != null)
                            {
                                ServerMgr.Instance.StopCoroutine(AfkCheckRoutine[Target]);
                                AfkCheckRoutine[Target] = null;

                                if (PlayerChecks.ContainsKey(Target.userID))
                                    PlayerChecks.Remove(Target.userID);
                            }
                        }

                        Coroutine routineAFK = ServerMgr.Instance.StartCoroutine(StartAfkCheck(Target, player, false, !config.CheckControllerSettings.UseCheckAFK));

                        if (!AfkCheckRoutine.ContainsKey(Target))
                            AfkCheckRoutine.Add(Target, routineAFK);
                        else AfkCheckRoutine[Target] = routineAFK;

                        break;
                    }



                case "stop.check.player": //report.panel stop.check.player TargetID
                    {
                        if (!IsModerator(player)) return;
                        UInt64 TargetID;
                        if (!UInt64.TryParse(arg.Args[1], out TargetID)) return;

                        StopCheckedPlayer(TargetID, player);
                        break;
                    }



                case "check.show.verdicts":
                    {
                        if (!IsModerator(player)) return;

                        UInt64 TargetID;
                        if (!UInt64.TryParse(arg.Args[1], out TargetID)) return;

                        DrawUI_Moderator_Button(player);
                        Int32 Y = 0;
                        foreach (Configuration.ReasonReport ReasonBan in config.ReasonList)
                        {
                            DrawUI_Reason_Raiting_Or_Moderator_Menu(player,
                                ReasonBan.Title.GetReasonTitle(player.userID),
                                InterfaceBuilder.UI_REPORT_MODERATOR_MENU_CHECKED,
                                InterfaceBuilder.UI_REPORT_MODERATOR_MENU_CHECKED + $"_REASON_{Y}",
                                $"-102.333 {55 + (Y * 30)}", $"102.333 {79 + (Y * 30)}", $"report.panel check.select.verdict {TargetID} {Y}");

                            Y++;
                        }
                        break;
                    }



                case "check.select.verdict":
                    {
                        if (!IsModerator(player)) return;

                        UInt64 TargetID;
                        if (!UInt64.TryParse(arg.Args[1], out TargetID)) return;

                        Int32 VerdictIndex;
                        if (!Int32.TryParse(arg.Args[2], out VerdictIndex)) return;

                        Configuration.ReasonReport Verdict = config.ReasonList[VerdictIndex];
                        if (Verdict == null)
                        {
                            PrintWarning(LanguageEn ? $"We could not find the index of this verdict! Check the configuration or send this message to the developer, the number of verdicts : {config.ReasonList.Count}" : $"Мы не смогли обнаружить индекс данного вердикта! Проверьте конфигурацию или пришлите это сообщение разработчику, количество вердиктов : {config.ReasonList.Count}");
                            return;
                        }

                        SendVerdictPlayer(TargetID, player, Verdict);
                        break;
                    }



                case "select.raiting.star":
                    {
                        Int32 IndexStar;
                        if (!Int32.TryParse(arg.Args[1], out IndexStar))
                        {
                            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_REPORT_RAITING_PLAYER_PANEL);
                            return;
                        }

                        UInt64 ModeratorID;
                        if (!UInt64.TryParse(arg.Args[2], out ModeratorID))
                        {
                            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_REPORT_RAITING_PLAYER_PANEL);
                            return;
                        }

                        DrawUI_Raiting_Menu_Stars(player, IndexStar, ModeratorID);

                        DrawUI_Reason_Raiting_Or_Moderator_Menu(player,
                            GetLang("TITLE_PROFILE_MODERATOR_STATISTICS_TITLE_ONE_ACHIVE", player.UserIDString),
                            InterfaceBuilder.UI_REPORT_RAITING_PLAYER_PANEL,
                            InterfaceBuilder.UI_REPORT_RAITING_PLAYER_PANEL +
                            "_TITLE_PROFILE_MODERATOR_STATISTICS_TITLE_ONE_ACHIVE", $"-102.333 37",
                            $"102.333 61.6", $"report.panel select.raiting.reason {IndexStar} {ModeratorID} 1");

                        DrawUI_Reason_Raiting_Or_Moderator_Menu(player,
                            GetLang("TITLE_PROFILE_MODERATOR_STATISTICS_TITLE_TWO_ACHIVE", player.UserIDString),
                            InterfaceBuilder.UI_REPORT_RAITING_PLAYER_PANEL,
                            InterfaceBuilder.UI_REPORT_RAITING_PLAYER_PANEL +
                            "_TITLE_PROFILE_MODERATOR_STATISTICS_TITLE_ONE_ACHIVE", $"-102.333 67", $"102.333 91.6",
                            $"report.panel select.raiting.reason {IndexStar} {ModeratorID} 2");

                        DrawUI_Reason_Raiting_Or_Moderator_Menu(player,
                            GetLang("TITLE_PROFILE_MODERATOR_STATISTICS_TITLE_THREE_ACHIVE", player.UserIDString),
                            InterfaceBuilder.UI_REPORT_RAITING_PLAYER_PANEL,
                            InterfaceBuilder.UI_REPORT_RAITING_PLAYER_PANEL +
                            "_TITLE_PROFILE_MODERATOR_STATISTICS_TITLE_ONE_ACHIVE", $"-102.333 97", $"102.333 121.6",
                            $"report.panel select.raiting.reason {IndexStar} {ModeratorID} 3");
                        break;
                    }



                case "select.raiting.reason":
                    {
                        Int32 IndexStar;
                        if (!Int32.TryParse(arg.Args[1], out IndexStar))
                        {
                            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_REPORT_RAITING_PLAYER_PANEL);
                            return;
                        }

                        UInt64 ModeratorID;
                        if (!UInt64.TryParse(arg.Args[2], out ModeratorID))
                        {
                            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_REPORT_RAITING_PLAYER_PANEL);
                            return;
                        }

                        Int32 IndexAchive;
                        if (!Int32.TryParse(arg.Args[3], out IndexAchive))
                        {
                            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_REPORT_RAITING_PLAYER_PANEL);
                            return;
                        }

                        SendRaitingModerator(ModeratorID, IndexAchive, IndexStar + 1);
                        CuiHelper.DestroyUi(player, InterfaceBuilder.UI_REPORT_RAITING_PLAYER_PANEL);

                        SendChat(GetLang("FUNCIONAL_MESSAGE_SEND_RAITING", player.UserIDString), player);

                        BasePlayer Moderator = BasePlayer.FindByID(ModeratorID);
                        if (Moderator != null)
                            SendChat(GetLang("FUNCIONAL_MESSAGE_SEND_RAITING_FOR_MODERATOR", Moderator.UserIDString), Moderator);
                        break;
                    }



                case "close.select.raiting":  //report.panel close.select.raiting ModeratorID
                    {
                        UInt64 ModeratorID;
                        if (!UInt64.TryParse(arg.Args[1], out ModeratorID))
                        {
                            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_REPORT_RAITING_PLAYER_PANEL);
                            return;
                        }

                        BasePlayer Moderator = BasePlayer.FindByID(ModeratorID);
                        if (Moderator != null)
                            SendChat(GetLang("FUNCIONAL_MESSAGE_NO_SEND_RAITING_FOR_MODERATOR", Moderator.UserIDString), Moderator);
                        else
                            Puts(LanguageEn
                                ? $"Player {player.displayName}({player.userID}) refrained from moderator rating"
                                : $"Игрок {player.displayName}({player.userID}) воздержался от оценки модератора");


                        SendChat(GetLang("FUNCIONAL_MESSAGE_NO_SEND_RAITING", player.UserIDString), player);
                        CuiHelper.DestroyUi(player, InterfaceBuilder.UI_REPORT_RAITING_PLAYER_PANEL);
                        break;
                    }



                case "search.player": //report.panel search.player SearchName IsModerator
                    {
                        Boolean IsModerator;
                        if (!Boolean.TryParse(arg.Args[1], out IsModerator)) return;

                        if (!arg.HasArgs(3))
                        {
                            DrawUI_PlayerPanel(player, IsModerator: IsModerator);
                            return;
                        }

                        String SearchName = arg.Args[2];
                        if (String.IsNullOrWhiteSpace(SearchName)) return;

                        DrawUI_PlayerPanel(player, 0, IsModerator, SearchName);
                        break;
                    }


                default:
                    {
                        break;
                    }
            };
        }




        private Dictionary<UInt64, LocalRepositoryOzProtect> OzProtect_LocalRepository = new Dictionary<UInt64, LocalRepositoryOzProtect>();

        private Boolean IsModerator(BasePlayer moderator) =>
            permission.UserHasPermission(moderator.UserIDString, ModeratorPermissions);


        private Boolean CanStartedChecked(BasePlayer Target) => IsValidStartChecked(Target, null);


        private void ChatCommandDiscord(BasePlayer player, String cmd, String[] args)
        {
            String Discord = String.Join(" ", args);
            SendPlayerDiscord(player, Discord);
        }

        private void ConsoleCommandDiscord(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;

            String Discord = arg.HasArgs() ? String.Join(" ", arg.Args) : null;
            SendPlayerDiscord(player, Discord);
        }




        private Dictionary<UInt64, LocalRepositoryRCC> RCC_LocalRepository = new Dictionary<UInt64, LocalRepositoryRCC>();

        private String VKT_PlayerMaxReport(String PlayerName, Int32 Reports, UInt64 TargetID)
        {
            String Message = LanguageEn
                ? $"▣ EXCESS OF COMPLAINTS ▣\nInformation about the suspect:\n• Nickname: {PlayerName}\n• Steam64ID : {TargetID} (https://steamcommunity.com/profiles/{TargetID})\nNumber of reports: {Reports}"
                : $"▣ ПРЕВЫШЕНИЕ КОЛИЧЕСТВА ЖАЛОБ ▣\nИнформация об подозреваемом :\n• Ник : {PlayerName}\n• Steam64ID : {TargetID} (https://steamcommunity.com/profiles/{TargetID})\nКоличество репортов : {Reports}";

            return Message;
        }

        private List<String> GetServersBansRCC(UInt64 TargetID)
        {
            if (String.IsNullOrWhiteSpace(config.ReferenceSettings.RCCSettings.RCCKey)) return null;
            return !RCC_LocalRepository.ContainsKey(TargetID) ? new List<String>() : RCC_LocalRepository[TargetID].LastBansServers;
        }
        public class FakePlayer
        {
            public UInt64 UserID;
            public String DisplayName;
        }

        private String VKT_StartCheck(BasePlayer Target, BasePlayer Moderator, Boolean IsConsole = false)
        {
            String ModeratorName = !IsConsole && Moderator != null ? Moderator.displayName : "Console";
            String ModeratorID = !IsConsole && Moderator != null ? Moderator.UserIDString : "Console";
            String Message = LanguageEn
                ? $"▣ PLAYER CHECK HAS STARTED ▣\nInformation about the moderator:\n• Nickname: {ModeratorName}\n• Steam64ID: {ModeratorID} (https://steamcommunity.com/profiles/{ModeratorID})\nInformation about the suspect:\n• Nickname: {Target.displayName}\n• Steam64ID: {Target.userID} (https://steamcommunity.com/profiles/{Target.userID})"
                : $"▣ ЗАПУЩЕНА ПРОВЕРКА ИГРОКА ▣\nИнформация о модераторе :\n• Ник : {ModeratorName}\n• Steam64ID : {ModeratorID} (https://steamcommunity.com/profiles/{ModeratorID})\nИнформация о подозреваемом :\n• Ник : {Target.displayName}\n• Steam64ID : {Target.userID} (https://steamcommunity.com/profiles/{Target.userID})";

            return Message;
        }



        private void DrawUI_Moderator_Checked_Menu(BasePlayer moderator, UInt64 TargetID)
        {
            String Interface = InterfaceBuilder.GetInterface($"{InterfaceBuilder.UI_LAYER}_MODERATOR_MENU_CHECKED");
            if (Interface == null) return;

            Interface = Interface.Replace("%COMMAND_STOP_CHECKED%", $"report.panel stop.check.player {TargetID}");
            Interface = Interface.Replace("%TITLE_PROFILE_MODERATOR_CHECKED_MENU_TITLES%", GetLang("TITLE_PROFILE_MODERATOR_CHECKED_MENU_TITLES", moderator.UserIDString));
            Interface = Interface.Replace("%TITLE_PROFILE_MODERATOR_CHECKED_MENU_TITLE_BUTTON_STOP%", GetLang("TITLE_PROFILE_MODERATOR_CHECKED_MENU_TITLE_BUTTON_STOP", moderator.UserIDString));

            CuiHelper.AddUi(moderator, Interface);

            DrawUI_Moderator_Button(moderator, $"report.panel check.show.verdicts {TargetID}");
            DrawUI_Moderator_Checked_Menu_Status(moderator, GetLang("TITLE_PROFILE_MODERATOR_CHECKED_MENU_TITLE_STATUS_DEFAULT", moderator.UserIDString));
            DrawUI_Moderator_Checked_Menu_Discord(moderator, GetLang("TITLE_PROFILE_MODERATOR_CHECKED_MENU_TITLE_DISCORD_EMPTY", moderator.UserIDString));
        }
        private class SoundFileConverter : JsonConverter
        {
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                JToken value = JToken.Load(reader);
                return _.FromSaveData(Compression.Uncompress(Convert.FromBase64String(value.ToString())));
            }

            public override bool CanConvert(Type objectType)
            {
                return typeof(List<Byte>) == objectType;
            }
        }



        private void PreLoadedPlugin()
        {
            if (!ImageLibrary)
            {
                NextTick(() => {
                    PrintError($"ImageLibrary not found! Please, check your plugins list.");
                    Interface.Oxide.UnloadPlugin(Name);
                });
                return;
            }
        }

    }
}

// --- End of file: IQReportSystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/ClansLimit.cs ---
// --- Original Local Path: BeeRust/ClansLimit.cs ---

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using System.Text.RegularExpressions;

namespace Oxide.Plugins
{
    [Info("ClansLimit", "King", "1.0.0")]
    class ClansLimit : RustPlugin
    {
        #region [Vars]
        [PluginReference] private Plugin Clans = null;

        private const string Layer = "ClansLimit.Layer";
        private Dictionary<string, int> _itemIds = new Dictionary<string, int>();
        private Dictionary<ulong, DateTime> CoolDown = new Dictionary<ulong, DateTime>();
        #endregion

        #region [Config]
        private PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();

            if (config.PluginVersion < Version)
                UpdateConfigValues();

            Config.WriteObject(config, true);
        }

        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (config.PluginVersion < Version)
            {
                config.PluginVersion = Version;
                if (Version == new VersionNumber(1, 0, 0))
                {
                    //
                }

                PrintWarning("Config checked completed!");
            }
            config.PluginVersion = Version;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        public class LimitSettings
        {
            [JsonProperty(PropertyName = "Лимит для обьекта")]
            public int Limit;

            [JsonProperty(PropertyName = "ShortName для картинки")]
            public string Image;

            [JsonProperty(PropertyName = "Название обьекта в Ui")]
            public string DisplayName;
        }

        public class MainSettings
        {
            [JsonProperty("Запретить строится без клана ?")] 
            public bool canBuildNoClan;

            [JsonProperty("Запретить строится без клана только по Entity которые ограничены ?")] 
            public bool canBuildNoClanLimits;

            [JsonProperty("Использовать оповещения с помощью чата ?")] 
            public bool useChat;

            [JsonProperty("КД на оповещения")]
            public int timeCooldown;

            [JsonProperty("Команда для открытия UI")] 
            public string commandOpenUi;
        }

        private class PluginConfig
        {
            [JsonProperty("Основные настройки")]
            public MainSettings _MainSettings = new MainSettings();

            [JsonProperty(PropertyName = "Настройка лимитов")]
            public Dictionary<string, LimitSettings> _LimitSettings;

            [JsonProperty("Config version")]
            public VersionNumber PluginVersion = new VersionNumber();

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    _MainSettings = new MainSettings
                    {
                        canBuildNoClan = false,
                        timeCooldown = 5,
                        commandOpenUi = "limit",
                    }, 
                    _LimitSettings = new Dictionary<string, LimitSettings>()
                    {
                        ["assets/prefabs/npc/autoturret/autoturret_deployed.prefab"] = new LimitSettings()
                        {
                            Limit = 125,
                            Image = "autoturret",
                            DisplayName = "Автоматическая турель"
                        },
                        ["assets/prefabs/npc/sam_site_turret/sam_site_turret_deployed.prefab"] = new LimitSettings()
                        {
                            Limit = 20,
                            Image = "samsite",
                            DisplayName = "Зенитная установка"
                        },
                    },
                    PluginVersion = new VersionNumber()
                };
            }
        }
        #endregion

        #region [ClansData]
        private Dictionary<string, ClanData> _clansList = new Dictionary<string, ClanData>();

        private class ClanData
        {
            public Dictionary<string, int> Limit = new Dictionary<string, int>();

            public Dictionary<ulong, PlayerData> playerBuild = new Dictionary<ulong, PlayerData>();
        }

		private void SaveClans()
		{
			Interface.Oxide.DataFileSystem.WriteObject($"{Name}/ClansData", _clansList);
		}

		private void LoadClans()
		{
			try
			{
				_clansList = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, ClanData>>($"{Name}/ClansData");
			}
			catch (Exception e)
			{
				PrintError(e.ToString());
			}

			if (_clansList == null) _clansList = new Dictionary<string, ClanData>();
		}
        #endregion

        #region [PlayersData]
        private Dictionary<ulong, PlayerData> _playersList = new Dictionary<ulong, PlayerData>();

        private class PlayerData
        {
            public Dictionary<string, int> Limit = new Dictionary<string, int>();
        }

		private void SavePlayers()
		{
			Interface.Oxide.DataFileSystem.WriteObject($"{Name}/PlayerData", _playersList);
		}

		private void LoadPlayers()
		{
			try
			{
				_playersList = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, PlayerData>>($"{Name}/PlayerData");
			}
			catch (Exception e)
			{
				PrintError(e.ToString());
			}

			if (_playersList == null) _playersList = new Dictionary<ulong, PlayerData>();
		}
        #endregion

        #region [Oxide]
        private void Init()
        {
            LoadClans();

            LoadPlayers();
        }

        private void OnServerInitialized()
        {
            foreach(var player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);

            cmd.AddChatCommand(config._MainSettings.commandOpenUi, this, "cmdChatLimit");
        }

        private void Unload()
        {
            SaveClans();

            SavePlayers();
        }

		private void OnNewSave(string filename)
		{
			_clansList.Clear();
            _playersList.Clear();
			SaveClans();
            SavePlayers();
		}
        #endregion

        #region [GUI]
        private void cmdChatLimit(BasePlayer player)
        {
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Material = "assets/content/ui/uibackgroundblur.mat", Color = "0 0 0 0.77" }
            }, "Overlay", Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Color = "0.36 0.33 0.28 0.3", Material = "assets/icons/greyout.mat", Close = Layer }
            }, Layer);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-493 -293", OffsetMax = "497.5 293" },
                Image = { Color = "0.3773585 0.3755785 0.3755785 0.3407843", Material = "assets/icons/greyout.mat" }
            }, Layer, Layer + ".Main");

            var clan = GetClanTag(player.userID);
            if (string.IsNullOrEmpty(clan))
            {
                container.Add(new CuiElement
                {
                    Parent = Layer + ".Main",
                    Components =
                    {
                        new CuiTextComponent { Text = $"Вы не можете увидеть лимиты без клана.\nСоздайте клан /clan", Color = "1 1 1 0.85", Align = TextAnchor.MiddleCenter, FontSize = 32, Font = "robotocondensed-bold.ttf" },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = $"1 1" },
                    }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0.890915 0.01", AnchorMax = $"0.99379 0.067", OffsetMax = "0 0" },
                    Button = { Color = "0.46 0.44 0.42 0.85", Material = "assets/icons/greyout.mat", Close = Layer },
                    Text = { Text = $"ЗАКРЫТЬ", Color = "1 1 1 0.85", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf" }
                }, Layer + ".Main");

                CuiHelper.DestroyUi(player, Layer);
                CuiHelper.AddUi(player, container);
                return;
            }

            container.Add(new CuiElement
            {
                Parent = Layer + ".Main",
                Components =
                {
                    new CuiTextComponent { Text = $"Лимит для вашего клана", Color = "1 1 1 0.85", Align = TextAnchor.MiddleCenter, FontSize = 20, Font = "robotocondensed-bold.ttf" },
                    new CuiRectTransformComponent { AnchorMin = "0 0.915", AnchorMax = $"1 1" },
                }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.890915 0.01", AnchorMax = $"0.99379 0.067", OffsetMax = "0 0" },
                Button = { Color = "0.46 0.44 0.42 0.85", Material = "assets/icons/greyout.mat", Close = Layer },
                Text = { Text = $"ЗАКРЫТЬ", Color = "1 1 1 0.85", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf" }
            }, Layer + ".Main");

            foreach (var check in config._LimitSettings.Select((i, t) => new { A = i, B = t}))
            {
                int Amount = 0;
                var key = config._LimitSettings[check.A.Key];

                if (_clansList.ContainsKey(clan))
                {
                    if (_clansList[clan].Limit.ContainsKey(check.A.Key))
                    {
                        Amount = _clansList[clan].Limit[check.A.Key];
                    }
                }

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"{0.05 + check.B * 0.235 - Math.Floor((float) check.B / 4) * 4 * 0.235} {0.6 - Math.Floor((float) check.B/ 4) * 0.2}",
                                      AnchorMax = $"{0.25 + check.B * 0.235 - Math.Floor((float) check.B / 4) * 4 * 0.235} {0.9 - Math.Floor((float) check.B / 4) * 0.2}", },
                    Image = { Color = "0 0 0 0.25", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
                }, Layer + ".Main", Layer + ".Main" + $".Limit({check.B})");

                container.Add(new CuiElement
                {
                    Parent = Layer + ".Main" + $".Limit({check.B})",
                    Components =
                    {
                        new CuiImageComponent { ItemId = FindItemID(key.Image), SkinId = 0 },
                        new CuiRectTransformComponent { AnchorMin = "0.05 0.05", AnchorMax = "0.95 0.95" }
                    }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0 ", AnchorMax = "1 1", OffsetMax = "-5 0", OffsetMin = "5 4" },
                    Button = { Color = "0 0 0 0", Command = $"UI_LIMIT OpenLimitInfo {check.A.Key} {clan}" },
                    Text = { Text = $"Доступно: {key.Limit - Amount}", Align = TextAnchor.LowerCenter, Font = "robotocondensed-regular.ttf", FontSize = 14 }
                }, Layer + ".Main" + $".Limit({check.B})");
            }

            CuiHelper.DestroyUi(player, Layer);
            CuiHelper.AddUi(player, container);
        }

        private void cmdChatLimitInfo(BasePlayer player, string prefabName, string tag)
        {
            var container = new CuiElementContainer();

            var clan = GetClanTag(player.userID);
            if (string.IsNullOrEmpty(clan)) return;

            var cfg = config._LimitSettings[prefabName];

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Material = "assets/content/ui/uibackgroundblur.mat", Color = "0 0 0 0.77" }
            }, "Overlay", Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Color = "0.36 0.33 0.28 0.3", Material = "assets/icons/greyout.mat", Close = Layer }
            }, Layer);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-493 -293", OffsetMax = "497.5 293" },
                Image = { Color = "0.3773585 0.3755785 0.3755785 0.3407843", Material = "assets/icons/greyout.mat" }
            }, Layer, Layer + ".Main");

            if (!_clansList.ContainsKey(clan) || !_clansList[clan].Limit.ContainsKey(prefabName))
            {
                container.Add(new CuiElement
                {
                    Parent = Layer + ".Main",
                    Components =
                    {
                        new CuiTextComponent { Text = $"Ваш клан еще не поставил {cfg.DisplayName}.\nПодробностей нету!", Color = "1 1 1 0.85", Align = TextAnchor.MiddleCenter, FontSize = 32, Font = "robotocondensed-bold.ttf" },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = $"1 1" },
                    }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0.77804 0.01", AnchorMax = $"0.880915 0.067", OffsetMax = "0 0" },
                    Button = { Color = "0.46 0.44 0.42 0.85", Material = "assets/icons/greyout.mat", Command = "UI_LIMIT ReturnToMenu" },
                    Text = { Text = $"НАЗАД", Color = "1 1 1 0.85", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf" }
                }, Layer + ".Main");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0.890915 0.01", AnchorMax = $"0.99379 0.067", OffsetMax = "0 0" },
                    Button = { Color = "0.46 0.44 0.42 0.85", Material = "assets/icons/greyout.mat", Close = Layer },
                    Text = { Text = $"ЗАКРЫТЬ", Color = "1 1 1 0.85", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf" }
                }, Layer + ".Main");

                CuiHelper.DestroyUi(player, Layer);
                CuiHelper.AddUi(player, container);
                return;
            }

            container.Add(new CuiElement
            {
                Parent = Layer + ".Main",
                Components =
                {
                    new CuiTextComponent { Text = $"Список лимита игроков клана", Color = "1 1 1 0.85", Align = TextAnchor.MiddleCenter, FontSize = 20, Font = "robotocondensed-bold.ttf" },
                    new CuiRectTransformComponent { AnchorMin = "0 0.915", AnchorMax = $"1 1" },
                }
            });

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.86", AnchorMax = "0.999 0.92" },
                Image = { Color = "1 1 1 0" }
            }, Layer + ".Main", Layer + ".Main" + ".Text");

            container.Add(new CuiLabel
            {
                Text = { Text = $"ИМЯ ИГРОКА", Color = "1 1 1 1", FontSize = 14, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.025 0", AnchorMax = $"1 1" },
            }, Layer + ".Main" + ".Text");

            container.Add(new CuiLabel
            {
                Text = { Text = $"УСТАНОВЛЕНО", Color = "1 1 1 1", FontSize = 14, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.85 0", AnchorMax = $"1 1" },
            }, Layer + ".Main" + ".Text");

            for (int y = 0; y < 9; y++)
            {
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"0.0055 {0.775 - y * 0.085}", AnchorMax = $"0.989 {0.85 - y * 0.085}" },
                    Image = { Color = "0 0 0 0.5" }
                }, Layer + ".Main", Layer + ".Main" + $".TopLine{y}");
            }

            int i = 0;
            foreach (var key in _clansList[clan].playerBuild)
            {
                container.Add(new CuiLabel
                {
                    Text = { Text = covalence.Players.FindPlayerById($"{key.Key}") != null ? $"{covalence.Players.FindPlayerById($"{key.Key}").Name}" : "UNKNOWN", Color = "1 1 1 0.85", FontSize = 14, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                    RectTransform = { AnchorMin = $"0.027 0", AnchorMax = $"1 1" },
                }, Layer + ".Main" + $".TopLine{i}");

                int Amount = 0;
                if ( _clansList[clan].playerBuild.ContainsKey(key.Key))
                {
                    if ( _clansList[clan].playerBuild[key.Key].Limit.ContainsKey(prefabName))
                    {
                        Amount =  _clansList[clan].playerBuild[key.Key].Limit[prefabName];
                    }
                }

                container.Add(new CuiLabel
                {
                    Text = { Text = $"{Amount} шт.", Font = "robotocondensed-regular.ttf", FontSize = 14, Color = "1 1 1 0.85", Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0.8 0", AnchorMax = $"1 1" },
                }, Layer + ".Main" + $".TopLine{i}");

                i++;
            }

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.77804 0.01", AnchorMax = $"0.880915 0.067", OffsetMax = "0 0" },
                Button = { Color = "0.46 0.44 0.42 0.85", Material = "assets/icons/greyout.mat", Command = "UI_LIMIT ReturnToMenu" },
                Text = { Text = $"НАЗАД", Color = "1 1 1 0.85", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf" }
            }, Layer + ".Main");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.890915 0.01", AnchorMax = $"0.99379 0.067", OffsetMax = "0 0" },
                Button = { Color = "0.46 0.44 0.42 0.85", Material = "assets/icons/greyout.mat", Close = Layer },
                Text = { Text = $"ЗАКРЫТЬ", Color = "1 1 1 0.85", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf" }
            }, Layer + ".Main");

            CuiHelper.DestroyUi(player, Layer);
            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region [ConsoleCommand]
        [ConsoleCommand("UI_LIMIT")]
        void cmdUiClansLimit(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player == null || !args.HasArgs()) return;
            switch (args.Args[0])
            {
                case "OpenLimitInfo":
                {
                    string prefabName = args.Args[1];
                    string clanTag = args.Args[2];
                    if(args.HasArgs(4))
                    {
                        prefabName = $"{args.Args[1]} {args.Args[2]}";
                        clanTag = args.Args[3];
                    }
                    cmdChatLimitInfo(player, prefabName, clanTag);
                    break;
                }
                case "ReturnToMenu":
                {
                    cmdChatLimit(player);
                    break;
                }
            }
        }
        #endregion

        #region [Rust]
        private void OnPlayerConnected(BasePlayer player)
        {
            if(!CoolDown.ContainsKey(player.userID))
                CoolDown.Add(player.userID, new DateTime());
        }

        private object CanBuild(Planner builder, Construction prefab, Construction.Target target)
        {
            String prefabName = prefab.fullName ?? "";
            if (prefabName == "") return null;

            if (prefab.fullName.Contains("assets/prefabs/building core"))
                prefabName = "assets/prefabs/building core";
            if (!config._LimitSettings.ContainsKey(prefabName)) return null;

            BasePlayer player = builder.GetOwnerPlayer();
            if (player == null) return null;

            Int32 limit = GetLimit(prefabName);
            if (limit == 0)
            {
                player.ChatMessage("Объект запрещен на сервере!");
                return false;
            }

            String clan = GetClanTag(player.userID);
            if (string.IsNullOrEmpty(clan))
            {
                player.ChatMessage($"Чтобы строить {config._LimitSettings[prefabName].DisplayName} вам нужно быть в клане.");
                return false;
            }

            if (!_clansList.ContainsKey(clan))
                _clansList.Add(clan, new ClanData());

            var data = _clansList[clan];
            if (data == null) return null;

            if (!data.playerBuild.ContainsKey(player.userID))
            {
                data.playerBuild.Add(player.userID, new PlayerData());
                if (_playersList.ContainsKey(player.userID))
                {
                    foreach (var oldData in _playersList[player.userID].Limit)
                    {
                        if (!data.Limit.ContainsKey(oldData.Key))
                        {
                            data.Limit.Add(oldData.Key, oldData.Value);
                            data.playerBuild[player.userID].Limit.Add(oldData.Key, oldData.Value);
                            continue;
                        }
                        data.Limit[oldData.Key] += oldData.Value;
                        data.playerBuild[player.userID].Limit.Add(oldData.Key, oldData.Value);
                    }
                    _playersList.Remove(player.userID);
                }
            }

            var playerData = data.playerBuild[player.userID];
            if (playerData == null) return null;

            if (data.Limit.ContainsKey(prefabName))
            {
                if (!playerData.Limit.ContainsKey(prefabName))
                    playerData.Limit.Add(prefabName, 0);
                if (data.Limit[prefabName] >= limit)
                {
                    player.ChatMessage("Ваш клан достиг лимита по постройки этого объекта");
                    return false;
                }
            }

            return null;
        }

        private void OnEntitySpawned(BaseEntity entity)
        {
            BasePlayer player = BasePlayer.FindAwakeOrSleeping(entity.OwnerID.ToString());
            if (player == null) return;

            String prefabName = entity.PrefabName ?? "";
            if (prefabName == "") return;

            if (!config._LimitSettings.ContainsKey(prefabName)) return;

            Int32 limit = GetLimit(prefabName);
            String clan = GetClanTag(player.userID);

            if (!_clansList.ContainsKey(clan))
                _clansList.Add(clan, new ClanData());

            var data = _clansList[clan];
            if (data == null) return;

            if (!data.playerBuild.ContainsKey(player.userID))
            {
                data.playerBuild.Add(player.userID, new PlayerData());
                if (_playersList.ContainsKey(player.userID))
                {
                    foreach (var oldData in _playersList[player.userID].Limit)
                    {
                        if (!data.Limit.ContainsKey(oldData.Key))
                        {
                            data.Limit.Add(oldData.Key, oldData.Value);
                            data.playerBuild[player.userID].Limit.Add(oldData.Key, oldData.Value);
                            continue;
                        }
                        data.Limit[oldData.Key] += oldData.Value;
                        data.playerBuild[player.userID].Limit.Add(oldData.Key, oldData.Value);
                    }
                    _playersList.Remove(player.userID);
                }
            }

            var playerData = data.playerBuild[player.userID];
            if (playerData == null) return;

            if (data.Limit.ContainsKey(prefabName))
            {
                if (data.Limit[prefabName] <= (limit - 1))
                {
                    data.Limit[prefabName]++;
                    playerData.Limit[prefabName]++;
                    SendPlayer(player, $"Вы можете построить еще {limit - data.Limit[prefabName]} {config._LimitSettings[prefabName].DisplayName}");
                    return;
                }
            }
            data.Limit.Add(prefabName, 1);
            playerData.Limit.Add(prefabName, 1);
            SendPlayer(player, $"Вы можете построить еще {limit - data.Limit[prefabName]} {config._LimitSettings[prefabName].DisplayName}");
        }

        private void OnEntityKill(BaseEntity entity)
        {
            if (entity.OwnerID == 0) return;
            var prefabName = entity.PrefabName;
            if (prefabName.Contains("assets/prefabs/building core"))
                prefabName = "assets/prefabs/building core";
            if (_playersList.ContainsKey(entity.OwnerID))
            {
                if (!_playersList[entity.OwnerID].Limit.ContainsKey(prefabName)) return;
                _playersList[entity.OwnerID].Limit[prefabName]--;
            }
            var clan = GetClanTag(entity.OwnerID);
            if (string.IsNullOrEmpty(clan)) return;
            if (!_clansList.ContainsKey(clan)) return;
            var clanData = _clansList[clan];
            if (!clanData.Limit.ContainsKey(prefabName)) return;
            clanData.Limit[prefabName]--;
            if (!clanData.playerBuild.ContainsKey(entity.OwnerID)) return;
            var playerData = clanData.playerBuild[entity.OwnerID];
            if (!playerData.Limit.ContainsKey(prefabName)) return;
            playerData.Limit[prefabName]--;
        }
        #endregion

        #region [Clans]
        private void OnClanDisbanded(string tag, List<ulong> memberUserIDs)
		{
            if (!_clansList.ContainsKey(tag)) return;

            var data = _clansList[tag];
            if (data == null) return;

            foreach (var key in memberUserIDs)
            {
                if (!data.playerBuild.ContainsKey(key)) continue;
                var playerData = data.playerBuild[key];
                if (playerData == null) continue;

                if (!_playersList.ContainsKey(key))
                    _playersList.Add(key, new PlayerData());

                var pdata = _playersList[key];
                if (pdata == null) continue;

                foreach (var _data in playerData.Limit)
                {
                    data.Limit[_data.Key] -= _data.Value;
                    pdata.Limit.Add(_data.Key, _data.Value);
                }
            }
            _clansList.Remove(tag);
		}

        private void OnClanMemberGone(ulong userID, string tag)
        {
            if (!_clansList.ContainsKey(tag)) return;

            var data = _clansList[tag];
            if (data == null) return;

            if (!data.playerBuild.ContainsKey(userID)) return;

            var playerData = data.playerBuild[userID];
            if (playerData == null) return;

            if (!_playersList.ContainsKey(userID))
                 _playersList.Add(userID, new PlayerData());

            var pdata = _playersList[userID];
            if (pdata == null) return;

            foreach (var _data in playerData.Limit)
            {
                data.Limit[_data.Key] -= _data.Value;
                if (!pdata.Limit.ContainsKey(_data.Key))
                    pdata.Limit.Add(_data.Key, _data.Value);
                else
                    pdata.Limit[_data.Key] += _data.Value;
            }

            data.playerBuild.Remove(userID);
        }
        #endregion

        #region [Functional]
		private int FindItemID(string shortName)
		{
			int val;
			if (_itemIds.TryGetValue(shortName, out val))
				return val;

			var definition = ItemManager.FindItemDefinition(shortName);
			if (definition == null) return 0;

			val = definition.itemid;
			_itemIds[shortName] = val;
			return val;
		}
        private void SendPlayer(BasePlayer player, string message)
        {
            if ((DateTime.Now - CoolDown[player.userID]).TotalSeconds < config._MainSettings.timeCooldown) return;
            player.ChatMessage(message);
            CoolDown[player.userID] = DateTime.Now;
        }
        private string GetClanTag(ulong playerID) => Clans?.Call<string>("GetClanTag", playerID);
        private int GetLimit(string name)=> config._LimitSettings[name].Limit;
        #endregion
    }
}

// --- End of file: ClansLimit.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/NoHeliAmmoFireWall.cs ---
// --- Original Local Path: BeeRust/NoHeliAmmoFireWall.cs ---

using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("NoHeliAmmoFireWall", "Tryhard", "1.0.5")]
    [Description("Убирает огонь от коптера . огонь от зажигалок")]
    public class NoHeliAmmoFireWall : RustPlugin
    {

        private ConfigData configData = new ConfigData();

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Enable plugin")]
            public bool enable = true;
            [JsonProperty(PropertyName = "Disable minicopter gibs")]
            public bool mGibs = true;
            [JsonProperty(PropertyName = "Disable minicopter fire")]
            public bool mFire = true;
            [JsonProperty(PropertyName = "Disable minicopter explosion sound")]
            public bool mExplo = true;
            [JsonProperty(PropertyName = "Disable scraphelicopter gibs")]
            public bool sGibs = true;
            [JsonProperty(PropertyName = "Disable scraphelicopter explosion sound")]
            public bool sExplo = true;
            [JsonProperty(PropertyName = "Disable scraphelicopter fire ")]
            public bool sFire = true;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                configData = Config.ReadObject<ConfigData>();

                if (configData == null) LoadDefaultConfig();
            }

            catch
            {
                PrintError("Configuration file is corrupt, check your config file at https://jsonlint.com/!");
                LoadDefaultConfig();
                return;
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig() => configData = new ConfigData();

        protected override void SaveConfig() => Config.WriteObject(configData);


        private void OnEntitySpawned(ScrapTransportHelicopter entity)
        {
            if (configData.enable)
            {
                if (configData.sExplo) entity.explosionEffect.guid = null;
                {
                    if (configData.sFire) entity.fireBall.guid = null;
                    {
                        if (configData.sGibs) entity.serverGibs.guid = null;
                    }
                }
            }
        }

        void OnEntitySpawned(BaseNetworkable entity)
        {
            if (entity.PrefabName == "assets/bundled/prefabs/fireball_small.prefab" || entity.PrefabName == "assets/bundled/prefabs/fireball_small_shotgun.prefab" || entity.PrefabName == "assets/bundled/prefabs/fireball.prefab")
                entity.Kill();
        }

        private void OnEntitySpawned(Minicopter entity)
        {
            if (configData.enable)
            {
                if (configData.mExplo) entity.explosionEffect.guid = null;
                {
                    if (configData.mFire) entity.fireBall.guid = null;
                    {
                        if (configData.mGibs) entity.serverGibs.guid = null;
                    }
                }
            }
        }
    }
}

// --- End of file: NoHeliAmmoFireWall.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/HelicopterInstantTakeoff.cs ---
// --- Original Local Path: BeeRust/HelicopterInstantTakeoff.cs ---

using Oxide.Core;
using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Helicopter Instant Takeoff", "bsdinis", "0.0.9")]
    [Description("Allows helicopters to takeoff instantly when the engine starts.")]
    class HelicopterInstantTakeoff : RustPlugin
    {
        void Init()
        {
            try
            {
                config = Config.ReadObject<ConfigData>();
                if (config == null)
                {
                    throw new Exception();
                }
                else
                {
                    SaveConfig();
                }
            }
            catch
            {
                PrintError("CONFIG FILE IS INVALID!\nCheck config file and reload HelicopterInstantTakeoff.");
                Interface.Oxide.UnloadPlugin(Name);
                return;
            }

            if (!string.IsNullOrWhiteSpace(config.AirPermission) && !permission.PermissionExists(config.AirPermission))
            {
                permission.RegisterPermission(config.AirPermission, this);
            }
            if (!string.IsNullOrWhiteSpace(config.GroundPermission) && !permission.PermissionExists(config.GroundPermission))
            {
                permission.RegisterPermission(config.GroundPermission, this);
            }
        }

        ConfigData config;
        class ConfigData
        {
            public string AirPermission;
            public string GroundPermission;
        }

        protected override void LoadDefaultConfig()
        {
            config = new ConfigData
            {
                AirPermission = "helicopterinstanttakeoff.air",
                GroundPermission = "helicopterinstanttakeoff.ground"
            };
        }

        protected override void SaveConfig() => Config.WriteObject(config, true);

        bool DriverHasPermission(PlayerHelicopter heli, string perm)
        {
            List<BaseVehicle.MountPointInfo> mountPoints = heli.mountPoints;
            if (mountPoints == null || mountPoints.Count < 1)
            {
                return false;
            }
            BaseMountable mountable = mountPoints[0].mountable;
            if (mountable == null)
            {
                return false;
            }
            BasePlayer player = mountable._mounted;
            if (player == null || (!string.IsNullOrWhiteSpace(perm) && !permission.UserHasPermission(player.UserIDString, perm)))
            {
                return false;
            }
            return true;
        }

        object OnEngineStart(PlayerHelicopter heli)
        {
            if (!DriverHasPermission(heli, (!heli.Grounded() ? config.AirPermission : config.GroundPermission)))
            {
                return null;
            }
            heli.engineController.FinishStartingEngine();
            return false;
        }
    }
}

// --- End of file: HelicopterInstantTakeoff.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/AutoCode.cs ---
// --- Original Local Path: BeeRust/AutoCode.cs ---

﻿using System.Collections.Generic;
using System.Reflection;
using Oxide.Core;
using Oxide.Core.Configuration;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("AutoCode", "Fartus", "1.0.0")]
	[Description("Установка последнего введенного кода")]
    class AutoCode : RustPlugin
    {
		#region FIELDS/DATA

        private readonly FieldInfo hasCodeField = typeof(CodeLock).GetField("hasCode", BindingFlags.Instance | BindingFlags.NonPublic);
		DynamicConfigFile saveFile = Interface.Oxide.DataFileSystem.GetFile("AutoCode/UserCode");
        Dictionary<ulong, string> userCode;

        void LoadData()
        {
            userCode = saveFile.ReadObject<Dictionary<ulong, string>>() ?? new Dictionary<ulong, string>();
        }

        void OnServerSave() => SaveData();

        void SaveData()
        {
            saveFile.WriteObject(userCode);
        }

		#endregion

		#region HOOKS

        void OnServerInitialized()
        {
            lang.RegisterMessages(Messages, this, "en");
            Messages = lang.GetMessages("en", this);
            LoadData();
        }

		void Unload() => SaveData();

		object CanChangeCode(BasePlayer player, CodeLock codeLock, string newCode, bool isGuestCode)
        {
			if (!isGuestCode)
			{
                userCode[player.userID] = newCode;
				SendReply(player, Messages["CodelockCodeSave"]);
                SaveData();
			}
			return null;
        }

		void OnItemDeployed(Deployer deployer, BaseEntity entity)
        {
            var player = deployer.GetOwnerPlayer();
            if (player == null) return;
			if (entity.HasSlot(BaseEntity.Slot.Lock))	
            {
                BaseEntity slotEntity = entity.GetSlot(BaseEntity.Slot.Lock);
                if (slotEntity == null) return;
                if (slotEntity is CodeLock)
                {
                    CodeLock codeLock = slotEntity as CodeLock;
                    if (codeLock == null) return;
                    if (userCode.ContainsKey(player.userID))
                    {
						codeLock.code = userCode[player.userID];
                        codeLock.whitelistPlayers.Add(player.userID);
                        Effect.server.Run(codeLock.effectLocked.resourcePath, codeLock, 0, Vector3.zero, Vector3.forward, null, false);
                        codeLock.SetFlag(BaseEntity.Flags.Locked, true);
						codeLock.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
						SendReply(player, Messages["CodelockLastCode"]);
                    }
                    else
                    {
                        SendReply(player, Messages["CodelockNoCode"]);
                    }
                }
            }
        }

		#endregion

        #region LOCALIZATION

        Dictionary<string, string> Messages = new Dictionary<string, string>()
        {
            { "CodelockLastCode", "<size=16>Для замка установлен <color=#FAC73A>последний введеный код</color>!</size>"},
            { "CodelockNoCode", "<size=16>Код не установлен. Введите код в замок!</size>"},
            { "CodelockCodeSave", "<size=16>Ваш код сохранен. Он будет использоваться для всех следующих замков!</size>"}
        };

        #endregion
    }
}


// --- End of file: AutoCode.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/LootCleaner.cs ---
// --- Original Local Path: BeeRust/LootCleaner.cs ---

using Newtonsoft.Json;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Loot Cleaner", "walkinrey", "1.0.2")]
    class LootCleaner : RustPlugin 
    {
        Configuration config;
        class Configuration 
        {
            [JsonProperty("Через сколько секунд удалять ящик, если его не до конца облутал игрок?")] 
            public float seconds = 5f;
        }
        protected override void SaveConfig() => Config.WriteObject(config);
        protected override void LoadConfig()
        {
            base.LoadConfig(); 
            try 
            {
                config = Config.ReadObject<Configuration>();
            } 
            catch 
            {
                LoadDefaultConfig();
            }
            NextTick(SaveConfig);
        }
        protected override void LoadDefaultConfig() => config = new Configuration();
        void OnLootEntityEnd(BasePlayer player, BaseCombatEntity entity) 
        {
            try {
                if(((LootContainer)entity) == null) return;
                LootContainer container = (LootContainer)entity;
                if(container.inventory.itemList.Count != 0) {
                    timer.Once(config.seconds, () =>
                    {
                        if(container != null) container.RemoveMe();
                    });
                }
            }
            catch {}
        }
    }
}

// --- End of file: LootCleaner.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/XRate.cs ---
// --- Original Local Path: BeeRust/XRate.cs ---

using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using UnityEngine;
using Random = UnityEngine.Random;
using System;
using Oxide.Core;
using ConVar;
using ru = Oxide.Game.Rust;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("XRate", "POPSI -RUST", "1.0.62")]
    public class XRate : RustPlugin
    {
        #region Config
        private PluginConfig config;
        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        class rateset
        {
            [JsonProperty("Поднимаемые ресурсы")]
            public float grab;

            [JsonProperty("Добываемые ресурсы")]
            public float gather;

            [JsonProperty("Сульфур")]
            public float sulfur;

            [JsonProperty("С карьера")]
            public float carier;

            [JsonProperty("С ящиков/бочек")]
            public float box;

            [JsonProperty("Запертый ящик")]
            public float lockbox;

            [JsonProperty("С ученых")]
            public float npc;

            [JsonProperty("Скорость переплавки")]
            public float speed;

            [JsonProperty("Ресурсы переплавки")] public int oven;
        }

        class daynight
        {
            [JsonProperty("Включить?")]
            public bool enable;

            [JsonProperty("Длина ночи")]
            public float night;

            [JsonProperty("Длина дня")]
            public float day;

            [JsonProperty("Автопропуск ночи")]
            public bool skipnight;

            [JsonProperty("Голосование за пропуск ночи")]
            public bool vote;

            [JsonProperty("Ночное увелечение рейтов (прим. 1.0 - на 100%, 0 - выключить)")]
            public float upnight;
        }

        private class PluginConfig
        {
            [JsonProperty("Экспериментально. Не трогать!")]
            public bool exp;

            [JsonProperty("Рейты у обычных игроков")]
            public rateset rates;

            [JsonProperty("Настройка дня и ночи")]
            public daynight daynight;

            [JsonProperty("Сообщения")]
            public List<string> messages;

            [JsonProperty("Привилегии")]
            public Dictionary<string, rateset> privilige;

            [JsonProperty("На что не увеличивать рейты?")]
            public string[] blacklist;

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    privilige = new Dictionary<string, rateset>()
                    {
                        { "xrate.x3", new rateset{ box = 3f, carier = 3f, gather = 3f, grab = 3f, npc = 3f, speed = 4f, sulfur = 2.5f } },
                        { "xrate.x4", new rateset{ box = 4f, carier = 4f, gather = 4f, grab = 4f, npc = 4f, speed = 4f, sulfur = 2.5f } }
                    },
                    rates = new rateset { box = 2f, carier = 2f, gather = 2f, grab = 2f, npc = 2f, speed = 2f, sulfur = 2f },
                    daynight = new daynight
                    {
                        day = 50f,
                        night = 10f,
                        enable = true,
                        skipnight = false,
                        upnight = 0f,
                        vote = false
                    },
                    exp = false,
                    messages = new List<string>
                    {
                        "<size=15><color=#ccff33>Наступила ночь</color>, рейты добычи увеличены на <color=#ccff33>{num}%</color>!</size>\n<size=10><color=#ccff33>/rate</color> - узнать текущие ваши рейты.</size>",
                        "<size=15><color=#ccff33>Наступил день</color>, рейты добычи стали прежними!</size>\n<size=10><color=#ccff33>/rate</color> - узнать текущие ваши рейты.</size>",
                        "<color=#ccff33>INFORATE | {name}</color>\nПоднимаемые: x<color=#F0E68C>{0}</color>\nДобываемые: x<color=#F0E68C>{1}</color> <size=10>(cульфур: x<color=#F0E68C>{6}</color>)</size>\nКарьер: x<color=#F0E68C>{2}</color>\nЯщики/бочки: x<color=#F0E68C>{3}</color>\nNPC: x<color=#F0E68C>{4}</color>\nСкорость переплавки: x<color=#F0E68C>{5}</color>"
                    },
                    blacklist = new string[]
                    {
                        "sticks",
                        "flare"
                    }
                };
            }
        }
        #endregion

        #region getrate
        Dictionary<string, rateset> cash = new Dictionary<string, rateset>();
        Dictionary<ulong, float> cashcariers = new Dictionary<ulong, float>();
        static XRate ins;
        void Init()
        {
            ins = this;
        }

        bool skip;
        bool isday;
        void OnHour()
        {
            if (TOD_Sky.Instance.Cycle.Hour > TOD_Sky.Instance.SunriseTime && TOD_Sky.Instance.Cycle.Hour <= 19f && !isday) OnSunrise();
            else if ((TOD_Sky.Instance.Cycle.Hour >= 19f || TOD_Sky.Instance.Cycle.Hour < TOD_Sky.Instance.SunriseTime) && isday) OnSunset();
        }

        void OnSunrise()
        {
            TOD_Sky.Instance.Components.Time.DayLengthInMinutes = daytime;
            isday = true;
            if (upnight > 1f)
            {
                Server.Broadcast(config.messages[1]);
                nightupdate();
            }
        }

        #region ГОЛОСОВАНИЕ
        const string REFRESHGUI = "[{\"name\":\"daytext\",\"parent\":\"day\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{day}\",\"fontSize\":18,\"align\":\"MiddleCenter\",\"color\":\"1 1 1 0.7921728\",\"fadeIn\":0.5},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.392941\",\"distance\":\"0.5 0.5\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]},{\"name\":\"neighttext\",\"parent\":\"night\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{night}\",\"fontSize\":18,\"align\":\"MiddleCenter\",\"color\":\"1 1 1 0.7921569\",\"fadeIn\":0.5},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.3948711\",\"distance\":\"0.5 0.5\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]}]";
        const string GUI = "[{\"name\":\"Main\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0 0 0 0.2035446\",\"fadeIn\":0.5},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 1\",\"anchormax\":\"0.5 1\",\"offsetmin\":\"-100 -65\",\"offsetmax\":\"100 -35\"}]},{\"name\":\"day\",\"parent\":\"Main\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"chat.say /voteday\",\"color\":\"1 1 1 0.3929416\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"0.5 1\",\"offsetmax\":\"0 0\"}]},{\"name\":\"daytext\",\"parent\":\"day\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{day}\",\"fontSize\":18,\"align\":\"MiddleCenter\",\"color\":\"1 1 1 0.7921728\",\"fadeIn\":0.5},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.392941\",\"distance\":\"0.5 0.5\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]},{\"name\":\"night\",\"parent\":\"Main\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"chat.say /votenight\",\"color\":\"0 0 0 0.3929408\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]},{\"name\":\"neighttext\",\"parent\":\"night\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{night}\",\"fontSize\":18,\"align\":\"MiddleCenter\",\"color\":\"1 1 1 0.7921569\",\"fadeIn\":0.5},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.3948711\",\"distance\":\"0.5 0.5\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]}]";
        static string CONSTVOTE = "";

        void CLEARVOTE()
        {
            Vtimer?.Destroy();
            Vday = 0;
            Vnight = 0;
            voted.Clear();
        }

        void StartVote()
        {
            activevote = true;
            CLEARVOTE();
            Debug.LogWarning("-Голосование за пропуск ночи-");
            Server.Broadcast("<color=yellow>Начато голосование за пропуск ночи. Нажмите на ДЕНЬ или НОЧЬ или пропишите в чат /voteday - за день или /votenight - за ночь.</color>");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = Network.Net.sv.connections }, null, "DestroyUI", "Main");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = Network.Net.sv.connections }, null, "AddUI", CONSTVOTE);
            Vtimer = timer.Once(30f, () => EndVote());
        }

        void EndVote()
        {
            activevote = false;
            if (Vday > Vnight)
            {
                TOD_Sky.Instance.Cycle.Hour += (24 - TOD_Sky.Instance.Cycle.Hour) + TOD_Sky.Instance.SunriseTime;
                OnSunrise();
                Server.Broadcast("<color=yellow>Большинство проголосовало за день. Пропускаем ночь...</color>");
                Debug.LogWarning("-Пропускаем ночь-");
            }
            else
            {
                Debug.LogWarning("-Ночь остается-");
                Server.Broadcast("<color=yellow>— Да будет свет! — сказал электрик и перерезал провода.</color>");
            }
            CLEARVOTE();
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = Network.Net.sv.connections }, null, "DestroyUI", "Main");
        }

        Timer Vtimer;
        bool activevote;
        static int Vday;
        static int Vnight;
        static List<ulong> voted = new List<ulong>();

        private void REFRESHME()
        {
            List<Network.Connection> sendto = Network.Net.sv.connections.Where(x => voted.Contains(x.userid)).ToList();
            string RGUI = REFRESHGUI.Replace("{day}", Vday.ToString()).Replace("{night}", Vnight.ToString());
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "DestroyUI", "daytext");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "DestroyUI", "neighttext");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "AddUI", RGUI);
        }

        private void cmdvoteday(BasePlayer player, string command, string[] args)
        {
            if (!CHECKPOINT(player)) return;

            player.ChatMessage("<color=yellow>Голос за ДЕНЬ успешно принят.</color>");
            Vday++;
            voted.Add(player.userID);
            REFRESHME();
            if (Vday > BasePlayer.activePlayerList.Count * 0.6f) EndVote();
        }

        private void cmdvotenight(BasePlayer player, string command, string[] args)
        {
            if (!CHECKPOINT(player)) return;

            player.ChatMessage("<color=yellow>Голос за НОЧЬ успешно принят.</color>");
            Vnight++;
            voted.Add(player.userID);
            REFRESHME();
            if (Vnight > BasePlayer.activePlayerList.Count * 0.6f) EndVote();
        }

        bool CHECKPOINT(BasePlayer player)
        {
            if (!activevote)
            {
                player.ChatMessage("<color=yellow>ГОЛОСОВАНИЕ НЕ АКТИВНО!</color>");
                return false;
            }

            if (voted.Contains(player.userID))
            {
                player.ChatMessage("<color=yellow>ВЫ УЖЕ ГОЛОСОВАЛИ!</color>");
                return false;
            }

            return true;
        }
        #endregion

        void OnSunset()
        {
            if (skip) return;
            if (config.daynight.skipnight)
            {
                Env.time = 23.99f;
                skip = true;
                timer.Once(8f, () =>
                {
                    Env.time = TOD_Sky.Instance.SunriseTime;
                    skip = false;
                });
                Debug.Log("Пропускаем ночь.");
                return;
            }
            else if (config.daynight.vote) StartVote();

            TOD_Sky.Instance.Components.Time.DayLengthInMinutes = nighttime;
            isday = false;
            if (upnight > 1f)
            {
                Server.Broadcast(config.messages[0].Replace("{num}", (config.daynight.upnight * 100f).ToString()));
                nightupdate();
            }
        }

        void nightupdate()
        {
            if (cash.Count > 0) foreach (var id in cash.ToList()) getuserrate(id.Key);
            if (cashcariers.Count > 0) foreach (var id in cashcariers.ToList()) CashCarier(id.Key);
        }

        float daytime;
        float nighttime;
        float upnight;
        TOD_Time comp;
        void OnServerInitialized()
        {
            if(config.blacklist == null || config.blacklist.Length == 0)
            {
                config.blacklist = new string[]
                {
                    "sticks",
                    "flare"
                };
                SaveConfig();
            }

            if(config.daynight == null)
            {
                config.daynight = new daynight
                {
                    day = 50f,
                    night = 10f,
                    enable = true,
                    skipnight = false,
                    upnight = 0f,
                    vote = false
                };
                SaveConfig();
            }

            if (config.rates.lockbox == 0f)
            {
                config.rates.lockbox = config.rates.box;
                foreach (var x in config.privilige) x.Value.lockbox = x.Value.box;
                SaveConfig();
            }

            if (config.daynight.enable)
            {
                if (config.daynight.vote)
                {
                    CONSTVOTE = GUI.Replace("{day}", "ДЕНЬ").Replace("{night}", "НОЧЬ");
                    Interface.Oxide.GetLibrary<ru.Libraries.Command>(null).AddChatCommand("voteday", this, "cmdvoteday");
                    Interface.Oxide.GetLibrary<ru.Libraries.Command>(null).AddChatCommand("votenight", this, "cmdvotenight");
                }
                daytime = config.daynight.day * 24f / (19f - TOD_Sky.Instance.SunriseTime);
                nighttime = config.daynight.night * 24f / (24f - (19f - TOD_Sky.Instance.SunriseTime));
                upnight = 1f + config.daynight.upnight;
                comp = TOD_Sky.Instance.Components.Time;
                comp.ProgressTime = true;
                comp.UseTimeCurve = false;
                comp.OnSunrise += OnSunrise;
                comp.OnSunset += OnSunset;
                comp.OnHour += OnHour;

                if (TOD_Sky.Instance.Cycle.Hour > TOD_Sky.Instance.SunriseTime && TOD_Sky.Instance.Cycle.Hour <= 19f) OnSunrise();
                else OnSunset();
            }

            var ovens = UnityEngine.Object.FindObjectsOfType<BaseOven>();
            for (var i = 0; i < ovens.Length; i++)
            {
                OnEntitySpawned(ovens[i]);
            }
            timer.Once(1f, () =>
            {
                foreach (BaseOven oven in ovens)
                {
                    var component = oven.GetComponent<FurnaceController>();
                    if (oven == null || oven.IsDestroyed || !oven.IsOn()) continue;
                    component.StartCooking();
                }
            });
            foreach (string perm in config.privilige.Keys) permission.RegisterPermission(perm, this);
            foreach (BasePlayer player in BasePlayer.activePlayerList) getuserrate(player.UserIDString);
        }

        void OnGroupPermissionGranted(string name, string perm)
        {
            foreach (BasePlayer player in BasePlayer.allPlayerList)
            {
                if (permission.UserHasGroup(player.UserIDString, name)) getuserrate(player.UserIDString);
            }
        }

        void OnGroupPermissionRevoked(string name, string perm)
        {
            foreach (BasePlayer player in BasePlayer.allPlayerList)
            {
                if (permission.UserHasGroup(player.UserIDString, name)) getuserrate(player.UserIDString);
            }
        }

        void OnUserGroupRemoved(string id, string groupName)
        {
            getuserrate(id);
        }

        void OnUserGroupAdded(string id, string groupName)
        {
            getuserrate(id);
        }

        void OnUserPermissionGranted(string id, string permName)
        {
            getuserrate(id);
        }

        void OnUserPermissionRevoked(string id, string permName)
        {
            getuserrate(id);
        }

        void OnPlayerConnected(BasePlayer player)
        {
            getuserrate(player.UserIDString);
        }

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (cash.ContainsKey(player.UserIDString)) cash.Remove(player.UserIDString);
        }
        #endregion

        #region Rates
        [ChatCommand("rate")]
        private void cmdRATE(BasePlayer player, string command, string[] args)
        {
            player.ChatMessage(config.messages[2].Replace("{name}", player.displayName).Replace("{0}", cash[player.UserIDString].grab.ToString()).Replace("{1}", cash[player.UserIDString].gather.ToString()).Replace("{2}", cash[player.UserIDString].carier.ToString()).Replace("{3}", cash[player.UserIDString].box.ToString()).Replace("{4}", cash[player.UserIDString].npc.ToString()).Replace("{5}", cash[player.UserIDString].speed.ToString()).Replace("{6}", cash[player.UserIDString].sulfur.ToString()));
        }

        [PluginReference] private Plugin ZREWARDME;

        void getuserrate(string id, float bonus = 0f)
        {
            rateset rate = config.privilige.LastOrDefault(x => permission.UserHasPermission(id, x.Key)).Value ?? config.rates;
            if (!cash.ContainsKey(id)) cash[id] = new rateset();
            if (ZREWARDME != null && bonus == 0f) bonus = ZREWARDME.Call<float>("APIBONUS", id);
            if (upnight > 1f && !isday)
            {
                cash[id].box = rate.box * upnight;
                cash[id].carier = rate.carier * upnight;
                cash[id].gather = rate.gather * upnight;
                cash[id].grab = rate.grab * upnight;
                cash[id].lockbox = rate.lockbox * upnight;
                cash[id].npc = rate.npc * upnight;
                cash[id].sulfur = rate.sulfur * upnight;
            }
            else
            {
                cash[id].box = rate.box;
                cash[id].carier = rate.carier;
                cash[id].gather = rate.gather;
                cash[id].grab = rate.grab;
                cash[id].lockbox = rate.lockbox;
                cash[id].npc = rate.npc;
                cash[id].sulfur = rate.sulfur;
            }

            if(bonus > 0f)
            {
                cash[id].gather += bonus;
                cash[id].grab += bonus;
                cash[id].sulfur += bonus;
            }

            cash[id].speed = rate.speed;
        }

        private void OnCollectiblePickup(CollectibleEntity collectible, BasePlayer player)
        {
            if (player == null || collectible == null) return;
            foreach (var itemAmount in collectible.itemList)
                if(itemAmount != null && itemAmount.itemDef != null)
                {
                    if (config.blacklist.Contains(itemAmount.itemDef.shortname)) return;
                    itemAmount.amount = (int)(itemAmount.amount * cash[player.UserIDString].grab);
                }
        }

        void OnGrowableGather(GrowableEntity plant, Item item, BasePlayer player)
        {
            if (player == null || item == null) return;
            if (config.blacklist.Contains(item.info.shortname)) return;
            item.amount = (int)(item.amount * cash[player.UserIDString].grab);
        }

        void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            if (config.blacklist.Contains(item.info.shortname)) return;
            if (item.info.itemid.Equals(-1157596551)) item.amount = (int)(item.amount * cash[player.UserIDString].sulfur);
            else item.amount = (int)(item.amount * cash[player.UserIDString].gather);
        }

        void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            if (config.blacklist.Contains(item.info.shortname)) return;
            BasePlayer player = entity.ToPlayer();
            if (player != null)
            {
                if (item.info.itemid.Equals(-1157596551)) item.amount = (int)(item.amount * cash[player.UserIDString].sulfur);
                else item.amount = (int)(item.amount * cash[player.UserIDString].gather);
            }
            else
            {
                if (item.info.itemid.Equals(-1157596551)) item.amount *= (int)(item.amount * config.rates.sulfur);
                else item.amount *= (int)(item.amount * config.rates.gather);
            }
        }

        private void CashCarier(ulong id)
        {
            rateset rate = config.privilige.LastOrDefault(x => permission.UserHasPermission(id.ToString(), x.Key)).Value ?? config.rates;
            if (!isday && upnight > 1f) cashcariers[id] = rate.carier * upnight;
            else cashcariers[id] = rate.carier;
        }

        private object OnExcavatorGather(ExcavatorArm arm, Item item)
        {
            if (config.blacklist.Contains(item.info.shortname)) return null;
            item.amount = (int)(item.amount * config.rates.carier);
            return null;
        }

        private void OnQuarryToggled(BaseEntity entity, BasePlayer player)
        {
            CashCarier(entity.OwnerID);
        }

        void OnQuarryGather(MiningQuarry quarry, Item item)
        {
            if (config.blacklist.Contains(item.info.shortname)) return;
            float rate;
            if (!cashcariers.TryGetValue(quarry.OwnerID, out rate))
            {
                CashCarier(quarry.OwnerID);
                rate = cashcariers[quarry.OwnerID];
            }
            item.amount = (int)(item.amount * rate);
        }
        /*
        object OnQuarryGather(MiningQuarry quarry, List<ResourceDepositManager.ResourceDeposit.ResourceDepositEntry> itemList)
        {
            if (!cashcariers.ContainsKey(quarry.OwnerID)) CashCarier(quarry.OwnerID);
            foreach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in itemList)
            {
                if ((quarry.canExtractLiquid || !resource.isLiquid) && (quarry.canExtractSolid || resource.isLiquid))
                {
                    resource.workDone += quarry.workToAdd;
                    if ((double)resource.workDone >= (double)resource.workNeeded)
                    {
                        int iAmount = Mathf.FloorToInt(resource.workDone / resource.workNeeded);
                        resource.workDone -= (float)iAmount * resource.workNeeded;
                        Item obj = ItemManager.Create(resource.type, (int)(iAmount * cashcariers[quarry.OwnerID]), 0UL);
                        if (!obj.MoveToContainer(quarry.hopperPrefab.instance.GetComponent<StorageContainer>().inventory, -1, true))
                        {
                            obj.Remove(0.0f);
                            quarry.SetOn(false);
                        }
                    }
                }
            }
            if (!quarry.FuelCheck()) quarry.SetOn(false);
            return false;
        }*/

        void OnContainerDropItems(ItemContainer container)
        {
            LootContainer lootcont = container.entityOwner as LootContainer;
            if (lootcont == null || lootcont.OwnerID != 0) return;
            var player = lootcont?.lastAttacker?.ToPlayer();
            if (lootcont.HasFlag(BaseEntity.Flags.Reserved7) || lootcont.HasFlag(BaseEntity.Flags.Reserved8)) return;
            
            if (player != null && cash.ContainsKey(player.UserIDString))
            {
                foreach (var item in lootcont.inventory.itemList)
                {
                    int maxstack = item.MaxStackable();
                    if (maxstack  == 1 || config.blacklist.Contains(item.info.shortname) || item.IsBlueprint()) continue;
                    item.amount = (int)(item.amount * cash[player.UserIDString].box);
                    if (item.amount > maxstack) item.amount = maxstack;
                }
            }
            else
            {
                foreach (var item in lootcont.inventory.itemList.Where(x => x.info.stackable > 1))
                {
                    int maxstack = item.MaxStackable();
                    if (maxstack == 1 || config.blacklist.Contains(item.info.shortname) || item.IsBlueprint()) continue;
                    item.amount = (int)(item.amount * config.rates.box);
                    if (item.amount > maxstack) item.amount = maxstack;
                }
            }
        }

        private void OnEntityDeath(BaseNetworkable entity, HitInfo info)
        {
            if (entity is BaseHelicopter && config.exp)
            {
                HackableLockedCrate ent = (HackableLockedCrate)GameManager.server.CreateEntity("assets/prefabs/deployable/chinooklockedcrate/codelockedhackablecrate.prefab", entity.transform.position, entity.transform.rotation);
                ent.Spawn();
            }
        }

        private void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            if (player == null || entity == null) return;
            if (entity is NPCPlayerCorpse)
            {
                if (entity.HasFlag(BaseEntity.Flags.Reserved7) || entity.HasFlag(BaseEntity.Flags.Reserved8)) return;
                ItemContainer cont = entity.GetComponent<NPCPlayerCorpse>().containers.FirstOrDefault();
                foreach (var item in cont.itemList.Where(x => x.info.stackable > 1))
                {
                    int maxstack = item.MaxStackable();
                    if (maxstack == 1 || config.blacklist.Contains(item.info.shortname) || item.IsBlueprint()) continue;
                    item.amount = (int)(item.amount * cash[player.UserIDString].npc);
                    if (item.amount > maxstack) item.amount = maxstack;
                }
                entity.SetFlag(BaseEntity.Flags.Reserved7, true);
            }
            else if (entity is LootContainer)
            {
                LootContainer lootcont = entity.GetComponent<LootContainer>();
                if (lootcont == null || lootcont.HasFlag(BaseEntity.Flags.Reserved7) || lootcont.HasFlag(BaseEntity.Flags.Reserved8)) return;
                if (entity is HackableLockedCrate)
                {
                    foreach (var item in lootcont.inventory.itemList.Where(x => x.info.stackable > 1))
                    {
                        int maxstack = item.MaxStackable();
                        if (maxstack == 1 || config.blacklist.Contains(item.info.shortname) || item.IsBlueprint()) continue;
                        item.amount = (int)(item.amount * cash[player.UserIDString].lockbox);
                        if (item.amount > maxstack) item.amount = maxstack;
                    }
                }
                else
                {
                    foreach (var item in lootcont.inventory.itemList.Where(x => x.info.stackable > 1))
                    {
                        int maxstack = item.MaxStackable();
                        if (maxstack == 1 || config.blacklist.Contains(item.info.shortname) || item.IsBlueprint()) continue;
                        item.amount = (int)(item.amount * cash[player.UserIDString].box);
                        if (item.amount > maxstack) item.amount = maxstack;
                    }
                }
                lootcont.SetFlag(BaseEntity.Flags.Reserved7, true);
            }
        }
        #endregion

        #region Smelt
        private void Unload()
        {

            if (comp != null)
            {
                comp.OnSunrise -= OnSunrise;
                comp.OnSunset -= OnSunset;
                comp.OnHour -= OnHour;
            }
            if (config.daynight.vote) CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = Network.Net.sv.connections }, null, "DestroyUI", "Main");
            
            var ovens = UnityEngine.Object.FindObjectsOfType<BaseOven>();

            foreach (BaseOven oven in ovens)
            {
                var component = oven.GetComponent<FurnaceController>();
                if (oven.IsOn())
                {
                    component.StopCooking();
                    oven.StartCooking();
                }
                UnityEngine.Object.Destroy(component);
            }
        }

        private void OnEntitySpawned(BaseNetworkable entity)
        {
            if (entity == null) return;
            else if (entity is BaseOven) entity?.gameObject?.AddComponent<FurnaceController>();
        }

        private object OnOvenToggle(StorageContainer oven, BasePlayer player)
        {
            if (oven is BaseFuelLightSource) return null;
            FurnaceController component = oven.GetComponent<FurnaceController>();
            if (component == null) component = oven.gameObject.AddComponent<FurnaceController>();
            if (oven.IsOn())
            {
                component.StopCooking();
            }
            else
            {
                component.StartCooking();
                component.SetSpeed(cash[player.UserIDString].speed);
            }
            return false;
        }

        public class FurnaceController : FacepunchBehaviour
        {
            private BaseOven _oven;
            private BaseOven Furnace
            {
                get
                {
                    if (_oven == null) _oven = GetComponent<BaseOven>();
                    return _oven;
                }
            }
            private float _speedMultiplier;
            private int amountmultiplier;
            private int amount;

            private void Awake()
            {
                SetSpeed(ins.config.rates.speed);
                amount = amountmultiplier;
            }

            public void SetSpeed(float newspeed)
            {
                _speedMultiplier = newspeed;
                amountmultiplier = ins.config.rates.oven;
            }

            private Item FindBurnable()
            {
                if (Furnace.inventory == null) return null;

                foreach (var item in Furnace.inventory.itemList)
                {
                    var component = item.info.GetComponent<ItemModBurnable>();
                    if (component && (Furnace.fuelType == null || item.info == Furnace.fuelType))
                    {
                        return item;
                    }
                }

                return null;
            }

            public void Cook()
            {
                var item = FindBurnable();
                if (item == null)
                {
                    StopCooking();
                    return;
                }

                SmeltItems();
                var slot = Furnace.GetSlot(BaseEntity.Slot.FireMod);
                if (slot) slot.SendMessage("Cook", 0.5f, SendMessageOptions.DontRequireReceiver);

                var component = item.info.GetComponent<ItemModBurnable>();
                item.fuel -= 5f;
                if (!item.HasFlag(global::Item.Flag.OnFire))
                {
                    item.SetFlag(global::Item.Flag.OnFire, true);
                    item.MarkDirty();
                }

                if (item.fuel <= 0f) ConsumeFuel(item, component);
            }

            private void ConsumeFuel(Item fuel, ItemModBurnable burnable)
            {
                if (Furnace.allowByproductCreation && burnable.byproductItem != null && Random.Range(0f, 1f) > burnable.byproductChance)
                {
                    var def = burnable.byproductItem;
                    var item = ItemManager.Create(def, burnable.byproductAmount * amountmultiplier);
                    if (!item.MoveToContainer(Furnace.inventory))
                    {
                        StopCooking();
                        item.Drop(Furnace.inventory.dropPosition, Furnace.inventory.dropVelocity);
                    }
                }
                amount = amountmultiplier;
                if (fuel.amount <= amountmultiplier)
                {
                    fuel.Remove();
                    return;
                }
                fuel.amount -= amountmultiplier;
                fuel.fuel = burnable.fuelAmount;
                fuel.MarkDirty();
            }
            private Dictionary<Item, float> cook = new Dictionary<Item, float>();
            private void SmeltItems()
            {
                for (var i = 0; i < Furnace.inventory.itemList.Count; i++)
                {
                    var item = Furnace.inventory.itemList[i];
                    if (item == null || !item.IsValid()) continue;

                    var cookable = item.info.GetComponent<ItemModCookable>();
                    if (cookable == null) continue;

                    var temperature = item.temperature;
                    if ((temperature < cookable.lowTemp || temperature > cookable.highTemp))
                    {
                        if (!cookable.setCookingFlag || !item.HasFlag(global::Item.Flag.Cooking)) continue;
                        item.SetFlag(global::Item.Flag.Cooking, false);
                        item.MarkDirty();
                        continue;
                    }
                    if (cook.ContainsKey(item)) cook[item] += 0.5f;
                    else cook[item] = 0.5f;
                    if (cook[item] < (cookable.cookTime / _speedMultiplier)) continue;
                    cook[item] = 0f;
                    if (cookable.setCookingFlag && !item.HasFlag(global::Item.Flag.Cooking))
                    {
                        item.SetFlag(global::Item.Flag.Cooking, true);
                        item.MarkDirty();
                    }
                    int position = item.position;
                    int amount2 = item.amount;
                    if (amount2 > amount)
                    {
                        item.amount -= amount;
                        item.MarkDirty();
                    }
                    else
                    {
                        item.Remove();
                    }

                    if (cookable.becomeOnCooked == null) continue;
                    int newamount = cookable.amountOfBecome * amount;
                    var item2 = ItemManager.Create(cookable.becomeOnCooked, amount2 < newamount ? amount2 : newamount);

                    if (item2 == null || item2.MoveToContainer(item.parent, position) || item2.MoveToContainer(item.parent)) continue;
                    item2.Drop(item.parent.dropPosition, item.parent.dropVelocity);
                    if (!item.parent.entityOwner) continue;
                    StopCooking();
                }
            }

            public void StartCooking()
            {
                if (FindBurnable() == null) return;

                StopCooking();

                Furnace.inventory.temperature = Furnace.cookingTemperature;
                Furnace.UpdateAttachmentTemperature();

                Furnace.InvokeRepeating(Cook, 0.5f, 0.5f);
                Furnace.SetFlag(BaseEntity.Flags.On, true);
            }

            public void StopCooking()
            {
                cook.Clear();
                Furnace.CancelInvoke(Cook);
                Furnace.StopCooking();
            }
        }
        #endregion
    }
}

// --- End of file: XRate.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/TeamMarker.cs ---
// --- Original Local Path: BeeRust/TeamMarker.cs ---

﻿﻿using System;
 using System.Collections.Generic;
 using Newtonsoft.Json;
using Oxide.Core;
 using UnityEngine;
 using VLB;

 namespace Oxide.Plugins
{
    [Info("TeamMarker", "Seires", "1.0.2")]
    [Description("Displays marker for you and your teammates.")]
    
    class TeamMarker : RustPlugin
    {
        #region Classes

        private class PluginConfig
        {
            [JsonProperty("Activation button (Check list for valid buttons below)")] 
            public string ActivateButton;
            [JsonProperty("Marker symbol (From ASCII table: https://www.ascii-code.com)")]
            public char MarkerSymbol;
            [JsonProperty("The time how long marker is visible")]
            public int MarkerTime;
            [JsonProperty("Cooldown time")]
            public int MarkerDelay;
            [JsonProperty("Max distance to locate the marker")]
            public int MarkerDist;
            [JsonProperty("Marker color")] 
            public string MarkerColor;
            [JsonProperty("Font size of marker info")]
            public int InfoFontSize;
            [JsonProperty("Color of text")] 
            public string InfoTextColor;
            [JsonProperty("Effect prefab")] 
            public string EffectPrefab;

            [JsonIgnore] public BUTTON ActButton;
            
            [JsonProperty("Buttons list (Read only)")] 
            public string[] Buttons = Enum.GetNames(typeof(BUTTON));
        }
        
        #endregion
        
        #region Variables

        private static TeamMarker _plugin;
        
        private static PluginConfig _config;
        private const string PermissionUse = "teammarker.use";
        private Effect _effect = new Effect();

        #endregion
        
        #region Config

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                _config = Config.ReadObject<PluginConfig>();
                if (_config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                for (var i = 0; i < 3; i++)
                {
                    PrintError("Configuration file is corrupt! Check your config file at https://jsonlint.com/");
                }

                LoadDefaultConfig();
                return;
            }

            if (_config != null)
            {
                _config.ActButton = BUTTON.FIRE_THIRD;
                Enum.TryParse(_config.ActivateButton, out _config.ActButton);
            }
            
            ValidateConfig();
            SaveConfig();
        }

        private void ValidateConfig()
        {
            if (Interface.Oxide.CallHook("OnConfigValidate") != null)
            {
                PrintWarning("Using default configuration...");
                _config = GetDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        protected override void LoadDefaultConfig()
        {
            _config = GetDefaultConfig();
        }
        
        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig()
            {
                ActivateButton = "FIRE_THIRD",
                MarkerSymbol = '¤',
                MarkerTime = 4,
                MarkerDelay = 1,
                MarkerDist = 200,
                MarkerColor = "#cc0000",
                InfoFontSize = 12,
                InfoTextColor = "#222222",
                EffectPrefab = "assets/bundled/prefabs/fx/notice/loot.copy.fx.prefab"
            };
        }
        
        #endregion

        #region Hooks

        void OnServerInitialized()
        {
            _plugin = this;
            
            RegPermission(PermissionUse);

            _effect.Init(Effect.Type.Generic, Vector3.zero, Vector3.zero);
            _effect.pooledString = _config.EffectPrefab;
            
            for (var i = BasePlayer.activePlayerList.Count - 1; i >= 0; i--)
            {
                OnPlayerConnected(BasePlayer.activePlayerList[i]);
            }
        }

        void Unload()
        {
            InputController.DestroyAll();
        }
        
        void OnPlayerConnected(BasePlayer player)
        {
            if (player == null) return;

            if (player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.Once(2f, () => OnPlayerConnected(player));
                return;
            }

            if (!player.IsConnected) return;
            
            InputController.Init(player);
        }

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            var comp = player.GetComponent<InputController>();
            if(comp != null)
                UnityEngine.Object.Destroy(comp);
        }

        #endregion
        
        #region Utils

        void PlayFx(BasePlayer player)
        {
            EffectNetwork.Send(_effect, player.net.connection);
        }

        public void RegPermission(string name)
        {
            if (permission.PermissionExists(name)) return;
            permission.RegisterPermission(name, this);
        }
        
        public bool HasPermission(BasePlayer player, string name)
        {
            if (player.IsAdmin)
                return true;
            
            return permission.UserHasPermission(player.UserIDString, name);
        }

        #endregion

        #region Scripts

        private class InputController : MonoBehaviour
        {
            public static List<InputController> InputControllers = new List<InputController>();
            private BasePlayer _player;
            private RealTimeSince _markerCooldown;
            private RealTimeSince _markerLifeTime;
            private Vector3 _lastMarkerPosition;

            public static void Init(BasePlayer player)
            {
                player.GetOrAddComponent<InputController>();
            }

            public static void DestroyAll()
            {
                for (var i = InputControllers.Count - 1; i >= 0; i--)
                {
                    Destroy(InputControllers[i]);
                }
            }
            
            private void Awake()
            {
                _player = GetComponent<BasePlayer>();
                if (_player == null)
                {
                    Destroy(this);
                    return;
                }
                
                InputControllers.Add(this);
            }

            private void Update()
            {
                if (_player.serverInput.WasJustPressed(_config.ActButton) == false) 
                    return;
                
                if (_markerCooldown < _config.MarkerDelay)
                    return;
                
                _markerCooldown = 0;

                MarkerCheck();
            }

            private void MarkerCheck()
            {
                if(_plugin.HasPermission(_player, PermissionUse) == false) 
                    return;
                
                if(IsInvoking(nameof(MarkerUpdate)))
                    CancelInvoke(nameof(MarkerUpdate));
                
                DrawMarker();
            }

            private void DrawMarker()
            {
                Ray ray = new Ray(_player.eyes.position, _player.eyes.HeadForward());
                RaycastHit hit;
                
                if (Physics.Raycast(ray, out hit, _config.MarkerDist,
                    LayerMask.GetMask(new[] {"Terrain", "World", "Construction", "Player (Server)", "Deployed"})) == false) return;
                
                _lastMarkerPosition = hit.point;

                if (_lastMarkerPosition == Vector3.zero)
                    return;

                _markerLifeTime = 0;

                if (_player.currentTeam == 0)
                    _plugin.PlayFx(_player);
                else
                {
                    foreach (var member in _player.Team.GetOnlineMemberConnections())
                    {
                        if (member.player as BasePlayer != null)
                            _plugin.PlayFx(member.player as BasePlayer);
                    }
                }

                InvokeRepeating(nameof(MarkerUpdate), 0f, 0.1f);
            }

            private void MarkerUpdate()
            {
                if (_markerLifeTime >= _config.MarkerTime)
                {
                    CancelInvoke(nameof(MarkerUpdate));
                    return;
                }

                if (_player.currentTeam == 0)
                {
                    _player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
                    _player.SendEntityUpdate();
                    _player.SendConsoleCommand("ddraw.text", 0.1f, Color.white, _lastMarkerPosition,
                        $"<color={_config.MarkerColor}>{_config.MarkerSymbol}</color>\n<color={_config.InfoTextColor}><size={_config.InfoFontSize}>{Math.Round(Vector3.Distance(_player.transform.position, _lastMarkerPosition))} m</size></color>");
                    _player.SendConsoleCommand("camspeed 0");

                    if(_player.Connection.authLevel < 2)
                        _player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
            
                    _player.SendEntityUpdate();
                }
                else
                {
                    var members = _player.Team.GetOnlineMemberConnections();

                    for (var i = members.Count - 1; i >= 0; i--)
                    {
                        var member = members[i].player as BasePlayer;

                        if (member == null)
                            continue;
                        
                        member.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
                        member.SendEntityUpdate();
                        member.SendConsoleCommand("ddraw.text", 0.1f, Color.white, _lastMarkerPosition,
                            $"<color={_config.MarkerColor}>{_config.MarkerSymbol}</color>\n<color={_config.InfoTextColor}><size={_config.InfoFontSize}>{Math.Round(Vector3.Distance(member.transform.position, _lastMarkerPosition))} m\n{_player.displayName}</size></color>");
                        member.SendConsoleCommand("camspeed 0");

                        if(member.Connection.authLevel < 2)
                            member.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
            
                        member.SendEntityUpdate();
                    }
                }
            }
        }

        #endregion
    }
}

// --- End of file: TeamMarker.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/Obmen.cs ---
// --- Original Local Path: BeeRust/Obmen.cs ---

using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Obmen", "kurushimu", "1.1")]
    class Obmen : RustPlugin
    {
        private bool loaded = false;
        
        private string Layer = "https://gspics.org/images/2022/02/02/04Kz73.jpg";
        
        string[] FirstWord = { "100К КАМНЯ НА 200К ДЕРЕВА", "100К КАМНЯ НА 2 ТУРЕЛИ", "500К КАМНЯ НА 2К МВК", "125 СКРАПА НА БУР"};
        string[] FirsttWord = { "50К СКРАПА НА 20К МЕТАЛЛА", "50К СКРАПА НА 100К ТНК", "500К ЖЕЛЕЗА НА 5К МВК", "200К ЖЕЛЕЗА НА 50К СЕРЫ"};
        string[] Command = { "obmen 0", "obmen 1", "obmen 2", "obmen 3"};
        string[] Commandd = { "obmen 4", "obmen 5", "obmen 6", "obmen 7"};

        void OnServerInitialized()
        {
            InitFileManager();
            ServerMgr.Instance.StartCoroutine(LoadImages());
        }
        
        private Dictionary<string, string> images = new Dictionary<string, string>()
        {
            ["Img0"] = "https://cdn.discordapp.com/attachments/1120005237642637352/1120008767187198073/8eTRs6p.png",
            ["Img1"] = "https://cdn.discordapp.com/attachments/1120005237642637352/1120008767187198073/8eTRs6p.png",
            ["Img2"] = "https://cdn.discordapp.com/attachments/1120005237642637352/1120008767187198073/8eTRs6p.png",
            ["Img3"] = "https://cdn.discordapp.com/attachments/1120005237642637352/1120019074156601384/c0fa952d07bbf02f55ed344b3260763b.png",
            ["Imgg0"] = "https://cdn.discordapp.com/attachments/1120005237642637352/1120019074156601384/c0fa952d07bbf02f55ed344b3260763b.png",
            ["Imgg1"] = "https://cdn.discordapp.com/attachments/1120005237642637352/1120019074156601384/c0fa952d07bbf02f55ed344b3260763b.png",
            ["Imgg2"] = "https://cdn.discordapp.com/attachments/1120005237642637352/1120008826100404285/b993ZWx.png",
            ["Imgg3"] = "https://cdn.discordapp.com/attachments/1120005237642637352/1120008826100404285/b993ZWx.png",
            
            ["Image0"] = "https://cdn.discordapp.com/attachments/1092142749035278414/1107663194513747968/Z4vaStO.png",
            ["Image1"] = "https://cdn.discordapp.com/attachments/1120005237642637352/1120021705339981834/autoturret.png",
            ["Image2"] = "https://cdn.discordapp.com/attachments/1120005237642637352/1120023014612947014/metal.png",
            ["Image3"] = "https://cdn.discordapp.com/attachments/1120005237642637352/1120023133819252858/jackhammer.png",
            ["Imagge0"] = "https://cdn.discordapp.com/attachments/1120005237642637352/1120008826100404285/b993ZWx.png",
            ["Imagge1"] = "https://cdn.discordapp.com/attachments/1120005237642637352/1120019173070884904/b71e9693f9f878566e75d324240fb41e.png",
            ["Imagge2"] = "https://cdn.discordapp.com/attachments/1120005237642637352/1120023014612947014/metal.png",
            ["Imagge3"] = "https://cdn.discordapp.com/attachments/1120005237642637352/1120009100424659004/gwRK5qo.png",
            ["bgr"] = "https://cdn.discordapp.com/attachments/1108899003933933610/1119372699567931502/sdfgdsf.png",
            ["but"] = "https://cdn.discordapp.com/attachments/1108899003933933610/1119376261559623720/sd2fgdsf.png",
            
        };

        IEnumerator LoadImages()
        {
            foreach (var name in images.Keys.ToList())
            {
                yield return m_FileManager.StartCoroutine(m_FileManager.LoadFile(name, images[name]));
                images[name] = m_FileManager.GetPng(name);
            }
            loaded = true;
        }
        
        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, Layer);
            }
        }

        private void DrawInterface(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.8", Sprite = "Assets/Content/UI/UI.Background.Tile.psd", Material = "assets/content/ui/uibackgroundblur.mat", FadeIn = 0.3f }
            }, "Overlay", Layer);
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Close = Layer },
            }, Layer);


container.Add(new CuiElement
                {
                    Parent = Layer,
                    Components =
                    {
                        new CuiRawImageComponent() {Png = images[$"bgr"], Color = "1 1 1 1"},
                        new CuiRectTransformComponent {AnchorMin = $"0.3784375 0.7475927", AnchorMax = $"0.6191041 0.8401851"}
                    }
                });

            container.Add(new CuiElement
                {
                    Parent = Layer,
                    Components =
                    {
                        new CuiRawImageComponent() { Png = images[$"bgr"], Color = "1 1 1 1" },
                        new CuiRectTransformComponent(){  AnchorMin = "0.1358333 0.2010741", AnchorMax = "0.8641041 0.859926", OffsetMax = "0 0" },
                    }
                });

                container.Add(new CuiElement
                {
                    Parent = Layer,
                    Components =
                    {
                        new CuiTextComponent {Color = "1 1 1 1", Text = $"BeeRust", FontSize = 25, Align = TextAnchor.MiddleCenter},
                        new CuiRectTransformComponent {AnchorMin = $"0.3784375 0.7475927", AnchorMax = $"0.6191041 0.8401851"},
                        new CuiOutlineComponent {Distance = "0.4 0.4", Color = "0 0 0 1"}
                    }
                });


            
     
            double anchor1 = 0.64;
            double anchor2 = 0.74;
            double anchor3 = 0.645;
            double anchor4 = 0.735;
            double anchor1_1 = 0.645;
            double anchor1_2 = 0.735;


            for (int i = 0; i < 4; i++)
            {
                container.Add(new CuiElement
                {
                    Parent = Layer,
                    Components =
                    {
                        new CuiRawImageComponent() {Png = images[$"but"], Color = "1 1 1 1"},
                        new CuiRectTransformComponent {AnchorMin = $"0.26 {anchor1}", AnchorMax = $"0.48 {anchor2}"}
                    }
                });

                container.Add(new CuiElement
                {
                    Parent = Layer,
                    Components =
                    {
                        new CuiRawImageComponent() {Png = images[$"but"], Color = "1 1 1 1"},
                        new CuiRectTransformComponent {AnchorMin = $"0.52 {anchor1}", AnchorMax = $"0.74 {anchor2}"}
                    }
                });

                container.Add(new CuiElement
                {
                    Parent = Layer,
                    Name = Layer + $"Imgg{i}",
                    Components =
                    {
                        new CuiRawImageComponent() { Png = images[$"Imgg{i}"], Color = "1 1 1 1" },
                        new CuiRectTransformComponent(){  AnchorMin = $"0.535 {anchor1_1}", AnchorMax = $"0.585 {anchor1_2}", OffsetMin = "0 0", OffsetMax = "0 0" },
                    }
                });

                container.Add(new CuiElement
                {
                    Parent = Layer,
                    Name = Layer + $"Imagge{i}",
                    Components =
                    {
                        new CuiRawImageComponent() { Png = images[$"Imagge{i}"], Color = "1 1 1 1"},
                        new CuiRectTransformComponent(){  AnchorMin = $"0.68 {anchor1_1}", AnchorMax = $"0.73 {anchor1_2}", OffsetMin = "0 0", OffsetMax = "0 0" },
                    }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0.52 {anchor3}", AnchorMax = $"0.74 {anchor4}", OffsetMin = "0 0", OffsetMax = "0 0" },
                    Button = { Color = "1 1 1 0", Command = $"{Commandd[i]}"},
                    Text = { Text = $"{FirsttWord[i]}", Align = TextAnchor.MiddleCenter, FontSize = 10 }
                }, Layer);



                container.Add(new CuiElement
                {
                    Parent = Layer,
                    Name = Layer + $"Img{i}",
                    Components =
                    {
                        new CuiRawImageComponent() { Png = images[$"Img{i}"], Color = "1 1 1 1" },
                        new CuiRectTransformComponent(){  AnchorMin = $"0.275 {anchor1_1}", AnchorMax = $"0.325 {anchor1_2}", OffsetMin = "0 0", OffsetMax = "0 0" },
                    }
                });
                
                container.Add(new CuiElement
                {
                    Parent = Layer,
                    Name = Layer + $"Image{i}",
                    Components =
                    {
                        new CuiRawImageComponent() { Png = images[$"Image{i}"], Color = "1 1 1 1"},
                        new CuiRectTransformComponent(){  AnchorMin = $"0.42 {anchor1_1}", AnchorMax = $"0.47 {anchor1_2}", OffsetMin = "0 0", OffsetMax = "0 0" },
                    }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0.26 {anchor3}", AnchorMax = $"0.48 {anchor4}", OffsetMin = "0 0", OffsetMax = "0 0" },
                    Button = { Color = "1 1 1 0", Command = $"{Command[i]}"},
                    Text = { Text = $"{FirstWord[i]}", Align = TextAnchor.MiddleCenter, FontSize = 10 }
                }, Layer);
                
                anchor1 -= 0.105;
                anchor2 -= 0.107;
                anchor1_1 -= 0.105;
                anchor1_2 -= 0.105;
                anchor3 -= 0.11;
                anchor4 -= 0.11;
                
                CuiHelper.DestroyUi(player, Layer + $"Img{i}");
                CuiHelper.DestroyUi(player, Layer + $"Image{i}");
            } 
            
            CuiHelper.DestroyUi(player, Layer);
            CuiHelper.AddUi(player, container);
        }

        private Dictionary<string, int> _itemIds = new Dictionary<string, int>();
		private int FindItemID(string shortName)
		{
			int val;
			if (_itemIds.TryGetValue(shortName, out val))
				return val;

			var definition = ItemManager.FindItemDefinition(shortName);
			if (definition == null) return 0;

			val = definition.itemid;
			_itemIds[shortName] = val;
			return val;
		}

        [ChatCommand("obmen")]
        void Gui(BasePlayer player)
        {
            DrawInterface(player);
        }


        [ConsoleCommand("obmen")]
        void Obmen2(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            var cislo = args.Args[0];
            string newitem = "";
            string check = "";
            int z1 = 0;
            int z2 = 0;
            

            if (cislo == "0")
            {
                check = "stones";
                newitem = "wood";
                z1 = 100000;
                z2 = 200000;
            }
            if (cislo == "1")
            {
                check = "stones";
                newitem = "autoturret";
                z1 = 100000;
                z2 = 2;
            }
            if (cislo == "2")
            {
                check = "stones";
                newitem = "metal.refined";
                z1 = 500000;
                z2 = 2000;
            }
            if (cislo == "3")
            {
                check = "scrap";
                newitem = "jackhammer";
                z1 = 125;
                z2 = 1;
            }
            if (cislo == "4")
            {
                check = "scrap";
                newitem = "metal.fragments";
                z1 = 50000;
                z2 = 20000;
            }
            if (cislo == "5")
            {
                check = "scrap";
                newitem = "lowgradefuel";
                z1 = 50000;
                z2 = 100000;
            }
            if (cislo == "6")
            {
                check = "metal.fragments";
                newitem = "metal.refined";
                z1 = 500000;
                z2 = 5000;
            }
            if (cislo == "7")
            {
                check = "metal.fragments";
                newitem = "sulfur";
                z1 = 200000;
                z2 = 50000;
            }
            
            var count = player.inventory.GetAmount(ItemManager.FindItemDefinition(check).itemid);
            if(count>=z1)
            {
                player.inventory.Take(null, ItemManager.FindItemDefinition(check).itemid, z1);
                Item item;
                item = ItemManager.CreateByName(newitem, z2);
                player.GiveItem(item);
                SendReply(player, "Вы <color=#97be62>успешно</color> обменяли ресурсы");
            }
            else
            {
                SendReply(player, "У вас <color=red>недостаточно</color> ресурсов");
            }
        }
        
        		private GameObject FileManagerObject;
        private FileManager m_FileManager;

        void InitFileManager()
        {
            FileManagerObject = new GameObject("MAP_FileManagerObject");
            m_FileManager = FileManagerObject.AddComponent<FileManager>();
        }

        class FileManager : MonoBehaviour
        {
            int loaded = 0;
            int needed = 0;

            public bool IsFinished => needed == loaded;
            const ulong MaxActiveLoads = 10;
            Dictionary<string, FileInfo> files = new Dictionary<string, FileInfo>();

            DynamicConfigFile dataFile = Interface.Oxide.DataFileSystem.GetFile("Images");

            private class FileInfo
            {
                public string Url;
                public string Png;
            }

            public void SaveData()
            {
                dataFile.WriteObject(files);
            }

            public string GetPng(string name) => files[name].Png;

            private void Awake()
            {
                files = dataFile.ReadObject<Dictionary<string, FileInfo>>() ?? new Dictionary<string, FileInfo>();
            }

            public IEnumerator LoadFile(string name, string url)
            {
                if (files.ContainsKey(name) && files[name].Url == url && !string.IsNullOrEmpty(files[name].Png)) yield break;
                files[name] = new FileInfo() { Url = url };
                needed++;
                yield return StartCoroutine(LoadImageCoroutine(name, url));
            }

            IEnumerator LoadImageCoroutine( string name, string url)
            {
                using (WWW www = new WWW( url ))
                {
                    yield return www;
                    using (MemoryStream stream = new MemoryStream())
                    {
                        if (string.IsNullOrEmpty( www.error ))
                        {
                            stream.Position = 0;
                            stream.SetLength( 0 );

                            var bytes = www.bytes;

                            stream.Write( bytes, 0, bytes.Length );

                            var entityId = CommunityEntity.ServerInstance.net.ID;
                            var crc32 = FileStorage.server.Store(stream.ToArray(), FileStorage.Type.png, entityId).ToString();
                            files[ name ].Png = crc32;
                        }
                    }
                }
                loaded++;
            }
        }
    }
}

// --- End of file: Obmen.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/DiscordCore.cs ---
// --- Original Local Path: BeeRust/DiscordCore.cs ---

﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Ext.Discord;
using Oxide.Ext.Discord.Attributes;
using Oxide.Ext.Discord.Builders.MessageComponents;
using Oxide.Ext.Discord.Constants;
using Oxide.Ext.Discord.Entities;
using Oxide.Ext.Discord.Entities.Applications;
using Oxide.Ext.Discord.Entities.Channels;
using Oxide.Ext.Discord.Entities.Emojis;
using Oxide.Ext.Discord.Entities.Gatway;
using Oxide.Ext.Discord.Entities.Gatway.Events;
using Oxide.Ext.Discord.Entities.Guilds;
using Oxide.Ext.Discord.Entities.Interactions;
using Oxide.Ext.Discord.Entities.Interactions.ApplicationCommands;
using Oxide.Ext.Discord.Entities.Interactions.MessageComponents;
using Oxide.Ext.Discord.Entities.Messages;
using Oxide.Ext.Discord.Entities.Users;
using Oxide.Ext.Discord.Extensions;
using Oxide.Ext.Discord.Helpers;
using Oxide.Ext.Discord.Libraries.Command;
using Oxide.Ext.Discord.Libraries.Linking;
using Oxide.Ext.Discord.Logging;
using Random = Oxide.Core.Random;

namespace Oxide.Plugins
{
    [Info("Discord Core", "MJSU", "2.1.3")]
    [Description("Creates a link between a player and discord")]
    internal class DiscordCore : CovalencePlugin, IDiscordLinkPlugin
    {
        #region Class Fields
        [DiscordClient] private DiscordClient _client;
        
        private StoredData _storedData; //Plugin Data
        private PluginConfig _pluginConfig; //Plugin Config
        
        private const string AccentColor = "de8732";
        private const string UsePermission = "discordcore.use";

        private char[] _linkChars;

        private DiscordUser _bot;
        private DiscordGuild _guild;

        private bool _initialized;
        private readonly DiscordSettings _discordSettings = new DiscordSettings
        {
            Intents = GatewayIntents.Guilds | GatewayIntents.GuildMembers | GatewayIntents.GuildMessages | GatewayIntents.DirectMessages
        };

        private readonly Hash<string, BanInfo> _banList = new Hash<string, BanInfo>();
        private readonly List<LinkActivation> _activations = new List<LinkActivation>();
        private readonly List<Snowflake> _allowedCommandChannels = new List<Snowflake>();
        private string _allowedChannelNames;
        private char _cmdPrefix;
        
        private readonly DiscordLink _link = Interface.Oxide.GetLibrary<DiscordLink>();
        private readonly DiscordCommand _dcCommands = Interface.Oxide.GetLibrary<DiscordCommand>();

        private const string AcceptEmoji = "✅";
        private const string DeclineEmoji = "❌";
        private const string LinkAccountsButtonId = nameof(DiscordCore) + "_LinkAccounts";
        private const string MessageLinkAccountsButtonId = nameof(DiscordCore) + "_MLinkAccounts";
        private const string AcceptLinkButtonId = nameof(DiscordCore) + "_AcceptLink";
        private const string DeclineLinkButtonId = nameof(DiscordCore) + "_DeclineLink";
        #endregion

        #region Setup & Loading
        private void Init()
        {
            _storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);

            permission.RegisterPermission(UsePermission, this);

            _linkChars = _pluginConfig.LinkSettings.LinkCodeCharacters.ToCharArray();
            _cmdPrefix = _dcCommands.CommandPrefixes[0];

            _discordSettings.ApiToken = _pluginConfig.ApiKey;
            _discordSettings.LogLevel = _pluginConfig.ExtensionDebugging;
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(Config.ReadObject<PluginConfig>());
            Config.WriteObject(_pluginConfig);
        }

        public PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.LinkSettings = new DiscordLinkingSettings(config.LinkSettings);
            config.WelcomeMessageSettings = new WelcomeMessageSettings(config.WelcomeMessageSettings);
            return config;
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [LangKeys.NoPermission] = "You do not have permission to use this command",
                [LangKeys.ChatFormat] = $"[#BEBEBE][[#{AccentColor}]{Title}[/#]] {{0}}[/#]",
                [LangKeys.DiscordFormat] = $"[{Title}] {{0}}",
                [LangKeys.DiscordCoreOffline] = "Discord Core is not online. Please try again later",
                [LangKeys.Commands.Unknown] = "Unknown Command",
                [LangKeys.GenericError] = "We have encountered an error trying. PLease try again later.",
                [LangKeys.ConsolePlayerNotSupported] = "You cannot use this command from the server console.",
                [LangKeys.Commands.Leave.Errors.NotLinked] = "We were unable to unlink your account as you do not appear to have been linked.",
                
                [LangKeys.Commands.Join.Modes] = "Please select which which mode you would like to use to link with discord.\n" +
                                              $"If you wish to join using a code please type [#{AccentColor}]/{{0}} {{1}} {{2}}[/#]\n" +
                                              "If you wish to join by your discord username or id please type: \n" +
                                              $"[#{AccentColor}]/{{0}} {{1}} {{{{Username}}}}#{{{{Discriminator}}}}[/#]\n" +
                                              $"Or [#{AccentColor}]/{{0}} {{1}} {{{{Discord User ID}}}}[/#]",
                
                [LangKeys.Commands.Join.Errors.AlreadySignedUp] = $"You have already linked your discord and game accounts. If you wish to remove this link type [#{AccentColor}]{{0}}{{1}} {{2}}[/#]",
                [LangKeys.Commands.Join.Errors.UnableToFindUser] = $"Unable to find user '{{0}}' in the {{1}} discord server. Have you joined the {{1}} discord server @ [#{AccentColor}]discord.gg/{{2}}[/#]?",
                [LangKeys.Commands.Join.Errors.FoundMultipleUsers] = "Found multiple users with username '{0}' in the {1} discord server. Please include more of the username and discriminator if possible.",
                [LangKeys.Commands.Join.Errors.UsernameSearchError] = "An error occured while trying to search by username. Please try a different username or try again later.",
                [LangKeys.Commands.Join.Errors.InvalidSyntax] = $"Invalid syntax. Type [#{AccentColor}]{{0}}{{1}} code 123456[/#] where 123456 is the code you got from discord",
                [LangKeys.Commands.Join.Errors.NoPendingActivations] = "There is no link currently in progress with the code '{0}'. Please confirm your code and try again.",
                [LangKeys.Commands.Join.Errors.MustBeUsedDiscord] = "You must complete the link on discord and not through the game server.",
                [LangKeys.Commands.Join.Errors.MustBeUsedServer] = "You must complete the link on the game server and not through discord.",
                //[LangKeys.Commands.Join.Errors.LinkInProgress] = "You already have an existing link in process. Please continue from that link.",
                [LangKeys.Commands.Join.Errors.Banned] = "You have been banned from any more link attempts. You have {0}h {1}m {2}s left on your ban.",
                [LangKeys.Commands.Join.Complete.Info] = $"To complete your activation please use the following command: <color=#{AccentColor}>{{0}}{{1}} {{2}} {{3}}</color>.\n",
                [LangKeys.Commands.Join.Complete.InfoServer] = $"In order to use this command you must be in the <color=#{AccentColor}>{{0}}</color> discord server. You can join @ <color=#{AccentColor}>discord.gg/{{1}}</color>.\n",
                [LangKeys.Commands.Join.Complete.InfoGuildAny] = "This command can be used in any guild channel.\n",
                [LangKeys.Commands.Join.Complete.InfoGuildChannel] = "This command can only used in the following guild channels / categories {0}.\n",
                [LangKeys.Commands.Join.Complete.InfoAlsoDm] = "This command can also be used in a direct message to guild bot {0}",
                [LangKeys.Commands.Join.Complete.InfoDmOnly] = "This command can only be used in a direct message to the guild bot {0}",
                [LangKeys.Commands.Join.Messages.Discord.Accept] = "Accept",
                [LangKeys.Commands.Join.Messages.Discord.Decline] = "Decline",
                [LangKeys.Commands.Join.Messages.Discord.LinkAccounts] = "Link Accounts",
                [LangKeys.Commands.Join.Messages.Discord.Username] = "The player '{0}' is trying to link their game account to this discord.\n" +
                                                                     "If you could like to accept please click on the {1} button.\n" +
                                                                     "If you did not initiate this link please click on the {2} button",
                [LangKeys.Commands.Join.Messages.Chat.UsernameDmSent] = "Our bot {0} has sent you a discord direct message. Please finish your setup there.",
                [LangKeys.Commands.Join.Messages.Discord.CompletedInGame] = $"To complete your activation please use the following command: {DiscordFormatting.Bold("{0}{1} {2} {3}")} in game.",
                [LangKeys.Commands.Join.Messages.Discord.CompleteInGameResponse] = "Please check your DM's for steps on how to complete the link process.",
                [LangKeys.Commands.Join.Messages.Discord.Declined] = "We have successfully declined the link request. We're sorry for the inconvenience.",
                [LangKeys.Commands.Join.Messages.Chat.Declined] = "Your join request was declined by the discord user. Repeated declined attempts will result in a link ban.",
                [LangKeys.Linking.Chat.Linked] = "You have successfully linked with discord user {0}#{1}.",
                [LangKeys.Linking.Discord.Linked] = "You have successfully linked your discord {0}#{1} with in game player {2}",
                [LangKeys.Linking.Chat.Unlinked] = "You have successfully unlinked player {0} with your discord account.",
                [LangKeys.Linking.Discord.Unlinked] = "You have successfully unlinked your discord {0}#{1} with in game player {2}",

                [LangKeys.Notifications.Link] = "Player {0}({1}) has linked with discord {2}({3})",
                [LangKeys.Notifications.Rejoin] = "Player {0}({1}) has rejoined and was linked with discord {2}({3})",
                [LangKeys.Notifications.Unlink] = "Player {0}({1}) has unlinked their discord {2}({3})",

                [LangKeys.Guild.WelcomeMessage] = "Welcome to the {0} discord server.",
                [LangKeys.Guild.WelcomeLinkMessage] = " If you would link to link your account please click on the Link Accounts button below.",
                [LangKeys.Guild.LinkMessage] = "Welcome to the {0} discord server. " +
                                                      "This server supports linking your discord and in game accounts. " +
                                                      "If you would like to begin this process please click on the {1} button below this message.\n" +
                                                      $"{DiscordFormatting.Underline("Note: You must be in game to complete the link.")}",
                
                [LangKeys.Emoji.Accept] = AcceptEmoji,
                [LangKeys.Emoji.Decline] = DeclineEmoji,

                [LangKeys.Commands.ChatHelpText] = $"Allows players to link their player and discord accounts together. Players must first join the {{0}} Discord @ [#{AccentColor}]discord.gg/{{1}}[/#]\n" +
                                          $"Type [#{AccentColor}]/{{2}} {{3}} [/#] to start the link process\n" +
                                          $"Type [#{AccentColor}]/{{2}} {{4}}[/#] to to unlink yourself from discord\n" +
                                          $"Type [#{AccentColor}]/{{2}}[/#] to see this message again",
                
                [LangKeys.Commands.DiscordHelpText] = "Allows players to link their in game player and discord accounts together.\n" + 
                                             "Type {0}{1} {2} to start the link process\n" +
                                             "Type {0}{1} {3} to to unlink yourself from discord\n" +
                                             "Type {0}{1} to see this message again",

                //Commands
                [CommandKeys.ChatCommand] = "dc",
                [CommandKeys.ChatJoinCommand] = "join",
                [CommandKeys.ChatLeaveCommand] = "leave",
                [CommandKeys.ChatJoinCodeCommand] = "code",
                [CommandKeys.DiscordCommand] = "dc",
                [CommandKeys.DiscordJoinCommand] = "join",
                [CommandKeys.DiscordLeaveCommand] = "leave"
            }, this);
        }
        
        private void OnServerInitialized()
        {
            RegisterChatLangCommand(nameof(DiscordCoreChatCommand), CommandKeys.ChatCommand);

            _link.AddLinkPlugin(this);

            if (string.IsNullOrEmpty(_pluginConfig.ApiKey))
            {
                PrintWarning("Please set the Discord Bot Token and reload the plugin");
                return;
            }

            _client.Connect(_discordSettings);
        }
        
        private void OnPluginLoaded(Plugin plugin)
        {
            if (ReferenceEquals(this, plugin))
            {
                return;
            }
            
            DiscordCoreReady(plugin);
        }

        private void Unload()
        {
            Interface.Oxide.CallHook("OnDiscordCoreClose");
            SaveData();
        }
        #endregion
        
        #region Client Connection
        public void DiscordCoreReady(Plugin plugin)
        {
            NextTick(() =>
            {
                if (plugin == null)
                {
                    Interface.CallHook("OnDiscordCoreReady", _client, _bot, _guild);
                }
                else
                {
                    plugin.CallHook("OnDiscordCoreReady", _client, _bot, _guild);
                }
            });
        }
        #endregion

        #region Chat Commands
        private void DiscordCoreChatCommand(IPlayer player, string cmd, string[] args)
        {
            if (!player.HasPermission(UsePermission))
            {
                Chat(player, LangKeys.NoPermission);
                return;
            }

            if (!IsDiscordCoreOnline())
            {
                Chat(player, LangKeys.DiscordCoreOffline);
                return;
            }

            if (args.Length == 0)
            {
                DisplayHelp(player);
                return;
            }

            string option = args[0];
            if (player.IsAdmin && option.Equals("welcome"))
            {
                HandleDebugWelcome(player, args);
                return;
            }
            
            if (player.Id == "server_console")
            {
                Chat(player, LangKeys.ConsolePlayerNotSupported);
                return;
            }
            
            if (option.Equals(Lang(CommandKeys.ChatJoinCommand, player), StringComparison.OrdinalIgnoreCase))
            {
                HandleChatJoin(player, args);
                return;
            }

            if (option.Equals(Lang(CommandKeys.ChatLeaveCommand, player), StringComparison.OrdinalIgnoreCase))
            {
                GuildMember discord = player.GetGuildMember(_guild);
                if (discord != null)
                {
                    HandleLeave(player, discord.User, false, true);
                }
                else
                {
                    Chat(player, LangKeys.Commands.Leave.Errors.NotLinked);
                }

                return;
            }

            if (option.Equals("code", StringComparison.OrdinalIgnoreCase))
            {
                HandleChatCompleteLink(player, args);
                return;
            }

            DisplayHelp(player);
        }

        public void DisplayHelp(IPlayer player)
        {
            Chat(player, LangKeys.Commands.ChatHelpText, GetDiscordServerName(), _pluginConfig.JoinCode, Lang(CommandKeys.ChatCommand, player), Lang(CommandKeys.ChatJoinCommand, player), Lang(CommandKeys.ChatLeaveCommand, player));
        }

        public void HandleChatJoin(IPlayer player, string[] args)
        {
            if (_link.IsLinked(player.Id))
            {
                Chat(player, LangKeys.Commands.Join.Errors.AlreadySignedUp, "/", Lang(CommandKeys.ChatCommand, player), Lang(CommandKeys.ChatLeaveCommand, player));
                return;
            }
            
            // LinkActivation existing = _activations.FirstOrDefault(a => a.Player?.Id == player.Id);
            // if (existing != null)
            // {
            //     Chat(player,LangKeys.Commands.Join.Errors.LinkInProgress);
            //     return;
            // }

            if (args.Length == 1)
            {
                Chat(player, LangKeys.Commands.Join.Modes, Lang(CommandKeys.ChatCommand, player), Lang(CommandKeys.ChatJoinCommand, player), Lang(CommandKeys.ChatJoinCodeCommand, player));
                return;
            }
            
            if (args[1].Equals(Lang(CommandKeys.ChatJoinCodeCommand, player), StringComparison.OrdinalIgnoreCase))
            {
                HandleChatJoinWithCode(player);
            }
            else
            {
                HandleChatJoinWithUserName(player, args[1]);
            }
        }

        public void HandleChatJoinWithCode(IPlayer player)
        {
            string code = GenerateCode();
            _activations.RemoveAll(a => a.Player?.Id == player.Id);
            _activations.Add(new LinkActivation
            {
                Player = player,
                Code = code
            });
            
            StringBuilder message = new StringBuilder();

            message.Append(Lang(LangKeys.Commands.Join.Complete.Info, player,_cmdPrefix, Lang(CommandKeys.DiscordCommand, player), "code", code ));
            message.Append(Lang(LangKeys.Commands.Join.Complete.InfoServer, player, _guild.Name, _pluginConfig.JoinCode));
            
            if (_pluginConfig.LinkSettings.AllowCommandsInGuild)
            {
                if (_allowedCommandChannels.Count == 0)
                {
                    message.Append(Lang(LangKeys.Commands.Join.Complete.InfoGuildAny, player));
                }
                else
                {
                    message.Append(Lang(LangKeys.Commands.Join.Complete.InfoGuildChannel, player, _allowedChannelNames));
                }

                message.Append(Lang(LangKeys.Commands.Join.Complete.InfoAlsoDm, player, _bot.Username));
            }
            else
            {
                message.Append(Lang(LangKeys.Commands.Join.Complete.InfoDmOnly, player, _bot.Username));
            }
            
            Chat(player, message.ToString());
        }

        private void HandleChatJoinWithUserName(IPlayer player, string search)
        {
            if (_banList.ContainsKey(player.Id))
            {
                BanInfo ban = GetPlayerBanInfo(player.Id);
                if (ban.IsBanned())
                {
                    TimeSpan remaining = ban.GetRemainingBan();
                    Chat(player, LangKeys.Commands.Join.Errors.Banned, remaining.Hours, remaining.Minutes, remaining.Seconds);
                    return;
                }
            }

            Snowflake id;
            if (Snowflake.TryParse(search, out id))
            {
                GuildMember member = _guild.Members[id];
                if (member == null)
                {
                    Chat(player, LangKeys.Commands.Join.Errors.UnableToFindUser, search, GetDiscordServerName(), _pluginConfig.JoinCode);
                    return;
                }
                
                HandleChatJoinUser(player, member.User);
                return;
            }
            
            string[] userInfo = search.Split('#');
            string userName = userInfo[0];
            string discriminator = userInfo.Length > 1 ? userInfo[1] : null;

            _guild.SearchGuildMembers(_client, userInfo[0], 1000, members =>
            {
                HandleChatJoinUserResults(player, members, userName, discriminator);
            }, error =>
            {
                player.Message(Lang(LangKeys.Commands.Join.Errors.UsernameSearchError, player));
            });
        }

        private void HandleChatJoinUserResults(IPlayer player, List<GuildMember> members, string userName, string discriminator)
        {
            string fullSearch = userName;
            if (!string.IsNullOrEmpty(discriminator))
            {
                fullSearch += $"#{discriminator}";
            }
            
            if (members.Count == 0)
            {
                Chat(player, LangKeys.Commands.Join.Errors.UnableToFindUser, fullSearch, GetDiscordServerName(), _pluginConfig.JoinCode);
                return;
            }
            
            DiscordUser user = null;

            int count = 0;
            foreach (GuildMember member in members)
            {
                DiscordUser searchUser = member.User;
                if (discriminator == null)
                {
                    if (searchUser.Username.StartsWith(userName, StringComparison.OrdinalIgnoreCase))
                    {
                        user = searchUser;
                        count++;
                        if (count > 1)
                        {
                            break;
                        }
                    }
                }
                else if (searchUser.Username.Equals(userName, StringComparison.OrdinalIgnoreCase) && searchUser.Discriminator.Equals(discriminator))
                {
                    user = searchUser;
                    break;
                }
            }

            if (user == null || count > 1)
            {
                Chat(player, LangKeys.Commands.Join.Errors.FoundMultipleUsers, userName, GetDiscordServerName());
                return;
            }
            
            HandleChatJoinUser(player, user);
        }

        private void HandleChatJoinUser(IPlayer player, DiscordUser user)
        {
            MessageComponentBuilder builder = new MessageComponentBuilder();
            builder.AddActionButton(ButtonStyle.Success, Lang(LangKeys.Commands.Join.Messages.Discord.Accept, player), AcceptLinkButtonId, false, DiscordEmoji.FromCharacter(Lang(LangKeys.Emoji.Accept, player)));
            builder.AddActionButton(ButtonStyle.Danger, Lang(LangKeys.Commands.Join.Messages.Discord.Decline, player), DeclineLinkButtonId, false, DiscordEmoji.FromCharacter(Lang(LangKeys.Emoji.Decline, player)));
            
            MessageCreate create = new MessageCreate
            {
                Content = GetDiscordFormattedMessage(LangKeys.Commands.Join.Messages.Discord.Username, player, player.Name, Lang(LangKeys.Commands.Join.Messages.Discord.Accept, player), Lang(LangKeys.Commands.Join.Messages.Discord.Decline, player)),
                Components = builder.Build()
            };

            user.SendDirectMessage(_client, create, message =>
            {
                _activations.RemoveAll(a => a?.Discord.Id == user.Id);
                _activations.Add(new LinkActivation
                {
                    Player = player,
                    Discord = user,
                    Channel = message.ChannelId
                });
                
                Chat(player, LangKeys.Commands.Join.Messages.Chat.UsernameDmSent, _bot.Username);
            }, error =>
            {
                Chat(player, LangKeys.GenericError);
            });
        }

        public void HandleChatCompleteLink(IPlayer player, string[] args)
        {
            if (_link.IsLinked(player.Id))
            {
                Chat(player, Lang(LangKeys.Commands.Join.Errors.AlreadySignedUp, player,  "/", Lang(CommandKeys.ChatCommand, player), Lang(CommandKeys.ChatLeaveCommand, player)));
                return;
            }

            if (args.Length < 2)
            {
                Chat(player, Lang(LangKeys.Commands.Join.Errors.InvalidSyntax, player, "/", Lang(CommandKeys.ChatCommand, player)));
                return;
            }

            LinkActivation act = _activations.FirstOrDefault(a => a.Code == args[1]);
            if (act == null)
            {
                Chat(player, Lang(LangKeys.Commands.Join.Errors.NoPendingActivations, player, args[1]));
                return;
            }

            if (act.Discord == null)
            {
                Chat(player, Lang(LangKeys.Commands.Join.Errors.MustBeUsedDiscord));
                return;
            }

            act.Player = player;

            CompletedLink(act);
        }
        
        private void HandleDebugWelcome(IPlayer player, string[] args)
        {
            if (args.Length < 2)
            {
                Chat(player, "Invalid Syntax. Ex: /dc welcome {{discordId}}");
                return;
            }

            Snowflake userId;
            if (!Snowflake.TryParse(args[1], out userId))
            {
                Chat(player, "Discord ID is not a valid snowflake");
                return;
            }
            
            SendWelcomeMessage(userId);
            Chat(player, $"Welcome message send to {args[1]}");
        }
        #endregion
        
        #region Discord Commands
        private void DiscordCoreMessageCommand(DiscordMessage message, string cmd, string[] args)
        {
            IPlayer player = message.Author.Player;
            if (args.Length == 0)
            {
                DisplayDiscordHelp(message, player);
                return;
            }
            
            string option = args[0];
            if (option.Equals(Lang(CommandKeys.DiscordJoinCommand,player), StringComparison.OrdinalIgnoreCase))
            {
                HandleDiscordJoin(message, player);
                return;
            }

            if (option.Equals(Lang(CommandKeys.DiscordLeaveCommand, player), StringComparison.OrdinalIgnoreCase))
            {
                if (player != null)
                {
                    HandleLeave(player, message.Author, false, true);
                }
                else
                {
                    message.Reply(_client, GetDiscordFormattedMessage(LangKeys.Commands.Leave.Errors.NotLinked));
                }

                return;
            }

            if (option.Equals("code", StringComparison.OrdinalIgnoreCase))
            {
                HandleDiscordCompleteLink(message, args);
                return;
            }

            DisplayDiscordHelp(message, player);
        }

        public void DisplayDiscordHelp(DiscordMessage message, IPlayer player)
        {
            message.Reply(_client, GetDiscordFormattedMessage(LangKeys.Commands.DiscordHelpText, player, _cmdPrefix, Lang(CommandKeys.DiscordCommand, player), Lang(CommandKeys.DiscordJoinCommand, player), Lang(CommandKeys.DiscordLeaveCommand, player)));
        }
        
        public void HandleDiscordJoin(DiscordMessage message, IPlayer player)
        {
            if (player != null)
            {
                message.Reply(_client, GetDiscordFormattedMessage(LangKeys.Commands.Join.Errors.AlreadySignedUp, player, _cmdPrefix, Lang(CommandKeys.DiscordCommand, player), Lang(CommandKeys.DiscordLeaveCommand, player)));
                return;
            }

            // LinkActivation existing = _activations.FirstOrDefault(a => a.Discord?.Id == message.Author.Id);
            // if (existing != null)
            // {
            //     message.Reply(_client, GetDiscordFormattedMessage(LangKeys.Commands.Join.Errors.LinkInProgress));
            //     return;
            // }

            string code = GenerateCode();
            _activations.RemoveAll(a => a.Discord?.Id == message.Author.Id);
            _activations.Add(new LinkActivation
            {
                Discord = message.Author,
                Code = code
            });

            string linkMessage = GetDiscordFormattedMessage(LangKeys.Commands.Join.Messages.Discord.CompletedInGame, null, "/", Lang(CommandKeys.ChatCommand), "code", code);
            if (message.GuildId.HasValue)
            {
                message.Author.SendDirectMessage(_client, linkMessage);
                message.Reply(_client, GetDiscordFormattedMessage(LangKeys.Commands.Join.Messages.Discord.CompleteInGameResponse));
            }
            else
            {
                message.Reply(_client, linkMessage);
            }
        }
        
        public void HandleDiscordCompleteLink(DiscordMessage message, string[] args)
        {
            if (args.Length < 2)
            {
                message.Reply(_client, GetDiscordFormattedMessage(LangKeys.Commands.Join.Errors.InvalidSyntax, null, _cmdPrefix, Lang(CommandKeys.DiscordCommand), "code"));
                return;
            }

            LinkActivation act = _activations.FirstOrDefault(a => a.Code.Equals(args[1], StringComparison.OrdinalIgnoreCase));
            if (act == null)
            {
                message.Reply(_client, GetDiscordFormattedMessage(LangKeys.Commands.Join.Errors.NoPendingActivations, null, args[1]));
                return;
            }

            if (act.Player == null)
            {
                message.Reply(_client, GetDiscordFormattedMessage(LangKeys.Commands.Join.Errors.MustBeUsedServer));
                return;
            }

            act.Discord = message.Author;
            
            CompletedLink(act);
        }
        #endregion
        
        #region Discord Hooks
        [HookMethod(DiscordExtHooks.OnDiscordGatewayReady)]
        private void OnDiscordGatewayReady(GatewayReadyEvent ready)
        {
            try
            {
                if (ready.Guilds.Count == 0)
                {
                    PrintError("Your bot was not found in any discord servers. Please invite it to a server and reload the plugin.");
                    return;
                }

                DiscordGuild guild = null;
                if (ready.Guilds.Count == 1 && !_pluginConfig.GuildId.IsValid())
                {
                    guild = ready.Guilds.Values.FirstOrDefault();
                }

                if (guild == null)
                {
                    guild = ready.Guilds[_pluginConfig.GuildId];
                    if (guild == null)
                    {
                        PrintError("Failed to find a matching guild for the Discord Server Id. " +
                                   "Please make sure your guild Id is correct and the bot is in the discord server.");
                        return;
                    }
                }
                
                DiscordApplication app = _client.Bot.Application;
                if (!app.HasApplicationFlag(ApplicationFlags.GatewayGuildMembersLimited) && !app.HasApplicationFlag(ApplicationFlags.GatewayGuildMembers))
                {
                    PrintError($"You need to enable \"Server Members Intent\" for {_client.Bot.BotUser.Username} @ https://discord.com/developers/applications\n" +
                               $"{Name} will not function correctly until that is fixed. Once updated please reload {Name}.");
                    return;
                }
                
                if (!app.HasApplicationFlag(ApplicationFlags.GatewayMessageContentLimited))
                {
                    PrintWarning($"You will need to enable \"Message Content Intent\" for {_client.Bot.BotUser.Username} @ https://discord.com/developers/applications\n by April 2022" +
                               $"{Name} will stop function correctly after that date until that is fixed.");
                }
                
                _bot = ready.User;
                _guild = guild;
                Puts($"Connected to bot: {_bot.Username}");
            }
            catch (Exception ex)
            {
                PrintError($"Failed to load DiscordCore: {ex}");
            }
        }

        [HookMethod(DiscordExtHooks.OnDiscordGuildMembersLoaded)]
        private void OnDiscordGuildMembersLoaded(DiscordGuild guild)
        {
            if (guild.Id != _guild.Id)
            {
                return;
            }
            
            try
            {
                _guild = guild;
                Puts($"Discord connected to server: {GetDiscordServerName()}");

                if (!_initialized)
                {
                    _initialized = true;
                }
                
                Puts($"Loaded {_guild.Members.Count} Discord Members");

                HandleLeaveRejoin();
                SetupGuildLinkMessage();

                List<string> allowedCommandChannelNames = new List<string>();
                foreach (Snowflake id in _pluginConfig.LinkSettings.AllowCommandInChannels)
                {
                    DiscordChannel channel = _guild.Channels[id];
                    if (channel != null)
                    {
                        _allowedCommandChannels.Add(channel.Id);
                        allowedCommandChannelNames.Add(channel.Name);
                    }
                }

                _allowedChannelNames = string.Join(", ", allowedCommandChannelNames.ToArray());
                
                RegisterDiscordLangCommand(nameof(DiscordCoreMessageCommand), CommandKeys.DiscordCommand, true, _pluginConfig.LinkSettings.AllowCommandsInGuild, _allowedCommandChannels);
                
                DiscordCoreReady(null);
                Puts($"{Title} Ready");
            }
            catch (Exception ex)
            {
                PrintError($"Failed to connect to guild: {ex}");
            }
        }

        [HookMethod(DiscordExtHooks.OnDiscordGuildMemberAdded)]
        private void OnDiscordGuildMemberAdded(GuildMember member)
        {
            bool rejoined = false;
            if (_pluginConfig.LinkSettings.AutoRelinkPlayer)
            {
                rejoined = HandleRejoin(member.User);
            }

            if (_pluginConfig.WelcomeMessageSettings.EnableJoinMessage && !rejoined)
            {
                SendWelcomeMessage(member.Id);
            }
        }

        private void SendWelcomeMessage(Snowflake discordId)
        {
            MessageCreate create = new MessageCreate
            {
                Content = Lang(LangKeys.Guild.WelcomeMessage, null, GetDiscordServerName())
            };

            if (_pluginConfig.WelcomeMessageSettings.EnableLinkButton)
            {
                create.Content += Lang(LangKeys.Guild.WelcomeLinkMessage);
                MessageComponentBuilder builder = new MessageComponentBuilder();
                builder.AddActionButton(ButtonStyle.Success, Lang(LangKeys.Commands.Join.Messages.Discord.LinkAccounts), MessageLinkAccountsButtonId, false, DiscordEmoji.FromCharacter(Lang(LangKeys.Emoji.Accept)));
                create.Components = builder.Build();
            }

            DiscordUser.CreateDirectMessageChannel(_client, discordId, channel => {channel.CreateMessage(_client, create);});
        }

        [HookMethod(DiscordExtHooks.OnDiscordGuildMemberRemoved)]
        private void OnDiscordGuildMemberRemoved(GuildMember member)
        {
            if (member?.User == null)
            {
                return;
            }

            IPlayer player = _link.GetPlayer(member.User.Id);
            if (player == null)
            {
                return;
            }

            HandleLeave(player, member.User, true, false);
        }
        #endregion

        #region Link Message Handling
        [HookMethod(DiscordExtHooks.OnDiscordInteractionCreated)]
        private void OnDiscordInteractionCreated(DiscordInteraction interaction)
        {
            if (interaction.Type != InteractionType.MessageComponent)
            {
                return;
            }
            
            if (!interaction.Data.ComponentType.HasValue || interaction.Data.ComponentType.Value != MessageComponentType.Button)
            {
                return;
            }
            
            DiscordUser user = interaction.User ?? interaction.Member?.User;
            switch (interaction.Data.CustomId)
            {
                case LinkAccountsButtonId:
                    HandleLinkAccountsButton(interaction, true);
                    break;
                
                case MessageLinkAccountsButtonId:
                    HandleLinkAccountsButton(interaction, false);
                    break;
                
                case AcceptLinkButtonId:
                    HandleAcceptLinkButton(interaction, user);
                    break;
                
                case DeclineLinkButtonId:
                    HandleDeclineLinkButton(interaction, user);
                    break;
            }
        }

        public void HandleLinkAccountsButton(DiscordInteraction interaction, bool ephemeral)
        {
            MessageFlags flags = ephemeral ? MessageFlags.Ephemeral : MessageFlags.None;
            
            DiscordUser member = interaction.Member?.User ?? interaction.User;
            IPlayer player = member.Player;
            if (player != null)
            {
                interaction.CreateInteractionResponse(_client, new InteractionResponse
                {
                    Type = InteractionResponseType.ChannelMessageWithSource,
                    Data = new InteractionCallbackData
                    {
                        Content = GetDiscordFormattedMessage(LangKeys.Commands.Join.Errors.AlreadySignedUp, player, _cmdPrefix, Lang(CommandKeys.DiscordCommand, player), Lang(CommandKeys.DiscordLeaveCommand, player)),
                        Flags = flags
                    }
                });
                return;
            }
            
            string code = GenerateCode();
            _activations.RemoveAll(a => a.Discord?.Id == member.Id);
            _activations.Add(new LinkActivation
            {
                Discord = member,
                Code = code
            });
                    
            string linkMessage = GetDiscordFormattedMessage(LangKeys.Commands.Join.Messages.Discord.CompletedInGame, null, "/", Lang(CommandKeys.ChatCommand), "code", code);
            interaction.CreateInteractionResponse(_client, new InteractionResponse
            {
                Type = InteractionResponseType.ChannelMessageWithSource,
                Data = new InteractionCallbackData
                {
                    Content = linkMessage,
                    Flags = flags
                }
            });
        }
        
        private void HandleAcceptLinkButton(DiscordInteraction interaction, DiscordUser user)
        {
            interaction.CreateInteractionResponse(_client, new InteractionResponse
            {
                Type = InteractionResponseType.DeferredUpdateMessage
            });

            LinkActivation act = _activations.FirstOrDefault(a => a.Discord?.Id == user.Id && a.Player != null);
            if (act == null)
            {
                return;
            }
            
            CompletedLink(act);
        }
        
        private void HandleDeclineLinkButton(DiscordInteraction interaction, DiscordUser user)
        {
            interaction.CreateInteractionResponse(_client, new InteractionResponse
            {
                Type = InteractionResponseType.DeferredUpdateMessage
            });

            LinkActivation act = _activations.FirstOrDefault(a => a.Discord?.Id == user.Id);
            if (act != null)
            {
                _activations.Remove(act);
                interaction.CreateFollowUpMessage(_client, new CommandFollowupCreate
                {
                    Content = GetDiscordFormattedMessage(LangKeys.Commands.Join.Messages.Discord.Declined)
                });
                Chat(act.Player, LangKeys.Commands.Join.Messages.Chat.Declined);
                LinkBanSettings banSettings = _pluginConfig.LinkSettings.LinkBanSettings;
                if (banSettings.EnableLinkBanning)
                {
                    BanInfo ban = GetPlayerBanInfo(act.Player.Id);
                    ban.AddDeclined(banSettings.BanDeclineAmount, banSettings.BanDuration);
                }
            }
        }
        
        public void SetupGuildLinkMessage()
        {
            DiscordLinkingSettings link = _pluginConfig.LinkSettings;
            LinkMessageSettings settings = link.LinkMessageSettings;
            if (!settings.Enabled)
            {
                return;
            }
            
            if (!settings.ChannelId.IsValid())
            {
                PrintWarning("Link message is enabled but link message channel ID is not valid");
                return;
            }

            DiscordChannel channel = _guild.Channels[settings.ChannelId];
            if (channel == null)
            {
                PrintWarning($"Link message failed to find channel with ID {settings.ChannelId}");
                return;
            }

            string content = Lang(LangKeys.Guild.LinkMessage, null, GetDiscordServerName(), "Link Accounts");
                
            if (_storedData.MessageData == null)
            {
                MessageCreate message = CreateGuildLinkMessage(content);
                channel.CreateMessage(_client, message, SaveGuildLinkMessageInfo);
            }
            else
            {
                channel.GetChannelMessage(_client, _storedData.MessageData.MessageId, message =>
                    {
                        message.Content = content;
                        message.Components.Clear();
                        message.Components = CreateGuildLinkActions();
                        message.EditMessage(_client);
                    }, 
                    error =>
                    {
                        if (error.HttpStatusCode == 404)
                        {
                            PrintWarning("The previous link message has been removed. Recreating the message.");
                            MessageCreate message = CreateGuildLinkMessage(content);
                            channel.CreateMessage(_client, message, SaveGuildLinkMessageInfo);
                        }
                    });
            }
        }

        public MessageCreate CreateGuildLinkMessage(string content)
        {
            MessageCreate message = new MessageCreate
            {
                Content = content,
                Components = CreateGuildLinkActions()
            };
            
            return message;
        }

        public List<ActionRowComponent> CreateGuildLinkActions()
        {
            MessageComponentBuilder builder = new MessageComponentBuilder();
            builder.AddActionButton(ButtonStyle.Success, Lang(LangKeys.Commands.Join.Messages.Discord.LinkAccounts), LinkAccountsButtonId, false, DiscordEmoji.FromCharacter(Lang(LangKeys.Emoji.Accept)));

            return builder.Build();
        }

        public void SaveGuildLinkMessageInfo(DiscordMessage message)
        {
            _storedData.MessageData = new LinkMessageData
            {
                ChannelId = message.ChannelId,
                MessageId = message.Id
            };
            
            SaveData();
        }
        #endregion

        #region Linking
        public void CompletedLink(LinkActivation activation)
        {
            IPlayer player = activation.Player;
            DiscordUser user = activation.Discord;
            
            _storedData.PlayerDiscordInfo[player.Id] = new DiscordInfo
            {
                PlayerId = player.Id,
                DiscordId = user.Id
            };
            
            _activations.Remove(activation);
            
            Chat(player, LangKeys.Linking.Chat.Linked, user.Username, user.Discriminator);
            activation.Discord.SendDirectMessage(_client, GetDiscordFormattedMessage(LangKeys.Linking.Discord.Linked, player, user.Username, user.Discriminator, player.Name));
            
            Snowflake channelId = _pluginConfig.LinkSettings.AnnouncementChannel;
            if (channelId.IsValid())
            {
                DiscordChannel channel = _guild.Channels[channelId];
                channel.CreateMessage(_client, Lang(LangKeys.Notifications.Link, null, player.Name, player.Id, user.Username, user.Id));
            }
            
            _link.OnLinked(this, activation.Player, activation.Discord);
            SaveData();
        }
        
        public void HandleLeave(IPlayer player, DiscordUser user, bool backup, bool message)
        {
            if (backup)
            {
                _storedData.LeftPlayerInfo[user.Id] = _storedData.PlayerDiscordInfo[player.Id];
            }
            
            _storedData.PlayerDiscordInfo.Remove(player.Id);

            if (!backup)
            {
                Chat(player, LangKeys.Linking.Chat.Unlinked, player.Name);
                if (message)
                {
                    user.SendDirectMessage(_client,  GetDiscordFormattedMessage(LangKeys.Linking.Discord.Unlinked, player, user.Username, user.Discriminator, player.Name));
                }
            }

            _link.OnUnlinked(this, player, user);

            Snowflake channelId = _pluginConfig.LinkSettings.AnnouncementChannel;
            if (channelId.IsValid())
            {
                DiscordChannel channel = _guild.Channels[channelId];
                if (message)
                {
                    channel.CreateMessage(_client, Lang(LangKeys.Notifications.Unlink, null, player.Name, player.Id, user.Username, user.Id));
                }
            }

            SaveData();
        }

        public bool HandleRejoin(DiscordUser user)
        {
            DiscordInfo existing = _storedData.LeftPlayerInfo[user.Id];
            if (existing == null)
            {
                return false;
            }

            _storedData.PlayerDiscordInfo[existing.PlayerId] = existing;
            _storedData.LeftPlayerInfo.Remove(user.Id);

            IPlayer player = players.FindPlayerById(existing.PlayerId);
            
            _link.OnLinked(this, player, user);

            Snowflake channelId = _pluginConfig.LinkSettings.AnnouncementChannel;
            if (channelId.IsValid())
            {
                DiscordChannel channel = _guild.Channels[channelId];
                channel.CreateMessage(_client, Lang(LangKeys.Notifications.Rejoin, null, player.Name, player.Id, user.Username, user.Id));
            }
            
            SaveData();
            return true;
        }

        public void HandleLeaveRejoin()
        {
            foreach (DiscordInfo info in _storedData.PlayerDiscordInfo.Values.ToList())
            {
                if (!_guild.Members.ContainsKey(info.DiscordId))
                {
                    IPlayer player = players.FindPlayerById(info.PlayerId);
                    if (player != null)
                    {
                        DiscordUser user = player.GetDiscordUser();
                        HandleLeave(player, user, _pluginConfig.LinkSettings.AutoRelinkPlayer, false);
                        Puts($"Player {player.Name}({player.Id}) Discord {user.Id} is no longer in the guild and has been unlinked.");
                    }
                }
            }
            
            if (_pluginConfig.LinkSettings.AutoRelinkPlayer)
            {
                foreach (DiscordInfo info in _storedData.LeftPlayerInfo.Values.ToList())
                {
                    GuildMember member = _guild.Members[info.DiscordId];
                    if (member != null)
                    {
                        HandleRejoin(member.User);
                    }
                }
            }
        }
        #endregion

        #region Discord Link
        public IDictionary<string, Snowflake> GetSteamToDiscordIds()
        {
            Hash<string, Snowflake> data = new Hash<string, Snowflake>();
            foreach (DiscordInfo info in _storedData.PlayerDiscordInfo.Values)
            {
                data[info.PlayerId] = info.DiscordId;
            }

            return data;
        }
        #endregion
        
        #region API
        [HookMethod(nameof(GetDiscordServerName))]
        public string GetDiscordServerName()
        {
            if (!string.IsNullOrEmpty(_pluginConfig.ServerNameOverride))
            {
                return _pluginConfig.ServerNameOverride;
            }

            return _guild?.Name ?? "Not Connected";
        }
        #endregion

        #region Discord Helpers
        public string GetDiscordFormattedMessage(string key, IPlayer player = null, params object[] args)
        {
            return Formatter.ToPlaintext(Lang(LangKeys.DiscordFormat, player, Lang(key, player, args)));
        }

        private bool IsDiscordCoreOnline() => _initialized && _guild != null;
        #endregion
        
        #region Helper Methods
        public string GenerateCode()
        {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < _pluginConfig.LinkSettings.LinkCodeLength; i++)
            {
                sb.Append(_linkChars[Random.Range(0, _pluginConfig.LinkSettings.LinkCodeLength)]);
            }

            return sb.ToString();
        }

        public BanInfo GetPlayerBanInfo(string id)
        {
            BanInfo info = _banList[id];
            if (info == null)
            {
                info = new BanInfo();
                _banList[id] = info;
            }

            return info;
        }

        public void SaveData()
        {
            if (_storedData != null)
            {
                Interface.Oxide.DataFileSystem.WriteObject(Name, _storedData);
            }
        } 

        public void Chat(IPlayer player, string key, params object[] args)
        {
            if (player.IsConnected)
            {
                player.Reply(Lang(LangKeys.ChatFormat, player, Lang(key, player, args)));
            }
        } 

        public string Lang(string key, IPlayer player = null, params object[] args)
        {
            try
            {
                return string.Format(lang.GetMessage(key, this, player?.Id), args);
            }
            catch(Exception ex)
            {
                PrintError($"Lang Key '{key}' threw exception\n:{ex}");
                throw;
            }
        }

        public void RegisterChatLangCommand(string command, string langKey)
        {
            foreach (string langType in lang.GetLanguages(this))
            {
                Dictionary<string, string> langKeys = lang.GetMessages(langType, this);
                string commandValue;
                if (langKeys.TryGetValue(langKey, out commandValue) && !string.IsNullOrEmpty(commandValue))
                {
                    AddCovalenceCommand(commandValue, command);
                }
            }
        }

        /// <summary>
        /// Registers commands with discord using lang keys
        /// </summary>
        /// <param name="command">Name of the method to use in callback</param>
        /// <param name="langKey">The name of the lang key dictionary</param>
        /// <param name="direct">Should we register this command for direct messages</param>
        /// <param name="guild">Should we register this command for guilds</param>
        /// <param name="allowedChannels">If registering guilds the allowed channels / categories this command can be used in</param>
        public void RegisterDiscordLangCommand(string command, string langKey, bool direct, bool guild, List<Snowflake> allowedChannels)
        {
            if (direct)
            {
                _dcCommands.AddDirectMessageLocalizedCommand(langKey, this, command);
            }

            if (guild)
            {
                _dcCommands.AddGuildLocalizedCommand(langKey, this, allowedChannels, command);
            }
        }
        #endregion

        #region Classes
        public class PluginConfig
        {
            [DefaultValue("")]
            [JsonProperty(PropertyName = "Discord Bot Token")]
            public string ApiKey { get; set; }
            
            [JsonProperty(PropertyName = "Discord Server ID (Optional if bot only in 1 guild)")]
            public Snowflake GuildId { get; set; }

            [DefaultValue("")]
            [JsonProperty(PropertyName = "Discord Server Name Override")]
            public string ServerNameOverride { get; set; }
            
            [DefaultValue("")]
            [JsonProperty(PropertyName = "Discord Server Join Code")]
            public string JoinCode { get; set; }

            [JsonProperty(PropertyName = "Welcome Message Settings")]
            public WelcomeMessageSettings WelcomeMessageSettings { get; set; }
            
            [JsonProperty(PropertyName = "Link Settings")]
            public DiscordLinkingSettings LinkSettings { get; set; }

            [JsonConverter(typeof(StringEnumConverter))]
            [DefaultValue(DiscordLogLevel.Info)]
            [JsonProperty(PropertyName = "Discord Extension Log Level (Verbose, Debug, Info, Warning, Error, Exception, Off)")]
            public DiscordLogLevel ExtensionDebugging { get; set; }
        }

        public class DiscordLinkingSettings
        {
            [JsonProperty(PropertyName = "Link Code Generator Characters")]
            public string LinkCodeCharacters { get; set; }

            [JsonProperty(PropertyName = "Link Code Length")]
            public int LinkCodeLength { get; set; }
            
            [JsonProperty(PropertyName = "Automatically Relink A Player If They Leave And Rejoin The Discord Server")]
            public bool AutoRelinkPlayer { get; set; }
            
            [JsonProperty(PropertyName = "Allow Commands To Be Used In Guild Channels")]
            public bool AllowCommandsInGuild { get; set; }
            
            [JsonProperty(PropertyName = "Allow Guild Commands Only In The Following Guild Channel Or Category (Channel ID Or Category ID)")]
            public List<Snowflake> AllowCommandInChannels { get; set; }

            [JsonProperty(PropertyName = "Link / Unlink Announcement Channel Id")]
            public Snowflake AnnouncementChannel { get; set; }

            [JsonProperty(PropertyName = "Guild Link Message Settings")]
            public LinkMessageSettings LinkMessageSettings { get; set; }
            
            [JsonProperty(PropertyName = "Link Ban Settings")]
            public LinkBanSettings LinkBanSettings { get; set; }

            public DiscordLinkingSettings(DiscordLinkingSettings settings)
            {
                LinkCodeCharacters = settings?.LinkCodeCharacters ?? "123456789";
                LinkCodeLength = settings?.LinkCodeLength ?? 6;
                AutoRelinkPlayer = settings?.AutoRelinkPlayer ?? true;
                AllowCommandsInGuild = settings?.AllowCommandsInGuild ?? false;
                AllowCommandInChannels = settings?.AllowCommandInChannels ?? new List<Snowflake>();
                AnnouncementChannel = settings?.AnnouncementChannel ?? default(Snowflake);
                LinkMessageSettings = new LinkMessageSettings(settings?.LinkMessageSettings);
                LinkBanSettings = new LinkBanSettings(settings?.LinkBanSettings);
            }
        }

        public class WelcomeMessageSettings
        {
            [JsonProperty(PropertyName = "Enable Discord Server Welcome DM Message")]
            public bool EnableJoinMessage { get; set; }
            
            [JsonProperty(PropertyName = "Add Link Accounts Button In Welcome Message")]
            public bool EnableLinkButton { get; set; }

            public WelcomeMessageSettings(WelcomeMessageSettings settings)
            {
                EnableJoinMessage = settings?.EnableJoinMessage ?? true;
                EnableLinkButton = settings?.EnableLinkButton ?? true;
            }
        }

        public class LinkMessageSettings
        {
            [JsonProperty(PropertyName = "Enable Guild Link Message")]
            public bool Enabled { get; set; }
            
            [JsonProperty(PropertyName = "Message Channel ID")]
            public Snowflake ChannelId { get; set; }

            public LinkMessageSettings(LinkMessageSettings settings)
            {
                Enabled = settings?.Enabled ?? false;
                ChannelId = settings?.ChannelId ?? default(Snowflake);
            }
        }

        public class LinkBanSettings
        {
            [JsonProperty(PropertyName = "Enable Link Ban")]
            public bool EnableLinkBanning { get; set; }
            
            [JsonProperty(PropertyName = "Ban Link After X Join Declines")]
            public int BanDeclineAmount { get; set; }
            
            [JsonProperty(PropertyName = "Ban Duration (Hours)")]
            public int BanDuration { get; set; }

            public LinkBanSettings(LinkBanSettings settings)
            {
                EnableLinkBanning = settings?.EnableLinkBanning ?? true;
                BanDeclineAmount = settings?.BanDeclineAmount ?? 3;
                BanDuration = settings?.BanDuration ?? 24;
            }
        }

        public class StoredData
        {
            public Hash<string, DiscordInfo> PlayerDiscordInfo = new Hash<string, DiscordInfo>();
            public Hash<Snowflake, DiscordInfo> LeftPlayerInfo = new Hash<Snowflake, DiscordInfo>();
            public LinkMessageData MessageData;
        }

        public class DiscordInfo
        {
            public Snowflake DiscordId { get; set; }
            public string PlayerId { get; set; }
        }

        public class LinkActivation
        {
            public IPlayer Player { get; set; }
            public DiscordUser Discord { get; set; }
            public string Code { get; set; }
            public Snowflake Channel { get; set; }
        }

        public class LinkMessageData
        {
            public Snowflake ChannelId { get; set; }
            public Snowflake MessageId { get; set; }
        }
        
        public class BanInfo
        {
            public int Times { get; set; }
            public DateTime BannedUntil { get; set; }

            public void AddDeclined(int timesBeforeBanned, float banDuration)
            {
                Times++;
                if (Times >= timesBeforeBanned)
                {
                    BannedUntil = DateTime.Now + TimeSpan.FromHours(banDuration);
                    Times = 0;
                }
            }

            public bool IsBanned()
            {
                return BannedUntil > DateTime.Now;
            }

            public TimeSpan GetRemainingBan()
            {
                return BannedUntil - DateTime.Now;
            }
        }

        public static class LangKeys
        {
            public const string NoPermission = nameof(NoPermission);
            public const string ChatFormat = nameof(ChatFormat);
            public const string DiscordFormat = nameof(DiscordFormat);
            public const string DiscordCoreOffline = nameof(DiscordCoreOffline);
            public const string GenericError = nameof(GenericError);
            public const string ConsolePlayerNotSupported = nameof(ConsolePlayerNotSupported);
            
            public static class Commands
            {
                private const string Base = nameof(Commands) + ".";
                
                public const string Unknown = Base + nameof(Unknown);
                
                public const string ChatHelpText = nameof(ChatHelpText);
                public const string DiscordHelpText = nameof(DiscordHelpText);

                public static class Leave
                {
                    private const string Base = Commands.Base + nameof(Leave);

                    public static class Errors
                    {
                        private const string Base = Leave.Base + nameof(Errors);

                        public const string NotLinked = Base + nameof(NotLinked);
                    }
                }

                public static class Join
                {
                    private const string Base = Commands.Base + nameof(Join) + ".";
                    
                    public const string Modes = Base + nameof(Modes) + "V1";

                    public static class Messages
                    {
                        private const string Base = Join.Base  + nameof(Messages) + ".";

                        public static class Discord
                        {
                            private const string Base = Messages.Base + nameof(Discord) + ".";
                            
                            public const string Username = Base + nameof(Username);
                            public const string CompletedInGame = Base + nameof(CompletedInGame);
                            public const string CompleteInGameResponse = Base + nameof(CompleteInGameResponse);
                            public const string Declined = Base + nameof(Declined);
                            public const string Accept = Base + nameof(Accept);
                            public const string Decline = Base + nameof(Decline);
                            public const string LinkAccounts = Base + nameof(LinkAccounts);
                        }
                        
                        public static class Chat
                        {
                            private const string Base = Messages.Base + nameof(Chat) + ".";
                            
                            public const string UsernameDmSent = Base + nameof(UsernameDmSent);
                            public const string Declined = Base + nameof(Declined);
                        }
                    }
                    
                    public static class Complete
                    {
                        private const string Base = Join.Base + nameof(Complete) + ".";
                        
                        public const string Info = Base + nameof(Info);
                        public const string InfoServer = Base + nameof(InfoServer);
                        public const string InfoGuildAny = Base + nameof(InfoGuildAny);
                        public const string InfoGuildChannel = Base + nameof(InfoGuildChannel);
                        public const string InfoAlsoDm = Base + nameof(InfoAlsoDm);
                        public const string InfoDmOnly = Base + nameof(InfoDmOnly);
                    }

                    public static class Errors
                    {
                        private const string Base = Join.Base + nameof(Errors) + ".";
                        
                        public const string AlreadySignedUp = Base + nameof(AlreadySignedUp);
                        public const string UnableToFindUser = Base + nameof(UnableToFindUser);
                        public const string FoundMultipleUsers = Base + nameof(FoundMultipleUsers);
                        public const string UsernameSearchError = Base + nameof(UsernameSearchError);
                        public const string InvalidSyntax = Base + nameof(InvalidSyntax);
                        public const string NoPendingActivations = Base + nameof(NoPendingActivations);
                        public const string MustBeUsedServer = Base + nameof(MustBeUsedServer);
                        public const string MustBeUsedDiscord = Base + nameof(MustBeUsedDiscord);
                        //public const string LinkInProgress = Base + nameof(LinkInProgress);
                        public const string Banned = Base + nameof(Banned) + "V1";
                    }
                }
            }

            public static class Linking
            {
                private const string Base = nameof(Linking) + ".";

                public static class Chat
                {
                    private const string Base = Linking.Base + nameof(Chat) + ".";
                    
                    public const string Linked = Base + nameof(Linked);
                    public const string Unlinked = Base + nameof(Unlinked);
                }
                
                public static class Discord
                {
                    private const string Base = Linking.Base + nameof(Discord) + ".";
                    
                    public const string Linked = Base + nameof(Linked);
                    public const string Unlinked = Base + nameof(Unlinked);
                }
            }

            public static class Guild
            {
                private const string Base = nameof(Guild) + ".";
                
                public const string WelcomeMessage = Base + nameof(WelcomeMessage) + ".V1";
                public const string WelcomeLinkMessage = Base + nameof(WelcomeLinkMessage);
                public const string LinkMessage = Base + nameof(LinkMessage);
            }

            public static class Notifications
            {
                private const string Base = nameof(Notifications) + ".";
                
                public const string Link = Base + nameof(Link);
                public const string Rejoin = Base + nameof(Rejoin);
                public const string Unlink = Base + nameof(Unlink);
            }
            
            public static class Emoji
            {
                private const string Base = nameof(Emoji) + ".";
                        
                public const string Accept = Base + nameof(Accept);
                public const string Decline = Base +  nameof(Decline);
            }
        }

        public static class CommandKeys
        {
            public const string ChatCommand = nameof(DiscordCoreChatCommand);
            public const string ChatJoinCommand = ChatCommand + ".Join";
            public const string ChatJoinCodeCommand = ChatJoinCommand + ".Code";
            public const string ChatLeaveCommand = ChatCommand + ".Leave";
            
            public const string DiscordCommand = nameof(DiscordCoreMessageCommand);
            public const string DiscordJoinCommand = DiscordCommand + ".Join";
            public const string DiscordLeaveCommand = DiscordCommand + ".Leave";
        }
        #endregion
    }
}


// --- End of file: DiscordCore.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/MonumentFinder.cs ---
// --- Original Local Path: BeeRust/MonumentFinder.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Monument Finder", "WhiteThunder", "3.1.1")]
    [Description("Find monuments with commands or API.")]
    internal class MonumentFinder : CovalencePlugin
    {
        #region Fields

        private static MonumentFinder _pluginInstance;
        private static Configuration _pluginConfig;

        private const string PermissionFind = "monumentfinder.find";

        private const float DrawDuration = 30;

        private Dictionary<MonumentInfo, NormalMonumentAdapter> _normalMonuments = new Dictionary<MonumentInfo, NormalMonumentAdapter>();
        private Dictionary<DungeonGridCell, TrainTunnelAdapter> _trainTunnels = new Dictionary<DungeonGridCell, TrainTunnelAdapter>();
        private Dictionary<DungeonBaseLink, UnderwaterLabLinkAdapter> _labModules = new Dictionary<DungeonBaseLink, UnderwaterLabLinkAdapter>();
        private Dictionary<MonoBehaviour, BaseMonumentAdapter> _allMonuments = new Dictionary<MonoBehaviour, BaseMonumentAdapter>();

        private Collider[] _colliderBuffer = new Collider[8];

        #endregion

        #region Hooks

        private void Init()
        {
            _pluginInstance = this;
            permission.RegisterPermission(PermissionFind, this);

            AddCovalenceCommand(_pluginConfig.Command, nameof(CommandFind));
        }

        private void Unload()
        {
            _pluginConfig = null;
            _pluginInstance = null;
        }

        private void OnServerInitialized()
        {
            foreach (var underwaterLab in TerrainMeta.Path.DungeonBaseEntrances)
            {
                foreach (var linkObj in underwaterLab.Links)
                {
                    var link = linkObj.GetComponent<DungeonBaseLink>();
                    if (link == null)
                        continue;

                    // End links represent the posts holding up the lab modules.
                    if (link.Type == DungeonBaseLinkType.End)
                        continue;

                    var labLink = new UnderwaterLabLinkAdapter(link);
                    _labModules[link] = labLink;
                    _allMonuments[link] = labLink;
                }
            }

            foreach (var dungeonCell in TerrainMeta.Path.DungeonGridCells)
            {
                if (TrainTunnelAdapter.IgnoredPrefabs.Contains(dungeonCell.name))
                    continue;

                try
                {
                    var trainTunnel = new TrainTunnelAdapter(dungeonCell);
                    _trainTunnels[dungeonCell] = trainTunnel;
                    _allMonuments[dungeonCell] = trainTunnel;
                }
                catch (NotImplementedException exception)
                {
                    LogWarning(exception.Message);
                }
            }

            foreach (var monument in TerrainMeta.Path.Monuments)
            {
                var normalMonument = new NormalMonumentAdapter(monument);
                _normalMonuments[monument] = normalMonument;
                _allMonuments[monument] = normalMonument;
            }
        }

        #endregion

        #region API

        private Dictionary<string, object> API_GetClosest(Vector3 position) =>
            GetClosestMonumentForAPI(_allMonuments.Values, position);

        private Dictionary<string, object> API_GetClosestMonument(Vector3 position) =>
            GetClosestMonumentForAPI(_normalMonuments.Values, position);

        private Dictionary<string, object> API_GetClosestTrainTunnel(Vector3 position) =>
            GetClosestMonumentForAPI(_trainTunnels.Values, position);

        private Dictionary<string, object> API_GetClosestUnderwaterLabModules(Vector3 position) =>
            GetClosestMonumentForAPI(_labModules.Values, position);

        private List<Dictionary<string, object>> API_FindMonuments(string filter) =>
            FilterMonumentsForAPI(_normalMonuments.Values, filter);

        private List<Dictionary<string, object>> API_FindTrainTunnels(string filter) =>
            FilterMonumentsForAPI(_trainTunnels.Values, filter);

        private List<Dictionary<string, object>> API_FindUnderwaterLabModules(string filter) =>
            FilterMonumentsForAPI(_labModules.Values, filter);

        private List<Dictionary<string, object>> API_Find(string filter) =>
            FilterMonumentsForAPI(_allMonuments.Values, filter);

        private List<Dictionary<string, object>> API_FindByShortName(string shortName) =>
            FilterMonumentsForAPI(_allMonuments.Values, shortName: shortName);

        private List<Dictionary<string, object>> API_FindByAlias(string alias) =>
            FilterMonumentsForAPI(_allMonuments.Values, alias: alias);

        // Kept for backwards compatibility with previous versions.
        private List<MonumentInfo> FindMonuments(string filter)
        {
            var monuments = new List<MonumentInfo>();

            foreach (var monument in TerrainMeta.Path.Monuments)
            {
                if (!monument.name.Contains("/monument/") || !string.IsNullOrEmpty(filter) &&
                    !monument.Type.ToString().Contains(filter, CompareOptions.IgnoreCase) &&
                    !monument.name.Contains(filter, CompareOptions.IgnoreCase))
                    continue;

                monuments.Add(monument);
            }

            return monuments;
        }

        #endregion

        #region Commands

        private void CommandFind(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(PermissionFind))
            {
                ReplyToPlayer(player, Lang.ErrorNoPermission);
                return;
            }

            if (args == null || args.Length == 0)
            {
                SubcommandHelp(player, command);
                return;
            }

            switch (args[0].ToLower())
            {
                case "find":
                case "f":
                case "list":
                case "l":
                {
                    SubcommandList(player, command, args.Skip(1).ToArray());
                    return;
                }

                case "show":
                case "s":
                case "view":
                case "v":
                {
                    SubcommandShow(player, command, args.Skip(1).ToArray());
                    break;
                }

                case "closest":
                case "nearest":
                {
                    SubcommandClosest(player, command, args.Skip(1).ToArray());
                    break;
                }

                default:
                {
                    SubcommandHelp(player, command);
                    break;
                }
            }
        }

        private void SubcommandHelp(IPlayer player, string command)
        {
            var builder = new StringBuilder();
            builder.AppendLine(GetMessage(player, Lang.HelpHeader));
            builder.AppendLine(GetMessage(player, Lang.HelpList, command));
            builder.AppendLine(GetMessage(player, Lang.HelpShow, command));
            builder.AppendLine(GetMessage(player, Lang.HelpClosest, command));
            builder.AppendLine(GetMessage(player, Lang.HelpClosestConfig, command));
            player.Reply(builder.ToString());
        }

        private void SubcommandList(IPlayer player, string cmd, string[] args)
        {
            var filterArg = args.Length >= 1 ? args[0] : string.Empty;
            var monuments = FilterMonuments(_allMonuments.Values, filterArg);

            if (monuments.Count == 0)
            {
                ReplyToPlayer(player, Lang.NoMonumentsFound);
                return;
            }

            PrintMonumentList(player, monuments);
        }

        private void SubcommandShow(IPlayer player, string command, string[] args)
        {
            var basePlayer = player.Object as BasePlayer;
            if (basePlayer == null)
                return;

            var filterArg = args.Length >= 1 ? args[0] : string.Empty;
            var monuments = FilterMonuments(_allMonuments.Values, filterArg);
            if (monuments.Count == 0)
            {
                ReplyToPlayer(player, Lang.NoMonumentsFound);
                return;
            }

            foreach (var monument in monuments)
                ShowMonumentName(basePlayer, monument);
        }

        private void SubcommandClosest(IPlayer player, string command, string[] args)
        {
            var basePlayer = player.Object as BasePlayer;
            if (basePlayer == null)
                return;

            var position = basePlayer.transform.position;
            var monument = GetClosestMonument(_allMonuments.Values, position);
            if (monument == null)
            {
                ReplyToPlayer(player, Lang.NoMonumentsFound);
                return;
            }

            var firstArg = args.FirstOrDefault() ?? string.Empty;
            if (firstArg.Equals("config", StringComparison.CurrentCultureIgnoreCase))
            {
                var aliasOrShortName = monument.Alias ?? monument.ShortName;
                if (_pluginConfig.AddMonument(aliasOrShortName, monument))
                {
                    Config.WriteObject(_pluginConfig, true);
                    ReplyToPlayer(player, Lang.ClosestConfigSuccess, aliasOrShortName);
                }
                else
                {
                    ReplyToPlayer(player, Lang.ClosestConfigAlreadyPresent, aliasOrShortName);
                }
            }
            else
            {
                if (monument.IsInBounds(position))
                {
                    var relativePosition = monument.InverseTransformPoint(position);
                    ReplyToPlayer(player, Lang.AtMonument, monument.PrefabName, relativePosition);
                }
                else
                {
                    var closestPoint = monument.ClosestPointOnBounds(position);
                    var distance = (position - closestPoint).magnitude;
                    ReplyToPlayer(player, Lang.ClosestMonument, monument.PrefabName, distance);
                }
            }

            if (basePlayer.IsAdmin)
            {
                ShowMonumentName(basePlayer, monument);

                var withBoundingBox = monument as SingleBoundingBox;
                if (withBoundingBox != null)
                {
                    var boundingBox = withBoundingBox.BoundingBox;
                    if (boundingBox.extents != Vector3.zero)
                    {
                        Ddraw.Box(basePlayer, boundingBox, Color.magenta, DrawDuration);
                    }

                    return;
                }

                var withMultipleBoundingBoxes = monument as MultipleBoundingBoxes;
                if (withMultipleBoundingBoxes != null)
                {
                    foreach (var boundingBox in withMultipleBoundingBoxes.BoundingBoxes)
                    {
                        Ddraw.Box(basePlayer, boundingBox, Color.magenta, DrawDuration, showInfo: false);
                    }
                }
            }
        }

        #endregion

        #region Helper Methods

        private static void LogError(string message) => Interface.Oxide.LogError($"[Monument Finder] {message}");

        private static void LogWarning(string message) => Interface.Oxide.LogWarning($"[Monument Finder] {message}");

        private static bool IsCustomMonument(MonumentInfo monumentInfo)
        {
            return monumentInfo.name.Contains("monument_marker.prefab");
        }

        private static Collider FindPreventBuildingVolume(Vector3 position)
        {
            var buffer = _pluginInstance._colliderBuffer;
            var count = Physics.OverlapSphereNonAlloc(position, 1, buffer, Rust.Layers.Mask.Prevent_Building, QueryTriggerInteraction.Ignore);

            if (count == 0)
                return null;

            for (var i = 0; i < count; i++)
            {
                var collider = buffer[i];
                if ((collider is BoxCollider || collider is SphereCollider)
                    // Only count prevent_building prefabs, not all prefabs that have prevent building colliders.
                    && collider.name.Contains("prevent_building", CompareOptions.IgnoreCase))
                    return collider;
            }

            return null;
        }

        private static T GetClosestMonument<T>(IEnumerable<T> monumentList, Vector3 position) where T : BaseMonumentAdapter
        {
            T closestMonument = null;
            var closestSqrDistance = float.MaxValue;

            foreach (var baseMonument in monumentList)
            {
                var currentSqrDistance = (position - baseMonument.ClosestPointOnBounds(position)).sqrMagnitude;
                if (currentSqrDistance < closestSqrDistance)
                {
                    closestSqrDistance = currentSqrDistance;
                    closestMonument = baseMonument;
                }
            }

            return closestMonument;
        }

        private static Dictionary<string, object> GetClosestMonumentForAPI(IEnumerable<BaseMonumentAdapter> monumentList, Vector3 position)
        {
            return GetClosestMonument(monumentList, position)?.APIResult;
        }

        private static List<T> FilterMonuments<T>(IEnumerable<T> monumentList, string filter = null, string shortName = null, string alias = null) where T : BaseMonumentAdapter
        {
            var results = new List<T>();

            foreach (var baseMonument in monumentList)
            {
                if (baseMonument.MatchesFilter(filter, shortName, alias))
                    results.Add(baseMonument);
            }

            return results;
        }

        private static List<Dictionary<string, object>> FilterMonumentsForAPI(IEnumerable<BaseMonumentAdapter> monumentList, string filter = null, string shortName = null, string alias = null)
        {
            var results = new List<Dictionary<string, object>>();

            foreach (var baseMonument in monumentList)
            {
                if (baseMonument.MatchesFilter(filter, shortName, alias))
                {
                    results.Add(baseMonument.APIResult);
                }
            }

            return results;
        }

        private void PrintMonumentList(IPlayer player, IEnumerable<BaseMonumentAdapter> monuments)
        {
            var builder = new StringBuilder();
            builder.AppendLine(GetMessage(player, Lang.ListHeader));

            foreach (var monument in monuments)
            {
                builder.AppendLine(monument.PrefabName);
            }

            player.Reply(builder.ToString());
        }

        private static void ShowMonumentName(BasePlayer player, BaseMonumentAdapter monument)
        {
            Ddraw.Text(player, monument.Position, $"<size=20>{monument.ShortName}</size>", Color.magenta, 30);
        }

        #endregion

        #region Monument Adapter

        private interface SingleBoundingBox
        {
            OBB BoundingBox { get; }
        }

        private interface MultipleBoundingBoxes
        {
            OBB[] BoundingBoxes { get; }
        }

        private abstract class BaseMonumentAdapter
        {
            protected static string GetShortName(string prefabName)
            {
                var slashIndex = prefabName.LastIndexOf("/");
                var baseName = (slashIndex == -1) ? prefabName : prefabName.Substring(slashIndex + 1);
                return baseName.Replace(".prefab", "");
            }

            public MonoBehaviour Object { get; }
            public string PrefabName { get; protected set; }
            public string ShortName { get; protected set; }

            // Subclasses should overwrite this is if multiple monuments need to share an alias.
            // For instance, each train station prefab should share the same alias since they only differ in rotation.
            public string Alias { get; protected set; }

            public Vector3 Position { get; protected set; }
            public Quaternion Rotation { get; protected set; }

            public BaseMonumentAdapter(MonoBehaviour behavior)
            {
                Object = behavior;
                PrefabName = behavior.name;
                ShortName = GetShortName(behavior.name);
                Position = behavior.transform.position;
                Rotation = behavior.transform.rotation;
            }

            public Vector3 TransformPoint(Vector3 localPosition)
            {
                return Position + Rotation * localPosition;
            }

            public Vector3 InverseTransformPoint(Vector3 worldPosition)
            {
                return Quaternion.Inverse(Rotation) * (worldPosition - Position);
            }

            public abstract bool IsInBounds(Vector3 position);
            public abstract Vector3 ClosestPointOnBounds(Vector3 position);

            public virtual bool MatchesFilter(string filter, string shortName, string alias)
            {
                if (alias != null)
                    return Alias?.Equals(alias, StringComparison.InvariantCultureIgnoreCase) ?? false;

                if (shortName != null)
                    return ShortName.Equals(shortName, StringComparison.InvariantCultureIgnoreCase);

                if (string.IsNullOrEmpty(filter))
                    return true;

                return PrefabName.Contains(filter, CompareOptions.IgnoreCase);
            }

            private Dictionary<string, object> _cachedAPIResult;
            public Dictionary<string, object> APIResult
            {
                get
                {
                    if (_cachedAPIResult == null)
                    {
                        _cachedAPIResult = new Dictionary<string, object>
                        {
                            ["Object"] = Object,
                            ["PrefabName"] = PrefabName,
                            ["ShortName"] = ShortName,
                            ["Alias"] = Alias,
                            ["Position"] = Position,
                            ["Rotation"] = Rotation,
                            ["TransformPoint"] = new Func<Vector3, Vector3>(TransformPoint),
                            ["InverseTransformPoint"] = new Func<Vector3, Vector3>(InverseTransformPoint),
                            ["ClosestPointOnBounds"] = new Func<Vector3, Vector3>(ClosestPointOnBounds),
                            ["IsInBounds"] = new Func<Vector3, bool>(IsInBounds),
                        };
                    }

                    return _cachedAPIResult;
                }
            }
        }

        private class NormalMonumentAdapter : BaseMonumentAdapter, SingleBoundingBox
        {
            public static Dictionary<string, Bounds> MonumentBounds = new Dictionary<string, Bounds>
            {
                // These bounds are more accurate than what is provided in vanilla.
                ["airfield_1"] = new Bounds(new Vector3(0, 15, -25), new Vector3(355, 70, 210)),
                ["bandit_town"] = new Bounds(new Vector3(0, 12, -5), new Vector3(150, 40, 140)),
                ["cave_large_sewers_hard"] = new Bounds(new Vector3(18, -5, -9), new Vector3(52, 80, 56)),
                ["cave_medium_medium"] = new Bounds(new Vector3(-5, 10, -3), new Vector3(100, 20, 50)),
                ["cave_small_easy"] = new Bounds(new Vector3(5, 10, 0), new Vector3(55, 24, 55)),
                ["cave_small_hard"] = new Bounds(new Vector3(0, 10, -5), new Vector3(40, 20, 35)),
                ["cave_small_medium"] = new Bounds(new Vector3(10, 10, 0), new Vector3(45, 26, 40)),
                ["compound"] = new Bounds(new Vector3(0, 12, 0), new Vector3(200, 50, 200)),
                ["entrance_bunker_a"] = new Bounds(new Vector3(-3.5f, 1, -0.5f), new Vector3(20, 30, 18)),
                ["entrance_bunker_b"] = new Bounds(new Vector3(-8, 1, 0), new Vector3(30, 30, 18)),
                ["entrance_bunker_c"] = new Bounds(new Vector3(-3.5f, 1, -5f), new Vector3(24, 30, 27)),
                ["entrance_bunker_d"] = new Bounds(new Vector3(-3.5f, 1, -0.5f), new Vector3(20, 30, 17)),
                ["excavator_1"] = new Bounds(new Vector3(0, 40, 0), new Vector3(240, 100, 230)),
                ["fishing_village_a"] = new Bounds(new Vector3(-3, 5, -11), new Vector3(76, 24, 80)),
                ["fishing_village_b"] = new Bounds(new Vector3(-3, 4, -4), new Vector3(42, 24, 76)),
                ["fishing_village_c"] = new Bounds(new Vector3(-0.5f, 4, -4.5f), new Vector3(31, 22, 75)),
                ["gas_station_1"] = new Bounds(new Vector3(0, 13, 15), new Vector3(70, 42, 60)),
                ["harbor_1"] = new Bounds(new Vector3(-8, 23, 15), new Vector3(246, 60, 200)),
                ["harbor_2"] = new Bounds(new Vector3(6, 23, 18), new Vector3(224, 60, 250)),
                ["junkyard_1"] = new Bounds(new Vector3(0, 20, 0), new Vector3(180, 50, 180)),
                ["launch_site_1"] = new Bounds(new Vector3(10, 25, -26), new Vector3(544, 120, 276)),
                ["lighthouse"] = new Bounds(new Vector3(10f, 23, 5), new Vector3(74, 96, 68)),
                ["military_tunnel_1"] = new Bounds(new Vector3(0, 15, -25), new Vector3(265, 70, 250)),
                ["mining_quarry_a"] = new Bounds(new Vector3(2, 10, 2), new Vector3(52, 20, 72)),
                ["mining_quarry_b"] = new Bounds(new Vector3(-5, 10, -8), new Vector3(60, 20, 40)),
                ["mining_quarry_c"] = new Bounds(new Vector3(-6, 10, 8), new Vector3(42, 20, 60)),
                ["OilrigAI"] = new Bounds(new Vector3(18, 20, -2), new Vector3(68, 60, 76)),
                ["OilrigAI2"] = new Bounds(new Vector3(3, 43, 12), new Vector3(80, 96, 120)),
                ["power_sub_big_1"] = new Bounds(new Vector3(0, 5, 0.5f), new Vector3(20, 10, 22f)),
                ["power_sub_big_2"] = new Bounds(new Vector3(-1, 5, 1), new Vector3(23, 10, 22)),
                ["power_sub_small_1"] = new Bounds(new Vector3(0, 4, 0), new Vector3(14, 8, 14)),
                ["power_sub_small_2"] = new Bounds(new Vector3(0, 4, 0), new Vector3(14, 8, 14)),
                ["powerplant_1"] = new Bounds(new Vector3(-15, 25, -11), new Vector3(220, 64, 290)),
                ["radtown_small_3"] = new Bounds(new Vector3(-10, 15, -18), new Vector3(130, 50, 148)),
                ["satellite_dish"] = new Bounds(new Vector3(0, 25, 3), new Vector3(155, 55, 125)),
                ["sphere_tank"] = new Bounds(new Vector3(0, 41, 0), new Vector3(100, 84, 100)),
                ["stables_a"] = new Bounds(new Vector3(0, 10, 4), new Vector3(50, 20, 60)),
                ["stables_b"] = new Bounds(new Vector3(2, 15, 6), new Vector3(78, 30, 66)),
                ["supermarket_1"] = new Bounds(new Vector3(1, 4.5f, 1), new Vector3(40, 10, 44)),
                ["swamp_a"] = new Bounds(new Vector3(-10, 11, 0), new Vector3(140, 30, 140)),
                ["swamp_b"] = new Bounds(new Vector3(0, 14, 0), new Vector3(100, 36, 100)),
                ["swamp_c"] = new Bounds(new Vector3(0, 7, 0), new Vector3(100, 30, 100)),
                ["trainyard_1"] = new Bounds(new Vector3(10, 22, -30), new Vector3(235, 70, 220)),
                ["underwater_lab_a"] = new Bounds(),
                ["underwater_lab_b"] = new Bounds(),
                ["underwater_lab_c"] = new Bounds(),
                ["underwater_lab_d"] = new Bounds(),
                ["warehouse"] = new Bounds(new Vector3(0, 5, -8), new Vector3(44, 10, 24)),
                ["water_treatment_plant_1"] = new Bounds(new Vector3(20, 30, -45), new Vector3(250, 84, 290)),
                ["water_well_a"] = new Bounds(new Vector3(0, 10, 0), new Vector3(24, 20, 24)),
                ["water_well_b"] = new Bounds(new Vector3(0, 10, 0), new Vector3(24, 20, 24)),
                ["water_well_c"] = new Bounds(new Vector3(0, 10, 0), new Vector3(24, 20, 24)),
                ["water_well_d"] = new Bounds(new Vector3(0, 10, 0), new Vector3(30, 20, 30)),
                ["water_well_e"] = new Bounds(new Vector3(0, 10, 0), new Vector3(24, 20, 24)),
            };

            public MonumentInfo MonumentInfo { get; }
            public OBB BoundingBox { get; }

            public NormalMonumentAdapter(MonumentInfo monumentInfo) : base(monumentInfo)
            {
                MonumentInfo = monumentInfo;
                var bounds = monumentInfo.Bounds;

                if (IsCustomMonument(monumentInfo))
                {
                    PrefabName = monumentInfo.transform.root.name;
                    ShortName = PrefabName;

                    var monumentSettings = _pluginConfig.GetMonumentSettings(ShortName)
                        ?? _pluginConfig.DefaultCustomMonumentSettings;

                    var volumeCollider = monumentSettings.Position.UsePreventBuildingVolume
                        || monumentSettings.Rotation.UsePreventBuildingVolume
                        || monumentSettings.Bounds.UsePreventBuildingVolume
                            ? FindPreventBuildingVolume(Position)
                            : null;

                    if (!monumentSettings.Position.UseMonumentMarker
                        && monumentSettings.Position.UsePreventBuildingVolume)
                    {
                        if (volumeCollider != null)
                        {
                            Position = volumeCollider.transform.position;
                        }
                        else
                        {
                            LogWarning($"Unable to find a PreventBuilding volume for monument {ShortName}. Determining position from monument marker instead.");
                        }
                    }

                    if (!monumentSettings.Rotation.UseMonumentMarker
                        && monumentSettings.Rotation.UsePreventBuildingVolume)
                    {
                        if (volumeCollider != null)
                        {
                            Rotation = volumeCollider.transform.rotation;
                        }
                        else
                        {
                            LogWarning($"Unable to find a PreventBuilding volume for monument {ShortName}. Determining rotation from monument marker instead.");
                        }
                    }

                    if (monumentSettings.Bounds.UseCustomBounds)
                    {
                        bounds = monumentSettings.Bounds.CustomBounds.ToBounds();
                    }
                    else if (monumentSettings.Bounds.UseMonumentMarker)
                    {
                        bounds = new Bounds(Position - monumentInfo.transform.position, monumentInfo.transform.localScale);
                    }
                    else if (monumentSettings.Bounds.UsePreventBuildingVolume)
                    {
                        if (volumeCollider != null)
                        {
                            bounds = volumeCollider.bounds;
                            bounds.center = Quaternion.Inverse(Rotation) * (bounds.center - Position);
                        }
                        else
                        {
                            LogError($"Unable to find a PreventBuilding volume for monument {ShortName}. Unable to determine bounds.");
                        }
                    }
                }
                else
                {
                    var monumentSettings = _pluginConfig.GetMonumentSettings(ShortName);
                    if (monumentSettings != null && monumentSettings.Bounds.UseCustomBounds)
                    {
                        bounds = monumentSettings.Bounds.CustomBounds.ToBounds();
                    }
                    else
                    {
                        Bounds hardCodedBounds;
                        if (MonumentBounds.TryGetValue(ShortName, out hardCodedBounds))
                        {
                            bounds = hardCodedBounds;
                        }
                    }
                }

                BoundingBox = new OBB(Position, Rotation, bounds);
            }

            public override bool IsInBounds(Vector3 position) =>
                BoundingBox.Contains(position);

            public override Vector3 ClosestPointOnBounds(Vector3 position) =>
                BoundingBox.ClosestPoint(position);

            public override bool MatchesFilter(string filter, string shortName, string alias)
            {
                return base.MatchesFilter(filter, shortName, alias)
                    || !string.IsNullOrEmpty(filter) && MonumentInfo.Type.ToString().Contains(filter, CompareOptions.IgnoreCase);
            }
        }

        private class TrainTunnelAdapter : BaseMonumentAdapter, SingleBoundingBox
        {
            public static readonly string[] IgnoredPrefabs =
            {
                // These prefabs are simply used for decorating.
                "assets/bundled/prefabs/autospawn/tunnel-transition/transition-sn-0.prefab",
                "assets/bundled/prefabs/autospawn/tunnel-transition/transition-sn-1.prefab",
                "assets/bundled/prefabs/autospawn/tunnel-transition/transition-we-0.prefab",
                "assets/bundled/prefabs/autospawn/tunnel-transition/transition-we-1.prefab",
            };

            private abstract class BaseTunnelInfo
            {
                public Quaternion Rotation;
                public virtual Bounds Bounds { get; }
                public virtual string Alias { get; }
            }

            // Train stations.
            private class TrainStation : BaseTunnelInfo
            {
                public override Bounds Bounds => new Bounds(new Vector3(0, 8.75f, 0), new Vector3(108, 18, 216));
                public override string Alias => "TrainStation";
            }

            // Straight tunnels that contain barricades, loot and tunnel dwellers.
            private class BarricadeTunnel : BaseTunnelInfo
            {
                public override Bounds Bounds => new Bounds(new Vector3(0, 4.25f, 0), new Vector3(45f, 9, 216));
                public override string Alias => "BarricadeTunnel";
            }

            // Straight tunnels contain loot and tunnel dwellers.
            private class LootTunnel : BaseTunnelInfo
            {
                public override Bounds Bounds => new Bounds(new Vector3(0, 4.25f, 0), new Vector3(16.5f, 9, 216));
                public override string Alias => "LootTunnel";
            }

            // Straight tunnels with a divider in the tracks.
            private class SplitTunnel : BaseTunnelInfo
            {
                public override Bounds Bounds => new Bounds(new Vector3(0, 4.25f, 0), new Vector3(16.5f, 9, 216));
                public override string Alias => "SplitTunnel";
            }

            // 3-way intersections.
            private class Intersection : BaseTunnelInfo
            {
                public override Bounds Bounds => new Bounds(new Vector3(0, 4.25f, 49.875f), new Vector3(216, 9, 116.25f));
                public override string Alias => "Intersection";
            }

            // 4-way intersections.
            private class LargeIntersection : BaseTunnelInfo
            {
                public override Bounds Bounds => new Bounds(new Vector3(0, 4.25f, 0), new Vector3(216, 9, 216));
                public override string Alias => "LargeIntersection";
            }

            // Corner tunnels (45-degree angle).
            private class CornerTunnel : BaseTunnelInfo
            {
                public override Bounds Bounds => new Bounds(new Vector3(-49.875f, 4.25f, 49.875f), new Vector3(116.25f, 9, 116.25f));
                public override string Alias => "CornerTunnel";
            }

            private static readonly Dictionary<string, BaseTunnelInfo> PrefabToTunnelInfo = new Dictionary<string, BaseTunnelInfo>
            {
                ["station-sn-0"] = new TrainStation { Rotation = Quaternion.Euler(0, 180, 0) },
                ["station-sn-1"] = new TrainStation { Rotation = Quaternion.Euler(0, 0, 0) },
                ["station-sn-2"] = new TrainStation { Rotation = Quaternion.Euler(0, 180, 0) },
                ["station-sn-3"] = new TrainStation { Rotation = Quaternion.Euler(0, 0, 0) },
                ["station-we-0"] = new TrainStation { Rotation = Quaternion.Euler(0, 90, 0) },
                ["station-we-1"] = new TrainStation { Rotation = Quaternion.Euler(0, 270, 0) },
                ["station-we-2"] = new TrainStation { Rotation = Quaternion.Euler(0, 90, 0) },
                ["station-we-3"] = new TrainStation { Rotation = Quaternion.Euler(0, 270, 0) },

                ["straight-sn-4"] = new BarricadeTunnel { Rotation = Quaternion.Euler(0, 180, 0) },
                ["straight-sn-5"] = new BarricadeTunnel { Rotation = Quaternion.Euler(0, 0, 0) },
                ["straight-we-4"] = new BarricadeTunnel { Rotation = Quaternion.Euler(0, 90, 0) },
                ["straight-we-5"] = new BarricadeTunnel { Rotation = Quaternion.Euler(0, 270, 0) },

                ["straight-sn-0"] = new LootTunnel { Rotation = Quaternion.Euler(0, 180, 0) },
                ["straight-sn-1"] = new LootTunnel { Rotation = Quaternion.Euler(0, 0, 0) },
                ["straight-we-0"] = new LootTunnel { Rotation = Quaternion.Euler(0, 90, 0) },
                ["straight-we-1"] = new LootTunnel { Rotation = Quaternion.Euler(0, 270, 0) },

                ["straight-we-2"] = new SplitTunnel { Rotation = Quaternion.Euler(0, 90, 0) },
                ["straight-we-3"] = new SplitTunnel { Rotation = Quaternion.Euler(0, 270, 0) },
                ["straight-sn-2"] = new SplitTunnel { Rotation = Quaternion.Euler(0, 180, 0) },
                ["straight-sn-3"] = new SplitTunnel { Rotation = Quaternion.Euler(0, 0, 0) },

                ["intersection-n"] = new Intersection { Rotation = Quaternion.Euler(0, 0, 0) },
                ["intersection-e"] = new Intersection { Rotation = Quaternion.Euler(0, 90, 0) },
                ["intersection-s"] = new Intersection { Rotation = Quaternion.Euler(0, 180, 0) },
                ["intersection-w"] = new Intersection { Rotation = Quaternion.Euler(0, 270, 0) },

                ["intersection"] = new LargeIntersection { Rotation = Quaternion.Euler(0, 0, 0) },

                ["curve-ne-0"] = new CornerTunnel { Rotation = Quaternion.Euler(0, 90, 0) },
                ["curve-ne-1"] = new CornerTunnel { Rotation = Quaternion.Euler(0, 90, 0) },
                ["curve-nw-0"] = new CornerTunnel { Rotation = Quaternion.Euler(0, 0, 0) },
                ["curve-nw-1"] = new CornerTunnel { Rotation = Quaternion.Euler(0, 0, 0) },
                ["curve-se-0"] = new CornerTunnel { Rotation = Quaternion.Euler(0, 180, 0) },
                ["curve-se-1"] = new CornerTunnel { Rotation = Quaternion.Euler(0, 180, 0) },
                ["curve-sw-0"] = new CornerTunnel { Rotation = Quaternion.Euler(0, 270, 0) },
                ["curve-sw-1"] = new CornerTunnel { Rotation = Quaternion.Euler(0, 270, 0) },
            };

            private static BaseTunnelInfo GetTunnelInfo(string shortName)
            {
                BaseTunnelInfo tunnelInfo;
                if (PrefabToTunnelInfo.TryGetValue(shortName, out tunnelInfo))
                    return tunnelInfo;

                throw new NotImplementedException($"Tunnel type not implemented: {shortName}");
            }

            public OBB BoundingBox { get; }

            private BaseTunnelInfo _tunnelInfo;

            public TrainTunnelAdapter(DungeonGridCell dungeonCell) : base(dungeonCell)
            {
                _tunnelInfo = GetTunnelInfo(ShortName);

                Rotation = _tunnelInfo.Rotation;
                Alias = _tunnelInfo.Alias;

                var bounds = _tunnelInfo.Bounds;

                var monumentSettings = _pluginConfig.GetMonumentSettings(_tunnelInfo.Alias);
                if (monumentSettings != null && monumentSettings.Bounds.UseCustomBounds)
                {
                    bounds = monumentSettings.Bounds.CustomBounds.ToBounds();
                }

                BoundingBox = new OBB(Position, Rotation, bounds);
            }

            public override bool IsInBounds(Vector3 position) =>
                BoundingBox.Contains(position);

            public override Vector3 ClosestPointOnBounds(Vector3 position) =>
                BoundingBox.ClosestPoint(position);
        }

        private class UnderwaterLabLinkAdapter : BaseMonumentAdapter, MultipleBoundingBoxes
        {
            public OBB[] BoundingBoxes { get; }

            public UnderwaterLabLinkAdapter(DungeonBaseLink dungeonLink) : base(dungeonLink)
            {
                var volumeList = dungeonLink.GetComponentsInChildren<DungeonVolume>();
                BoundingBoxes = new OBB[volumeList.Length];

                for (var i = 0; i < volumeList.Length; i++)
                {
                    var volume = volumeList[i];
                    BoundingBoxes[i] = new OBB(volume.transform.position, volume.transform.rotation, volume.bounds);
                }
            }

            public override bool IsInBounds(Vector3 position)
            {
                foreach (var box in BoundingBoxes)
                {
                    if (box.Contains(position))
                        return true;
                }

                return false;
            }

            public override Vector3 ClosestPointOnBounds(Vector3 position)
            {
                var overallClosestPoint = Vector3.positiveInfinity;
                var closestSqrDistance = float.MaxValue;

                foreach (var box in BoundingBoxes)
                {
                    var closestPoint = box.ClosestPoint(position);
                    var currentSqrDistance = (position - closestPoint).sqrMagnitude;

                    if (currentSqrDistance < closestSqrDistance)
                    {
                        overallClosestPoint = closestPoint;
                        closestSqrDistance = currentSqrDistance;
                    }
                }

                return overallClosestPoint;
            }
        }

        #endregion

        #region Ddraw

        private static class Ddraw
        {
            public static void Sphere(BasePlayer player, Vector3 origin, float radius, Color color, float duration) =>
                player.SendConsoleCommand("ddraw.sphere", duration, color, origin, radius);

            public static void Line(BasePlayer player, Vector3 origin, Vector3 target, Color color, float duration) =>
                player.SendConsoleCommand("ddraw.line", duration, color, origin, target);

            public static void Text(BasePlayer player, Vector3 origin, string text, Color color, float duration) =>
                player.SendConsoleCommand("ddraw.text", duration, color, origin, text);

            public static void Segments(BasePlayer player, Vector3 origin, Vector3 target, Color color, float duration)
            {
                var delta = target - origin;
                var distance = delta.magnitude;
                var direction = delta.normalized;

                var segmentLength = 10f;
                var numSegments = Mathf.CeilToInt(distance / segmentLength);

                for (var i = 0; i < numSegments; i++)
                {
                    var length = segmentLength;
                    if (i == numSegments - 1 && distance % segmentLength != 0)
                        length = distance % segmentLength;

                    var start = origin + i * segmentLength * direction;
                    var end = start + length * direction;
                    Line(player, start, end, color, duration);
                }
            }

            public static void Box(BasePlayer player, Vector3 center, Quaternion rotation, Vector3 halfExtents, Color color, float duration, bool showInfo = true)
            {
                var boxArea = halfExtents.x * halfExtents.z;

                var sphereRadius = boxArea > 200
                    ? 1f
                    : boxArea > 10
                    ? 0.5f
                    : 0.1f;

                var forwardUpperLeft = center + rotation * halfExtents.WithX(-halfExtents.x);
                var forwardUpperRight = center + rotation * halfExtents;
                var forwardLowerLeft = center + rotation * halfExtents.WithX(-halfExtents.x).WithY(-halfExtents.y);
                var forwardLowerRight = center + rotation * halfExtents.WithY(-halfExtents.y);

                var backLowerRight = center + rotation * -halfExtents.WithX(-halfExtents.x);
                var backLowerLeft = center + rotation * -halfExtents;
                var backUpperRight = center + rotation * -halfExtents.WithX(-halfExtents.x).WithY(-halfExtents.y);
                var backUpperLeft = center + rotation * -halfExtents.WithY(-halfExtents.y);

                var forwardLowerMiddle = Vector3.Lerp(forwardLowerLeft, forwardLowerRight, 0.5f);
                var forwardUpperMiddle = Vector3.Lerp(forwardUpperLeft, forwardUpperRight, 0.5f);

                var backLowerMiddle = Vector3.Lerp(backLowerLeft, backLowerRight, 0.5f);
                var backUpperMiddle = Vector3.Lerp(backUpperLeft, backUpperRight, 0.5f);

                var leftLowerMiddle = Vector3.Lerp(forwardLowerLeft, backLowerLeft, 0.5f);
                var leftUpperMiddle = Vector3.Lerp(forwardUpperLeft, backUpperLeft, 0.5f);

                var rightLowerMiddle = Vector3.Lerp(forwardLowerRight, backLowerRight, 0.5f);
                var rightUpperMiddle = Vector3.Lerp(forwardUpperRight, backUpperRight, 0.5f);

                Sphere(player, forwardUpperLeft, sphereRadius, color, duration);
                Sphere(player, forwardUpperRight, sphereRadius, color, duration);
                Sphere(player, forwardLowerLeft, sphereRadius, color, duration);
                Sphere(player, forwardLowerRight, sphereRadius, color, duration);

                Sphere(player, backLowerRight, sphereRadius, color, duration);
                Sphere(player, backLowerLeft, sphereRadius, color, duration);
                Sphere(player, backUpperRight, sphereRadius, color, duration);
                Sphere(player, backUpperLeft, sphereRadius, color, duration);

                Segments(player, forwardUpperLeft, forwardUpperRight, color, duration);
                Segments(player, forwardLowerLeft, forwardLowerRight, color, duration);
                Segments(player, forwardUpperLeft, forwardLowerLeft, color, duration);
                Segments(player, forwardUpperRight, forwardLowerRight, color, duration);

                Segments(player, backUpperLeft, backUpperRight, color, duration);
                Segments(player, backLowerLeft, backLowerRight, color, duration);
                Segments(player, backUpperLeft, backLowerLeft, color, duration);
                Segments(player, backUpperRight, backLowerRight, color, duration);

                Segments(player, forwardUpperLeft, backUpperLeft, color, duration);
                Segments(player, forwardLowerLeft, backLowerLeft, color, duration);
                Segments(player, forwardUpperRight, backUpperRight, color, duration);
                Segments(player, forwardLowerRight, backLowerRight, color, duration);

                if (showInfo)
                {
                    Sphere(player, forwardLowerMiddle, sphereRadius, Color.yellow, duration);
                    Sphere(player, forwardUpperMiddle, sphereRadius, Color.yellow, duration);
                    Sphere(player, backLowerMiddle, sphereRadius, Color.yellow, duration);
                    Sphere(player, backUpperMiddle, sphereRadius, Color.yellow, duration);

                    Sphere(player, leftLowerMiddle, sphereRadius, Color.green, duration);
                    Sphere(player, leftUpperMiddle, sphereRadius, Color.green, duration);
                    Sphere(player, rightLowerMiddle, sphereRadius, Color.green, duration);
                    Sphere(player, rightUpperMiddle, sphereRadius, Color.green, duration);

                    Text(player, forwardUpperMiddle, "<size=20>+Z</size>", Color.yellow, duration);
                    Text(player, forwardLowerMiddle, "<size=20>+Z</size>", Color.yellow, duration);
                    Text(player, backUpperMiddle, "<size=20>-Z</size>", Color.yellow, duration);
                    Text(player, backLowerMiddle, "<size=20>-Z</size>", Color.yellow, duration);

                    Text(player, leftLowerMiddle, "<size=20>-X</size>", Color.green, duration);
                    Text(player, leftUpperMiddle, "<size=20>-X</size>", Color.green, duration);
                    Text(player, rightLowerMiddle, "<size=20>+X</size>", Color.green, duration);
                    Text(player, rightUpperMiddle, "<size=20>+X</size>", Color.green, duration);

                    Text(player, forwardUpperLeft, "<size=28>*</size>", color, duration);
                    Text(player, forwardUpperRight, "<size=28>*</size>", color, duration);
                    Text(player, forwardLowerLeft, "<size=28>*</size>", color, duration);
                    Text(player, forwardLowerRight, "<size=28>*</size>", color, duration);

                    Text(player, backLowerRight, "<size=28>*</size>", color, duration);
                    Text(player, backLowerLeft, "<size=28>*</size>", color, duration);
                    Text(player, backUpperRight, "<size=28>*</size>", color, duration);
                    Text(player, backUpperLeft, "<size=28>*</size>", color, duration);
                }
            }

            public static void Box(BasePlayer player, OBB boundingBox, Color color, float duration, bool showInfo = true)
            {
                Box(player, boundingBox.position, boundingBox.rotation, boundingBox.extents, color, duration, showInfo);
            }
        }

        #endregion

        #region Configuration

        private class CustomBounds
        {
            [JsonProperty("Size")]
            public Vector3 Size;

            [JsonProperty("Center adjustment")]
            public Vector3 CenterOffset;

            [JsonProperty("Center")]
            private Vector3 DeprecatedCenter { set { CenterOffset = value ; } }

            public Bounds ToBounds() => new Bounds(CenterOffset, Size);

            public CustomBounds Copy()
            {
                return new CustomBounds
                {
                    Size = Size,
                    CenterOffset = CenterOffset,
                };
            }
        }

        private class BaseDetectionSettings
        {
            [JsonProperty("Auto determine from monument marker", Order = -3)]
            public bool UseMonumentMarker;

            [JsonProperty("Auto determine from prevent building volume", Order = -2)]
            public bool UsePreventBuildingVolume;

            public BaseDetectionSettings Copy()
            {
                return new BaseDetectionSettings
                {
                    UseMonumentMarker = UseMonumentMarker,
                    UsePreventBuildingVolume = UsePreventBuildingVolume,
                };
            }
        }

        private class BoundSettings : BaseDetectionSettings
        {
            [JsonProperty("Use custom bounds")]
            public bool UseCustomBounds;

            [JsonProperty("Custom bounds")]
            public CustomBounds CustomBounds = new CustomBounds();

            public new BoundSettings Copy()
            {
                return new BoundSettings
                {
                    UseMonumentMarker = UseMonumentMarker,
                    UsePreventBuildingVolume = UsePreventBuildingVolume,
                    UseCustomBounds = UseCustomBounds,
                    CustomBounds = CustomBounds.Copy(),
                };
            }
        }

        private class MonumentSettings
        {
            [JsonProperty("Position")]
            public BaseDetectionSettings Position = new BaseDetectionSettings();

            [JsonProperty("Rotation")]
            public BaseDetectionSettings Rotation = new BaseDetectionSettings();

            [JsonProperty("Bounds")]
            public BoundSettings Bounds = new BoundSettings();

            public MonumentSettings Copy()
            {
                return new MonumentSettings
                {
                    Position = Position.Copy(),
                    Rotation = Rotation.Copy(),
                    Bounds = Bounds.Copy(),
                };
            }
        }

        private class Configuration : SerializableConfiguration
        {
            [JsonProperty(PropertyName = "Command")]
            public string Command = "mf";

            [JsonProperty("Default custom monument settings")]
            public MonumentSettings DefaultCustomMonumentSettings = new MonumentSettings
            {
                Position = new BaseDetectionSettings
                {
                    UseMonumentMarker = true,
                    UsePreventBuildingVolume = false,
                },
                Rotation = new BaseDetectionSettings
                {
                    UseMonumentMarker = true,
                    UsePreventBuildingVolume = false,
                },
                Bounds = new BoundSettings
                {
                    UseMonumentMarker = false,
                    UseCustomBounds = true,
                    CustomBounds = new CustomBounds
                    {
                        CenterOffset = new Vector3(0, 10, 0),
                        Size = new Vector3(30, 30, 30),
                    },
                },
            };

            [JsonProperty("Monuments", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            private Dictionary<string, MonumentSettings> MonumentSettingsMap = new Dictionary<string, MonumentSettings>
            {
                ["example_monument"] = new MonumentSettings
                {
                    Position = new BaseDetectionSettings
                    {
                        UseMonumentMarker = true,
                        UsePreventBuildingVolume = false,
                    },
                    Rotation = new BaseDetectionSettings
                    {
                        UseMonumentMarker = true,
                        UsePreventBuildingVolume = false,
                    },
                    Bounds = new BoundSettings
                    {
                        UseMonumentMarker = false,
                        UseCustomBounds = true,
                        CustomBounds = new CustomBounds
                        {
                            CenterOffset = new Vector3(0, 10, 0),
                            Size = new Vector3(30, 30, 30),
                        },
                    },
                },
            };

            [JsonProperty("OverrideMonumentBounds")]
            private Dictionary<string, CustomBounds> DeprecatedOverrideMonumentBounds
            {
                set
                {
                    foreach (var entry in value)
                    {
                        MonumentSettingsMap[entry.Key] = new MonumentSettings
                        {
                            Position = new BaseDetectionSettings { UseMonumentMarker = true },
                            Rotation = new BaseDetectionSettings { UseMonumentMarker = true },
                            Bounds = new BoundSettings
                            {
                                UseCustomBounds = true,
                                CustomBounds = entry.Value,
                            },
                        };
                    }
                }
            }

            public MonumentSettings GetMonumentSettings(string monumentName)
            {
                MonumentSettings monumentSettings;
                return MonumentSettingsMap.TryGetValue(monumentName, out monumentSettings)
                    ? monumentSettings
                    : null;
            }

            public bool AddMonument(string aliasOrShortName, BaseMonumentAdapter monument)
            {
                if (MonumentSettingsMap.ContainsKey(aliasOrShortName))
                    return false;

                var monumentInfo = monument.Object as MonumentInfo;
                var isCustomMonument = monumentInfo != null && IsCustomMonument(monumentInfo);

                MonumentSettings monumentSettings;

                if (isCustomMonument)
                {
                    monumentSettings = DefaultCustomMonumentSettings.Copy();
                }
                else
                {
                    Bounds bounds;
                    if (!NormalMonumentAdapter.MonumentBounds.TryGetValue(aliasOrShortName, out bounds))
                    {
                        bounds = default(Bounds);
                    }

                    monumentSettings = new MonumentSettings
                    {
                        Bounds = new BoundSettings
                        {
                            UseCustomBounds = true,
                            CustomBounds = new CustomBounds
                            {
                                Size = bounds.size,
                                CenterOffset = bounds.center,
                            },
                        }
                    };
                }

                MonumentSettingsMap[aliasOrShortName] = monumentSettings;
                return true;
            }
        }

        private Configuration GetDefaultConfig() => new Configuration();

        #endregion

        #region Configuration Boilerplate

        private class SerializableConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(SerializableConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _pluginConfig = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _pluginConfig = Config.ReadObject<Configuration>();
                if (_pluginConfig == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_pluginConfig))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_pluginConfig, true);
        }

        #endregion

        #region Localization

        private string GetMessage(string playerId, string messageName, params object[] args)
        {
            var message = lang.GetMessage(messageName, this, playerId);
            return args.Length > 0 ? string.Format(message, args) : message;
        }

        private string GetMessage(IPlayer player, string messageName, params object[] args) =>
            GetMessage(player.Id, messageName, args);

        private void ReplyToPlayer(IPlayer player, string messageName, params object[] args) =>
            player.Reply(string.Format(GetMessage(player, messageName), args));

        private static class Lang
        {
            public const string ErrorNoPermission = "NoPermission";
            public const string NoMonumentsFound = "NoMonumentsFound";
            public const string ListHeader = "List.Header";
            public const string AtMonument = "AtMonument";
            public const string ClosestMonument = "ClosestMonument";
            public const string ClosestConfigSuccess = "Closest.Config.Success";
            public const string ClosestConfigAlreadyPresent = "Closest.Config.AlreadyPresent";
            public const string HelpHeader = "Help.Header";
            public const string HelpList = "Help.List";
            public const string HelpShow = "Help.Show";
            public const string HelpClosest = "Help.Closest";
            public const string HelpClosestConfig = "Help.Closest.Config";
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Lang.ErrorNoPermission] = "You don't have permission to do that.",
                [Lang.NoMonumentsFound] = "No monuments found",
                [Lang.AtMonument] = "At monument: {0}\nRelative position: {1}",
                [Lang.ClosestMonument] = "Closest monument: {0}\nDistance: {1:f2}m",
                [Lang.ClosestConfigSuccess] = "Added monument <color=#9f6>{0}</color> to the plugin config.",
                [Lang.ClosestConfigAlreadyPresent] = "Monument <color=#9f6>{0}</color> is already in the plugin config.",
                [Lang.ListHeader] = "Listing monuments:",
                [Lang.HelpHeader] = "Monument Finder commands:",
                [Lang.HelpList] = "<color=#9f6>{0} list <filter></color> - List monuments matching filter",
                [Lang.HelpShow] = "<color=#9f6>{0} show <filter></color> - Show monuments matching filter",
                [Lang.HelpClosest] = "<color=#9f6>{0} closest</color> - Show info about the closest monument",
                [Lang.HelpClosestConfig] = "<color=#9f6>{0} closest config</color> - Adds the closest monument to the config",
            }, this, "en");
        }

        #endregion
    }
}


// --- End of file: MonumentFinder.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/WipeBlock.cs ---
// --- Original Local Path: BeeRust/WipeBlock.cs ---

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using System.Collections;

namespace Oxide.Plugins
{
    [Info("Wipe Block", "King.", "1.0.1")]
    class WipeBlock : RustPlugin
    {
        #region [Vars]
        [PluginReference] private Plugin ImageLibrary = null;

        private const string Layer = "WipeBlock.Layer";
        private const string NLayer = "WipeBlock.Notify";
        private const string IgnorePermission = "WipeBlock.ignore";

        static readonly DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        static double CurrentTime() { return DateTime.UtcNow.Subtract(epoch).TotalSeconds; }
 
        private double IsBlocked(ItemDefinition itemDefinition) => IsBlocked(itemDefinition.shortname);
        private double UnBlockTime(int amount) => SaveRestore.SaveCreatedTime.ToUniversalTime().Subtract(epoch).TotalSeconds + amount;

        private Dictionary<string, int> _itemIds = new Dictionary<string, int>();
        private List<BasePlayer> openUI = new List<BasePlayer>();
        List<ulong> fix = new List<ulong>();
        #endregion

        #region [Config]
        private PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();

            if (config.PluginVersion < Version)
                UpdateConfigValues();

            Config.WriteObject(config, true);
        }

        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (config.PluginVersion < Version)
            {
                config.PluginVersion = Version;
                if (Version == new VersionNumber(1, 0, 0))
                {
                    //
                }

                PrintWarning("Config checked completed!");
            }
            config.PluginVersion = Version;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        private class PluginConfig
        {
            [JsonProperty(PropertyName = "Блокировка предметов")]
            public Dictionary<string, int> blockItems;

            [JsonProperty("Предметы которые нельзя кидать")]
            public List<string> blockItemsThrown;

            [JsonProperty("Config version")]
            public VersionNumber PluginVersion = new VersionNumber();

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    blockItems = new Dictionary<string, int>()
                    {
                        ["pistol.revolver"] = 1800,
                        ["shotgun.double"] = 1800,
                        ["pistol.semiauto"] = 3600,
                        ["pistol.python"] = 3600,
                        ["pistol.m92"] = 3600,
                        ["pistol.prototype17"] = 3600,
                        ["shotgun.pump"] = 3600,
                        ["coffeecan.helmet"] = 3600,
                        ["roadsign.jacket"] = 3600,
                        ["roadsign.kilt"] = 3600,
                        ["smg.2"] = 4200,
                        ["smg.thompson"] = 4200,
                        ["shotgun.spas12"] = 4200,
                        ["rifle.semiauto"] = 4200,
                        ["smg.mp5"] = 5600,
                        ["rifle.m39"] = 5600,
                        ["metal.facemask"] = 5600,
                        ["metal.facemask.icemask"] = 5600,
                        ["metal.plate.torso"] = 5600,
                        ["metal.plate.torso.icevest"] = 5600,
                        ["metal.facemask.hockey"] = 5600,
                        ["rifle.ak"] = 7200,
                        ["rifle.ak.ice"] = 7200,
                        ["rifle.bolt"] = 7200,
                        ["rifle.l96"] = 7200,
                        ["rifle.lr300"] = 7200,
                        ["hmlmg"] = 75600,
                        ["lmg.m249"] = 75600,
                        ["heavy.plate.helmet"] = 75600,
                        ["heavy.plate.jacket"] = 75600,
                        ["heavy.plate.pants"] = 75600,
                        ["grenade.f1"] = 75600,
                        ["grenade.beancan"] = 75600,
                        ["explosive.satchel"] = 84400,
                        ["submarine.torpedo.straight"] = 84400,
                        ["ammo.rocket.mlrs"] = 84400,
                        ["multiplegrenadelauncher"] = 84400,
                        ["explosive.timed"] = 84400,
                        ["rocket.launcher"] = 84400,
                        ["ammo.rifle.explosive"] = 84400,
                        ["ammo.rocket.basic"] = 84400,
                        ["ammo.rocket.fire"] = 84400,
                        ["ammo.rocket.hv"] = 84400,
                    },
                    blockItemsThrown = new List<string>()
                    {
                        "grenade.flashbang.deployed",
                        "grenade.molotov.deployed",
                    },
                    PluginVersion = new VersionNumber()
                };
            }
        }
        #endregion

        #region [ImageLibrary]
        private Boolean HasImage(String imageName, ulong imageId = 0) => (Boolean)ImageLibrary.Call("HasImage", imageName, imageId);
        private Boolean AddImage(String url, String shortname, ulong skin = 0) => (Boolean)ImageLibrary?.Call("AddImage", url, shortname, skin);
        private String GetImage(String shortname, ulong skin = 0) => (String)ImageLibrary?.Call("GetImage", shortname, skin);
        #endregion

        #region [Oxide-Api]
        private void OnServerInitialized()
        {
            if (!permission.PermissionExists(IgnorePermission))
                permission.RegisterPermission(IgnorePermission, this);

            AddImage("https://i.postimg.cc/5t74ZzBr/C2g6QoA.png", $"{Name}.Background");
            AddImage("https://i.postimg.cc/V6rG9J5S/Group-11-1-1.png", $"ItemFon");
            AddImage("https://i.postimg.cc/Gt5jZ44x/uHTdwjY.png", $"{Name}.BlockFon");

            cmd.AddChatCommand("block", this, "MainUi");

            CheckPlayers();
        }

        private void Unload()
        {
            foreach (var player in openUI)
            {
                if (!player.IsConnected) continue;

                CuiHelper.DestroyUi(player, Layer);
            }
        }
        #endregion

        #region [Rust-Api]
        private object CanWearItem(PlayerInventory inventory, Item item)
        {
            var player = inventory.GetComponent<BasePlayer>();
            if (!IsValid(player)) return null;

            var isBlocked = IsBlocked(item.info.shortname) > 0 ? false : (bool?)null;
            if (isBlocked == false)
            {
                if (!fix.Contains(player.userID))
                {
                    plugins.Find("Alerts")?.Call("AddAlert", player, "Предмет заблокирован!", $"Информация о заблокированных\nпредметах - /block", $"{item.info.shortname}");
                    fix.Add(player.userID);
                    timer.Once(0.1f, () => fix.Remove(player.userID));
                }
                return false;
            }

            return null;
        }

        private object CanEquipItem(PlayerInventory inventory, Item item, int targetPos)
        {
            var player = inventory.GetComponent<BasePlayer>();
            if (!IsValid(player)) return null;

            var isBlocked = IsBlocked(item.info.shortname) > 0 ? false : (bool?)null;
            if (isBlocked == false)
            {
                if (!fix.Contains(player.userID))
                {
                    plugins.Find("Alerts")?.Call("AddAlert", player, "Предмет заблокирован!", $"Информация о заблокированных\nпредметах - /block", $"{item.info.shortname}");
                    fix.Add(player.userID);
                    timer.Once(0.1f, () => fix.Remove(player.userID));
                }
                return false;
            }

            return null;
        }

        private object CanMoveItem(Item item, PlayerInventory inventory, ItemContainerId targetContainer)
        {
            if (inventory == null || item == null)
                return null;

            var player = inventory.GetComponent<BasePlayer>();
            if (!IsValid(player)) return null;

            var container = inventory.FindContainer(targetContainer);
            if (container == null || container.entityOwner == null)
                return null;

            var isBlocked = IsBlocked(item.info.shortname) > 0 ? false : (bool?)null;
            if (container.entityOwner is AutoTurret && isBlocked == false)
            {
                if (!fix.Contains(player.userID))
                {
                    plugins.Find("Alerts")?.Call("AddAlert", player, "Предмет заблокирован!", $"Информация о заблокированных\nпредметах - /block", $"{item.info.shortname}");
                    fix.Add(player.userID);
                    timer.Once(0.1f, () => fix.Remove(player.userID));
                }
                return true;
            }

            return null;
        }

        private object CanAcceptItem(ItemContainer container, Item item)
        {
            if (container == null || item == null || container.entityOwner == null)
                return null;

            if (container.entityOwner is AutoTurret)
            {
                var player = item.GetOwnerPlayer();
                if (!IsValid(player)) return null;

                var isBlocked = IsBlocked(item.info.shortname) > 0 ? false : (bool?)null;
                if (isBlocked == false)
                {
                    if (!fix.Contains(player.userID))
                    {
                        plugins.Find("Alerts")?.Call("AddAlert", player, "Предмет заблокирован!", $"Информация о заблокированных\nпредметах - /block", $"{item.info.shortname}");
                        fix.Add(player.userID);
                        timer.Once(0.1f, () => fix.Remove(player.userID));
                    }
                    return ItemContainer.CanAcceptResult.CannotAcceptRightNow;
                }
            }

            return null;
        }

        private object OnWeaponReload(BaseProjectile projectile, BasePlayer player)
        {
            if (!IsValid(player)) return null;

            var isBlocked = IsBlocked(projectile.primaryMagazine.ammoType.shortname) > 0 ? false : (bool?)null;
            if (isBlocked == false)
            {
                SendReply(player, $"Вы <color=#81B67A>не можете</color> использовать этот тип боеприпасов!");
                return false;
            }

            return null;
        }

        private object OnMagazineReload(BaseProjectile projectile, int desiredAmount, BasePlayer player)
        {
            if (!IsValid(player)) return null;

            NextTick(() =>
            {
                var isBlocked = IsBlocked(projectile.primaryMagazine.ammoType.shortname) > 0 ? false : (bool?)null;
                if (isBlocked == false)
                {
                    player.GiveItem(ItemManager.CreateByItemID(projectile.primaryMagazine.ammoType.itemid, projectile.primaryMagazine.contents));
                    projectile.primaryMagazine.contents = 0;
                    projectile.GetItem().LoseCondition(projectile.GetItem().maxCondition);
                    projectile.SendNetworkUpdate();
                    player.SendNetworkUpdate();
                }
            });

            return null;
        }

        private object CanMountEntity(BasePlayer player, MLRS entity)
        {
            if (!IsValid(player)) return null;

            var isBlocked = IsBlocked("ammo.rocket.mlrs") > 0 ? false : (bool?)null;
            if (isBlocked == false)
            {
                player.ChatMessage($"Установка MLRS будет доступна через <color=#eb7d6a>{Convert.ToInt32(Math.Floor(TimeSpan.FromSeconds(IsBlocked("ammo.rocket.mlrs")).TotalHours))}ч{TimeSpan.FromSeconds(IsBlocked("ammo.rocket.mlrs")).Minutes}м</color>");
                return false;
            }

            return null;
        }

        private void OnExplosiveDropped(BasePlayer player, BaseEntity entity) => OnExplosiveThrown(player, entity);

        private void OnExplosiveThrown(BasePlayer player, BaseEntity entity)
        {
            if (!IsValid(player)) return;
            if (!config.blockItemsThrown.Contains(entity.ShortPrefabName)) return;
             
            entity.Kill();
            player.ChatMessage("Вы <color=#81B67A>не можете</color> кидать этот предмет!");
        }
        #endregion

        #region [ConsoleCommand]
        [ConsoleCommand("cmdCloseWipeBlock")]
        private void cmdRemoveUi(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;

            CuiHelper.DestroyUi(player, Layer);
            openUI.Remove(player);
        }

        [ConsoleCommand("changePage")]
        private void cmdChangePage(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;

            AvailableItem(player, int.Parse(arg.Args[0]));
        }

        [ConsoleCommand("changeBlockPage")]
        private void cmdChangeBlockPage(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;

            NotAvailableItem(player, int.Parse(arg.Args[0]));
        }

        [ConsoleCommand("changeButton")]
        private void cmdChnageButton(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;

            if (arg.Args[0] == "OpenItem")
            {
                CuiHelper.DestroyUi(player, Layer + ".Main" + ".BlockItem");

                MenuButton(player, arg.Args[0]);
                AvailableItem(player);
            }
            else if (arg.Args[0] == "BlockItem")
            {
                CuiHelper.DestroyUi(player, Layer + ".Main" + ".LayerItem");

                MenuButton(player, arg.Args[0]);
                NotAvailableItem(player);
            }
        }
        #endregion

        #region [Ui]
        private void MainUi(BasePlayer player)
        {
            #region [Vars]
            if (openUI.Contains(player)) return;
            if (!openUI.Contains(player))
                openUI.Add(player);
            CuiElementContainer container = new CuiElementContainer();
            #endregion

            #region [Parrent]
            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat", Color = "0 0 0 0.7" }
            }, "Overlay", Layer);

            container.Add(new CuiElement
            {
                Parent = Layer,
                Components =
                {
                    new CuiRawImageComponent { Png = GetImage($"{Name}.Background"), Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                }
            });

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Color = "0 0 0 0.35", Material = "assets/content/ui/uibackgroundblur.mat", Sprite = "assets/content/ui/ui.background.transparent.radial.psd" }
            }, Layer);
            #endregion

            #region [Main-Ui]
            container.Add(new CuiPanel
            {
                Image = { Color = "0.3773585 0.3755785 0.3755785 0.65" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-200 -205", OffsetMax = "203 166" },
                CursorEnabled = true,
            }, Layer, Layer + ".Main");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-43 -243", OffsetMax = "46 -215" },
                Text = { Text = "ЗАКРЫТЬ", Font = "robotocondensed-bold.ttf", FontSize = 11, Align = TextAnchor.MiddleCenter, Color = "1 1 1 0.65" },
                Button = { Color = "0.3773585 0.3755785 0.3755785 0.65", Command = "cmdCloseWipeBlock" }
            }, Layer);
            #endregion

            #region [Text]
            container.Add(new CuiLabel
            {
                Text = { Text = $"ВРЕМЕННЫЕ БЛОКИРОВКИ", Color = "1 1 1 0.85", FontSize = 32, Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperCenter },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-393 166", OffsetMax = "395 245" },
            }, Layer);
            #endregion

            CuiHelper.DestroyUi(player, Layer);
            CuiHelper.AddUi(player, container);
            AvailableItem(player);
            MenuButton(player, "OpenItem");
        }

        private void MenuButton(BasePlayer player, String Name)
        {
            #region [Vars]
            CuiElementContainer container = new CuiElementContainer();
            #endregion

            #region [Parrent]
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5" },
                Image = { Color = "0 0 0 0" }
            }, Layer, Layer + ".MenuButton");
            #endregion

            #region [Button]
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-107 174", OffsetMax = "-2 199" },
                Text = { Text = "ДОСТУПНЫЕ", Font = "robotocondensed-bold.ttf", FontSize = 11, Align = TextAnchor.MiddleCenter, Color = Name == "OpenItem" ? $"1 1 1 0.65" : "1 1 1 0.3" },
                Button = { Color = Name == "OpenItem" ? "0.3773585 0.3755785 0.3755785 0.65" : "0.3773585 0.3755785 0.3755785 0.45", Command = "changeButton OpenItem" }
            }, Layer + ".MenuButton");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "10 174", OffsetMax = "122.5 199" },
                Text = { Text = "В БЛОКИРОВКЕ", Font = "robotocondensed-bold.ttf", FontSize = 11, Align = TextAnchor.MiddleCenter, Color = Name == "BlockItem" ? $"1 1 1 0.65" : "1 1 1 0.3" },
                Button = { Color = Name == "BlockItem" ? "0.3773585 0.3755785 0.3755785 0.65" : "0.3773585 0.3755785 0.3755785 0.45", Command = "changeButton BlockItem" }
            }, Layer + ".MenuButton");
            #endregion

            CuiHelper.DestroyUi(player, Layer + ".MenuButton");
            CuiHelper.AddUi(player, container);
        }

        private void AvailableItem(BasePlayer player, int page = 0)
        {
            #region [Vars]
            CuiElementContainer container = new CuiElementContainer();

            var Items = config.blockItems.Where(x => !BlockTimeGui(x.Key)).OrderBy(x => x.Value).ToList();
            var ItemsBlock = Items.Skip(20 * page).Take(20).ToList();
            #endregion

            #region [Main-Ui]
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Color = "0 0 0 0" }
            }, Layer + ".Main", Layer + ".Main" + ".LayerItem");
            #endregion

            #region [Items]
            for (Int32 i = 0, x = 0, y = 0; i < 20; i++)
            {

                if (ItemsBlock.Count - 1 >= i)
                {
                    String Name = ItemManager.FindItemDefinition(ItemsBlock[i].Key)?.displayName?.english;

                    if (String.IsNullOrEmpty(Name))
                        Name = "UNKNOWN";

                    if (Name == "Double Barrel Shotgun")
                        Name = "Double Barrel";

                    if (Name == "Semi-Automatic Pistol")
                        Name = "Semi-Automatic";

                    if (Name == "Ice Metal Chest Plate")
                        Name = "Ice Metal Chest";

                    container.Add(new CuiPanel
                    {
                        RectTransform = { AnchorMin = $"{0.036 + x * 0.187} {0.735 - y * 0.226}", AnchorMax = $"{0.206 + x * 0.187} {0.945 - y * 0.226}" },
                        Image = { Color = "0 0 0 0.5" }
                    }, Layer + ".Main" + ".LayerItem", Layer + ".Main" + ".LayerItem" + $".Item{i}");

                    container.Add(new CuiElement
                    {
                        Parent = Layer + ".Main" + ".LayerItem" + $".Item{i}",
                        Components =
                        {
                            new CuiImageComponent { ItemId = FindItemID(ItemsBlock[i].Key), SkinId = 0 },
                            new CuiRectTransformComponent { AnchorMin = "0.15 0.25", AnchorMax = "0.85 0.9" }
                        }
                    });

			        container.Add(new CuiElement
			        {
				        Parent = Layer + ".Main" + ".LayerItem" + $".Item{i}",
				        Components =
				        {
					        new CuiTextComponent { Text = $"{Name}", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleCenter, Color = "1 1 1 0.85" },
					        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 0.28" }
				        }
			        });

                    container.Add(new CuiElement
                    {
                        Parent = Layer + ".Main" + ".LayerItem" + $".Item{i}",
                        Components =
                        {
                            new CuiRawImageComponent { Png = GetImage($"ItemFon"), Color = "1 1 1 1" },
                            new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                        }
                    });
                }
                else
                {
                    container.Add(new CuiPanel
                    {
                        RectTransform = { AnchorMin = $"{0.036 + x * 0.187} {0.735 - y * 0.226}", AnchorMax = $"{0.206 + x * 0.187} {0.945 - y * 0.226}" },
                        Image = { Color = "0 0 0 0" }
                    }, Layer + ".Main" + ".LayerItem", Layer + ".Main" + ".LayerItem" + $".Item{i}");

                    container.Add(new CuiElement
                    {
                        Parent = Layer + ".Main" + ".LayerItem" + $".Item{i}",
                        Components =
                        {
                            new CuiRawImageComponent { Png = GetImage($"{Name}.BlockFon"), Color = "0 0 0 1" },
                            new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                        }
                    });

                    container.Add(new CuiPanel
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                        Image = { Color = "0 0 0 0.5" }
                    }, Layer + ".Main" + ".LayerItem" + $".Item{i}");
                }

                x++;
                if (x == 5)
                {
                    x = 0;
                    y++;
                }
            }
            #endregion

            #region [Page]
            container.Add(new CuiButton
            {
                Button = { Color = "0.3773585 0.3755785 0.3755785 0.65", Command = Items.Skip(20 * (page + 1)).Count() > 0 ? $"changePage {page + 1}" : "" },
                Text = { Text = ">", FontSize = 18, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, Color = Items.Skip(20 * (page + 1)).Count() > 0 ? "1 1 1 0.65" : "1 1 1 0.15" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "207.5 -13", OffsetMax = "234 13" }
            }, Layer + ".Main" + ".LayerItem");

            container.Add(new CuiButton
            {
                Button = { Color = "0.3773585 0.3755785 0.3755785 0.65", Command = page >= 1 ? $"changePage {page - 1}" : "" },
                Text = { Text = "<", FontSize = 18, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, Color = page >= 1 ? "1 1 1 0.65" : "1 1 1 0.15" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-234 -13", OffsetMax = "-207.5 13" }
            }, Layer + ".Main" + ".LayerItem");
            #endregion

            CuiHelper.DestroyUi(player, Layer + ".Main" + ".LayerItem");
            CuiHelper.AddUi(player, container);
        }

        private void NotAvailableItem(BasePlayer player, int page = 0)
        {
            #region [Vars]
            CuiElementContainer container = new CuiElementContainer();

            var Items = config.blockItems.Where(x => BlockTimeGui(x.Key)).OrderBy(x => x.Value).ToList();
            var ItemsBlock = Items.Skip(20 * page).Take(20).ToList();
            #endregion

            #region [Main-Ui]
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Color = "0 0 0 0" }
            }, Layer + ".Main", Layer + ".Main" + ".BlockItem");
            #endregion

            #region [Items]
            for (Int32 i = 0, x = 0, y = 0; i < 20; i++)
            {
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"{0.036 + x * 0.187} {0.735 - y * 0.226}", AnchorMax = $"{0.206 + x * 0.187} {0.945 - y * 0.226}" },
                    Image = { Color = "0 0 0 0" }
                }, Layer + ".Main" + ".BlockItem", Layer + ".Main" + ".BlockItem" + $".Item{i}");

                if (ItemsBlock.Count - 1 >= i)
                {
                    String Name = ItemManager.FindItemDefinition(ItemsBlock[i].Key)?.displayName?.english;

                    if (String.IsNullOrEmpty(Name))
                        Name = "UNKNOWN";

                    if (Name == "Double Barrel Shotgun")
                        Name = "Double Barrel";

                    if (Name == "Semi-Automatic Pistol")
                        Name = "Semi-Automatic";

                    if (Name == "Ice Metal Chest Plate")
                        Name = "Ice Metal Chest";

                    container.Add(new CuiElement
                    {
                        Parent = Layer + ".Main" + ".BlockItem" + $".Item{i}",
                        Components =
                        {
                            new CuiImageComponent { ItemId = FindItemID(ItemsBlock[i].Key), SkinId = 0, Color = "1 1 1 0.35" },
                            new CuiRectTransformComponent { AnchorMin = "0.15 0.25", AnchorMax = "0.85 0.9" }
                        }
                    });

			        container.Add(new CuiElement
			        {
				        Parent = Layer + ".Main" + ".BlockItem" + $".Item{i}",
				        Components =
				        {
					        new CuiTextComponent { Text = $"{Name}", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleCenter, Color = "1 1 1 0.85" },
					        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 0.28" }
				        }
			        });

                    var time = IsBlocked(ItemsBlock[i].Key);
                    if (time >= 3600)
                    {
                        container.Add(new CuiElement
                        {
                            Parent = Layer + ".Main" + ".BlockItem" + $".Item{i}",
                            Name = Layer + ".Main" + ".BlockItem" + $".Item{i}" + "Time",
                            Components =
                            {
                                new CuiTextComponent { Text = $"<color=#FFFFFF>{Convert.ToInt32(Math.Floor(TimeSpan.FromSeconds(time).TotalHours))}ч{TimeSpan.FromSeconds(time).Minutes}м</color>", FontSize = 12, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf" },
                                new CuiRectTransformComponent { AnchorMin = "0.04 0", AnchorMax = "1 1" },
                            }
                        });
                    }
                    else if (time <= 3600 && time > 60)
                    {
                        container.Add(new CuiElement
                        {
                            Parent = Layer + ".Main" + ".BlockItem" + $".Item{i}",
                            Name = Layer + ".Main" + ".BlockItem" + $".Item{i}" + "Time",
                            Components =
                            {
                                new CuiTextComponent { Text = $"<color=#FFFFFF>{TimeSpan.FromSeconds(time).Minutes}м</color>", FontSize = 12, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf" },
                                new CuiRectTransformComponent { AnchorMin = "0.04 0", AnchorMax = "1 1" },
                            }
                        });
                    }
                    else if (time <= 60 && time > 0)
                    {
                        container.Add(new CuiElement
                        {
                            Parent = Layer + ".Main" + ".BlockItem" + $".Item{i}",
                            Name = Layer + ".Main" + ".BlockItem" + $".Item{i}" + "Time",
                            Components =
                            {
                                new CuiTextComponent { Text = $"<color=#FFFFFF>{TimeSpan.FromSeconds(time).Seconds}с</color>", FontSize = 12, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf" },
                                new CuiRectTransformComponent { AnchorMin = "0.04 0", AnchorMax = "1 1" },
                            }
                        });
                    }
                }

                container.Add(new CuiElement
                {
                    Parent = Layer + ".Main" + ".BlockItem" + $".Item{i}",
                    Components =
                    {
                        new CuiRawImageComponent { Png = GetImage($"{Name}.BlockFon"), Color = "0 0 0 1" },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                    }
                });

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Image = { Color = "0 0 0 0.5" }
                }, Layer + ".Main" + ".BlockItem" + $".Item{i}");

                x++;
                if (x == 5)
                {
                    x = 0;
                    y++;
                }
            }
            #endregion

            #region [Page]
            container.Add(new CuiButton
            {
                Button = { Color = "0.3773585 0.3755785 0.3755785 0.65", Command = Items.Skip(20 * (page + 1)).Count() > 0 ? $"changeBlockPage {page + 1}" : "" },
                Text = { Text = ">", FontSize = 18, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, Color = Items.Skip(20 * (page + 1)).Count() > 0 ? "1 1 1 0.65" : "1 1 1 0.15" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "207.5 -13", OffsetMax = "234 13" }
            }, Layer + ".Main" + ".BlockItem");

            container.Add(new CuiButton
            {
                Button = { Color = "0.3773585 0.3755785 0.3755785 0.65", Command = page >= 1 ? $"changeBlockPage {page - 1}" : "" },
                Text = { Text = "<", FontSize = 18, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, Color = page >= 1 ? "1 1 1 0.65" : "1 1 1 0.15" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-234 -13", OffsetMax = "-207.5 13" }
            }, Layer + ".Main" + ".BlockItem");
            #endregion

            CuiHelper.DestroyUi(player, Layer + ".Main" + ".BlockItem");
            CuiHelper.AddUi(player, container);
        }

        private void NotifyBlock(BasePlayer player, string shortname)
        {
            CuiHelper.DestroyUi(player, NLayer);
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                Image = { Color = "0.5 0.5 0.5 0.25", Material = "assets/icons/greyout.mat" },
                RectTransform = {AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "-245.182 -155.661", OffsetMax = "-2.618 -102.735"},
                CursorEnabled = false,
            }, "Overlay", NLayer);

            container.Add(new CuiElement
            {
                Parent = NLayer,
                Name = NLayer + ".BlockItem",
                Components =
                 {
                     new CuiImageComponent {Color = "0.49 0.44 0.38 0.75", Material = "assets/icons/greyout.mat"},
                     new CuiRectTransformComponent { AnchorMin = "0.01586128 0.08839238", AnchorMax = "0.1925 0.9208925" }
                 }
            });

			container.Add(new CuiElement
			{
				Parent = NLayer + ".BlockItem",
				Components =
				{
					new CuiImageComponent
					{
						ItemId = FindItemID(shortname),
						SkinId = 0
					},
					new CuiRectTransformComponent
					{
						AnchorMin = "0 0", AnchorMax = "1 1"
					}
				}
			});

            container.Add(new CuiElement
            {
                Parent = NLayer,
                Components =
                 {
                     new CuiTextComponent()
                     {
                         Color = "1 1 1 0.65",
                         Text = $"Предмет заблокирован!",
                         FontSize = 14, Align = TextAnchor.MiddleLeft, Font = "robotocondensed-bold.ttf"
                     },
                     new CuiRectTransformComponent {AnchorMin = "0.215 0.585", AnchorMax = "1 1"},
                     new CuiOutlineComponent{Color = "0 0 0 1", Distance = "0.15 0.15"},
                 }
            });

            container.Add(new CuiElement
            {
                Parent = NLayer,
                Components =
                 {
                     new CuiTextComponent()
                     {
                         Color = "1 1 1 0.65",
                         Text = $"Информация о заблокированных\nпредметах - /block",
                         FontSize = 12, Align = TextAnchor.MiddleLeft, Font = "robotocondensed-regular.ttf"
                     },
                     new CuiRectTransformComponent {AnchorMin = "0.215 0", AnchorMax = "1 0.7"},
                     new CuiOutlineComponent{Color = "0 0 0 1", Distance = "0.15 0.15"},
                 }
            });

            container.Add(new CuiButton
            {
                Button = { Color = "0.9 0 0 0.65", Material = "assets/icons/greyout.mat", Close = NLayer },
                RectTransform = { AnchorMin = "0.94 0.725", AnchorMax = "0.995 0.98" }
            }, NLayer, "CloseX");

            container.Add(new CuiElement
            {
                Parent = "CloseX",
                Components =
                 {
                     new CuiTextComponent()
                     {
                         Color = "1 1 1 0.65",
                         Text = $"✘",
                         FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter
                     },
                     new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1"},
                     new CuiOutlineComponent{Color = "0 0 0 1", Distance = "0.35 0.35"},
                 }
            });

            timer.Once(15f, () =>
            {
                  CuiHelper.DestroyUi(player, NLayer);
            });
            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region [Func]
        private double IsBlocked(string shortName)
        {
            if (!config.blockItems.ContainsKey(shortName)) return 0;

            var blockTime = UnBlockTime(config.blockItems[shortName]) - CurrentTime();
            return blockTime > 0 ? blockTime : 0;
        }

        private bool BlockTimeGui(string shortName)
        {
            var blockTime = UnBlockTime(config.blockItems[shortName]) - CurrentTime();
            if (blockTime > 0) return true;

            return false;
        }

        private bool IsValid(BasePlayer player)
        {
            return player != null && player.userID.IsSteamId() &&
                   !permission.UserHasPermission(player.UserIDString, IgnorePermission);
        }

		private int FindItemID(string shortName)
		{
			int val;
			if (_itemIds.TryGetValue(shortName, out val))
				return val;

			var definition = ItemManager.FindItemDefinition(shortName);
			if (definition == null) return 0;

			val = definition.itemid;
			_itemIds[shortName] = val;
			return val;
		}

        private void CheckBlockedItem(BasePlayer player, Item item)
        {
            if (!IsValid(player)) return;

            var isBlocked = IsBlocked(item.info.shortname) > 0 ? false : (bool?)null;
            if (isBlocked == false)
            {
                if (item.MoveToContainer(player.inventory.containerMain))
                    player.Command("note.inv", item.info.itemid, item.amount,
                        !string.IsNullOrEmpty(item.name) ? item.name : string.Empty,
                        (int) BaseEntity.GiveItemReason.PickedUp);
                else
                    item.Drop(player.inventory.containerMain.dropPosition,
                        player.inventory.containerMain.dropVelocity);
            }
        }

        private void CheckPlayers()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                player.inventory.containerBelt.itemList.ToList().ForEach(item => CheckBlockedItem(player, item));
                player.inventory.containerWear.itemList.ToList().ForEach(item => CheckBlockedItem(player, item));
            }
        }
        #endregion
    }
}

// --- End of file: WipeBlock.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/CommandReplacer.cs ---
// --- Original Local Path: BeeRust/CommandReplacer.cs ---

using System.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("CommandReplacer", "YourName", "0.2.0")]
    [Description("Replace non-existent commands with custom text.")]
    class CommandReplacer : RustPlugin
    {
        private DynamicConfigFile config;

        private string replacementText = "Unknown command. Type /help for a list of commands."; // Default replacement text

        void Init()
        {
            config = Interface.Oxide.DataFileSystem.GetFile("commandreplacer");
            LoadConfig();
        }

        void LoadConfig()
        {
            // Load the configuration file
            replacementText = config.Get<string>("ReplacementText", "Unknown command. Type /help for a list of commands.");
            SaveConfig();
        }

        void SaveConfig()
        {
            // Save the configuration file
            config["ReplacementText"] = replacementText;
            config.Save();
        }

        private List<string> GetCommandList()
        {
            var commands = new List<string>();
            foreach (var loadedPlugin in plugins.GetAll())
            {
                if (loadedPlugin == null) continue;
                var pluginCommands = loadedPlugin.GetType().GetMethods()
                    .Where(m =>
                        m.GetCustomAttributes(typeof(ChatCommandAttribute), true)?.Length > 0 ||
                        m.GetCustomAttributes(typeof(ConsoleCommandAttribute), true)?.Length > 0)
                    .Select(m => m.GetCustomAttributes(typeof(ChatCommandAttribute), true)?.FirstOrDefault() ??
                                 m.GetCustomAttributes(typeof(ConsoleCommandAttribute), true)
                                     ?.FirstOrDefault())
                    .ToList();

                pluginCommands.ForEach(p => commands.Add(p.ToString().Replace("Oxide.Core.Libraries.Covalence.ChatCommandAttribute", "").Replace("Oxide.Core.Libraries.Command.ConsoleCommandAttribute", "").Trim()));
            }

            return commands;
        }

        void OnPlayerCommand(IPlayer player, string command, string[] args)
        {
            if (GetCommandList().All(cmd => cmd != "/" + command))
            {
                player.Message(replacementText);
                return;
            }
        }

        [ChatCommand("setreplacementtext")]
        void SetReplacementTextCommand(BasePlayer player, string command, string[] args)
        {
            // Check if the player is an admin
            if (!player.IsAdmin)
            {
                player.ChatMessage("You must be an admin to use this command.");
                return;
            }

            // Set the replacement text with the command argument
            if (args.Length >= 1)
            {
                replacementText = string.Join(" ", args);
                SaveConfig();
                player.ChatMessage("Replacement text set to: " + replacementText);
            }
        }
    }
}

// --- End of file: CommandReplacer.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/XRestartUI.cs ---
// --- Original Local Path: BeeRust/XRestartUI.cs ---

using System.Collections.Generic;
using Oxide.Game.Rust.Cui;  
using UnityEngine;  
using System;
using Newtonsoft.Json;
using System.Linq;
using System.Collections;
  
namespace Oxide.Plugins 
{ 
    [Info("XRestartUI", "Monster.", "1.0.201")]
    class XRestartUI : RustPlugin
    {	 
		 
				
				
		private void TimerGameTip(BasePlayer player, string message, int seconds)
        {
			TimeSpan t = TimeSpan.FromSeconds(seconds);
            player.SendConsoleCommand("gametip.showgametip", string.Format(lang.GetMessage("RESTART", this, player.UserIDString), t.Minutes, t.Seconds, lang.GetMessage(message, this, player.UserIDString)));
        }		
 
        private class RestartConfig 
        {		  
			[JsonProperty("Настройка рестартов по расписанию [ Можно запланировать любую команду в любое время ]")] 
			public Dictionary<string, string> ARestart;			
			
			public static RestartConfig GetNewConfiguration()
            {
                return new RestartConfig  
                {
					Setting = new GeneralSetting      
					{ 
						Message = true,
						UI = true,
						GameTip = false,
						EffectTickUse = true,
						EffectWarningUse = true,
						EffectTick = "assets/bundled/prefabs/fx/notice/loot.drag.dropsuccess.fx.prefab",
						EffectWarning = "assets/bundled/prefabs/fx/item_unlock.prefab",
						SteamID = 0
					},    
					ListMessage = new List<string>
					{
						"M_DEFAULT", "M_1", "M_2"
					},
					ARestart = new Dictionary<string, string>
					{
						["08:00"] = "restart 300",
						["21:00"] = "restart 300 M_1"
					},
					Warning = new List<int>
					{
						60,
						45,
						30,
						15,
						10,
						5
					}
				};
			}
			
			[JsonProperty("Общие настройки")] 
            public GeneralSetting Setting;	
			[JsonProperty("Настройка предупреждений за N минут до рестарта")] 
			public List<int> Warning;			
			[JsonProperty("Список уникальных имен(ключей) причин рестарта - [ Настройка текста в lang ]")] 
			public List<string> ListMessage;			
		    internal class GeneralSetting
			{
				[JsonProperty("SteamID профиля для кастомной аватарки")] public ulong SteamID;
			    [JsonProperty("Использовать эффект тика")] public bool EffectTickUse;
			    [JsonProperty("Использовать UI уведомления")] public bool UI;
			    [JsonProperty("Используемый эффект тика")] public string EffectTick;
			    [JsonProperty("Использовать GameTip уведомления")] public bool GameTip;
			    [JsonProperty("Используемый эффект предупреждения")] public string EffectWarning;
			    [JsonProperty("Использовать сообщения в чате")] public bool Message;
			    [JsonProperty("Использовать эффект предупреждения")] public bool EffectWarningUse;
			}	 				 			
        } 
 
				
				 
		private void TimerGUI(BasePlayer player, string message, int seconds)
		{
			TimeSpan t = TimeSpan.FromSeconds(seconds);
			
			CuiHelper.DestroyUi(player, ".TimerGUI");
            CuiElementContainer container = new CuiElementContainer();
			 
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.85", AnchorMax = "1 0.85", OffsetMin = "0 -25", OffsetMax = "0 25" },
                Image = { Color = "0.217 0.221 0.209 0.4", Material = "assets/icons/greyout.mat" }
            }, "Hud", ".TimerGUI");
			
			container.Add(new CuiElement 
			{ 
				Parent = ".TimerGUI", 
				Components =
				{
					new CuiTextComponent { Text = string.Format(lang.GetMessage("RESTART", this, player.UserIDString), t.Minutes, t.Seconds, lang.GetMessage(message, this, player.UserIDString)), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 18, Color = "1 1 1 0.75" },
				    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
					new CuiOutlineComponent { Color = "0 0 0 1", Distance = "0.2 -0.2" }
				} 
			});	
			 
			CuiHelper.AddUi(player, container);
		}		
		   		 		  						  	   		  	 				   		 		  	 	 		   		 
		private void AutoRestart() 
		{
			string time = DateTime.Now.ToString("t");
			
			foreach(int minute in config.Warning)
			{
				string newtime = DateTime.Now.AddMinutes(minute).ToString("t");
				
				if(config.ARestart.ContainsKey(newtime) && config.ARestart[newtime].Contains("restart"))
				{
					TimeSpan t = TimeSpan.FromSeconds(minute * 60);
					
					if(config.Setting.Message)
						BasePlayer.activePlayerList.ToList().ForEach(x => Player.Reply(x, string.Format(lang.GetMessage("CHAT_WARNING_RESTART", this, x.UserIDString), t.Hours, t.Minutes, t.Seconds), config.Setting.SteamID));
					
					foreach(BasePlayer player in BasePlayer.activePlayerList)
					{
						if(config.Setting.UI)
							WarningGUI(player, t);
						if(config.Setting.GameTip)
							WarningGameTip(player, t);
						
						if(config.Setting.EffectWarningUse)
							EffectNetwork.Send(new Effect(config.Setting.EffectWarning, player, 0, new Vector3(), new Vector3()), player.Connection);
					}
					break;
				}
			}
			
			if(config.ARestart.ContainsKey(time))
				Server.Command(config.ARestart[time]);
		}		
		
		private IEnumerator Restart(string message, int seconds) 
		{
			if(config.Setting.Message)
			{
				TimeSpan t = TimeSpan.FromSeconds(seconds);
				BasePlayer.activePlayerList.ToList().ForEach(x => Player.Reply(x, string.Format(lang.GetMessage("CHAT_RESTART", this, x.UserIDString), t.Minutes, t.Seconds, lang.GetMessage(message, this, x.UserIDString)), config.Setting.SteamID));
			}
			
			for(int i = 0; i <= seconds; i++)
			{
				int sec = seconds - i;
				
				foreach(BasePlayer player in BasePlayer.activePlayerList)
				{
					if(config.Setting.UI)
						TimerGUI(player, message, sec);
					if(config.Setting.GameTip)
						TimerGameTip(player, message, sec);
					
					if(config.Setting.EffectTickUse)
						EffectNetwork.Send(new Effect(config.Setting.EffectTick, player, 0, new Vector3(), new Vector3()), player.Connection);
				}
				
				yield return CoroutineEx.waitForSeconds(1);
			}
			
			yield return CoroutineEx.waitForSeconds(1);
			
			BasePlayer.activePlayerList.ToList().ForEach(x => x.Kick("Server Restarting"));
			
			yield return CoroutineEx.waitForSeconds(2);
			
			ConsoleSystem.Run(ConsoleSystem.Option.Server, "quit", Array.Empty<object>());
			
			yield break;
		}
		 
		  
        private RestartConfig config; 
		  
		private void Unload()
		{
			if(_coroutine != null) 
				ServerMgr.Instance.StopCoroutine(_coroutine);
			
			foreach(BasePlayer player in BasePlayer.activePlayerList)
			{
				CuiHelper.DestroyUi(player, ".TimerGUI");
				player.SendConsoleCommand("gametip.hidegametip");
			}
		} 
        protected override void SaveConfig() => Config.WriteObject(config);
		 
		private object OnServerRestart(string message, int seconds)
		{ 
			if(_coroutine != null) 
				ServerMgr.Instance.StopCoroutine(_coroutine); 
			
			if(seconds > 0)
			{
				message = String.IsNullOrEmpty(message) ? "M_DEFAULT" : message;
			    _coroutine = ServerMgr.Instance.StartCoroutine(Restart(message, seconds)); 
			}
			else if(_coroutine != null) 
			{
				if(config.Setting.Message)
					BasePlayer.activePlayerList.ToList().ForEach(x => Player.Reply(x, lang.GetMessage("CANCELED_RESTART", this, x.UserIDString), config.Setting.SteamID));
				Unload(); 
				
				_coroutine = null;
			}
			
			return true;
		} 
  
        protected override void LoadConfig()
        {
            base.LoadConfig();
			
			try
			{
				config = Config.ReadObject<RestartConfig>(); 
			}
			catch
			{
				PrintWarning("Ошибка чтения конфигурации! Создание дефолтной конфигурации!");
				LoadDefaultConfig();
			}
			
			SaveConfig();
        }
		protected override void LoadDefaultConfig() => config = RestartConfig.GetNewConfiguration();
		private Coroutine _coroutine; 
		   		 		  						  	   		  	 				   		 		  	 	 		   		 
        		
				 
		private void OnServerInitialized()
		{ 
			PrintWarning("\n-----------------------------\n" + 
			"     Author - Monster\n" +
			"     VK - vk.com/idannopol\n" + 
			"     Discord - Monster#4837\n" +
			"     Config - v.3062\n" + 
			"-----------------------------"); 
			
			InitializeLang();
			timer.Every(60, () => AutoRestart());
		}
		
				
	      
        private void InitializeLang() 
        {	
			Dictionary<string, string> langen = new Dictionary<string, string>
			{
				["RESTART"] = "SERVER RESTART THROUGH: {0} MIN. {1} SEC.\n<size=12>{2}</size>",
				["CHAT_RESTART"] = "<color=#a3f0ff>SERVER RESTART THROUGH</color>: <color=orange>{0} MIN. {1} SEC.</color>\n<size=10>{2}</size>",
				["WARNING_RESTART"] = "SERVER RESTART WILL START IN: {0} HR. {1} MIN. {2} SEC.",
				["CHAT_WARNING_RESTART"] = "<size=13><color=#a3f0ff>SERVER RESTART WILL START IN</color>: <color=orange>{0} HR. {1} MIN. {2} SEC.</color></size>",
				["CANCELED_RESTART"] = "<color=#a3f0ff>RESTART CANCELED</color>"
			};		    
			 
			Dictionary<string, string> langru = new Dictionary<string, string>
			{
                ["RESTART"] = "РЕСТАРТ СЕРВЕРА ЧЕРЕЗ: {0} МИН. {1} СЕК.\n<size=12>{2}</size>",
                ["CHAT_RESTART"] = "<color=#a3f0ff>РЕСТАРТ СЕРВЕРА ЧЕРЕЗ</color>: <color=orange>{0} МИН. {1} СЕК.</color>\n<size=10>{2}</size>",				
                ["WARNING_RESTART"] = "РЕСТАРТ СЕРВЕРА НАЧНЕТСЯ ЧЕРЕЗ: {0} ЧАС. {1} МИН. {2} СЕК.",									
                ["CHAT_WARNING_RESTART"] = "<size=13><color=#a3f0ff>РЕСТАРТ СЕРВЕРА НАЧНЕТСЯ ЧЕРЕЗ</color>: <color=orange>{0} ЧАС. {1} МИН. {2} СЕК.</color></size>",									
				["CANCELED_RESTART"] = "<color=#a3f0ff>РЕСТАРТ ОТМЕНЕН</color>"				
			};				
			  
			Dictionary<string, string> langes = new Dictionary<string, string>
			{
                ["RESTART"] = "REINICIAR EL SERVIDOR A TRAVÉS: {0} MIN. {1} SEG.\n<size=12>{2}</size>",	
                ["CHAT_RESTART"] = "<color=#a3f0ff>REINICIAR EL SERVIDOR A TRAVÉS</color>: <color=orange>{0} MIN. {1} SEG.</color>\n<size=10>{2}</size>",				
                ["WARNING_RESTART"] = "EL REINICIO DEL SERVIDOR COMENZARÁ EN: {0} HR. {1} MIN. {2} SEG.",								
                ["CHAT_WARNING_RESTART"] = "<size=13><color=#a3f0ff>EL REINICIO DEL SERVIDOR COMENZARÁ EN</color>: <color=orange>{0} HR. {1} MIN. {2} SEG.</color></size>",								
				["CANCELED_RESTART"] = "<color=#a3f0ff>REINICIO CANCELADO</color>"
			};			
			
			foreach(var message in config.ListMessage)
			{
			   	langen.Add(message, "RESTART RESTART RESTART");
				langru.Add(message, "РЕСТАРТ РЕСТАРТ РЕСТАРТ");
				langes.Add(message, "REINICIAR REINICIAR REINICIAR");
			}
			
			lang.RegisterMessages(langen, this);
			lang.RegisterMessages(langru, this, "ru");
			lang.RegisterMessages(langes, this, "es-ES");
        }
		
		private void WarningGameTip(BasePlayer player, TimeSpan time)
        {
            player.SendConsoleCommand("gametip.showgametip", string.Format(lang.GetMessage("WARNING_RESTART", this, player.UserIDString), time.Hours, time.Minutes, time.Seconds));
            timer.Once(15f, () => player.SendConsoleCommand("gametip.hidegametip"));
        }
		
		private void WarningGUI(BasePlayer player, TimeSpan time)
		{
			CuiHelper.DestroyUi(player, ".TimerGUI");
            CuiElementContainer container = new CuiElementContainer();
			  
			container.Add(new CuiPanel
            {
				FadeOut = 2.5f,
                RectTransform = { AnchorMin = "0 0.85", AnchorMax = "1 0.85", OffsetMin = "0 -25", OffsetMax = "0 25" },
                Image = { Color = "0.217 0.221 0.209 0.4", Material = "assets/icons/greyout.mat", FadeIn = 2.5f }
            }, "Hud", ".TimerGUI");
			
			container.Add(new CuiElement 
			{ 
				Parent = ".TimerGUI", 
				Name = ".TimerGUIText", 
				FadeOut = 2.5f,
				Components =
				{
					new CuiTextComponent { Text = string.Format(lang.GetMessage("WARNING_RESTART", this, player.UserIDString), time.Hours, time.Minutes, time.Seconds), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 20, Color = "1 1 1 0.75", FadeIn = 2.5f },
				    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
					new CuiOutlineComponent { Color = "0 0 0 1", Distance = "0.2 -0.2" }
				} 
			});	
			 
			CuiHelper.AddUi(player, container);
			player.Invoke(() => { CuiHelper.DestroyUi(player, ".TimerGUI"); CuiHelper.DestroyUi(player, ".TimerGUIText"); }, 15.0f);
		} 

        	}
}


// --- End of file: XRestartUI.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/ServerStats.cs ---
// --- Original Local Path: BeeRust/ServerStats.cs ---


using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

using Facepunch;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Rust;

using UnityEngine;
using WebSocketSharp;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
    [Info("ServerStats", "TheRyuzaki & skyplugins.ru", "1.0.6")]
    public class ServerStats : CovalencePlugin
    {
        private static ServerStats _instance;
        private WSH _wsh;
        private FPSVisor ActiveVisor;

        public class WSH
        {
            public WebSocket client;
            public bool hasUnloaded = false;
            public bool networkStatus = false;
            public List<string> pool = new List<string>();
            public Coroutine coroutine;
            public WSH(string WS)
            {
                client = new WebSocket(WS);
                client.SslConfiguration.EnabledSslProtocols = System.Security.Authentication.SslProtocols.Tls12;

                client.OnMessage += OnSocketMessage;
                client.OnOpen += OnSocketConnected;
                client.OnClose += OnSocketDisconnected;
            }

            public void connect()
            {
                if (!this.hasUnloaded)
                {
                    _instance.PrintWarning("[WS] Trying to establish a connection to server...");
                    try
                    {
                        client.ConnectAsync();
                    }
                    catch (Exception ex)
                    {

                    }
                }
            }
            public void close()
            {
                this.hasUnloaded = true;
                client.CloseAsync();
            }
            public bool send(Dictionary<string, object> packet, bool networkIgnore = false)
            {
                return this.send(JsonConvert.SerializeObject(packet, Formatting.None), networkIgnore);
            }

            public bool send(string packet, bool networkIgnore = false)
            {
                if (this.networkStatus || networkIgnore)
                {
#if DEBUG
                    _instance.PrintWarning($"[DEBUG][WS][<-----]: {packet}");
#endif
                    client.SendAsync(packet, new Action<bool>((completed) =>
                    {
                        if (!completed)
                        {
                            _instance.PrintWarning($"[WS] Something went wrong! The message was not sent and was added to the pool!");
                            pool.Add(packet);
                        }
                    }));

                    return true;
                }

                _instance.PrintWarning($"[WS] Send error! We are not connected! The message has been added to the pool and will be sent later!");
                pool.Add(packet);

                return false;
            }

            private void OnSocketConnected(object sender, EventArgs e)
            {
                _instance.PrintWarning("[WS] Socket Connected!");
                this.networkStatus = true;

                NetworkWelcomePacket packet = Pool.Get<NetworkWelcomePacket>();        

                this.client.SendAsync(JsonConvert.SerializeObject(packet), (res) => { });

                Pool.Free(ref packet);
                if (pool.Count > 0)
                {
                    foreach (string packets in pool)
                        this.send(packets, true);

                    pool.Clear();
                }

                this.coroutine = Global.Runner.StartCoroutine(this.Sender());
            }

            private void OnSocketMessage(object sender, MessageEventArgs e)
            {
#if DEBUG
                _instance.PrintWarning($"[DEBUG][WS][----->]: {e.Data}");
#endif
                _instance.NextFrame(() =>
                {
                    try
                    {

                    }
                    catch (Exception ex)
                    {
                        _instance.PrintError($"Exception from OnSocketMessage: {ex}");
                    }
                });
            }

            private void OnSocketDisconnected(object sender, CloseEventArgs e)
            {
                if (e == null || string.IsNullOrEmpty(e.Reason))
                    _instance.PrintWarning("[WS] Socket Disconnected.");
                else
                    _instance.PrintError($"[WS] Socket Disconnected: {e.Reason}");

                this.networkStatus = false;

                if (this.coroutine != null)
                    Global.Runner.StopCoroutine(this.coroutine);

                if (!this.hasUnloaded)
                {
                    _instance.timer.Once(10, this.connect);
                }
            }
            private IEnumerator Sender()
            {
                yield return CoroutineEx.waitForSeconds(1f);

                while (true)
                {
                    _instance.QueueWorkerThread(_ =>
                    {
                        NetworkTickPacket packet = Pool.Get<NetworkTickPacket>();

                        var listPlugins = _instance.plugins.PluginManager.GetPlugins().ToArray();

                        for (var i = 0; i < listPlugins.Length; i++)
                        {
                            packet.ListPlugins.Add(new NetworkTickPacket.PluginItem
                            {
                                Name = listPlugins[i].Name,
                                Version = listPlugins[i].Version.ToString(),
                                Author = listPlugins[i].Author,
                                Hash = listPlugins[i].Name.GetHashCode(),
                                Time = listPlugins[i].TotalHookTime
                            });
                        }


                        client.SendAsync(JsonConvert.SerializeObject(packet), (res) => { });
                        Pool.Free(ref packet);
                    });
                    yield return CoroutineEx.waitForSeconds(1f);
                }
            }

        }


        private void Init()
        {
            _instance = this;
            _wsh = new WSH("wss://s1.server-stats.skyplugins.ru:5191/");

            Unsubscribe("OnPlayerConnected");
            Unsubscribe("OnPlayerDisconnected");
            Unsubscribe("OnPluginLoaded");
            Unsubscribe("OnPluginUnloaded");
        }

        private void OnServerInitialized()
        {
            _wsh.connect();
            this.ActiveVisor = Terrain.activeTerrain.gameObject.AddComponent<FPSVisor>();
        }

        private void Unload()
        {
            _wsh.close();
        }























































        private int MinimalFPS = 9999;

        protected override void LoadDefaultConfig()
        {
            this.Config["Password"] = Random.Range(1000, 999999);
            this.LogWarning("Config file ServerStats.json is not found, you new password: " + this.Config["Password"]);
            this.Config.Save();
        }

        public class FPSVisor : MonoBehaviour
        {
            private void Update()
            {
                if (_instance.MinimalFPS > (int)global::Performance.current.frameRate)
                    _instance.MinimalFPS = (int)global::Performance.current.frameRate;
            }
        }


        public class NetworkWelcomePacket : Pool.IPooled
        {

            [JsonProperty("method")]
            public string Method { get; } = "reg_server";

            [JsonProperty("ServerIp")]
            public string ServerIp { get; } = _instance.server.Address + ":" + _instance.server.Port;
            [JsonProperty("serverName")]
            public string ServerName { get; } = _instance.server.Name;
            [JsonProperty("password")]
            public string Password => _instance.Config["Password"].ToString();

            public void EnterPool()
            {

            }

            public void LeavePool()
            {

            }
        }


        public class NetworkTickPacket: Pool.IPooled
        {
            [JsonProperty("method")]
            public string Method { get; } = "tick_server";
            [JsonProperty("listPlugins")]
            public List<PluginItem> ListPlugins { get; } = Pool.GetList<PluginItem>();

            [JsonProperty("minfps")]
            public int MinimalFps
            {
                get
                {
                    int currentValue = _instance.MinimalFPS;
                    _instance.MinimalFPS = 9999;
                    return currentValue;
                }
            }
            [JsonProperty("fps")]
            public int Fps => Performance.current.frameRate;

            [JsonProperty("ent")]
            public int Ent => BaseNetworkable.serverEntities.Count;
            [JsonProperty("online")]
            public int Online => _instance.players.Connected.Count();
            [JsonProperty("SleepPlayer")]
            public int SleepPlayer => BasePlayer.sleepingPlayerList.Count;
            [JsonProperty("JoiningPlayer")]
            public int JoiningPlayer => ServerMgr.Instance.connectionQueue.Joining;
            [JsonProperty("QueuedPlayer")]
            public int QueuedPlayer => ServerMgr.Instance.connectionQueue.Queued;

            public void EnterPool()
            {
                this.ListPlugins.Clear();
            }

            public void LeavePool()
            {

            }

            public struct PluginItem
            {
                [JsonProperty("name")]
                public string Name
                {
                    get; set;
                }
                [JsonProperty("author")]
                public string Author
                {
                    get; set;
                }
                [JsonProperty("version")]
                public string Version
                {
                    get; set;
                }
                [JsonProperty("hash")]
                public int Hash
                {
                    get; set;
                }
                [JsonProperty("time")]
                public double Time
                {
                    get; set;
                }
            }
        }
    }
}

// --- End of file: ServerStats.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/Clans.cs ---
// --- Original Local Path: BeeRust/Clans.cs ---

using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Transactions;
using Facepunch.Extend;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust;
using Oxide.Game.Rust.Cui;
using ProtoBuf;
using Rust;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Clans", "OxideBro - RustPlugin.ru || Edit by King. ( Boloto Clans )", "1.0.61", ResourceId = 14)]
    public class Clans : RustPlugin
    {

        bool Changed;
        bool Initialized;
        internal static Clans cc = null;
        bool newSaveDetected = false;
        List<ulong> manuallyEnabledBy = new List<ulong>();
        HashSet<ulong> bypass = new HashSet<ulong>();
        Dictionary<string, DateTime> notificationTimes = new Dictionary<string, DateTime>();
        static readonly DateTime UnixEpoch = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc);
        static readonly double MaxUnixSeconds = (DateTime.MaxValue - UnixEpoch).TotalSeconds;
        Library lib;
        public Dictionary<string, Clan> clans = new Dictionary<string, Clan>();
        public Dictionary<string, string> clansSearch = new Dictionary<string, string>();
        List<string> purgedClans = new List<string>();
        Dictionary<string, string> originalNames = new Dictionary<string, string>();
        Dictionary<string, List<string>> pendingPlayerInvites = new Dictionary<string, List<string>>();
        Regex tagReExt;
        Dictionary<string, Clan> clanCache = new Dictionary<string, Clan>();
        List<object> filterDefaults()
        {
            var dp = new List<object>();
            dp.Add("admin");
            dp.Add("mod");
            dp.Add("owner");
            return dp;
        }

        private void SaveConf()
        {
            if (Author != r("BkvqrOeb - EhfgCyhtva.eh"))
                Author = r("Cyhtva nhgube BkvqrOeb - EhfgCyhtva.eh");

        }
        private static string r(string i)
        {
            return !string.IsNullOrEmpty(i) ? new string(i.Select(x => x >= 'a' && x <= 'z' ? (char)((x - 'a' + 13) % 26 + 'a') : x >= 'A' && x <= 'Z' ? (char)((x - 'A' + 13) % 26 + 'A') : x).ToArray()) : i;
        }

        Dictionary<string, object> rewardsDefaults()
        {
            var dp = new Dictionary<string, object>()
            {
                {"wood", 1 },
                { "stones", 1 },
                { "metal.ore", 1 },
                { "sulfur.ore", 1},
                { "hq.metal.ore", 1 },
                {"fat.animal", 1},
                {"cloth", 1},
                {"leather", 1},
                {"scrap", 1},
                {"gears", 1},
                {"techparts", 1},
                {"metalpipe", 1},
            };
            return dp;
        }

        private void RewardClans()
        {
            string SecretKey = "";
            if (string.IsNullOrEmpty(SecretKey))
            {
                PrintWarning("У вас не указан секретный ключ магазина!");
                return;
            }
            string ShopId = "";
            if (string.IsNullOrEmpty(ShopId))
            {
                PrintWarning("У вас не указан айди магазина!");
                return;
            }
            var sortedData = from pair in clans orderby pair.Value.ClanPoints descending select pair;
            int pos = 1;
            foreach (KeyValuePair<string, Clan> key in sortedData)
            {
                if (ClanBonus.ContainsKey(pos))
                {
                    foreach (var member in key.Value.members)
                    {
                        ulong playerID = Convert.ToUInt64(member.Key);
                        string request = $"http://gamestores.ru/api?shop_id={ShopId}&secret={SecretKey}&action=moneys&type=plus&steam_id={playerID}&amount={ClanBonus[pos]}&mess=Баланс за топ клана";
                        webrequest.Enqueue(request, null, (code, response) =>
                        {
                            if (code != 200 || response == null || code != 100) 
                                return;
                        }, this, Core.Libraries.RequestMethod.GET);

                        var player = BasePlayer.FindByID(playerID);
                        if (player == null)
                        {
                            Puts($"Успешно выдано {ClanBonus[pos]} рублей на баланс магазина игроку {playerID}");
                        }
                        else
                        {
                            Puts($"Успешно выдано {ClanBonus[pos]} рублей на баланс магазина игроку {player.displayName}/{playerID}");
                        }
                    }
                }
                pos++;
            }
        }

        Dictionary<int, float> ClanBonus = new Dictionary<int, float>()
        {
            [1] = 100,
            [2] = 45,
            [3] = 15,
        };

        Dictionary<string, int> NeedLimit = new Dictionary<string, int>()
        {
            ["wood"] = 1000000,
            ["stones"] = 1000000,
            ["metal.ore"] = 1000000,
            ["sulfur.ore"] = 1000000,
            ["hq.metal.ore"] = 250000,
            ["cloth"] = 100000,
            ["leather"] = 100000,
            ["fat.animal"] = 100000,
            ["loot-barrel"] = 100000,
        };

        Dictionary<string, object> rewardsTranslateDefault()
        {
            var dp = new Dictionary<string, object>()
            {
                {"wood", "ДЕРЕВО"},
                { "stones", "КАМЕНЬ" },
                { "metal.ore", "МЕТАЛ" },
                { "sulfur.ore", "СЕРА"},
                { "hq.metal.ore", "МВК" },
                {"fat.animal", "ЖИР"},
                {"cloth", "ТКАНЬ"},
                {"leather", "КОЖА"},
                {"scrap", "СКРАП"},
                {"gears", "ШЕСТЕРНИ"},
                {"techparts", "МИКРОСХЕМЫ"},
                {"metalpipe", "ТРУБЫ"},
            };
            return dp;
        }
        int ValidTimeFarm; 
        public int limitMembers;
        int limitModerators;
        public int limitAlliances;
        int tagLengthMin;
        int tagLengthMax;
        int inviteValidDays;
        int friendlyFireNotifyTimeout;
        string allowedSpecialChars;
        public bool enableFFOPtion;
        bool enableAllyFFOPtion;
        bool enableWordFilter;
        bool enableClanTagging;
        public bool enableClanAllies;
        bool forceAllyFFNoDeactivate;
        bool forceClanFFNoDeactivate;
        bool enableWhoIsOnlineMsg;
        bool enableComesOnlineMsg;
        int authLevelRename;
        int authLevelDelete;
        int authLevelInvite;
        int authLevelKick;
        int authLevelPromoteDemote;
        int authLevelClanInfo;
        bool purgeOldClans;
        int notUpdatedSinceDays;
        bool listPurgedClans;
        bool wipeClansOnNewSave;
        bool useProtostorageClandata;
        string consoleName;
        string broadcastPrefix;
        string broadcastPrefixAlly;
        string broadcastPrefixColor;
        string broadcastPrefixFormat;
        string broadcastMessageColor;
        string colorCmdUsage;
        string colorTextMsg;
        string colorClanNamesOverview;
        string colorClanFFOff;
        string colorClanFFOn;
        string pluginPrefix;
        string pluginPrefixColor;
        string pluginPrefixREBORNColor;
        bool pluginPrefixREBORNShow;
        string pluginPrefixFormat;
        string clanServerColor;
        string clanOwnerColor;
        string clanCouncilColor;
        string clanModeratorColor;
        string clanMemberColor;
        bool setHomeOwner = false;
        bool setHomeModerator = false;
        bool setHomeMember = false;
        string chatCommandClan;
        string chatCommandFF;
        string chatCommandAllyChat;
        string chatCommandClanChat;
        string chatCommandClanInfo;
        string subCommandClanHelp;
        string subCommandClanAlly;
        bool usePermGroups;
        string permGroupPrefix;
        bool usePermToCreateClan;
        string permissionToCreateClan;
        bool usePermToJoinClan;
        string permissionToJoinClan;
        bool addClanMembersAsIOFriends;
        string clanTagColorBetterChat;
        int clanTagSizeBetterChat;
        string clanTagOpening;
        string clanTagClosing;
        bool clanChatDenyOnMuted;
        List<string> activeRadarUsers = new List<string>();
        Dictionary<string, List<BasePlayer>> clanRadarMemberobjects = new Dictionary<string, List<BasePlayer>>();
        static Vector3 sleeperHeight = new Vector3(0f, 1.0f, 0f);
        static Vector3 playerHeight = new Vector3(0f, 1.8f, 0f);
        bool enableAtLogin;
        private bool forceNametagsOnTagging;
        public static bool useRelationshipManager;
        private bool teamUiWasDisabled;
        private bool disableManageFunctions;
        private bool allowButtonLeave;
        private bool allowButtonKick;
        private bool allowDirectInvite;
        private bool allowPromoteLeader;

        List<object> wordFilter = new List<object>();

        Dictionary<string, object> RewardGather = new Dictionary<string, object>();
        Dictionary<string, object> RewardTranslate = new Dictionary<string, object>();

        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }


        int PointsOfDeath = 1;
        int PointsOfKilled = 1;
        int PointsOfKilledHeli = 1;
        int PointsOfKilledBradleyAPC = 1;
        int PointsOfSuicide = 1;
        int PointsOfBarrel = 1;
        int PointFarm = 1;
        int PointsOfGatherMetalOre = 1;
        int PointsOfGatherStone = 1;
        int PointsOfGatherWood = 1;
        int PointsOfGatherHQM = 0;

        void LoadVariables()
        {
            wordFilter = (List<object>)GetConfig("Фильтр", "Слова", filterDefaults());
            RewardGather = (Dictionary<string, object>)GetConfig("ТОП", "Список предметов и очков за их добычу [Shortname: количество очков]", rewardsDefaults());

            RewardTranslate = (Dictionary<string, object>)GetConfig("ТОП", "Перевод итемов на русский [Shortname: Русский перевод]", rewardsTranslateDefault());

            PointsOfKilledBradleyAPC = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков даем за Танк", 1));
            PointsOfDeath = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков убирает за смерть", 1));
            PointsOfKilled = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков даем за убийство игрока", 1));
            PointsOfKilledHeli = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков даем за сбитие вертолёта", 1));
            PointsOfSuicide = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков забираем за суицид", 1));
            PointFarm = Convert.ToInt32(GetConfig("ТОП", "Скок очков за фарм?", 1));
            PointsOfGatherMetalOre = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков даем за добычу металической руды (за разбитый камень - то есть за последний удар)", 1));
            PointsOfGatherStone = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков даем за добычу камня (за разбитый камень - то есть за последний удар)", 1));
            PointsOfGatherWood = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков даем за добычу дерева (за разбитый камень - то есть за последний удар)", 1));
            PointsOfGatherHQM = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков даем за добычу МВК (за разбитый камень - то есть за последний удар)", 0));
            PointsOfBarrel = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков даем за разрушение бочки (за разбитый камень - то есть за последний удар)", 1));

            ValidTimeFarm = Convert.ToInt32(GetConfig("Время", "После сколки часов нельзя фармить очки", 1));
            limitMembers = Convert.ToInt32(GetConfig("Лимиты", "Лимит участников клана", 8));
            limitModerators = Convert.ToInt32(GetConfig("Лимиты", "Лимит модераторов", 2));
            limitAlliances = Convert.ToInt32(GetConfig("Лимиты", "Лимит альянса", 2));
            tagLengthMin = Convert.ToInt32(GetConfig("Лимиты", "Лимит размера тега клана от", 2));
            tagLengthMax = Convert.ToInt32(GetConfig("Лимиты", "Лимит размера тега клана до", 10));
            inviteValidDays = Convert.ToInt32(GetConfig("Лимиты", "Длительность активного приглашения в днях", 1));
            friendlyFireNotifyTimeout = Convert.ToInt32(GetConfig("Лимиты", "Таймаут FF", 5));
            allowedSpecialChars = Convert.ToString(GetConfig("Лимиты", "Разрешенные специальные символы в тег клана", "!²³"));
            enableFFOPtion = Convert.ToBoolean(GetConfig("Настройки", "Включить FF длля кланов", true));
            enableAllyFFOPtion = Convert.ToBoolean(GetConfig("Настройки", "Включить FF для альянса", true));
            forceAllyFFNoDeactivate = Convert.ToBoolean(GetConfig("Настройки", "Запретить отключать FF для альянса", true));
            forceClanFFNoDeactivate = Convert.ToBoolean(GetConfig("Настройки", "Запретить отключать FF для клана", false));
            enableWordFilter = Convert.ToBoolean(GetConfig("Настройки", "Включить фльтр слов", true));
            enableClanTagging = Convert.ToBoolean(GetConfig("Настройки", "Включить клан ТЭГ", true));
            enableClanAllies = Convert.ToBoolean(GetConfig("Настройки", "Включить альянсы", false));
            enableWhoIsOnlineMsg = Convert.ToBoolean(GetConfig("Настройки", "Включить сообщение об онлайне клана", true));
            enableComesOnlineMsg = Convert.ToBoolean(GetConfig("Настройки", "Включить сообщение об входе игрока сокланам", true));
            useProtostorageClandata = Convert.ToBoolean(GetConfig("Storage", "Использовать Proto хранилище данных клана (Дата)", false));
            authLevelRename = Convert.ToInt32(GetConfig("Настройки привилегий", "Authentication Level Rename (Не трогать)", 1));
            authLevelDelete = Convert.ToInt32(GetConfig("Настройки привилегий", "Authentication Level Delete (Не трогать)", 2));
            authLevelInvite = Convert.ToInt32(GetConfig("Настройки привилегий", "Authentication Level Invite (Не трогать)", 1));
            authLevelKick = Convert.ToInt32(GetConfig("Настройки привилегий", "Authentication Level Kick (Не трогать)", 2));
            authLevelPromoteDemote = Convert.ToInt32(GetConfig("Настройки привилегий", "Authentication Level Promote Demote (Не трогать)", 1));
            authLevelClanInfo = Convert.ToInt32(GetConfig("Настройки привилегий", "Authentication Level Clan Info (Не трогать)", 0));
            usePermGroups = Convert.ToBoolean(GetConfig("Настройки привилегий", "Использовать разрешения для групп?", false));
            permGroupPrefix = Convert.ToString(GetConfig("Настройки привилегий", "Префикс привилегий для групп", "clan_"));
            usePermToCreateClan = Convert.ToBoolean(GetConfig("Настройки привилегий", "Использовать привилегию для создания клана?", false));
            permissionToCreateClan = Convert.ToString(GetConfig("Настройки привилегий", "Привилегия для создания клана", "clans.cancreate"));
            usePermToJoinClan = Convert.ToBoolean(GetConfig("Permission", "Использовать привилегию для возможности вступления в клан?", false));
            permissionToJoinClan = Convert.ToString(GetConfig("Permission", "Привилегия на возможность вступления в клан", "clans.canjoin"));
            purgeOldClans = Convert.ToBoolean(GetConfig("Очистка", "Удаление старых кланов", false));
            notUpdatedSinceDays = Convert.ToInt32(GetConfig("Очистка", "Дни с каких клан не обновлялся на удаление", 14));
            listPurgedClans = Convert.ToBoolean(GetConfig("Очистка", "Включить список очищенных кланов", false));
            wipeClansOnNewSave = Convert.ToBoolean(GetConfig("Очистка", "Удалить кланы при вайпе?", false));
            consoleName = Convert.ToString(GetConfig("Оформление", "Консольное имя", "ServerOwner"));
            broadcastPrefix = Convert.ToString(GetConfig("Оформление", "Префикс", "(CLAN)"));
            broadcastPrefixAlly = Convert.ToString(GetConfig("Оформление", "Префикс альянса", "(ALLY)"));
            broadcastPrefixColor = Convert.ToString(GetConfig("Оформление", "Цвет префикса", "#a1ff46"));
            broadcastPrefixFormat = Convert.ToString(GetConfig("Оформление", "Формат вывода сообщения", "<color={0}>{1}</color> "));
            broadcastMessageColor = Convert.ToString(GetConfig("Оформление", "Цвет вывода сообщения", "#e0e0e0"));
            colorCmdUsage = Convert.ToString(GetConfig("Оформление", "Цвет CMD", "#ffd479"));
            colorTextMsg = Convert.ToString(GetConfig("Оформление", "Цвет сообщения", "#e0e0e0"));
            colorClanNamesOverview = Convert.ToString(GetConfig("Оформление", "Цвет имена клана ", "#b2eece"));
            colorClanFFOff = Convert.ToString(GetConfig("Оформление", "Цвет сообщения об отключении FF", "#00DF00"));
            colorClanFFOn = Convert.ToString(GetConfig("Оформление", "Цвет сообщения об включении FF", "#DF0005"));
            pluginPrefix = Convert.ToString(GetConfig("Оформление", "Префикс", "CLANS"));
            pluginPrefixColor = Convert.ToString(GetConfig("Оформление", "Цвет префикса в сообщении", "#FBA300"));
            pluginPrefixREBORNColor = Convert.ToString(GetConfig("Оформление", "Цвет префикса в сообщении", "#ce422b"));
            pluginPrefixREBORNShow = Convert.ToBoolean(GetConfig("Оформление", "Включить префикс?", true));
            pluginPrefixFormat = Convert.ToString(GetConfig("Оформление", "Формат префикса REBORN в сообщении", "<color={0}>{1}</color>: "));
            clanServerColor = Convert.ToString(GetConfig("Оформление", "Цвет клана сервера в сообщении", "#ff3333"));
            clanOwnerColor = Convert.ToString(GetConfig("Оформление", "Цвец владельца клана в сообщении", "#a1ff46"));
            clanCouncilColor = Convert.ToString(GetConfig("Оформление", "Цвет команд помощи в сообщении", "#b573ff"));
            clanModeratorColor = Convert.ToString(GetConfig("Оформление", "Цвет модераторов клана в сообщении", "#74c6ff"));
            clanMemberColor = Convert.ToString(GetConfig("Оформление", "Цвет онлайна клана в сообщении", "#fcf5cb"));
            clanTagColorBetterChat = Convert.ToString(GetConfig("BetterChat", "Цвет тега кланов в чате", "#aaff55"));
            clanTagSizeBetterChat = Convert.ToInt32(GetConfig("BetterChat", "Размер тега кланов в чате", 15));
            clanTagOpening = Convert.ToString(GetConfig("BetterChat", "Скобка начало для тега", "["));
            clanTagClosing = Convert.ToString(GetConfig("BetterChat", "Скобка конец для тега", "]"));
            clanChatDenyOnMuted = Convert.ToBoolean(GetConfig("BetterChat", "Использовать полный мут для клана", false));
            chatCommandClan = Convert.ToString(GetConfig("Команды", "Открытие меню клана", "clan"));
            chatCommandFF = Convert.ToString(GetConfig("Команды", "Настройка FF для клана", "cff"));
            chatCommandAllyChat = Convert.ToString(GetConfig("Команды", "Отправка сообщения альянсу", "a"));
            chatCommandClanChat = Convert.ToString(GetConfig("Команды", "Отправка сообщения клану", "c"));
            chatCommandClanInfo = Convert.ToString(GetConfig("Команды", "Чатовая команда инфо клана для администраторов", "cinfo"));
            subCommandClanHelp = Convert.ToString(GetConfig("Команды", "Дополнительная подкоманда для вывода информации помощи", "help"));
            subCommandClanAlly = Convert.ToString(GetConfig("Команды", "Дополнительная подкоманда для вывода информации об альянсе", "ally"));
            addClanMembersAsIOFriends = Convert.ToBoolean(GetConfig("RustIO", "Добавить членов клана в качестве IO Friends", true));

            forceNametagsOnTagging = Convert.ToBoolean(GetConfig("Настройки", "forceNametagsOnTagging", false));

            useRelationshipManager = Convert.ToBoolean(GetConfig("Внутриигровая система друзей", "Использовать внутриигровую систему друзей", false));
            disableManageFunctions = Convert.ToBoolean(GetConfig("Внутриигровая система друзей", "Отключить управление тимой игрокам (Выход, инвайт и прочее)", false));
            allowButtonLeave = Convert.ToBoolean(GetConfig("Внутриигровая система друзей", "Разрешить выходить из тимы", true));
            allowButtonKick = Convert.ToBoolean(GetConfig("Внутриигровая система друзей", "Разрешить удалять из тимы", true));
            allowDirectInvite = Convert.ToBoolean(GetConfig("Внутриигровая система друзей", "Разрешить приглашение в тиму", true));
            allowPromoteLeader = Convert.ToBoolean(GetConfig("Внутриигровая система друзей", "Разрешить продвижение лидера тимы", true));
            if (!Changed) return;

            SaveConf();
            SaveConfig();
            Changed = false;
        }

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string> {
                    { "nopermtocreate", "You got no rights to create a clan." },
                {
                    "nopermtojoin", "You got no rights to join a clan."
                }
                , {
                    "nopermtojoinbyinvite", "The player {0} has no rights to join a clan."
                }
                , {
                    "claninvite", "You have been invited to join the clan: [{0}] '{1}'\nTo join, type: <color={2}>/clan join {0}</color>"
                }
                , {
                    "comeonline", "{0} has come online!"
                }
                , {
                    "goneoffline", "{0} has gone offline!"
                }
                , {
                    "friendlyfire", "{0} is a clan member and cannot be hurt.\nTo toggle clan friendlyfire type: <color=#FF6c6c>/clan ff</color>"
                }
                , {
                    "allyfriendlyfire", "{0} is an ally member and cannot be hurt."
                }
                , {
                    "notmember", "You are currently not a member of a clan."
                }
                , {
                    "youareownerof", "You are the owner of:"
                }
                , {
                    "youaremodof", "You are a moderator of:"
                }
                , {
                    "youarecouncilof", "You are a council of:"
                }
                , {
                    "youarememberof", "You are a member of:"
                }
                , {
                    "claninfo", " [{0}] {1}"
                }
                , {
                    "memberon", "Members online: "
                }
                , {
                    "overviewnamecolor", "<color={0}>{1}</color>"
                }
                , {
                    "memberoff", "Members offline: "
                }
                , {
                    "notmoderator", "You need to be a moderator of your clan to use this command."
                }
                , {
                    "pendinvites", "Pending invites: "
                }
                , {
                    "bannedwords", "The clan tag contains banned words."
                }
                , {
                    "viewthehelp", "To view more commands, type: <color={0}>/{1} helpies</color>"
                }
                , {
                    "usagecreate", "Usage - <color={0}>/clan create \"TAG\" \"Description\"</color>"
                }
                , {
                    "hintlength", "Clan tags must be {0} to {1} characters long"
                }
                , {
                    "hintchars", "Clan tags must contain only 'a-z' 'A-Z' '0-9' '{0}'"
                }
                , {
                    "providedesc", "Please provide a short description of your clan."
                }
                , {
                    "tagblocked", "There is already a clan with this tag."
                }
                , {
                    "nownewowner", "You are now the owner of the clan [{0}] \"{1}\""
                }
                , {
                    "inviteplayers", "To invite new members, type: <color={0}>/clan invite <name></color>"
                }
                , {
                    "usageinvite", "Usage - <color={0}>/clan invite <name></color>"
                }
                , {
                    "nosuchplayer", "No such player or player name not unique: {0}"
                }
                , {
                    "alreadymember", "This player is already a member of your clan: {0}"
                }
                , {
                    "alreadyinvited", "This player has already been invited to your clan: {0}"
                }
                , {
                    "alreadyinclan", "This player is already in a clan: {0}"
                }
                , {
                    "invitebroadcast", "{0} invited {1} to the clan."
                }
                , {
                    "usagewithdraw", "Usage: <color={0}>/clan withdraw <name></color>"
                }
                , {
                    "notinvited", "This player has not been invited to your clan: {0}"
                }
                , {
                    "canceledinvite", "{0} canceled the invitation of {1}."
                }
                , {
                    "usagejoin", "Usage: <color={0}>/clan join \"TAG\"</color>"
                }
                , {
                    "youalreadymember", "You are already a member of a clan."
                }
                , {
                    "younotinvited", "You have not been invited to join this clan."
                }
                , {
                    "reachedmaximum", "This clan has already reached the maximum number of members."
                }
                , {
                    "broadcastformat", "<color={0}>{1}</color>: {2}"
                }
                , {
                    "allybroadcastformat", "[{0}] <color=#FF6c6c>{2}</color>: {3}"
                }
                , {
                    "clanrenamed", "{0} renamed your clan to: [{1}]."
                }
                , {
                    "yourenamed", "You have renamed the clan [{0}] to [{1}]"
                }
                , {
                    "clandeleted", "{0} deleted your clan."
                }
                , {
                    "youdeleted", "You have deleted the clan [{0}]"
                }
                , {
                    "noclanfound", "There is no clan with that tag [{0}]"
                }
                , {
                    "renamerightsowner", "You need to be a server owner to rename clans."
                }
                , {
                    "usagerename", "Usage: <color={0}>/clan rename OLDTAG NEWTAG</color>"
                }
                , {
                    "deleterightsowner", "You need to be a server owner to delete clans."
                }
                , {
                    "usagedelete", "Usage: <color={0}>/clan delete TAG</color>"
                }
                , {
                    "clandisbanded", "Your current clan has been disbanded forever."
                }
                , {
                    "needclanowner", "You need to be the owner of your clan to use this command."
                }
                , {
                    "needclanownercouncil", "You need to be the owner or a council to use this command."
                }
                , {
                    "usagedisband", "Usage: <color={0}>/clan disband forever</color>"
                }
                , {
                    "usagepromote", "Usage: <color={0}>/clan promote <name></color>"
                }
                , {
                    "playerjoined", "{0} has joined the clan!"
                }
                , {
                    "waskicked", "{0} kicked {1} from the clan."
                }
                , {
                    "modownercannotkicked", "The player {0} is an owner or moderator and cannot be kicked."
                }
                , {
                    "notmembercannotkicked", "The player {0} is not a member of your clan."
                }
                , {
                    "usageff", "Usage: <color={0}>/clan ff</color> toggles your current FriendlyFire status."
                }
                , {
                    "usagekick", "Usage: <color={0}>/clan kick <name></color>"
                }
                , {
                    "playerleft", "{0} has left the clan."
                }
                , {
                    "youleft", "You have left your current clan."
                }
                , {
                    "usageleave", "Usage: <color={0}>/clan leave</color>"
                }
                , {
                    "notaclanmember", "The player {0} is not a member of your clan."
                }
                , {
                    "alreadyowner", "The player {0} is already the owner of your clan."
                }
                , {
                    "alreadyamod", "The player {0} is already a moderator of your clan."
                }
                , {
                    "alreadyacouncil", "The player {0} is already a council of your clan."
                }
                , {
                    "alreadyacouncilset", "The position of the council is already awarded."
                }
                , {
                    "maximummods", "This clan has already reached the maximum number of moderators."
                }
                , {
                    "playerpromoted", "{0} promoted {1} to moderator."
                }
                , {
                    "playerpromotedcouncil", "{0} promoted {1} to council."
                }
                , {
                    "playerpromotedowner", "{0} promoted {1} to new owner."
                }
                , {
                    "usagedemote", "Usage: <color={0}>/clan demote <name></color>"
                }
                , {
                    "notamoderator", "The player {0} is not a moderator of your clan."
                }
                , {
                    "notpromoted", "The player {0} is not a moderator or council of your clan."
                }
                , {
                    "playerdemoted", "{0} demoted {1} to a member."
                }
                , {
                    "councildemoted", "{0} demoted {1} to a moderator."
                }
                , {
                    "noactiveally", "Your clan has no current alliances."
                }
                , {
                    "yourffstatus", "Your FriendlyFire:"
                }
                , {
                    "yourclanallies", "Your Clan allies:"
                }
                , {
                    "allyinvites", "Ally invites:"
                }
                , {
                    "allypending", "Ally requests:"
                }
                , {
                    "allyReqHelp", "Offer an alliance to another clan"
                }
                , {
                    "allyAccHelp", "Accept an alliance from another clan"
                }
                , {
                    "allyDecHelp", "Decline an alliance from another clan"
                }
                , {
                    "allyCanHelp", "Cancel an alliance with another clan"
                }
                , {
                    "reqAlliance", "[{0}] has requested a clan alliance"
                }
                , {
                    "invitePending", "You already have a pending alliance invite for [{0}]"
                }
                , {
                    "clanNoExist", "The clan [{0}] does not exist"
                }
                , {
                    "alreadyAllies", "You are already allied with"
                }
                , {
                    "allyProvideName", "You need to provide a Clan name"
                }
                , {
                    "allyLimit", "You already have the maximum allowed ally limit"
                }
                , {
                    "allyAccLimit", "You can not accept the alliance with {0}. You reached the limit"
                }
                , {
                    "allyCancel", "You have cancelled your alliance with [{0}]"
                }
                , {
                    "allyCancelSucc", "{0} has cancelled your clan alliance"
                }
                , {
                    "noAlly", "Your clans have no alliance with each other"
                }
                , {
                    "noAllyInv", "You do not have a alliance invite from [{0}]"
                }
                , {
                    "allyInvWithdraw", "You have cancelled your request to [{0}]"
                }
                , {
                    "allyDeclined", "You have declined the clan alliance from [{0}]"
                }
                , {
                    "allyDeclinedSucc", "[{0}] has declined your alliance request"
                }
                , {
                    "allyReq", "You have requested a clan alliance from [{0}]"
                }
                , {
                    "allyAcc", "You have accepted the clan alliance from [{0}]"
                }
                , {
                    "allyAccSucc", "[{0}] has accepted your alliance request"
                }
                , {
                    "allyPendingInfo", "Your clan has pending ally request(s). Check those in the clan overview."
                }
                , {
                    "clanffdisabled", "You have <color={0}>disabled</color> friendly fire for your clan.\nThey are safe!"
                }
                , {
                    "clanffenabled", "You have <color={0}>enabled</color> friendly fire for your clan.\nTake care!"
                }
                , {
                    "yourname", "YOU"
                }
                , {
                    "helpavailablecmds", "Available commands:"
                }
                , {
                    "helpinformation", "Display your clan information"
                }
                , {
                    "helpmessagemembers", "Send a message to all members"
                }
                , {
                    "helpmessageally", "Send a message to all allied members"
                }
                , {
                    "helpcreate", "Create a new clan"
                }
                , {
                    "helpjoin", "Join a clan by invitation"
                }
                , {
                    "helpleave", "Leave your clan"
                }
                , {
                    "helptoggleff", "Toggle friendlyfire status"
                }
                , {
                    "helpinvite", "Invite a player"
                }
                , {
                    "helpwithdraw", "Cancel an invite"
                }
                , {
                    "helpkick", "Kick a member"
                }
                , {
                    "helpallyoptions", "Lists the ally options"
                }
                , {
                    "helppromote", "Promote a member"
                }
                , {
                    "helpdemote", "Demote a member"
                }
                , {
                    "helpdisband", "Disband your clan (no undo)"
                }
                , {
                    "helpmoderator", "Moderator"
                }
                , {
                    "helpowner", "Owner"
                }
                , {
                    "helpcommands", "commands:"
                }
                , {
                    "helpconsole", "Open F1 console and type:"
                }
                , {
                    "yourradarstatus", "Your ClanRadar:"
                }
                , {
                    "clanradardisabled", "Clan radar disabled"
                }
                , {
                    "clanradarenabled", "Clan radar enabled"
                }
                , {
                    "helptoggleradar", "Toggle clanradar status"
                }
                , {
                    "clanArgCreate", "create"
                }
                , {
                    "clanArgInvite", "invite"
                }
                , {
                    "clanArgLeave", "leave"
                }
                , {
                    "clanArgWithdraw", "withdraw"
                }
                , {
                    "clanArgJoin", "join"
                }
                , {
                    "clanArgPromote", "promote"
                }
                , {
                    "clanArgDemote", "demote"
                }
                , {
                    "clanArgFF", "ff"
                }
                , {
                    "clanArgRadar", "radar"
                }
                , {
                    "clanArgAlly", "ally"
                }
                , {
                    "clanArgHelp", "help"
                }
                , {
                    "clanArgKick", "kick"
                }
                , {
                    "clanArgDisband", "disband"
                }
                , {
                    "clanArgForever", "forever"
                }
                , {
                    "clanArgNameId", "<name|id>"
                }
                , {
                    "allyArgRequest", "request"
                }
                , {
                    "allyArgRequestShort", "req"
                }
                , {
                    "allyArgAccept", "accept"
                }
                , {
                    "allyArgAcceptShort", "acc"
                }
                , {
                    "allyArgDecline", "decline"
                }
                , {
                    "allyArgDeclineShort", "dec"
                }
                , {
                    "allyArgCancel", "cancel"
                }
                , {
                    "allyArgCancelShort", "can"
                }
                ,
                {
                    "clanchatmuted", "You may not clanchat, you are muted."
                },
                 {
                    "clanUItitle", "Clan System by RustPlugin.ru / OxideBro"
                },
                  {
                    "clanTOPUItitle", "Clans TOP"
                },
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>()
            {
                {"nopermtocreate", "У тебя нету привилегии для создания клана."},
                 { "nopermtojoin", "У тебя нету привилегии что бы вступать в клан."},
                 { "nopermtojoinbyinvite", "У игрока {0} нету прав чтобы вступить в клан."},
                 { "claninvite", "Вас пригласили в клан: [{0}] '{1}'\nЧтобы вступить, введите: <color=#FF6c6c>/clan join {0}</color>"},
                 { "comeonline", "{0} зашел в игру!"},
                 { "goneoffline", "{0} вышел с игры!"},
                 { "friendlyfire", "{0} ваш соклановец, и не может получить урон.\nИспользуйте: <color=#FF6c6c>/clan ff</color> чтобы включить урон"},
                 { "allyfriendlyfire", "{0} является союзником и не может получить урон."},
                 { "notmember", "В настоящее время вы не являетесь членом клана."},
                 { "youareownerof", "Вы являетесь владельцем:"},
                 { "youaremodof", "Вы являетесь модератором:"},
                  {"youarecouncilof", "Вы советник в:"},
                 { "youarememberof", "Вы участник в:"},
                 { "claninfo", " [{0}] {1}"},
                  {"memberon", "Игроки клана в сети: "},
                 { "overviewnamecolor", "<color=#FF6c6c>{1}</color>"},
                 { "memberoff", "Игроки клана не в сети: "},
                 { "notmoderator", "Вы должны быть модератором своего клана, чтобы использовать эту команду."},
                 { "pendinvites", "Ожидающие приглашения: "},
                 { "bannedwords", "Tег клана содержит запрещенные слова."},
                 { "viewthehelp", "Чтобы просмотреть больше команд, введите: <color=#FF6c6c>/{1}</color>"},
                 { "hintlength", "Клановый тег должнен быть от {0} до {1} символов"},
                  {"hintchars", "Клановый тег может использовать только 'a-z' 'A-Z' '0-9' '{0}' символы"},
                 { "providedesc", "Пожалуйста, уточните краткое описание вашего клана."},
                 { "tagblocked", "Уже есть клан с этим тегом."},
                 { "nownewowner", "Теперь вы владелец клана [{0}] \"{1}\""},
                  {"inviteplayers", "Чтобы пригласить новых участников, введите: <color=#FF6c6c>/clan invite <name></color>"},
                  {"nosuchplayer", "Нет такого игрока или имя игрока указано не верно: {0}"},
                  {"alreadymember", "Этот игрок уже является членом вашего клана: {0}"},
                  {"alreadyinvited", "Этот игрок уже приглашен в ваш клан: {0}"},
                  {"alreadyinclan", "Этот игрок уже в клане: {0}"},
                 { "invitebroadcast", "{0} вступил в клан {1}."},
                 { "notinvited", "Этот игрок не был приглашен в ваш клан: {0}"},
                 { "canceledinvite", "{0} отменил приглашение {1}."},
                 { "youalreadymember", "Вы уже являетесь членом клана."},
                 { "younotinvited", "Вы не были приглашены в этот клан."},
                 { "reachedmaximum", "Этот клан уже достиг максимального количества участников."},
                 { "broadcastformat", "<color=#FF6c6c>{1}</color>: {2}"},
                 { "allybroadcastformat", "[{0}] <color=#FF6c6c>{2}</color>: {3}"},
                 { "clanrenamed", "{0} переименовал переименовал клан в: [{1}]."},
                 { "yourenamed", "Вы переименовали клан [{0}] в [{1}]"},
                  {"clandeleted", "{0} удалил свой клан."},
                 { "youdeleted", "Вы удалили клан [{0}]"},
                 { "noclanfound", "Нету клана с этим тегом [{0}]"},
                  {"renamerightsowner", "Вы должны быть администратором сервера, чтобы переименовать кланы."},
                 { "deleterightsowner", "Вы должны быть администратором сервера, чтобы удалять кланы."},
                 { "clandisbanded", "Ваш текущий клан был распущен навсегда."},
                 { "needclanowner", "Вы должны быть владельцем своего клана, чтобы использовать эту команду."},
                 { "needclanownercouncil", "Вы должны быть владельцем или модератором, чтобы использовать эту команду."},
                 { "playerjoined", "{0} присоединился к клану!"},
                 { "waskicked", "{0} выгнал {1} из клана."},
                 { "modownercannotkicked", "Игрок {0} является владельцем или модератором и не может быть выкинут."},
                 { "notmembercannotkicked", "Игрок {0} не является членом клана."},
                 { "playerleft", "{0} покинул клан."},
                 { "youleft", "Вы покинули свой текущий клан."},
                  {"notaclanmember", "Игрок {0} не является членом вашего клана."},
                 { "maximummods", "Этот клан уже достиг максимального количества модераторов."},
                  {"playerpromoted", "{0} повышен {1} до модератора."},
                 { "playerpromotedcouncil", "{0} повышен до {1} до советника."},
                 { "playerpromotedowner", "{0} повышен {1} до нового владельца."},
                 { "notamoderator", "Игрок {0} не является модератором вашего клана."},
                 { "notpromoted", "Игрок {0} не является модератором или советом вашего клана."},
                 { "playerdemoted", "{0} понижен в должности {1} до участника."},
                 { "noactiveally", "Ваш клан не имеет текущих альянсов."},
                 { "yourffstatus", "Ваш FriendlyFire:"},
                 { "yourclanallies", "Союзники вашего клана:"},
                 { "allyinvites", "Ally приглашает:"},
                 { "allypending", "запросы союзников:"},
                 { "allyReqHelp", "Предложить союз другому клану"},
                 { "allyAccHelp", "Примите союз от другого клана"},
                  {"allyDecHelp", "Отклонить союз от другого клана"},
                 { "allyCanHelp", "Отменить союз с другим кланом"},
                 { "reqAlliance", "[{0}] запросил альянс клана"},
                {  "clanNoExist", "Клан [{0}] не существует"},
                 { "allyProvideName", "Вам необходимо указать имя клана"},
                 { "allyLimit", "У вас уже есть максимально допустимое ограничение союзников"},
                 { "allyAccLimit", "Вы не можете принять альянс с {0}. Вы достигли предела"},
                {  "allyCancel", "Вы отменили свой союз с [{0}]"},
                {  "allyCancelSucc", "{0} отменил ваш клановый союз"},
                 { "noAlly", "Ваши кланы не имеют альянса друг с другом"},
                 { "noAllyInv", "У вас нет приглашения в альянс от [{0}]"},
                 { "allyInvWithdraw", "Вы отменили свой запрос к [{0}]"},
                 { "allyDeclined", "Вы отказались от альянса кланов от [{0}]"},
                {  "allyDeclinedSucc", "[{0}] отклонил ваш запрос на альянс"},
                 { "allyReq", "Вы запросили альянс клана от [{0}]"},
                 { "allyAcc", "Вы приняли клановый союз от [{0}]"},
                {  "allyAccSucc", "[{0}] принял ваш запрос на альянс"},
                 { "allyPendingInfo", "Ваш клан имеет ожидающие запросы союзников. Проверьте их в обзоре клана."},
                 { "clanffdisabled", "У вас <color=#FF6c6c> отключенный </color> дружественный огонь для вашего клана.\nЭто безопасно!"},
                 { "clanffenabled", "У вас <color=#FF6c6c> включенный </color> дружественный огонь для вашего клана.\nВнимитесь!"},
                 {"yourname", "ВЫ"},
                 { "helpavailablecmds", "Доступные команды:"},
                 { "helpinformation", "Показать информацию о вашем клане"},
                 { "helpmessagemembers", "Отправить сообщение всем участникам"},
                 { "helpmessageally", "Отправить сообщение всем союзникам"},
                 { "helpcreate", "Создание нового клана"},
                 { "helpjoin", "Вступить в клан по приглашению"},
                 { "helpleave", "Выйти с вашего текущего клана"},
                 { "helptoggleff", "Переключить статус FF"},
                 { "helpinvite", "Пригласить игрока"},
                 { "helpwithdraw", "Отменить приглашение"},
                 { "helpkick", "Кикнуть участника"},
                 { "helpallyoptions", "Список опций"},
                 { "helppromote", "Повысить участника"},
                 { "helpdemote", "Понизить участника"},
                {  "helpdisband", "Расформирование своего клана (Не отменить)"},
                {  "helpmoderator", "Модератор"},
                {  "helpowner", "Создатель"},
                 { "helpcommands", "команды:"},
                 { "helpconsole", "Откройте консоль, F1:"},
                 { "yourradarstatus", "Ваш клан радар:"},
                 { "clanradardisabled", "Клан радар отключен"},
                  {"clanradarenabled", "Клан радар включен"},
                 { "helptoggleradar", "Переключение статуса клан радара"},
                 { "clanArgCreate", "create"},
                 { "clanArgInvite", "invite"},
                 { "clanArgLeave", "leave"},
                {  "clanArgWithdraw", "withdraw"},
                {  "clanArgJoin", "join"},
                 { "clanArgPromote", "promote"},
                 { "clanArgDemote", "demote"},
                 { "clanArgFF", "ff"},
                 { "clanArgRadar", "radar"},
                {  "clanArgAlly", "ally"},
                 { "clanArgHelp", "help"},
                 { "clanArgKick", "kick"},
                 { "clanArgDisband", "disband"},
                 { "clanArgForever", "forever"},
                 { "clanArgNameId", "<name|id>"},
                 { "allyArgRequest", "request"},
                 { "allyArgRequestShort", "req"},
                 { "allyArgAccept", "accept"},
                 { "allyArgAcceptShort", "acc"},
                 { "allyArgDecline", "decline"},
                 { "allyArgDeclineShort", "dec"},
                 { "allyArgCancel", "cancel"},
                 { "allyArgCancelShort", "can"},
                 { "clanchatmuted", "Вы не можете писать в клан чат."},
                 { "clanUItitle", "Система кланов Unusual"},
                 { "clanTOPUItitle", "TOP кланов сервера"},
                 { "alreadyowner", "Игрок {0} уже владелец вашего клана."},
                 { "alreadyamod", "Игрок {0} уже капитан вашего клана."},
                {  "alreadyacouncil", "Игрок {0} уже советчик вашего клана."},
                 { "alreadyacouncilset", "Должность советчика уже установлена."},
                  {"councildemoted", "{0} пониженный {1} до модератора."},
                 { "invitePending", "У вас уже есть ожидающее приглашение в альянс для [{0}]"},
                 { "alreadyAllies", "Вы уже состоите в альянсе с"},
                 { "usagecreate", "Используйте - <color=#FF6c6c>/clan create \"TAG Клана\" \"Название клана\"</color>"},
                 { "usageinvite", "Используйте - <color=#FF6c6c>/clan invite <name></color>"},
                 { "usagewithdraw", "Используйте: <color=#FF6c6c>/clan withdraw <name></color>"},
                {  "usagejoin", "Используйте: <color=#FF6c6c>/clan join \"TAG\"</color>"},
                {  "usagerename", "Используйте: <color=#FF6c6c>/clan rename OLDTAG NEWTAG</color>"},
                {  "usagedelete", "Используйте: <color=#FF6c6c>/clan delete TAG</color>"},
                { "usagedisband", "Используйте: <color=#FF6c6c>/clan disband forever</color>"},
                {  "usagepromote", "Используйте: <color=#FF6c6c>/clan promote <name></color>"},
                {  "usageff", "Используйте: <color=#FF6c6c>/clan ff</color> toggles your current FriendlyFire status."},
                {  "usagekick", "Используйте: <color=#FF6c6c>/clan kick <name></color>"},
                {  "usageleave", "Используйте: <color=#FF6c6c>/clan leave</color>"},
                 { "usagedemote", "Используйте: <color=#FF6c6c>/clan demote <name></color>"}
            }, this, "ru");
        }

        void Init()
        {
            cc = this;
            LoadVariables();
            LoadDefaultMessages();
            Initialized = false;
            if (!permission.PermissionExists(permissionToCreateClan)) permission.RegisterPermission(permissionToCreateClan, this);
            permission.RegisterPermission("clans.forestset", this);
            if (!permission.PermissionExists(permissionToJoinClan)) permission.RegisterPermission(permissionToJoinClan, this);
            cmd.AddChatCommand(chatCommandFF, this, "cmdChatClanFF");
            //Custom code
            //cmd.AddChatCommand("clanui", this, "CLanUIInfo");

            cmd.AddChatCommand(chatCommandClan, this, "cmdChatClan");
            cmd.AddChatCommand(chatCommandClanChat, this, "cmdChatClanchat");
            cmd.AddChatCommand(chatCommandAllyChat, this, "cmdChatAllychat");
            cmd.AddChatCommand(chatCommandClanInfo, this, "cmdChatClanInfo");
            cmd.AddChatCommand(chatCommandClan + subCommandClanHelp, this, "cmdChatClanHelp");
            cmd.AddChatCommand(chatCommandClan + subCommandClanAlly, this, "cmdChatClanAlly");
            if (enableClanTagging) Interface.CallHook("API_RegisterThirdPartyTitle", this, new Func<IPlayer, string>(getFormattedClanTag));
        }

        void OnPluginLoaded(Plugin plugin)
        {
            if (plugin.Title == "Better Chat" || plugin.Title == "ChatPlus")
                if (enableClanTagging) Interface.CallHook("API_RegisterThirdPartyTitle", this, new Func<IPlayer, string>(getFormattedClanTag));
        }


        string getFormattedClanTag(IPlayer player)
        {
            var clan = findClanByUser(player.Id);
            if (clan != null && !string.IsNullOrEmpty(clan.tag)) return $"[#{clanTagColorBetterChat.Replace("#", "")}][+{clanTagSizeBetterChat}]{clanTagOpening}{clan.tag}{clanTagClosing}[/+][/#]";
            return string.Empty;
        }

        [PluginReference] private Plugin ImageLibrary, TournamentBoloto;

        public string GetImageSkin(string shortname, ulong skin = 13975490) => (string)ImageLibrary.Call("GetImage", shortname, skin);
        public bool AddImage(string url, string imageName, ulong imageId = 0) => (bool)ImageLibrary.Call("AddImage", url, imageName, imageId);


        #region LoadNewSkinsMethod

        private Dictionary<string, Dictionary<ulong, ulong>> SkinList = new Dictionary<string, Dictionary<ulong, ulong>>();

        void LoadSkins()
        {
            webrequest.Enqueue("https://files.facepunch.com/rust/icons/inventory/rust/schema.json", null, (code, response) =>
            {
                if (!(response == null && code == 200))
                {
                    var schm = JsonConvert.DeserializeObject<Rust.Workshop.ItemSchema>(response);
                    var items = schm.items;
                    foreach (var item in items)
                    {
                        if (!string.IsNullOrEmpty(item.itemshortname) && !string.IsNullOrEmpty(item.icon_url) && item.type != "None")
                        {
                            ulong owner = 0;
                            if (!SkinList.ContainsKey(item.itemshortname))
                            {
                                SkinList[item.itemshortname] = new Dictionary<ulong, ulong>();
                                SkinList[item.itemshortname][0] = 0;
                            }

                            if (item.workshopdownload != null)
                                AddSkinToList(item.itemshortname, item.itemdefid, Convert.ToUInt64(item.workshopdownload), owner);
                            else
                                AddSkinToList(item.itemshortname, item.itemdefid, item.itemdefid, owner);
                        }
                    }
                }
            }, this);
        }

        private static Dictionary<string, Dictionary<ulong, ulong>> FreeSkinList = new Dictionary<string, Dictionary<ulong, ulong>>();

        private static Dictionary<ulong, Dictionary<string, Dictionary<ulong, ulong>>> PlayerSkinList = new Dictionary<ulong, Dictionary<string, Dictionary<ulong, ulong>>>();

        private void AddSkinToList(string item, ulong skin, ulong workshopid, ulong owner = 0)
        {
            if (owner == 0)
            {
                if (SkinList[item] == null)
                {
                    SkinList[item] = new Dictionary<ulong, ulong>();
                    SkinList[item][0] = 0;
                }

                SkinList[item][skin] = workshopid;
            }
            else if (owner == 1)
            {
                if (FreeSkinList[item] == null)
                    FreeSkinList[item] = new Dictionary<ulong, ulong>();

                FreeSkinList[item][skin] = workshopid;
            }
            else
            {
                if (PlayerSkinList[owner] == null)
                    PlayerSkinList[owner] = new Dictionary<string, Dictionary<ulong, ulong>>();
                if (PlayerSkinList[owner][item] == null)
                    PlayerSkinList[owner][item] = new Dictionary<ulong, ulong>();

                PlayerSkinList[owner][item][skin] = workshopid;
            }
            //AddImage("https://rustlabs.com/img/skins/324/" + skin + ".png", item, workshopid);
        }

        #endregion
        static Clans ins;

        void OnServerInitialized()
        {
            LoadSkins();
            ins = this;
            if (useRelationshipManager)
            {
                Subscribe(nameof(OnServerCommand));
                if (!RelationshipManager.TeamsEnabled())
                {
                    teamUiWasDisabled = true;
                    PrintWarning($"TeamUI functions partly inactive, maxTeamSize was set to '{RelationshipManager.maxTeamSize}'");
                }
            }
            else
            {
                Unsubscribe(nameof(OnServerCommand));
            }


            object obj = LoadData();

            if (!ImageLibrary)
            {
                PrintError("ImageLibrary not found! Clans not work!");
            }
            else
            {
                clanCache.ToList().ForEach(c => ImageLibrary?.Call("AddImage", c.Value.owner, c.Value.owner));
            }

            Rust.Global.Runner.StartCoroutine(ServerInitialized(obj));

            foreach (var player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);

            timer.Every(1f, PlayTimePlayer);
            timer.Every(60f, PlayTimePlayer);

            ImageLibrary?.Call("AddImage", "https://i.imgur.com/lQ8Yf5O.png", "logopng");
            ImageLibrary?.Call("AddImage", "https://i.imgur.com/cEBay4m.png", "loot-barrel");
            ImageLibrary?.Call("AddImage", "https://media.discordapp.net/attachments/615106543662268418/1068982385351336027/image.png", "bStats");
        }

        void PlayTimePlayer()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                var clan = findClanByUser(player.UserIDString);
                if(clan != null)
                    clan.members[player.UserIDString].PlayTimeInServer += 1;
            }
        }

        void AvatarClan()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                var clan = findClanByUser(player.UserIDString);
                if(clan != null)
                    ImageLibrary?.Call("AddImage", clan.owner, clan.owner);
            }
        }

        private IEnumerator ServerInitialized(object obj)
        {
            if (obj != null)
                InitializeClans((bool)obj);

            if (purgeOldClans)
                Puts($"Valid clans loaded: '{clans.Count}'");

            if (purgeOldClans && purgedClans.Count() > 0)
            {
                Puts($"Old Clans purged: '{purgedClans.Count}'");
                if (listPurgedClans)
                {
                    foreach (string purged in purgedClans)
                        Puts($"Purged > {purged}");
                }
            }

            yield return CoroutineEx.waitForSeconds(2f);

            AllyRemovalCheck();

            tagReExt = new Regex("[^a-zA-Z0-9" + allowedSpecialChars + "]");

            foreach (BasePlayer player in BasePlayer.activePlayerList.ToList())
                SetupPlayer(player);

            foreach (BasePlayer player in BasePlayer.sleepingPlayerList.ToList())
                SetupPlayer(player);

            foreach (KeyValuePair<string, Clan> clan in clans)
            {
                clan.Value.OnUpdate(false);
                clan.Value.UpdateTeam();
            }

            Initialized = true;
            yield return null;
        }

        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            if (useRelationshipManager && arg != null && arg.cmd != null)
            {
                if (RelationshipManager.TeamsEnabled() || teamUiWasDisabled)
                {
                    if (arg.cmd.Name.ToLower() == "maxteamsize" && arg.FullString != string.Empty)
                    {
                        int i = arg.GetInt(0, 0);
                        if (i > 0 && teamUiWasDisabled)
                        {
                            teamUiWasDisabled = false;
                            Puts($"TeamUI functions full activated");
                            return null;
                        }
                        else if (i < 1)
                        {
                            teamUiWasDisabled = true;
                            PrintWarning($"TeamUI functions partly inactive, maxTeamSize was set to '{i}'");
                            return null;
                        }
                    }

                    Clan obj;
                    if (!RelationshipManager.TeamsEnabled())
                        return null;

                    if (arg.Connection != null && clanCache.TryGetValue(arg.Connection.userid.ToString(), out obj) && arg.cmd.Parent.ToLower() == "relationshipmanager")
                    {
                        if (disableManageFunctions)
                            return false;

                        if (arg.cmd.Name.ToLower() == "leaveteam" && allowButtonLeave)
                        {
                            LeaveClan(arg.Player());
                            return false;
                        }

                        if (arg.cmd.Name.ToLower() == "kickmember" && allowButtonKick)
                        {
                            KickPlayer(arg.Player(), arg.FullString.Trim('"'));
                            return false;
                        }

                        if (arg.cmd.Name.ToLower() == "sendinvite" && allowDirectInvite)
                        {
                            InvitePlayer(arg.Player(), arg.FullString.Trim('"'));
                            return false;
                        }

                        if (arg.cmd.Name.ToLower() == "promote" && allowPromoteLeader)
                        {
                            BasePlayer lookingAtPlayer = RelationshipManager.GetLookingAtPlayer(arg.Player());
                            if (lookingAtPlayer == null || lookingAtPlayer.IsDead() || lookingAtPlayer == arg.Player())
                                return false;

                            if (lookingAtPlayer.currentTeam == arg.Player().currentTeam)
                            {
                                bool wasCouncil = obj.IsCouncil(lookingAtPlayer.UserIDString);
                                bool wasMod = obj.IsModerator(lookingAtPlayer.UserIDString);

                                if (wasCouncil && !wasMod)
                                    obj.council = arg.Player().UserIDString;

                                if (wasMod && !wasCouncil)
                                {
                                    obj.RemoveModerator(lookingAtPlayer);
                                    obj.SetModerator(arg.Player());
                                }

                                obj.owner = lookingAtPlayer.UserIDString;
                                obj.BroadcastLoc("playerpromotedowner", obj.GetColoredName(arg.Player().UserIDString, arg.Connection.username), obj.GetColoredName(lookingAtPlayer.UserIDString, obj.FindClanMember(lookingAtPlayer.UserIDString).Name));
                                obj.OnUpdate(true);
                            }
                            return false;
                        }
                    }
                }
            }

            return null;
        }

        void OnServerSave() => SaveData();
        void OnNewSave()
        {
            if (wipeClansOnNewSave) newSaveDetected = true;
            RewardClans();
        }

        void Unload()
        {
            if (!Initialized) return;
            SaveData();

            foreach (BasePlayer player in BasePlayer.activePlayerList.ToList())
                DoCleanUp(player);

            foreach (BasePlayer player in BasePlayer.sleepingPlayerList.ToList())
                DoCleanUp(player);

            foreach (BasePlayer player in BasePlayer.activePlayerList.ToList())
                CuiHelper.DestroyUi(player, "clans_main1");

            foreach (BasePlayer player in BasePlayer.activePlayerList.ToList())
            {
                CuiHelper.DestroyUi(player, "Message");
                CuiHelper.DestroyUi(player, "setRes");
                CuiHelper.DestroyUi(player, "Layerkk");
                CuiHelper.DestroyUi(player, "MainSkinLayerMain");
                CuiHelper.DestroyUi(player, "Clanstop_main2");
            }
        }

        private void DoCleanUp(BasePlayer player)
        {
            if (player == null)
                return;

            Clan clan = findClanByUser(player.UserIDString);
            if (clan != null)
            {
                if (useRelationshipManager)
                {
                    RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);
                    playerTeam?.RemovePlayer(player.userID);

                    player.ClearTeam();
                    RelationshipManager.ServerInstance.playerToTeam.Remove(player.userID);
                }

                if (enableClanTagging)
                {
                    string name = player.displayName.Replace($"{clanTagOpening}{clan.tag}{clanTagClosing} ", "");
                    player.displayName = name;

                    if (player.net != null)
                        player._name = string.Format("{1}[{0}/{2}]", player.net.ID, name, player.userID);
                }

                if (!Interface.Oxide.IsShuttingDown)
                {
                    if (forceNametagsOnTagging)
                        player.limitNetworking = true;

                    player.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

                    if (forceNametagsOnTagging)
                        player.limitNetworking = false;
                }
            }
        }


        private object LoadData()
        {
            StoredData protoStorage = new StoredData();
            StoredData jsonStorage = new StoredData();
            StoredData oldStorage = new StoredData();
            bool protoFileFound = ProtoStorage.Exists(new string[] { Title });
            bool jsonFileFound = Interface.GetMod().DataFileSystem.ExistsDatafile(Title);
            bool oldFileFound = Interface.GetMod().DataFileSystem.ExistsDatafile("rustio_clans");
            if (!protoFileFound && !jsonFileFound)
            {
                oldStorage = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("rustio_clans");
            }
            else
            {
                if (jsonFileFound)
                    jsonStorage = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(Title);

                if (protoFileFound)
                {
                    protoStorage = ProtoStorage.Load<StoredData>(new string[]
                      {
                        Title
                      });
                }
            }

            bool lastwasProto = protoStorage.lastStorage == "proto" && (protoStorage.saveStamp > jsonStorage.saveStamp || protoStorage.saveStamp > oldStorage.saveStamp);

            if (useProtostorageClandata)
            {
                if (lastwasProto)
                {
                    clanSaves = ProtoStorage.Load<StoredData>(new string[] { Title }) ?? new StoredData();
                }
                else
                {
                    if (oldFileFound && !jsonFileFound)
                        clanSaves = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("rustio_clans");

                    if (jsonFileFound)
                        clanSaves = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(Title);
                }
            }
            else
            {
                if (!lastwasProto)
                {
                    if (oldFileFound && !jsonFileFound)
                        clanSaves = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("rustio_clans");

                    if (jsonFileFound)
                        clanSaves = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(Title);
                }
                else if (protoFileFound)
                {
                    clanSaves = ProtoStorage.Load<StoredData>(new string[] { Title }) ?? new StoredData();
                }
            }

            if (wipeClansOnNewSave && newSaveDetected)
            {
                if (useProtostorageClandata)
                    ProtoStorage.Save<StoredData>(clanSaves, new string[] { Title + ".bak" });
                else Interface.Oxide.DataFileSystem.WriteObject(Title + ".bak", clanSaves);

                Puts("New save detected > Created backup of clans and wiped datafile");
                clans = new Dictionary<string, Clan>();
                clansSearch = new Dictionary<string, string>();
                return null;
            }

            clans = new Dictionary<string, Clan>();
            clansSearch = new Dictionary<string, string>();

            if (clanSaves.clans == null || clanSaves.clans.Count == 0)
                return null;

            clans = clanSaves.clans;
            return !jsonFileFound && !protoFileFound;
        }

        void InitializeClans(bool newFileFound)
        {
            Dictionary<string, int> clanDuplicates = new Dictionary<string, int>();
            List<string> clanDuplicateCount = new List<string>();
            foreach (var _clan in clans.ToList())
            {
                Clan clan = _clan.Value;
                if (purgeOldClans && (UnixTimeStampUTC() - clan.updated) > (notUpdatedSinceDays * 86400))
                {
                    purgedClans.Add($"[{clan.tag}] | {clan.description} | Owner: {clan.owner} | LastUpd: {UnixTimeStampToDateTime(clan.updated)}");
                    if (permission.GroupExists(permGroupPrefix + clan.tag))
                    {
                        foreach (var member in clan.members)
                            if (permission.UserHasGroup(member.Key, permGroupPrefix + clan.tag))
                                permission.RemoveUserGroup(member.Key, permGroupPrefix + clan.tag);
                        permission.RemoveGroup(permGroupPrefix + clan.tag);
                    }
                    RemoveClan(clan.tag);
                    continue;
                }
                foreach (var member in clan.members.ToList())
                {
                    var p = covalence.Players.FindPlayerById(member.Key);
                    if (!(p is IPlayer) || p == null || p.Name == "")
                    {
                        clan.members.Remove(member.Key);
                        clan.moderators.Remove(member.Key);
                    }
                }
                if (clan.members.Count() == 0)
                {
                    RemoveClan(clan.tag);
                    continue;
                }
                if (!clan.members.ContainsKey(clan.owner)) clan.owner = clan.members.ToList()[0].Key;
                if (usePermGroups && !permission.GroupExists(permGroupPrefix + clan.tag)) permission.CreateGroup(permGroupPrefix + clan.tag, "Clan " + clan.tag, 0);
                foreach (var member in clan.members)
                {
                    if (usePermGroups && !permission.UserHasGroup(member.Key, permGroupPrefix + clan.tag)) permission.AddUserGroup(member.Key, permGroupPrefix + clan.tag);
                }
                foreach (var invited in clan.invites.ToList())
                {
                    if ((UnixTimeStampUTC() - (int)invited.Value) > (inviteValidDays * 86400)) clan.invites.Remove(invited.Key);
                }
                clanCache[clan.owner] = clan;
                foreach (var member in clan.members)
                {
                    if (!clanDuplicates.ContainsKey(member.Key))
                    {
                        clanDuplicates.Add(member.Key, 1);
                        clanCache[member.Key] = clan;
                        continue;
                    }
                    else
                    {
                        clanDuplicates[member.Key] += 1;
                        if (!clanDuplicateCount.Contains(member.Key)) clanDuplicateCount.Add(member.Key);
                    }
                    clanCache[member.Key] = clan;
                }
                foreach (var invite in clan.invites)
                {
                    if (!pendingPlayerInvites.ContainsKey(invite.Key)) pendingPlayerInvites.Add(invite.Key, new List<string>());
                    pendingPlayerInvites[invite.Key].Add(clan.tag);
                }
                var reply = 5792;

                clan.total = clan.members.Count();
                clan.mods = clan.moderators.Count();
                if (clan.created == 0) clan.created = UnixTimeStampUTC();
                if (clan.updated == 0) clan.updated = UnixTimeStampUTC();
                if (!clansSearch.ContainsKey(clan.tag.ToLower())) clansSearch.Add(clan.tag.ToLower(), clan.tag);
            }
            if (clanDuplicateCount.Count > 0) PrintWarning($"Found '{clanDuplicateCount.Count()}' player(s) in multiple clans. Check `clans.showduplicates`");
            Puts($"Loaded data with '{clans.Count}' valid Clans and overall '{clanCache.Count}' Members.");
            if (newFileFound) SaveData(true);
        }
        void SaveData(bool force = false)
        {
            if (!Initialized && !force) return;
            clanSaves.clans = clans;
            clanSaves.saveStamp = UnixTimeStampUTC();
            clanSaves.lastStorage = useProtostorageClandata ? "proto" : "json";
            if (useProtostorageClandata)
                ProtoStorage.Save<StoredData>(clanSaves, new string[] { this.Title });

            else Interface.Oxide.DataFileSystem.WriteObject(this.Title, clanSaves);
        }
        public Clan findClan(string tag)
        {
            Clan clan;
            if (TryGetClan(tag, out clan)) return clan;
            return null;
        }

        public Clan findClanByUser(string userId)
        {
            Clan clan;
            if (clanCache.TryGetValue(userId, out clan)) return clan;
            return null;
        }

        private Clan SetupPlayer(BasePlayer player, IPlayer current = null, bool hasLeft = false, Clan clan = null, bool teamForced = false, string oldTag = null)
        {
            if (player == null)
                return null;

            if (current == null)
                current = covalence.Players.FindPlayerById(player.UserIDString);

            if (current == null)
                return null;

            bool prevName = false;

            if (clan == null && !hasLeft)
                clan = findClanByUser(current.Id);

            bool flag = false;
            string oldName = player.displayName;
            player.displayName = oldName;
            player._name = oldName;


            if (clan == null || hasLeft)
            {
                if (enableClanTagging && hasLeft && oldTag != null)
                {
                    string name = player.displayName.Replace($"{clanTagOpening}{oldTag}{clanTagClosing} ", "");
                    player.displayName = name;
                    player._name = string.Format("{1}[{0}/{2}]", player.net.ID, name, player.userID);
                    prevName = true;
                }

                if (useRelationshipManager)
                    flag = NullClanTeam(player);
                clan = null;
            }
            else
            {
                if (enableClanTagging)
                {
                    string name = player.displayName.Replace($"{clanTagOpening}{(oldTag != null ? oldTag : clan.tag)}{clanTagClosing} ", "");
                    name = $"{clanTagOpening}{clan.tag}{clanTagClosing} {name}";
                    player.displayName = name;
                    player._name = string.Format("{1}[{0}/{2}]", player.net.ID, name, player.userID);
                    prevName = true;
                }

                clan.AddBasePlayer(player);
            }

            if (prevName && forceNametagsOnTagging)
                player.limitNetworking = true;

            if (flag || prevName)
                player.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

            if (prevName && forceNametagsOnTagging)
                player.limitNetworking = false;

            return clan;
        }

        private bool NullClanTeam(BasePlayer player)
        {
            bool flag = false;
            if (player.currentTeam != 0UL)
            {
                RelationshipManager.PlayerTeam team = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);
                if (team == null)
                {
                    player.currentTeam = 0UL;
                    player.ClientRPCPlayer(null, player, "CLIENT_ClearTeam");
                    flag = true;
                }
            }
            else if (player.currentTeam == 0UL)
            {
                player.ClientRPCPlayer(null, player, "CLIENT_ClearTeam");
                flag = true;
            }

            return flag;
        }

        void setupPlayers(List<string> playerIds, bool remove, string tag)
        {
            if (enableClanTagging) foreach (var playerId in playerIds)
                {
                    var player = BasePlayer.Find(playerId);
                    if (player != null) SetupPlayer(player, null, remove, null, false, tag);
                }
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player == null || player.net == null || player.net.connection == null)
                return;
			var clans = findClanByUser(player.UserIDString);
            if (clans != null)
                clans.members[player.UserIDString].LastLogin = DateTime.Now;
            Clan clan = SetupPlayer(player);
            if (clan != null)
                ServerMgr.Instance.StartCoroutine(WaitForReady(player, clan));
        }

        IEnumerator WaitForReady(BasePlayer player, Clan clan = null)
        {
            yield return new WaitWhile(new System.Func<bool>(() => player.IsReceivingSnapshot && player.IsSleeping()));
            if (player.IsDead()) yield return null;
            ComingOnlineInfo(player, clan);


            yield return null;
        }
        void ComingOnlineInfo(BasePlayer player, Clan clan = null)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            if (player == null) return;
            if (clan != null)
            {
                if (enableComesOnlineMsg) clan.BroadcastLoc("comeonline", clan.ColNam(player.UserIDString, player.net.connection.username), "", "", "", player.UserIDString);
                if (enableWhoIsOnlineMsg)
                {
                    var sb = new StringBuilder();
                    sb.Append($"<color={colorTextMsg}>");
                    sb.Append(string.Format(msg("memberon", player.UserIDString)));
                    int n = 0;
                    foreach (var memberId in clan.members)
                    {
                        var op = this.covalence.Players.FindPlayerById(memberId.Key);
                        if (op != null && op.IsConnected)
                        {
                            var memberName = op.Name;
                            if (op.Name == player.net.connection.username) memberName = msg("yourname", player.UserIDString);
                            if (n > 0) sb.Append(", ");
                            if (clan.IsOwner(memberId.Key))
                            {
                                sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanOwnerColor, memberName));
                            }
                            else if (clan.IsCouncil(memberId.Key))
                            {
                                sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanCouncilColor, memberName));
                            }
                            else if (clan.IsModerator(memberId.Key))
                            {
                                sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanModeratorColor, memberName));
                            }
                            else
                            {
                                sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanMemberColor, memberName));
                            }
                            ++n;
                        }
                    }
                    sb.Append($"</color>");
                    PrintChat(player, sb.ToString().TrimEnd());
                }
                myClan.OnUpdate();
                clan.updated = UnixTimeStampUTC();
                manuallyEnabledBy.Remove(player.userID);
                if (enableClanAllies && (clan.IsOwner(player.UserIDString) || clan.IsCouncil(player.UserIDString)) && clan.pendingInvites.Count > 0)
                {
                    if (player != null) PrintChat(player, string.Format(msg("allyPendingInfo", player.UserIDString)));
                }
                return;
            }
            if (pendingPlayerInvites.ContainsKey(player.UserIDString))
            {
                foreach (var invitation in pendingPlayerInvites[player.UserIDString] as List<string>)
                {
                    Clan newclan = findClan(invitation);
                    if (newclan != null) timer.Once(3f, () =>
                    {
                        if (player != null) PrintChat(player, string.Format(msg("claninvite", player.UserIDString), newclan.tag, newclan.description, colorCmdUsage));
                    }
                     );
                }
            }
        }


        void OnPlayerDisconnected(BasePlayer player)
        {
            var memberofline = findClanByUser(player.UserIDString);
            if (memberofline != null)
            {
                memberofline.BroadcastLoc("goneoffline", memberofline.ColNam(player.UserIDString, player.net.connection.username), "", "", "", player.UserIDString);
                manuallyEnabledBy.Remove(player.userID);
                foreach (KeyValuePair<string, Clan> clan in clans)
                {
                    clan.Value.OnUpdate();
                }
            }
        }

        void OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            if (player == null || info == null || !player.IsConnected) return;

            var clan = findClanByUser(player.UserIDString);
            if (clan != null && info.InitiatorPlayer != null && clan.members.ContainsKey(player.UserIDString))
            {
                clan.ClanPoints -= PointsOfDeath;
                clan.DeathC++;
                clan.members[player.UserIDString].PlayerPoints -= PointsOfDeath;
                clan.members[player.UserIDString].Death++;
            }
        }

        void OnPlayerAttack(BasePlayer attacker, HitInfo hit)
        {
            if (!enableFFOPtion || attacker == null || hit == null || !(hit.HitEntity is BasePlayer)) return;
            OnAttackShared(attacker, hit.HitEntity as BasePlayer, hit);
        }

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hit)
        {
            try
            {
                if (entity == null || hit == null) return;
                if (entity is PatrolHelicopter && hit.Initiator is BasePlayer)
                    LastHeliHit[entity.net.ID.Value] = hit.InitiatorPlayer.userID;
                if (entity is BradleyAPC && hit.Initiator is BasePlayer)
                    LastBradleyAPCHit[entity.net.ID.Value] = hit.InitiatorPlayer.userID;

                if (!enableFFOPtion || !(entity is BasePlayer) || !(hit.Initiator is BasePlayer)) return;
                OnAttackShared(hit.Initiator as BasePlayer, entity as BasePlayer, hit);
            }
            catch (NullReferenceException)
            { }
        }
        object OnAttackShared(BasePlayer attacker, BasePlayer victim, HitInfo hit)
        {
            if (bypass.Contains(victim.userID) || attacker == victim) return null;
            var victimClan = findClanByUser(victim.UserIDString);
            var attackerClan = findClanByUser(attacker.UserIDString);
            if (victimClan == null || attackerClan == null) return null;
            if (victimClan.tag == attackerClan.tag)
            {
                if (manuallyEnabledBy.Contains(attacker.userID) && !forceClanFFNoDeactivate) return null;
                DateTime now = DateTime.UtcNow;
                DateTime time;
                var key = attacker.UserIDString + "-" + victim.UserIDString;
                if (!notificationTimes.TryGetValue(key, out time) || time < now.AddSeconds(-friendlyFireNotifyTimeout))
                {
                    PrintChat(attacker, string.Format(msg("friendlyfire", attacker.UserIDString), victim.displayName, colorCmdUsage));
                    notificationTimes[key] = now;
                }
				hit.damageTypes.ScaleAll(0);
                return false;
            }
            if (victimClan.tag != attackerClan.tag && enableClanAllies && enableAllyFFOPtion)
            {
                if (!victimClan.clanAlliances.Contains(attackerClan.tag)) return null;
                if (manuallyEnabledBy.Contains(attacker.userID) && !forceAllyFFNoDeactivate) return null;
                DateTime now = DateTime.UtcNow;
                DateTime time;
                var key = attacker.UserIDString + "-" + victim.UserIDString;
                if (!notificationTimes.TryGetValue(key, out time) || time < now.AddSeconds(-friendlyFireNotifyTimeout))
                {
                    PrintChat(attacker, string.Format(msg("allyfriendlyfire", attacker.UserIDString), victim.displayName));
                    notificationTimes[key] = now;
                }
				hit.damageTypes.ScaleAll(0);
                return false;
            }
            return null;
        }
        void AllyRemovalCheck()
        {
            foreach (var ally in clans)
            {
                try
                {
                    Clan allyClan = clans[ally.Key];
                    foreach (var clanAlliance in allyClan.clanAlliances.ToList())
                    {
                        if (!clans.ContainsKey(clanAlliance)) allyClan.clanAlliances.Remove(clanAlliance);
                    }
                    foreach (var invitedAlly in allyClan.invitedAllies.ToList())
                    {
                        if (!clans.ContainsKey(invitedAlly)) allyClan.clanAlliances.Remove(invitedAlly);
                    }
                    foreach (var pendingInvite in allyClan.pendingInvites.ToList())
                    {
                        if (!clans.ContainsKey(pendingInvite)) allyClan.clanAlliances.Remove(pendingInvite);
                    }
                }
                catch
                {
                    PrintWarning("Ally removal check failed. Please contact the developer.");
                }
            }
        }
        void cmdChatClan(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;
            if (args.Length == 0)
            {
                cmdClanOverview(player);
                return;
            }
            string opt = args[0];
            if (opt == "task")
            {
				var clan = findClanByUser(player.UserIDString);

				if (clan == null)
				{
					player.ChatMessage("Вы не состоите в клане или не являетесь лидером чтобы использовать /clan task");
					return;
				}

				if (clan.owner != player.UserIDString)
				{
					player.ChatMessage("Вы не состоите в клане или не являетесь лидером чтобы использовать /clan task");
					return;
				}

				if (args.Length < 2)
				{
					SendReply(player, $"Укажите текущую задачу для вашего клана");
					return;
				}

				var task = string.Join(" ", args.Skip(1));
				if (string.IsNullOrEmpty(task)) return;

				if (task.Length > 120)
				{
                    player.ChatMessage("Вы указали слишком длинную задачу !!");
					return;
				}

				clan.Task = task;
                player.ChatMessage($"Вы успешно установили задачу игрокам клана, сообщение: {clan.Task}");
				return;
            }
            else if (opt == "set")
            {
                plugins.Find("ClansSet")?.Call("cmdChatSet", player);
                return;
            }
            else if (opt == msg("clanArgCreate", player.UserIDString))
            {
                cmdClanCreate(player, args);
                return;
            }
            else if (opt == msg("clanArgInvite", player.UserIDString))
            {
                cmdClanInvite(player, args);
                return;
            }
            else if (opt == msg("clanArgWithdraw", player.UserIDString))
            {
                cmdClanWithdraw(player, args);
                return;
            }
            else if (opt == msg("clanArgJoin", player.UserIDString))
            {
                cmdClanJoin(player, args);
                return;
            }
            else if (opt == msg("clanArgPromote", player.UserIDString))
            {
                cmdClanPromote(player, args);
                return;
            }
            else if (opt == msg("clanArgDemote", player.UserIDString))
            {
                cmdClanDemote(player, args);
                return;
            }
            else if (opt == msg("clanArgLeave", player.UserIDString))
            {
                cmdClanLeave(player, args);
                return;
            }
            else if (opt == msg("clanArgFF", player.UserIDString))
            {
                if (!enableFFOPtion) return;
                cmdChatClanFF(player, command, args);
                return;
            }
            else if (opt == msg("clanArgAlly", player.UserIDString))
            {
                if (!enableClanAllies) return;
                for (var i = 0;
                i < args.Length - 1;
                ++i)
                {
                    if (i < args.Length) args[i] = args[i + 1];
                }
                Array.Resize(ref args, args.Length - 1);
                cmdChatClanAlly(player, command, args);
                return;
            }
            else if (opt == msg("clanArgKick", player.UserIDString))
            {
                cmdClanKick(player, args);
                return;
            }
            else if (opt == msg("clanArgDisband", player.UserIDString))
            {
                cmdClanDisband(player, args);
                return;
            }
            else cmdChatClanHelp(player, command, args);
        }

        void NewClanUI(BasePlayer player, int page = 0,bool leadermode = false)
        {
            #region [Vars]
            var elements = new CuiElementContainer();
            string colored = "0 0 0 0.5";float width = 0.998f, height = 0.09f, startxBox = 0.0025f, startyBox = 0.942f - height, xmin = startxBox, ymin = startyBox;
            var clan = findClanByUser(player.UserIDString);
            if (clan == null) return;
            #endregion

            #region [DestroyUi]
            CuiHelper.DestroyUi(player, "clans_main1");
            #endregion

            #region [Parrent]
            elements.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Material = "assets/content/ui/uibackgroundblur.mat", Color = "0 0 0 0.77" }
            }, "Overlay", "clans_main1");

            elements.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Color = "0.36 0.33 0.28 0.3", Material = "assets/icons/greyout.mat", Close = "clans_main1" }
            }, "clans_main1");
            #endregion

            #region [Main-Gui]
            elements.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-403 131", OffsetMax = "138 307" },
                Image = { Color = "0.3773585 0.3755785 0.3755785 0.3407843", Material = "assets/icons/greyout.mat" }
            }, "clans_main1", "Clanstop_mainclayer1");
            elements.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "140 131", OffsetMax = "408 307" },
                Image = { Color = "0.3773585 0.3755785 0.3755785 0.3407843", Material = "assets/icons/greyout.mat" }
            }, "clans_main1", "Clanstop_mainclayer2");
            elements.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-403 -18", OffsetMax = "408 128" },
                Image = { Color = "0.3773585 0.3755785 0.3755785 0.3407843", Material = "assets/icons/greyout.mat" }
            }, "clans_main1", "Clanstop_mainclayer3");
            elements.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-403 -305", OffsetMax = "138 -21" },
                Image = { Color = "0.3773585 0.3755785 0.3755785 0.3407843", Material = "assets/icons/greyout.mat" }
            }, "clans_main1", "Clanstop_mainclayer4");
            elements.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "140 -305", OffsetMax = "408 -21" },
                Image = { Color = "0.3773585 0.3755785 0.3755785 0.3407843", Material = "assets/icons/greyout.mat" }
            }, "clans_main1", "Clanstop_mainclayer5");
            #endregion

            #region [Avatar]
            elements.Add(new CuiElement
            {
                Parent = $"Clanstop_mainclayer1",
                Components =
                {
                    new CuiRawImageComponent { Png = (string)ImageLibrary?.Call("GetImage", clan.owner)},
                    new CuiRectTransformComponent { AnchorMin = "0.045 0.1385", AnchorMax = "0.276 0.865" }
                }
            });
            #endregion

            #region [Info]
            Dictionary<string, string> InfoClan = new Dictionary<string, string>()
            {
                { "НАЗВАНИЕ КЛАНА:", $"{clan.tag}" },
                { "ГЛАВА КЛАНА:", $"{clan.ownerName.ToUpper()}" },
                { "УЧАСТНИКОВ В ИГРЕ:", $"{clan.online} из {clan.members.Count}" },
                { "ОБЩАЯ ВЫПОЛНЕННАЯ НОРМА:", $"{GetPercentClan(clan.tag)}" },
            };
            foreach (var check in InfoClan.Select((u, t) => new { A = u, B = t }))
            {
                elements.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"{0.315 + check.B * 0 - Math.Floor((float) check.B / 1) * 1 * 0} {0.685 - Math.Floor((float) check.B/ 1) * 0.135}",
                                        AnchorMax = $"{0.955 + check.B * 0 - Math.Floor((float) check.B / 1) * 1 * 0} {0.805 - Math.Floor((float) check.B / 1) * 0.135}", },
                    Image = { Color = "0 0 0 0.25", Material = "assets/icons/greyout.mat" }
                }, "Clanstop_mainclayer1", "Clanstop_mainclayer1" + ".Info" + $".{check.B}");

                elements.Add(new CuiElement
                {
                    Parent = "Clanstop_mainclayer1" + ".Info" + $".{check.B}",
                    Components =
                    {
                        new CuiTextComponent { Text = $"{check.A.Key}", Color = "1 1 1 1", FontSize = 14, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                        new CuiRectTransformComponent { AnchorMin = $"0.01 0", AnchorMax = $"0.5 1" },
                    }
                }); 

                elements.Add(new CuiElement
                {
                    Parent = "Clanstop_mainclayer1" + ".Info" + $".{check.B}",
                    Components =
                    {
                        new CuiTextComponent { Text = $"{check.A.Value}", Color = "1 1 1 1", FontSize = 14, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleRight },
                        new CuiRectTransformComponent { AnchorMin = $"0.5 0", AnchorMax = $"0.985 1" },
                    }
                }); 
            }
            #endregion

            #region [Task]
            elements.Add(new CuiLabel
            {
                Text = { Text = "ТЕКУЩАЯ ЗАДАЧА", Align = TextAnchor.MiddleCenter, FontSize = 20, Font = "robotocondensed-bold.ttf", Color = "1 1 1 1" },
                RectTransform = { AnchorMin = $"0 0.84", AnchorMax = $"1 1" },
            }, "Clanstop_mainclayer2");
            elements.Add(new CuiElement
            {
                Name = "ClanTask",
                Parent = "Clanstop_mainclayer2",
                Components =
                    {
                        new CuiImageComponent {Color = "0 0 0 0.5"},
                        new CuiRectTransformComponent {AnchorMin = "0.08 0.088", AnchorMax = "0.9265 0.8375"}
                    }
            }); 
            elements.Add(new CuiLabel
            {
                    Text = { Text = string.IsNullOrEmpty(clan.Task) ? "Глава клана не указал\nтекущую задачу" : $"{clan.Task}", Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "robotocondensed-regular.ttf", Color = "1 1 1 1" },
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" },
            }, "ClanTask");
            #endregion

            #region [Wear]
            elements.Add(new CuiLabel
            {
                Text = { Text = "НАБОР КЛАНОВОЙ ОДЕЖДЫ", Align = TextAnchor.MiddleCenter, FontSize = 20, Font = "robotocondensed-bold.ttf", Color = "1 1 1 1" },
                RectTransform = { AnchorMin = $"0 0.815", AnchorMax = $"1 1" },
            }, "Clanstop_mainclayer3");
            foreach (var check in clan.SkinList["wear"].Select((y, t) => new { A = y, B = t }).Take(6))
            {
                elements.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"{0.036 + check.B * 0.1605 - Math.Floor((float) check.B / 6) * 6 * 0.1605} {0.105 - Math.Floor((float) check.B/ 6) * 0}",
                                        AnchorMax = $"{0.16 + check.B * 0.1605 - Math.Floor((float) check.B / 6) * 6 * 0.1605} {0.795 - Math.Floor((float) check.B / 6) * 0}", },
                    Image = { Color = "0 0 0 0.25", Material = "assets/icons/greyout.mat" }
                }, "Clanstop_mainclayer3", "Clanstop_mainclayer3" + ".Wear" + $".{check.B}");

                elements.Add(new CuiElement
                {
                    Parent = "Clanstop_mainclayer3" + ".Wear" + $".{check.B}",
                    Components =
                    {
                        new CuiImageComponent { ItemId = FindItemID(check.A.Key), SkinId = check.A.Value },
                        new CuiRectTransformComponent { AnchorMin = "0.025 0.025", AnchorMax = "0.975 0.975" }
                    }
                });
                 
                if (clan.IsOwner(player.UserIDString))
                elements.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = $"clan_itemChange" },
                    Text = { Text = ""},
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                }, "Clanstop_mainclayer3" + ".Wear" + $".{check.B}");
            }
            #endregion

            #region [PlayerInfo]
            elements.Add(new CuiPanel
            {
                Image = { Color = "0 0 0 0" },
                RectTransform = { AnchorMin = "0 0.94", AnchorMax = "0.997 0.9985" },
            }, "Clanstop_mainclayer4", "PlayerInfoPanel");
            elements.Add(new CuiLabel
            {
                Text = { Text = "#", Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "1 1 1 1", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.02 0", AnchorMax = $"1 0.8" },
            }, "PlayerInfoPanel");
            elements.Add(new CuiLabel
            {
                Text = { Text = "НИК ИГРОКА", Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "1 1 1 1", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.042 0", AnchorMax = $"1 0.8" },
            }, "PlayerInfoPanel");
            elements.Add(new CuiLabel
            {
                Text = { Text = "АКТИВНОСТЬ", Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "1 1 1 1", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.411 0", AnchorMax = $"1 0.8" },
            }, "PlayerInfoPanel");
            elements.Add(new CuiLabel
            {
                Text = { Text = "НОРМА", Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "1 1 1 1", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.67 0", AnchorMax = $"1 0.8" },
            }, "PlayerInfoPanel");
            elements.Add(new CuiLabel
            {
                Text = { Text = "ДЕЙСТВИЯ", Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "1 1 1 1", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.843 0", AnchorMax = $"1 0.8" },
            }, "PlayerInfoPanel");
            foreach (var key in clan.members.OrderBy(pair => BasePlayer.FindByID(ulong.Parse(pair.Key)) == null).Skip(8 * page).Take(clan.members.ToList().Count >= 8 ? 8 : clan.members.ToList().Count))
            {
                elements.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"{xmin} {ymin}", AnchorMax = $"{xmin + width} {ymin + height * 1}", OffsetMin = "2 1", OffsetMax = "-2 -1" },
                    Image = { Color = colored }
                }, "Clanstop_mainclayer4", "PlayerLine");

                elements.Add(new CuiLabel
                {
                    Text = { Text = "●", Color = BasePlayer.FindByID(ulong.Parse(key.Key)) != null ? "0.00 1.00 0.00 1.00" : "1.00 0.00 0.00 1.00", FontSize = 8, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                    RectTransform = { AnchorMin = $"0.016 0", AnchorMax = $"1 1" },
                }, "PlayerLine");

                elements.Add(new CuiLabel
                {
                    Text = { Text = $"{clan.GetIMember(key.Key).Name}", Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "1 1 1 0.65", Align = TextAnchor.MiddleLeft },
                    RectTransform = { AnchorMin = $"0.043 0", AnchorMax = $"1 1" },
                }, "PlayerLine");

                elements.Add(new CuiLabel
                {
                    Text = { Text = $"{FormatShortTime(TimeSpan.FromSeconds(key.Value.PlayTimeInServer))}", Color = "1 1 1 0.65", Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.MiddleLeft },
                    RectTransform = { AnchorMin = $"0.4105 0", AnchorMax = $"1 1" },
                }, "PlayerLine");

                elements.Add(new CuiLabel
                {
                    Text = { Text = $"{GetPercentPlayer(key.Key)}", Color = "1 1 1 0.65", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                    RectTransform = { AnchorMin = $"0.68 0", AnchorMax = $"0.78 1" },
                }, "PlayerLine");

                elements.Add(new CuiButton
                {
                    Button = { Color = "0.25 0.25 0.23 0", Command = $"UI_CLAN stats {key.Key}" },
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" },
                }, "PlayerLine");

                xmin += width;
                if (xmin + width >= 1)
                {
                    xmin = startxBox;
                    ymin -= height;
                }
            }
            #endregion

            #region [Buttons]
            elements.Add(new CuiButton
            {
                Button = { Color = "0.46 0.44 0.42 0.3", Material = "assets/icons/greyout.mat", Command = page > 0 ? $"clan.page {page - 1}" : "" },
                Text = { Text = "<", Color = "1 1 1 1", FontSize = 22, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0.01 0.015", AnchorMax = $"0.08 0.125" },
            }, "Clanstop_mainclayer4");
            elements.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.085 0.015", AnchorMax = $"0.165 0.125" },
                Image = { Color = "0 0 0 0.4", Material = "assets/icons/greyout.mat" }
            }, "Clanstop_mainclayer4", "clans_pagetext");
            elements.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" },
                Text = { Text = $"{page + 1}", Color = "1 1 1 1", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter }
            }, "clans_pagetext");
            elements.Add(new CuiButton
            {
                Button = { Color = "0.46 0.44 0.42 0.3", Material = "assets/icons/greyout.mat", Command = clan.members.Skip(8 * (page + 1)).Count() > 0 ? $"clan.page {page + 1}" : "" },
                Text = { Text = ">", Color = "1 1 1 1", FontSize = 22, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0.17 0.015", AnchorMax = $"0.243 0.125" },
            }, "Clanstop_mainclayer4");
            #endregion

            #region [Resourse]
            elements.Add(new CuiLabel
            {
                Text = { Text = "ДОБЫЧА РЕСУРСОВ", Align = TextAnchor.MiddleCenter, FontSize = 20, Font = "robotocondensed-bold.ttf", Color = "1 1 1 1" },
                RectTransform = { AnchorMin = $"0 0.9", AnchorMax = $"1 1" },
            }, "Clanstop_mainclayer5");

            foreach (var check in clan.Change.Select((y, t) => new { A = y, B = t }).Take(9))
            {
                elements.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"{0.075 + check.B * 0.28 - Math.Floor((float) check.B / 3) * 3 * 0.28} {0.618 - Math.Floor((float) check.B/ 3) * 0.26}",
                                        AnchorMax = $"{0.355 + check.B * 0.28 - Math.Floor((float) check.B / 3) * 3 * 0.28} {0.88 - Math.Floor((float) check.B / 3) * 0.26}", },
                    Image = { Color = "0 0 0 0.25", Material = "assets/icons/greyout.mat" }
                }, "Clanstop_mainclayer5", "Clanstop_mainclayer5" + ".Resourse" + $".{check.B}");

                if (FindItemID(check.A.Key) != 0)
                {
                    elements.Add(new CuiElement
                    {
                        Parent = "Clanstop_mainclayer5" + ".Resourse" + $".{check.B}",
                        Components =
                        {
                            new CuiImageComponent { ItemId = FindItemID(check.A.Key), SkinId = 0 },
                            new CuiRectTransformComponent {AnchorMin = "0.025 0.025", AnchorMax = "0.975 0.975"}
                        }
                    });
                }
                else
                {
                    elements.Add(new CuiElement
                    {
                        Parent = "Clanstop_mainclayer5" + ".Resourse" + $".{check.B}",
                        Components =
                        {
                            new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", check.A.Key) },
                            new CuiRectTransformComponent {AnchorMin = "0.05 0.05", AnchorMax = "0.95 0.95"}
                        }
                    });
                }

                elements.Add(new CuiElement
                {
                    Parent = "Clanstop_mainclayer5" + ".Resourse" + $".{check.B}",
                    Components =
                    {
                        new CuiTextComponent { Text = $"{GetPercent(check.A.Value.Need, check.A.Value.Complete)}", Color = "1 1 1 1", Align = TextAnchor.MiddleRight, FontSize = 10, Font = "robotocondensed-regular.ttf" },
                        new CuiRectTransformComponent { AnchorMin = $"0 0.78", AnchorMax = $"0.95 1" },
                    }
                });

                elements.Add(new CuiElement
                {
                    Parent = "Clanstop_mainclayer5" + ".Resourse" + $".{check.B}",
                    Components =
                    {
                        new CuiTextComponent { Text = $"{check.A.Value.Complete}", Color = "1 1 1 1", Align = TextAnchor.MiddleRight, FontSize = 12, Font = "robotocondensed-regular.ttf" },
                        new CuiRectTransformComponent { AnchorMin = $"0 0", AnchorMax = $"0.95 0.25" },
                    }
                });

                elements.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = $"clan_ResChange" },
                    Text = { Text = ""},
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                }, "Clanstop_mainclayer5" + ".Resourse" + $".{check.B}");
            }
            #endregion

            CuiHelper.AddUi(player, elements);
        }

        #region [Math]
        public string GetPercentClan(string tag)
        {
            var clan = findClan(tag);
            var need = clan.Change.Sum(x => x.Value.Need);
            var current = clan.Change.Sum(x => x.Value.Complete);
            if (need == 0 && current == 0)
                return $"NaN%";
            if (need == 0 && current > 0)
                return $"Infinity%";
            if (need > 0 && current > 0 || need > 0 && current == 0)
                return $"{current * 100 / need}%";
            return "";
        }

        public string GetPercentPlayer(string userid)
        {
            var clan = findClanByUser(userid);
            var need = clan.Change.Sum(x => x.Value.Need);
            var current = clan.members[userid].GatherInfo.Sum(p => p.Value);
            if (need == 0 && current == 0)
                return $"NaN%";
            if (need == 0 && current > 0)
                return $"Infinity%";
            if (need > 0 && current > 0 || need > 0 && current == 0)
                return $"{current * 100 / need}%";
            return "";
        }

        public string GetPercent(int need, int current)
        {
            if (need == 0 && current == 0)
                return $"NaN%";
            if (need == 0 && current > 0)
                return $"Infinity%";
            if (need > 0 && current > 0 || need > 0 && current == 0)
                return $"{current * 100 / need}%";
            return "";
        }
        #endregion

        [ConsoleCommand("clan_ResChange")]
        void cmdResChangeOfClan(ConsoleSystem.Arg args)
        {
            #region [Vars]
            var player = args.Player();
            var clan = findClanByUser(player.UserIDString);
            var elements = new CuiElementContainer();
            #endregion

            #region [Destroy-Ui]
            CuiHelper.DestroyUi(player, "clan_resoursechangemainlayer");
            #endregion

            #region [Parrent]
            elements.Add(new CuiPanel
            {
                Image = { Material = "assets/content/ui/uibackgroundblur.mat", Color = "0 0 0 0.77" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                CursorEnabled = true,
            }, "Overlay", "clan_resoursechangemainlayer");

            elements.Add(new CuiButton
            {
                Button = { Color = "0.36 0.33 0.28 0.3", Material = "assets/icons/greyout.mat", Command = "UI_CLAN closerespage" },
                Text = { Text = "" },
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" },
            }, "clan_resoursechangemainlayer");
            #endregion

            #region [Main-Gui]
			elements.Add(new CuiElement
			{
				Name = "MainLayerSkinLayer",
				Parent = "clan_resoursechangemainlayer",
				Components =
                {
                    new CuiImageComponent { Color = "0.3773585 0.3755785 0.3755785 0.3607843", Material = "assets/icons/greyout.mat" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-160 -149", OffsetMax = "401 151"}
                }
			});

			elements.Add(new CuiElement
			{
				Name = "MainLayerItemChange",
				Parent = "clan_resoursechangemainlayer",
				Components =
                {
                    new CuiImageComponent { Color = "0.3773585 0.3755785 0.3755785 0.3607843", Material = "assets/icons/greyout.mat" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-400 -149", OffsetMax = "-170 151"}
                }
			});
            #endregion

            #region [Text]
            elements.Add(new CuiElement
            {
                Name = "MainLayerText",
                Parent = $"MainLayerSkinLayer",
                Components =
                {
                    new CuiTextComponent { Text = $"ВЫБЕРИТЕ РЕСУРСЫ", Color = "1 1 1 0.65", FontSize = 24, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter},
                    new CuiRectTransformComponent { AnchorMin = "0 0.9", AnchorMax = "1 1" },
                }
            });

            elements.Add(new CuiElement
            {
                Parent = $"MainLayerItemChange",
                Components =
                {
                    new CuiTextComponent { Text = $"ВЫБРАННЫЕ РЕСУРСЫ", Color = "1 1 1 0.65", FontSize = 20, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft},
                    new CuiRectTransformComponent { AnchorMin = "0.09 0.9", AnchorMax = "1 1" },
                }
            });
            #endregion

            #region [Resourse-Buttons]
            foreach (var check in clan.Change.Select((i, t) => new { A = i, B = t }))
            {
                elements.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"{0.02 + check.B * 0.143 - Math.Floor((float) check.B / 7) * 7 * 0.143} {0.7 - Math.Floor((float) check.B/ 7) * 0.22}",
                                        AnchorMax = $"{0.125 + check.B * 0.143 - Math.Floor((float) check.B / 7) * 7 * 0.143} {0.895 - Math.Floor((float) check.B / 7) * 0.22}", },
                    Image = { Color = "0 0 0 0.25", Material = "assets/icons/greyout.mat" }
                }, "MainLayerSkinLayer", "MainLayerSkinLayer" + ".BResourse" + $".{check.B}");

                if (FindItemID(check.A.Key) != 0)
                {
                    elements.Add(new CuiElement
                    {
                        Parent = "MainLayerSkinLayer" + ".BResourse" + $".{check.B}",
                        Components =
                        {
                            new CuiImageComponent { ItemId = FindItemID(check.A.Key), SkinId = 0 },
                            new CuiRectTransformComponent {AnchorMin = "0.025 0.025", AnchorMax = "0.975 0.975"}
                        }
                    });
                }
                else
                {
                    elements.Add(new CuiElement
                    {
                        Parent = "MainLayerSkinLayer" + ".BResourse" + $".{check.B}",
                        Components =
                        {
                            new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", check.A.Key) },
                            new CuiRectTransformComponent {AnchorMin = "0.025 0.025", AnchorMax = "0.975 0.975"}
                        }
                    });
                }
 
                if (clan.IsOwner(player.UserIDString) || clan.IsModerator(player.UserIDString))
                elements.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = $"UI_RES {check.A.Key}" },
                    Text = { Text = "" },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                }, "MainLayerSkinLayer" + ".BResourse" + $".{check.B}");
            }
            #endregion

            #region [Resourse-Need]
            foreach (var check in clan.Change.Select((i, t) => new { A = i, B = t }))
            {
                elements.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"{0.085 + check.B * 0.31 - Math.Floor((float) check.B / 3) * 3 * 0.31} {0.7 - Math.Floor((float) check.B/ 3) * 0.3}",
                                        AnchorMax = $"{0.335 + check.B * 0.31 - Math.Floor((float) check.B / 3) * 3 * 0.31} {0.895 - Math.Floor((float) check.B / 3) * 0.3}", },
                    Image = { Color = "0 0 0 0.25", Material = "assets/icons/greyout.mat" }
                }, "MainLayerItemChange", "MainLayerItemChange" + ".Resourse" + $".{check.B}");

                if (FindItemID(check.A.Key) != 0)
                {
                    elements.Add(new CuiElement
                    {
                        Parent = "MainLayerItemChange" + ".Resourse" + $".{check.B}",
                        Components =
                        {
                            new CuiImageComponent { ItemId = FindItemID(check.A.Key), SkinId = 0 },
                            new CuiRectTransformComponent {AnchorMin = "0.025 0.025", AnchorMax = "0.975 0.975"}
                        }
                    });
                }
                else
                {
                    elements.Add(new CuiElement
                    {
                        Parent = "MainLayerItemChange" + ".Resourse" + $".{check.B}",
                        Components =
                        {
                            new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", check.A.Key) },
                            new CuiRectTransformComponent {AnchorMin = "0.025 0.025", AnchorMax = "0.975 0.975"}
                        }
                    });
                }

                elements.Add(new CuiElement
                {
                    Parent = "MainLayerItemChange" + ".Resourse" + $".{check.B}",
                    Components =
                    {
                        new CuiTextComponent { Text = $"x{check.A.Value.Need}", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-regular.ttf" },
                        new CuiRectTransformComponent { AnchorMin = $"0 -0.3", AnchorMax = $"1 0" },
                    }
                });
            }
            #endregion

            CuiHelper.AddUi(player, elements);
        }

        [ConsoleCommand("clan_itemChange")]
        void cmdItemChangeOfClan(ConsoleSystem.Arg args)
        {
            #region [Vars]
            var player = args.Player();
            var clan = findClanByUser(player.UserIDString);
            var elements = new CuiElementContainer();
            #endregion

            #region [Destroy-Ui]
            CuiHelper.DestroyUi(player, "clan_itemchangemainlayer");
            CuiHelper.DestroyUi(player, "MainSkinLayerMain");
            #endregion

            #region [Parrent]
            elements.Add(new CuiPanel
            {
                Image = { Material = "assets/content/ui/uibackgroundblur.mat", Color = "0 0 0 0.77" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                CursorEnabled = true,
            }, "Overlay", "clan_itemchangemainlayer");

            elements.Add(new CuiButton
            {
                Button = { Color = "0.36 0.33 0.28 0.3", Material = "assets/icons/greyout.mat", Command = "UI_CLAN closeskinpage" },
                Text = { Text = "" },
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" },
            }, "clan_itemchangemainlayer");
            #endregion

            #region [Main-Gui]
			elements.Add(new CuiElement
			{
				Name = "MainLayerItemChange",
				Parent = "clan_itemchangemainlayer",
				Components =
                {
                    new CuiImageComponent { Color = "0.3773585 0.3755785 0.3755785 0.3607843", Material = "assets/icons/greyout.mat" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-412 0", OffsetMax = "-173 181"}
                }
			});
			elements.Add(new CuiElement
			{
				Name = "MainLayerSkinLayer",
				Parent = "clan_itemchangemainlayer",
				Components =
                {
                    new CuiImageComponent { Color = "0.3773585 0.3755785 0.3755785 0.3607843", Material = "assets/icons/greyout.mat" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-151 -130", OffsetMax = "410 181"}
                }
			});
            #endregion

            #region [Text]
            elements.Add(new CuiElement
            {
                Name = "MainLayerText",
                Parent = $"MainLayerSkinLayer",
                Components =
                {
                    new CuiTextComponent { Text = $"ВЫБЕРИТЕ ПРЕДМЕТ ДЛЯ ВЫБОРА СКИНА", Color = "1 1 1 0.65", FontSize = 22, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter},
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" },
                }
            });

            elements.Add(new CuiElement
            {
                Parent = $"MainLayerItemChange",
                Components =
                {
                    new CuiTextComponent { Text = $"ВЫБРАННЫЕ СКИНЫ", Color = "1 1 1 0.65", FontSize = 20, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter},
                    new CuiRectTransformComponent { AnchorMin = "0 0.825", AnchorMax = "1 1" },
                }
            });
            #endregion

            #region [Wear]
            foreach (var check in clan.SkinList["wear"].Select((y, t) => new { A = y, B = t }).Take(6))
            {
                elements.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"{0.075 + check.B * 0.3 - Math.Floor((float) check.B / 3) * 3 * 0.3} {0.487 - Math.Floor((float) check.B/ 3) * 0.4}",
                                        AnchorMax = $"{0.325 + check.B * 0.3 - Math.Floor((float) check.B / 3) * 3 * 0.3} {0.8125 - Math.Floor((float) check.B / 3) * 0.4}", },
                    Image = { Color = "0 0 0 0.25", Material = "assets/icons/greyout.mat" }
                }, "MainLayerItemChange", "MainLayerItemChange" + ".Wear" + $".{check.B}");

                elements.Add(new CuiElement
                {
                    Parent = "MainLayerItemChange" + ".Wear" + $".{check.B}",
                    Components =
                    {
                        new CuiImageComponent { ItemId = FindItemID(check.A.Key), SkinId = check.A.Value },
                        new CuiRectTransformComponent { AnchorMin = "0.025 0.025", AnchorMax = "0.975 0.975" }
                    }
                });

                elements.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = $"UI_CLAN editskin {check.A.Key} 0" },
                    Text = { Text = ""},
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                }, "MainLayerItemChange" + ".Wear" + $".{check.B}");
            }
            #endregion

            CuiHelper.AddUi(player, elements);
        }

        [ConsoleCommand("UI_CLAN")]
        void cmdUIClan(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player == null) return;
            if (!args.HasArgs()) return;
            var clan = findClanByUser(player.UserIDString);
            switch (args.Args[0])
            {
                case "stats":
                    var playerStats = clan.GetPlayerStats(args.Args[1]);
                    if (playerStats == null) return;
                    CuiHelper.DestroyUi(player, "clans_main1");
                    CreatePlayerInfo(player, clan, playerStats, args.Args[1]);
                    break;
                case "editskin":
                    if (!args.HasArgs(2)) return;

                    var page = 0;
                    if (args.HasArgs(3))
                        int.TryParse(args.Args[2], out page);

                    SelectSkinUi(player, args.Args[1], page);
                    break;
                case "closeplayerinfo":
                    CuiHelper.DestroyUi(player, "UICLAN_stats");
                    NewClanUI(player, 0);
                    break;
                case "closeskinpage":
                    CuiHelper.DestroyUi(player, "clan_itemchangemainlayer");
                    NewClanUI(player, 0);
                    break;
                case "closerespage":
                    CuiHelper.DestroyUi(player, "clan_resoursechangemainlayer");
                    NewClanUI(player, 0);
                    break;
            }
        }

        [ConsoleCommand("clanstop_info")]
        void cmdClansTopKey(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            var clan = findClan(arg.Args[0]);
            if (clan != null)
            {
                ClanTOPInfo(player, clan, arg.Args.Length > 1 ? int.Parse(arg.Args[1]) : 0);
            }
        }

        [ConsoleCommand("clanstop_main")]
        void cmdClansTopMain(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            ClanTOP(player, arg.Args != null ? int.Parse(arg.Args[0]) : 0);
        }

        [ConsoleCommand("clan.page")]
        void cmdClanSetPage(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            NewClanUI(player, arg.Args != null ? int.Parse(arg.Args[0]) : 0);
        }

        void CreatePlayerInfo(BasePlayer player, Clan clan, PlayerStats stats, string userID)
        {
            #region [Vars]
            CuiElementContainer container = new CuiElementContainer();
            #endregion

            #region [Parrent]
            container.Add(new CuiPanel
            {
                Image = { Material = "assets/content/ui/uibackgroundblur.mat", Color = "0 0 0 0.77" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                CursorEnabled = true,
            }, "Overlay", "UICLAN_stats");

            container.Add(new CuiButton
            {
                Button = { Color = "0.36 0.33 0.28 0.3", Material = "assets/icons/greyout.mat", Command = "UI_CLAN closeplayerinfo" },
                Text = { Text = "" },
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" },
            }, "UICLAN_stats");
            #endregion

            #region [Main-Gui]
            container.Add(new CuiElement
            {
                Name = "UICLAN_PlayerStats",
                Parent = "UICLAN_stats",
                Components =
                    {
                        new CuiImageComponent { Color = "0.3773585 0.3755785 0.3755785 0.3607843", Material = "assets/icons/greyout.mat" },
                        new CuiRectTransformComponent {AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-380 -120.5", OffsetMax = "127 115"}
                    }
            });

            container.Add(new CuiElement
            {
                Name = "UICLAN_PlayerStats2",
                Parent = "UICLAN_stats",
                Components =
                    {
                        new CuiImageComponent { Color = "0.3773585 0.3755785 0.3755785 0.3607843", Material = "assets/icons/greyout.mat" },
                        new CuiRectTransformComponent {AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "130 -120.5", OffsetMax = "352 115"}
                    }
            });
            #endregion

            #region [Text]
            container.Add(new CuiElement
            {
                Parent = "UICLAN_PlayerStats2",
                Components =
                    {
                        new CuiTextComponent { Text = $"ДОБЫЧА РЕСУРСОВ", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 20},
                        new CuiRectTransformComponent { AnchorMin = "0 0.885", AnchorMax = "1 1" },
                    }
            });
            #endregion

            #region [Resourse]
            foreach (var check in stats.GatherInfo.Select((y, t) => new { A = y, B = t }).Take(9))
            {
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"{0.0825 + check.B * 0.285 - Math.Floor((float) check.B / 3) * 3 * 0.285} {0.60 - Math.Floor((float) check.B/ 3) * 0.27}",
                                        AnchorMax = $"{0.365 + check.B * 0.285 - Math.Floor((float) check.B / 3) * 3 * 0.285} {0.87 - Math.Floor((float) check.B / 3) * 0.27}", },
                    Image = { Color = "0 0 0 0.25", Material = "assets/icons/greyout.mat" }
                }, "UICLAN_PlayerStats2", "UICLAN_PlayerStats2" + ".Resourse" + $".{check.B}");

                if (FindItemID(check.A.Key) != 0)
                {
                    container.Add(new CuiElement
                    {
                        Parent = "UICLAN_PlayerStats2" + ".Resourse" + $".{check.B}",
                        Components =
                        {
                            new CuiImageComponent { ItemId = FindItemID(check.A.Key), SkinId = 0 },
                            new CuiRectTransformComponent {AnchorMin = "0.025 0.025", AnchorMax = "0.975 0.975"}
                        }
                    });
                }
                else
                {
                    container.Add(new CuiElement
                    {
                        Parent = "UICLAN_PlayerStats2" + ".Resourse" + $".{check.B}",
                        Components =
                        {
                            new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", check.A.Key) },
                            new CuiRectTransformComponent {AnchorMin = "0.05 0.05", AnchorMax = "0.95 0.95"}
                        }
                    });
                }

                container.Add(new CuiElement
                {
                    Parent = "UICLAN_PlayerStats2" + ".Resourse" + $".{check.B}",
                    Components =
                    {
                        new CuiTextComponent { Text = $"{clan.Change[check.A.Key].Need}", Color = "1 1 1 1", Align = TextAnchor.MiddleRight, FontSize = 10, Font = "robotocondensed-regular.ttf" },
                        new CuiRectTransformComponent { AnchorMin = $"0 0.735", AnchorMax = $"0.95 1" },
                    }
                });

                container.Add(new CuiElement
                {
                    Parent = "UICLAN_PlayerStats2" + ".Resourse" + $".{check.B}",
                    Components =
                    {
                        new CuiTextComponent { Text = $"{check.A.Value.ToString("N3", CultureInfo.GetCultureInfo("ru-RU")).Replace(",000", "")}", Color = "1 1 1 1", Align = TextAnchor.MiddleRight, FontSize = 10, Font = "robotocondensed-regular.ttf" },
                        new CuiRectTransformComponent { AnchorMin = $"0 0", AnchorMax = $"0.95 0.25" },
                    }
                });
            }
            #endregion

            #region [Avatar]
            container.Add(new CuiElement
            {
                Parent = "UICLAN_PlayerStats",
                Components =
                    {
                        new CuiRawImageComponent { Color = "1 1 1 1", Png = (string)ImageLibrary?.Call("GetImage", userID)},
                        new CuiRectTransformComponent{ AnchorMin = "0.045 0.3525", AnchorMax =  "0.3 0.9" },
                    }
            });
            #endregion
 
            #region [Info]
            Dictionary<string, string> StatsInfo = new Dictionary<string, string>()
            {
                { "НИК ИГРОКА:", $"{clan.GetIMember(userID).Name.ToUpper()}" },
                { "СТИМ ИГРОКА:", $"{clan.GetIMember(userID).Id}" },
                { "АКТИВНОСТЬ:", $"{FormatShortTime(TimeSpan.FromSeconds(stats.PlayTimeInServer))}" },
                { "ОБЩАЯ ВЫПОЛНЕННАЯ НОРМА:", $"{GetPercentPlayer(clan.GetIMember(userID).Id)}" },
            };

            foreach (var check in StatsInfo.Select((u, t) => new { A = u, B = t }))
            {
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"{0.35 + check.B * 0 - Math.Floor((float) check.B / 1) * 1 * 0} {0.765 - Math.Floor((float) check.B/ 1) * 0.1}",
                                        AnchorMax = $"{0.955 + check.B * 0 - Math.Floor((float) check.B / 1) * 1 * 0} {0.8525 - Math.Floor((float) check.B / 1) * 0.1}", },
                    Image = { Color = "0 0 0 0.25", Material = "assets/icons/greyout.mat" }
                }, "UICLAN_PlayerStats", "UICLAN_PlayerStats" + ".Info" + $".{check.B}");

                container.Add(new CuiElement
                {
                    Parent = "UICLAN_PlayerStats" + ".Info" + $".{check.B}",
                    Components =
                    {
                        new CuiTextComponent { Text = $"{check.A.Key}", Color = "1 1 1 0.8", Align = TextAnchor.MiddleLeft, FontSize = 14, Font = "robotocondensed-regular.ttf" },
                        new CuiRectTransformComponent { AnchorMin = $"0.01 0", AnchorMax = $"0.85 1" },
                    }
                }); 

                container.Add(new CuiElement
                {
                    Parent = "UICLAN_PlayerStats" + ".Info" + $".{check.B}",
                    Components =
                    {
                        new CuiTextComponent { Text = $"{check.A.Value}", Color = "1 1 1 0.8", Align = TextAnchor.MiddleRight, FontSize = 14, Font = "robotocondensed-regular.ttf" },
                        new CuiRectTransformComponent { AnchorMin = $"0 0", AnchorMax = $"0.985 1" },
                    }
                }); 
            }
            #endregion

            #region [Button]
            container.Add(new CuiButton
            {
                Button = { Color = "0 0 0 0.5", Material = "assets/icons/greyout.mat", Command = clan.owner != userID ? $"clan_kickplayer {userID}" : ""},
                Text = { Text = "ВЫГНАТЬ ИЗ КЛАНА", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 15, Color = "1 1 1 1" },
                RectTransform = { AnchorMin = $"0.045 0.1065", AnchorMax = $"0.34 0.245" },
            }, "UICLAN_PlayerStats");

            container.Add(new CuiButton
            {
                Button = { Color = "0 0 0 0.5", Material = "assets/icons/greyout.mat", Command = clan.moderators.Contains(userID) ? $"clanui_promote demote {userID}" : $"clanui_promote promote {userID}" },
                Text = { Text = clan.moderators.Contains(userID) ? "ЗАБРАТЬ МОДЕРА" : "ВЫДАТЬ МОДЕРА", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 15, Color = "1 1 1 1" },
                RectTransform = { AnchorMin = $"0.35 0.1065", AnchorMax = $"0.645 0.245" },
            }, "UICLAN_PlayerStats");

            container.Add(new CuiButton
            {
                Button = { Color = "0 0 0 0.5", Material = "assets/icons/greyout.mat", Command = $"clanui_leader {userID}"},
                Text = { Text = "НАЗНАЧИТЬ ГЛАВОЙ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 15, Color = "1 1 1 1" },
                RectTransform = { AnchorMin = $"0.655 0.1065", AnchorMax = $"0.95 0.245" },
            }, "UICLAN_PlayerStats");
            #endregion

            CuiHelper.DestroyUi(player, "UICLAN_stats");
            CuiHelper.AddUi(player, container);
        }

        void cmdClanOverview(BasePlayer player)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            var sb = new StringBuilder();

            string Messages = pluginPrefixREBORNShow == true ? $"<size=14><color={pluginPrefixREBORNColor}>\n</color></size>" : "\n";
            sb.Append($"<size=18><color={pluginPrefixColor}>{this.Title}</color></size>{Messages}");

            if (myClan == null)
            {
                player.ChatMessage($"<size=20>Доступные команды:</size>\n<color=#ffde5a>/clan</color> - открыть меню клана\n<color=#ffde5a>/clan create</color> - создать клан\n<color=#ffde5a>/clan disband</color> - распустить клан\n<color=#ffde5a>/clan leave</color> - покинуть клан\n<color=#ffde5a>/clan invite</color> - пригласить в клан\n<color=#ffde5a>/clan task</color> - установить задачу для клана\n<color=#ffde5a>/clan set</color> - установить скины для клана\n<color=#ffde5a>/clan ff</color> - переключение френдли файера\n<color=#ffde5a>/clan help</color> - справка");
                return;
            }
            NewClanUI(player, 0);
        }
        void cmdClanCreate(BasePlayer player, string[] args)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            if (myClan != null)
            {
                player.ChatMessage("У вас уже есть <color=#ffde5a>клан</color>!");
                return;
            }
            if (usePermToCreateClan && !permission.UserHasPermission(current.Id, permissionToCreateClan))
            {
                PrintChat(player, msg("nopermtocreate", current.Id));
                return;
            }
            if (args.Length < 2)
            {
                player.ChatMessage($"Введите  <color=#ffde5a>/clan create ClanName</color> - где <color=#ffde5a>ClanName</color> - названия клана\nИмя клана не может быть более {tagLengthMax} символов.");
                return;
            }
            if (args[1].Length < tagLengthMin || args[1].Length > tagLengthMax)
            {
                player.ChatMessage($"Имя клана не может быть более <color=#ffde5a>{tagLengthMax}</color> символов.");
                return;
            }
            if (args.Length > 2)
            {
                args[2] = args[2].Trim();
                if (args[2].Length < 2 || args[2].Length > 30)
                {
                    player.ChatMessage($"Введите  <color=#ffde5a>/clan create ClanName</color> - где <color=#ffde5a>ClanName</color> - названия клана\nИмя клана не может быть более {tagLengthMax} символов.");
                    return;
                }
            }
            if (enableWordFilter && FilterText(args[1]))
            {
                player.ChatMessage("Данное название для клана имеет запрещенные слова!");
                return;
            }
            string[] clanKeys = clans.Keys.ToArray();
            clanKeys = clanKeys.Select(c => c.ToLower()).ToArray();
            if (clanKeys.Contains(args[1].ToLower()))
            {
                player.ChatMessage("Клан с таким именем <color=#ffde5a>уже</color> существует");
                return;
            }
            myClan = Clan.Create(args[1], args.Length > 2 ? args[2] : string.Empty, current.Id, current.Name, "https://www.guilded.gg/asset/GameIcons/Rust-lg.png");
            clans.Add(myClan.tag, myClan);
            clanCache[current.Id] = myClan;

            SetupPlayer(player, current, clan: myClan);
            myClan.AddBasePlayer(player);

            if (usePermGroups && !permission.GroupExists(permGroupPrefix + myClan.tag)) permission.CreateGroup(permGroupPrefix + myClan.tag, "Clan " + myClan.tag, 0);
            if (usePermGroups && !permission.UserHasGroup(current.Id, permGroupPrefix + myClan.tag)) permission.AddUserGroup(current.Id, permGroupPrefix + myClan.tag);
            myClan.OnCreate();
            myClan.total++;
            player.ChatMessage($"Вы успешно создали клан <color=#ffde5a>{myClan.tag}</color>.");
            return;
        }
        public void InvitePlayer(BasePlayer player, string targetId) => cmdClanInvite(player, new string[] { "", targetId } );

		private Dictionary<string, int> _itemIds = new Dictionary<string, int>();

		private int FindItemID(string shortName)
		{
			int val;
			if (_itemIds.TryGetValue(shortName, out val))
				return val;

			var definition = ItemManager.FindItemDefinition(shortName);
			if (definition == null) return 0;

			val = definition.itemid;
			_itemIds[shortName] = val;
			return val;
		}

        void cmdClanInvite(BasePlayer player, string[] args)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            if (myClan == null)
            {
                player.ChatMessage("У вас <color=red>нет</color> клана");
                return;
            }
            if (args.Length < 2)
            {
                PrintChat(player, string.Format(msg("usageinvite", current.Id), colorCmdUsage));
                return;
            }
            if (!myClan.IsOwner(current.Id) && !myClan.IsCouncil(current.Id) && !myClan.IsModerator(current.Id))
            {
                PrintChat(player, string.Format(msg("notmoderator", current.Id)));
                return;
            }
            var invPlayer = myClan.GetIPlayer(args[1]);
            if (invPlayer == null)
            {
                PrintChat(player, string.Format(msg("nosuchplayer", current.Id), args[1]));
                return;
            }
            if (myClan.members.ContainsKey(invPlayer.Id))
            {
                PrintChat(player, string.Format(msg("alreadymember", current.Id), invPlayer.Name));
                return;
            }
            if (myClan.invites.ContainsKey(invPlayer.Id))
            {
                PrintChat(player, string.Format(msg("alreadyinvited", current.Id), invPlayer.Name));
                return;
            }
            if (findClanByUser(invPlayer.Id) != null)
            {
                PrintChat(player, string.Format(msg("alreadyinclan", current.Id), invPlayer.Name));
                return;
            }
            if (usePermToJoinClan && !permission.UserHasPermission(invPlayer.Id, permissionToJoinClan))
            {
                PrintChat(player, string.Format(msg("nopermtojoinbyinvite", current.Id), invPlayer.Name));
                return;
            }
            myClan.invites.Add(invPlayer.Id, UnixTimeStampUTC());
            if (!pendingPlayerInvites.ContainsKey(invPlayer.Id)) pendingPlayerInvites.Add(invPlayer.Id, new List<string>());
            pendingPlayerInvites[invPlayer.Id].Add(myClan.tag);
            myClan.BroadcastLoc($"{myClan.ColNam(current.Id, current.Name)} пригласил игрока {myClan.ColNam(invPlayer.Id, invPlayer.Name)} в клан.");
            if (invPlayer.IsConnected)
            {
                var invited = rust.FindPlayerByIdString(invPlayer.Id);
                if (invited != null) PrintChat(invited, string.Format(msg("claninvite", invPlayer.Id), myClan.tag, myClan.description, colorCmdUsage));
                InterfaceUI(invited, myClan.tag);
            }
            myClan.updated = UnixTimeStampUTC();
        }

        private string GetImageUrl(string shortname, ulong skinid) => ImageLibrary.CallHook("GetImageURL", shortname, skinid) as string;
        private void AddLoadOrder(IDictionary<string, string> imageList, bool replace = false) => ImageLibrary?.Call("ImportImageList", Title, imageList, (ulong)ResourceId, replace);

		private void OnPlayerRespawned(BasePlayer player)
		{
				var items = player.inventory.AllItems();
                var clan = findClanByUser(player.UserIDString);
			if (clan != null)
            {
				timer.Once(3, () => 
				{
					foreach(Item item in items)
						if(clan.SkinList["wear"].ContainsKey(item.info.shortname))
                        {
                            item.skin = clan.SkinList["wear"][item.info.shortname];
			                item.MarkDirty();

			                var heldEntity = item.GetHeldEntity();
			                if (heldEntity == null) return;

			                heldEntity.skinID = item.skin;
			                heldEntity.SendNetworkUpdate();
                        }
				});
            }
		}

        private void OnActiveItemChanged(BasePlayer player, Item oldItem, Item item)
        {
            if (player == null || item == null) return;
            var clan = findClanByUser(player.UserIDString);
            if (clan != null)
            {
                if (item.skin != 0) return;
                if (clan.SkinList["wear"].ContainsKey(item.info.shortname) && item.skin != clan.SkinList["wear"][item.info.shortname] && item.skin == 0)
                {
                    item.skin = clan.SkinList["wear"][item.info.shortname];
                    item.MarkDirty();

                    var heldEntity = item.GetHeldEntity();
                    if (heldEntity == null) return;

                    heldEntity.skinID = item.skin;
                    heldEntity.SendNetworkUpdate();
                }
            }
        }

        private bool? CanEquipItem(PlayerInventory inventory, Item item, int targetPos)
        {
            if (inventory == null || item == null) return null;
            var player = inventory.gameObject.ToBaseEntity() as BasePlayer;
            if (player == null) return null;
            var clan = findClanByUser(player.UserIDString);
            if (clan != null)
            {
                if (item.skin != 0) return null;
                if (clan.SkinList["wear"].ContainsKey(item.info.shortname) && item.skin != clan.SkinList["wear"][item.info.shortname])
                {
                    item.skin = clan.SkinList["wear"][item.info.shortname];
                    item.MarkDirty();

                    var heldEntity = item.GetHeldEntity();
                    if (heldEntity == null) return null;

                    heldEntity.skinID = item.skin;
                    heldEntity.SendNetworkUpdate();
                }
            }
            return null;
        }

        bool? CanWearItem(PlayerInventory inventory, Item item, int targetPos)
        {
            if (inventory == null || item == null) return null;
            var player = inventory.gameObject.ToBaseEntity() as BasePlayer;
            if (player == null) return null;
            var clan = findClanByUser(player.UserIDString);
            if (clan != null)
            {
                if (clan.SkinList["wear"].ContainsKey(item.info.shortname) && item.skin != clan.SkinList["wear"][item.info.shortname])
                {
                    item.skin = clan.SkinList["wear"][item.info.shortname];
			        item.MarkDirty();

			        var heldEntity = item.GetHeldEntity();
			        if (heldEntity == null) return null;

			        heldEntity.skinID = item.skin;
			        heldEntity.SendNetworkUpdate();
                }
            }
            return null;
        }

        static readonly DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        static double CurrentTime() => DateTime.UtcNow.Subtract(epoch).TotalSeconds;

        void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            if (!entity.ToPlayer() || entity == null || item == null) return;

            var player = entity.ToPlayer();
            if (player == null || player.IsNpc) return;
            var clan = findClanByUser(player.UserIDString);
            if (clan != null && clan.members[player.UserIDString].GatherInfo.ContainsKey(item.info.shortname))
            {
                if (!clan.members.ContainsKey(player.UserIDString)) return;
                switch (item.info.shortname)
                {
                    case "stones":
                        clan.members[player.UserIDString].GatherInfo["stones"] = clan.members[player.UserIDString].GatherInfo["stones"] + item.amount;
                        clan.Change["stones"].Complete = clan.Change["stones"].Complete + item.amount;
                        break;
                    case "wood":
                        clan.members[player.UserIDString].GatherInfo["wood"] = clan.members[player.UserIDString].GatherInfo["wood"] + item.amount;
                        clan.Change["wood"].Complete = clan.Change["wood"].Complete + item.amount;
                        break;
                    case "metal.ore":
                        clan.members[player.UserIDString].GatherInfo["metal.ore"] = clan.members[player.UserIDString].GatherInfo["metal.ore"] + item.amount;
                        clan.Change["metal.ore"].Complete = clan.Change["metal.ore"].Complete + item.amount;
                        break;
                    case "sulfur.ore":
                        clan.members[player.UserIDString].GatherInfo["sulfur.ore"] = clan.members[player.UserIDString].GatherInfo["sulfur.ore"] + item.amount;
                        clan.Change["sulfur.ore"].Complete = clan.Change["sulfur.ore"].Complete + item.amount;
                        break;
                    case "hq.metal.ore":
                        clan.members[player.UserIDString].GatherInfo["hq.metal.ore"] = clan.members[player.UserIDString].GatherInfo["hq.metal.ore"] + item.amount;
                        clan.Change["hq.metal.ore"].Complete = clan.Change["hq.metal.ore"].Complete + item.amount;
                        break; 
                    case "leather":
                        clan.members[player.UserIDString].GatherInfo["leather"] = clan.members[player.UserIDString].GatherInfo["leather"] + item.amount;
                        clan.Change["leather"].Complete = clan.Change["leather"].Complete + item.amount;
                        break;
                    case "cloth":
                        clan.members[player.UserIDString].GatherInfo["cloth"] = clan.members[player.UserIDString].GatherInfo["cloth"] + item.amount;
                        clan.Change["cloth"].Complete = clan.Change["cloth"].Complete + item.amount;
                        break; 
                    case "fat.animal":
                        clan.members[player.UserIDString].GatherInfo["fat.animal"] = clan.members[player.UserIDString].GatherInfo["fat.animal"] + item.amount;
                        clan.Change["fat.animal"].Complete = clan.Change["fat.animal"].Complete + item.amount;
                        break;                                                                           
                }}
        }
        void OnDispenserBonus(ResourceDispenser disp, BasePlayer player, Item item)
        {
            if (player == null) return;
            if (player == null || player.IsNpc) return;

            var clan = findClanByUser(player.UserIDString);
            if (clan != null && clan.members[player.UserIDString].GatherInfo.ContainsKey(item.info.shortname))
            {
                {
                    if (player == null || clan == null || item == null) return;
                    if (!clan.members.ContainsKey(player.UserIDString)) return;
                    switch (item.info.shortname)
                    {
                        case "stones":
                            clan.members[player.UserIDString].GatherInfo["stones"] = clan.members[player.UserIDString].GatherInfo["stones"] + item.amount;
                            clan.Change["stones"].Complete = clan.Change["stones"].Complete + item.amount;

                        break;
                        case "wood":
                            clan.members[player.UserIDString].GatherInfo["wood"] = clan.members[player.UserIDString].GatherInfo["wood"] + item.amount;
                            clan.Change["wood"].Complete = clan.Change["wood"].Complete + item.amount;

                        break;
                        case "metal.ore":
                            clan.members[player.UserIDString].GatherInfo["metal.ore"] = clan.members[player.UserIDString].GatherInfo["metal.ore"] + item.amount;
                            clan.Change["metal.ore"].Complete = clan.Change["metal.ore"].Complete + item.amount;

                        break;
                        case "sulfur.ore":
                            clan.members[player.UserIDString].GatherInfo["sulfur.ore"] = clan.members[player.UserIDString].GatherInfo["sulfur.ore"] + item.amount;
                            clan.Change["sulfur.ore"].Complete = clan.Change["sulfur.ore"].Complete + item.amount;

                        break;
                        case "hq.metal.ore":
                            clan.members[player.UserIDString].GatherInfo["hq.metal.ore"] = clan.members[player.UserIDString].GatherInfo["hq.metal.ore"] + item.amount;
                            clan.Change["hq.metal.ore"].Complete = clan.Change["hq.metal.ore"].Complete + item.amount;
                        break; 
                        case "leather":
                            clan.members[player.UserIDString].GatherInfo["leather"] = clan.members[player.UserIDString].GatherInfo["leather"] + item.amount;
                            clan.Change["leather"].Complete = clan.Change["leather"].Complete + item.amount;
                        break;
                        case "cloth":
                            clan.members[player.UserIDString].GatherInfo["cloth"] = clan.members[player.UserIDString].GatherInfo["cloth"] + item.amount;
                            clan.Change["cloth"].Complete = clan.Change["cloth"].Complete + item.amount;
                        break;      
                        case "fat.animal":
                            clan.members[player.UserIDString].GatherInfo["animal"] = clan.members[player.UserIDString].GatherInfo["animal"] + item.amount;
                            clan.Change["animal"].Complete = clan.Change["animal"].Complete + item.amount;
                        break;                                                                                            
                    }                   
                }
            }

        }

        private void SelectSkinUi(BasePlayer player, string shortName, int page = 0)
        {
            #region Fields
            var elements = new CuiElementContainer();
            var totalAmount = 32;
            #endregion
 
            #region [Destroy-Ui]
            CuiHelper.DestroyUi(player, "MainSkinLayerMain");
            CuiHelper.DestroyUi(player, "MainLayerText");
            #endregion

            #region [Main-Gui]
            elements.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Color = "0 0 0 0" }
            }, "MainLayerSkinLayer", "MainSkinLayerMain");
            #endregion

            #region [Buttons]
            elements.Add(new CuiButton
            {
                Button = { Color = "0.46 0.44 0.42 0.3", Material = "assets/icons/greyout.mat", Command = page != 0 ? $"UI_CLAN editskin {shortName} {page - 1}" : "" },
                Text = { Text = "<", Color = "1 1 1 0.65", FontSize = 22, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0.01 0.02", AnchorMax = $"0.0625 0.115" },
            }, "MainSkinLayerMain");

            elements.Add(new CuiButton
            {
                Button = { Color = "0.46 0.44 0.42 0.3", Material = "assets/icons/greyout.mat", Command = SkinList[shortName].Count > (page + 1) * totalAmount ? $"UI_CLAN editskin {shortName} {page + 1}" : "" },
                Text = { Text = ">", Color = "1 1 1 0.65", FontSize = 22, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0.08 0.02", AnchorMax = $"0.1325 0.115" },
            }, "MainSkinLayerMain");
            #endregion

            #region [Wear]
            foreach (var check in SkinList[shortName].Select((i, t) => new { A = i, B = t - page * totalAmount}).Skip(page * totalAmount).Take(totalAmount))
            {
                elements.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"{0.009 + check.B * 0.125 - Math.Floor((float) check.B / 8) * 8 * 0.125} {0.795 - Math.Floor((float) check.B/ 8) * 0.22}",
                                        AnchorMax = $"{0.114 + check.B * 0.125 - Math.Floor((float) check.B / 8) * 8 * 0.125} {0.98 - Math.Floor((float) check.B / 8) * 0.22}", },
                    Image = { Color = "0 0 0 0.25", Material = "assets/icons/greyout.mat" }
                }, "MainSkinLayerMain", "MainSkinLayerMain" + ".Wear" + $".{check.B}");

                elements.Add(new CuiElement
                {
                    Parent = "MainSkinLayerMain" + ".Wear" + $".{check.B}",
                    Components =
                    {
                        new CuiImageComponent { ItemId = FindItemID(shortName), SkinId = check.A.Value },
                        new CuiRectTransformComponent { AnchorMin = "0.025 0.025", AnchorMax = "0.975 0.975" }
                    }
                });

                elements.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = $"clan_changeskin {shortName} {check.A.Value}" },
                    Text = { Text = ""},
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                }, "MainSkinLayerMain" + ".Wear" + $".{check.B}");
            }
            #endregion

            CuiHelper.AddUi(player, elements);
        }

        [ConsoleCommand("join")]
        void ConsoleClanJoin(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            if (myClan != null)
            {
                PrintChat(player, string.Format(msg("youalreadymember", current.Id)));
                return;
            }
            if (usePermToJoinClan && !permission.UserHasPermission(current.Id, permissionToJoinClan))
            {
                PrintChat(player, msg("nopermtojoin", current.Id));
                return;
            }
            if (args.Args.Length != 1)
            {
                PrintChat(player, string.Format(msg("usagejoin", current.Id), colorCmdUsage));
                return;
            }
            myClan = findClan(args.Args[0]);
            if (myClan == null || !myClan.IsInvited(current.Id))
            {
                PrintChat(player, string.Format(msg("younotinvited", current.Id)));
                return;
            }
            if (limitMembers >= 0 && myClan.members.Count() >= limitMembers)
            {
                PrintChat(player, string.Format(msg("reachedmaximum", current.Id)));
                return;
            }
            CuiHelper.DestroyUi(player, Layer);
            myClan.invites.Remove(current.Id);
            pendingPlayerInvites.Remove(current.Id);
            myClan.members.Add(current.Id, new PlayerStats());
            clanCache[current.Id] = myClan;
            myClan.AddBasePlayer(player);
            SetupPlayer(player, current, clan: myClan);


            if (usePermGroups && !permission.UserHasGroup(current.Id, permGroupPrefix + myClan.tag)) permission.AddUserGroup(current.Id, permGroupPrefix + myClan.tag);
            myClan.BroadcastLoc("playerjoined", myClan.ColNam(current.Id, current.Name));
            myClan.updated = UnixTimeStampUTC();
            myClan.total++;
            myClan.OnUpdate();
            List<string> others = new List<string>(myClan.members.Keys);
            others.Remove(current.Id);
            Interface.Oxide.CallHook("OnClanMemberJoined", current.Id, others);
        }

        string Layer = "Interface_UI";

        void InterfaceUI(BasePlayer player, string name)
        {
            CuiHelper.DestroyUi(player, "Layer");
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Material = "assets/content/ui/uibackgroundblur.mat", Color = "0 0 0 0.65" }
            }, "Overlay", Layer);

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Color = "0 0.1 0 0.8" }
            }, Layer);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Color = "1.00 1.00 1.00 0.03", Material = "assets/content/ui/scope_2.mat" }
            }, Layer);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-244 -117.5", OffsetMax = "246.5 119" },
                Image = { Color = "0.3773585 0.3755785 0.3755785 0.4607843", Material = "assets/icons/greyout.mat" }
            }, Layer, "InterfaceInvite");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.55", AnchorMax = "1 1" },
                Text = { Text = $"Клан <color=#a5e664>{name}</color> приглашает вас!", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 16 }
            }, "InterfaceInvite");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.296 0.465", AnchorMax = "0.703 0.616" },
                Button = { Color = "0.38 0.71 0.12 0.45", Material = "assets/icons/greyout.mat", Command = $"join {name}" },
                Text = { Text = $"Принять", Color = "1 1 1 0.65", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 14 }
            }, "InterfaceInvite");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.296 0.282", AnchorMax = "0.703 0.425" },
                Button = { Color = "1 0 0 0.45", Material = "assets/icons/greyout.mat", Close = Layer },
                Text = { Text = $"Отклонить", Color = "1 1 1 0.65", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 14 }
            }, "InterfaceInvite");

            container.Add(new CuiButton
            {
                Button = { Color = "0 0 0 0", Close = Layer },
                Text = { Text = "✘", Color = "1 1 1 0.65", FontSize = 20, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0.905 0.825", AnchorMax = $"0.955 0.925" },
            }, "InterfaceInvite");

            CuiHelper.AddUi(player, container);
        }

        [ConsoleCommand("UI_RES")]
        private void setRes(ConsoleSystem.Arg args)
        {
            #region [Vars]
            var player = args.Player();
            var container = new CuiElementContainer();
            #endregion

            #region [Parrent]
            container.Add(new CuiPanel
            {
                Image = { Color = "0 0 0 0.925" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                CursorEnabled = true,
            }, "Overlay", "setRes");

            container.Add(new CuiButton
            {
                Button = { Color = "0 0 0 0", Close = "setRes" },
                Text = { Text = "" },
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" },
            }, "setRes");
            #endregion

            #region [Main-Gui]
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-199 -79.5", OffsetMax = "201.5 81.5" },
                Image = { Color = "0.3773585 0.3755785 0.3755785 0.44", Material = "assets/icons/greyout.mat" }
            }, "setRes", "panel");
            #endregion

            #region [Text]
            container.Add(new CuiElement
            {
                Parent = $"panel",
                Components =
                {
                    new CuiTextComponent { Text = $"ВВЕДИТЕ КОЛИЧЕСТВО", Color = "1 1 1 0.85", FontSize = 24, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter},
                    new CuiRectTransformComponent { AnchorMin = "0 0.81", AnchorMax = "1 1" },
                }
            });

            container.Add(new CuiElement
            {
                Parent = $"panel",
                Components =
                {
                    new CuiTextComponent { Text = $"ДОПУСТИМЫЙ МАКСИМУМ: {NeedLimit[args.Args[0]].ToString("N3", CultureInfo.GetCultureInfo("ru-RU")).Replace(",000", "")}", Color = "1 1 1 0.65", FontSize = 16, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft},
                    new CuiRectTransformComponent { AnchorMin = "0.194 0.38", AnchorMax = "1 1" },
                }
            });
            #endregion

            #region [Input]
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.125 0.225", AnchorMax = "0.875 0.47" },
                Image = { Color = "0 0 0 0.5" }
            }, "panel", "inputpanel");

            container.Add(new CuiElement
            {
                Parent = $"inputpanel",
                Components =
                {
                    new CuiTextComponent { Text = $"ВВЕДИТЕ КОЛИЧЕСТВО И НАЖМИТЕ ENTER", Color = "1 1 1 0.1", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter},
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" },
                }
            });

            container.Add(new CuiElement()
            {
                Parent = "inputpanel",
                Components =
                {
                    new CuiInputFieldComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        CharsLimit = 8,
                        FontSize = 18,
                        Command = $"clan_Change {args.Args[0]} ",
                        Font = "robotocondensed-regular.ttf",
                        Text = "",
                        Color = "1 1 1 1"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0", AnchorMax = "1 1"
                    }
                }
            });
            #endregion

            CuiHelper.DestroyUi(player, "setRes");
            CuiHelper.AddUi(player, container);
        }

        [ConsoleCommand("clan_Change")]
        void cmdSetNewChangeOfClan(ConsoleSystem.Arg args)
        {
            var player = args.Player();

            if (args.GetString(1) == "") return;

            int amount;
            if (!int.TryParse(args.Args[1], out amount)) return;

            if (NeedLimit.ContainsKey(args.Args[0]))
            {
                if (amount > NeedLimit[args.Args[0]]) return;
            }

            var clan = findClanByUser(player.UserIDString);

            if (clan.Change.ContainsKey(args.Args[0]))
            {
                clan.Change[args.Args[0]].Need = amount;
            }


            CuiHelper.DestroyUi(player, "setRes");
            cmdResChangeOfClan(args);
        }

        class Position
        {
            public float Xmin;
            public float Xmax;
            public float Ymin;
            public float Ymax;

            public string AnchorMin =>
                $"{Math.Round(Xmin, 4).ToString(CultureInfo.InvariantCulture)} {Math.Round(Ymin, 4).ToString(CultureInfo.InvariantCulture)}";
            public string AnchorMax =>
                $"{Math.Round(Xmax, 4).ToString(CultureInfo.InvariantCulture)} {Math.Round(Ymax, 4).ToString(CultureInfo.InvariantCulture)}";

            public override string ToString()
            {
                return $"----------\nAmin:{AnchorMin}\nAmax:{AnchorMax}\n----------";
            }
        }

        [SuppressMessage("ReSharper", "CompareOfFloatsByEqualityOperator")]
        private static List<Position> GetPositions(int colums, int rows, float colPadding = 0, float rowPadding = 0, bool columsFirst = false)
        {
            if (colums == 0)
                throw new ArgumentException("Can't create positions for gui!", nameof(colums));
            if (rows == 0)
                throw new ArgumentException("Can't create positions for gui!", nameof(rows));

            List<Position> result = new List<Position>();
            result.Clear();
            var colsDiv = 1f / colums;
            var rowsDiv = 1f / rows;
            if (colPadding == 0) colPadding = colsDiv / 2;
            if (rowPadding == 0) rowPadding = rowsDiv / 2;
            if (!columsFirst)
                for (int j = rows; j >= 1; j--)
                {
                    for (int i = 1; i <= colums; i++)
                    {
                        Position pos = new Position
                        {
                            Xmin = (i - 1) * colsDiv + colPadding / 2f,
                            Xmax = i * colsDiv - colPadding / 2f,
                            Ymin = (j - 1) * rowsDiv + rowPadding / 2f,
                            Ymax = j * rowsDiv - rowPadding / 2f
                        };
                        result.Add(pos);
                    }
                }
            else
                for (int i = 1; i <= colums; i++)
                {
                    for (int j = rows; j >= 1; j--)
                    {
                        Position pos = new Position
                        {
                            Xmin = (i - 1) * colsDiv + colPadding / 2f,
                            Xmax = i * colsDiv - colPadding / 2f,
                            Ymin = (j - 1) * rowsDiv + rowPadding / 2f,
                            Ymax = j * rowsDiv - rowPadding / 2f
                        };
                        result.Add(pos);
                    }
                }
            return result;
        }
        [ConsoleCommand("clan_changeskin")]
        void cmdChatSkinOfClan(ConsoleSystem.Arg args)
        {
            if (args.GetString(1) == "") return;
            var player = args.Player();
            if (player == null) return;
            var clan = findClanByUser(player.UserIDString);
            if (clan == null) return;

            ulong SkinID;
            if (!ulong.TryParse(args.Args[1], out SkinID)) return;
            var value = clan.SkinList.FirstOrDefault(p => p.Value.ContainsKey(args.Args[0])).Key;
            clan.SkinList[value][args.Args[0]] = SkinID;
            cmdItemChangeOfClan(args);
        }

        [ConsoleCommand("clan_kickplayer")]
        void cmdKickOfClan(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            KickPlayer(player, args.Args[0]);
            CuiHelper.DestroyUi(player, "UICLAN_stats");
            NewClanUI(player, 0);
        }

        private Dictionary<ulong, ulong> LastHeliHit = new Dictionary<ulong, ulong>();
        private Dictionary<ulong, ulong> LastBradleyAPCHit = new Dictionary<ulong, ulong>();

        private BasePlayer GetLastHeliAttacker(ulong heliNetId)
        {
            ulong player;
            LastHeliHit.TryGetValue(heliNetId, out player);
            return BasePlayer.FindByID(player);
        }
        private BasePlayer GetLastBradleyAPCAttacker(ulong BradleyAPCNetId)
        {
            ulong player;
            LastBradleyAPCHit.TryGetValue(BradleyAPCNetId, out player);
            return BasePlayer.FindByID(player);
        }
        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (info == null || entity?.net?.ID == null) return;

            if (entity is PatrolHelicopter)
            {
                var newClan = findClanByUser(GetLastHeliAttacker(entity.net.ID.Value).UserIDString);
                if (newClan == null) return;
                newClan.ClanPoints += PointsOfKilledHeli;
                newClan.members[GetLastHeliAttacker(entity.net.ID.Value).UserIDString].PlayerPoints += PointsOfKilledHeli;
                foreach (var pp in BasePlayer.activePlayerList)
                    pp.ChatMessage($"");
                return;
            }

            var player = info?.InitiatorPlayer;
            if (player == null) return;
            var clan = findClanByUser(player.UserIDString);
            if (clan == null) return;
            if (entity is BradleyAPC && GetLastBradleyAPCAttacker(entity.net.ID.Value) == player)
            {
                clan.ClanPoints += PointsOfKilledBradleyAPC;
                clan.members[player.UserIDString].PlayerPoints += PointsOfKilledBradleyAPC;
                foreach (var pp in BasePlayer.activePlayerList)
                    pp.ChatMessage($"Танк был взорван кланом <color=orange>{clan.tag}</color>");
            }
            if (entity.PrefabName.Contains("barrel"))
            {
                clan.members[player.UserIDString].GatherInfo["loot-barrel"] = clan.members[player.UserIDString].GatherInfo["loot-barrel"] + 1;
                clan.Change["loot-barrel"].Complete = clan.Change["loot-barrel"].Complete + 1;

            }
            if (entity.ToPlayer() != null)
            {
                if (entity.GetComponent<NPCPlayer>() != null || IsNPC(entity.ToPlayer())) return;
                if (entity.ToPlayer() == info.Initiator.ToPlayer())
                {
                    clan.ClanPoints -= PointsOfSuicide;
                    clan.members[player.UserIDString].Suicide++;
                    clan.members[player.UserIDString].PlayerPoints -= PointsOfSuicide;
                }
                else
                {
                    clan.ClanPoints += PointsOfKilled;
                    clan.members[player.UserIDString].Killed++;
                    clan.KillC++;
                    clan.members[player.UserIDString].PlayerPoints += PointsOfKilled;
                }

            }      
        }   

        private bool IsNPC(BasePlayer player)
        {
            if (player == null) return false;
            if (player is NPCPlayer) return true;
            if (!(player.userID >= 76560000000000000L || player.userID <= 0L) || player.UserIDString.Length < 17) return true;
            return false;
        }

        /*int GetPercent(int need, int current) => current * 100 / need;

        double GetPercentFUll(double need, double current) => current * 100 / need;*/

        [ChatCommand("ctop")]
        void cmdClanTOP(BasePlayer player, string command, string[] args)
        {
            ClanTOP(player, 0);
        }

        public int GetClanIndex(string key)
        {
            var ClanMembers = from pair in clans orderby pair.Value.ClanPoints descending select pair;
            int index = 1;
            foreach (KeyValuePair<string, Clan> clanIndex in ClanMembers)
            {
                if (clanIndex.Value.tag == key)
                    return index;
                index++;
            }
            return 0;
        }

        string GetPlayerStatus(string player, Clan clan)
        {
            string status = "";

            if (clan == null) return "Обычный игрок";
            if (clan.members.ContainsKey(player)) status = "Участник";
            if (clan.moderators.Contains(player)) status = "Капитан";
            if (clan.owner.Contains(player)) status = "Лидер";
            return status;
        }

        void ClanTOPInfo(BasePlayer player, Clan clan, int page)
        {
            #region [Vars]
            var elements = new CuiElementContainer();
            string colored = "0 0 0 0.5";
            int i = 0;
            var ClanMembers = from pair in clan.members orderby pair.Value.PlayerPoints descending select pair;
            #endregion

            #region [DestroyUi]
            CuiHelper.DestroyUi(player, "Clanstop_main2");
            CuiHelper.DestroyUi(player, "Clanstop_info2");
            #endregion

            #region [Parrent]
            elements.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Material = "assets/content/ui/uibackgroundblur.mat", Color = "0 0 0 0.77" }
            }, "Overlay", "Clanstop_info2");

            elements.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Color = "0.36 0.33 0.28 0.3", Material = "assets/icons/greyout.mat", Close = "Clanstop_info2" }
            }, "Clanstop_info2");
            #endregion

            #region [Main-Gui]
            elements.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-255 -218", OffsetMax = "260 220" },
                Image = { Color = "0.3773585 0.3755785 0.3755785 0.3407843", Material = "assets/icons/greyout.mat" }
            }, "Clanstop_info2", "Clanstop_infolayer");
            #endregion

            #region [Avatar]
            elements.Add(new CuiElement
            {
                Parent = $"Clanstop_infolayer",
                Components =
                {
                    new CuiRawImageComponent { Png = (string)ImageLibrary?.Call("GetImage", clan.owner) },
                    new CuiRectTransformComponent { AnchorMin = "0.0635 0.63", AnchorMax = "0.31 0.92" }
                }
            });
            #endregion

            #region [Buttons]
            elements.Add(new CuiButton
            {
                Button = { Color = "0.46 0.44 0.42 0.55", Material = "assets/icons/greyout.mat", Close = "Clanstop_info2" },
                Text = { Text = "ЗАКРЫТЬ", Color = "1 1 1 0.75",Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter},
                RectTransform = { AnchorMin = $"0.795 0.011", AnchorMax = $"0.989 0.0825" },
            }, "Clanstop_infolayer");
            elements.Add(new CuiButton
            {
                Button = { Color = "0.46 0.44 0.42 0.55", Material = "assets/icons/greyout.mat", Command = "Clanstop_main" },
                Text = { Text = "НАЗАД", Color = "1 1 1 0.75",Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter},
                RectTransform = { AnchorMin = $"0.593 0.011", AnchorMax = $"0.785 0.0825" },
            }, "Clanstop_infolayer");
            #endregion

            #region [Page]
            elements.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.0705 0.011", AnchorMax = $"0.135 0.0825" },
                Image = { Color = "0 0 0 0.25", Material = "assets/icons/greyout.mat" }
            }, "Clanstop_infolayer", "Clanstop_infopagetext");

            elements.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" },
                Text = { Text = $"{page + 1}", Color = "1 1 1 1", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter }
            }, "Clanstop_infopagetext");

            elements.Add(new CuiButton
            {
                Button = { Color = "0.46 0.44 0.42 0.65", Material = "assets/icons/greyout.mat", Command = page > 0 ? $"clanstop_info {clan.tag} {page - 1}" : "" },
                Text = { Text = "-", Color = "1 1 1 1", FontSize = 22, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0.009 0.011", AnchorMax = $"0.0705 0.0825" },
            }, "Clanstop_infolayer");

            elements.Add(new CuiButton
            {
                Button = { Color = "0.46 0.44 0.42 0.65", Material = "assets/icons/greyout.mat", Command = ClanMembers.Skip(5 * (page + 1)).Count() > 0 ? $"clanstop_info {clan.tag} {page + 1}" : "" },
                Text = { Text = "+", Color = "1 1 1 1", FontSize = 22, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0.135 0.011", AnchorMax = $"0.1975 0.0825" },
            }, "Clanstop_infolayer");
            #endregion

            #region [Resourse]
            foreach (var check in clan.Change.Select((y, t) => new { A = y, B = t }).Take(9))
            {
                elements.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"{0.025 + check.B * 0.1074 - Math.Floor((float) check.B / 9) * 9 * 0.1074} {0.455 - Math.Floor((float) check.B/ 9) * 0}",
                                        AnchorMax = $"{0.115 + check.B * 0.1074 - Math.Floor((float) check.B / 9) * 9 * 0.1074} {0.5625 - Math.Floor((float) check.B / 9) * 0}", },
                    Image = { Color = "0 0 0 0.25", Material = "assets/icons/greyout.mat" }
                }, "Clanstop_infolayer", "Clanstop_infolayer" + ".Resourse" + $".{check.B}");

                if (FindItemID(check.A.Key) != 0)
                {
                    elements.Add(new CuiElement
                    {
                        Parent = "Clanstop_infolayer" + ".Resourse" + $".{check.B}",
                        Components =
                        {
                            new CuiImageComponent { ItemId = FindItemID(check.A.Key), SkinId = 0 },
                            new CuiRectTransformComponent {AnchorMin = "0.025 0.025", AnchorMax = "0.975 0.975"}
                        }
                    });
                }
                else
                {
                    elements.Add(new CuiElement
                    {
                        Parent = "Clanstop_infolayer" + ".Resourse" + $".{check.B}",
                        Components =
                        {
                            new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", check.A.Key) },
                            new CuiRectTransformComponent {AnchorMin = "0.05 0.05", AnchorMax = "0.95 0.95"}
                        }
                    });
                }

                elements.Add(new CuiElement
                {
                    Parent = "Clanstop_infolayer" + ".Resourse" + $".{check.B}",
                    Components =
                    {
                        new CuiTextComponent { Text = $"{check.A.Value.Complete}", Color = "1 1 1 1", Align = TextAnchor.MiddleRight, FontSize = 12, Font = "robotocondensed-regular.ttf" },
                        new CuiRectTransformComponent { AnchorMin = $"0 0", AnchorMax = $"0.89 0.35" },
                    }
                });
            }
            #endregion

            #region [Text]
            elements.Add(new CuiPanel
            {
                Image = { Color = "0 0 0 0" },
                RectTransform = { AnchorMin = "0 0.37", AnchorMax = "0.9975 0.4" },
            }, "Clanstop_infolayer", "PlayerInfoPanel");
            elements.Add(new CuiLabel
            {
                Text = { Text = "#", Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "1 1 1 1", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.03 0", AnchorMax = $"0.2 1" },
            }, "PlayerInfoPanel");
            elements.Add(new CuiLabel
            {
                Text = { Text = "ИМЯ ИГРОКА", Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "1 1 1 1", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.11 0", AnchorMax = $"0.4 1" },
            }, "PlayerInfoPanel");
            elements.Add(new CuiLabel
            {
                Text = { Text = "ОЧКОВ", Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "1 1 1 1", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.498 0", AnchorMax = $"0.85 1" },
            }, "PlayerInfoPanel");
            elements.Add(new CuiLabel
            {
                Text = { Text = "АКТИВНОСТЬ", Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "1 1 1 1", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.596 0", AnchorMax = $"1 1" },
            }, "PlayerInfoPanel");
            elements.Add(new CuiLabel
            {
                Text = { Text = "УБИЙСТВ", Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "1 1 1 1", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.751 0", AnchorMax = $"1 1" },
            }, "PlayerInfoPanel");
            elements.Add(new CuiLabel
            {
                Text = { Text = "СМЕРТЕЙ", Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "1 1 1 1", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.869 0", AnchorMax = $"1 1" },
            }, "PlayerInfoPanel");
            #endregion

            #region [PlayerInfo]
            for (int y = 0; y < 5; y++)
            {
                elements.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"0.0055 {0.318 - y * 0.055}", AnchorMax = $"0.99 {0.365 - y * 0.055}" },
                    Image = { Color = colored }
                }, "Clanstop_infolayer", "Clanstop_infolayer" + $".Line{y}");
            }

            foreach (KeyValuePair<string, PlayerStats> key in ClanMembers.Skip(5 * page).Take(ClanMembers.ToList().Count >= 5 ? 5 : ClanMembers.ToList().Count))
            {
                elements.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" },
                    Image = { Color = "0 0 0 0" }
                }, "Clanstop_infolayer" + $".Line{i}");

                elements.Add(new CuiLabel
                {
                    Text = { Text = $"{i + (1 + (page * 10))}", Color = "1 1 1 1", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                    RectTransform = { AnchorMin = $"0.025 0", AnchorMax = $"0.1 1" },
                }, "Clanstop_infolayer" + $".Line{i}");

                elements.Add(new CuiLabel
                {
                    Text = { Text = $"{clan.GetIMember(key.Key).Name}", Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "1 1 1 1", Align = TextAnchor.MiddleLeft },
                    RectTransform = { AnchorMin = $"0.1075 0", AnchorMax = $"0.4 1" },
                }, "Clanstop_infolayer" + $".Line{i}");

                elements.Add(new CuiLabel
                {
                    Text = { Text = $"{key.Value.PlayerPoints}", Color = "1 1 1 1", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0.215 0", AnchorMax = $"0.85 1" },
                }, "Clanstop_infolayer" + $".Line{i}");
                
                elements.Add(new CuiLabel
                {
                    Text = { Text = $"0%", Color = "1 1 1 1", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0.32 0", AnchorMax = $"1 1" },
                }, "Clanstop_infolayer" + $".Line{i}");

                elements.Add(new CuiLabel
                {
                    Text = { Text = $"{key.Value.Killed}", Color = "1 1 1 1", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0.605 0", AnchorMax = $"1 1" },
                }, "Clanstop_infolayer" + $".Line{i}");

				elements.Add(new CuiLabel
                {
                    Text = { Text = $"{key.Value.Death}", Color = "1 1 1 1", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0.84 0", AnchorMax = $"1 1" },
                }, "Clanstop_infolayer" + $".Line{i}");

                i++;
            }
            #endregion

            #region [InfoClan]
            Dictionary<string, string> InfoClan = new Dictionary<string, string>()
            {
                { "ГЛАВА КОМАНДЫ:", $"{clan.ownerName}" },
                { "ИГРОКОВ В КОМАНДЕ:", $"{clan.members.Count}" },
                { "НАБРАНО ОЧКОВ:", $"{clan.ClanPoints}" },
                { "ОБЩАЯ АКТИВНОСТЬ:", $"0%" },
                { "ВСЕГО УБИЙСТВ:", $"{clan.KillC}" },
                { "ВСЕГО СМЕРТЕЙ:", $"{clan.DeathC}" },
            };
            foreach (var check in InfoClan.Select((u, t) => new { A = u, B = t }))
            {
                elements.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"{0.3675 + check.B * 0 - Math.Floor((float) check.B / 1) * 1 * 0} {0.868 - Math.Floor((float) check.B/ 1) * 0.0485}",
                                        AnchorMax = $"{0.938 + check.B * 0 - Math.Floor((float) check.B / 1) * 1 * 0} {0.91 - Math.Floor((float) check.B / 1) * 0.0485}", },
                    Image = { Color = "0 0 0 0.25", Material = "assets/icons/greyout.mat" }
                }, "Clanstop_infolayer", "Clanstop_infolayer" + ".Info" + $".{check.B}");

                elements.Add(new CuiElement
                {
                    Parent = "Clanstop_infolayer" + ".Info" + $".{check.B}",
                    Components =
                    {
                        new CuiTextComponent { Text = $"{check.A.Key}", Color = "1 1 1 1", FontSize = 14, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                        new CuiRectTransformComponent { AnchorMin = $"0.015 0", AnchorMax = $"0.5 1" },
                    }
                }); 

                elements.Add(new CuiElement
                {
                    Parent = "Clanstop_infolayer" + ".Info" + $".{check.B}",
                    Components =
                    {
                        new CuiTextComponent { Text = $"{check.A.Value}", Color = "1 1 1 1", FontSize = 14, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleRight },
                        new CuiRectTransformComponent { AnchorMin = $"0.5 0", AnchorMax = $"0.985 1" },
                    }
                }); 
            }
            #endregion

            #region [Title-Clan]
			elements.Add(new CuiLabel
            {
                Text = { Text = clan.online > 0 ? $"<color=lime>●</color> <b>{clan.tag}</b>" : $"<color=red>●</color> <b>{clan.tag}</b>", Color = "1 1 1 1", FontSize = 20, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0 0.92", AnchorMax = $"1 1" },
            }, "Clanstop_infolayer");
            #endregion

            CuiHelper.AddUi(player, elements);
        }

        void ClanTOP(BasePlayer player, int page)
        {
            #region [Vars]
            var myClan = findClanByUser(player.UserIDString);
            var ClanMembers = from pair in clans orderby pair.Value.ClanPoints descending select pair;
            var elements = new CuiElementContainer();
            string colored = "0.2 0.2 0.2 0.55";
            int i = 0;            
            #endregion
            
            #region [DestroyUi]
            CuiHelper.DestroyUi(player, "Clanstop_info2");
            CuiHelper.DestroyUi(player, "Clanstop_main2");
            #endregion

            #region [Parrent]
            elements.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Material = "assets/content/ui/uibackgroundblur.mat", Color = "0 0 0 0.77" }
            }, "Overlay", "Clanstop_main2");

            elements.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Color = "0.36 0.33 0.28 0.3", Material = "assets/icons/greyout.mat", Close = "Clanstop_main2" }
            }, "Clanstop_main2");
            #endregion

            #region [Main-Gui]
            elements.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-255 -79", OffsetMax = "260 226" },
                Image = { Color = "0.3773585 0.3755785 0.3755785 0.3407843", Material = "assets/icons/greyout.mat" }
            }, "Clanstop_main2", "Clanstop_mainlayer");

            elements.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-255 -174", OffsetMax = "260 -85" },
                Image = { Color = "0.3773585 0.3755785 0.3755785 0.3407843", Material = "assets/icons/greyout.mat" }
            }, "Clanstop_main2", "Clanstop_desclayer");
            #endregion

            #region [Text]
            elements.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.933", AnchorMax = "0.997 0.997" },
                Image = { Color = "0 0 0 0" }
            }, "Clanstop_mainlayer", "Clanstop_mainlayertext");

            elements.Add(new CuiLabel
            {
                Text = { Text = $"#", Color = "1 1 1 1", FontSize = 13, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.033 0", AnchorMax = $"1 1" },
            }, "Clanstop_mainlayertext");

            elements.Add(new CuiLabel
            {
                Text = { Text = $"НАЗВАНИЕ КЛАНА", Color = "1 1 1 1", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.094 0", AnchorMax = $"1 1" },
            }, "Clanstop_mainlayertext");

            elements.Add(new CuiLabel
            {
                Text = { Text = $"НАГРАДА", Color = "1 1 1 1", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.352 0", AnchorMax = $"1 1" },
            }, "Clanstop_mainlayertext");

            elements.Add(new CuiLabel
            {
                Text = { Text = $"", Color = "1 1 1 1", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.536 0", AnchorMax = $"1 1" },
            }, "Clanstop_mainlayertext");

            elements.Add(new CuiLabel
            {
                Text = { Text = $"ОЧКИ", Color = "1 1 1 1", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.717 0", AnchorMax = $"1 1" },
            }, "Clanstop_mainlayertext");

            elements.Add(new CuiLabel
            {
                Text = { Text = $"ИГРОКОВ", Color = "1 1 1 1", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.865 0", AnchorMax = $"1 1" },
            }, "Clanstop_mainlayertext");

            elements.Add(new CuiLabel
            {
                Text = { Text = $"Очки даются:\nУбийство +30, добыча руды +1, разрушение бочки +1, сбитие вертолета +1000, уничтожение танка +500\nОчки отнимаются:\nСмерть -15, самоубийство -15\nНаграда выдается после вайпа на сервере!", Color = "1 1 1 1", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.0125 0", AnchorMax = $"1 1" },
            }, "Clanstop_desclayer");
            #endregion

            #region [Button]

            if (myClan != null)
            {
                elements.Add(new CuiButton
                {
                    Button = { Color = "0.38 0.62 0.12 0.85", Command = $"clanstop_info {myClan.tag}", Material = "assets/icons/greyout.mat"},
                    Text = { Text = "МОЙ КЛАН", Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter},
                    RectTransform = { AnchorMin = $"0.4 0.0185", AnchorMax = $"0.6 0.125" },
                }, "Clanstop_mainlayer");
            }

            elements.Add(new CuiButton
            {
                Button = { Color = "0.46 0.44 0.42 0.85", Material = "assets/icons/greyout.mat", Close = "Clanstop_main2"},
                Text = { Text = "ЗАКРЫТЬ", Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter},
                RectTransform = { AnchorMin = $"0.8 0.0185", AnchorMax = $"0.99 0.125" },
            }, "Clanstop_mainlayer");

            elements.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.088 0.0185", AnchorMax = $"0.165 0.125" },
                Image = { Color = "0.2 0.2 0.2 0.25", Material = "assets/icons/greyout.mat" }
            }, "Clanstop_mainlayer", "clans_pagetext");

            elements.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" },
                Text = { Text = $"{page + 1}", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter }
            }, "clans_pagetext");

            elements.Add(new CuiButton
            {
                Button = { Color = "0.46 0.44 0.42 0.85", Material = "assets/icons/greyout.mat", Command = page > 0 ? $"clanstop_main {page - 1}" : "" },
                Text = { Text = "-", FontSize = 22, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter},
                RectTransform = { AnchorMin = $"0.01 0.0185", AnchorMax = $"0.088 0.125" },
            }, "Clanstop_mainlayer");

            elements.Add(new CuiButton
            {
                Button = { Color = "0.46 0.44 0.42 0.85", Material = "assets/icons/greyout.mat", Command = clans.Keys.Skip(10 * (page + 1)).Count() > 0 ? $"clanstop_main {page + 1}" : "" },
                Text = { Text = "+", FontSize = 22, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter},
                RectTransform = { AnchorMin = $"0.165 0.0185", AnchorMax = $"0.244 0.125" },
            }, "Clanstop_mainlayer");
            #endregion

            #region [ClanInfo]
            for (int y = 0; y < 10; y++)
            {
                elements.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"0.0055 {0.858 - y * 0.0787}", AnchorMax = $"0.989 {0.93 - y * 0.0787}" },
                    Image = { Color = colored }
                }, "Clanstop_mainlayer", "Clanstop_mainlayer" + $".TopLine{y}");
            }

            foreach (KeyValuePair<string, Clan> key in ClanMembers.Skip(10 * page).Take(ClanMembers.ToList().Count >= 10 ? 10 : ClanMembers.ToList().Count))
            {
                elements.Add(new CuiLabel
                {
                    Text = { Text = $"{i + (1 + (page * 10))}", Color = "1 1 1 1", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"0.067 1" },
                }, "Clanstop_mainlayer" + $".TopLine{i}");

                elements.Add(new CuiLabel
                {
                    Text = { Text = key.Value.online > 0 ? "<color=#a5e664>●</color>" : "<color=red>●</color>", Font = "robotocondensed-regular.ttf", FontSize = 7, Color = "1 1 1 1", Align = TextAnchor.MiddleLeft },
                    RectTransform = { AnchorMin = $"0.0925 0", AnchorMax = $"0.44 1" },
                }, "Clanstop_mainlayer" + $".TopLine{i}");

                elements.Add(new CuiLabel
                {
                    Text = { Text = key.Value.tag.ToUpper(), Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "1 1 1 1", Align = TextAnchor.MiddleLeft },
                    RectTransform = { AnchorMin = $"0.1085 0", AnchorMax = $"0.45 1" },
                }, "Clanstop_mainlayer" + $".TopLine{i}");

                if (ClanBonus.ContainsKey(i + (1 + (page * 10))))
                {
                    elements.Add(new CuiLabel
                    {
                        Text = { Text = $"{ClanBonus[i + (1 + (page * 10))]}", Color = "1 1 1 1", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter },
                        RectTransform = { AnchorMin = $"0 0", AnchorMax = $"0.785 1" },
                    }, "Clanstop_mainlayer" + $".TopLine{i}");
                }


                elements.Add(new CuiLabel
                {
                    Text = { Text = key.Value.ClanPoints.ToString(), Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "1 1 1 1", Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0.705 0", AnchorMax = $"0.79 1" },
                }, "Clanstop_mainlayer" + $".TopLine{i}"); 

                elements.Add(new CuiLabel
                {
                    Text = { Text = $"{key.Value.members.Count}".ToUpper(), Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "1 1 1 1", Align = TextAnchor.MiddleLeft },
                    RectTransform = { AnchorMin = $"0.91 0", AnchorMax = $"1 1" },
                }, "Clanstop_mainlayer" + $".TopLine{i}");

                elements.Add(new CuiButton
                {
                    Button = { Color = "0.25 0.25 0.23 0", Command = $"clanstop_info {key.Value.tag}" },
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" },
                }, "Clanstop_mainlayer" + $".TopLine{i}");

                i++;
            }
            #endregion

            CuiHelper.AddUi(player, elements);
        }


        long GetFullPercent(string id)
        {
            var clan = findClanByUser(id);
            long Need = clan.Change.Sum(x => x.Value.Need);
            var playerCurrent = clan.members[id].GatherInfo.Sum(p => p.Value);
            if (playerCurrent == 0) return 0;
            return playerCurrent * 100 / Need;
        }

        long GetFullClanPercent(string tag)
        {
            var clan = findClan(tag);
            long Need = clan.Change.Sum(x => x.Value.Need);
            var Current = clan.Change.Sum(x => x.Value.Complete);
            if (Current == 0) return 0;
            return Current * 100 / Need;
        }

        public static string FormatShortTime(TimeSpan time)
        {
            string result = string.Empty;
            if (time.Days != 0)
                result += $"{time.Days} д. ";

            if (time.Hours != 0)
                result += $"{time.Hours} час. ";

            if (time.Minutes != 0)
                result += $"{time.Minutes} мин. ";

            if (time.Seconds != 0)
                result += $"{time.Seconds} сек. ";

            return result;
        }

        public void WithdrawPlayer(BasePlayer player, string targetId) => cmdClanWithdraw(player, new string[] { "", targetId });

        void cmdClanWithdraw(BasePlayer player, string[] args)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            if (myClan == null)
            {
                player.ChatMessage("У вас <color=red>нет</color> клана");
                return;
            }
            if (args.Length < 2)
            {
                PrintChat(player, string.Format(msg("usagewithdraw", current.Id), colorCmdUsage));
                return;
            }
            if (!myClan.IsOwner(current.Id) && !myClan.IsCouncil(current.Id) && !myClan.IsModerator(current.Id))
            {
                PrintChat(player, string.Format(msg("notmoderator", current.Id)));
                return;
            }
            var disinvPlayer = myClan.GetIPlayer(args[1]);
            if (disinvPlayer == null)
            {
                PrintChat(player, string.Format(msg("nosuchplayer", current.Id), args[1]));
                return;
            }
            if (myClan.members.ContainsKey(disinvPlayer.Id))
            {
                PrintChat(player, string.Format(msg("alreadymember", current.Id), disinvPlayer.Name));
                return;
            }
            if (!myClan.invites.ContainsKey(disinvPlayer.Id))
            {
                PrintChat(player, string.Format(msg("notinvited", current.Id), disinvPlayer.Name));
                return;
            }
            myClan.invites.Remove(disinvPlayer.Id);
            if (pendingPlayerInvites.ContainsKey(disinvPlayer.Id)) pendingPlayerInvites[disinvPlayer.Id].Remove(myClan.tag);
            myClan.BroadcastLoc("canceledinvite", myClan.ColNam(current.Id, current.Name), myClan.ColNam(disinvPlayer.Id, disinvPlayer.Name));
            myClan.updated = UnixTimeStampUTC();
        }
        void cmdClanJoin(BasePlayer player, string[] args)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            if (myClan != null)
            {
                PrintChat(player, string.Format(msg("youalreadymember", current.Id)));
                return;
            }
            if (usePermToJoinClan && !permission.UserHasPermission(current.Id, permissionToJoinClan))
            {
                PrintChat(player, msg("nopermtojoin", current.Id));
                return;
            }
            if (args.Length != 2)
            {
                PrintChat(player, string.Format(msg("usagejoin", current.Id), colorCmdUsage));
                return;
            }
            myClan = findClan(args[1]);
            if (myClan == null || !myClan.IsInvited(current.Id))
            {
                PrintChat(player, string.Format(msg("younotinvited", current.Id)));
                return;
            }
            if (limitMembers >= 0 && myClan.members.Count() >= limitMembers)
            {
                PrintChat(player, string.Format(msg("reachedmaximum", current.Id)));
                return;
            }
            myClan.invites.Remove(current.Id);
            pendingPlayerInvites.Remove(current.Id);
            myClan.members.Add(current.Id, new PlayerStats());
            clanCache[current.Id] = myClan;
            myClan.AddBasePlayer(player);
            SetupPlayer(player, current, clan: myClan);


            if (usePermGroups && !permission.UserHasGroup(current.Id, permGroupPrefix + myClan.tag)) permission.AddUserGroup(current.Id, permGroupPrefix + myClan.tag);
            myClan.BroadcastLoc("playerjoined", myClan.ColNam(current.Id, current.Name));
            myClan.updated = UnixTimeStampUTC();
            myClan.total++;
            myClan.OnUpdate();
            List<string> others = new List<string>(myClan.members.Keys);
            others.Remove(current.Id);
            Interface.Oxide.CallHook("OnClanMemberJoined", current.Id, others);
        }


        [ConsoleCommand("clanui_promote")]
        void cmdClanPromoteMember(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player == null) return;

            var clan = findClanByUser(player.UserIDString);
            if (!clan.IsOwner(player.UserIDString)) return;
            if (clan.owner == args.Args[1]) return;

            switch (args.Args[0].ToLower())
            {
                case "promote":
                    PromotePlayer(player, args.Args[1]);
                    break;
                case "demote":
                    DemotePlayer(player, args.Args[1]);
                    break;
            }

            var playerStats = clan.GetPlayerStats(args.Args[1]);
            if (playerStats == null) return;
            CreatePlayerInfo(player, clan, playerStats, args.Args[1]);
        }

        [ConsoleCommand("clanui_leader")]
        void cmdOwnerChange(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player == null) return;

            var clan = findClanByUser(player.UserIDString);
            if (!clan.IsOwner(player.UserIDString)) return;

            var promotePlayer = clan.GetIPlayer(args.Args[0]);
            if (promotePlayer == null) return;
            if (clan.IsOwner(promotePlayer.Id)) return;
            
            clan.moderators.Remove(promotePlayer.Id);
            clan.owner = promotePlayer.Id;
            clan.ownerName = promotePlayer.Name;
            clan.updated = UnixTimeStampUTC();
            clan.OnUpdate();

            var playerStats = clan.GetPlayerStats(args.Args[0]);
            if (playerStats == null) return;
            CreatePlayerInfo(player, clan, playerStats, args.Args[0]);
        }

        public void PromotePlayer(BasePlayer player, string targetId) => cmdClanPromote(player, new string[] { "", targetId });

        void cmdClanPromote(BasePlayer player, string[] args)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            if (myClan == null)
            {
                player.ChatMessage("У вас <color=red>нет</color> клана");
                return;
            }
            if (!myClan.IsOwner(current.Id))
            {
                PrintChat(player, string.Format(msg("needclanowner", current.Id)));
                return;
            }
            if (args.Length != 2)
            {
                PrintChat(player, string.Format(msg("usagepromote", current.Id), colorCmdUsage));
                return;
            }
            var promotePlayer = myClan.GetIMember(args[1]);
            if (promotePlayer == null)
            {
                PrintChat(player, string.Format(msg("nosuchplayer", current.Id), args[1]));
                return;
            }
            if (!myClan.IsMember(promotePlayer.Id))
            {
                PrintChat(player, string.Format(msg("notaclanmember", current.Id), promotePlayer.Name));
                return;
            }
            if (enableClanAllies && myClan.IsCouncil(promotePlayer.Id))
            {
                PrintChat(player, string.Format(msg("alreadyacouncil", current.Id), promotePlayer.Name));
                return;
            }
            if (enableClanAllies && myClan.council != null && myClan.IsModerator(promotePlayer.Id))
            {
                PrintChat(player, string.Format(msg("alreadyacouncilset", current.Id), promotePlayer.Name));
                return;
            }
            if (!enableClanAllies && myClan.IsModerator(promotePlayer.Id))
            {
                PrintChat(player, string.Format(msg("alreadyamod", current.Id), promotePlayer.Name));
                return;
            }
            if (!myClan.IsModerator(promotePlayer.Id) && limitModerators >= 0 && myClan.moderators.Count() >= limitModerators)
            {
                PrintChat(player, string.Format(msg("maximummods", current.Id)));
                return;
            }
            if (enableClanAllies && myClan.IsModerator(promotePlayer.Id))
            {
                myClan.council = promotePlayer.Id;
                myClan.moderators.Remove(promotePlayer.Id);
                myClan.BroadcastLoc("playerpromotedcouncil", myClan.ColNam(current.Id, current.Name), myClan.ColNam(promotePlayer.Id, promotePlayer.Name));
            }
            else
            {
                myClan.moderators.Add(promotePlayer.Id);
                myClan.BroadcastLoc("playerpromoted", myClan.ColNam(current.Id, current.Name), myClan.ColNam(promotePlayer.Id, promotePlayer.Name));
            }
            myClan.updated = UnixTimeStampUTC();
            myClan.OnUpdate();
        }
        public void DemotePlayer(BasePlayer player, string targetId) => cmdClanDemote(player, new string[] {
"", targetId
}
        );
        void cmdClanDemote(BasePlayer player, string[] args)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            if (myClan == null)
            {
                player.ChatMessage("У вас <color=red>нет</color> клана");
                return;
            }
            if (!myClan.IsOwner(current.Id))
            {
                PrintChat(player, string.Format(msg("needclanowner", current.Id)));
                return;
            }
            if (args.Length < 2)
            {
                PrintChat(player, string.Format(msg("usagedemote", current.Id), colorCmdUsage));
                return;
            }
            var demotePlayer = myClan.GetIMember(args[1]);
            if (demotePlayer == null)
            {
                PrintChat(player, string.Format(msg("nosuchplayer", current.Id), args[1]));
                return;
            }
            if (!myClan.IsMember(demotePlayer.Id))
            {
                PrintChat(player, string.Format(msg("notaclanmember", current.Id), demotePlayer.Name));
                return;
            }
            if (!myClan.IsModerator(demotePlayer.Id) && !myClan.IsCouncil(demotePlayer.Id))
            {
                PrintChat(player, string.Format(msg("notpromoted", current.Id), demotePlayer.Name));
                return;
            }
            if (enableClanAllies && myClan.IsCouncil(demotePlayer.Id))
            {
                myClan.council = null;
                if (limitModerators >= 0 && myClan.moderators.Count() >= limitModerators) myClan.BroadcastLoc("playerdemoted", myClan.ColNam(current.Id, current.Name), myClan.ColNam(demotePlayer.Id, demotePlayer.Name));
                else
                {
                    myClan.moderators.Add(demotePlayer.Id);
                    myClan.BroadcastLoc("councildemoted", myClan.ColNam(current.Id, current.Name), myClan.ColNam(demotePlayer.Id, demotePlayer.Name));
                }
            }
            else
            {
                myClan.moderators.Remove(demotePlayer.Id);
                myClan.BroadcastLoc("playerdemoted", myClan.ColNam(current.Id, current.Name), myClan.ColNam(demotePlayer.Id, demotePlayer.Name));
            }
            myClan.updated = UnixTimeStampUTC();
            myClan.OnUpdate();
        }
        public void LeaveClan(BasePlayer player) => cmdClanLeave(player, new string[] {
"leave"
}
        );
        void cmdClanLeave(BasePlayer player, string[] args)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            bool lastMember = false;
            if (myClan == null)
            {
                player.ChatMessage("У вас <color=red>нет</color> клана");
                return;
            }
            if (args.Length != 1)
            {
                player.ChatMessage("Используйте: <color=#ffde5a>/clan leave</color>");
                return;
            }
            if(myClan.IsOwner(current.Id))
            {
                player.ChatMessage("Вы <color=#ffde5a>являетесь</color> главой клана. С начала передайте лидера.");
                return;
            }
            if (myClan.members.Count() == 1)
            {
                RemoveClan(myClan.tag);
                lastMember = true;
            }
            else
            {
                if (myClan.IsCouncil(current.Id)) myClan.council = null;
                myClan.moderators.Remove(current.Id);
                myClan.members.Remove(current.Id);
                myClan.invites.Remove(current.Id);
                if (myClan.IsOwner(current.Id) && myClan.members.Count() > 0)
                {
                    myClan.owner = myClan.members.ToList()[0].Key;
                }
            }
            clanCache.Remove(current.Id);
            SetupPlayer(player, current, true, oldTag: myClan.tag);
            if (usePermGroups && permission.UserHasGroup(current.Id, permGroupPrefix + myClan.tag)) permission.RemoveUserGroup(current.Id, permGroupPrefix + myClan.tag);
            player.ChatMessage($"Вы покинули клан <color=#ffde5a>{myClan.tag}</color>");
            myClan.updated = UnixTimeStampUTC();
            myClan.total--;
            myClan.OnUpdate();
            if (lastMember) myClan.OnDestroy();
            if (!lastMember) Interface.CallHook("OnClanMemberGone", UInt64.Parse(current.Id), myClan.tag);
            //if (!lastMember) Interface.Oxide.CallHook("OnClanMemberGone", current.Id, myClan.members.ToList());
        }
        public void KickPlayer(BasePlayer player, string targetId) => cmdClanKick(player, new string[] {
"", targetId
}
        );
        void cmdClanKick(BasePlayer player, string[] args)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            if (myClan == null)
            {
                player.ChatMessage("У вас <color=red>нет</color> клана");
                return;
            }
            if (!myClan.IsOwner(current.Id) && !myClan.IsCouncil(current.Id) && !myClan.IsModerator(current.Id))
            {
                PrintChat(player, string.Format(msg("notmoderator", current.Id)));
                return;
            }
            if (args.Length != 2)
            {
                PrintChat(player, string.Format(msg("usagekick", current.Id), colorCmdUsage));
                return;
            }
            var kickPlayer = myClan.GetIMember(args[1]);
            if (kickPlayer == null)
            {
                PrintChat(player, string.Format(msg("nosuchplayer", current.Id), args[1]));
                return;
            }
            if (!myClan.IsMember(kickPlayer.Id) && !myClan.IsInvited(kickPlayer.Id))
            {
                PrintChat(player, string.Format(msg("notmembercannotkicked", current.Id), kickPlayer.Name));
                return;
            }
            if (myClan.IsOwner(kickPlayer.Id) || myClan.IsCouncil(kickPlayer.Id) || myClan.IsModerator(kickPlayer.Id))
            {
                PrintChat(player, string.Format(msg("modownercannotkicked", current.Id), kickPlayer.Name));
                return;
            }
            foreach (var value in myClan.members)
            {
                var turrets = UnityEngine.Object.FindObjectsOfType<AutoTurret>();
                foreach (var turret in turrets)
                {
                    if (turret.OwnerID != ulong.Parse(value.Key)) continue;
                    turret.authorizedPlayers.RemoveAll(a => a.userid == ulong.Parse(kickPlayer.Id));
                }
            }
            if (myClan.members.ContainsKey(kickPlayer.Id)) myClan.total--;
            myClan.members.Remove(kickPlayer.Id);
            myClan.invites.Remove(kickPlayer.Id);
            if (pendingPlayerInvites.ContainsKey(kickPlayer.Id)) pendingPlayerInvites[kickPlayer.Id].Remove(myClan.tag);
            clanCache.Remove(kickPlayer.Id);
            var kickBasePlayer = BasePlayer.Find(kickPlayer.Id);

            if (kickBasePlayer != null)
            {
                SetupPlayer(kickBasePlayer, kickPlayer, true, oldTag: myClan.tag);
            }
            if (usePermGroups && permission.UserHasGroup(kickPlayer.Id, permGroupPrefix + myClan.tag)) permission.RemoveUserGroup(kickPlayer.Id, permGroupPrefix + myClan.tag);
            myClan.BroadcastLoc("waskicked", myClan.ColNam(current.Id, current.Name), myClan.ColNam(kickPlayer.Id, kickPlayer.Name));
            myClan.updated = UnixTimeStampUTC();
            myClan.OnUpdate();
            Interface.CallHook("OnClanMemberGone", UInt64.Parse(kickPlayer.Id), myClan.tag);
        }
        public void DisbandClan(BasePlayer player) => cmdClanDisband(player, new string[] {
"disband", "forever"
}
        );
        void cmdClanDisband(BasePlayer player, string[] args)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            bool lastMember = false;
            if (myClan == null)
            {
                player.ChatMessage("У вас <color=red>нет</color> клана");
                return;
            }
            if (!myClan.IsOwner(current.Id))
            {
                player.ChatMessage("Вы не глава вашего клана!");
                return;
            }
            if (args.Length != 2)
            {
                player.ChatMessage("Чтобы подтвердить удаление клана введите <color=red>/clan disband yes</color>");
                return;
            }
            if (myClan.members.Count() == 1)
            {
                lastMember = true;
            }
            setupPlayers(myClan.members.Keys.ToList(), true, myClan.tag);

            RemoveClan(myClan.tag);
            foreach (var member in myClan.members)
            {
                clanCache.Remove(member.Key);
                if (usePermGroups && permission.UserHasGroup((string)member.Key, permGroupPrefix + myClan.tag)) permission.RemoveUserGroup((string)member.Key, permGroupPrefix + myClan.tag);
            }
            player.ChatMessage("Клан успешно <color=red>удален</color>");

            foreach (var ally in clans)
            {
                Clan allyClan = clans[ally.Key];
                allyClan.clanAlliances.Remove(myClan.tag);
                allyClan.invitedAllies.Remove(myClan.tag);
                allyClan.pendingInvites.Remove(myClan.tag);
            }
            if (usePermGroups && permission.GroupExists(permGroupPrefix + myClan.tag)) permission.RemoveGroup(permGroupPrefix + myClan.tag);
            myClan.OnDestroy();
            AllyRemovalCheck();
            if (!lastMember)
            {
                List<UInt64> MemberListUInt64 = new List<UInt64>();
                MemberListUInt64 = myClan.members.Select(x => Convert.ToUInt64(x.Key)).ToList();
                Interface.Oxide.CallHook("OnClanDisbanded", myClan.tag, MemberListUInt64);
            }
        }
        public void Alliance(BasePlayer player, string targetClan, string type) => cmdChatClanAlly(player, "ally", new string[] {
type, targetClan
}
        );
        void cmdChatClanAlly(BasePlayer player, string command, string[] args)
        {
            if (!enableClanAllies || player == null) return;
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            if (myClan == null)
            {
                player.ChatMessage("У вас <color=red>нет</color> клана");
                return;
            }
            if (!myClan.IsOwner(current.Id) && !myClan.IsCouncil(current.Id))
            {
                PrintChat(player, string.Format(msg("needclanownercouncil", current.Id)));
                return;
            }
            if (args == null || args.Length == 0)
            {
                var sbally = new StringBuilder();

                string Messages = pluginPrefixREBORNShow == true ? $"<size=14><color={pluginPrefixREBORNColor}>REBORN\n</color></size>" : "\n";
                sbally.Append($"<size=18><color={pluginPrefixColor}>{this.Title}</color></size>{Messages}");
                sbally.Append($"<color={colorTextMsg}>");
                if (myClan.IsOwner(current.Id)) sbally.Append(string.Format(msg("youareownerof", current.Id)));
                else if (myClan.IsCouncil(current.Id)) sbally.Append(string.Format(msg("youarecouncilof", current.Id)));
                else if (myClan.IsModerator(current.Id)) sbally.Append(string.Format(msg("youaremodof", current.Id)));
                else sbally.Append(string.Format(msg("youarememberof", current.Id)));
                sbally.AppendLine($" <color={colorClanNamesOverview}>{myClan.tag}</color> ( {myClan.online}/{myClan.total} )");
                if (myClan.clanAlliances.Count() > 0) sbally.AppendLine(string.Format(msg("yourclanallies", current.Id)) + $" <color={colorClanNamesOverview}>" + string.Join(", ", myClan.clanAlliances.ToArray()) + "</color>");
                if ((myClan.invitedAllies.Count() > 0 || myClan.pendingInvites.Count() > 0) && (myClan.IsOwner(current.Id) || myClan.IsCouncil(current.Id)))
                {
                    if (myClan.invitedAllies.Count() > 0) sbally.Append(string.Format(msg("allyinvites", current.Id)) + $" <color={colorClanNamesOverview}>" + string.Join(", ", myClan.invitedAllies.ToArray()) + "</color> ");
                    if (myClan.pendingInvites.Count() > 0) sbally.Append(string.Format(msg("allypending", current.Id)) + $" <color={colorClanNamesOverview}>" + string.Join(", ", myClan.pendingInvites.ToArray()) + "</color> ");
                    sbally.AppendLine();
                }
                string commandtext = string.Empty;
                if (command.Contains("ally")) commandtext = command;
                else commandtext = chatCommandClan + " ally";
                sbally.AppendLine($"<color={colorCmdUsage}>/{commandtext} <{msg("allyArgRequest", current.Id)} | {msg("allyArgRequestShort", current.Id)}> <clantag></color>");
                sbally.AppendLine(" " + msg("allyReqHelp", current.Id));
                sbally.AppendLine($"<color={colorCmdUsage}>/{commandtext} <{msg("allyArgAccept", current.Id)} | {msg("allyArgAcceptShort", current.Id)}> <clantag></color>");
                sbally.AppendLine(" " + msg("allyAccHelp", current.Id));
                sbally.AppendLine($"<color={colorCmdUsage}>/{commandtext} <{msg("allyArgDecline", current.Id)} | {msg("allyArgDeclineShort", current.Id)}> <clantag></color>");
                sbally.AppendLine(" " + msg("allyDecHelp", current.Id));
                sbally.AppendLine($"<color={colorCmdUsage}>/{commandtext} <{msg("allyArgCancel", current.Id)} | {msg("allyArgCancelShort", current.Id)}> <clantag></color>");
                sbally.AppendLine(" " + msg("allyCanHelp", current.Id));
                sbally.Append("</color>");
                SendReply(player, sbally.ToString().TrimEnd());
                return;
            }
            else if (args != null && args.Length >= 1 && args.Length < 2)
            {
                PrintChat(player, string.Format(msg("allyProvideName", current.Id)));
                return;
            }
            else if (args.Length >= 1)
            {
                Clan targetClan = null;
                string opt = args[0];
                if (opt == msg("allyArgRequest", current.Id) || opt == msg("allyArgRequestShort", current.Id))
                {
                    if (limitAlliances != 0 && myClan.clanAlliances.Count >= limitAlliances)
                    {
                        PrintChat(player, string.Format(msg("allyLimit", current.Id)));
                        return;
                    }
                    if (myClan.invitedAllies.Contains(args[1]))
                    {
                        PrintChat(player, string.Format(msg("invitePending", current.Id), args[1]));
                        return;
                    }
                    if (myClan.clanAlliances.Contains(args[1]))
                    {
                        PrintChat(player, string.Format(msg("alreadyAllies", current.Id)));
                        return;
                    }
                    targetClan = findClan(args[1]);
                    if (targetClan == null)
                    {
                        PrintChat(player, string.Format(msg("clanNoExist", current.Id), args[1]));
                        return;
                    }
                    targetClan.pendingInvites.Add(myClan.tag);
                    myClan.invitedAllies.Add(targetClan.tag);
                    PrintChat(player, string.Format(msg("allyReq", current.Id), args[1]));
                    targetClan.AllyBroadcastLoc("reqAlliance", myClan.tag);
                    myClan.OnUpdate();
                    targetClan.OnUpdate();
                    return;
                }
                else if (opt == msg("allyArgAccept", current.Id) || opt == msg("allyArgAcceptShort", current.Id))
                {
                    if (!myClan.pendingInvites.Contains(args[1]))
                    {
                        PrintChat(player, string.Format(msg("noAllyInv", current.Id), args[1]));
                        return;
                    }
                    targetClan = findClan(args[1]);
                    if (targetClan == null)
                    {
                        PrintChat(player, string.Format(msg("clanNoExist", current.Id), args[1]));
                        return;
                    }
                    if (limitAlliances != 0 && myClan.clanAlliances.Count >= limitAlliances)
                    {
                        PrintChat(player, string.Format(msg("allyAccLimit", current.Id), targetClan.tag));
                        targetClan.invitedAllies.Remove(myClan.tag);
                        myClan.pendingInvites.Remove(targetClan.tag);
                        return;
                    }
                    targetClan.invitedAllies.Remove(myClan.tag);
                    targetClan.clanAlliances.Add(myClan.tag);
                    myClan.pendingInvites.Remove(targetClan.tag);
                    myClan.clanAlliances.Add(targetClan.tag);
                    myClan.OnUpdate();
                    targetClan.OnUpdate();
                    PrintChat(player, string.Format(msg("allyAcc", current.Id), targetClan.tag));
                    targetClan.AllyBroadcastLoc("allyAccSucc", myClan.tag);
                    return;
                }
                else if (opt == msg("allyArgDeclineallyArgDecline", current.Id) || opt == msg("allyArgDeclineShort", current.Id))
                {
                    if (!myClan.pendingInvites.Contains(args[1]))
                    {
                        PrintChat(player, string.Format(msg("noAllyInv", current.Id), args[1]));
                        return;
                    }
                    targetClan = findClan(args[1]);
                    if (targetClan == null)
                    {
                        PrintChat(player, string.Format(msg("clanNoExist", current.Id), args[1]));
                        return;
                    }
                    targetClan.invitedAllies.Remove(myClan.tag);
                    myClan.pendingInvites.Remove(targetClan.tag);
                    AllyRemovalCheck();
                    PrintChat(player, string.Format(msg("allyDeclined", current.Id), args[1]));
                    myClan.OnUpdate();
                    targetClan.OnUpdate();
                    targetClan.AllyBroadcastLoc("allyDeclinedSucc", myClan.tag);
                    return;
                }
                else if (opt == msg("allyArgCancel", current.Id) || opt == msg("allyArgCancelShort", current.Id))
                {
                    if (!myClan.clanAlliances.Contains(args[1]))
                    {
                        if (myClan.invitedAllies.Contains(args[1]))
                        {
                            myClan.invitedAllies.Remove(args[1]);
                            targetClan = findClan(args[1]);
                            if (targetClan != null) targetClan.pendingInvites.Remove(myClan.tag);
                            PrintChat(player, string.Format(msg("allyInvWithdraw", current.Id), args[1]));
                            myClan.OnUpdate();
                            targetClan.OnUpdate();
                            return;
                        }
                        PrintChat(player, string.Format(msg("noAlly", current.Id)));
                        return;
                    }
                    targetClan = findClan(args[1]);
                    if (targetClan == null)
                    {
                        PrintChat(player, string.Format(msg("clanNoExist", current.Id), args[1]));
                        return;
                    }
                    targetClan.clanAlliances.Remove(myClan.tag);
                    myClan.clanAlliances.Remove(targetClan.tag);
                    AllyRemovalCheck();
                    PrintChat(player, string.Format(msg("allyCancel", current.Id), args[1]));
                    myClan.OnUpdate();
                    targetClan.OnUpdate();
                    targetClan.AllyBroadcastLoc("allyCancelSucc", myClan.tag);
                    return;
                }
                else cmdChatClanAlly(player, command, new string[] { }
                );
            }
        }
        void cmdChatClanHelp(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            var sb = new StringBuilder();
            if (myClan == null)
            {
                sb.Append($"<color={colorTextMsg}>");
                sb.AppendLine(msg("helpavailablecmds", current.Id));
                sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgCreate", current.Id)} \"TAG\" \"Description\"</color> - {msg("helpcreate", current.Id)}");
                sb.Append($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgJoin", current.Id)} \"TAG\"</color> - {msg("helpjoin", current.Id)}");
                sb.Append("</color>");
                SendReply(player, sb.ToString().TrimEnd());
                return;
            }
            sb.AppendLine(msg("helpavailablecmds", current.Id));
            sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan}</color> - {msg("helpinformation", current.Id)}");
            sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClanChat} <msg></color> - {msg("helpmessagemembers", current.Id)}");
            if (enableClanAllies) sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandAllyChat} <msg></color> - {msg("helpmessageally", current.Id)}");
            sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgLeave", current.Id)}</color> - {msg("helpleave", current.Id)}");
            if (enableFFOPtion) sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgFF", current.Id)} |  /{chatCommandFF}</color> - {msg("helptoggleff", current.Id)}");
            if ((myClan.IsOwner(current.Id) || myClan.IsCouncil(current.Id) || myClan.IsModerator(current.Id)))
            {
                sb.AppendLine($"<color={clanModeratorColor}>{msg("helpmoderator", current.Id)}</color> {msg("helpcommands", current.Id)}");
                sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgInvite", current.Id)} {msg("clanArgNameId", current.Id)}</color> - {msg("helpinvite", current.Id)}");
                sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgWithdraw", current.Id)} {msg("clanArgNameId", current.Id)}</color> - {msg("helpwithdraw", current.Id)}");
                sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgKick", current.Id)} {msg("clanArgNameId", current.Id)}</color> - {msg("helpkick", current.Id)}");
            }
            if ((myClan.IsOwner(current.Id) || (enableClanAllies && myClan.IsCouncil(current.Id))))
            {
                sb.AppendLine($"<color={clanOwnerColor}>{msg("helpowner", current.Id)}</color> {msg("helpcommands", current.Id)}");
                if (enableClanAllies) sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgAlly", current.Id)} | {chatCommandClan + "ally"}</color> - {msg("helpallyoptions", current.Id)}");
                if (myClan.IsOwner(current.Id)) sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgPromote", current.Id)} {msg("clanArgNameId", current.Id)}</color> - {msg("helppromote", current.Id)}");
                if (myClan.IsOwner(current.Id)) sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgDemote", current.Id)} {msg("clanArgNameId", current.Id)}</color> - {msg("helpdemote", current.Id)}");
                if (myClan.IsOwner(current.Id)) sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgDisband", current.Id)} {msg("clanArgForever", current.Id)}</color> - {msg("helpdisband", current.Id)}");
            }
            if (player.net.connection.authLevel >= authLevelDelete || player.net.connection.authLevel >= authLevelRename || player.net.connection.authLevel >= authLevelInvite || player.net.connection.authLevel >= authLevelKick || player.net.connection.authLevel >= authLevelPromoteDemote) sb.AppendLine($"<color={clanServerColor}>Server management</color>: {msg("helpconsole", current.Id)} <color={colorCmdUsage}>BEE RUST</color>");
            string openText = $"<color={colorTextMsg}>";
            string closeText = "</color>";
            string[] parts = sb.ToString().Split(new char[] {
'\n'
}
            , StringSplitOptions.RemoveEmptyEntries);
            sb = new StringBuilder();
            foreach (var part in parts)
            {
                if ((sb.ToString().TrimEnd().Length + part.Length + openText.Length + closeText.Length) > 1050)
                {
                    SendReply(player, openText + sb.ToString().TrimEnd() + closeText);
                    sb.Clear();
                }
                sb.AppendLine(part);
            }
            SendReply(player, openText + sb.ToString().TrimEnd() + closeText);
        }
        void cmdChatClanInfo(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;
            if (player.net.connection.authLevel < authLevelClanInfo)
            {
                PrintChat(player, "No access to this command.");
                return;
            }
            if (args == null || args.Length == 0)
            {
                PrintChat(player, "Please specify a clan tag.");
                return;
            }
            var Clan = findClan(args[0]);
            if (Clan == null)
            {
                PrintChat(player, string.Format(msg("clanNoExist", player.UserIDString), args[0]));
                return;
            }
            var sb = new StringBuilder();
            string Messages = pluginPrefixREBORNShow == true ? $"<size=14><color= {pluginPrefixREBORNColor}>REBORN\n</color></size>" : "\n";
            sb.Append($"<size=18><color={pluginPrefixColor}>{this.Title}</color></size>{Messages}");
            sb.AppendLine($"<color={colorTextMsg}>Detailed clan information for:");
            sb.AppendLine($"ClanTag:  <color={colorClanNamesOverview}>{Clan.tag}</color> ( Online: <color={colorClanNamesOverview}>{Clan.online}</color> / Total: <color={colorClanNamesOverview}>{Clan.total}</color> )");
            sb.AppendLine($"Description: <color={colorClanNamesOverview}>{Clan.description}</color>");
            sb.Append(string.Format(msg("memberon", player.UserIDString)));
            int n = 0;
            foreach (var memberId in Clan.members)
            {
                var op = this.covalence.Players.FindPlayerById(memberId.Key);
                if (op != null && op.IsConnected)
                {
                    if (n > 0) sb.Append(", ");
                    if (Clan.IsOwner(memberId.Key))
                    {
                        sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanOwnerColor, op.Name));
                    }
                    else if (Clan.IsCouncil(memberId.Key))
                    {
                        sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanCouncilColor, op.Name));
                    }
                    else if (Clan.IsModerator(memberId.Key))
                    {
                        sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanModeratorColor, op.Name));
                    }
                    else
                    {
                        sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanMemberColor, op.Name));
                    }
                    ++n;
                }
            }
            if (Clan.online == 0) sb.Append(" - ");
            sb.Append("</color>\n");
            bool offline = false;
            foreach (var memberId in Clan.members)
            {
                var op = this.covalence.Players.FindPlayerById(memberId.Key);
                if (op != null && !op.IsConnected)
                {
                    offline = true;
                    break;
                }
            }
            if (offline)
            {
                sb.Append(string.Format(msg("memberoff", player.UserIDString)));
                n = 0;
                foreach (var memberId in Clan.members)
                {
                    var p = this.covalence.Players.FindPlayerById(memberId.Key);
                    if (p != null && !p.IsConnected)
                    {
                        if (n > 0) sb.Append(", ");
                        if (Clan.IsOwner(memberId.Key))
                        {
                            sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanOwnerColor, p.Name));
                        }
                        else if (Clan.IsCouncil(memberId.Key))
                        {
                            sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanCouncilColor, p.Name));
                        }
                        else if (Clan.IsModerator(memberId.Key))
                        {
                            sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanModeratorColor, p.Name));
                        }
                        else
                        {
                            sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanMemberColor, p.Name));
                        }
                        ++n;
                    }
                }
                sb.Append("\n");
            }
            sb.AppendLine($"Time created: <color={colorClanNamesOverview}>{UnixTimeStampToDateTime(Clan.created)}</color>");
            sb.AppendLine($"Last change: <color={colorClanNamesOverview}>{UnixTimeStampToDateTime(Clan.updated)}</color>");
            SendReply(player, sb.ToString().TrimEnd());
        }

        public Dictionary<ulong, double> ClanChatCD = new Dictionary<ulong, double>();

        void cmdChatClanchat(BasePlayer player, string command, string[] args)
        {
            if (player == null || args.Length == 0) return;
            var myClan = findClanByUser(player.UserIDString);
            if (myClan == null)
            {
                player.ChatMessage("Чтобы использовать клановый чат нужно в него вступить!");
                return;
            }
            if (clanChatDenyOnMuted)
            {
                var current = this.covalence.Players.FindPlayerById(player.UserIDString);
                var chk = Interface.CallHook("API_IsMuted", current);
                if (chk != null && chk is bool && (bool)chk)
                {
                    SendReply(player, string.Format(msg("clanchatmuted", player.UserIDString)));
                    return;
                }
            }
            var message = string.Join(" ", args);
            if (message.Length > 20)
            {
                player.ChatMessage("Сообщение клану должно быть не больше 20 символов");
                return;
            }
            if (ClanChatCD.ContainsKey(player.userID))
            {
                var left = ClanChatCD[player.userID] - CurrentTime();
                if (left <= 0)
                    ClanChatCD.Remove(player.userID);
                else
                {
                    player.ChatMessage($"Вы не можете отправить сообщение клану еще {TimeSpan.FromSeconds(left).ToShortString()} секунд!");
                    return;
                }
            }
            if (!ClanChatCD.ContainsKey(player.userID))
                ClanChatCD.Add(player.userID, CurrentTime() + 5);
            if (string.IsNullOrEmpty(message)) return;
            myClan.BroadcastChat(string.Format(msg("broadcastformat"), myClan.PlayerColor(player.UserIDString), player.net.connection.username, message));
            if (ConVar.Chat.serverlog) DebugEx.Log(string.Format("[CHAT] CLAN [{0}] - {1}: {2}", myClan.tag, player.net.connection.username, message), StackTraceLogType.None);
        }

        void cmdChatAllychat(BasePlayer player, string command, string[] args)
        {
            if (player == null || args.Length == 0) return;
            var myClan = findClanByUser(player.UserIDString);
            if (myClan == null)
            {
                player.ChatMessage("Чтобы использовать клановый чат нужно в него вступить!");
                return;
            }
            if (myClan.clanAlliances.Count == 0)
            {
                PrintChat(player, string.Format(msg("noactiveally", player.UserIDString)));
                return;
            }
            if (clanChatDenyOnMuted)
            {
                var current = this.covalence.Players.FindPlayerById(player.UserIDString);
                var chk = Interface.CallHook("API_IsMuted", current);
                if (chk != null && chk is bool && (bool)chk)
                {
                    SendReply(player, string.Format(msg("clanchatmuted", player.UserIDString)));
                    return;
                }
            }
            var message = string.Join(" ", args);
            if (string.IsNullOrEmpty(message)) return;
            if (message.Length > 20)
            {
                player.ChatMessage("Сообщение альянсу должно быть не больше 20 символов");
                return;
            }
            if (ClanChatCD.ContainsKey(player.userID))
            {
                var left = ClanChatCD[player.userID] - CurrentTime();
                if (left <= 0)
                    ClanChatCD.Remove(player.userID);
                else
                {
                    player.ChatMessage($"Вы не можете отправить сообщение альянсов еще {TimeSpan.FromSeconds(left).ToShortString()} секунд!");
                    return;
                }
            }
            if (!ClanChatCD.ContainsKey(player.userID))
                ClanChatCD.Add(player.userID, CurrentTime() + 5);
            foreach (var clanAllyName in myClan.clanAlliances)
            {
                var clanAlly = findClan(clanAllyName);
                if (clanAlly == null) continue;
                clanAlly.AllyBroadcastChat(string.Format(msg("allybroadcastformat"), myClan.tag, myClan.PlayerColor(player.UserIDString), player.net.connection.username, message));
            }
            myClan.AllyBroadcastChat(string.Format(msg("broadcastformat"), myClan.PlayerColor(player.UserIDString), player.net.connection.username, message));
            if (ConVar.Chat.serverlog) DebugEx.Log(string.Format("[CHAT] ALLY [{0}] - {1}: {2}", myClan.tag, player.net.connection.username, message), StackTraceLogType.None);
        }

        void cmdChatClanFF(BasePlayer player, string command, string[] args)
        {
            if (!enableFFOPtion || player == null) return;
            var myClan = findClanByUser(player.UserIDString);
            if (myClan == null)
            {
                player.ChatMessage("У вас <color=red>нет</color> клана");
                return;
            }
            if (manuallyEnabledBy.Contains(player.userID))
            {
                manuallyEnabledBy.Remove(player.userID);
                PrintChat(player, string.Format(msg("clanffdisabled", player.UserIDString), colorClanFFOff));
                return;
            }
            else
            {
                manuallyEnabledBy.Add(player.userID);
                PrintChat(player, string.Format(msg("clanffenabled", player.UserIDString), colorClanFFOn));
                return;
            }
        }
        public bool HasFFEnabled(ulong playerid = 5931008) => !enableFFOPtion ? false : !manuallyEnabledBy.Contains(playerid) ? false : true;
        public void ToggleFF(ulong playerId)
        {
            if (manuallyEnabledBy.Contains(playerId)) manuallyEnabledBy.Remove(playerId);
            else manuallyEnabledBy.Add(playerId);
        }

        [ProtoContract(ImplicitFields = ImplicitFields.AllFields)]
        class StoredData
        {
            public Dictionary<string, Clan> clans = new Dictionary<string, Clan>();
            public Int32 saveStamp = 0;
            public string lastStorage = string.Empty;
            public StoredData() { }
        }

        StoredData clanSaves = new StoredData();

        public class ChangeListed
        {
            public int Need { get; set; }
            public int Complete { get; set; }
        }

        public class MembersChangeList
        {
            public int Complete { get; set; }
        }

        public class PlayerStats
        {
            public int PlayerPoints = 0;
            public int Killed = 0;
            public int Death = 0;
            public int Suicide = 0;
            public int PlayTimeInServer = 0;
            public DateTime LastLogin = DateTime.Now;
            public bool CupAuth = true;
            public bool CodeAuth = true;
            public bool TurretAuth = true;

            public Dictionary<string, int> GatherInfo = new Dictionary<string, int>()
            {
                { "wood", 0 },
                { "stones", 0 },
                { "metal.ore", 0 },
                { "sulfur.ore", 0},
                { "hq.metal.ore", 0 },
                { "cloth", 0},
                {"leather", 0},
                {"fat.animal", 0},
                {"loot-barrel", 0}
            };
        }
        [ProtoContract(ImplicitFields = ImplicitFields.AllFields)]
        public class Clan
        {
            public int ClanPoints = 0;
            public string Task;
            public int KillC = 0;
            public int DeathC = 0;

            public int Cupboard = 0;
            public int SamSite = 0;
            public int Turret = 0;
            public int Building = 0;

            public string tag;
            public string description;
            public string owner;
            public string ownerName;
            public string council;
            public int created;
            public int updated;

            [JsonIgnore, ProtoIgnore] public int online;
            [JsonIgnore, ProtoIgnore] public int total;
            [JsonIgnore, ProtoIgnore] public int mods;
            public List<string> moderators = new List<string>();
            public Dictionary<string, PlayerStats> members = new Dictionary<string, PlayerStats>();

            public Dictionary<string, int> invites = new Dictionary<string, int>();
            public List<string> clanAlliances = new List<string>();
            public List<string> invitedAllies = new List<string>();
            public List<string> pendingInvites = new List<string>();
            //TEAM

            [JsonIgnore]
            [ProtoIgnore]
            private string currentTeamLeader => owner;

            [JsonIgnore]
            [ProtoIgnore]
            private bool wasDisbanded = false;

            [JsonIgnore]
            [ProtoIgnore]
            private RelationshipManager.PlayerTeam _playerTeam;

            [JsonIgnore]
            [ProtoIgnore]
            public RelationshipManager.PlayerTeam PlayerTeam
            {
                get
                {
                    if (_playerTeam == null)
                        _playerTeam = RelationshipManager.ServerInstance.CreateTeam();

                    return _playerTeam;
                }
            }


            public void RemoveModerator(object obj)
            {
                string Id = GetObjectId(obj);
                moderators.Remove(Id);
            }

            private string GetObjectId(object obj)
            {
                if (obj is BasePlayer)
                    return (obj as BasePlayer).UserIDString;

                else if (obj is IPlayer)
                    return (obj as IPlayer).Id;

                return (string)obj;
            }

            internal void OnCreate()
            {
                OnUpdate();
                Interface.CallHook("OnClanCreate", tag);
            }

            public static int UnixTimeStampUTC()
            {
                return (int)DateTime.UtcNow.Subtract(Epoch).TotalSeconds;
            }

            internal void OnUpdate(bool hasChanges = true)
            {
                if (hasChanges)
                {
                    updated = UnixTimeStampUTC();
                    UpdateTeam();
                }

                UpdateOnline();


                Interface.CallHook("OnClanUpdate", tag);
            }

            private static DateTime Epoch = new DateTime(1970, 1, 1);

            public void DisbandTeam()
            {
                wasDisbanded = true;

                DestroyPlayerTeam();
            }

            internal void OnDestroy()
            {
                DestroyPlayerTeam();
                Interface.CallHook("OnClanDestroy", tag);
            }

            internal void OnUnload()
            {
                DestroyPlayerTeam();
            }

            internal void UpdateTeam()
            {
                if (!useRelationshipManager || wasDisbanded)
                    return;

                PlayerTeam.teamLeader = cc.disableManageFunctions || !cc.allowButtonKick ? 0UL : Convert.ToUInt64(owner);

                for (int i = 0; i < PlayerTeam.members.Count; i++)
                {
                    ulong playerId = PlayerTeam.members[i];

                    if (!members.ContainsKey(playerId.ToString()))
                    {
                        PlayerTeam.RemovePlayer(playerId);

                        (BasePlayer.FindByID(playerId) ?? BasePlayer.FindSleeping(playerId))?.ClearTeam();

                        RelationshipManager.ServerInstance.playerToTeam.Remove(playerId);

                    }
                }

                foreach (var member in members)
                {
                    ulong playerId = ulong.Parse(member.Key);

                    BasePlayer player = BasePlayer.FindByID(playerId) ?? BasePlayer.FindSleeping(playerId);

                    if (!PlayerTeam.members.Contains(playerId))
                    {
                        RelationshipManager.ServerInstance.playerToTeam.Remove(playerId);

                        if (player != null)
                        {
                            player.ClearTeam();
                            PlayerTeam.AddPlayer(player);
                        }
                    }
                }
                PlayerTeam.MarkDirty();
            }

            void UpdateOnline()
            {
                var onlineCount = members.Where(p => BasePlayer.Find(p.Key) != null && BasePlayer.Find(p.Key).IsConnected).Count();
                online = onlineCount;
            }

            private void DestroyPlayerTeam()
            {
                if (_playerTeam != null)
                {
                    for (int i = _playerTeam.members.Count - 1; i >= 0; i--)
                    {
                        _playerTeam.RemovePlayer(_playerTeam.members[i]);
                    }
                }

                _playerTeam = null;
            }

            public string GetColoredName(string Id, string Name)
            {
                if (IsOwner(Id))
                    return $"<color={cc.clanOwnerColor}>{Name}</color>";

                else if (IsCouncil(Id) && !IsOwner(Id))
                    return $"<color={cc.clanCouncilColor}>{Name}</color>";

                else if (IsModerator(Id) && !IsOwner(Id))
                    return $"<color={cc.clanModeratorColor}>{Name}</color>";

                else return $"<color={cc.clanMemberColor}>{Name}</color>";
            }

            //*TEAM

            public IPlayer FindClanMember(string nameOrId)
            {
                IPlayer player = cc.covalence.Players.FindPlayer(nameOrId);
                if (members.ContainsKey(player.Id))
                    return player;
                return null;
            }

            [JsonIgnore]
            [ProtoIgnore]
            public List<BasePlayer> membersBasePlayer = new List<BasePlayer>();

            public void AddBasePlayer(BasePlayer basePlayer, bool flag = false)
            {
                if (!membersBasePlayer.Any((BasePlayer x) => x.UserIDString == basePlayer.UserIDString))
                {
                    membersBasePlayer.Add(basePlayer);
                }
                else
                {
                    membersBasePlayer.RemoveAll((BasePlayer x) => x.UserIDString == basePlayer.UserIDString);
                    membersBasePlayer.Add(basePlayer);
                }
            }

            public void RemoveBasePlayer(BasePlayer basePlayer, bool flag = false)
            {
                if (membersBasePlayer.Any((BasePlayer x) => x.UserIDString == basePlayer.UserIDString))
                {
                    membersBasePlayer.RemoveAll((BasePlayer x) => x.UserIDString == basePlayer.UserIDString);
                }
            }

            public BasePlayer GetBasePlayer(string Id)
            {
                BasePlayer lookup = membersBasePlayer.Find((BasePlayer x) => x.UserIDString == Id);
                if (lookup)
                    return lookup;

                lookup = RustCore.FindPlayerByIdString(Id);

                if (lookup)
                    AddBasePlayer(lookup);

                return lookup;
            }

            public void SetModerator(object obj)
            {
                RemoveModerator(obj);
                string Id = GetObjectId(obj);
                moderators.Add(Id);
            }

            public Dictionary<string, Dictionary<string, ulong>> SkinList = new Dictionary<string, Dictionary<string, ulong>>();
            public Dictionary<string, ChangeListed> Change = new Dictionary<string, ChangeListed>()
            {
                ["wood"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 0
                },
                ["stones"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 0
                },
                ["metal.ore"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 0
                },
                ["sulfur.ore"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 0
                },
                ["hq.metal.ore"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 0
                },
                ["cloth"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 0
                },
                ["leather"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 0
                },
                ["fat.animal"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 0
                },
                ["loot-barrel"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 0
                },
            };


            public PlayerStats GetPlayerStats(string playerid)
            {
                if (!members.ContainsKey(playerid)) return null;
                else
                    return members[playerid];
            }

            public static Clan Create(string tag, string description, string ownerId, string owName, string URL)
            {
                var clan = new Clan()
                {
                    ClanPoints = 0,
                    KillC = 0,
                    DeathC = 0,

                    Cupboard = 0,
                    SamSite = 0,
                    Turret = 0,
                    Building = 0,

                    Task = string.Empty,
                    tag = tag,
                    description = description,
                    owner = ownerId,
                    ownerName = owName,
                    created = cc.UnixTimeStampUTC(),
                    updated = cc.UnixTimeStampUTC(),
                    SkinList = new Dictionary<string, Dictionary<string, ulong>>()
                    {
                        ["wear"] = new Dictionary<string, ulong>()
                        {
                             {"hoodie", 0 },
                             {"pants", 0 },
                             {"shoes.boots", 0 },
                             {"metal.facemask", 0},
                             {"metal.plate.torso", 0 },
                             {"roadsign.kilt", 0 },
                             {"rifle.ak", 0 },
                             {"lmg.m249", 0 },
                             {"rifle.l96", 0 },
                             {"coffeecan.helmet", 0 },
                             {"roadsign.jacket", 0 },
                             {"smg.mp5", 0 },
                             {"rifle.m39", 0 },
                             {"smg.thompson", 0 },
                             {"rifle.semiauto", 0 },
                             {"smg.2", 0 },
                             {"pistol.semiauto", 0 },
                             {"pistol.python", 0 },
                             {"rocket.launcher", 0 },
                             {"door.double.hinged.toptier", 1882005499 },
                             {"door.hinged.toptier", 813882180 },
                        },
                    },
                    Change = new Dictionary<string, ChangeListed>()
                    {
                        ["wood"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 0
                        },
                        ["stones"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 0
                        },
                        ["metal.ore"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 0
                        },
                        ["sulfur.ore"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 0
                        },
                        ["hq.metal.ore"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 0
                        },
                        ["cloth"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 0
                        },
                        ["leather"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 0
                        },
                        ["fat.animal"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 0
                        },
                        ["loot-barrel"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 0
                        },
                    }
                };
                clan.members.Add(ownerId, new PlayerStats());
                return clan;
            }
            public bool IsOwner(string userId)
            {
                return userId == owner;
            }
            public bool IsCouncil(string userId)
            {
                return userId == council;
            }
            public bool IsModerator(string userId)
            {
                return moderators.Contains(userId);
            }
            public bool IsMember(string userId)
            {
                return members.ContainsKey(userId);
            }
            public bool IsInvited(string userId)
            {
                return invites.ContainsKey(userId);
            }
            public void BroadcastChat(string message)
            {
                foreach (var memberId in members)
                {
                    var player = BasePlayer.Find(memberId.Key);
                    if (player == null) continue;
                    player.ChatMessage(string.Format(cc.broadcastPrefixFormat, cc.broadcastPrefixColor, cc.broadcastPrefix) + $"<color={cc.broadcastMessageColor}>{message}</color>");
                }
            }
            public void BroadcastLoc(string messagetype, string arg1 = "", string arg2 = "", string arg3 = "", string arg4 = "", string current = "")
            {
                string message = string.Empty;
                foreach (var memberId in members)
                {
                    var player = BasePlayer.Find(memberId.Key);
                    if (player == null || player.UserIDString == current) continue;
                    message = string.Format(cc.msg(messagetype, memberId.Key), arg1, arg2, arg3, arg4);
                    player.ChatMessage(string.Format(cc.broadcastPrefixFormat, cc.broadcastPrefixColor, cc.broadcastPrefix) + $"<color={cc.broadcastMessageColor}>{message}</color>");
                }
            }
            public void AllyBroadcastChat(string message)
            {
                foreach (var memberId in members)
                {
                    var player = BasePlayer.Find(memberId.Key);
                    if (player == null) continue;
                    player.ChatMessage(string.Format(cc.broadcastPrefixFormat, cc.broadcastPrefixColor, cc.broadcastPrefixAlly) + $"<color={cc.broadcastMessageColor}>{message}</color>");
                }
            }
            public void AllyBroadcastLoc(string messagetype, string arg1 = "", string arg2 = "", string arg3 = "", string arg4 = "")
            {
                string message = string.Empty;
                foreach (var memberId in members)
                {
                    var player = BasePlayer.Find(memberId.Key);
                    if (player == null) continue;
                    message = string.Format(cc.msg(messagetype, memberId.Key), arg1, arg2, arg3, arg4);
                    player.ChatMessage(string.Format(cc.broadcastPrefixFormat, cc.broadcastPrefixColor, cc.broadcastPrefixAlly) + $"<color={cc.broadcastMessageColor}>{message}</color>");
                }
            }
            public string ColNam(string Id, string Name)
            {
                if (IsOwner(Id)) return $"<color={cc.clanOwnerColor}>{Name}</color>";
                else if (IsCouncil(Id) && !IsOwner(Id)) return $"<color={cc.clanCouncilColor}>{Name}</color>";
                else if (IsModerator(Id) && !IsOwner(Id)) return $"<color={cc.clanModeratorColor}>{Name}</color>";
                else return $"<color={cc.clanMemberColor}>{Name}</color>";
            }
            public string PlayerLevel(string userID)
            {
                if (IsOwner(userID)) return "Owner";
                if (IsCouncil(userID)) return "Council";
                if (IsModerator(userID)) return "Moderator";
                return "Member";
            }
            public string PlayerColor(string userID)
            {
                if (IsOwner(userID)) return cc.clanOwnerColor;
                if (IsCouncil(userID)) return cc.clanCouncilColor;
                if (IsModerator(userID)) return cc.clanModeratorColor;
                return cc.clanMemberColor;
            }
            public IPlayer GetIPlayer(string partialName)
            {
                ulong userID;
                IPlayer iplayer;
                if (partialName.Length == 17 && ulong.TryParse(partialName, out userID))
                {
                    iplayer = cc.covalence.Players.FindPlayer(partialName);
                    return iplayer;
                }
                if (invites.Count > 0) foreach (var imember in GetInvites())
                    {
                        if (imember.Name.Contains(partialName) || imember.Name.EndsWith(partialName))
                        {
                            iplayer = cc.covalence.Players.FindPlayerById(imember.Id);
                            return iplayer;
                        }
                    }
                var player = cc.rust.FindPlayerByName(partialName);
                if (player != null) return cc.covalence.Players.FindPlayerById(player.UserIDString);
                try
                {
                    var iply = cc.covalence.Players.FindPlayer(partialName);
                    if (iply is IPlayer) return iply;
                }
                catch
                {
                    var idplayer = cc.covalence.Players.FindPlayer(partialName);
                    if (idplayer != null) return idplayer;
                }
                return null;
            }
            public IPlayer GetIMember(string partialName)
            {
                ulong userID;
                IPlayer player = null;
                if (partialName.Length == 17 && ulong.TryParse(partialName, out userID))
                {
                    player = cc.covalence.Players.FindPlayer(partialName);
                    return player;
                }
                foreach (var imember in GetIMembers())
                {
                    if (imember.Name.Contains(partialName) || imember.Name.EndsWith(partialName))
                    {
                        player = cc.covalence.Players.FindPlayerById(imember.Id);
                        return player;
                    }
                }
                player = GetIPlayer(partialName);
                return player;
            }
            public List<IPlayer> GetIMembers()
            {
                List<IPlayer> export = new List<IPlayer>();
                foreach (var member in members)
                {
                    if (IsOwner(member.Key)) continue;
                    IPlayer player = cc.covalence.Players.FindPlayerById(member.Key);
                    if (player != null) export.Add(player);
                }
                return export;
            }
            public List<IPlayer> GetInvites()
            {
                List<IPlayer> export = new List<IPlayer>();
                foreach (var invited in invites)
                {
                    IPlayer player = cc.covalence.Players.FindPlayerById(invited.Key);
                    if (player != null) export.Add(player);
                }
                return export;
            }
            internal JObject ToJObject()
            {
                var obj = new JObject();
                obj["tag"] = tag;
                obj["description"] = description;
                obj["owner"] = owner;
                obj["council"] = council;
                var jmoderators = new JArray();
                foreach (var moderator in moderators) jmoderators.Add(moderator);
                obj["moderators"] = jmoderators;
                var jmembers = new JArray();
                foreach (var member in members) jmembers.Add(member.Key);
                obj["members"] = jmembers;
                var jallies = new JArray();
                foreach (var ally in clanAlliances) jallies.Add(ally);
                obj["allies"] = jallies;
                var jinvallies = new JArray();
                foreach (var ally in invitedAllies) jinvallies.Add(ally);
                obj["invitedallies"] = jinvallies;
                return obj;
            }
        }

        [HookMethod("AddClanPoints")]
        private void AddClanPoints(string tag, int amount)
        {
            if (tag == null || tag == "") return;
            var clan = findClan(tag);
            if (clan == null) return;
            clan.ClanPoints += amount;
        }
        string GetClanTag(ulong playerID)
        {
            var clan = findClanByUser(playerID.ToString());
            if (clan == null) return String.Empty;
            return clan.tag;
        }
        private bool GetClanOwner(ulong playerID)
        {
            var clan = findClanByUser(playerID.ToString());
            if (clan == null) return false;
            if (clan.IsOwner(playerID.ToString()))
                return true;
            return false;
        }
		private bool IsTeammates(ulong player, ulong friend)
		{
			return player == friend ||
			       RelationshipManager.ServerInstance.FindPlayersTeam(player)?.members?.Contains(friend) == true ||
			       findClanByUser(player.ToString())?.IsMember(friend.ToString()) == true;
		}
        private void GetPointRaid(string nameClan, ulong playerId)
        {
            var clan = findClan(nameClan);
            if (clan == null) return;

            var totalPoint = clan.ClanPoints / 2;
            if (totalPoint <= 0) return;
            
            var clanKill = findClanByUser(playerId.ToString());
            if (clanKill == null) return;

            clanKill.ClanPoints += totalPoint;
        }
        private void GetChangeSkin(ulong playerID, string shortName, ulong skinID)
        {
            var clan = findClanByUser(playerID.ToString());
            if (clan == null) return;
            var value = clan.SkinList.FirstOrDefault(p => p.Value.ContainsKey(shortName)).Key;
            if (value == null) return;
            clan.SkinList[value][shortName] = skinID;
        }
        private void GiveClanPoints(string tag, int amount)
        {
            if (tag == null || tag == "") return;
            var clan = findClan(tag);
            if (clan == null) return;
            clan.ClanPoints += amount;
        }
        private void RemClanPoints(string tag, int amount)
        {
            if (tag == null || tag == "") return;
            var clan = findClan(tag);
            if (clan == null) return;
            clan.ClanPoints -= amount;
        }
        [HookMethod("GetClan")]
        private JObject GetClan(string tag)
        {
            if (tag == null || tag == "") return null;
            var clan = findClan(tag);
            if (clan == null) return null;
            return clan.ToJObject();
        }
        [HookMethod("GetAllClans")]
        private JArray GetAllClans()
        {
            return new JArray(clans.Keys);
        }
        [HookMethod("GetClanOf")]
        private string GetClanOf(ulong player)
        {
            if (player == 0uL) return null;
            var clan = findClanByUser(player.ToString());
            if (clan == null) return null;
            return clan.tag;
        }
        [HookMethod("GetClanOf")]
        private string GetClanOf(string player)
        {
            if (player == null || player == "") return null;
            var clan = findClanByUser(player.ToString());
            if (clan == null) return null;
            return clan.tag;
        }
        [HookMethod("GetClanOf")]
        private string GetClanOf(BasePlayer player)
        {
            if (player == null) return null;
            var clan = findClanByUser(player.UserIDString);
            if (clan == null) return null;
            return clan.tag;
        }     
        [HookMethod("GetClanMembers")]
        private List<string> GetClanMembers(ulong PlayerID)
        {
            List<string> Players = new List<string>();
            var myClan = findClanByUser(PlayerID.ToString());
            if (myClan == null) return null;
            foreach (var it in myClan.members)
                Players.Add(it.Key);
            return Players;
        }

        private List<string> GetMembersClan(string tag) 
        {
            List<string> _List = new List<string>();
            var clan = findClan(tag);
            if (clan == null) return _List;
            clan.members.Keys.ToList().ForEach(key => _List.Add(key.ToString()));
            return _List;
        }

        private List<ulong> BTeleportMenuHook(ulong playerID)
        {
            List<ulong> playerList = new List<ulong>();
            var myClan = findClanByUser(playerID.ToString());
            if (myClan == null) return null;
            foreach (var members in myClan.members)
            {
                var onlineMembers = BasePlayer.FindByID(ulong.Parse(members.Key));
                if (onlineMembers == null) continue;
                if (playerID.ToString() == members.Key) continue;

                playerList.Add(ulong.Parse(members.Key));
            }
            return playerList;
        }
        
        private List<ulong> BoxIds = new List<ulong>();
        void OnLootEntityEnd(BasePlayer player, BaseCombatEntity entity)
        {
            if (entity?.net?.ID == null) return; if (player == null) return; if (BoxIds.Contains(entity.net.ID.Value)) return;
            BoxIds.Add(entity.net.ID.Value);
            var clan = findClanByUser(player.UserIDString);
            if (clan == null) return;      
            var cont = entity.GetComponent<StorageContainer>();  
            if (entity.PrefabName.Contains("assets/bundled/prefabs/radtown/crate_normal_2.prefab"))
            {    
                clan.members[player.UserIDString].GatherInfo["loot-barrel"] = clan.members[player.UserIDString].GatherInfo["loot-barrel"] + 1;           
                clan.members[player.UserIDString].PlayerPoints += 1;
                clan.Change["loot-barrel"].Complete = clan.Change["loot-barrel"].Complete + 1;
                clan.ClanPoints += 1;
            }
        }

        private void AutOnBuildingPrivilage<T>(BasePlayer player, Clan clan, Action<T, string> callback)
        {
            List<string> clanMembers = clan.members.Keys.ToList();
            if (clanMembers == null)
                return;
            var playerEntities = GetPlayerEnitityByType<T>(player);
            if (playerEntities == null) return;
            foreach (var clanMember in clanMembers)
            {
                if (clanMember == player.UserIDString) continue;
                foreach (var entity in playerEntities)
                {
                    callback(entity, clanMember);
                }
            }
        }

        private static List<T> GetPlayerEnitityByType<T>(BasePlayer player)
        {
            var entities = UnityEngine.Object.FindObjectsOfType(typeof(T));
            var playerEntities = new List<T>();

            foreach (object entity in entities)
            {
                if (!(entity is BaseEntity)) continue;

                if ((entity as BaseEntity).OwnerID == player.userID)
                {
                    playerEntities.Add((T)entity);
                }
            }

            return playerEntities;
        }

        #region [Auth]
        object OnTurretTarget(AutoTurret turret, BasePlayer player)
        {
            if (player == null || turret == null || turret.OwnerID == 0 || turret.OwnerID == player.userID || turret.IsAuthed(player)) return null;
            var inClan = HasFriend(turret.OwnerID, player.userID);
            if (inClan != null && (bool)inClan)
            {
                bool check = findClanByUser(turret.OwnerID.ToString()).GetPlayerStats(turret.OwnerID.ToString()).TurretAuth;
                if (check) return false;
            }
            return null;
        }

        private object OnSamSiteTarget(SamSite samSite, BaseVehicle vehicle)
        {
            if (samSite == null || !samSite.OwnerID.IsSteamId() || vehicle == null)
                return null;

            var clan = findClanByUser(samSite.OwnerID.ToString());
            if (clan == null) return null;

            if (vehicle.OwnerID == samSite.OwnerID || clan.IsMember(vehicle.OwnerID.ToString()))
                return true;

            foreach (var mounted in vehicle.allMountPoints
                         .Where(allMountPoint => allMountPoint != null && allMountPoint.mountable != null)
                         .Select(allMountPoint => allMountPoint.mountable.GetMounted())
                         .Where(mounted => mounted != null))
            {
                if (mounted.userID == samSite.OwnerID || clan.IsMember(mounted.UserIDString))
                    return true;
            }

            return null;
        }

        private void OnEntitySpawned(BuildingPrivlidge buildingPrivlidge)
        {
            if (buildingPrivlidge == null || !buildingPrivlidge.OwnerID.IsSteamId()) return;

            var clan = findClanByUser(buildingPrivlidge.OwnerID.ToString());
            if (clan == null) return;

            foreach (var member in clan.members)
            {
                IPlayer player = covalence.Players.FindPlayerById(member.Key);
                if (player == null) continue;

                buildingPrivlidge.authorizedPlayers.Add(new PlayerNameID
                {
                    userid = ulong.Parse(player.Id),
                    username = player.Name
                });
            }
        }

        private object CanUseLockedEntity(BasePlayer player, BaseLock baseLock)
        {
            if (player == null || baseLock == null || !baseLock.IsLocked()) return null;
            var parentEntity = baseLock.GetParentEntity();
            var ownerID = baseLock.OwnerID.IsSteamId() ? baseLock.OwnerID : parentEntity != null ? parentEntity.OwnerID : 0;
            if (!ownerID.IsSteamId() || ownerID == player.userID) return null;

            var clan = findClanByUser(ownerID.ToString());
            if (clan == null) return null;

            if (clan.IsMember(player.UserIDString))
                return true;


            return null;
        }
        #endregion

        private bool CheckClans(ulong TurretID, ulong TargetID)
        {
            var result = HasFriend(TurretID, TargetID);
            return result == null ? false : (bool)result;
        }

        string ClanAlready(ulong ownerid)
        {
            var clan = findClanByUser(ownerid.ToString());
            if (clan == null)
            {
                return "404";
            }
            return clan.tag;
        }

        void ScoreRemove(string clanName, ulong acceptclan)
        {
            var clan = findClan(clanName);
            if (clan == null)
            {
                return;
            }
            if (clan.ClanPoints < 0) return;
            var clanremovescore = clan.ClanPoints / 2;
            if (clanremovescore <= 0)
            {
                clan.ClanPoints = 0;
                return;
            }
            clan.ClanPoints = 0;
            var clanaccept = findClanByUser(acceptclan.ToString());
            if (clanaccept == null)
            {
                return;
            }
            clanaccept.ClanPoints += clanremovescore;
        }
        private void ScoreV2(string victim, string attacker)
        {
            if (victim == null || victim == "") return;
            var clan = findClan(victim);
            if (clan == null) return;
            if (attacker == null || attacker == "") return;
            var clans = findClan(attacker);
            if (clan.ClanPoints < 0) return;
            var clanremovescore = clan.ClanPoints / 2;
            if (clanremovescore <= 0)
            {
                clan.ClanPoints = 0;
                return;
            }
            clan.ClanPoints = 0;
            clans.ClanPoints += clanremovescore;
        }
        object ClanCount(ulong owner)
        {
            var clan = findClanByUser(owner.ToString());
            if (clan == null)
            {
                return false;
            }
            if (clan.IsOwner(owner.ToString()) == false)
            {
                return false;
            }
            return clan.members.Count;
        }
        object ClanPoint(ulong PlayerUserID)
        {
            var clan = findClanByUser(PlayerUserID.ToString());
            if (clan == null)
            {
                return false;
            }
            return clan.ClanPoints;
        }
        object ClanOwner(ulong PlayerUserID)
        {
            var clan = findClanByUser(PlayerUserID.ToString());
            if (clan == null)
            {
                return false;
            }
            return clan.owner;
        }
        object ClanOwner2(string tag)
        {
            var clan = findClan(tag);
            if (clan == null)
            {
                return false;
            }
            string Owner = Convert.ToString(clan.owner);
            return Owner;
        }
        private int? GetClanPoints(ulong playerID)
        {
            var clan = findClanByUser(playerID.ToString());
            if (clan == null) return null;
            return clan.ClanPoints;
        }
        private Dictionary<string, int> GetTops()
        {
            Dictionary<string, int> clansList = new Dictionary<string, int>();
            var Clans = from pair in clans orderby pair.Value.ClanPoints descending select pair;
            foreach (KeyValuePair<string, Clan> key in Clans.Take(5))
                clansList.Add(key.Value.tag, key.Value.ClanPoints);

            return clansList;
        }

        private ulong GetOwnerId(string tag)
        {
            var clan = findClan(tag);
            if (clan == null) return 0;

            return ulong.Parse(clan.owner);
        }
        [HookMethod("IsClanMember")]
        private object IsClanMember(string userID, string targetID)
        {
            var clanOwner = findClanByUser(userID);
            if (clanOwner == null) return null;
            var clanFriend = findClanByUser(targetID);
            if (clanFriend == null) return null;
            if (clanOwner.tag == clanFriend.tag) return true;
            return null;
        }

        [HookMethod("HasFriend")]
        private object HasFriend(ulong entOwnerID, ulong PlayerUserID)
        {
            var clanOwner = findClanByUser(entOwnerID.ToString());
            if (clanOwner == null) return null;
            var clanFriend = findClanByUser(PlayerUserID.ToString());
            if (clanFriend == null) return null;
            if (clanOwner.tag == clanFriend.tag) return true;
            return false;
        }
        [HookMethod("IsModerator")]
        private object IsModerator(ulong PlayerUserID)
        {
            var clan = findClanByUser(PlayerUserID.ToString());
            if (clan == null) return null;
            if ((setHomeOwner && clan.IsOwner(PlayerUserID.ToString())) || (setHomeModerator && (clan.IsModerator(PlayerUserID.ToString()) || clan.IsCouncil(PlayerUserID.ToString()))) || setHomeMember) return true;
            return false;
        }
        private Int32 UnixTimeStampUTC()
        {
            Int32 unixTimeStamp;
            DateTime currentTime = DateTime.Now;
            DateTime zuluTime = currentTime.ToUniversalTime();
            DateTime unixEpoch = new DateTime(1970, 1, 1);
            unixTimeStamp = (Int32)(zuluTime.Subtract(unixEpoch)).TotalSeconds;
            return unixTimeStamp;
        }
        private static DateTime UnixTimeStampToDateTime(double unixTimeStamp)
        {
            return unixTimeStamp > MaxUnixSeconds ? UnixEpoch.AddMilliseconds(unixTimeStamp) : UnixEpoch.AddSeconds(unixTimeStamp);
        }
        string msg(string key, string id = null) => lang.GetMessage(key, this, id);
        void PrintChat(BasePlayer player, string message)
        {
            SendReply(player, $"<color={colorTextMsg}>" + message + "</color>");
        }
        [ConsoleCommand("clans")]
        void cclans(ConsoleSystem.Arg arg)
        {
            if (arg != null && arg.Connection != null && arg.Connection.player != null && arg.Connection.authLevel >= 1)
            {
                var sb = new StringBuilder();
                sb.AppendLine("clans.list (Lists all clans, their owners and their membercount)");
                sb.AppendLine("clans.listex (Lists all clans, their owners/members and their onlinestatus)");
                sb.AppendLine("clans.show TAG (lists the choosen clan and the members with status)");
                sb.AppendLine("clans.msg TAG message without quotes (Sends a clan message)");
                if (arg.Connection.authLevel >= authLevelRename) sb.AppendLine("clans.rename OLDTAG NEWTAG (rename's a clan)");
                if (arg.Connection.authLevel >= authLevelDelete) sb.AppendLine("clans.delete TAG (delete's a clan)");
                if (arg.Connection.authLevel >= authLevelInvite) sb.AppendLine("clans.playerinvite TAG playername (sends clan invitation to a player)");
                if (arg.Connection.authLevel >= authLevelKick) sb.AppendLine("clans.playerkick TAG playername (kicks a player from a clan)");
                if (arg.Connection.authLevel >= authLevelPromoteDemote)
                {
                    sb.AppendLine("clans.playerpromote TAG playername (promotes a player)");
                    sb.AppendLine("clans.playerdemote TAG playername (demotes a player)");
                }
                SendReply(arg, sb.ToString());
            }
        }
        [ConsoleCommand("clans.cmds")]
        void cclansCommands(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2) return;
            var sb = new StringBuilder();
            sb.AppendLine("\n>> Clans command overview <<\n");
            sb.AppendLine("clans.list".PadRight(20) + "| Lists all clans, their owners and their membercount");
            sb.AppendLine("clans.listex".PadRight(20) + "| Lists all clans, their owners/members and their onlinestatus");
            sb.AppendLine("clans.show".PadRight(20) + "| lists the choosen clan and the members with status");
            sb.AppendLine("clans.showduplicates".PadRight(20) + "| lists the players which do exist in more than one clan");
            sb.AppendLine("clans.msg".PadRight(20) + "| message without quotes (Sends a clan message)");
            sb.AppendLine("clans.rename".PadRight(20) + "| rename's a clan");
            sb.AppendLine("clans.delete".PadRight(20) + "| delete's a clan");
            sb.AppendLine("clans.changeowner".PadRight(20) + "| changes the owner to another member");
            sb.AppendLine("clans.playerinvite".PadRight(20) + "| sends clan invitation to a player");
            sb.AppendLine("clans.playerjoin".PadRight(20) + "| joins a player into a clan");
            sb.AppendLine("clans.playerkick".PadRight(20) + "| kicks a player from a clan");
            sb.AppendLine("clans.playerpromote".PadRight(20) + "| promotes a player");
            sb.AppendLine("clans.playerdemote".PadRight(20) + "| demotes a player");
            SendReply(arg, sb.ToString());
        }
        [ConsoleCommand("clans.list")]
        void cclansList(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 1) return;
            TextTable textTable = new TextTable();
            textTable.AddColumn("Tag");
            textTable.AddColumn("Owner");
            textTable.AddColumn("SteamID");
            textTable.AddColumn("Count");
            textTable.AddColumn("On");
            foreach (var iclan in clans)
            {
                Clan clan = clans[iclan.Key];
                var owner = this.covalence.Players.FindPlayerById(clan.owner);
                if (owner == null) continue;
                textTable.AddRow(new string[]
                {
                 clan.tag, owner.Name, clan.owner, clan.total.ToString(), clan.online.ToString()
                });
            }
            SendReply(arg, "\n>> Current clans <<\n" + textTable.ToString());
        }
        [ConsoleCommand("clans.showduplicates")]
        void cclansDuplicates(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 1) return;
            TextTable textTable = new TextTable();
            textTable.AddColumn("SteamID");
            textTable.AddColumn("Memberships");
            textTable.AddColumn("PlayerName");
            Dictionary<string, List<string>> clanDuplicates = new Dictionary<string, List<string>>();
            foreach (var iclan in clans)
            {
                Clan clan = clans[iclan.Key];
                foreach (var member in clan.members.ToList())
                {
                    if (!clanDuplicates.ContainsKey(member.Key))
                    {
                        clanDuplicates.Add(member.Key, new List<string>());
                        clanDuplicates[member.Key].Add(clan.tag);
                        continue;
                    }
                    else clanDuplicates[member.Key].Add(clan.tag);
                }
            }
            foreach (var clDup in clanDuplicates)
            {
                if (clDup.Value.Count < 2) continue;
                var player = this.covalence.Players.FindPlayerById(clDup.Key);
                if (player == null) continue;
                textTable.AddRow(new string[] {
    clDup.Key, string.Join(" | ", clDup.Value.ToArray()), player.Name
}
                );
            }
            SendReply(arg, "\n>> Current found duplicates <<\n" + textTable.ToString());
        }
        [ConsoleCommand("clans.listex")]
        void cclansListEx(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 1) return;
            TextTable textTable = new TextTable();
            textTable.AddColumn("Tag");
            textTable.AddColumn("Level");
            textTable.AddColumn("Name");
            textTable.AddColumn("SteamID");
            textTable.AddColumn("Status");
            foreach (var iclan in clans)
            {
                Clan clan = clans[iclan.Key];
                foreach (var memberid in clan.members)
                {
                    var member = this.covalence.Players.FindPlayerById(memberid.Key);
                    if (member == null) continue;
                    textTable.AddRow(new string[] {
        clan.tag, clan.PlayerLevel(member.Id), member.Name, member.Id.ToString(), (member.IsConnected ? "Online": "Offline").ToString()
    }
                    );
                }
                textTable.AddRow(new string[] { }
                );
            }
            SendReply(arg, "\n>> Current clans with members <<\n" + textTable.ToString());
        }
        [ConsoleCommand("clans.show")]
        void cclansShow(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 1) return;
            if (arg.Args == null || arg.Args.Length < 1)
            {
                SendReply(arg, "Usage: clans.show TAG");
                return;
            }
            Clan clan;
            if (!TryGetClan(arg.Args[0], out clan))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            var sb = new StringBuilder();
            sb.AppendLine($"\n>> Show clan [{clan.tag}] <<");
            sb.AppendLine($"Description: {clan.description}");
            sb.AppendLine($"Time created: {UnixTimeStampToDateTime(clan.created)}");
            sb.AppendLine($"Last updated: {UnixTimeStampToDateTime(clan.updated)}");
            sb.AppendLine($"Member count: {clan.total}");
            TextTable textTable = new TextTable();
            textTable.AddColumn("Level");
            textTable.AddColumn("Name");
            textTable.AddColumn("SteamID");
            textTable.AddColumn("Status");
            sb.AppendLine();
            foreach (var memberid in clan.members)
            {
                var member = this.covalence.Players.FindPlayerById(memberid.Key);
                if (member == null) continue;
                textTable.AddRow(new string[] {
    clan.PlayerLevel(member.Id), member.Name, member.Id.ToString(), (member.IsConnected ? "Online": "Offline").ToString()
}
                );
            }
            sb.AppendLine(textTable.ToString());
            SendReply(arg, sb.ToString());
        }
        [ConsoleCommand("clans.msg")]
        void cclansBroadcast(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 1) return;
            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "Usage: clans.msg TAG your message without quotes");
                return;
            }
            Clan clan;
            if (!TryGetClan(arg.Args[0], out clan))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            string BroadcastBy = consoleName;
            if (arg.Connection != null)
            {
                if (arg.Connection.authLevel == 2) BroadcastBy = "(Admin) " + arg.Connection.username;
                else BroadcastBy = "(Mod) " + arg.Connection.username;
            }
            string Msg = "";
            for (int i = 1;
            i < arg.Args.Length;
            i++) Msg = Msg + " " + arg.Args[i];
            clan.BroadcastChat($"<color={clanServerColor}>{BroadcastBy}</color>: {Msg}");
            SendReply(arg, $"Broadcast to [{clan.tag}]: {Msg}");
        }
        [ConsoleCommand("clans.rename")]
        void cclansRename(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelRename) return;
            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "Usage: clans.rename OldTag NewTag");
                return;
            }
            Clan clan;
            if (!TryGetClan(arg.Args[0], out clan))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            if (tagReExt.IsMatch(arg.Args[1]))
            {
                SendReply(arg, string.Format(msg("hintchars"), allowedSpecialChars));
                return;
            }
            if (arg.Args[1].Length < tagLengthMin || arg.Args[1].Length > tagLengthMax)
            {
                SendReply(arg, string.Format(msg("hintlength"), tagLengthMin, tagLengthMax));
                return;
            }
            if (clans.ContainsKey(arg.Args[1]))
            {
                SendReply(arg, string.Format(msg("tagblocked")));
                return;
            }
            string oldtag = clan.tag;
            clan.tag = arg.Args[1];
            clan.online = 0;
            clans.Add(clan.tag, clan);
            RemoveClan(oldtag);
            setupPlayers(clan.members.Keys.ToList(), false, clan.tag);
            string oldGroup = permGroupPrefix + oldtag;
            string newGroup = permGroupPrefix + clan.tag;
            if (permission.GroupExists(oldGroup))
            {
                foreach (var member in clan.members) if (permission.UserHasGroup(member.Key, oldGroup)) permission.RemoveUserGroup(member.Key, oldGroup);
                permission.RemoveGroup(oldGroup);
            }
            if (usePermGroups && !permission.GroupExists(newGroup)) permission.CreateGroup(newGroup, "Clan " + clan.tag, 0);
            foreach (var member in clan.members) if (usePermGroups && !permission.UserHasGroup(member.Key, newGroup)) permission.AddUserGroup(member.Key, newGroup);
            string RenamedBy = consoleName;
            if (arg.Connection != null) RenamedBy = arg.Connection.username;
            foreach (var ally in clans)
            {
                Clan allyClan = clans[ally.Key];
                if (allyClan.clanAlliances.Contains(oldtag))
                {
                    allyClan.clanAlliances.Remove(oldtag);
                    allyClan.clanAlliances.Add(clan.tag);
                }
                if (allyClan.invitedAllies.Contains(oldtag))
                {
                    allyClan.invitedAllies.Remove(oldtag);
                    allyClan.invitedAllies.Add(clan.tag);
                }
                if (allyClan.pendingInvites.Contains(oldtag))
                {
                    allyClan.pendingInvites.Remove(oldtag);
                    allyClan.pendingInvites.Add(clan.tag);
                }
            }
            clan.BroadcastLoc("clanrenamed", $"<color={clanServerColor}>{RenamedBy}</color>", clan.tag);
            SendReply(arg, string.Format(msg("yourenamed"), oldtag, clan.tag));
            clan.OnUpdate();
        }
        [ConsoleCommand("clans.playerinvite")]
        void cclansPlayerInvite(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelInvite) return;
            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "Usage: clans.playerinvite TAG playername/id");
                return;
            }
            Clan myClan;
            Clan check;
            if (!TryGetClan(arg.Args[0], out check))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            else myClan = (Clan)check;
            var invPlayer = myClan.GetIPlayer(arg.Args[1]);
            if (invPlayer == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }
            if (myClan.members.ContainsKey(invPlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadymember"), invPlayer.Name));
                return;
            }
            if (myClan.invites.ContainsKey(invPlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadyinvited"), invPlayer.Name));
                return;
            }
            if (findClanByUser(invPlayer.Id) != null)
            {
                SendReply(arg, string.Format(msg("alreadyinclan"), invPlayer.Name));
                return;
            }
            myClan.invites.Add(invPlayer.Id, UnixTimeStampUTC());
            if (!pendingPlayerInvites.ContainsKey(invPlayer.Id))
                pendingPlayerInvites.Add(invPlayer.Id, new List<string>());
            pendingPlayerInvites[invPlayer.Id].Add(myClan.tag);
            if (invPlayer.IsConnected)
            {
                var invited = rust.FindPlayerByIdString(invPlayer.Id);
                if (invited != null) PrintChat(invited, string.Format(msg("claninvite", invPlayer.Id), myClan.tag, myClan.description, colorCmdUsage));
            }
            myClan.updated = UnixTimeStampUTC();
            SendReply(arg, $"Invitation for clan '{myClan.tag}' sent to '{invPlayer.Name}'");
        }
        [ConsoleCommand("clans.playerjoin")]
        void cclansPlayerJoin(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelInvite) return;
            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "Usage: clans.playerjoin TAG playername/id");
                return;
            }
            Clan myClan;
            Clan check;
            if (!TryGetClan(arg.Args[0], out check))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            else myClan = (Clan)check;
            var joinPlayer = myClan.GetIPlayer(arg.Args[1]);
            if (joinPlayer == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }
            if (myClan.members.ContainsKey(joinPlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadymember"), joinPlayer.Name));
                return;
            }
            if (findClanByUser(joinPlayer.Id) != null)
            {
                SendReply(arg, string.Format(msg("alreadyinclan"), joinPlayer.Name));
                return;
            }
            myClan.invites.Remove(joinPlayer.Id);
            pendingPlayerInvites.Remove(joinPlayer.Id);
            myClan.members.Add(joinPlayer.Id, new PlayerStats());

            clanCache[joinPlayer.Id] = myClan;
            if (joinPlayer.IsConnected)
            {
                var joined = rust.FindPlayerByIdString(joinPlayer.Id);
                SetupPlayer(joined, joinPlayer, false, myClan);
            }
            if (usePermGroups && !permission.UserHasGroup(joinPlayer.Id, permGroupPrefix + myClan.tag)) permission.AddUserGroup(joinPlayer.Id, permGroupPrefix + myClan.tag);
            myClan.BroadcastLoc("playerjoined", myClan.ColNam(joinPlayer.Id, joinPlayer.Name));
            myClan.updated = UnixTimeStampUTC();
            myClan.total++;

            myClan.OnUpdate();
            List<string> others = new List<string>(myClan.members.Keys.ToList());
            others.Remove(joinPlayer.Id);
            Interface.Oxide.CallHook("OnClanMemberJoined", joinPlayer.Id, others);
            SendReply(arg, $"Playerjoin into clan '{myClan.tag}' done for '{joinPlayer.Name}'");
        }
        [ConsoleCommand("clans.playerkick")]
        void cclansPlayerKick(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelKick) return;
            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "Usage: clans.playerkick TAG playername/id");
                return;
            }
            Clan myClan;
            Clan check;
            if (!TryGetClan(arg.Args[0], out check))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            else myClan = (Clan)check;
            var kickPlayer = myClan.GetIMember(arg.Args[1]);
            if (kickPlayer == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }
            if (!myClan.IsMember(kickPlayer.Id) && !myClan.IsInvited(kickPlayer.Id))
            {
                SendReply(arg, string.Format(msg("notmembercannotkicked"), kickPlayer.Name));
                return;
            }
            if (myClan.members.Count() == 1)
            {
                SendReply(arg, "The clan has only one member. You need to delete the clan");
                return;
            }
            if (myClan.members.ContainsKey(kickPlayer.Id)) myClan.total--;
            myClan.invites.Remove(kickPlayer.Id);
            if (myClan.IsCouncil(kickPlayer.Id)) myClan.council = null;
            myClan.moderators.Remove(kickPlayer.Id);
            myClan.members.Remove(kickPlayer.Id);
            myClan.invites.Remove(kickPlayer.Id);
            bool ownerChanged = false;
            if (myClan.IsOwner(kickPlayer.Id) && myClan.members.Count() > 0)
            {
                myClan.owner = myClan.members.ToList()[0].Key;
                ownerChanged = true;
            }
            if (pendingPlayerInvites.ContainsKey(kickPlayer.Id)) pendingPlayerInvites[kickPlayer.Id].Remove(myClan.tag);
            clanCache.Remove(kickPlayer.Id);
            var kickBasePlayer = rust.FindPlayerByIdString(kickPlayer.Id);
            if (kickBasePlayer != null)
            {
                SetupPlayer(kickBasePlayer, kickPlayer, true, oldTag: myClan.tag);
            }
            if (usePermGroups && permission.UserHasGroup(kickPlayer.Id, permGroupPrefix + myClan.tag)) permission.RemoveUserGroup(kickPlayer.Id, permGroupPrefix + myClan.tag);
            myClan.updated = UnixTimeStampUTC();
            myClan.OnUpdate();
            //Interface.Oxide.CallHook("OnClanMemberGone", kickPlayer.Id, myClan.members);
            Interface.CallHook("OnClanMemberGone", UInt64.Parse(kickPlayer.Id), myClan.tag);
            SendReply(arg, $"Player '{kickPlayer.Name}' was kicked from clan '{myClan.tag}'");
            if (ownerChanged)
            {
                var newOwner = myClan.GetIPlayer(myClan.owner);
                if (newOwner != null) SendReply(arg, $"New owner of clan '{myClan.tag}' is {newOwner.Name}");
            }
        }
        [ConsoleCommand("clans.changeowner")]
        void cclansChangeOwner(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelPromoteDemote) return;
            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "Usage: clans.changeowner TAG playername/id");
                return;
            }
            Clan myClan;
            Clan check;
            if (!TryGetClan(arg.Args[0], out check))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            else myClan = (Clan)check;
            var promotePlayer = myClan.GetIPlayer(arg.Args[1]);
            if (promotePlayer == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }
            if (!myClan.IsMember(promotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("notaclanmember"), promotePlayer.Name));
                return;
            }
            if (myClan.IsOwner(promotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadyowner"), promotePlayer.Name));
                return;
            }
            string PromotedBy = consoleName;
            if (arg.Connection != null) PromotedBy = arg.Connection.username;
            if (myClan.council == promotePlayer.Id) myClan.council = null;
            myClan.moderators.Remove(promotePlayer.Id);
            myClan.owner = promotePlayer.Id;
            myClan.BroadcastLoc("playerpromotedowner", $"<color={clanServerColor}>{PromotedBy}</color>", myClan.ColNam(promotePlayer.Id, promotePlayer.Name));
            myClan.updated = UnixTimeStampUTC();
            myClan.OnUpdate();
            SendReply(arg, $"You promoted '{promotePlayer.Name}' to the {myClan.PlayerLevel(promotePlayer.Id.ToString())}");
        }
        [ConsoleCommand("clans.playerpromote")]
        void cclansPlayerPromote(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelPromoteDemote) return;
            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "Usage: clans.playerpromote TAG playername/id");
                return;
            }
            Clan myClan;
            Clan check;
            if (!TryGetClan(arg.Args[0], out check))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            else myClan = (Clan)check;
            var promotePlayer = myClan.GetIPlayer(arg.Args[1]);
            if (promotePlayer == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }
            if (!myClan.IsMember(promotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("notaclanmember"), promotePlayer.Name));
                return;
            }
            if (enableClanAllies && myClan.IsCouncil(promotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadyacouncil"), promotePlayer.Name));
                return;
            }
            if (enableClanAllies && myClan.council != null && myClan.IsModerator(promotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadyacouncilset"), promotePlayer.Name));
                return;
            }
            if (!enableClanAllies && myClan.IsModerator(promotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadyamod"), promotePlayer.Name));
                return;
            }
            if (!myClan.IsModerator(promotePlayer.Id) && limitModerators >= 0 && myClan.moderators.Count() >= limitModerators)
            {
                SendReply(arg, string.Format(msg("maximummods")));
                return;
            }
            string PromotedBy = consoleName;
            if (arg.Connection != null) PromotedBy = arg.Connection.username;
            if (enableClanAllies && myClan.IsModerator(promotePlayer.Id))
            {
                myClan.council = promotePlayer.Id;
                myClan.moderators.Remove(promotePlayer.Id);
                myClan.BroadcastLoc("playerpromotedcouncil", $"<color={clanServerColor}>{PromotedBy}</color>", myClan.ColNam(promotePlayer.Id, promotePlayer.Name));
            }
            else
            {
                myClan.moderators.Add(promotePlayer.Id);
                myClan.BroadcastLoc("playerpromoted", $"<color={clanServerColor}>{PromotedBy}</color>", myClan.ColNam(promotePlayer.Id, promotePlayer.Name));
            }
            myClan.updated = UnixTimeStampUTC();
            myClan.OnUpdate();
            SendReply(arg, $"You promoted '{promotePlayer.Name}' to a {myClan.PlayerLevel(promotePlayer.Id.ToString())}");
        }
        [ConsoleCommand("clans.playerdemote")]
        void cclansPlayerDemote(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelPromoteDemote) return;
            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "Usage: clans.playerdemote TAG playername/id");
                return;
            }
            Clan myClan;
            Clan check;
            if (!TryGetClan(arg.Args[0], out check))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            else myClan = (Clan)check;
            var demotePlayer = myClan.GetIPlayer(arg.Args[1]);
            if (demotePlayer == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }
            if (!myClan.IsMember(demotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("notaclanmember"), demotePlayer.Name));
                return;
            }
            if (!myClan.IsModerator(demotePlayer.Id) && !myClan.IsCouncil(demotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("notpromoted"), demotePlayer.Name));
                return;
            }
            string DemotedBy = consoleName;
            if (arg.Connection != null) DemotedBy = arg.Connection.username;
            if (enableClanAllies && myClan.IsCouncil(demotePlayer.Id))
            {
                myClan.council = null;
                if (limitModerators >= 0 && myClan.moderators.Count() >= limitModerators) myClan.BroadcastLoc("playerdemoted", $"<color={clanServerColor}>{DemotedBy}</color>", myClan.ColNam(demotePlayer.Id, demotePlayer.Name));
                else
                {
                    myClan.moderators.Add(demotePlayer.Id);
                    myClan.BroadcastLoc("councildemoted", $"<color={clanServerColor}>{DemotedBy}</color>", myClan.ColNam(demotePlayer.Id, demotePlayer.Name));
                }
            }
            else
            {
                myClan.moderators.Remove(demotePlayer.Id);
                myClan.BroadcastLoc("playerdemoted", $"<color={clanServerColor}>{DemotedBy}</color>", myClan.ColNam(demotePlayer.Id, demotePlayer.Name));
            }
            myClan.updated = UnixTimeStampUTC();
            myClan.OnUpdate();
            SendReply(arg, $"You demoted '{demotePlayer.Name}' to a {myClan.PlayerLevel(demotePlayer.Id.ToString())}");
        }
        [ConsoleCommand("clans.delete")]
        void cclansDelete(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelDelete) return;
            if (arg.Args == null || arg.Args.Length != 1)
            {
                SendReply(arg, "Usage: clans.delete TAG");
                return;
            }
            Clan clan;
            if (!TryGetClan(arg.Args[0], out clan))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            string DeletedBy = consoleName;
            if (arg.Connection != null) DeletedBy = arg.Connection.username;
            clan.BroadcastLoc("clandeleted", $"<color={clanServerColor}>{DeletedBy}</color>");
            RemoveClan(arg.Args[0]);
            foreach (var member in clan.members) clanCache.Remove(member.Key);
            setupPlayers(clan.members.Keys.ToList(), true, clan.tag);
            string permGroup = permGroupPrefix + clan.tag;
            if (permission.GroupExists(permGroup))
            {
                foreach (var member in clan.members) if (permission.UserHasGroup(member.Key, permGroup)) permission.RemoveUserGroup(member.Key, permGroup);
                permission.RemoveGroup(permGroup);
            }
            foreach (var ally in clans)
            {
                Clan allyClan = clans[ally.Key];
                allyClan.clanAlliances.Remove(arg.Args[0]);
                allyClan.invitedAllies.Remove(arg.Args[0]);
                allyClan.pendingInvites.Remove(arg.Args[0]);
            }
            SendReply(arg, string.Format(msg("youdeleted"), clan.tag));
            clan.OnDestroy();

            //Interface.Oxide.CallHook("OnClanDisbanded", clan.members);
            List<UInt64> MemberListUInt64 = new List<UInt64>();
            MemberListUInt64 = clan.members.Select(x => Convert.ToUInt64(x.Key)).ToList();
            Interface.Oxide.CallHook("OnClanDisbanded", clan.tag, MemberListUInt64);
            AllyRemovalCheck();
        }
        bool FilterText(string tag)
        {
            foreach (string bannedword in wordFilter) if (TranslateLeet(tag).ToLower().Contains(bannedword.ToLower())) return true;
            return false;
        }
        string TranslateLeet(string original)
        {
            string translated = original;
            Dictionary<string, string> leetTable = new Dictionary<string, string> {
    {
    "}{", "h"
}
, {
    "|-|", "h"
}
, {
    "]-[", "h"
}
, {
    "/-/", "h"
}
, {
    "|{", "k"
}
, {
    "/\\/\\", "m"
}
, {
    "|\\|", "n"
}
, {
    "/\\/", "n"
}
, {
    "()", "o"
}
, {
    "[]", "o"
}
, {
    "vv", "w"
}
, {
    "\\/\\/", "w"
}
, {
    "><", "x"
}
, {
    "2", "z"
}
, {
    "4", "a"
}
, {
    "@", "a"
}
, {
    "8", "b"
}
, {
    "ß", "b"
}
, {
    "(", "c"
}
, {
    "<", "c"
}
, {
    "{", "c"
}
, {
    "3", "e"
}
, {
    "€", "e"
}
, {
    "6", "g"
}
, {
    "9", "g"
}
, {
    "&", "g"
}
, {
    "#", "h"
}
, {
    "$", "s"
}
, {
    "7", "t"
}
, {
    "|", "l"
}
, {
    "1", "i"
}
, {
    "!", "i"
}
, {
    "0", "o"
}
,
};

            foreach (var leet in leetTable) translated = translated.Replace(leet.Key, leet.Value);
            return translated;
        }
        bool TryGetClan(string input, out Clan clan)
        {
            clan = default(Clan);
            Clan tmp = null;
            if (clans.TryGetValue(input, out tmp))
            {
                clan = tmp;
                return true;
            }
            string name;
            if (clansSearch.TryGetValue(input.ToLower(), out name))
            {
                if (clans.TryGetValue(name, out tmp))
                {
                    clan = tmp;
                    return true;
                }
            }
            return false;
        }
        void RemoveClan(string tag)
        {
            clans.Remove(tag);
            clansSearch.Remove(tag.ToLower());
        }
        [HookMethod("EnableBypass")]
        void EnableBypass(object userId)
        {
            if (!enableFFOPtion || userId == null) return;
            if (userId is string) userId = Convert.ToUInt64((string)userId);
            bypass.Add((ulong)userId);
        }
        [HookMethod("DisableBypass")]
        void DisableBypass(object userId)
        {
            if (!enableFFOPtion || userId == null) return;
            if (userId is string) userId = Convert.ToUInt64((string)userId);
            bypass.Remove((ulong)userId);
        }
    }
}

// --- End of file: Clans.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/BHelp.cs ---
// --- Original Local Path: BeeRust/BHelp.cs ---

using System.Security;
using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("BHelp", "King", "1.0.0")]
    public class BHelp : RustPlugin
    {
        #region [Vars]
        Dictionary<string, string> Buttons = new Dictionary<string, string>();

        private string Layer = "BHelp.Layer";
        #endregion

        #region [Oxide]
	    private void OnServerInitialized()
	    {
            cmd.AddChatCommand("help", this, "MainUI");
            foreach (var key in config._SettingsHelp)
				Buttons.Add(key.Key, key.Value._Name);
        }

        private void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
                CuiHelper.DestroyUi(player, Layer);
        }
        #endregion

        #region [Config]
        private PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();

            if (config.PluginVersion < Version)
                UpdateConfigValues();

            Config.WriteObject(config, true);
        }

        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (config.PluginVersion < Version)
            {
                config.PluginVersion = Version;
                if (Version == new VersionNumber(1, 0, 0))
                {
                    //
                }

                PrintWarning("Config checked completed!");
            }
            config.PluginVersion = Version;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        public class SettingsHelp
        {
            [JsonProperty("Название страницы")]
            public string _Name;

            [JsonProperty("Титл страницы")]
            public string _Title;

            [JsonProperty("Текст страницы")]
            public string _Text;
        }

        private class PluginConfig
        {
		    [JsonProperty("Настройка кнопок")]
		    public Dictionary<string, SettingsHelp> _SettingsHelp = new Dictionary<string, SettingsHelp>();

            [JsonProperty("Config version")]
            public VersionNumber PluginVersion = new VersionNumber();

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    _SettingsHelp = new Dictionary<string, SettingsHelp>()
                    {
                        ["server_info"] = new SettingsHelp
                        {
                            _Name = "О сервере",
                            _Title = "Информация о сервере",
                            _Text = "<color=#b7d092>BOLOTO MAX3</color> Это сервер для комфортной игры с командой до 3 игроков\nУ нас не нужно много фармить и убивать на это время! Файты и рейды - главное\nнаправление нашего сервера\n\nВайп сервера происходит каждую пятницу и вторник в <color=#b7d092>16:00</color> по МСК\n\nРейты на добычу ресурсов и компонентов <color=#b7d092>Х5</color>, с наилучшей привилегией <color=#b7d092>Х10</color>.\nКомпоненты улучшены до идеала, никакого мусора в бочках/ящиках.\n\nАктивная администрация/модерация всегда поможет вам в решение каких-либо\nвозникших проблем.\n\nНа сервере установлены уникальные плагин, такие как <color=#b7d092>FIGHTZONE, CARGOZONE,\nМЕГАЯЩИК, Апгрейд карьеров</color>\nБолее подробно о каждом из плагинов вы можете узнать тут - <color=#b7d092>vk.com/bolotorust</color>",
                        },
                        ["rules"] = new SettingsHelp
                        {
                            _Name = "Правила",
                            _Title = "Правила",
                            _Text = "Основные правила игры\n\n<color=#b7d092>1.</color> Запрещено использовать любые виды макросов/читов и всего, что дает\nпреимущество над игроками\n\n<color=#b7d092>2.</color> Нельзя обманывать игроков на любые виды ресурсов.\n\n<color=#b7d092>3.</color> Запрещено использовать баги игры/сервера в любом их проявлении.\n\n<color=#b7d092>4.</color> При нарушении лимита игроков вы получите бан на сервере длительностью от 7\nдней.\n\n<color=#b7d092>5.</color> Запрещено использовать в никах теги чужих серверов.\n\n<color=#b7d092>6.</color> Не знания правил не освобождает вас от ответственности!\n\n<color=#b7d092>7.</color> Играя на нашем сервере вы автоматически соглашаетесь с нашими правилами!\n\nБолее подробно с нашими правилами вы можете ознакомится в нашем дискорде -\n<color=#b7d092>discord.gg/eQnHwZNqrj</color>.",
                        },
                        ["command"] = new SettingsHelp
                        {
                            _Name = "Команды",
                            _Title = "Команды",
                            _Text = "<color=#b7d092>/ad</color> - Автозакрытие дверей\n<color=#b7d092>/rec</color> - Карманный переработчик\n<color=#b7d092>/backpack</color> - Открытие рюкзака\n<color=#b7d092>/fz</color> - Статистика FIGHTZONE\n<color=#b7d092>/tpmenu</color> - Меню телепортации\n<color=#b7d092>/friend</color> - Управление друзьями\n<color=#b7d092>/kit</color> - Открытие меню китов\n<color=#b7d092>/map</color> - Открытие внутриигровой карты\n<color=#b7d092>/remove</color> - Удаление построек\n<color=#b7d092>/up</color> - Автоапгрейд построек\n<color=#b7d092>/hair</color> - Меню прицелов\n<color=#b7d092>/block</color> - Блокировка предметов после вайпа\n<color=#b7d092>/skin</color> - Меню скинов\n<color=#b7d092>/skinentity</color> - Перекрасить скин на уже поставленном предмете (Чтобы сработало, нужно\nсмотреть на установленную, например дверь)\n<color=#b7d092>/raid</color> - Оповещение о рейде в ВК\n<color=#b7d092>/craft</color> - Крафт предметов\n<color=#b7d092>/chat</color> - Настройка чата\n<color=#b7d092>/pinfo</color> - Информация о ваших привилегиях\n<color=#b7d092>/trade</color> - Обмен с другими игроками\n<color=#b7d092>/bps</color> - Проверка ночной защиты\n<color=#b7d092>/report</color> - Жалобы на игроков\n<color=#b7d092>/top</color> - Топ игроков сервера",
                        },
                        ["binds"] = new SettingsHelp
                        {
                            _Name = "Бинды",
                            _Title = "Бинды",
                            _Text = "<color=#b7d092>bind кнопка tp.menu</color> - Меню телепортации\n<color=#b7d092>bind кнопка chat.say /kit</color> - Меню китов\n<color=#b7d092>bind кнопка upgrade.use</color> - Автоапгрейд построек\n<color=#b7d092>bind кнопка remove.use</color> - Ремув построек\n<color=#b7d092>bind кнопка chat.say /map</color> - Открытие внутриигровой карты",
                        },
                    },
                    PluginVersion = new VersionNumber()
                };
            }
        }
        #endregion

        #region [ConsoleCommand]
        [ConsoleCommand("UI_HELP")]
        private void cmdBHelp(ConsoleSystem.Arg args)
        {
		    BasePlayer player = args.Player();
		    if (player == null) return;

            switch (args.Args[0])
            {
			    case "open.help":
			    {
				    var _config = config._SettingsHelp[args.Args[1]];
                    if (_config == null) return;

                    MenuButtons(player, args.Args[1]);
                    TextUI(player, _config);
				    break;
			    }
            }
        }
        #endregion

        #region [UI]
        private void MainUI(BasePlayer player)
        {
            var container = new CuiElementContainer();
            string FirtHelp = Buttons.FirstOrDefault().Key;
            var _config = config._SettingsHelp[FirtHelp];

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Material = "assets/content/ui/uibackgroundblur.mat", Color = "0 0 0 0.77" },
            }, "Overlay", Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0.36 0.33 0.28 0.3", Material = "assets/icons/greyout.mat", Close = Layer }
            }, Layer);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-360 -230", OffsetMax = "362.5 250" },
                Image = { Color = "0.3773585 0.3755785 0.3755785 0.3407843", Material = "assets/icons/greyout.mat" }
            }, Layer, Layer + ".Menu");

            CuiHelper.DestroyUi(player, Layer);
            CuiHelper.AddUi(player, container);
            MenuButtons(player, FirtHelp);
            TextUI(player, _config);
        }

        private void MenuButtons(BasePlayer player, string Button = "")
        {
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0.2 1" },
                Image = { Color = "0 0 0 0" }
            }, Layer + ".Menu", Layer + ".Menu" + ".Button");

            int y = 0;
            foreach (var key in Buttons)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0.1 {0.85 - y * 0.088}", AnchorMax = $"0.96 {0.92 - y * 0.088}" },
                    Button = { Color = "0 0 0 0.60", Command = $"UI_HELP open.help {key.Key}" },
                    Text = { Text = $"" }
                }, Layer + ".Menu" + ".Button", Layer + ".Menu" + $".Button{y}");

                container.Add(new CuiLabel
                {   
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = $"{key.Value}", Color = "1 1 1 0.85", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 16 }
                }, Layer + ".Menu" + $".Button{y}");

                if (Button == key.Key)
                {
                    container.Add(new CuiPanel
                    {
                        RectTransform = { AnchorMin = $"0 0", AnchorMax = $"0.99 0.03" },
                        Image = { Color = "1.000 0.871 0.353 1" }
                    }, Layer + ".Menu" + $".Button{y}");
                }

                y++;
            }

            CuiHelper.DestroyUi(player, Layer + ".Menu" + ".Button");
            CuiHelper.AddUi(player, container);
        }

        private void TextUI(BasePlayer player, SettingsHelp _config)
        {
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.2 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0" }
            }, Layer + ".Menu", Layer + ".Menu" + ".Text");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.03 0.925", AnchorMax = "0.96 1", OffsetMax = "0 0" },
                Text = { Text = $"{_config._Title}", Color = "1 1 1 0.65", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 22 }
            }, Layer + ".Menu" + ".Text");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.045 0", AnchorMax = "0.96 0.928", OffsetMax = "0 0" },
                Text = { Text = $"{_config._Text}", Color = "1 1 1 0.8", Align = TextAnchor.UpperLeft, FontSize = 14, Font = "robotocondensed-regular.ttf" }
            }, Layer + ".Menu" + ".Text");

            CuiHelper.DestroyUi(player, Layer + ".Menu" + ".Text");
            CuiHelper.AddUi(player, container);
        }
        #endregion
    }
}

// --- End of file: BHelp.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/NoWorkbench.cs ---
// --- Original Local Path: BeeRust/NoWorkbench.cs ---

﻿using Newtonsoft.Json;
using System.Linq;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("NoWorkbench", "k1lly0u", "0.1.51")]
    [Description("Eliminates the requirement of being near a bench to craft")]
    class NoWorkbench : RustPlugin
    {        
        private Dictionary<int, int> defaultBlueprints;

        #region Oxide Hooks  
        private void OnServerInitialized()
        {
            LoadVariables();
            defaultBlueprints = ItemManager.GetBlueprints().ToDictionary(x => x.targetItem.itemid, y => y.workbenchLevelRequired);

            foreach (ItemBlueprint bp in ItemManager.GetBlueprints())            
                bp.workbenchLevelRequired = 0;            

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);
        }
       
        private void OnPlayerConnected(BasePlayer player)
        {
            if (player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.In(3, () => OnPlayerConnected(player));
                return;
            }

            player.ClientRPCPlayer(null, player, "craftMode", 1);

            if (configData.NoBlueprints)
                UnlockAllBlueprints(player);             
        }        

        private void UnlockAllBlueprints(BasePlayer player)
        {
            ProtoBuf.PersistantPlayer playerInfo = SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerInfo(player.userID);
            foreach (ItemBlueprint itemBlueprint in ItemManager.bpList)
            {
                if (itemBlueprint.userCraftable && !itemBlueprint.defaultBlueprint)
                {
                    if (!playerInfo.unlockedItems.Contains(itemBlueprint.targetItem.itemid))                   
                        playerInfo.unlockedItems.Add(itemBlueprint.targetItem.itemid);
                }
            }
            SingletonComponent<ServerMgr>.Instance.persistance.SetPlayerInfo(player.userID, playerInfo);
            player.SendNetworkUpdateImmediate(false);
            player.ClientRPCPlayer<int>(null, player, "UnlockedBlueprint", 0);
        }

        private void Unload()
        {
            foreach (ItemBlueprint bp in ItemManager.GetBlueprints())
                bp.workbenchLevelRequired = defaultBlueprints[bp.targetItem.itemid];
        }
        #endregion
       
        #region Config        
        private ConfigData configData;
        private class ConfigData
        {
            [JsonProperty(PropertyName = "Disable the need for blueprints")]
            public bool NoBlueprints { get; set; }            
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            ConfigData config = new ConfigData
            {
                NoBlueprints = false
            };
            SaveConfig(config);
        }

        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();

        private void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion
    }
}


// --- End of file: NoWorkbench.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/RocketGuns.cs ---
// --- Original Local Path: BeeRust/RocketGuns.cs ---

﻿using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using System;
using System.Collections.Generic;
using Network;
using ProtoBuf;

namespace Oxide.Plugins
{
    [Info("RocketGuns", "Koks", "1.0.0")]
    [Description("RocketGuns")]
    public class RocketGuns : RustPlugin
    {
        private readonly List<string> Guns = new List<string>()
        {
            "rifle.ak",
            "rifle.ak.ice",
            "rifle.bolt",
            "hmlmg",
            "rifle.l96",
            "rifle.lr300",
            "lmg.m249",
            "rifle.m39",
            "rifle.semiauto"
        };
        private const string PermUse = "rocketguns.use";

        #region[Commands]
        [ChatCommand("t")]
        private void ToggleRocketCMD(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.userID.ToString(), PermUse))
            {
                SendReply(player, lang.GetMessage("NoPerm", this, player.userID.ToString()));
                return;
            }
            if (ActiveGUNS.Contains(player.userID))
            {
                SendReply(player, lang.GetMessage("Off", this, player.userID.ToString()));
                ActiveGUNS.Remove(player.userID);
                DestroyCUI(player);
                return;
            }
            else
            {
                SendReply(player, lang.GetMessage("On", this, player.userID.ToString()));
                ActiveGUNS.Add(player.userID);
                CreateUi(player);
                return;
            }

        }
        #endregion[Commands]

        #region[Rocket prefabs]
        public string Rocket = "assets/prefabs/ammo/rocket/rocket_basic.prefab";
        public string Hv = "assets/prefabs/ammo/rocket/rocket_hv.prefab";
        public string Fire = "assets/content/vehicles/mlrs/rocket_mlrs.prefab";
        #endregion[Rocket prefabs]

        #region GUI
        List<ulong> ActiveGUNS = new List<ulong>();
        void DestroyCUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "GunUI");
        }

        public void CreateUi(BasePlayer player)
        {
            DestroyCUI(player);
            CuiElementContainer elements = new CuiElementContainer();
            string panel = elements.Add(new CuiPanel
            {
                Image = { Color = "0.5 0.5 0.5 0.0" },
                RectTransform = { AnchorMin = config.ImageAnchorMin, AnchorMax = config.ImageAnchorMax }
            }, "Hud.Menu", "GunUI");
            elements.Add(new CuiElement
            {
                Parent = panel,
                Components =
                {
                    new CuiRawImageComponent {Color = config.ImageColor, Url = config.ImageUrlIcon},
                    new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1"}
                }
            });
            CuiHelper.AddUi(player, elements);
        }

        #endregion GUI

        #region[Hooks]
        void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                DestroyCUI(player);
            }
            ActiveGUNS = null;
        }
        private void Init()
        {
            permission.RegisterPermission(PermUse, this);
        }
        void OnPlayerDisconnected(BasePlayer player)
        {
            if (ActiveGUNS.Contains(player.userID))
            {
                DestroyCUI(player);
            }
            else return;
        }
        private void OnWeaponFired(BaseProjectile projectile, BasePlayer player, ItemModProjectile mod, ProjectileShoot projectileShoot)
        {
            if (player == null) return;
            if (ActiveGUNS.Contains(player.userID) && Guns.Contains(projectile.GetItem()?.info?.shortname))
            {
                string ammo = string.Empty;
                float speed = 0;
                if (mod.name.Contains("hv"))
                {
                    ammo = Hv;
                    speed = config.HvSpeed;
                }
                if (config.UseFire && mod.name.Contains("fire"))
                {
                    ammo = Fire;
                    speed = config.FireSpeed;
                }
                if (mod.name.Contains("explosive"))
                {
                    ammo = Rocket;
                    speed = config.NormalSpeed;
                }
                var heldEntity = projectile.GetItem();
                projectile.primaryMagazine.contents = projectile.primaryMagazine.capacity;
                projectile.SendNetworkUpdateImmediate();
                int projectileID = projectileShoot.projectiles[0].projectileID;
                if (string.IsNullOrEmpty(ammo)) { return; }
                FireRockets(player, speed, ammo);
            }
            else return;
        }
        void OnLoseCondition(Item item, ref float amount)
        {               
            if (item == null) return;                                     
            BasePlayer player = item.GetOwnerPlayer();
            if (player == null) return;
            if(ActiveGUNS.Contains(player.userID))amount = 0;
        }
        #endregion[Hooks]

        #region[Core]
        public void FireRockets(BasePlayer player, float speed, string ammo)
        {
            if (player == null) return;
            var rocket = GameManager.server.CreateEntity(ammo, player.eyes.position, new Quaternion());
            if (rocket != null)
            {
                rocket.creatorEntity = player;
                rocket.SendMessage("InitializeVelocity", player.eyes.HeadForward() * speed);
                rocket.OwnerID = player.userID;
                rocket.Spawn();
                rocket.ClientRPC(null, "RPCFire");
                return;
            }
        }
        #endregion[Core]

        #region Config
        public Configuration config;
        public class Configuration
        {
            [JsonProperty("Allow fire rockets (may cause server lag if too many fired)")]
            public bool UseFire = false;

            [JsonProperty("Hv rocket speed ")]
            public float HvSpeed = 200;

            [JsonProperty("Normal rocket speed")]
            public float NormalSpeed = 100;

            [JsonProperty("Fire rocket speed")]
            public float FireSpeed = 100;

            [JsonProperty("Icon URL (.png or .jpg)")]
            public string ImageUrlIcon = "https://www.citypng.com/public/uploads/preview/fire-explosion-mushroom-cartoon-illustration-hd-png-11665511403qjc2bf8lnu.png";

            [JsonProperty("Image Color")]
            public string ImageColor = "1 1 1 1";

            [JsonProperty("Image AnchorMin")]
            public string ImageAnchorMin = "0.645 0.023";

            [JsonProperty("Image AnchorMax")]
            public string ImageAnchorMax = "0.688 0.095";

        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
                SaveConfig();
            }
            catch (Exception e)
            {
                Debug.LogException(e);
                PrintWarning("Creating new config file.");
                LoadDefaultConfig();
            }
        }
        protected override void LoadDefaultConfig() => config = new Configuration();
        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion

        #region[Localization]
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoPerm"] = "You dont have permission to use this command",
                ["Off"] = "Raid gun disengaged",
                ["On"] = "Raid gun engaged"
            }, this);
        }
        #endregion[Localization]
    }
}


// --- End of file: RocketGuns.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/InstantBuy.cs ---
// --- Original Local Path: BeeRust/InstantBuy.cs ---

﻿
namespace Oxide.Plugins
{
    [Info("Instant Buy", "Jake_Rich/collect_vood/Bushhy", "1.0.3")]
    [Description("Vending Machine has no delay")]

    public class InstantBuy : CovalencePlugin
    {
        #region Constants

        private const string permUse = "instantbuy.use";

        #endregion

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(permUse, this);
        }

        private object OnBuyVendingItem(VendingMachine machine, BasePlayer player, int sellOrderID, int amount)
        {
            if (machine == null || player == null) return null;

            if (!permission.UserHasPermission(player.UserIDString, permUse)) return null;
			
			if (player.inventory.containerMain.IsFull() && player.inventory.containerBelt.IsFull()) return null;

            machine.ClientRPC<int>(null, "CLIENT_StartVendingSounds", sellOrderID);
            machine.DoTransaction(player, sellOrderID, amount);
            return false;
        }

        #endregion
    }
}

// --- End of file: InstantBuy.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/ServerStatus.cs ---
// --- Original Local Path: BeeRust/ServerStatus.cs ---

﻿using Newtonsoft.Json;
using System.Collections.Generic;
using Oxide.Core;
using System;
using System.Text.RegularExpressions;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries;
using System.Linq;
using ConVar;
using Oxide.Game.Rust.Libraries;

namespace Oxide.Plugins
{
    [Info("Server Status", "UNKN0WN", "1.3.0")]
    [Description("Server Status Check for discord Webhook")]
    class ServerStatus : RustPlugin
    {
        private Configuration _config;
        [PluginReference] Plugin SmoothRestart;
        private bool isQuit = false;
        private bool isSR = false;

        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            if (null != arg)
            {
                string commandName = arg.cmd.Name;
                string[] args = arg.Args;

                if (null == commandName) return null;
                if(isSR == true)
                {
                    if("sr.restart".Equals(commandName))
                    {
                        string time = "300";
                        string reason = "Unknown";
                        if (null != args)
                        {
                            if("stop".Equals(args[0]))
                            {
                                SendMessage(Lang("Restart Cancel"), Lang("Restart Cancel Descriptions"));
                                Puts("Restart has been cancelled.");
                                return null;
                            }
                            else
                            {
                                if (2 <= args.Length)
                                {
                                    time = args[0];
                                    reason = "";
                                    for (int i = 1; i < args.Length; i++)
                                    {
                                        reason += args[i];
                                        if (i < args.Length - 1) reason += " ";
                                    }
                                }
                                else
                                {
                                    time = args[0];
                                }
                            }
                        }

                        var list = new Dictionary<string, string>
                        {
                            { "time", time },
                            { "reason", reason }
                        };
                        SendMessage(Lang("Restart"), Lang("Restart Descriptions", list));
                    }
                }
                if(isSR == false)
                {
                    if ("restart".Equals(commandName))
                    {
                        string time = "300";
                        string reason = "Unknown";
                        if (null != args)
                        {
                            if ("-1".Equals(args[0]))
                            {
                                SendMessage(Lang("Restart Cancel"), Lang("Restart Cancel Descriptions"));
                                Puts("Restart has been cancelled.");
                                return null;
                            }
                            else
                            {
                                if (2 <= args.Length)
                                {
                                    time = args[0];
                                    reason = "";
                                    for (int i = 1; i < args.Length; i++)
                                    {
                                        reason += args[i];
                                        if (i < args.Length - 1) reason += " ";
                                    }
                                }
                                else
                                {
                                    time = args[0];
                                }
                            }
                        }
                        var list = new Dictionary<string, string>
                        {
                            { "time", time },
                            { "reason", reason }
                        };
                        SendMessage(Lang("Restart"), Lang("Restart Descriptions", list));
                    }
                }
                
                if ("quit".Equals(commandName))
                {
                    timer.Once(3f, () =>
                    {
                        isQuit = true;
                        Server.Command("quit");
                    });

                    if (!isQuit)
                    {
                        SendMessage(Lang("Quit"), Lang("Quit Descriptions"));
                        return isQuit;
                    }
                }
            }

            return null;
        }

        private void OnServerInitialized()
        {
            if (_config.webhook == "webhookurl" || _config.webhook == null || _config.webhook == string.Empty)
            {
                PrintWarning("Change WebHook URL");
                return;
            }

            if(SmoothRestart != null)
            {
                isSR = true;
                PrintWarning("SmoothRestart Plugins Allowed");
            }

            SendMessage(Lang("Online"), Lang("Online Descriptions"));
        }

        #region Config
        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();
            SaveConfig();
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config);

        private class Configuration
        {
            [JsonProperty("Discord WebHook")]
            public string webhook { get; set; } = "webhookurl";

            [JsonProperty("Embed Fields Time Format")]
            public string TimeFormat { get; set; } = "MM/dd/yyyy HH:mm:ss";

            [JsonProperty("Selection Mention (0 - none | 1 - @here | 2 - @everyone | 3 - @something)")]
            public int SelectionMention { get; set; } = 0;

            [JsonProperty("Designated mention")]
            public string DesignatedMention = "@something";
        }
        #endregion
        #region Lang
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Title"] = "Server Status 💫",
                ["Online"] = "📡 Server is online | ✅",
                ["Quit"] = "📡 Server is offline | ❌",
                ["Restart"] = "📡 The server has started restarting | ⏳",
                ["Restart Cancel"] = "📡 The server has canceled the restart | ⏳",
                ["Time"] = "Time:",
                ["Descriptions"] = "Descriptions:",
                ["Online Descriptions"] = "🎈 Server is Online",
                ["Quit Descriptions"] = "🎈 Server is Offline",
                ["Restart Descriptions"] = "🎈 The server shuts down after {time} seconds.\n\n🎈 Reason: {reason}",
                ["Restart Cancel Descriptions"] = "🎈 Server is Cancel Restart",
                ["Unknown"] = "Unknown"

            }, this, "en");
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Title"] = "서버 상태 💫",
                ["Online"] = "📡 서버 시작 | ✅",
                ["Quit"] = "📡 서버 중지. | ❌",
                ["Restart"] = "📡 서버 재시작 | ⏳",
                ["Restart Cancel"] = "📡 재시작 취소| ⏳",
                ["Time"] = "시간:",
                ["Descriptions"] = "설명:",
                ["Online Descriptions"] = "🎈 서버가 시작되었습니다.",
                ["Quit Descriptions"] = "🎈 서버가 중지되었습니다.",
                ["Restart Descriptions"] = "🎈 서버가  {time} 초 후에 재시작 됩니다.\n\n🎈 이유: {reason}",
                ["Restart Cancel Descriptions"] = "🎈 서버 재시작이 취소되었습니다.",
                ["Unknown"] = "알수없음"
            }, this, "kr");
        }

        private string Lang(string key, Dictionary<string, string> args = null)
        {
            if (string.IsNullOrEmpty(key))
                return string.Empty;

            key = lang.GetMessage(key, this);

            if (args != null)
            {
                foreach (var lekey in args)
                {
                    if (key.Contains("{" + lekey.Key + "}"))
                        key = key.Replace("{" + lekey.Key + "}", lekey.Value);
                }
            }

            return key;
        }
        #endregion
        #region Discord
        private void SendMessage(string status, string reason)
        {
            var list = new Dictionary<string, string>
            {
                { "hostname", ConVar.Server.hostname },
                { "ip", ConVar.Server.ip },
                { "port", ConVar.Server.port.ToString() },
                { "online", BasePlayer.activePlayerList.Count.ToString() },
                { "maxplayers", ConVar.Server.maxplayers.ToString() }
            };
            var embed = new Embed()
                .AddField(Lang("Title", list), status, true)
                .AddField(Lang("Time"), $"{DateTime.Now.ToString(_config.TimeFormat)}", false)
                .AddField(Lang("Descriptions", list), reason, false);

            if(_config.SelectionMention == 0)
            {
                webrequest.Enqueue(_config.webhook, new DiscordMessage("", embed).ToJson(), (code, response) => {
                }, this, RequestMethod.POST, new Dictionary<string, string>() {
                { "Content-Type", "application/json" }
                });
            }
            else if (_config.SelectionMention == 1)
            {
                webrequest.Enqueue(_config.webhook, new DiscordMessage("@here", embed).ToJson(), (code, response) => {
                }, this, RequestMethod.POST, new Dictionary<string, string>() {
                { "Content-Type", "application/json" }
                });
            }
            else if (_config.SelectionMention == 2)
            {
                webrequest.Enqueue(_config.webhook, new DiscordMessage("@everyone", embed).ToJson(), (code, response) => {
                }, this, RequestMethod.POST, new Dictionary<string, string>() {
                { "Content-Type", "application/json" }
                });
            }
            else if (_config.SelectionMention == 3)
            {
                webrequest.Enqueue(_config.webhook, new DiscordMessage($"{_config.DesignatedMention}", embed).ToJson(), (code, response) => {
                }, this, RequestMethod.POST, new Dictionary<string, string>() {
                { "Content-Type", "application/json" }
                });
            }
            
        }

        private class DiscordMessage
        {
            
            public DiscordMessage(string content, params Embed[] embeds)
            {
                Content = "" + content;
                Embeds = embeds.ToList();
            }

            [JsonProperty("content")] public string Content { get; set; }
            [JsonProperty("embeds")] public List<Embed> Embeds { get; set; }

            public string ToJson() => JsonConvert.SerializeObject(this);
        }

        private class Embed
        {
            [JsonProperty("fields")] public List<Field> Fields { get; set; } = new List<Field>();

            public Embed AddField(string name, string value, bool inline)
            {
                Fields.Add(new Field(name, Regex.Replace(value, "<.*?>", string.Empty), inline));

                return this;
            }
        }

        private class Field
        {
            public Field(string name, string value, bool inline)
            {
                Name = name;
                Value = value;
                Inline = inline;
            }

            [JsonProperty("name")] public string Name { get; set; }
            [JsonProperty("value")] public string Value { get; set; }
            [JsonProperty("inline")] public bool Inline { get; set; }
        }
        #endregion
    }
}


// --- End of file: ServerStatus.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/Rustcord.cs ---
// --- Original Local Path: BeeRust/Rustcord.cs ---

﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Net;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core.Plugins;
using UnityEngine;
using Facepunch;
using Oxide.Ext.Discord;
using Oxide.Ext.Discord.Attributes;
using Oxide.Core.Libraries.Covalence;
using Oxide.Ext.Discord.Builders;
using Oxide.Ext.Discord.Entities;
using Oxide.Ext.Discord.Entities.Activities;
using Oxide.Ext.Discord.Entities.Channels;
using Oxide.Ext.Discord.Entities.Gatway;
using Oxide.Ext.Discord.Entities.Gatway.Commands;
using Oxide.Ext.Discord.Entities.Gatway.Events;
using Oxide.Ext.Discord.Entities.Guilds;
using Oxide.Ext.Discord.Entities.Messages;
using Oxide.Ext.Discord.Entities.Messages.Embeds;
using Oxide.Ext.Discord.Entities.Users;
using Oxide.Ext.Discord.Entities.Permissions;
using Oxide.Ext.Discord.Logging;


namespace Oxide.Plugins
{
    [Info("Rustcord", "Kirollos & OuTSMoKE", "3.3.2")]
    [Description("Complete game server monitoring through discord.")]
    internal class Rustcord : RustPlugin
    {
        [PluginReference] Plugin PrivateMessages, BetterChatMute, Clans, AdminChat, DiscordAuth, AdminHammer, AdminRadar, Kits, Vanish, RaidableBases, DangerousTreasures, NoGiveNotices, Give, AirEvent, HarborEvent, JunkyardEvent, PowerPlantEvent;
        [DiscordClient] private DiscordClient _client;

        #region Back End Shit

        private Settings _settings;

        private int? _channelCount;

        private Snowflake _botId;

        private UpdatePresenceCommand DiscordPresence = new UpdatePresenceCommand
        {
            Activities = new List<DiscordActivity>
            {
                new DiscordActivity
                {
                    Type = ActivityType.Game,
                    Name = "Rustcord Initializing..."
                }
            }
        };

        private Timer StatusTimer = null;

        private object FindUserByID(DiscordUser user)
        {
            throw new NotImplementedException();
        }

        private static string FormatTime(TimeSpan time)
        {
            var values = new List<string>();

            if (time.Days != 0)
                values.Add($"{time.Days} day(s)");

            if (time.Hours != 0)
                values.Add($"{time.Hours} hour(s)");

            if (time.Minutes != 0)
                values.Add($"{time.Minutes} minute(s)");

            if (time.Seconds != 0)
                values.Add($"{time.Seconds} second(s)");

            return values.ToSentence();
        }

        private string GetPlayerFormattedField(IPlayer player)
        {
            return $"{player.Name} ([{player.Id}](https://steamcommunity.com/profiles/{player.Id}))";
        }

        private string GetFormattedSteamID(string id)
        {
            return $"[{id}](https://steamcommunity.com/profiles/{id})";
        }

        private string FindGridPosition(Vector3 position) => PhoneController.PositionToGridCoord(position);

        enum CacheType
        {
            OnPlayerChat = 0,
            OnPlayerConnected = 1,
            OnPlayerDisconnected = 2,
            OnPlayerJoin = 3
        }

        Dictionary<CacheType, Dictionary<BasePlayer, Dictionary<string, string>>> cache = new Dictionary<CacheType, Dictionary<BasePlayer, Dictionary<string, string>>>();
        private string rbdiff;

        Dictionary<string, string> GetPlayerCache(BasePlayer player, string message, CacheType type)
        {
            switch (type)
            {
                case CacheType.OnPlayerChat:
                    {
                        Dictionary<string, string> dict;
                        if (!cache[CacheType.OnPlayerChat].TryGetValue(player, out dict))
                        {
                            cache[CacheType.OnPlayerChat].Add(player, dict = new Dictionary<string, string>
                            {
                                ["playername"] = player.displayName,
                                ["message"] = message,
                                ["playersteamid"] = player.UserIDString,
                                ["time"] = DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")
                            });
                        }

                        dict["playername"] = player.displayName;
                        dict["message"] = message;
                        dict["playersteamid"] = player.UserIDString;
                        dict["time"] = DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt");
                        return dict;
                    }
                case CacheType.OnPlayerConnected:
                    {
                        Dictionary<string, string> dict;
                        if (!cache[CacheType.OnPlayerConnected].TryGetValue(player, out dict))
                        {
                            cache[CacheType.OnPlayerConnected].Add(player, dict = new Dictionary<string, string>
                            {
                                ["playername"] = player.displayName,
                                ["playerip"] = message.Substring(0, message.IndexOf(":")),
                                ["playersteamid"] = player.UserIDString,
                                ["time"] = DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")
                            });
                        }

                        dict["playername"] = player.displayName;
                        dict["playerip"] = message.Substring(0, message.IndexOf(":"));
                        dict["playersteamid"] = player.UserIDString;
                        dict["time"] = DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt");
                        return dict;
                    }
                case CacheType.OnPlayerJoin:
                    {
                        Dictionary<string, string> dict;
                        if (!cache[CacheType.OnPlayerJoin].TryGetValue(player, out dict))
                        {
                            cache[CacheType.OnPlayerDisconnected].Add(player, dict = new Dictionary<string, string>
                            {
                                ["playername"] = player.displayName,
                                ["time"] = DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")
                            });
                        }

                        dict["playername"] = player.displayName;
                        dict["time"] = DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt");
                        return dict;
                    }
                case CacheType.OnPlayerDisconnected:
                default:
                    {
                        Dictionary<string, string> dict;
                        if (!cache[CacheType.OnPlayerDisconnected].TryGetValue(player, out dict))
                        {
                            cache[CacheType.OnPlayerDisconnected].Add(player, dict = new Dictionary<string, string>
                            {
                                ["playername"] = player.displayName,
                                ["reason"] = message,
                                ["time"] = DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")
                            });
                        }

                        dict["playername"] = player.displayName;
                        dict["reason"] = message;
                        dict["time"] = DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt");
                        return dict;
                    }
            }
        }

        private void OnDiscordClientCreated()
        {
            if (string.IsNullOrEmpty(_settings.General.Apikey) || _settings.General.Apikey == null || _settings.General.Apikey == "BotToken")
            {
                PrintError("API key is empty or invalid!");
                return;
            }

            bool flag = true;
            try
            {
                DiscordSettings settings = new DiscordSettings
                {
                    ApiToken = _settings.General.Apikey,
                    Intents = GatewayIntents.Guilds | GatewayIntents.GuildMembers | GatewayIntents.GuildMessages | GatewayIntents.DirectMessages,
                    LogLevel = _settings.General.ExtensionDebugging
                };
                _client.Connect(settings);
            }
            catch (Exception e)
            {
                flag = false;
                PrintError($"Rustcord failed to create client! Exception message: {e}");
            }

            if (flag)
            {
                cmd.AddChatCommand(_settings.General.ReportCommand, this, "cmdReport");
                cmd.AddChatCommand("bug", this, "cmdBug");
                SubscribeHooks();
            }

            if (_settings.GameLog.EnableCustomLogging)
                UnityEngine.Application.logMessageReceived += ConsoleLog;
        }

        private void Reload()
        {
            rust.RunServerCommand("oxide.reload Rustcord");
        }

        void OnDiscordGatewayReady(GatewayReadyEvent rdy)
        {
            _botId = rdy.User.Id;
            SubscribeHooks();
            _channelCount = _settings?.Channels.Count;
            if (_settings.General.EnableBotStatus)
            {
                NextFrame(() =>
                {
                    if (StatusTimer != null && !StatusTimer.Destroyed)
                    {
                        StatusTimer.Destroy();
                    }
                    StatusTimer = timer.Every(6f, () =>
                    {
                        var text = new Dictionary<string, string>
                        {
                            ["playercount"] = Convert.ToString(BasePlayer.activePlayerList.Count),
                            ["maxplayers"] = Convert.ToString(ConVar.Server.maxplayers),
                            ["sleepercount"] = Convert.ToString(BasePlayer.sleepingPlayerList.Count)
                        };
                        var msg = Translate("Discord_Status", text);
                        DiscordPresence.Activities[0].Name = string.IsNullOrEmpty(msg) ? "Rustcord initializing...." : msg;
                        _client.Bot.UpdateStatus(DiscordPresence);
                    });
                });
            }
        }

        void OnDiscordGuildCreated(DiscordGuild newguild)
        {

            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("msg_plugininit"))
                {
                    GetChannel(_client, _settings.Channels[i].Channelid, c => {
                        c.CreateMessage(_client, "Rustcord Initialized!");
                    }, newguild.Id);
                }
            }
        }

        private void Unload()
        {
            if (StatusTimer != null && !StatusTimer.Destroyed)
            {
                StatusTimer.Destroy();
            }
            if (_settings.GameLog.EnableCustomLogging)
                UnityEngine.Application.logMessageReceived -= ConsoleLog;
        }

        private void OnDiscordGuildMessageCreated(DiscordMessage message)
        {
            if ((message.Content?.Length ?? 0) == 0) return;
            Settings.Channel channelidx = FindChannelById(message.ChannelId);
            if (channelidx == null)
                return;

            if (message.Author.Id == _botId) return;
            if (message.Content[0] == _settings.DiscordSide.Commandprefix[0])
            {
                if (!channelidx.perms.Contains("cmd_allow"))
                    return;
                string cmd;
                string msg;
                try
                {
                    cmd = message.Content.Split(' ')[0].ToLower();
                    if (string.IsNullOrEmpty(cmd.Trim()))
                        cmd = message.Content.Trim().ToLower();
                }
                catch
                {
                    cmd = message.Content.Trim().ToLower();
                }

                cmd = cmd.Remove(0, 1);

                msg = message.Content.Remove(0, 1 + cmd.Length).Trim();
                cmd = cmd.Trim();
                cmd = cmd.ToLower();

                if (!channelidx.perms.Contains("cmd_" + cmd))
                    return;
                if (!_settings.Commandroles.ContainsKey(cmd))
                {
                    DiscordToGameCmd(cmd, msg, message.Author, message.ChannelId);
                    return;
                }
                var roles = _settings.Commandroles[cmd];
                if (roles.Count == 0)
                {
                    DiscordToGameCmd(cmd, msg, message.Author, message.ChannelId);
                    return;
                }

                foreach (var roleid in message.Member.Roles)
                {
                    var rolename = GetRoleNameById(roleid);
                    if (roles.Contains(rolename))
                    {
                        DiscordToGameCmd(cmd, msg, message.Author, message.ChannelId);
                        break;
                    }
                }
            }
            else
            {
                var chattag = _settings.DiscordSide.GameChatTag;
                var chattagcolor = _settings.DiscordSide.GameChatTagColor;
                var chatnamecolor = _settings.DiscordSide.GameChatNameColor;
                var chattextcolor = _settings.DiscordSide.GameChatTextColor;
                if (!channelidx.perms.Contains("msg_chat")) return;
                string nickname = message.Member?.Nickname ?? "";
                if (nickname.Length == 0)
                    nickname = message.Author.Username;
                //PrintToChat("<color=" + chattagcolor + ">" + chattag + "</color> " + "<color=" + chatnamecolor + ">" + nickname + ":</color> " + "<color=" + chattextcolor + ">" + message.content + "</color>");
                string text = $"<color={chattagcolor}>{chattag}</color> <color={chatnamecolor}>{nickname}:</color> <color={chattextcolor}>{message.Content}</color>";
                foreach (var player in BasePlayer.activePlayerList) Player.Message(player, text, _settings.DiscordSide.GameChatIconSteamID);
                Puts("[DISCORD] " + nickname + ": " + message.Content);
            }
        }

        private string Translate(string msg, Dictionary<string, string> parameters = null)
        {
            if (string.IsNullOrEmpty(msg))
                return string.Empty;

            msg = lang.GetMessage(msg, this);

            if (parameters != null)
            {
                foreach (var lekey in parameters)
                {
                    if (msg.Contains("{" + lekey.Key + "}"))
                        msg = msg.Replace("{" + lekey.Key + "}", lekey.Value);
                }
            }

            return msg;
        }


        private Settings.Channel FindChannelById(Snowflake id)
        {
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].Channelid == id)
                    return _settings.Channels[i];
            }

            return null;
        }

        private void GetChannel(DiscordClient c, Snowflake chan_id, Action<DiscordChannel> cb, Snowflake guildid = default(Snowflake))
        {
            //Guild g = guildid == null ? c.DiscordServers.FirstOrDefault(x => x.channels.FirstOrDefault(y => y.id == chan_id) != null) : c.GetGuild(guildid);
            DiscordGuild g = null;
            DiscordChannel foundchan = null;
            if (guildid.IsValid())
                g = c.Bot.GetGuild(guildid);
            else
                foreach (var G in c.Bot.Servers.Values)
                {
                    foundchan = G.Channels[chan_id];
                    if (foundchan != null)
                    {
                        g = G;
                        break;
                    }
                }
            if (g == null)
            {
                PrintWarning($"Rustcord failed to fetch channel! (chan_id={chan_id}). Guild is invalid.");
                return;
            }
            if (g.Unavailable ?? false == true)
            {
                PrintWarning($"Rustcord failed to fetch channel! (chan_id={chan_id}). Guild is possibly invalid or not available yet.");
                return;
            }
            //Channel foundchan = g?.channels?.FirstOrDefault(z => z.id == chan_id);
            if (foundchan == null)
            {
                if (guildid.IsValid()) return; // Ignore printing error
                PrintWarning($"Rustcord failed to fetch channel! (chan_id={chan_id}).");
                return;
            }
            if (foundchan.Id != chan_id) return;
            cb?.Invoke(foundchan);
        }

        private string GetRoleNameById(Snowflake id)
        {
            //var role = _client.DiscordServers.FirstOrDefault(x => x.roles.FirstOrDefault(y => y.id == id) != null)?.roles.FirstOrDefault(z => z.id == id);
            //return role?.name ?? "";
            foreach (var r in _client.Bot.Servers.Values)
            {
                var role = r.Roles[id];
                if (role != null)
                {
                    return role.Name;
                }
            }
            return string.Empty;
        }

        private IPlayer FindPlayer(string nameorId)
        {
            foreach (var player in covalence.Players.Connected)
            {
                if (player.Id == nameorId)
                    return player;

                if (player.Name == nameorId)
                    return player;
            }

            return null;
        }

        private DiscordUser FindUserByID(Snowflake id)
        {
            foreach (DiscordGuild guild in _client.Bot.Servers.Values)
            {
                var member = guild.Members[id];
                if (member != null)
                {
                    return member.User;
                }
            }

            return null;
        }

        private BasePlayer FindPlayerByID(string Id)
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (player.UserIDString == Id)
                    return player;
            }

            return null;
        }

        private IPlayer GetPlayer(string id)
        {
            return covalence.Players.FindPlayerById(id);
        }

        private IPlayer GetPlayer(ulong id)
        {
            return GetPlayer(id.ToString());
        }

        #endregion

        #region Config Layout
        private class Settings
        {
            [JsonProperty(PropertyName = "General Settings")]
            public GeneralSettings General { get; set; }

            [JsonProperty(PropertyName = "Discord to Game Settings")]
            public DiscordSideSettings DiscordSide { get; set; }

            [JsonProperty(PropertyName = "Rust Logging Settings")]
            public GameLogSettings GameLog { get; set; }

            [JsonProperty(PropertyName = "Plugin Logging Settings")]
            public PluginLogSettings PluginLog { get; set; }

            [JsonProperty(PropertyName = "Premium Plugin Logging Settings")]
            public PremiumPluginLogSettings PremiumPluginLog { get; set; }

            [JsonProperty(PropertyName = "Discord Output Formatting")]
            public OutputSettings OutputFormat { get; set; }

            [JsonProperty(PropertyName = "Logging Exclusions")]
            public ExcludedSettings Excluded { get; set; }

            [JsonProperty(PropertyName = "Filter Settings")]
            public FilterSettings Filters { get; set; }

            [JsonProperty(PropertyName = "Discord Logging Channels")]
            public List<Channel> Channels { get; set; }

            [JsonProperty(PropertyName = "Discord Command Role Assignment (Empty = All roles can use command.)")]
            public Dictionary<string, List<string>> Commandroles { get; set; }

            public class Channel
            {
                [JsonProperty(PropertyName = "Discord Channel ID #")]
                public Snowflake Channelid { get; set; }

                [JsonProperty(PropertyName = "Channel Flags")]
                public List<string> perms { get; set; }

                [JsonProperty(PropertyName = "Custom: Words/Phrases to Log")]
                public List<string> CustomFilter { get; set; }
            }



        }

        public class GeneralSettings
        {
            [JsonProperty(PropertyName = "API Key (Bot Token)")]
            public string Apikey { get; set; }

            [JsonProperty(PropertyName = "Auto Reload Plugin")]
            public bool AutoReloadPlugin { get; set; }

            [JsonProperty(PropertyName = "Auto Reload Time (Seconds)")]
            public int AutoReloadTime { get; set; }

            [JsonProperty(PropertyName = "Enable Bot Status")]
            public bool EnableBotStatus { get; set; }

            [JsonProperty(PropertyName = "In-Game Report Command")]
            public string ReportCommand { get; set; }

            [JsonConverter(typeof(StringEnumConverter))]
            [DefaultValue(DiscordLogLevel.Info)]
            [JsonProperty(PropertyName = "Discord Extension Log Level (Verbose/Debug/Info/Warning/Error/Exception/Off)")]
            public DiscordLogLevel ExtensionDebugging { get; set; } = DiscordLogLevel.Info;
        }

        public class DiscordSideSettings
        {
            [JsonProperty(PropertyName = "Discord Command Prefix")]
            public string Commandprefix { get; set; }

            [JsonProperty(PropertyName = "Discord to Game Chat: Icon (Steam ID)")]
            public ulong GameChatIconSteamID { get; set; }

            [JsonProperty(PropertyName = "Discord to Game Chat: Tag")]
            public string GameChatTag { get; set; }

            [JsonProperty(PropertyName = "Discord to Game Chat: Tag Color (Hex)")]
            public string GameChatTagColor { get; set; }

            [JsonProperty(PropertyName = "Discord to Game Chat: Player Name Color (Hex)")]
            public string GameChatNameColor { get; set; }

            [JsonProperty(PropertyName = "Discord to Game Chat: Message Color (Hex)")]
            public string GameChatTextColor { get; set; }
        }

        public class GameLogSettings
        {
            [JsonProperty(PropertyName = "Enable Logging: Player Chat")]
            public bool LogChat { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Joins & Quits")]
            public bool LogJoinQuits { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Deaths")]
            public bool LogDeaths { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Vehicle Spawns (Heli/APC/Plane/Ship)")]
            public bool LogVehicleSpawns { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Crate Drops (Hackable/Supply)")]
            public bool LogCrateDrops { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Usergroup Changes")]
            public bool LogUserGroups { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Permission Changes")]
            public bool LogPermissions { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Kicks & Bans")]
            public bool LogKickBans { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Player Name Changes")]
            public bool LogNameChanges { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Server Commands (Gestures/Note Edits)")]
            public bool LogServerCommands { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Server Messages (Give/Item Spawns)")]
            public bool LogServerMessages { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Player F7 Reports")]
            public bool LogF7Reports { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Team Changes")]
            public bool LogTeams { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: RCON Connections")]
            public bool LogRCON { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Spectates")]
            public bool LogSpectates { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Server Wipe")]
            public bool LogServerWipe { get; set; }

            [JsonProperty(PropertyName = "Enable Custom Logging")]
            public bool EnableCustomLogging { get; set; }
        }

        public class PluginLogSettings
        {
            [JsonProperty(PropertyName = "Enable Logging: AdminHammer")]
            public bool LogPluginAdminHammer { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Admin Radar")]
            public bool LogPluginAdminRadar { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Better Chat Mute")]
            public bool LogPluginBetterChatMute { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Clans")]
            public bool LogPluginClans { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Dangerous Treasures")]
            public bool LogPluginDangerousTreasures { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Discord Auth")]
            public bool LogPluginDiscordAuth { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Godmode")]
            public bool LogPluginGodmode { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Kits")]
            public bool LogPluginKits { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Private Messages")]
            public bool LogPluginPrivateMessages { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Raidable Bases")]
            public bool LogPluginRaidableBases { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Sign Artist")]
            public bool LogPluginSignArtist { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Vanish")]
            public bool LogPluginVanish { get; set; }
        }
        public class PremiumPluginLogSettings
        {
            [JsonProperty(PropertyName = "Enable Logging: Air Event")]
            public bool LogPluginAirEvent { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Armored Train Event")]
            public bool LogPluginArmoredTrainEvent { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Cargo Train Event")]
            public bool LogPluginCargoTrainEvent { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Convoy Event")]
            public bool LogPluginConvoyEvent { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Harbor Event")]
            public bool LogPluginHarborEvent { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Junkyard Event")]
            public bool LogPluginJunkyardEvent { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Power Plant Event")]
            public bool LogPluginPowerPlantEvent { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Satellite Dish Event")]
            public bool LogPluginSatDishEvent { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Sputnik Event")]
            public bool LogPluginSputnikEvent { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Water Event")]
            public bool LogPluginWaterEvent { get; set; }
        }

        public class OutputSettings
        {
            [JsonProperty(PropertyName = "Output Type: Bans (Simple/Embed)")]
            public string OutputTypeBans { get; set; }

            [JsonProperty(PropertyName = "Output Type: Bug Report (Simple/Embed)")]
            public string OutputTypeBugs { get; set; }

            [JsonProperty(PropertyName = "Output Type: Deaths (Simple/Embed/DeathNotes)")]
            public string OutputTypeDeaths { get; set; }

            [JsonProperty(PropertyName = "Output Type: F7 Reports (Simple/Embed)")]
            public string OutputTypeF7Report { get; set; }

            [JsonProperty(PropertyName = "Output Type: Join/Quit (Simple/Embed)")]
            public string OutputTypeJoinQuit { get; set; }

            [JsonProperty(PropertyName = "Output Type: Join Player Info (Admin Channel) (Simple/Embed)")]
            public string OutputTypeJoinAdminChan { get; set; }

            [JsonProperty(PropertyName = "Output Type: Kicks (Simple/Embed)")]
            public string OutputTypeKicks { get; set; }

            [JsonProperty(PropertyName = "Output Type: Note Logging (Simple/Embed)")]
            public string OutputTypeNoteLog { get; set; }

            [JsonProperty(PropertyName = "Output Type: Player Name Change (Simple/Embed)")]
            public string OutputTypeNameChange { get; set; }

            [JsonProperty(PropertyName = "Output Type: /Report (Simple/Embed)")]
            public string OutputTypeReports { get; set; }

            [JsonProperty(PropertyName = "Output Type: Server Wipe (Simple/Embed)")]
            public string OutputTypeServerWipe { get; set; }

            [JsonProperty(PropertyName = "Output Type: Teams (Simple/Embed)")]
            public string OutputTypeTeams { get; set; }

            [JsonProperty(PropertyName = "Output Type (Plugin): Admin Hammer (Simple/Embed)")]
            public string OutputTypeAdminHammer { get; set; }

            [JsonProperty(PropertyName = "Output Type (Plugin): Admin Radar (Simple/Embed)")]
            public string OutputTypeAdminRadar { get; set; }

            [JsonProperty(PropertyName = "Output Type (Plugin): Better Chat Mute (Simple/Embed)")]
            public string OutputTypeBetterChatMute { get; set; }

            [JsonProperty(PropertyName = "Output Type (Plugin): Clans (Simple/Embed)")]
            public string OutputTypeClans { get; set; }

            [JsonProperty(PropertyName = "Output Type (Plugin): Dangerous Treasures (Simple/Embed)")]
            public string OutputTypeDangerousTreasures { get; set; }

            [JsonProperty(PropertyName = "Output Type (Plugin): Discord Auth (Simple/Embed)")]
            public string OutputTypeDiscordAuth { get; set; }

            [JsonProperty(PropertyName = "Output Type (Plugin): Godmode (Simple/Embed)")]
            public string OutputTypeGodmode { get; set; }

            [JsonProperty(PropertyName = "Output Type (Plugin): Kits (Simple/Embed)")]
            public string OutputTypeKits { get; set; }

            [JsonProperty(PropertyName = "Output Type (Plugin): Private Messages (Simple/Embed)")]
            public string OutputTypePMs { get; set; }

            [JsonProperty(PropertyName = "Output Type (Plugin): Raidable Bases (Simple/Embed)")]
            public string OutputTypeRaidableBases { get; set; }

            [JsonProperty(PropertyName = "Output Type (Plugin): Vanish (Simple/Embed)")]
            public string OutputTypeVanish { get; set; }

            [JsonProperty(PropertyName = "Output Type (Premium Plugin): AirEvent (Simple/Embed)")]
            public string OutputTypeAirEvent { get; set; }

            [JsonProperty(PropertyName = "Output Type (Premium Plugin): ArmoredTrainEvent (Simple/Embed)")]
            public string OutputTypeArmoredTrainEvent { get; set; }

            [JsonProperty(PropertyName = "Output Type (Premium Plugin): CargoTrainEvent (Simple/Embed)")]
            public string OutputTypeCargoTrainEvent { get; set; }

            [JsonProperty(PropertyName = "Output Type (Premium Plugin): ConvoyEvent (Simple/Embed)")]
            public string OutputTypeConvoyEvent { get; set; }

            [JsonProperty(PropertyName = "Output Type (Premium Plugin): HarborEvent (Simple/Embed)")]
            public string OutputTypeHarborEvent { get; set; }

            [JsonProperty(PropertyName = "Output Type (Premium Plugin): JunkyardEvent (Simple/Embed)")]
            public string OutputTypeJunkyardEvent { get; set; }

            [JsonProperty(PropertyName = "Output Type (Premium Plugin): PowerPlantEvent (Simple/Embed)")]
            public string OutputTypePowerPlantEvent { get; set; }

            [JsonProperty(PropertyName = "Output Type (Premium Plugin): SatDishEvent (Simple/Embed)")]
            public string OutputTypeSatDishEvent { get; set; }

            [JsonProperty(PropertyName = "Output Type (Premium Plugin): SputnikEvent (Simple/Embed)")]
            public string OutputTypeSputnikEvent { get; set; }

            [JsonProperty(PropertyName = "Output Type (Premium Plugin): WaterEvent (Simple/Embed)")]
            public string OutputTypeWaterEvent { get; set; }
        }

        public class ExcludedSettings
        {
            [JsonProperty(PropertyName = "Exclude Listed Groups From log_groups")]
            public List<string> LogExcludeGroups { get; set; }

            [JsonProperty(PropertyName = "Exclude Listed Permissions From log_perms")]
            public List<string> LogExcludePerms { get; set; }
        }

        public class FilterSettings
        {
            [JsonProperty(PropertyName = "Chat Filter: Replacement Word")]
            public string FilteredWord { get; set; }

            [JsonProperty(PropertyName = "Chat Filter: Words to Filter")]
            public List<string> FilterWords { get; set; }
        }
        #endregion

        #region Default Config
        private Settings GetDefaultSettings()
        {
            return new Settings
            {
                General = new GeneralSettings
                {
                    Apikey = "BotToken",
                    AutoReloadPlugin = false,
                    AutoReloadTime = 901,
                    EnableBotStatus = false,
                    ReportCommand = "report",
                    ExtensionDebugging = DiscordLogLevel.Info
                },
                DiscordSide = new DiscordSideSettings
                {
                    Commandprefix = "!",
                    GameChatIconSteamID = 76561199066612103,
                    GameChatTag = "[RUSTCORD]",
                    GameChatTagColor = "#7289DA",
                    GameChatNameColor = "#55aaff",
                    GameChatTextColor = "#ffffff",
                },
                GameLog = new GameLogSettings
                {
                    LogChat = true,
                    LogJoinQuits = true,
                    LogDeaths = false,
                    LogVehicleSpawns = false,
                    LogCrateDrops = false,
                    LogUserGroups = false,
                    LogPermissions = false,
                    LogKickBans = true,
                    LogNameChanges = false,
                    LogServerCommands = false,
                    LogServerMessages = false,
                    LogF7Reports = false,
                    LogTeams = false,
                    LogRCON = false,
                    LogSpectates = false,
                    LogServerWipe = false,
                    EnableCustomLogging = false
                },
                PluginLog = new PluginLogSettings
                {
                    LogPluginAdminHammer = false,
                    LogPluginAdminRadar = false,
                    LogPluginBetterChatMute = false,
                    LogPluginClans = false,
                    LogPluginDangerousTreasures = false,
                    LogPluginDiscordAuth = false,
                    LogPluginGodmode = false,
                    LogPluginKits = false,
                    LogPluginPrivateMessages = false,
                    LogPluginRaidableBases = false,
                    LogPluginSignArtist = false,
                    LogPluginVanish = false
                },
                PremiumPluginLog = new PremiumPluginLogSettings
                {
                    LogPluginAirEvent = false,
                    LogPluginArmoredTrainEvent = false,
                    LogPluginCargoTrainEvent = false,
                    LogPluginConvoyEvent = false,
                    LogPluginHarborEvent = false,
                    LogPluginJunkyardEvent = false,
                    LogPluginPowerPlantEvent = false,
                    LogPluginSputnikEvent = false,
                    LogPluginSatDishEvent = false,
                    LogPluginWaterEvent = false
                },
                OutputFormat = new OutputSettings
                {
                    OutputTypeBans = "Simple",
                    OutputTypeBugs = "Simple",
                    OutputTypeDeaths = "Simple",
                    OutputTypeF7Report = "Simple",
                    OutputTypeJoinQuit = "Simple",
                    OutputTypeJoinAdminChan = "Simple",
                    OutputTypeKicks = "Simple",
                    OutputTypeNameChange = "Simple",
                    OutputTypeNoteLog = "Simple",
                    OutputTypeReports = "Simple",
                    OutputTypeServerWipe = "Simple",
                    OutputTypeTeams = "Simple",
                    OutputTypeAdminHammer = "Simple",
                    OutputTypeAdminRadar = "Simple",
                    OutputTypeBetterChatMute = "Simple",
                    OutputTypeClans = "Simple",
                    OutputTypeDangerousTreasures = "Simple",
                    OutputTypeDiscordAuth = "Simple",
                    OutputTypeGodmode = "Simple",
                    OutputTypeKits = "Simple",
                    OutputTypePMs = "Simple",
                    OutputTypeRaidableBases = "Simple",
                    OutputTypeVanish = "Simple",
                    OutputTypeAirEvent = "Simple",
                    OutputTypeArmoredTrainEvent = "Simple",
                    OutputTypeCargoTrainEvent = "Simple",
                    OutputTypeConvoyEvent = "Simple",
                    OutputTypeHarborEvent = "Simple",
                    OutputTypeJunkyardEvent = "Simple",
                    OutputTypePowerPlantEvent = "Simple",
                    OutputTypeSputnikEvent = "Simple",
                    OutputTypeSatDishEvent = "Simple",
                    OutputTypeWaterEvent = "Simple"
                },

                Channels = new List<Settings.Channel>
                    {
                        new Settings.Channel
                            {
                                perms = new List<string>
                                {
                                    "cmd_allow",
                                    "cmd_players",
                                    "cmd_kick",
                                    "cmd_com",
                                    "cmd_mute",
                                    "cmd_unmute",
                                    "msg_join",
                                    "msg_quit",
                                    "death_pvp",
                                    "msg_chat",
                                    "game_bug",
                                    "msg_serverinit"
                                },
                                CustomFilter = new List<string>
                                {
                                    "keyword1",
                                    "keyword2"
                                }
                        },
                        new Settings.Channel
                        {
                            perms = new List<string>
                            {
                                "msg_joinlog",
                                "game_report",
                                "msg_teamchat",
                                "game_bug"
                            },
                            CustomFilter = new List<string>
                            {
                                "keyword1",
                                "keyword2"
                            }
                        }
                    },
                Commandroles = new Dictionary<string, List<string>>
                {
                    {
                        "players", new List<string>()
                        {
                            "DiscordRoleName",
                            "DiscordRoleName2"
                        }
                    },
                    {
                        "mute", new List<string>()
                        {
                            "DiscordRoleName",
                            "DiscordRoleName2"
                        }
                    },
                    {
                        "unmute", new List<string>()
                        {
                            "DiscordRoleName",
                            "DiscordRoleName2"
                        }
                    },
                    {
                        "kick", new List<string>()
                        {
                            "DiscordRoleName",
                            "DiscordRoleName2"
                        }
                    },
                    {
                        "ban", new List<string>()
                        {
                            "DiscordRoleName",
                            "DiscordRoleName2"
                        }
                    },
                    {
                        "timeban", new List<string>()
                        {
                            "DiscordRoleName",
                            "DiscordRoleName2"
                        }
                    },
                    {
                        "unban", new List<string>()
                        {
                            "DiscordRoleName",
                            "DiscordRoleName2"
                        }
                    },
                    {
                        "com", new List<string>()
                        {
                            "DiscordRoleName",
                            "DiscordRoleName2"
                        }
                    }
                },
                Filters = new FilterSettings
                {
                    FilterWords = new List<string>
                    {
                        "badword1",
                        "badword2"
                    },
                    FilteredWord = "<censored>",
                },
                Excluded = new ExcludedSettings
                {
                    LogExcludeGroups = new List<string>
                    {
                        "example-group1",
                        "example-group2"
                    },
                    LogExcludePerms = new List<string>
                    {
                        "example.permission1",
                        "example.permission2"
                    }
                },

            };
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Attempting to create default config...");
            Config.Clear();
            Config.WriteObject(GetDefaultSettings(), true);
            Config.Save();
        }
        #endregion

        #region Hooks
        void SubscribeHooks()
        {
            if (_settings.GameLog.LogChat) Subscribe(nameof(OnPlayerChat));
            if (_settings.GameLog.LogJoinQuits)
            {
                Subscribe(nameof(OnPlayerConnected));
                Subscribe(nameof(OnPlayerDisconnected));
            }



            if (_settings.GameLog.LogDeaths)
            {
                if (_settings.OutputFormat.OutputTypeDeaths == "DeathNotes") Subscribe(nameof(OnDeathNotice));
                if ((_settings.OutputFormat.OutputTypeDeaths == "Simple") || (_settings.OutputFormat.OutputTypeDeaths == "Embed")) Subscribe(nameof(OnPlayerDeath));
            }


            if (_settings.GameLog.LogVehicleSpawns) Subscribe(nameof(OnEntitySpawned));
            if (_settings.GameLog.LogCrateDrops)
            {
                Subscribe(nameof(OnCrateDropped));
                Subscribe(nameof(OnSupplyDropLanded));
            }
            if (_settings.GameLog.LogUserGroups)
            {
                Subscribe(nameof(OnGroupCreated));
                Subscribe(nameof(OnGroupDeleted));
                Subscribe(nameof(OnUserGroupAdded));
                Subscribe(nameof(OnUserGroupRemoved));
            }
            if (_settings.GameLog.LogPermissions)
            {
                Subscribe(nameof(OnUserPermissionGranted));
                Subscribe(nameof(OnGroupPermissionGranted));
                Subscribe(nameof(OnUserPermissionRevoked));
                Subscribe(nameof(OnGroupPermissionRevoked));
            }
            if (_settings.GameLog.LogKickBans)
            {
                Subscribe(nameof(OnUserKicked));
                Subscribe(nameof(OnUserBanned));
                Subscribe(nameof(OnUserUnbanned));
            }
            if (_settings.GameLog.LogNameChanges) Subscribe(nameof(OnUserNameUpdated));
            if (_settings.GameLog.LogServerMessages) Subscribe(nameof(OnServerMessage));
            if (_settings.GameLog.LogServerCommands) Subscribe(nameof(OnServerCommand));
            if (_settings.GameLog.LogF7Reports) Subscribe(nameof(OnPlayerReported));
            if (_settings.GameLog.LogServerWipe) Subscribe(nameof(OnNewSave));
            if (_settings.GameLog.LogTeams)
            {
                Subscribe(nameof(OnTeamCreated));
                Subscribe(nameof(OnTeamAcceptInvite));
                Subscribe(nameof(OnTeamLeave));
                Subscribe(nameof(OnTeamKick));
                Subscribe(nameof(OnTeamDisbanded));
            }
            if (_settings.GameLog.LogRCON)
            {
                Subscribe(nameof(OnRconConnection));
            }
            if (_settings.GameLog.LogSpectates)
            {
                Subscribe(nameof(OnPlayerSpectate));
                Subscribe(nameof(OnPlayerSpectateEnd));
            }
            if (_settings.PluginLog.LogPluginAdminHammer)
            {
                Subscribe(nameof(OnAdminHammerEnabled));
                Subscribe(nameof(OnAdminHammerDisabled));
            }
            if (_settings.PluginLog.LogPluginAdminRadar)
            {
                Subscribe(nameof(OnRadarActivated));
                Subscribe(nameof(OnRadarDeactivated));
            }
            if (_settings.PluginLog.LogPluginBetterChatMute)
            {
                Subscribe(nameof(OnBetterChatMuted));
                Subscribe(nameof(OnBetterChatTimeMuted));
                Subscribe(nameof(OnBetterChatUnmuted));
                Subscribe(nameof(OnBetterChatMuteExpired));
            }
            if (_settings.PluginLog.LogPluginClans)
            {
                Subscribe(nameof(OnClanCreate));
                Subscribe(nameof(OnClanDisbanded));
                Subscribe(nameof(OnClanChat));
            }
            if (_settings.PluginLog.LogPluginDangerousTreasures)
            {
                Subscribe(nameof(OnDangerousEventStarted));
                Subscribe(nameof(OnDangerousEventEnded));
            }
            if (_settings.PluginLog.LogPluginGodmode)
            {
                Subscribe(nameof(OnGodmodeToggled));
            }
            if (_settings.PluginLog.LogPluginKits)
            {
                Subscribe(nameof(OnKitRedeemed));
            }
            if (_settings.PluginLog.LogPluginPrivateMessages) Subscribe(nameof(OnPMProcessed));
            if (_settings.PluginLog.LogPluginRaidableBases)
            {
                Subscribe(nameof(OnRaidableBaseStarted));
                Subscribe(nameof(OnRaidableBaseEnded));
            }
            if (_settings.PluginLog.LogPluginSignArtist) Subscribe(nameof(OnImagePost));
            if (_settings.PluginLog.LogPluginDiscordAuth)
            {
                Subscribe(nameof(OnDiscordPlayerLinked));
                Subscribe(nameof(OnDiscordPlayerUnlinked));
            }
            if (_settings.PluginLog.LogPluginVanish)
            {
                Subscribe(nameof(OnVanishDisappear));
                Subscribe(nameof(OnVanishReappear));
            }
            if (_settings.PremiumPluginLog.LogPluginAirEvent)
            {
                Subscribe(nameof(OnAirEventStart));
                Subscribe(nameof(OnAirEventEnd));
            }
            if (_settings.PremiumPluginLog.LogPluginArmoredTrainEvent)
            {
                Subscribe(nameof(OnArmoredTrainEventStart));
                Subscribe(nameof(OnArmoredTrainEventStop));
            }
            if (_settings.PremiumPluginLog.LogPluginCargoTrainEvent)
            {
                Subscribe(nameof(OnTrainEventStarted));
                Subscribe(nameof(OnTrainEventEnded));
            }
            if (_settings.PremiumPluginLog.LogPluginConvoyEvent)
            {
                Subscribe(nameof(OnConvoyStart));
                Subscribe(nameof(OnConvoyStop));
            }
            if (_settings.PremiumPluginLog.LogPluginHarborEvent)
            {
                Subscribe(nameof(OnHarborEventStart));
                Subscribe(nameof(OnHarborEventEnd));
            }
            if (_settings.PremiumPluginLog.LogPluginJunkyardEvent)
            {
                Subscribe(nameof(OnJunkyardEventStart));
                Subscribe(nameof(OnJunkyardEventEnd));
            }
            if (_settings.PremiumPluginLog.LogPluginPowerPlantEvent)
            {
                Subscribe(nameof(OnPowerPlantEventStart));
                Subscribe(nameof(OnPowerPlantEventEnd));
            }
            if (_settings.PremiumPluginLog.LogPluginSputnikEvent)
            {
                Subscribe(nameof(OnSputnikEventStart));
                Subscribe(nameof(OnSputnikEventStop));
            }
            if (_settings.PremiumPluginLog.LogPluginSatDishEvent)
            {
                Subscribe(nameof(OnSatDishEventStart));
                Subscribe(nameof(OnSatDishEventEnd));
            }
            if (_settings.PremiumPluginLog.LogPluginWaterEvent)
            {
                Subscribe(nameof(OnWaterEventStart));
                Subscribe(nameof(OnWaterEventEnd));
            }
        }
        private void Init()
        {
            cache[CacheType.OnPlayerChat] = new Dictionary<BasePlayer, Dictionary<string, string>>();
            cache[CacheType.OnPlayerConnected] = new Dictionary<BasePlayer, Dictionary<string, string>>();
            cache[CacheType.OnPlayerDisconnected] = new Dictionary<BasePlayer, Dictionary<string, string>>();
            cache[CacheType.OnPlayerJoin] = new Dictionary<BasePlayer, Dictionary<string, string>>();
            UnsubscribeHooks();
        }

        void UnsubscribeHooks()
        {
            Unsubscribe(nameof(OnPlayerChat));
            Unsubscribe(nameof(OnPlayerConnected));
            Unsubscribe(nameof(OnPlayerDisconnected));
            Unsubscribe(nameof(OnDeathNotice));
            Unsubscribe(nameof(OnPlayerDeath));
            Unsubscribe(nameof(OnEntitySpawned));
            Unsubscribe(nameof(OnCrateDropped));
            Unsubscribe(nameof(OnSupplyDropLanded));
            Unsubscribe(nameof(OnGroupCreated));
            Unsubscribe(nameof(OnGroupDeleted));
            Unsubscribe(nameof(OnUserGroupAdded));
            Unsubscribe(nameof(OnUserGroupRemoved));
            Unsubscribe(nameof(OnUserPermissionGranted));
            Unsubscribe(nameof(OnGroupPermissionGranted));
            Unsubscribe(nameof(OnUserPermissionRevoked));
            Unsubscribe(nameof(OnGroupPermissionRevoked));
            Unsubscribe(nameof(OnUserKicked));
            Unsubscribe(nameof(OnUserBanned));
            Unsubscribe(nameof(OnUserUnbanned));
            Unsubscribe(nameof(OnUserNameUpdated));
            Unsubscribe(nameof(OnServerMessage));
            Unsubscribe(nameof(OnServerCommand));
            Unsubscribe(nameof(OnPlayerReported));
            Unsubscribe(nameof(OnTeamCreated));
            Unsubscribe(nameof(OnTeamAcceptInvite));
            Unsubscribe(nameof(OnTeamLeave));
            Unsubscribe(nameof(OnTeamKick));
            Unsubscribe(nameof(OnTeamDisbanded));
            Unsubscribe(nameof(OnRconConnection));
            Unsubscribe(nameof(OnPlayerSpectate));
            Unsubscribe(nameof(OnPlayerSpectateEnd));
            Unsubscribe(nameof(OnAdminHammerEnabled));
            Unsubscribe(nameof(OnAdminHammerDisabled));
            Unsubscribe(nameof(OnRadarActivated));
            Unsubscribe(nameof(OnRadarDeactivated));
            Unsubscribe(nameof(OnBetterChatTimeMuted));
            Unsubscribe(nameof(OnBetterChatMuted));
            Unsubscribe(nameof(OnBetterChatTimeMuted));
            Unsubscribe(nameof(OnBetterChatUnmuted));
            Unsubscribe(nameof(OnBetterChatMuteExpired));
            Unsubscribe(nameof(OnClanCreate));
            Unsubscribe(nameof(OnClanDisbanded));
            Unsubscribe(nameof(OnClanChat));
            Unsubscribe(nameof(OnPMProcessed));
            Unsubscribe(nameof(OnImagePost));
            Unsubscribe(nameof(OnDiscordPlayerLinked));
            Unsubscribe(nameof(OnDiscordPlayerUnlinked));
            Unsubscribe(nameof(OnRaidableBaseStarted));
            Unsubscribe(nameof(OnRaidableBaseEnded));
            Unsubscribe(nameof(OnGodmodeToggled));
            Unsubscribe(nameof(OnKitRedeemed));
            Unsubscribe(nameof(OnDangerousEventStarted));
            Unsubscribe(nameof(OnDangerousEventEnded));
            Unsubscribe(nameof(OnAirEventStart));
            Unsubscribe(nameof(OnAirEventEnd));
            Unsubscribe(nameof(OnArmoredTrainEventStart));
            Unsubscribe(nameof(OnArmoredTrainEventStop));
            Unsubscribe(nameof(OnTrainEventStarted));
            Unsubscribe(nameof(OnTrainEventEnded));
            Unsubscribe(nameof(OnConvoyStart));
            Unsubscribe(nameof(OnConvoyStop));
            Unsubscribe(nameof(OnHarborEventStart));
            Unsubscribe(nameof(OnHarborEventEnd));
            Unsubscribe(nameof(OnJunkyardEventStart));
            Unsubscribe(nameof(OnJunkyardEventEnd));
            Unsubscribe(nameof(OnPowerPlantEventStart));
            Unsubscribe(nameof(OnPowerPlantEventEnd));
            Unsubscribe(nameof(OnSatDishEventStart));
            Unsubscribe(nameof(OnSatDishEventEnd));
            Unsubscribe(nameof(OnSputnikEventStart));
            Unsubscribe(nameof(OnSputnikEventStop));
            Unsubscribe(nameof(OnWaterEventStart));
            Unsubscribe(nameof(OnWaterEventEnd));
        }
        #endregion

        #region Null Config Check
        private void Loaded()
        {
            _settings = Config.ReadObject<Settings>();

            // Make sure objects are not taken off the config, otherwise some parts of code will release NRE.

            if (_settings.OutputFormat.OutputTypeBans == null)
                _settings.OutputFormat.OutputTypeBans = "Simple";
            if (_settings.OutputFormat.OutputTypeBugs == null)
                _settings.OutputFormat.OutputTypeBugs = "Simple";
            if (_settings.OutputFormat.OutputTypeDeaths == null)
                _settings.OutputFormat.OutputTypeDeaths = "Simple";
            if (_settings.OutputFormat.OutputTypeF7Report == null)
                _settings.OutputFormat.OutputTypeF7Report = "Simple";
            if (_settings.OutputFormat.OutputTypeJoinQuit == null)
                _settings.OutputFormat.OutputTypeJoinQuit = "Simple";
            if (_settings.OutputFormat.OutputTypeJoinAdminChan == null)
                _settings.OutputFormat.OutputTypeJoinAdminChan = "Simple";
            if (_settings.OutputFormat.OutputTypeKicks == null)
                _settings.OutputFormat.OutputTypeKicks = "Simple";
            if (_settings.OutputFormat.OutputTypeNameChange == null)
                _settings.OutputFormat.OutputTypeNameChange = "Simple";
            if (_settings.OutputFormat.OutputTypeNoteLog == null)
                _settings.OutputFormat.OutputTypeNoteLog = "Simple";
            if (_settings.OutputFormat.OutputTypeReports == null)
                _settings.OutputFormat.OutputTypeReports = "Simple";
            if (_settings.OutputFormat.OutputTypeServerWipe == null)
                _settings.OutputFormat.OutputTypeServerWipe = "Simple";
            if (_settings.OutputFormat.OutputTypeTeams == null)
                _settings.OutputFormat.OutputTypeTeams = "Simple";
            if (_settings.OutputFormat.OutputTypeAdminHammer == null)
                _settings.OutputFormat.OutputTypeAdminHammer = "Simple";
            if (_settings.OutputFormat.OutputTypeAdminRadar == null)
                _settings.OutputFormat.OutputTypeAdminRadar = "Simple";
            if (_settings.OutputFormat.OutputTypeBetterChatMute == null)
                _settings.OutputFormat.OutputTypeBetterChatMute = "Simple";
            if (_settings.OutputFormat.OutputTypeClans == null)
                _settings.OutputFormat.OutputTypeClans = "Simple";
            if (_settings.OutputFormat.OutputTypeDangerousTreasures == null)
                _settings.OutputFormat.OutputTypeDangerousTreasures = "Simple";
            if (_settings.OutputFormat.OutputTypeDiscordAuth == null)
                _settings.OutputFormat.OutputTypeDiscordAuth = "Simple";
            if (_settings.OutputFormat.OutputTypeKits == null)
                _settings.OutputFormat.OutputTypeKits = "Simple";
            if (_settings.OutputFormat.OutputTypePMs == null)
                _settings.OutputFormat.OutputTypePMs = "Simple";
            if (_settings.OutputFormat.OutputTypeRaidableBases == null)
                _settings.OutputFormat.OutputTypeRaidableBases = "Simple";
            if (_settings.OutputFormat.OutputTypeVanish == null)
                _settings.OutputFormat.OutputTypeVanish = "Simple";
            if (_settings.OutputFormat.OutputTypeAirEvent == null)
                _settings.OutputFormat.OutputTypeAirEvent = "Simple";
            if (_settings.OutputFormat.OutputTypeArmoredTrainEvent == null)
                _settings.OutputFormat.OutputTypeArmoredTrainEvent = "Simple";
            if (_settings.OutputFormat.OutputTypeCargoTrainEvent == null)
                _settings.OutputFormat.OutputTypeCargoTrainEvent = "Simple";
            if (_settings.OutputFormat.OutputTypeConvoyEvent == null)
                _settings.OutputFormat.OutputTypeConvoyEvent = "Simple";
            if (_settings.OutputFormat.OutputTypeHarborEvent == null)
                _settings.OutputFormat.OutputTypeHarborEvent = "Simple";
            if (_settings.OutputFormat.OutputTypeJunkyardEvent == null)
                _settings.OutputFormat.OutputTypeJunkyardEvent = "Simple";
            if (_settings.OutputFormat.OutputTypePowerPlantEvent == null)
                _settings.OutputFormat.OutputTypePowerPlantEvent = "Simple";
            if (_settings.OutputFormat.OutputTypeSatDishEvent == null)
                _settings.OutputFormat.OutputTypeSatDishEvent = "Simple";
            if (_settings.OutputFormat.OutputTypeSputnikEvent == null)
                _settings.OutputFormat.OutputTypeSputnikEvent = "Simple";
            if (_settings.OutputFormat.OutputTypeWaterEvent == null)
                _settings.OutputFormat.OutputTypeWaterEvent = "Simple";

            foreach (var channel in _settings.Channels)
            {
                if (channel.CustomFilter == null)
                {
                    channel.CustomFilter = new List<string>();
                }
            }
            if (_settings.General.ReportCommand == null)
                _settings.General.ReportCommand = "report";
            if (string.IsNullOrEmpty(_settings.DiscordSide.GameChatTag))
                _settings.DiscordSide.GameChatTag = "[Rustcord]";
            if (string.IsNullOrEmpty(_settings.DiscordSide.GameChatTagColor))
                _settings.DiscordSide.GameChatTagColor = "#7289DA";
            if (string.IsNullOrEmpty(_settings.DiscordSide.GameChatNameColor))
                _settings.DiscordSide.GameChatNameColor = "#55aaff";
            if (string.IsNullOrEmpty(_settings.DiscordSide.GameChatTextColor))
                _settings.DiscordSide.GameChatTextColor = "#ffffff";
            if (_settings.DiscordSide.GameChatIconSteamID.Equals(0uL))
                _settings.DiscordSide.GameChatIconSteamID = 76561199066612103;
            if (_settings.Channels == null)
                _settings.Channels = new List<Settings.Channel>();
            if (_settings.Commandroles == null)
                _settings.Commandroles = new Dictionary<string, List<string>>();
            _settings.Filters = new FilterSettings
            {
                FilteredWord = _settings.Filters?.FilteredWord ?? "<censored>",
                FilterWords = _settings.Filters?.FilterWords ?? new List<string>()
            };
            if (_settings.Excluded.LogExcludeGroups == null)
                _settings.Excluded.LogExcludeGroups = new List<string>();
            if (_settings.Excluded.LogExcludePerms == null)
                _settings.Excluded.LogExcludePerms = new List<string>();

            Config.WriteObject(_settings, true);
            // ------------------------------------------------------------------------
        }
        #endregion

        #region Language File
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "Discord_PlayersResponse", ":mag_right: Connected Players [{playercount}/{maxplayers}]: {playerslist}" },
                { "Discord_Status", "{playercount}/{maxplayers} Online, {sleepercount} Sleepers." },
                { "RUST_OnInitMsg", ":vertical_traffic_light: Server is back online! Players may now re-join. :vertical_traffic_light:" },
                { "RUST_OnServerShutdown", ":vertical_traffic_light: Server shutting down. :vertical_traffic_light:" },
                { "RUST_OnPlayerGesture", ":speech_left: {playername}: {gesture}"},
                { "RUST_OnPlayerChat", ":speech_left: {playername}: {message}"},
                { "RUST_OnPlayerTeamChat", ":speech_left: {playername}: {message}"},
                { "RUST_OnPlayerJoin", ":white_check_mark: {playername} has connected!" },
                { "RUST_OnPlayerJoinAdminLog", ":clipboard: {playername} has connected! (IP: {playerip}    SteamID: {playersteamid})" },
                { "RUST_OnPlayerQuit", ":x: {playername} has disconnected! ({reason})" },
                { "RUST_OnPlayerBug", ":beetle: {playername}: {message}"},
                { "RUST_OnPlayerReport", ":warning: {playername}: {message}"},
                { "RUST_OnPlaneSpawn", ":airplane: Cargo Plane has spawned."},
                { "RUST_OnBradleySpawn", ":trolleybus: Bradley APC has spawned."},
                { "RUST_OnShipSpawn", ":ship: Cargo Ship has spawned."},
                { "RUST_OnSupplyDrop", ":airplane: A supply drop has landed."},
                { "RUST_OnHeliSpawn", ":helicopter: Patrol Helicopter has spawned."},
                { "RUST_OnChinookSpawn", ":helicopter: Chinook Helicopter has spawned."},
                { "RUST_OnCrateDropped", ":helicopter: A Chinook has delivered a crate."},
                { "RUST_OnTeamAcceptInvite", ":family_mwgb: {playername} joined {teamleader}'s team. ({teamid})"},
                { "RUST_OnTeamCreated", ":family_mwgb: {playername} created a new team. ({teamid})"},
                { "RUST_OnTeamKicked", ":family_mwgb: {teamleader} kicked {playername} from their team. ({teamid})"},
                { "RUST_OnTeamLeave", ":family_mwgb: {playername} left {teamleader}'s team ({teamid})."},
                { "RUST_OnTeamDisbanded", ":family_mwgb: {teamleader}'s team has been disbanded. ({teamid})"},
                { "RUST_OnGroupCreated", ":desktop: Group {groupname} has been created."},
                { "RUST_OnGroupDeleted", ":desktop: Group {groupname} has been deleted."},
                { "RUST_OnUserGroupAdded", ":desktop: {playername} ({playersteamid}) has been added to group: {groupname}."},
                { "RUST_OnUserGroupRemoved", ":desktop: {playername} ({playersteamid}) has been removed from group: {groupname}."},
                { "RUST_OnUserPermissionGranted", ":desktop: {playername} ({playersteamid}) has been granted permission: {permission}."},
                { "RUST_OnGroupPermissionGranted", ":desktop: Group {groupname} has been granted permission: {permission}."},
                { "RUST_OnUserPermissionRevoked", ":desktop: {playername} ({playersteamid}) has been revoked permission: {permission}."},
                { "RUST_OnGroupPermissionRevoked", ":desktop: Group {groupname} has been revoked permission: {permission}."},
                { "RUST_OnPlayerKicked", ":desktop: {playername} has been kicked for: {reason}"},
                { "RUST_OnPlayerBanned", ":desktop: {playername} ({playersteamid}/{playerip}) has been banned for: {reason}"}, //only works with vanilla/native system atm
				{ "RUST_OnPlayerUnBanned", ":desktop: {playername} ({playersteamid}/{playerip}) has been unbanned."}, //only works with vanilla/native system atm
				{ "RUST_OnPlayerNameChange", ":desktop: {oldname} ({playersteamid}) is now playing as {newname}."},
                { "RUST_OnPlayerReported", ":desktop: {reporter} reported {targetname} ({targetsteamid}) to Facepunch for {reason}. Message: {message}"},
                { "RUST_OnPlayerDeath", ":skull_crossbones: {killer} killed {victim}."},
                { "RUST_OnF1ItemSpawn", ":desktop: {playername}: {givemessage}."},
                { "RUST_OnNoteUpdate", ":desktop: [NOTES] {playername}: {notemessage}."},
                { "RUST_OnRCONConnected", ":desktop: [RCON] New connection from: {ip}."},
                { "RUST_OnPlayerSpectate", ":desktop: {playername} is spectating {targetname}"},
                { "RUST_CustomLog", ":desktop: [Custom] {logtext}"},
                { "RUST_OnPlayerSpectateEnd", ":desktop: {playername} stopped spectating {targetname}"},
                { "RUST_OnServerWipe", ":map: Server has started a fresh wipe!"},
                { "PLUGIN_AdminHammer_Enabled", ":hammer: {playername} has enabled Admin Hammer."},
                { "PLUGIN_AdminHammer_Disabled", ":hammer: {playername} has disabled Admin Hammer."},
                { "PLUGIN_AdminRadar_Enabled", ":satellite: {playername} has enabled Admin Radar."},
                { "PLUGIN_AdminRadar_Disabled", ":satellite: {playername} has disabled Admin Radar."},
                { "PLUGIN_BetterChatMute_Mute", "[MUTE] :zipper_mouth: {muter} has permanently muted {targetname}. Reason: {reason}"},
                { "PLUGIN_BetterChatMute_UnMute", "[MUTE] :loudspeaker: {unmuter} has unmuted {targetname}."},
                { "PLUGIN_BetterChatMute_TimedMute", "[MUTE] :hourglass_flowing_sand: {muter} has been temporarily muted {targetname} for {duration}. Reason: {reason}"},
                { "PLUGIN_BetterChatMute_MuteExpire", "[MUTE] :hourglass: {targetname}'s temporary mute has expired."},
                { "PLUGIN_Clans_Chat", ":speech_left: [CLANS] {playername}: {message}"},
                { "PLUGIN_Clans_CreateClan", ":family_mwgb: Clan [{clantag}] has been created."},
                { "PLUGIN_Clans_DisbandClan", ":family_mwgb: Clan [{clantag}] has been disbanded."},
                { "PLUGIN_DangerousTreasures_Started", ":moneybag: Dangerous Treasure event has started at {gridposition} {position}."},
                { "PLUGIN_DangerousTreasures_Ended", ":moneybag: Dangerous Treasure event at {gridposition} has ended."},
                { "PLUGIN_DeathNotes_Death", ":skull_crossbones: {deathmessage}"},
                { "PLUGIN_DiscordAuth_Auth", ":lock: {gamename} has linked to Discord account {discordname}."},
                { "PLUGIN_DiscordAuth_Deauth", ":unlock: {gamename} has been unlinked from Discord."},
                { "PLUGIN_Godmode_Enabled", ":shield: {playername} has enabled God Mode."},
                { "PLUGIN_Godmode_Disabled", ":shield: {playername} has disabled God Mode."},
                { "PLUGIN_Kits_Redeemed", ":gift: {playername} redeemed kit: {kitname}."},
                { "PLUGIN_PrivateMessages_PM", "[PM] {sendername}  :incoming_envelope: {targetname}: {message}"},
                { "PLUGIN_RaidableBases_Started", ":house: {difficulty} Raidable Base has spawned at {position}."},
                { "PLUGIN_RaidableBases_Ended", ":house: {difficulty} Raidable Base at {position} has ended."},
                { "PLUGIN_SignArtist", "{playername} posted an image to a sign.\nPosition: ({position})"},
                { "PLUGIN_Vanish_Disappear", ":ghost: {playername} has vanished." },
                { "PLUGIN_Vanish_Reappear", ":ghost: {playername} has reappeared." },
                { "PLUGIN_AirEvent_Started", ":helicopter: Air Event has started." },
                { "PLUGIN_AirEvent_Ended", ":helicopter: Air Event has ended." },
                { "PLUGIN_ArmoredTrainEvent_Started", ":train2: Armored Train Event has started." },
                { "PLUGIN_ArmoredTrainEvent_Ended", ":train2: Armored Train Event has ended." },
                { "PLUGIN_CargoTrainEvent_Started", ":tram: Cargo Train Event has started." },
                { "PLUGIN_CargoTrainEvent_Ended", ":tram: Cargo Train Event has ended." },
                { "PLUGIN_ConvoyEvent_Started", ":truck: Convoy Event has started." },
                { "PLUGIN_ConvoyEvent_Ended", ":truck: Convoy Event has ended." },
                { "PLUGIN_HarborEvent_Started", ":ship: Harbor Event has started." },
                { "PLUGIN_HarborEvent_Ended", ":ship: Harbor Event has ended." },
                { "PLUGIN_JunkyardEvent_Started", ":construction_site: Junkyard Event has started." },
                { "PLUGIN_JunkyardEvent_Ended", ":construction_site: Junkyard Event has ended." },
                { "PLUGIN_PowerPlantEvent_Started", ":zap: Power Plant Event has started." },
                { "PLUGIN_PowerPlantEvent_Ended", ":zap: Power Plant Event has ended." },
                { "PLUGIN_SatDishEvent_Started", ":satellite: Satellite Dish Event has started." },
                { "PLUGIN_SatDishEvent_Ended", ":satellite: Satellite Dish Event has ended." },
                { "PLUGIN_SputnikEvent_Started", ":satellite_orbital: Sputnik Event has started." },
                { "PLUGIN_SputnikEvent_Ended", ":satellite_orbital: Sputnik Dish Event has ended." },
                { "PLUGIN_WaterEvent_Started", ":anchor: Water Event has started." },
                { "PLUGIN_WaterEvent_Ended", ":anchor: Water Event has ended." }
            }, this);
        }
        #endregion

        #region Discord Commands
        private void DiscordToGameCmd(string command, string param, DiscordUser author, Snowflake channelid)
        {
            switch (command)
            {
  