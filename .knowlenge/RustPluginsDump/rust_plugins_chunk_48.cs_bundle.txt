              case "players":
                    {
                        string listStr = string.Empty;
                        var pList = BasePlayer.activePlayerList;
                        int i = 0;
                        foreach (var player in pList)
                        {
                            listStr += player.displayName + " " + "[" + (i++ + 1) + "]";
                            if (i != pList.Count)
                                listStr += ", ";

                            

                            if (i % 25 == 0 || i == pList.Count)
                            {
                                var text = new Dictionary<string, string>
                                {
                                    ["playercount"] = Convert.ToString(BasePlayer.activePlayerList.Count),
                                    ["maxplayers"] = Convert.ToString(ConVar.Server.maxplayers),
                                    ["playerslist"] = listStr
                                };
                                GetChannel(_client, channelid, chan =>
                                {
                                    chan.CreateMessage(_client, Translate("Discord_PlayersResponse", text));
                                });
                                text.Clear();
                                listStr = string.Empty;
                            }
                            
                        }
                        if (pList.Count < 1)
                        {
                            GetChannel(_client, channelid, chan =>
                            {
                                chan.CreateMessage(_client, "Server is empty!");
                            });
                        }
                        break;
                    }
                case "kick":
                    {
                        if (String.IsNullOrEmpty(param))
                        {
                            GetChannel(_client, channelid, chan =>
                            {
                                chan.CreateMessage(_client, "Syntax: !kick <steam id> <reason>");
                            });
                            return;
                        }
                        string[] _param = param.Split(' ');
                        if (_param.Length < 2)
                        {
                            GetChannel(_client, channelid, chan =>
                            {
                                chan.CreateMessage(_client, "Syntax: !kick <steam id> <reason>");
                            });
                            return;
                        }
                        BasePlayer plr = BasePlayer.Find(_param[0]);
                        if (plr == null)
                        {
                            GetChannel(_client, channelid, chan =>
                            {
                                chan.CreateMessage(_client, "Error: player not found");
                            });
                            return;
                        }
                        plr.Kick(param.Remove(0, _param[0].Length + 1));
                        GetChannel(_client, channelid, chan =>
                        {
                            chan.CreateMessage(_client, "Success: Kick command executed!");
                        });
                        break;
                    }
                case "timeban":
                    {
                        if (string.IsNullOrEmpty(param))
                        {
                            GetChannel(_client, channelid, chan =>
                            {
                                chan.CreateMessage(_client, "Syntax: !timeban <steamid> <name> <duration> <reason>");
                            });
                            return;
                        }
                        string[] _param = param.Split(' ');
                        if (_param.Length < 3)
                        {
                            GetChannel(_client, channelid, chan =>
                            {
                                chan.CreateMessage(_client, "Syntax: !timeban <steamid> <name> <duration> <reason>");
                            });
                            return;
                        }
                        var plr = covalence.Players.FindPlayer(_param[0]);
                        if (plr == null)
                        {
                            GetChannel(_client, channelid, chan =>
                            {
                                chan.CreateMessage(_client, "Error: player not found");
                            });
                            return;
                        }
                        string[] args = new string[4];
                        args[0] = _param[0]; // id
                        args[1] = _param[1]; // name
                        args[2] = "\""; // reason
                        for (int i = 3; i < _param.Length; i++)
                        {
                            args[2] += _param[i];
                            if (i != _param.Length - 1)
                                args[2] += " ";
                        }
                        args[2] += "\"";
                        args[3] = _param[2];
                        this.Server.Command("banid", args);
                        GetChannel(_client, channelid, chan =>
                        {
                            chan.CreateMessage(_client, "Success: Ban command executed!");
                        });
                        break;
                    }
                case "ban":
                    {
                        if (string.IsNullOrEmpty(param))
                        {
                            GetChannel(_client, channelid, chan =>
                            {
                                chan.CreateMessage(_client, "Syntax: !ban <name/id> <reason>");
                            });
                            return;
                        }
                        string[] _param = param.Split(' ');
                        if (_param.Length < 2)
                        {
                            GetChannel(_client, channelid, chan =>
                            {
                                chan.CreateMessage(_client, "Syntax: !ban <name/id> <reason>");
                            });
                            return;
                        }
                        var plr = covalence.Players.FindPlayer(_param[0]);
                        if (plr == null)
                        {
                            GetChannel(_client, channelid, chan =>
                            {
                                chan.CreateMessage(_client, "Error: player not found");
                            });
                            return;
                        }
                        plr.Ban(param.Remove(0, _param[0].Length + 1));
                        GetChannel(_client, channelid, chan =>
                        {
                            chan.CreateMessage(_client, "Success: Ban command executed!");
                        });
                        break;
                    }
                case "unban":
                    {
                        if (string.IsNullOrEmpty(param))
                        {
                            GetChannel(_client, channelid, chan =>
                            {
                                chan.CreateMessage(_client, "Syntax: !unban <name/id>");
                            });
                            return;
                        }
                        string[] _param = param.Split(' ');
                        var plr = covalence.Players.FindPlayer(_param[0]);
                        if (plr == null)
                        {
                            GetChannel(_client, channelid, chan =>
                            {
                                chan.CreateMessage(_client, "Error: player not found");
                            });
                            return;
                        }
                        plr.Unban();
                        GetChannel(_client, channelid, chan =>
                        {
                            chan.CreateMessage(_client, "Success: Unban command executed!");
                        });
                        break;
                    }
                case "com":
                    {
                        if (String.IsNullOrEmpty(param))
                        {
                            GetChannel(_client, channelid, chan =>
                            {
                                chan.CreateMessage(_client, "Syntax: !com <command>");
                            });
                            return;
                        }
                        string[] _param = param.Split(' ');
                        if (_param.Length > 1)
                        {
                            string[] args = new string[_param.Length - 1];
                            Array.Copy(_param, 1, args, 0, args.Length);
                            this.Server.Command(_param[0], args);
                        }
                        else
                        {
                            this.Server.Command(param);
                        }
                        GetChannel(_client, channelid, chan =>
                        {
                            chan.CreateMessage(_client, "Success: Console command executed!");
                        });
                        break;
                    }
                case "mute":
                    {
                        if (BetterChatMute == null)
                        {
                            GetChannel(_client, channelid, chan =>
                            {
                                chan.CreateMessage(_client, "This command requires the Better Chat Mute plugin.");
                                return;
                            });
                        }
                        if (string.IsNullOrEmpty(param))
                        {
                            GetChannel(_client, channelid, chan =>
                            {
                                chan.CreateMessage(_client, "Syntax: !mute <playername/steamid> <time (optional)> <reason (optional)>");
                            });
                            return;
                        }
                        string[] _param = param.Split(' ');
                        if (_param.Length >= 1)
                        {
                            this.Server.Command($"mute {string.Join(" ", _param)}");
                            return;
                        }
                        GetChannel(_client, channelid, chan =>
                        {
                            chan.CreateMessage(_client, "Success: Mute command executed!");
                        });
                        break;
                    }
                case "unmute":
                    {
                        if (BetterChatMute == null)
                        {
                            GetChannel(_client, channelid, chan =>
                            {
                                chan.CreateMessage(_client, "This command requires the Better Chat Mute plugin.");
                                return;
                            });
                        }
                        if (String.IsNullOrEmpty(param))
                        {
                            GetChannel(_client, channelid, chan =>
                            {
                                chan.CreateMessage(_client, "Syntax: !unmute <playername/steamid>");
                            });
                            return;
                        }
                        string[] _param = param.Split(' ');
                        if (_param.Length > 1)
                        {
                            GetChannel(_client, channelid, chan =>
                            {
                                chan.CreateMessage(_client, "Syntax: !unmute <playername/steamid>");
                            });
                            return;
                        }
                        if (_param.Length == 1)
                        {
                            this.Server.Command($"unmute {string.Join(" ", _param)}");
                            return;
                        }
                        break;
                    }
            }

        }
        #endregion

        #region Game Commands
        // /report [message]
        void cmdReport(BasePlayer player, string command, string[] args)
        {
            if (args.Length < 1)
            {
                SendReply(player, "Syntax: /report [message]");
                return;
            }

            if (_settings.OutputFormat.OutputTypeReports == "Embed")
            {
                string message = string.Join(" ", args);
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                                  .AddTitle("PLAYER REPORT")
                                                  .AddColor("#FF0000")
                                                  .AddThumbnail("https://i.imgur.com/qg7v0Tv.png")
                                                  .AddDescription($"{player.displayName} has submitted a report.")
                                                  .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                                  .AddNowTimestamp()
                                                  .AddField("Message", message, true);



                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("game_report"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeReports == "Simple")
            {
                string message = string.Join(" ", args);

                var dict = new Dictionary<string, string>
                    {
                        { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                        { "playername", player.displayName },
                        { "message", message }
                    };

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("game_report"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnPlayerReport", dict));
                        });
                    }
                }
            }

            SendReply(player, "Your report has been submitted to Discord.");

        }

        void cmdBug(BasePlayer player, string command, string[] args)
        {
            if (args.Length < 1)
            {
                SendReply(player, "Syntax: /bug [message]");
                return;
            }
            if (_settings.OutputFormat.OutputTypeBugs == "Embed")
            {
                string message = string.Join(" ", args);
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                                  .AddTitle("BUG REPORT")
                                                  .AddThumbnail("https://i.imgur.com/GLjfCFd.png")
                                                  .AddColor("#FF0000")
                                                  .AddDescription($"{player.displayName} has reported a bug.")
                                                  .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                                  .AddNowTimestamp()
                                                  .AddField("Bug", message, true);



                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("game_bug"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeBugs == "Simple")
            {
                string message = string.Join(" ", args);
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("game_bug"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnPlayerBug", new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.displayName },
                            { "message", message }
                        }));
                        });
                    }
                }
            }

            SendReply(player, "Your bug report has been submitted to Discord.");

        }
        #endregion

        #region Rust Logging

        #region Chat Logging
        private void OnPlayerChat(BasePlayer player, string message, ConVar.Chat.ChatChannel channel)
        {
            if (_client == null) return;
            if (player == null || message == null) return;
            if (permission.UserHasPermission(player.UserIDString, "rustcord.hidechat")) return;
            if (BetterChatMute?.Call<bool>("API_IsMuted", player.IPlayer) ?? false) return;
            if (_settings.Filters.FilterWords != null && _settings.Filters.FilterWords.Count > 0)
            {
                for (int i = _settings.Filters.FilterWords.Count - 1; i >= 0; i--)
                {
                    while (message.Contains(" " + _settings.Filters.FilterWords[i] + " ") || message.Contains(_settings.Filters.FilterWords[i]))
                        message = message.Replace(_settings.Filters.FilterWords[i], _settings.Filters.FilteredWord ?? "");
                }
            }

            var text = GetPlayerCache(player, message, CacheType.OnPlayerChat);

            for (int i = 0; i < _settings.Channels.Count; i++)
            {
                if (_settings.Channels[i].perms.Contains(channel == ConVar.Chat.ChatChannel.Team ? "msg_teamchat" : "msg_chat"))
                {
                    if (!(player.IsValid())) continue;

                    GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(_client, Translate(channel == ConVar.Chat.ChatChannel.Team ? "RUST_OnPlayerTeamChat" : "RUST_OnPlayerChat", text));

                    });
                }
            }

            text.Clear();
        }
        #endregion

        #region Crate Logging
        void OnCrateDropped(HackableLockedCrate crate)
        {
            var dict = new Dictionary<string, string>
            {
                    { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
            };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_cratedrop"))
                {
                    GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(_client, Translate("RUST_OnCrateDropped", dict));
                    });
                }
            }
        }

        void OnSupplyDropLanded(SupplyDrop entity)
        {
            var dict = new Dictionary<string, string>
            {
                    { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
            };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_supplydrop"))
                {
                    GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(_client, Translate("RUST_OnSupplyDrop", dict));
                    });
                }
            }
        }
        #endregion

        #region Death Logging
        private void OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            if (player == null) return;
            if (info?.InitiatorPlayer == null) return;
            if ((player.IsNpc) || (info.InitiatorPlayer.IsNpc)) return;

            if (_settings.OutputFormat.OutputTypeDeaths == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("PLAYER DEATH")
                                              .AddColor("#000000")
                                              .AddThumbnail("https://i.imgur.com/UZZTf08.png")
                                              .AddField("Victim", player.displayName, true)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddField("Killer", info.InitiatorPlayer.displayName, true);

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_deaths"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeDeaths == "Simple")
            {
                var dict = new Dictionary<string, string>
                {
                    { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                    { "victim", player.displayName },
                    { "killer", info.InitiatorPlayer.displayName }
                };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_deaths"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnPlayerDeath", dict));
                        });

                    }
                }
            }
        }
        #endregion

        #region Group Logging
        void OnGroupCreated(string name)
        {
            var dict = new Dictionary<string, string>
            {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "groupname", name }
            };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_groups"))
                {
                    GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(_client, Translate("RUST_OnGroupCreated", dict));
                    });
                }
            }
        }

        void OnGroupDeleted(string name)
        {
            var dict = new Dictionary<string, string>
            {
                { "groupname", name }
            };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_groups"))
                {
                    GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(_client, Translate("RUST_OnGroupDeleted", dict));
                    });
                }
            }
        }



        void OnUserGroupAdded(string id, string groupName)
        {
            if (_settings.Excluded.LogExcludeGroups.Contains(groupName)) { return; }
            if (groupName == "default") return;
            var player = covalence.Players.FindPlayerById(id);
            if (player == null) return;
            var dict = new Dictionary<string, string>
            {
                { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                { "playername", player.Name },
                { "playersteamid", id },
                { "groupname", groupName }
            };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_groups"))
                {
                    GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(_client, Translate("RUST_OnUserGroupAdded", dict));
                    });
                }
            }
        }

        void OnUserGroupRemoved(string id, string groupName)
        {
            if (_settings.Excluded.LogExcludeGroups.Contains(groupName)) return;
            if (groupName == "default") return;
            var player = covalence.Players.FindPlayerById(id);
            if (player == null) return;
            var dict = new Dictionary<string, string>
            {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.Name },
                            { "playersteamid", id },
                            { "groupname", groupName }
            };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_groups"))
                {
                    GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(_client, Translate("RUST_OnUserGroupRemoved", dict));
                    });
                }
            }
        }
        #endregion

        #region Join & Quit Logging
        private void OnPlayerConnected(BasePlayer player)
        {
            if (_client == null) return;
            if (player == null) return;
            if (!player.IsValid()) return;

            HandleAdminJoin(player);
            HandlePlayerJoin(player);
        }

        private void HandleAdminJoin(BasePlayer player)
        {
            if (_settings.OutputFormat.OutputTypeJoinAdminChan == "Simple")
            {
                var text = GetPlayerCache(player, player.net.connection.ipaddress, CacheType.OnPlayerConnected);

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("msg_joinlog"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            // Admin
                            chan.CreateMessage(_client, Translate("RUST_OnPlayerJoinAdminLog", text));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeJoinAdminChan == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                                  .AddTitle("PLAYER INFO")
                                                  .AddColor("#00FF00")
                                                  .AddThumbnail("https://i.imgur.com/AfbPIrb.png")
                                                  .AddField("Name", player.displayName, true)
                                                  .AddField("IP", player.net.connection.ipaddress.Split(':')[0], true)
                                                  .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                                  .AddNowTimestamp()
                                                  .AddField("Steam ID", GetFormattedSteamID(player.UserIDString), true);



                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("msg_joinlog"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }

        private void HandlePlayerJoin(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, "rustcord.hidejoinquit")) return;

            if (_settings.OutputFormat.OutputTypeJoinQuit == "Simple")
            {
                var text = GetPlayerCache(player, null, CacheType.OnPlayerJoin);

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("msg_join"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan => { chan.CreateMessage(_client, Translate("RUST_OnPlayerJoin", text)); });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeJoinQuit == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                                  .AddTitle("PLAYER JOIN")
                                                  .AddColor("#00FF00")
                                                  .AddThumbnail("https://i.imgur.com/hQK7Jjv.png")
                                                  .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                                  .AddNowTimestamp()
                                                  .AddDescription($"{player.displayName} has joined the server.");



                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("msg_join"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (_client == null) return;
            if (player == null || string.IsNullOrEmpty(reason)) return;
            if (permission.UserHasPermission(player.UserIDString, "rustcord.hidejoinquit"))
                return;
            if (_settings.OutputFormat.OutputTypeJoinQuit == "Simple")
            {
                var text = GetPlayerCache(player, reason, CacheType.OnPlayerDisconnected);

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("msg_quit"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnPlayerQuit", text));
                        });
                    }
                }

                cache[CacheType.OnPlayerChat].Remove(player);
                cache[CacheType.OnPlayerConnected].Remove(player);
                cache[CacheType.OnPlayerDisconnected].Remove(player);
                cache[CacheType.OnPlayerJoin].Remove(player);
            }
            if (_settings.OutputFormat.OutputTypeJoinQuit == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                                  .AddTitle("PLAYER QUIT")
                                                  .AddColor("#00FF00")
                                                  .AddThumbnail("https://i.imgur.com/py6bHm0.png")
                                                  .AddDescription($"{player.displayName} has left the server.")
                                                  .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                                  .AddNowTimestamp()
                                                  .AddField("Reason", reason, true);



                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("msg_quit"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Permission Logging
        void OnUserPermissionGranted(string id, string permName)
        {
            if (_settings.Excluded.LogExcludePerms.Contains(permName)) return;
            var player = covalence.Players.FindPlayerById(id);
            if (player == null) return;
            var dict = new Dictionary<string, string>
            {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.Name },
                            { "playersteamid", id },
                            { "permission", permName }
            };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_perms"))
                {
                    GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(_client, Translate("RUST_OnUserPermissionGranted", dict));
                    });
                }
            }
        }

        void OnGroupPermissionGranted(string name, string perm)
        {
            if (_settings.Excluded.LogExcludePerms.Contains(perm)) return;
            var dict = new Dictionary<string, string>
            {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "groupname", name },
                            { "permission", perm }
            };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_perms"))
                {
                    GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(_client, Translate("RUST_OnGroupPermissionGranted", dict));
                    });
                }
            }
        }

        void OnUserPermissionRevoked(string id, string permName)
        {
            if (_settings.Excluded.LogExcludePerms.Contains(permName)) return;
            var player = covalence.Players.FindPlayerById(id);
            if (player == null) return;
            var dict = new Dictionary<string, string>
            {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.Name },
                            { "playersteamid", id },
                            { "permission", permName }
            };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_perms"))
                {
                    GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(_client, Translate("RUST_OnUserPermissionRevoked", dict));
                    });
                }
            }
        }

        void OnGroupPermissionRevoked(string name, string perm)
        {
            if (_settings.Excluded.LogExcludePerms.Contains(perm)) return;
            var dict = new Dictionary<string, string>
            {
                        { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                        { "groupname", name },
                        { "permission", perm }
            };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_perms"))
                {
                    GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(_client, Translate("RUST_OnGroupPermissionRevoked", dict));
                    });
                }
            }
        }
        #endregion

        #region Kick & Ban Logging
        void OnUserKicked(IPlayer player, string reason)
        {
            if (_settings.OutputFormat.OutputTypeKicks == "Simple")
            {
                var dict = new Dictionary<string, string>
            {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.Name },
                            { "reason", reason }
            };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_kicks"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnPlayerKicked", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeKicks == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("PLAYER KICKED")
                                              .AddThumbnail("https://i.imgur.com/ekF9ClZ.png")
                                              .AddField("Name", player.Name, true)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddField("Reason", reason, true);

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_kicks"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }

        void OnUserBanned(string name, string bannedId, string address, string reason)
        {
            if (_settings.OutputFormat.OutputTypeBans == "Simple")
            {
                var dict = new Dictionary<string, string>
            {
                        { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                        { "playername", name },
                        { "playersteamid", bannedId },
                        { "playerip", address },
                        { "reason", reason }
            };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_bans"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnPlayerBanned", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeBans == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("PLAYER BANNED")
                                              .AddThumbnail("https://i.imgur.com/ekF9ClZ.png")
                                              .AddField("Name", name, true)
                                              .AddField("IP", address, true)
                                              .AddField("Steam ID", GetFormattedSteamID(bannedId), true)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddField("Ban Reason", reason, false);

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_bans"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }

        }
        
        private void OnUserUnbanned(string name, string id, string ip)
        {
            if (_settings.OutputFormat.OutputTypeBans == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", name },
                            { "playersteamid", id },
                            { "playerip", ip }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_bans"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnPlayerUnBanned", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeBans == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("PLAYER UNBANNED")
                                              .AddThumbnail("https://i.imgur.com/ekF9ClZ.png")
                                              .AddField("Name", name, true)
                                              .AddField("IP", ip, true)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddField("Steam ID", GetFormattedSteamID(id), true);
                
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_bans"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Player Name Change Logging
        void OnUserNameUpdated(string id, string oldName, string newName) //TESTING FUNCTION
        {

            if ((oldName == newName) || (oldName == "Unnamed")) return;
            if (_settings.OutputFormat.OutputTypeNameChange == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("PLAYER NAME CHANGE")
                                              .AddThumbnail("https://i.imgur.com/Fq4LvFz.png")
                                              .AddField("Old Name", oldName, true)
                                              .AddField("New Name", newName, true)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddField("Steam ID", GetFormattedSteamID(id), false);

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_namechange"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeNameChange == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "oldname", oldName },
                            { "newname", newName },
                            { "playersteamid", id }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_namechange"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnPlayerNameChange", dict));
                        });
                    }
                }
            }

        }
        #endregion

        #region Server Init/Shutdown Logging
        private void OnServerInitialized()
        {
            var reloadtime = _settings.General.AutoReloadTime;

            permission.RegisterPermission("rustcord.hidejoinquit", this);
            permission.RegisterPermission("rustcord.hidechat", this);

            if (_settings.General.AutoReloadPlugin && _settings.General.AutoReloadTime > 59)
            {
                timer.Every(reloadtime, () => Reload());
            }

            if (_client != null)
            {
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("msg_serverinit"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnInitMsg"));
                        });
                    }
                }
            }
        }
        void OnServerShutdown()
        {

            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("msg_serverinit"))
                {
                    GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(_client, Translate("RUST_OnServerShutdown"));
                    });
                }
            }
        }
        #endregion

        #region Server Message Logging (F1 Spawns)
        private object OnServerMessage(string message, string name)
        {
            if (message.Contains("gave") && name == "SERVER")
            {
                var dict = new Dictionary<string, string>
                        {
                                { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                                { "playername", name },
                                { "givemessage", message }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_admingive"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnF1ItemSpawn", dict));
                        });
                    }
                }
            }

            return null;
        }
        #endregion

        #region Server Wipe Logging
        private void OnNewSave(string filename)
        {
            var mapseed = ConVar.Server.seed.ToString();
            var servername = ConVar.Server.hostname;
            var serverip = covalence.Server.Address.ToString();
            var serverport = covalence.Server.Port.ToString();
            var serverworldsize = ConVar.Server.worldsize.ToString();

            if (_settings.OutputFormat.OutputTypeServerWipe == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                                { "mapseed", mapseed },
                                { "servername", servername },
                                { "serverip", serverip },
                                { "serverport", serverport },
                                { "serverworldsize", serverworldsize }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_serverwipe"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnServerWipe", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeServerWipe == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                          .AddTitle("SERVER HAS WIPED")
                                          .AddThumbnail("https://i.imgur.com/EODRYQQ.png")
                                          .AddDescription(servername)
                                          .AddField("Map Seed", mapseed, true)
                                          .AddField("World Size", serverworldsize, true)
                                          .AddField("Server IP", serverip, false)
                                          .AddField("Server Port", serverport, true)
                                          .AddField("Quick Join:", $"steam://connect/{serverip}:{serverport}", false)
                                          .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                          .AddNowTimestamp();

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_serverwipe"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Server Command Logging (Note/Gestures)
        private void OnServerCommand(ConsoleSystem.Arg arg)
        {
            var player1 = arg.Player();
            var emote = arg.GetString(0);

            if (arg.cmd.Name == "gesture")
            {
                if (_emotes.ContainsKey(emote))
                {
                    var emoji = _emotes[emote];
                    var dict = new Dictionary<string, string>
                        {
                                    { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                                    {"playername", player1.displayName },
                                    {"gesture", emoji }
                        };
                    for (int i = 0; i < _channelCount; i++)
                    {
                        if (_settings.Channels[i].perms.Contains("msg_gestures"))
                        {
                            GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                            {
                                chan.CreateMessage(_client, Translate("RUST_OnPlayerGesture", dict));
                            });
                        }
                    }
                }
            }
            if (arg.cmd.FullName == "note.update")
            {
                BasePlayer player = arg.Connection.player as BasePlayer;
                if (player == null)
                    return;
                var notemsg = arg.GetString(1, string.Empty);
                if (string.IsNullOrEmpty(notemsg)) return;

                if (_settings.OutputFormat.OutputTypeNoteLog == "Simple")
                {
                    var dict = new Dictionary<string, string>
                        {
                                { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                                { "playername", player.displayName },
                                { "notemessage", notemsg }
                        };
                    for (int i = 0; i < _channelCount; i++)
                    {
                        if (_settings.Channels[i].perms.Contains("log_itemnote"))
                        {
                            GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                            {
                                chan.CreateMessage(_client, Translate("RUST_OnNoteUpdate", dict));
                            });
                        }
                    }
                }
                if (_settings.OutputFormat.OutputTypeNoteLog == "Embed")
                {
                    DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("NOTE UPDATE")
                                              .AddThumbnail("https://i.imgur.com/AZvqSSf.png")
                                              .AddField("Author", player.displayName, false)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddField("Message", notemsg, false);

                    for (int i = 0; i < _channelCount; i++)
                    {
                        if (_settings.Channels[i].perms.Contains("log_itemnote"))
                        {
                            GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                            {
                                chan.CreateMessage(_client, builder.Build());
                            });
                        }
                    }
                }
            }
        }
        private readonly Dictionary<string, string> _emotes = new Dictionary<string, string>
        {
            ["wave"] = ":wave:",
            ["shrug"] = ":shrug:",
            ["victory"] = ":trophy:",
            ["thumbsup"] = ":thumbsup:",
            ["chicken"] = ":chicken:",
            ["hurry"] = ":runner:",
            ["whoa"] = ":flag_white:"
        };
        #endregion

        #region F7 Report Logging
        void OnPlayerReported(BasePlayer reporter, string targetName, string targetId, string subject, string message, string type)
        {
            if (reporter == null || message == null || targetName == null || targetId == null || subject == null || type == null) return;
            if (_settings.OutputFormat.OutputTypeF7Report == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("PLAYER F7 REPORT")
                                              .AddThumbnail("https://i.imgur.com/qg7v0Tv.png")
                                              .AddField("Reporter", reporter.displayName, false)
                                              .AddField("User Reported", $"{targetName} ([{targetId}](https://steamcommunity.com/profiles/{targetId})", false)
                                              .AddField("Reason", subject, false)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddField("Message", message, false);

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_f7reports"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeF7Report == "Simple")
            {
                var dict = new Dictionary<string, string>
             {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "reporter", reporter.displayName },
                            { "targetname", targetName },
                            { "targetsteamid", targetId },
                            { "reason", subject },
                            { "message", message }
            };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_f7reports"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnPlayerReported", dict));
                        });
                    }
                }
            }

        }
        #endregion

        #region Custom Logging
        private void ConsoleLog(string condition, string stackTrace, LogType type)
        {
            if (string.IsNullOrEmpty(condition))
            {
                return;
            }
            var dict = new Dictionary<string, string>
            {
                { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                { "logtext", condition }
            };
            for (int i = 0; i < _channelCount; i++)
            {
                Settings.Channel channel = _settings.Channels[i];
                if (channel.CustomFilter.Any(c => condition.Contains(c)))
                {
                    GetChannel(_client, channel.Channelid, chan =>
                    {
                        chan.CreateMessage(_client, Translate("RUST_CustomLog", dict));
                    });
                }
            }
        }
        #endregion

        #region RCON Logging
        private void OnRconConnection(IPAddress ip)
        {
            var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "ip", ip.ToString() }
                        };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_rcon"))
                {
                    GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(_client, Translate("RUST_OnRCONConnected", dict));
                    });
                }
            }
        }
        #endregion

        #region Spectate Logging
        private void OnPlayerSpectate(BasePlayer player, string spectateFilter)
        {
            var dict = new Dictionary<string, string>
            {
                { "playername", player.displayName },
                { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                { "targetname", spectateFilter }
            };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_spectates"))
                {
                    GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(_client, Translate("RUST_OnPlayerSpectate", dict));
                    });

                }
            }
        }
        private void OnPlayerSpectateEnd(BasePlayer player, string spectateFilter)
        {
            var dict = new Dictionary<string, string>
            {
                { "playername", player.displayName },
                { "targetname", spectateFilter }
            };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_spectates"))
                {
                    GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(_client, Translate("RUST_OnPlayerSpectateEnd", dict));
                    });
                }
            }
        }
        #endregion

        #region SignShit

        /*private void OnSignUpdated(Signage sign, BasePlayer player, int textureIndex)
        {
            using (Image image = Image.FromStream(new MemoryStream(FileStorage.server.Get(sign.textureIDs[textureIndex], FileStorage.Type.png, sign.net.ID, (uint)0))))
            {
                image.Save($"{sign.net.ID}.png");
            }
            DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Sign Update")
                                              .AddColor("#800080")
                                              .AddDescription($"{player.displayName} has updated a sign.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddImage($"{sign.net.ID}.png")
                                              .AddThumbnail("https://i.imgur.com/qkI2B4l.png");

            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_signs"))
                {
                    GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(_client, builder.Build());
                    });
                }
            }
        }*/
        #endregion

        #region Team Logging
        void OnTeamCreated(BasePlayer player, RelationshipManager.PlayerTeam team)
        {
            if (_settings.OutputFormat.OutputTypeTeams == "Embed")
            {
                string leaderName = covalence.Players.FindPlayerById(team.teamLeader.ToString())?.Name;

                List<string> players = Pool.GetList<string>();
                foreach (ulong member in team.members)
                {
                    IPlayer memberPlayer = covalence.Players.FindPlayerById(member.ToString());
                    if (memberPlayer != null)
                    {
                        players.Add(GetPlayerFormattedField(memberPlayer));
                    }
                    else
                    {
                        players.Add(member.ToString());
                    }
                }

                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("NEW TEAM CREATED")
                                              .AddThumbnail("https://i.imgur.com/ChdmYGD.png")
                                              .AddColor("#800080")
                                              .AddField("Team ID", team.teamID.ToString(), true)
                                              .AddField("Leader", leaderName, true)
                                              .AddField("Members", string.Join("\n", players), false)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp();

                Pool.FreeList(ref players);

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_teams"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeTeams == "Simple")
            {
                var dict = new Dictionary<string, string>
            {
                { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                { "playername", player.displayName },
                { "teamid", team.teamID.ToString() }
            };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_teams"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnTeamCreated", dict));
                        });
                    }
                }
            }

        }
        void OnTeamAcceptInvite(RelationshipManager.PlayerTeam team, BasePlayer player)
        {
            if (_settings.OutputFormat.OutputTypeTeams == "Embed")
            {
                NextTick(() =>
                {
                    string leaderName = covalence.Players.FindPlayerById(team.teamLeader.ToString())?.Name;

                    List<string> players = Pool.GetList<string>();
                    foreach (ulong member in team.members)
                    {
                        IPlayer memberPlayer = covalence.Players.FindPlayerById(member.ToString());
                        if (memberPlayer != null)
                        {
                            players.Add(GetPlayerFormattedField(memberPlayer));
                        }
                        else
                        {
                            players.Add(member.ToString());
                        }
                    }

                    DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                                  .AddTitle("TEAM JOIN")
                                                  .AddColor("#00FF00")
                                                  .AddThumbnail("https://i.imgur.com/nV7KfWf.png")
                                                  .AddDescription($"{player.displayName} has joined {leaderName}'s team.")
                                                  .AddField("Team ID", team.teamID.ToString(), true)
                                                  .AddField("Team Leader", leaderName, true)
                                                  .AddField("Team Members", string.Join("\n", players), false)
                                                  .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                                  .AddNowTimestamp();

                    Pool.FreeList(ref players);

                    for (int i = 0; i < _channelCount; i++)
                    {
                        if (_settings.Channels[i].perms.Contains("log_teams"))
                        {
                            GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                            {
                                chan.CreateMessage(_client, builder.Build());
                            });
                        }
                    }
                });
            }
            if (_settings.OutputFormat.OutputTypeTeams == "Simple")
            {
                var dict = new Dictionary<string, string>
            {
                 { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                 { "playername", player.displayName },
                 { "teamleader", team.GetLeader().displayName },
                 { "teamid", team.teamID.ToString() }
            };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_teams"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnTeamAcceptInvite", dict));
                        });
                    }
                }
            }

        }



        void OnTeamLeave(RelationshipManager.PlayerTeam team, BasePlayer player)
        {
            if (team == null || player == null) return;
            if (_settings.OutputFormat.OutputTypeTeams == "Embed")
            {
                string leaderName = covalence.Players.FindPlayerById(team.teamLeader.ToString())?.Name;
                if (player.displayName == team.GetLeader().displayName) return;
                List<string> players = Pool.GetList<string>();
                foreach (ulong member in team.members)
                {
                    IPlayer memberPlayer = covalence.Players.FindPlayerById(member.ToString());
                    if (memberPlayer != null)
                    {
                        players.Add(GetPlayerFormattedField(memberPlayer));
                    }
                    else
                    {
                        players.Add(member.ToString());
                    }
                }

                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                                .AddTitle("TEAM PART")
                                                .AddColor("#FFA500")
                                                .AddThumbnail("https://i.imgur.com/92y7DWt.png")
                                                .AddDescription($"{player.displayName} left {leaderName}'s team.")
                                                .AddField("Team ID", team.teamID.ToString(), true)
                                                .AddField("Team Leader", leaderName, true)
                                                .AddField("Team Members", string.Join("\n", players), false)
                                                .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp();

                Pool.FreeList(ref players);

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_teams"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeTeams == "Simple")
            {
                if (player == team.GetLeader()) return;
                if ((team == null) || (player == null)) return;
                var dict = new Dictionary<string, string>
            {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.displayName },
                            { "teamleader", team.GetLeader().displayName },
                            { "teamid", team.teamID.ToString() }
            };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_teams"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnTeamLeave", dict));
                        });
                    }
                }
            }
        }
        void OnTeamKick(RelationshipManager.PlayerTeam team, BasePlayer player, ulong target)
        {
            if (_settings.OutputFormat.OutputTypeTeams == "Embed")
            {
                NextTick(() =>
                {
                    string leaderName = covalence.Players.FindPlayerById(team.teamLeader.ToString())?.Name;
                    var targetplayer = GetPlayer(target);

                    List<string> players = Pool.GetList<string>();
                    foreach (ulong member in team.members)
                    {
                        IPlayer memberPlayer = covalence.Players.FindPlayerById(member.ToString());
                        if (memberPlayer != null)
                        {
                            players.Add(GetPlayerFormattedField(memberPlayer));
                        }
                        else
                        {
                            players.Add(member.ToString());
                        }
                    }

                    DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                                  .AddTitle("TEAM KICK")
                                                  .AddColor("#FF0000")
                                                  .AddThumbnail("https://i.imgur.com/92y7DWt.png")
                                                  .AddDescription($"{targetplayer.Name} was kicked from {leaderName}'s team.")
                                                  .AddField("Team ID", team.teamID.ToString(), true)
                                                  .AddField("Team Leader", leaderName, true)
                                                  .AddField("Team Members", string.Join("\n", players), false)
                                                  .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp();

                    Pool.FreeList(ref players);

                    for (int i = 0; i < _channelCount; i++)
                    {
                        if (_settings.Channels[i].perms.Contains("log_teams"))
                        {
                            GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                            {
                                chan.CreateMessage(_client, builder.Build());
                            });
                        }
                    }
                });
            }
            if (_settings.OutputFormat.OutputTypeTeams == "Simple")
            {
                var targetplayer = FindPlayerByID(target.ToString());
                var dict = new Dictionary<string, string>
                        {
                            { "playername", targetplayer.displayName },
                            { "teamleader", team.GetLeader().displayName },
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "teamid", team.teamID.ToString() }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_teams"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnTeamKicked", dict));
                        });
                    }
                }
            }
        }
        void OnTeamDisbanded(RelationshipManager.PlayerTeam team)
        {
            if (_settings.OutputFormat.OutputTypeTeams == "Embed")
            {
                string leaderName = covalence.Players.FindPlayerById(team.teamLeader.ToString())?.Name;

                List<string> players = Pool.GetList<string>();
                foreach (ulong member in team.members)
                {
                    IPlayer memberPlayer = covalence.Players.FindPlayerById(member.ToString());
                    if (memberPlayer != null)
                    {
                        players.Add(GetPlayerFormattedField(memberPlayer));
                    }
                    else
                    {
                        players.Add(member.ToString());
                    }
                }

                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("TEAM DISBANDED")
                                              .AddColor("#FF0000")
                                              .AddThumbnail("https://i.imgur.com/B9mPg0l.png")
                                              .AddField("Team ID", team.teamID.ToString(), true)
                                              .AddField("Leader", leaderName, true)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp();

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_teams"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeTeams == "Simple")
            {
                var dict = new Dictionary<string, string>
            {
                            { "teamleader", team.GetLeader().displayName },
                            { "teamid", team.teamID.ToString() }
            };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_teams"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnTeamDisbanded", dict));
                        });
                    }
                }
            }
        }
        #endregion

        #region Vehicle Spawn Logging

        private void OnEntitySpawned(BaseEntity Entity)
        {
            var dict = new Dictionary<string, string>
            {
                    { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
            };
            if (Entity == null) return;
            if (Entity is BaseHelicopter)
            {
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("msg_helispawn"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnHeliSpawn"));
                        });
                    }
                }
            }
            if (Entity is CargoPlane)
            {
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("msg_planespawn"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnPlaneSpawn"));
                        });
                    }
                }
            }
            if (Entity is CargoShip)
            {
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("msg_shipspawn"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnShipSpawn"));
                        });
                    }
                }

            }
            if (Entity is CH47Helicopter)
            {
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("msg_chinookspawn"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnChinookSpawn"));
                        });
                    }
                }
            }
            if (Entity is BradleyAPC)
            {
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("msg_bradleyspawn"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnBradleySpawn"));
                        });
                    }
                }
            }

        }
        #endregion

        #endregion

        #region External Plugin Logging

        #region Admin Hammer

        void OnAdminHammerEnabled(BasePlayer player)
        {
            if (_settings.OutputFormat.OutputTypeAdminHammer == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.displayName }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_adminhammer"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_AdminHammer_Enabled", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeAdminHammer == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Admin Hammer Plugin")
                                              .AddColor("#800080")
                                              .AddDescription($"{player.displayName} has enabled Admin Hammer.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5ebb965d00f21.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_adminhammer"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }

        }
        void OnAdminHammerDisabled(BasePlayer player)
        {
            if (_settings.OutputFormat.OutputTypeAdminHammer == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.displayName }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_adminhammer"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_AdminHammer_Disabled", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeAdminHammer == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Admin Hammer Plugin")
                                              .AddColor("#800080")
                                              .AddDescription($"{player.displayName} has disabled Admin Hammer.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5ebb965d00f21.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_adminhammer"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Admin Radar
        void OnRadarActivated(BasePlayer player)
        {
            if (_settings.OutputFormat.OutputTypeAdminRadar == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.displayName }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_adminradar"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_AdminRadar_Enabled", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeAdminRadar == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Admin Radar Plugin")
                                              .AddUrl("https://umod.org/plugins/admin-radar")
                                              .AddColor("#800080")
                                              .AddDescription($"{player.displayName} has enabled Admin Radar.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5b7e1bc17d769.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_adminradar"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnRadarDeactivated(BasePlayer player)
        {
            if (_settings.OutputFormat.OutputTypeAdminRadar == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.displayName }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_adminradar"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_AdminRadar_Disabled", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeAdminRadar == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Admin Radar Plugin")
                                              .AddUrl("https://umod.org/plugins/admin-radar")
                                              .AddColor("#800080")
                                              .AddDescription($"{player.displayName} has disabled Admin Radar.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5b7e1bc17d769.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_adminradar"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Better Chat Mute

        private void OnBetterChatMuted(IPlayer target, IPlayer player, string reason)
        {
            if (_settings.OutputFormat.OutputTypeBetterChatMute == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "targetname", target.Name },
                            { "reason", reason },
                            { "muter", player.Name }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_betterchatmute"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_BetterChatMute_Mute", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeBetterChatMute == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Better Chat Mute Plugin")
                                              .AddUrl("https://umod.org/plugins/better-chat-mute")
                                              .AddColor("#800080")
                                              .AddDescription($"Permanent Mute Issued By: {player.Name}.")
                                              .AddField("Muted Player", target.Name, false)
                                              .AddField("Reason", reason, false)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5f242f4c92225.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_betterchatmute"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }

        private void OnBetterChatTimeMuted(IPlayer target, IPlayer player, TimeSpan time, string reason)
        {
            if (_settings.OutputFormat.OutputTypeBetterChatMute == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "targetname", target.Name },
                            { "reason", reason },
                            { "muter", player.Name },
                            { "duration", FormatTime((TimeSpan) time) }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_betterchatmute"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_BetterChatMute_TimedMute", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeBetterChatMute == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Better Chat Mute Plugin")
                                              .AddUrl("https://umod.org/plugins/better-chat-mute")
                                              .AddColor("#800080")
                                              .AddDescription($"Temporary Mute Issued By: {player.Name}.")
                                              .AddField("Muted Player", target.Name, true)
                                              .AddField("Duration", FormatTime((TimeSpan)time), true)
                                              .AddField("Reason", reason, false)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5f242f4c92225.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_betterchatmute"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }

        private void OnBetterChatUnmuted(IPlayer target, IPlayer player)
        {
            if (_settings.OutputFormat.OutputTypeBetterChatMute == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "targetname", target.Name },
                            { "unmuter", player.Name }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_betterchatmute"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_BetterChatMute_UnMute", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeBetterChatMute == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Better Chat Mute Plugin")
                                              .AddUrl("https://umod.org/plugins/better-chat-mute")
                                              .AddColor("#800080")
                                              .AddDescription($"{player.Name} removed {target.Name}'s mute.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5f242f4c92225.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_betterchatmute"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }


        private void OnBetterChatMuteExpired(IPlayer target)
        {
            if (_settings.OutputFormat.OutputTypeBetterChatMute == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "targetname", target.Name }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_betterchatmute"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_BetterChatMute_MuteExpire", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeBetterChatMute == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Better Chat Mute Plugin")
                                              .AddUrl("https://umod.org/plugins/better-chat-mute")
                                              .AddColor("#800080")
                                              .AddDescription($"{target.Name}'s mute has expired.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5f242f4c92225.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_betterchatmute"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Clans

        void OnClanCreate(string tag, string ownerID)
        {
            if ((_settings.PluginLog.LogPluginClans == true) && (_settings.OutputFormat.OutputTypeClans == "Simple"))
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "clantag", tag }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_clans"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_Clans_CreateClan", dict));
                        });
                    }
                }

            }
            if ((_settings.PluginLog.LogPluginClans == true) && (_settings.OutputFormat.OutputTypeClans == "Embed"))
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                          .AddTitle("Clans Plugin")
                                          .AddUrl("https://umod.org/plugins/clans")
                                          .AddColor("#800080")
                                          .AddDescription($"Clan {tag} has been created.")
                                          .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                          .AddThumbnail("https://assets.umod.org/images/icons/plugin/5b63bf642ea2c.jpg");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_clans"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnClanDisbanded(string tag, List<string> memberUserIDs)
        {
            if ((_settings.PluginLog.LogPluginClans == true) && (_settings.OutputFormat.OutputTypeClans == "Simple"))
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "clantag", tag }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_clans"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_Clans_DisbandClan", dict));
                        });
                    }
                }
            }
            if ((_settings.PluginLog.LogPluginClans == true) && (_settings.OutputFormat.OutputTypeClans == "Embed"))
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                          .AddTitle("Clans Plugin")
                                          .AddUrl("https://umod.org/plugins/clans")
                                          .AddColor("#800080")
                                          .AddDescription($"Clan {tag} has been Disbanded.")
                                          .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                          .AddNowTimestamp()
                                          .AddThumbnail("https://assets.umod.org/images/icons/plugin/5b63bf642ea2c.jpg");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_clans"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnClanChat(IPlayer player, string message)
        {
            var dict = new Dictionary<string, string>
                        {
                            { "playername", player.Name },
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "message", message }
                        };
            if (player.Name == null || message == null) return;
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("plugin_clanchat"))
                {
                    GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(_client, Translate("PLUGIN_Clans_Chat", dict));
                    });
                }
            }
        }
        #endregion

        #region Dangerous Treasures

        private void OnDangerousEventStarted(Vector3 containerPos)
        {
            if (containerPos == null) return;
            if (_settings.OutputFormat.OutputTypeDangerousTreasures == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "position", containerPos.ToString() },
                            { "gridposition", FindGridPosition(containerPos).ToString() }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_dangeroustreasures"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_DangerousTreasures_Started", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeDangerousTreasures == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Dangerous Treasures Plugin")
                                              .AddUrl("https://umod.org/plugins/dangerous-treasures")
                                              .AddDescription("Dangerous Event Started")
                                              .AddField("Position", $"{ FindGridPosition(containerPos)} {containerPos} ", true)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5b7d66ce65af7.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_dangeroustreasures"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        private void OnDangerousEventEnded(Vector3 containerPos)
        {
            if (containerPos == null) return;
            if (_settings.OutputFormat.OutputTypeDangerousTreasures == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "position", containerPos.ToString() },
                            { "gridposition", FindGridPosition(containerPos).ToString() }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_dangeroustreasures"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_DangerousTreasures_Ended", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeDangerousTreasures == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Dangerous Treasures Plugin")
                                              .AddUrl("https://umod.org/plugins/dangerous-treasures")
                                              .AddDescription("Dangerous Event Ended")
                                              .AddField("Position", $"{FindGridPosition(containerPos)} {containerPos} ", true)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5b7d66ce65af7.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_dangeroustreasures"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Death Notes
        private void OnDeathNotice(Dictionary<string, object> data, string message)
        {
            if (_client == null) return;
            if (data["VictimEntityType"] == null || data["KillerEntityType"] == null) return;
            int victimType = (int)data["VictimEntityType"];
            int killerType = (int)data["KillerEntityType"];

            var _DeathNotes = plugins.Find("DeathNotes");
            var deathmessage = (string)_DeathNotes.Call("StripRichText", message);

            var dict = new Dictionary<string, string>
                    {
                        { "deathmessage", deathmessage},
                        { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                    };

            if (_DeathNotes != null)
                if ((victimType == 5 && (killerType == 5 || killerType == 6 || killerType == 7 || killerType == 8 || killerType == 9 || killerType == 10 || killerType == 11 || killerType == 12 || killerType == 14 || killerType == 15)))
                {
                    for (int i = 0; i < _channelCount; i++)
                    {
                        if (_settings.Channels[i].perms.Contains("plugin_deathnotes_pvp"))
                        {
                            GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                            {
                                chan.CreateMessage(_client, Translate("PLUGIN_DeathNotes_Death", dict));
                            });
                        }
                    }

                }
                else if ((victimType == 2 && killerType == 5) || (victimType == 5 && killerType == 2))
                {
                    for (int i = 0; i < _channelCount; i++)
                    {
                        if (_settings.Channels[i].perms.Contains("plugin_deathnotes_animal"))
                        {
                            GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                            {
                                chan.CreateMessage(_client, Translate("PLUGIN_DeathNotes_Death", dict));
                            });
                        }
                    }

                }
                else if ((victimType == 5 && (killerType == 0 || killerType == 1)) || ((victimType == 0 || victimType == 1) && (killerType == 5)))
                {
                    message = (string)_DeathNotes.Call("StripRichText", message);

                    for (int i = 0; i < _channelCount; i++)
                    {
                        if (_settings.Channels[i].perms.Contains("plugin_deathnotes_vehicle"))
                        {
                            GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                            {
                                chan.CreateMessage(_client, Translate("PLUGIN_DeathNotes_Death", dict));
                            });
                        }
                    }
                }
                else if ((victimType == 5 && (killerType == 3 || killerType == 4 || killerType == 16 || killerType == 17 || killerType == 18)) || ((victimType == 3 || victimType == 4 || victimType == 16 || victimType == 17 || victimType == 18) && (killerType == 5)))
                {
                    message = (string)_DeathNotes.Call("StripRichText", message);

                    for (int i = 0; i < _channelCount; i++)
                    {
                        if (_settings.Channels[i].perms.Contains("plugin_deathnotes_npc"))
                        {
                            GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                            {
                                chan.CreateMessage(_client, Translate("PLUGIN_DeathNotes_Death", dict));
                            });
                        }
                    }

                }
        }
        #endregion

        #region Discord Auth
        private void OnDiscordPlayerLinked(IPlayer player, DiscordUser user)
        {
            if (player == null || user == null) return;
            if (_settings.OutputFormat.OutputTypeDiscordAuth == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "gamename", player.Name },
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "discordname", user.GetFullUserName }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_discordauth"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_DiscordAuth_Auth", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeDiscordAuth == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Discord Auth Plugin")
                                              .AddUrl("https://umod.org/plugins/discord-auth")
                                              .AddColor("#800080")
                                              .AddDescription("Player Account Linked.")
                                              .AddField("Rust Player", player.Name, true)
                                              .AddField("Discord Account", user.GetFullUserName, true)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddColor("#00FF00")
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5d20e5691c3c5.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_discordauth"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }

        }
        private void OnDiscordPlayerUnlinked(IPlayer player, DiscordUser user)
        {
            if (player == null || user == null) return;
            if (_settings.OutputFormat.OutputTypeDiscordAuth == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "gamename", player.Name },
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "discordname", user.GetFullUserName }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_discordauth"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_DiscordAuth_Deauth", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeDiscordAuth == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Discord Auth Plugin")
                                              .AddUrl("https://umod.org/plugins/discord-auth")
                                              .AddColor("#800080")
                                              .AddDescription($"{player.Name} Unlinked From Discord.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddColor("#FF0000")
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5d20e5691c3c5.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_discordauth"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Godmode
        private void OnGodmodeToggled(string playerId, bool enabled)
        {
            var player = covalence.Players.FindPlayerById(playerId);
            if (player.Name == null) return;
            if (_settings.OutputFormat.OutputTypeGodmode == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.Name }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_godmode"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            if (enabled == true)
                            {
                                chan.CreateMessage(_client, Translate("PLUGIN_Godmode_Enabled", dict));
                            }
                            if (enabled == false)
                            {
                                chan.CreateMessage(_client, Translate("PLUGIN_Godmode_Disabled", dict));
                            }
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeGodmode == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Godmode Plugin")
                                              .AddUrl("https://umod.org/plugins/godmode")
                                              .AddColor("#800080")
                                              .AddDescription("Godmode has been toggled")
                                              .AddField("Player", player.Name, true)
                                              .AddField("Enabled", enabled.ToString(), true)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5b6394e5e597b.jpg");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_godmode"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Kits
        void OnKitRedeemed(BasePlayer player, string kitName)
        {
            if (player == null || kitName == null) return;
            if (_settings.OutputFormat.OutputTypeKits == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "kitname", kitName },
                            { "playername", player.displayName }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_kits"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_Kits_Redeemed", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeKits == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Kits Plugin")
                                              .AddUrl("https://umod.org/plugins/kits")
                                              .AddColor("#800080")
                                              .AddDescription($"{player.displayName} has redeemd a kit.")
                                              .AddField("Kit", kitName, true)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5b910ab50f5d1.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_kits"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Private Messages
        [HookMethod("OnPMProcessed")]
        void OnPMProcessed(IPlayer sender, IPlayer target, string message)
        {
            if (_settings.OutputFormat.OutputTypePMs == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "sendername", sender.Name },
                            { "targetname", target.Name },
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "message", message }
                        };

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_privatemessages"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_PrivateMessages_PM", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypePMs == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Private Messages Plugin")
                                              .AddUrl("https://umod.org/plugins/private-messages")
                                              .AddColor("#800080")
                                              .AddField("From", sender.Name, true)
                                              .AddField("To", target.Name, true)
                                              .AddField("Message", message, false)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5b66ed6b7e606.jpg");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_privatemessages"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Raidable Bases
        void OnRaidableBaseStarted(Vector3 pos, int difficulty)
        {
            string rbdiff = string.Empty;
            if (difficulty == 0) rbdiff = "Easy";
            if (difficulty == 1) rbdiff = "Medium";
            if (difficulty == 2) rbdiff = "Hard";
            if (difficulty == 3) rbdiff = "Expert";
            if (difficulty == 4) rbdiff = "Nightmare";
            if (difficulty == 512) rbdiff = "Normal";

            if (_settings.OutputFormat.OutputTypeRaidableBases == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "position", pos.ToString() },
                            { "gridposition", FindGridPosition(pos).ToString() },
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "difficulty", rbdiff }
                        };

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_raidablebases"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_RaidableBases_Started", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeRaidableBases == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Raidable Bases Plugin")
                                              .AddUrl("https://umod.org/plugins/raidable-bases")
                                              .AddColor("#800080")
                                              .AddDescription("A Raidable Base Has Spawned.")
                                              .AddField("Difficulty", rbdiff, true)
                                              .AddField("Location", $"{FindGridPosition(pos)} {pos}", true)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5e986213be8c8.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_raidablebases"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnRaidableBaseEnded(Vector3 pos, int difficulty)
        {
            string rbdiff = string.Empty;
            if (difficulty == 0) rbdiff = "Easy";
            if (difficulty == 1) rbdiff = "Medium";
            if (difficulty == 2) rbdiff = "Hard";

            if (_settings.OutputFormat.OutputTypeRaidableBases == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "position", pos.ToString() },
                            { "gridposition", FindGridPosition(pos).ToString() },
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "difficulty", rbdiff }
                        };

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_raidablebases"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_RaidableBases_Ended", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeRaidableBases == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Raidable Bases Plugin")
                                              .AddUrl("https://umod.org/plugins/raidable-bases")
                                              .AddColor("#800080")
                                              .AddDescription($"Raidable Base at {FindGridPosition(pos)} Has Ended.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5e986213be8c8.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_raidablebases"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Sign Artist
        private void OnImagePost(BasePlayer player, string image)
        {
            var dict = new Dictionary<string, string>
                        {
                            { "playername", player.displayName },
                            { "position", $"{player.transform.position.x} {player.transform.position.y} {player.transform.position.z}" }
                        };

            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("plugin_signartist"))
                {
                    GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(_client, SignArtistEmbed(Translate("PLUGIN_SignArtist", dict), image));
                    });
                }
            }
        }

        private DiscordEmbed SignArtistEmbed(string text, string image)
        {
            DiscordEmbed embed = new DiscordEmbedBuilder()
                                 .AddTitle("SignArtist Plugin")
                                 .AddUrl("https://umod.org/plugins/sign-artist")
                                 .AddThumbnail("https://i.imgur.com/NBu6OjS.png")
                                 .AddDescription(text)
                                 .AddColor(52326)
                                 .AddImage(image)
                                 .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                 .AddNowTimestamp()
                                 .Build();

            return embed;
        }
        #endregion

        #region Vanish
        void OnVanishDisappear(BasePlayer player)
        {
            if (_settings.OutputFormat.OutputTypeVanish == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.displayName }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_vanish"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_Vanish_Disappear", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeVanish == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Vanish Plugin")
                                              .AddUrl("https://umod.org/plugins/vanish")
                                              .AddColor("#800080")
                                              .AddDescription($"{player.displayName} has vanished.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5e2c4da074770.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_vanish"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnVanishReappear(BasePlayer player)
        {
            if (_settings.OutputFormat.OutputTypeVanish == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.displayName }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_vanish"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_Vanish_Reappear", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeVanish == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Vanish Plugin")
                                              .AddUrl("https://umod.org/plugins/vanish")
                                              .AddColor("#800080")
                                              .AddDescription($"{player.displayName} has reappeared.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5e2c4da074770.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_vanish"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion


        #endregion

        #region Premium Plugins

        #region Air Event
        void OnAirEventStart(HashSet<BaseEntity> entities)
        {
            if (_settings.OutputFormat.OutputTypeAirEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_airevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_AirEvent_Started", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeAirEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Air Event Plugin")
                                              .AddUrl("https://lone.design/product/airevent/")
                                              .AddColor("#800080")
                                              .AddDescription("Air Event has started.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1010785120237649961/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_airevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnAirEventEnd(HashSet<BaseEntity> entities)
        {
            if (_settings.OutputFormat.OutputTypeAirEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_airevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_AirEvent_Ended", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeAirEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Air Event Plugin")
                                              .AddUrl("https://lone.design/product/airevent/")
                                              .AddColor("#800080")
                                              .AddDescription("Air Event has ended.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1010785120237649961/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_airevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Armored Train Event
        void OnArmoredTrainEventStart()
        {
            if (_settings.OutputFormat.OutputTypeArmoredTrainEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_armoredtrainevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_ArmoredTrainEvent_Started", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeArmoredTrainEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Armored Train Event Plugin")
                                              .AddUrl("https://lone.design/product/armored-train-rust-plugin/")
                                              .AddColor("#800080")
                                              .AddDescription("Armored Train Event has started.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1012196381617815584/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_armoredtrainevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnArmoredTrainEventStop()
        {
            if (_settings.OutputFormat.OutputTypeArmoredTrainEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_armoredtrainevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_ArmoredTrainEvent_Ended", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeArmoredTrainEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Armored Train Event Plugin")
                                              .AddUrl("https://lone.design/product/armored-train-rust-plugin/")
                                              .AddColor("#800080")
                                              .AddDescription("Armored Train Event has ended.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1012196381617815584/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_armoredtrainevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Cargo Train Event
        void OnTrainEventStarted(TrainEngine train)
        {
            if (_settings.OutputFormat.OutputTypeCargoTrainEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_cargotrainevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_CargoTrainEvent_Started", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeCargoTrainEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Cargo Train Event Plugin")
                                              .AddUrl("https://lone.design/product/cargo-train-event-rust/")
                                              .AddColor("#800080")
                                              .AddDescription("Cargo Train Event has started.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1012200951647588422/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_cargotrainevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnTrainEventEnded(TrainEngine train)
        {
            if (_settings.OutputFormat.OutputTypeCargoTrainEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_cargotrainevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_CargoTrainEvent_Ended", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeCargoTrainEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Cargo Train Event Plugin")
                                              .AddUrl("https://lone.design/product/cargo-train-event-rust/")
                                              .AddColor("#800080")
                                              .AddDescription("Cargo Train Event has ended.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1012200951647588422/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_cargotrainevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Convoy Event
        void OnConvoyStart()
        {
            if (_settings.OutputFormat.OutputTypeConvoyEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_convoyevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_ConvoyEvent_Started", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeConvoyEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Convoy Event Plugin")
                                              .AddUrl("https://lone.design/product/convoy-rust-plugin/")
                                              .AddColor("#800080")
                                              .AddDescription("Convoy Event has started.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1012202423940567150/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_convoyevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnConvoyStop()
        {
            if (_settings.OutputFormat.OutputTypeConvoyEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_convoyevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_ConvoyEvent_Ended", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeConvoyEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Convoy Event Plugin")
                                              .AddUrl("https://lone.design/product/convoy-rust-plugin/")
                                              .AddColor("#800080")
                                              .AddDescription("Convoy Event has ended.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1012202423940567150/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_convoyevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Harbor Event
        void OnHarborEventStart()
        {
            if (_settings.OutputFormat.OutputTypeHarborEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_harborevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_HarborEvent_Started", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeHarborEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Harbor Event Plugin")
                                              .AddUrl("https://lone.design/product/harborevent/")
                                              .AddColor("#800080")
                                              .AddDescription("Harbor Event has started.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1010813485791326288/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_harborevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnHarborEventEnd(HashSet<BaseEntity> entities)
        {
            if (_settings.OutputFormat.OutputTypeHarborEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_harborevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_HarborEvent_Ended", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeHarborEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Harbor Event Plugin")
                                              .AddUrl("https://lone.design/product/harborevent/")
                                              .AddColor("#800080")
                                              .AddDescription("Harbor Event has ended.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1010813485791326288/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_harborevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Junkyard Event
        void OnJunkyardEventStart()
        {
            if (_settings.OutputFormat.OutputTypeJunkyardEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_junkyardevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_JunkyardEvent_Started", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeJunkyardEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Junkyard Event Plugin")
                                              .AddUrl("https://lone.design/product/junkyardevent-rust-plugin/")
                                              .AddColor("#800080")
                                              .AddDescription("Junkyard Event has started.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1011142703939063868/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_junkyardevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnJunkyardEventEnd(HashSet<BaseEntity> entities)
        {
            if (_settings.OutputFormat.OutputTypeJunkyardEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_junkyardevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_JunkyardEvent_Ended", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeJunkyardEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Junkyard Event Plugin")
                                              .AddUrl("https://lone.design/product/junkyardevent-rust-plugin/")
                                              .AddColor("#800080")
                                              .AddDescription("Junkyard Event has ended.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1011142703939063868/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_junkyardevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Power Plant Event
        void OnPowerPlantEventStart()
        {
            if (_settings.OutputFormat.OutputTypePowerPlantEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_powerplantevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_PowerPlantEvent_Started", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypePowerPlantEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Power Plant Event Plugin")
                                              .AddUrl("https://lone.design/product/power-plant-event/")
                                              .AddColor("#800080")
                                              .AddDescription("Power Plant Event has started.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1011144872826253372/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_powerplantevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnPowerPlantEventEnd(HashSet<BaseEntity> entities)
        {
            if (_settings.OutputFormat.OutputTypePowerPlantEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_powerplantevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_PowerPlantEvent_Ended", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeJunkyardEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Power Plant Event Plugin")
                                              .AddUrl("https://lone.design/product/power-plant-event/")
                                              .AddColor("#800080")
                                              .AddDescription("Power Plant Event has ended.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1011144872826253372/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_powerplantevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Satellite Dish Event
        void OnSatDishEventStart()
        {
            if (_settings.OutputFormat.OutputTypeSatDishEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_satdishevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_SatDishEvent_Started", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeSatDishEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Satellite Dish Event Plugin")
                                              .AddUrl("https://lone.design/product/satdishevent/")
                                              .AddColor("#800080")
                                              .AddDescription("Satellite Dish Event has started.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1011145882395213854/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_satdishevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnSatDishEventEnd(HashSet<BaseEntity> entities)
        {
            if (_settings.OutputFormat.OutputTypeSatDishEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_satdishevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_SatDishEvent_Ended", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeSatDishEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Satellite Dish Event Plugin")
                                              .AddUrl("https://lone.design/product/satdishevent/")
                                              .AddColor("#800080")
                                              .AddDescription("Satellite Dish Event has ended.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1011145882395213854/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_satdishevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Sputnik Event
        void OnSputnikEventStart()
        {
            if (_settings.OutputFormat.OutputTypeSputnikEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_sputnikevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_SputnikEvent_Started", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeSputnikEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Sputnik Event Plugin")
                                              .AddUrl("https://lone.design/product/sputnik/")
                                              .AddColor("#800080")
                                              .AddDescription("Sputnik Event has started.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1011495773936037888/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_sputnikevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnSputnikEventStop()
        {
            if (_settings.OutputFormat.OutputTypeSputnikEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_sputnikevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_SputnikEvent_Ended", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeSputnikEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Sputnik Event Plugin")
                                              .AddUrl("https://lone.design/product/sputnik/")
                                              .AddColor("#800080")
                                              .AddDescription("Sputnik Event has ended.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1011495773936037888/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_sputnikevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Water Event
        void OnWaterEventStart()
        {
            if (_settings.OutputFormat.OutputTypeWaterEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_waterevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_WaterEvent_Started", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeWaterEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Water Event Plugin")
                                              .AddUrl("https://lone.design/product/waterevent/")
                                              .AddColor("#800080")
                                              .AddDescription("Water Event has started.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1011166741310754836/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_waterevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnWaterEventEnd(HashSet<BaseEntity> entities)
        {
            if (_settings.OutputFormat.OutputTypeWaterEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_waterevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_WaterEvent_Ended", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeWaterEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Water Event Plugin")
                                              .AddUrl("https://lone.design/product/waterevent/")
                                              .AddColor("#800080")
                                              .AddDescription("Water Event has ended.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1011166741310754836/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_waterevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #endregion
    }
}

// --- End of file: Rustcord.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/Smelt.cs ---
// --- Original Local Path: BeeRust/Smelt.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using ru = Oxide.Game.Rust;

namespace Oxide.Plugins
{
    [Info("Smelt", "Rosty", "0.0.1")]
    class Smelt : RustPlugin
    {
        #region Config
        private PluginConfig config;
        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        private class PluginConfig
        {
            [JsonProperty("Кулдавн")]
            public float cooldown;

            [JsonProperty("Чат команда")]
            public string command;

            [JsonProperty("Переплавлять дерево?")]
            public bool wood;

            [JsonProperty("Сообщения")]
            public Dictionary<string, string> messages;

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    cooldown = 300f,
                    command = "smelt",
                    wood = true,
                    messages = new Dictionary<string, string>
                    {
                        {"M.COOLDOWN", "<color=#8888ff>[PsixRust]</color>  Переплавка инвентаря находится на перезарядке подождите:<color=#ff8888> {0} </color> сек."},
                        {"M.PERM", "<color=#8888ff>[PsixRust]</color> У вас нет разрешения на использование <color=#ff8888>smelt</color>." },
                        {"M.INV", "<color=#8888ff>[PsixRust]</color> Твой инвентарь переплавлен <color=#ff8888>successfully</color>." }
                    }
                };
            }
        }
        #endregion

        #region Initialize
        const string perminsta = "justsmelt.instant";
        const string permcommand = "justsmelt.command";
        static Dictionary<ulong, float> cooldowns = new Dictionary<ulong, float>();
        static ItemDefinition coal;

        private void OnServerInitialized()
        {
            permission.RegisterPermission(perminsta, this);
            permission.RegisterPermission(permcommand, this);
            Interface.Oxide.GetLibrary<ru.Libraries.Command>(null).AddChatCommand(config.command, this, "SmeltCmd");
            if (config.wood) coal = ItemManager.FindItemDefinition(-1938052175);
        }
        #endregion

    

        #region Command
        private void SmeltCmd(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, permcommand))
            {
                SendReply(player, config.messages["M.PERM"]);
                return;
            }

            float cooldown;
            if (cooldowns.TryGetValue(player.userID, out cooldown) && cooldown > UnityEngine.Time.realtimeSinceStartup)
            {
                SendReply(player, config.messages["M.COOLDOWN"], cooldowns[player.userID] - (int)UnityEngine.Time.realtimeSinceStartup);
                return;
            }

            foreach (Item item in player.inventory.AllItems()) SmeltIt(player, item);

            SendReply(player, config.messages["M.INV"]);
            cooldowns[player.userID] = (int)UnityEngine.Time.realtimeSinceStartup + config.cooldown;
        }
        #endregion

       #region Gathering
        /* private void OnItemAddedToContainer(ItemContainer container, Item item)
         {
             var player = container.GetOwnerPlayer();
             if (player == null || !permission.UserHasPermission(player.UserIDString, perminsta)) return;
             SmeltIt(player, item);
         }*/

        private object OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            var player = entity.ToPlayer();
            if (player == null || !permission.UserHasPermission(player.UserIDString, perminsta)) return null;
            return SmeltIt(player, item);
        }

        private object OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            if (!permission.UserHasPermission(player.UserIDString, perminsta)) return null;
            return SmeltIt(player, item);
        }

        private void OnCollectiblePickup(Item item, BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, perminsta)) return;
            SmeltIt(player, item);
        }
        #endregion

        #region Smelt
        private object SmeltIt(BaseEntity player, Item item)
        {
            if (item.info.itemid == -151838493 && config.wood) return GiveToPlayer(player, item, coal);
            else
            {
                ItemModCookable cookable = item.info.GetComponent<ItemModCookable>();
                if (cookable == null) return null;
                return GiveToPlayer(player, item, cookable.becomeOnCooked);
            }
        }

        private object GiveToPlayer(BaseEntity player, Item item, ItemDefinition def)
        {
            Item newItem = ItemManager.Create(def, item.amount);
            if (newItem == null) return null;
            item.Remove(0.0f);
            player.GiveItem(newItem, BaseEntity.GiveItemReason.ResourceHarvested);
            return true;
        }
        #endregion
    }
}

// --- End of file: Smelt.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/EventRandomizer.cs ---
// --- Original Local Path: BeeRust/EventRandomizer.cs ---

using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using ConVar;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Event Randomizer", "mvrb", "0.3.4")]
    [Description("Set random timers for server events")]
    class EventRandomizer : RustPlugin
    {
        private float heliInterval;
        private float chinookInterval;
        private float cargoInterval;
        private float airdropInterval;

        private int lastHeli;
        private int lastChinook;
        private int lastCargo;
        private int lastAirdrop;

        private string permSpawnChinook = "eventrandomizer.spawn.ch47";
        private string permSpawnHeli = "eventrandomizer.spawn.heli";
        private string permSpawnCargo = "eventrandomizer.spawn.cargo";
        private string permSpawnAirdrop = "eventrandomizer.spawn.airdrop";
		
        private string permCheckTimer = "eventrandomizer.check";
		
		private bool initialized = false;

        private class EventTimer
        {
            public float Min;
            public float Max;
        }

        private void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NextHeliIn"] = "Next Patrol Helicopter spawns in {0}",
                ["NextChinookIn"] = "Next Chinook Helicopter spawns in {0}",
                ["NextCargoIn"] = "Next Cargo Ship spawns in {0}",
                ["NextAirdropIn"] = "Next Airdrop spawns in {0}",

                ["CargoSpawned"] = "A Cargo Ship has been spawned.",
                ["PatrolHelicopterSpawned"] = "A Patrol Helicopter has been spawned.",
                ["ChinookSpawned"] = "A Chinook Helicopter has been spawned.",
                ["AirdropSpawned"] = "An Airdrop has been spawned.",

                ["FormatTime"] = "{0} Hours {1} Minutes",

                ["EventNotEnabled"] = "The Min and Max timer for {0} is less than or equal to 0 so this event has been disabled.",

                ["Warning: MinGreaterThanMax"] = "The minimum value ({0}) for {1} is greater than the maximum value ({2})!",

                ["Error: NoPermission"] = "You do not have permission to use this command.",
            }, this);
        }

        private void OnServerInitialized()
        {
            permission.RegisterPermission(permSpawnChinook, this);
            permission.RegisterPermission(permSpawnHeli, this);
            permission.RegisterPermission(permSpawnCargo, this);
            permission.RegisterPermission(permSpawnAirdrop, this);
            permission.RegisterPermission(permCheckTimer, this);

            LoadVariables();

            foreach (var entry in configData.EventTimers)
            {
                if (entry.Value.Min > entry.Value.Max)
                {
                    PrintWarning(Lang("Warning: MinGreaterThanMax", null, entry.Value.Min, entry.Key, entry.Value.Max));
                }
            }

            if (configData.EventTimers["Helicopter"].Min > 0 && configData.EventTimers["Helicopter"].Max > 0)
            {
                heliInterval = UnityEngine.Random.Range(configData.EventTimers["Helicopter"].Min, configData.EventTimers["Helicopter"].Max);
                timer.Once(heliInterval, SpawnHeliRandom);
                PrintWarning(Lang("NextHeliIn", null, FormatTime(heliInterval)));
            }
            else
            {
                PrintWarning(Lang("EventNotEnabled", null, "Helicopter"));
            }

            if (configData.EventTimers["Chinook"].Min > 0 && configData.EventTimers["Chinook"].Max > 0)
            {
                chinookInterval = UnityEngine.Random.Range(configData.EventTimers["Chinook"].Min, configData.EventTimers["Chinook"].Max);
                timer.Once(chinookInterval, SpawnChinookRandom);
                PrintWarning(Lang("NextChinookIn", null, FormatTime(chinookInterval)));
            }
            else
            {
                PrintWarning(Lang("EventNotEnabled", null, "Chinook"));
            }

            if (configData.EventTimers["Cargo"].Min > 0 && configData.EventTimers["Cargo"].Max > 0)
            {
                cargoInterval = UnityEngine.Random.Range(configData.EventTimers["Cargo"].Min, configData.EventTimers["Cargo"].Max);
                timer.Once(cargoInterval, SpawnCargoRandom);
                PrintWarning(Lang("NextCargoIn", null, FormatTime(cargoInterval)));
            }
            else
            {
                PrintWarning(Lang("EventNotEnabled", null, "Cargo"));
            }

            if (configData.EventTimers["Airdrop"].Min > 0 && configData.EventTimers["Airdrop"].Max > 0)
            {
                airdropInterval = UnityEngine.Random.Range(configData.EventTimers["Airdrop"].Min, configData.EventTimers["Airdrop"].Max);
                timer.Once(airdropInterval, SpawnAirdropRandom);
                PrintWarning(Lang("NextAirdropIn", null, FormatTime(airdropInterval)));
            }
            else
            {
                PrintWarning(Lang("EventNotEnabled", null, "Airdrop"));
            }

            var currentTime = GetUnix();

            lastHeli = currentTime;
            lastChinook = currentTime;
            lastCargo = currentTime;
            lastAirdrop = currentTime;
			
			initialized = true;
        }

        private void OnEntitySpawned(BaseNetworkable entity)
        {
			if (!initialized) return;			
            
            /*if (configData.blockServerAirdrops && entity is CargoPlane)
            {
                entity.KillMessage();
            }
            else*/ if (configData.blockServerCargoShips && entity is CargoShip)
            {
                entity.KillMessage();
            }
            else if (configData.blockServerChinooks && (entity is CH47Helicopter || entity is CH47HelicopterAIController))
            {
                //entity.KillMessage();
            }
            else if (configData.blockServerPatrolHelicopters && entity is PatrolHelicopterAI)
            {
                entity.KillMessage();
            }
        }

        [ChatCommand("heli")]
        private void CmdHeli(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, permCheckTimer))
            {
                player.ChatMessage(Lang("Error: NoPermission", player.UserIDString));
                return;
            }

            player.ChatMessage(Lang("NextHeliIn", player.UserIDString, FormatTime(heliInterval + lastHeli - GetUnix())));
        }

        [ChatCommand("chinok")]
        private void CmdChinook(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, permCheckTimer))
            {
                player.ChatMessage(Lang("Error: NoPermission", player.UserIDString));
                return;
            }

            player.ChatMessage(Lang("NextChinookIn", player.UserIDString, FormatTime(chinookInterval + lastChinook - GetUnix())));
        }

        [ChatCommand("cargo")]
        private void CmdCargo(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, permCheckTimer))
            {
                player.ChatMessage(Lang("Error: NoPermission", player.UserIDString));
                return;
            }

            player.ChatMessage(Lang("NextCargoIn", player.UserIDString, FormatTime(cargoInterval + lastCargo - GetUnix())));
        }

        [ConsoleCommand("ch47.spawn")]
        private void ConsoleCmdSpawnCh47(ConsoleSystem.Arg arg)
        {
            var player = arg?.Player();

            if (arg?.Connection != null && player && !permission.UserHasPermission(player.UserIDString, permSpawnChinook))
            {
                player.ChatMessage(Lang("Error: NoPermission", player.UserIDString));
                return;
            }

            SpawnChinook();
        }

        [ConsoleCommand("heli.spawn")]
        private void ConsoleCmdSpawnHeli(ConsoleSystem.Arg arg)
        {
            var player = arg?.Player();

            if (arg?.Connection != null && player && !permission.UserHasPermission(player.UserIDString, permSpawnHeli))
            {
                player.ChatMessage(Lang("Error: NoPermission", player.UserIDString));
                return;
            }

            SpawnHeli();
        }

        [ConsoleCommand("cargo.spawn")]
        private void ConsoleCmdSpawnCargo(ConsoleSystem.Arg arg)
        {
            var player = arg?.Player();

            if (arg?.Connection != null && player && !permission.UserHasPermission(player.UserIDString, permSpawnCargo))
            {
                player.ChatMessage(Lang("Error: NoPermission", player.UserIDString));
                return;
            }

            SpawnCargo();
        }

        [ConsoleCommand("airdrop.spawn")]
        private void ConsoleCmdSpawnAirdrop(ConsoleSystem.Arg arg)
        {
            var player = arg?.Player();

            if (arg?.Connection != null && player && !permission.UserHasPermission(player.UserIDString, permSpawnAirdrop))
            {
                player.ChatMessage(Lang("Error: NoPermission", player.UserIDString));
                return;
            }

            SpawnAirdrop();
        }

        private void SpawnCargoRandom()
        {
            SpawnCargo();
            lastCargo = GetUnix();

            cargoInterval = UnityEngine.Random.Range(configData.EventTimers["Cargo"].Min, configData.EventTimers["Cargo"].Max);
            timer.Once(cargoInterval, SpawnCargoRandom);
        }

        private void SpawnHeliRandom()
        {
            SpawnHeli();
            lastHeli = GetUnix();

            heliInterval = UnityEngine.Random.Range(configData.EventTimers["Helicopter"].Min, configData.EventTimers["Helicopter"].Max);
            timer.Once(heliInterval, SpawnHeliRandom);
        }

        private void SpawnChinookRandom()
        {
            SpawnChinook();
            lastChinook = GetUnix();

            chinookInterval = UnityEngine.Random.Range(configData.EventTimers["Chinook"].Min, configData.EventTimers["Chinook"].Max);
            timer.Once(chinookInterval, SpawnChinookRandom);
        }

        private void SpawnAirdropRandom()
        {
            SpawnAirdrop();
            lastAirdrop = GetUnix();

            airdropInterval = UnityEngine.Random.Range(configData.EventTimers["Airdrop"].Min, configData.EventTimers["Airdrop"].Max);
            timer.Once(airdropInterval, SpawnAirdropRandom);
        }

        private string FormatTime(float seconds)
        {
            TimeSpan time = TimeSpan.FromSeconds(seconds);

            return Lang("FormatTime", null, time.Hours, time.Minutes);
        }

        private void SpawnAirdrop()
        {
            var entity = GameManager.server.CreateEntity("assets/prefabs/npc/cargo plane/cargo_plane.prefab", new Vector3());
            entity?.Spawn();

            PrintWarning(Lang("AirdropSpawned"));
        }

        private void SpawnCargo()
        {
            Unsubscribe(nameof(OnEntitySpawned));
            var cargoShip = GameManager.server.CreateEntity("assets/content/vehicles/boats/cargoship/cargoshiptest.prefab") as CargoShip;
            if (cargoShip == null) return;
            cargoShip.TriggeredEventSpawn();
            cargoShip.Spawn();

            PrintWarning(Lang("CargoSpawned"));
            Subscribe(nameof(OnEntitySpawned));
        }

        private void SpawnHeli()
        {
            Unsubscribe(nameof(OnEntitySpawned));
            var heli = GameManager.server.CreateEntity("assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab");
            if (heli == null) return;
            heli.Spawn();

            PrintWarning(Lang("PatrolHelicopterSpawned"));
            Subscribe(nameof(OnEntitySpawned));
        }

        private void SpawnChinook()
        {
            Unsubscribe(nameof(OnEntitySpawned));
            var ch47 = (CH47HelicopterAIController)GameManager.server.CreateEntity("assets/prefabs/npc/ch47/ch47scientists.entity.prefab", new Vector3(0, 200, 0));
            if (ch47 == null) return;
            ch47.Spawn();

            PrintWarning(Lang("ChinookSpawned"));
            Subscribe(nameof(OnEntitySpawned));
        }

        private int GetUnix() => (int)(DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1))).TotalSeconds;

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        #region Config        
        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Event Timers in seconds")]
            public Dictionary<string, EventTimer> EventTimers { get; set; }

            [JsonProperty(PropertyName = "Block Airdrops spawned by the server")]
            public bool blockServerAirdrops;

            [JsonProperty(PropertyName = "Block Cargo Ships spawned by the server")]
            public bool blockServerCargoShips;

            [JsonProperty(PropertyName = "Block Chinooks spawned by the server")]
            public bool blockServerChinooks;

            [JsonProperty(PropertyName = "Block Patrol Helicopters spawned by the server")]
            public bool blockServerPatrolHelicopters;
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                EventTimers = new Dictionary<string, EventTimer>()
                {
                    { "Helicopter", new EventTimer(){ Min = 3600, Max = 7200 } },
                    { "Chinook", new EventTimer(){ Min = 7200, Max = 14400 } },
                    { "Cargo", new EventTimer(){ Min = 7200, Max = 10800 } },
                    { "Airdrop", new EventTimer(){ Min = 3600, Max = 3600 } }
                },
                blockServerPatrolHelicopters = true,
                blockServerChinooks =  true,
                blockServerAirdrops = true,
                blockServerCargoShips = true
            };

            SaveConfig(config);
        }

        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();

        private void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion
    }
}

// --- End of file: EventRandomizer.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/EnhancedBanSystem.cs ---
// --- Original Local Path: BeeRust/EnhancedBanSystem.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Database;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core.SQLite.Libraries;
using System.Text.RegularExpressions;

namespace Oxide.Plugins
{
    
    [Info("Enhanced Ban System", "Reneb/Slut", "5.2.6")]
    class EnhancedBanSystem : CovalencePlugin
    {
        [PluginReference]
        private Plugin PlayerDatabase, DiscordMessages;

        ////////////////////////////////////////////////////////////
        // Static fields
        ////////////////////////////////////////////////////////////
        static DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        char[] ipChrArray = new char[] { '.' };

        private static BanSystem banSystem;

        static Hash<int, BanData> cachedBans = new Hash<int, BanData>();

        static List<int> wasBanned = new List<int>();

        ////////////////////////////////////////////////////////////
        // Config fields
        ////////////////////////////////////////////////////////////
        private static string Platform = "Steam";
        private static string Server = "1.1.1.1:28015";
        private static string Game = "Rust";

        string PermissionBan = "enhancedbansystem.ban";
        string PermissionUnban = "enhancedbansystem.unban";
        string PermissionBanlist = "enhancedbansystem.banlist";
        string PermissionKick = "enhancedbansystem.kick";

        private bool SQLite_use = false;
        private string SQLite_DB = "banlist.db";

        private bool MySQL_use = false;
        private string MySQL_Host = "localhost";
        private int MySQL_Port = 3306;
        private string MySQL_DB = "banlist";
        private string MySQL_User = "root";
        private string MySQL_Pass = "toor";

        private bool PlayerDatabase_use = false;
        private string PlayerDatabase_IPFile = "EnhancedBanSystem_IPs.json";

        private bool Files_use = false;

        private bool WebAPI_use = false;
        private string WebAPI_Ban_Request = "http://webpage.com/api.php?action=ban&pass=mypassword&id={id}&steamid={steamid}&name={name}&ip={ip}&reason={reason}&source={source}&game={game}&platform={platform}&server={server}&tempban={expiration}";
        private string WebAPI_Unban_Request = "http://webpage.com/api.php?action=unban&pass=mypassword&steamid={steamid}&name={name}&ip={ip}&name={name}&source={source}";
        private string WebAPI_IsBanned_Request = "http://webpage.com/api.php?action=isbanned&pass=mypassword&id={id}&update={update}&steamid={steamid}&ip={ip}&time={time}&name={name}&game=Rust&server=rust.kortal.org:28015";
        private string WebAPI_Banlist_Request = "http://webpage.com/banlist.php?startid={startid}";

        private bool Native_use = false;

        private string BanDefaultReason = "Banned";
        private string BanEvadeReason = "Ban Evade";

        private bool Kick_Broadcast = true;
        private bool Kick_Log = true;
        private bool Kick_OnBan = true;

        private bool Ban_Broadcast = true;
        private bool Ban_Log = true;
        private bool Discord_use = false;
        private string Discord_Webhook = "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks";

        private bool Ban_Escape = true;

        private bool Log_Denied = true;

        protected override void LoadDefaultConfig() { }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }

        void Init()
        {
            CheckCfg<string>("Server Info - Platform", ref Platform);
            CheckCfg<string>("Server Info - Game", ref Game);
            CheckCfg<string>("Server Info - IP:PORT", ref Server);

            CheckCfg<string>("Permissions - Ban", ref PermissionBan);
            CheckCfg<string>("Permissions - Unban", ref PermissionUnban);
            CheckCfg<string>("Permissions - Banlist", ref PermissionBanlist);
            CheckCfg<string>("Permissions - Kick", ref PermissionKick);

            CheckCfg<bool>("DataType - SQLite - use", ref SQLite_use);
            CheckCfg<string>("DataType - SQLite - Database Filename", ref SQLite_DB);

            CheckCfg<bool>("DataType - MySQL - use", ref MySQL_use);
            CheckCfg<string>("DataType - MySQL - Host", ref MySQL_Host);
            CheckCfg<int>("DataType - MySQL - Port", ref MySQL_Port);
            CheckCfg<string>("DataType - MySQL - Database", ref MySQL_DB);
            CheckCfg<string>("DataType - MySQL - User", ref MySQL_User);
            CheckCfg<string>("DataType - MySQL - Pass", ref MySQL_Pass);

            CheckCfg<bool>("DataType - Files - use", ref Files_use);

            CheckCfg<bool>("DataType - PlayerDatabase - use", ref PlayerDatabase_use);
            CheckCfg<string>("DataType - PlayerDatabase - IP Filename", ref PlayerDatabase_IPFile);

            CheckCfg<bool>("DataType - WebAPI - use", ref WebAPI_use);
            CheckCfg<string>("DataType - WebAPI - Host", ref WebAPI_Ban_Request);
            CheckCfg<string>("DataType - WebAPI - Unban", ref WebAPI_Unban_Request);
            CheckCfg<string>("DataType - WebAPI - IsBanned", ref WebAPI_IsBanned_Request);
            CheckCfg<string>("DataType - WebAPI - Banlist", ref WebAPI_Banlist_Request);

            CheckCfg<bool>("DataType - Native - use", ref Native_use);

            CheckCfg<bool>("Ban - Evade", ref Ban_Escape);
            CheckCfg<string>("Ban - Default Reason", ref BanDefaultReason);
            CheckCfg<string>("Ban - Evade Reason", ref BanEvadeReason);
            CheckCfg<bool>("Ban - Broadcast", ref Ban_Broadcast);
            CheckCfg<bool>("Ban - Log", ref Ban_Log);
            CheckCfg<bool>("DiscordMessages - Use Discord", ref Discord_use);
            CheckCfg<string>("DiscordMessages - Discord Webhook", ref Discord_Webhook);

            CheckCfg<bool>("Kick - Broadcast", ref Kick_Broadcast);
            CheckCfg<bool>("Kick - Log", ref Kick_Log);
            CheckCfg<bool>("Kick - On Ban", ref Kick_OnBan);

            CheckCfg<bool>("Denied Connection - Log", ref Log_Denied);

            SaveConfig();

            if (SQLite_use) banSystem |= BanSystem.SQLite;
            if (MySQL_use) banSystem |= BanSystem.MySQL;
            if (Native_use) banSystem |= BanSystem.Native;
            if (PlayerDatabase_use) banSystem |= BanSystem.PlayerDatabase;
            if (Files_use) banSystem |= BanSystem.Files;
            if (WebAPI_use) banSystem |= BanSystem.WebAPI;

            InitializeLang();
        }

        void InitializeLang()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "PlayerNotFound", "No matching player was found.\n" },
                { "PlayerTempBanned", "You are temporarily banned from this server ({0}). {1} left" },
                { "PlayerPermBanned", "You are permanently banned from this server ({0})." },
                {"LoadedBans","Loaded {0} bans" },
                {"BanExists","This ban already exists ({0})." },
                {"BanAdded","Successfully added {0} to the banlist." },
                {"MultipleBans","Multiple Bans Found:\n\r" },
                {"BansRemoved","{0} matching bans were removed" },
                {"PlayerNotBanned","{0} - {1} isn't banned.\n" },
                {"Loaded","Loaded" },
                {"NoPermission","You don't have the permission to use this command." },
                {"KickSyntax","Syntax: kick < Name | SteamID | IP | IP Range > < reason(optional) >" },
                {"UnbanSyntax","Syntax: unban < Name | SteamID | IP | IP Range >" },
                {"BanSyntax","Syntax: ban < Name | SteamID | IP | IP Range > < reason(optional) > < time in secondes(optional) > " },
                {"BanlistSyntax","Syntax: banlist <BanSystem> <startid>" },
                {"BanSystems","Avaible BanSystems:\n" },
                {"BanlistSyntax1","Wrong usage of /banlist" },
                {"OutOfRange","Index is out of range. Current bans recorded: {0}" },
                {"Banlist","Banlist - {0}-{1}/{2}\n" },
                {"PlayerPermBan", "{0} was permanently banned from the server for {1}" },
                {"PlayerTempBan", "{0} was temporarily banned for {1} for {2}" },
                {"PlayerKick", "<color=red>{0}</color> <color=silver>was kicked from the server for</color> <color=red>{1}</color>" },
                {"IPPermBan", "An IP was banned from the server for {0}" },
                {"IPTempBan", "An IP was temporarily banned for {0} for {1}" },
                {"BanUpdated", "Succesfully updated {0} in the banlist." }
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "PlayerNotFound", "Подходящий игрок не найден.\n" },
                { "PlayerTempBanned", "Вы временно заблокированы на этом сервере (<color=#97be62>{0}</color>). Осталось <color=#97be62>{1}</color>" },
                { "PlayerPermBanned", "Вы навсегда заблокированы на этом сервере (<color=#97be62>{0}</color>)." },
                {"LoadedBans","Загружено банов: <color=#97be62>{0}</color>" },
                {"BanExists","Этот бан уже существует (<color=#97be62>{0}</color>)." },
                {"BanAdded","<color=#97be62>{0}</color> успешно добавлено в черный список." },
                {"MultipleBans","Найдено несколько банов:\n\r" },
                {"BansRemoved","Было удалено <color=#97be62>{0}</color> соответствующих банов" },
                {"PlayerNotBanned","<color=#97be62>{0}</color> - <color=#97be62>{1}</color> не забанен.\n" },
                {"Loaded","Загружено" },
                {"NoPermission","У вас нет прав на использование этой команды." },
                {"KickSyntax","Неверный Синтаксис: kick < Имя | SteamID | IP | Диапазон IP > < причина (необязательно) >" },
                {"UnbanSyntax","Неверный Синтаксис: unban < Имя | SteamID | IP | Диапазон IP >" },
                {"BanSyntax","Неверный Синтаксис: бан < Имя | SteamID | IP | Диапазон IP > < причина (необязательно) > < время в секундах (необязательно) >" },
                {"BanlistSyntax","Неверный Синтаксис: список банов <BanSystem> <startid>" },
                {"BanSystems","Доступные BanSystems:\n" },
                {"BanlistSyntax1","Неправильное использование <color=#97be62>/banlist</color>" },
                {"OutOfRange","Индекс вне допустимого диапазона. Зарегистрировано текущих банов: <color=#97be62>{0}</color>" },
                {"Banlist","Banlist - <color=#97be62>{0}</color>-<color=#97be62>{1}</color>/<color=#97be62>{2}</color>\n" },
                {"PlayerPermBan", "<color=#97be62>{0}</color> навсегда забанен на сервере за <color=#97be62>{1}</color>" },
                {"PlayerTempBan", "<color=#97be62>{0}</color> был временно забанен на <color=#97be62>{1}</color> за <color=#97be62>{2}</color>" },
                {"PlayerKick", "<color=#97be62>{0}</color> был выгнан с сервера за <color=#97be62>{1}</color>" },
                {"IPPermBan", "IP-адрес был заблокирован на сервере для <color=#97be62>{0}</color>" },
                {"IPTempBan", "IP-адрес был временно заблокирован для <color=#97be62>{0}</color> для <color=#97be62>{1}</color>" },
                {"BanUpdated", "Успешно обновлен <color=#97be62>{0}</color> в черном списке." }
            }, this, "ru");
        }

        ////////////////////////////////////////////////////////////
        // ID Save
        ////////////////////////////////////////////////////////////

        private static DynamicConfigFile Ban_ID_File;
        private static int Ban_ID = 0;

        void Load_ID()
        {
            try
            {
                Ban_ID_File = Interface.Oxide.DataFileSystem.GetDatafile(Name + "_ID");
                Ban_ID = (int)Ban_ID_File["id"];
            }
            catch
            {
                Ban_ID = 0;
                Ban_ID_File["id"] = Ban_ID;
                Save_ID();
            }
        }

        void Save_ID()
        {
            Interface.Oxide.DataFileSystem.SaveDatafile(Name + "_ID");
        }

        static int GetNewID()
        {
            Ban_ID++;
            Ban_ID_File["id"] = Ban_ID;
            return Ban_ID;
        }

        ////////////////////////////////////////////////////////////
        // Enum & Class
        ////////////////////////////////////////////////////////////

        enum BanSystem
        {
            Native = 1,
            MySQL = 2,
            SQLite = 4,
            WebAPI = 8,
            PlayerDatabase = 16,
            Files = 32,
        }

        class BanData
        {
            public int id;
            public string steamid;
            public string ip;
            public string name;
            public string game;
            public string server;
            public string source;
            public double date;
            public double expire;
            public string reason;
            public string platform;

            public BanData() { }

            public BanData(object source, string userID, string name, string ip, string reason, double duration)
            {
                this.id = GetNewID();
                this.source = source is IPlayer ? ((IPlayer)source).Name : source is string ? (string)source : "Console";
                this.steamid = userID;
                this.name = name;
                this.ip = ip;
                this.reason = reason;
                this.expire = duration != 0.0 ? LogTime() + duration : 0.0;
                this.date = LogTime();
                this.platform = Platform;
                this.game = Game;
                this.server = Server;
            }

            public BanData(int id, string source, string userID, string name, string ip, string reason, string duration)
            {
                this.id = id;
                this.source = source;
                this.steamid = userID;
                this.name = name;
                this.ip = ip;
                this.reason = reason;
                this.expire = double.Parse(duration);
                this.date = LogTime();
                this.platform = Platform;
                this.game = Game;
                this.server = Server;
            }

            public string ToJson()
            {
                return JsonConvert.SerializeObject(this);
            }

            public override string ToString()
            {
                return string.Format("{0} - {1} - {2} - {3} - {4}", steamid, name, ip, reason, expire == 0.0 ? "Permanent" : expire < LogTime() ? "Expired" : string.Format("Temporary: {0}s", (expire - LogTime()).ToString()));
            }
        }

        ////////////////////////////////////////////////////////////
        // General Methods
        ////////////////////////////////////////////////////////////


        private bool IsPluginLoaded(Plugin plugin)
        {
            if (plugin != null)
            {
                return plugins.GetAll().Where(x => x.Equals(plugin) && x.IsLoaded) != null;
            }
            else
            {
                return false;
            }
        }
        string FormatTime(TimeSpan time) => $"{(time.Days == 0 ? string.Empty : $"{time.Days} day(s)")}{(time.Days != 0 && time.Hours != 0 ? $", " : string.Empty)}{(time.Hours == 0 ? string.Empty : $"{time.Hours} hour(s)")}{(time.Hours != 0 && time.Minutes != 0 ? $", " : string.Empty)}{(time.Minutes == 0 ? string.Empty : $"{time.Minutes} minute(s)")}{(time.Minutes != 0 && time.Seconds != 0 ? $", " : string.Empty)}{(time.Seconds == 0 ? string.Empty : $"{time.Seconds} second(s)")}";

        private bool TryParseTimeSpan(string source, out TimeSpan timeSpan)
        {
            int seconds = 0, minutes = 0, hours = 0, days = 0;

            Match s = new Regex(@"(\d+?)s", RegexOptions.IgnoreCase).Match(source);
            Match m = new Regex(@"(\d+?)m", RegexOptions.IgnoreCase).Match(source);
            Match h = new Regex(@"(\d+?)h", RegexOptions.IgnoreCase).Match(source);
            Match d = new Regex(@"(\d+?)d", RegexOptions.IgnoreCase).Match(source);

            if (s.Success)
                seconds = Convert.ToInt32(s.Groups[1].ToString());

            if (m.Success)
                minutes = Convert.ToInt32(m.Groups[1].ToString());

            if (h.Success)
                hours = Convert.ToInt32(h.Groups[1].ToString());

            if (d.Success)
                days = Convert.ToInt32(d.Groups[1].ToString());

            source = source.Replace(seconds + "s", string.Empty);
            source = source.Replace(minutes + "m", string.Empty);
            source = source.Replace(hours + "h", string.Empty);
            source = source.Replace(days + "d", string.Empty);

            if (!string.IsNullOrEmpty(source) || (!s.Success && !m.Success && !h.Success && !d.Success))
            {
                timeSpan = default(TimeSpan);
                return false;
            }

            timeSpan = new TimeSpan(days, hours, minutes, seconds);

            return true;
        }


        static double LogTime() => DateTime.UtcNow.Subtract(epoch).TotalSeconds;

        string GetMsg(string key, object steamid = null, params object[] args)
        {

            if (args.Length != 0)
            {
                return string.Format(lang.GetMessage(key, this, steamid is IPlayer ? ((IPlayer)steamid).Id : steamid == null ? null : steamid.ToString()), args);
            }
            else
            {
                return lang.GetMessage(key, this, steamid is IPlayer ? ((IPlayer)steamid).Id : steamid == null ? null : steamid.ToString());
            }
        }

        bool hasPermission(IPlayer player, string permissionName)
        {
            if (player.IsAdmin) return true;
            return permission.UserHasPermission(player.Id.ToString(), permissionName);
        }

        bool isIPAddress(string arg)
        {
            int subIP;
            string[] strArray = arg.Split(ipChrArray);
            if (strArray.Length != 4)
            {
                return false;
            }
            foreach (string str in strArray)
            {
                if (str.Length == 0)
                {
                    return false;
                }
                if (!int.TryParse(str, out subIP) && str != "*")
                {
                    return false;
                }
                if (!(str == "*" || (subIP >= 0 && subIP <= 255)))
                {
                    return false;
                }
            }
            return true;
        }

        bool IPRange(string sourceIP, string targetIP)
        {
            string[] srcArray = sourceIP.Split(ipChrArray);
            string[] trgArray = targetIP.Split(ipChrArray);
            for (int i = 0; i < 4; i++)
            {
                if (srcArray[i] != trgArray[i] && srcArray[i] != "*")
                {
                    return false;
                }
            }
            return true;
        }

        bool RangeFromIP(string sourceIP, out string range1, out string range2, out string range3)
        {
            range1 = string.Empty;
            range2 = string.Empty;
            range3 = string.Empty;
            if (sourceIP == string.Empty) return false;

            string[] strArray = sourceIP.Split(ipChrArray);
            if (strArray.Length != 4)
            {
                return false;
            }

            range1 = string.Format("{0}.*.*.*", strArray[0]);
            range2 = string.Format("{0}.{1}.*.*", strArray[0], strArray[1]);
            range3 = string.Format("{0}.{1}.{2}.*", strArray[0], strArray[1], strArray[2]);

            return true;
        }

        List<IPlayer> FindPlayers(string userIDorNameorIP, object source, out string reason)
        {
            reason = string.Empty;
            var FoundPlayers = players.FindPlayers(userIDorNameorIP).ToList();
            if (FoundPlayers.Count == 0)
            {
                reason = GetMsg("PlayerNotFound", source) + "xd ";
            }
            if (FoundPlayers.Count > 1)
            {
                foreach (var iplayer in FoundPlayers)
                {
                    reason += string.Format("{0} {1}\r\n", iplayer.Id, iplayer.Name);
                }
            }
            return FoundPlayers;
        }

        List<IPlayer> FindConnectedPlayers(string userIDorNameorIP, object source, out string reason)
        {
            reason = string.Empty;
            ulong steamid = 0L;
            var FoundPlayers = new List<IPlayer>();
            ulong.TryParse(userIDorNameorIP, out steamid);
            if (isIPAddress(userIDorNameorIP))
            {
                FoundPlayers = players.All.Where(x => x.IsConnected).Where(w => IPRange(userIDorNameorIP, w.Address)).ToList();
            }
            else if (steamid != 0L)
            {
                var p = players.FindPlayer(userIDorNameorIP);
                if (p != null && p.IsConnected)
                {
                    FoundPlayers.Add(p);
                }
            }
            else
            {
                FoundPlayers = players.FindPlayers(userIDorNameorIP).Where(x => x.IsConnected).ToList();
                if (FoundPlayers.Count > 1)
                {
                    foreach (var iplayer in FoundPlayers)
                    {
                        reason += string.Format("{0} {1}\r\n", iplayer.Id, iplayer.Name);
                    }
                }
            }
            if (FoundPlayers.Count == 0)
            {
                reason = GetMsg("PlayerNotFound", source);
            }
            return FoundPlayers;
        }

        string GetPlayerIP(IPlayer iplayer)
        {
            try
            {
                if (iplayer.IsConnected) return iplayer.Address;
                return GetPlayerIP(iplayer.Id);
            }
            catch
            {
                return GetPlayerIP(iplayer.Id);
            }
        }
        string GetPlayerIP(string userID)
        {
            if (PlayerDatabase != null)
            {
                return (string)PlayerDatabase.Call("GetPlayerData", userID, "ip") ?? string.Empty;
            }
            return string.Empty;
        }

        string GetPlayerName(string userID)
        {
            if (PlayerDatabase != null)
            {
                return (string)PlayerDatabase.Call("GetPlayerData", userID, "name") ?? string.Empty;
            }
            return string.Empty;
        }
        bool HasDelayedAnswer() => BanSystemHasFlag(banSystem, BanSystem.MySQL) || BanSystemHasFlag(banSystem, BanSystem.SQLite) || (BanSystemHasFlag(banSystem, BanSystem.WebAPI));

        bool BanSystemHasFlag(BanSystem b, BanSystem t) => (b & t) == t;

        string FormatReturn(BanSystem system, string msg, params object[] args) => string.Format("{0}: {1}", system.ToString(), string.Format(msg, args));

        void SendReply(object source, string msg)
        {
            if (source is IPlayer) ((IPlayer)source).Reply(msg);
            else if (source is string) return;
            else Interface.Oxide.LogInfo(msg);
        }

        public static string ToShortString(TimeSpan timeSpan)
        {
            return string.Format("{0:00}:{1:00}:{2:00}", (int)timeSpan.TotalHours, timeSpan.Minutes, timeSpan.Seconds);
        }

        ////////////////////////////////////////////////////////////
        // Oxide Hooks
        ////////////////////////////////////////////////////////////


        void OnServerInitialized()
        {
            Load_ID();
            List<string> returnString = new List<string>();

            if (BanSystemHasFlag(banSystem, BanSystem.PlayerDatabase))
            {
                 returnString.Add(PlayerDatabase_Load());
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Files))
            {
                returnString.Add(Files_Load());
            }
            if (BanSystemHasFlag(banSystem, BanSystem.MySQL))
            {
                returnString.Add(MySQL_Load());
            }
            if (BanSystemHasFlag(banSystem, BanSystem.SQLite))
            {
                returnString.Add(SQLite_Load());
            }
            if (BanSystemHasFlag(banSystem, BanSystem.WebAPI))
            {
                returnString.Add(WebAPI_Load());
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Native))
            {
                returnString.Add(Native_Load());
            }

            if (returnString.Count == 0)
            {
                this.LogWarning("You must enable at least one Ban System to use this plugin!");
                Interface.Oxide.UnloadPlugin(Name);
            }

            permission.RegisterPermission(PermissionBan, this);
            permission.RegisterPermission(PermissionBanlist, this);
            permission.RegisterPermission(PermissionKick, this);
            permission.RegisterPermission(PermissionUnban, this);

            Interface.Oxide.LogInfo(string.Join("\n", returnString.ToArray()));

            if (Discord_use && (!IsPluginLoaded(DiscordMessages) || Discord_Webhook.Equals("https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks")))
            {
                LogError("DiscordMessages enabled but it isn't setup correctly.");
                Discord_use = false;
            }
        }

        void Unload() => OnServerSave();

        void OnServerSave()
        {
            Save_ID();
            if (BanSystemHasFlag(banSystem, BanSystem.PlayerDatabase))
            {
                Save_PlayerDatabaseIP();
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Files))
            {
                Save_Files();
            }
        }
        private void OnUserBanned(string name, string id, string address, string reason)
        {
            timer.Once(5f, () =>
            {
                if (!isBanned_Check(name, id, address))
                {
                    Puts("Adding banned player to EnhancedBanSystem");
                    BanData bd = new BanData("Auto Ban", id, name, address, reason, 0.0);
                    ExecuteBan("Auto Ban", bd, false);
                }
            });
        }
        object CanUserLogin(string name, string id, string ip)
        {
            BanData bd = null;
            if (isBanned_NonDelayed(name, id, ip, Ban_Escape, out bd))
            {
                if (bd != null && bd.expire != 0.0)
                {
                    return GetMsg("PlayerTempBanned", id, bd.reason, FormatTime(TimeSpan.FromSeconds(bd.expire - LogTime())));
                }
                return GetMsg("PlayerPermBanned", id, bd == null ? string.Empty : bd.reason);
            }
            return null;
        }

        void OnUserConnected(IPlayer player)
        {
            if (player == null) return;
            string ip = player.Address;
            string name = player.Name;
            string steamid = player.Id;

            isBanned_Delayed(name, steamid, ip, Ban_Escape);
        }

        ////////////////////////////////////////////////////////////
        // Files
        ////////////////////////////////////////////////////////////

        StoredData storedData;

        class StoredData
        {
            public HashSet<string> Banlist = new HashSet<string>();
        }

        string Files_Load()
        {
            try
            {
                storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            }
            catch
            {
                storedData = new StoredData();
            }
            foreach (var b in storedData.Banlist)
            {
                var bd = JsonConvert.DeserializeObject<BanData>(b);
                if (!cachedBans.ContainsKey(bd.id))
                    cachedBans.Add(bd.id, bd);
            }
            return FormatReturn(BanSystem.Files, GetMsg("LoadedBans", null), storedData.Banlist.Count.ToString());
        }

        void Save_Files()
        {
            if (storedData.Banlist == null)
            {
                return;
            }
            Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);
        }

        string Files_UpdateBan(BanData bandata)
        {
            if (!cachedBans.ContainsKey(bandata.id)) return FormatReturn(BanSystem.Files, "No such ban id {0}", bandata.id);

            storedData.Banlist.Remove(cachedBans[bandata.id].ToJson());
            cachedBans.Remove(bandata.id);

            storedData.Banlist.Add(bandata.ToJson());

            if (!cachedBans.ContainsKey(bandata.id))
                cachedBans.Add(bandata.id, bandata);

            return FormatReturn(BanSystem.Files, GetMsg("BanUpdated"), bandata.ToString());
        }

        string Files_ExecuteBan(BanData bandata)
        {

            var f = cachedBans.Values.Where(x => x.ip == bandata.ip).Where(x => x.steamid == bandata.steamid).ToList();
            if (f.Count > 0)
            {
                var i = f.ToList();
                foreach (var id in i)
                {
                    if (id.expire == 0.0 || id.expire < LogTime()) continue;
                    storedData.Banlist.Remove(id.ToJson());
                    f.Remove(id);
                }
                if (f.Count > 0)
                {
                    return FormatReturn(BanSystem.Files, GetMsg("BanExists"), f[0].ToString());
                }
            }
            storedData.Banlist.Add(bandata.ToJson());
            Save_Files();
            if (!cachedBans.ContainsKey(bandata.id))
                cachedBans.Add(bandata.id, bandata);

            return FormatReturn(BanSystem.Files, GetMsg("BanAdded"), bandata.ToString());
        }

        string Files_RawUnban(List<BanData> unbanList)
        {
            int i = 0;
            foreach (var u in unbanList)
            {
                var json = u.ToJson();
                if (storedData.Banlist.Contains(json))
                {
                    i++;
                    storedData.Banlist.Remove(json);
                }
            }
            return FormatReturn(BanSystem.Files, GetMsg("BansRemoved"), i.ToString());
        }

        string Files_ExecuteUnban(string steamid, string name, string ip, out List<BanData> unbanList)
        {
            unbanList = new List<BanData>();
            if (ip != string.Empty)
            {
                unbanList = cachedBans.Values.Where(x => x.ip == ip).ToList();
            }
            else if (steamid != string.Empty)
            {
                unbanList = cachedBans.Values.Where(x => x.steamid == steamid).ToList();
            }
            else
            {
                var list = cachedBans.Values.Where(x => x.name.ToLower().Equals(name.ToLower())).ToList();
                if (list.Count > 1)
                {
                    var ret = FormatReturn(BanSystem.Files, GetMsg("MultipleBans"));
                    foreach (var b in list)
                    {
                        ret += string.Format("{0} - {1} - {2}\n\r", b.steamid, b.name, b.reason);
                    }
                    return ret;
                }
                else
                {
                    unbanList = list;
                }
            }
            return Files_RawUnban(unbanList);
        }

        bool Files_IsBanned(string steamid, string ip, out BanData bandata)
        {
            bandata = null;
            double cTime = LogTime();
            bool permanent = false;
            List<BanData> unbanList = new List<BanData>();
            List<BanData> list = new List<BanData>();
            // check by ID then IP
            var b_steamid = cachedBans.Values.Where(x => x.steamid == steamid).ToList();
            var b_steamid_ip = ip != null ? b_steamid.Where(w => w.ip == ip).ToList() : new List<BanData>();

            foreach (var b in b_steamid_ip)
            {
                if (b.expire != 0.0 && cTime >= b.expire)
                {
                    unbanList.Add(b);
                }
                else
                {
                    if (b.expire == 0.0)
                    {
                        permanent = true;
                    }
                    if (b.ip == ip)
                    {
                        bandata = b;
                    }
                }
            }
            if (unbanList.Count > 0)
            {
                Files_RawUnban(unbanList);
                foreach (var u in unbanList)
                {
                    b_steamid_ip.Remove(u);
                }
                unbanList.Clear();
            }
            foreach (var b in b_steamid)
            {
                if (b.expire != 0.0 && cTime >= b.expire)
                {
                    unbanList.Add(b);
                }
                else
                {
                    if (b.expire == 0.0)
                    {
                        permanent = true;
                    }
                    if (b.ip == ip)
                    {
                        bandata = b;
                    }
                }
            }
            if (unbanList.Count > 0)
            {
                Files_RawUnban(unbanList);
                foreach (var u in unbanList)
                {
                    b_steamid.Remove(u);
                }
                unbanList.Clear();
            }
            if (bandata == null)
            {
                if (b_steamid_ip.Count > 0)
                {
                    bandata = b_steamid_ip[0];
                }
                else if (b_steamid.Count > 0)
                {
                    bandata = b_steamid[0];
                }
            }
            if (bandata == null && !permanent)
            {
                // check by IP & IP Range
                list = ip != null ? cachedBans.Values.Where(x => x.ip != null && IPRange(x.ip, ip)).ToList() : new List<BanData>();
                foreach (var b in list)
                {
                    if (b.expire != 0.0 && cTime >= b.expire)
                    {
                        unbanList.Add(b);
                    }
                    else
                    {
                        if (b.expire == 0.0)
                        {
                            permanent = true;
                        }
                    }
                }
                if (unbanList.Count > 0)
                {
                    Files_RawUnban(unbanList);
                    foreach (var u in unbanList)
                    {
                        list.Remove(u);
                    }
                    unbanList.Clear();
                }
                if (list.Count > 0)
                {
                    bandata = list[0];
                }
            }
            if (bandata != null && bandata.expire != 0.0 && permanent)
            {
                bandata.expire = 0.0;
                Files_UpdateBan(bandata);
            }
            return bandata != null;
        }

        string Files_Banlist(object source, int startid)
        {
            if (startid > cachedBans.Count)
            {
                return FormatReturn(BanSystem.Files, "Index is out of range. Current bans recorded: {0}", cachedBans.Count.ToString());
            }

            int i = -1;
            int max = startid + 9;

            string returnstring = FormatReturn(BanSystem.Files, GetMsg("Banlist"), startid.ToString(), max.ToString(), cachedBans.Count.ToString());


            var bans = from pair in cachedBans orderby pair.Key descending select pair;

            foreach (KeyValuePair<int, BanData> b in bans)
            {
                i++;
                if (i < startid) continue;
                if (i > max) break;
                returnstring += b.ToString() + "\n";

            }

            return returnstring;
        }

        ////////////////////////////////////////////////////////////
        // PlayerDatabase
        ////////////////////////////////////////////////////////////

        static StoredIPData storedIPData;

        class StoredIPData
        {
            public HashSet<string> Banlist = new HashSet<string>();
        }

        string PlayerDatabase_Load()
        {
            if (!IsPluginLoaded(PlayerDatabase)) return FormatReturn(BanSystem.PlayerDatabase, "Missing plugin: oxidemod.org/threads/playerdatabase.18409/");

            try
            {
                storedIPData = Interface.Oxide.DataFileSystem.ReadObject<StoredIPData>(PlayerDatabase_IPFile);
            }
            catch
            {
                storedIPData = new StoredIPData();
            }

            if (storedIPData.Banlist.Count > 0)
            {
                foreach (var b in storedIPData.Banlist)
                {
                    var bd = JsonConvert.DeserializeObject<BanData>(b);
                    if (!cachedBans.ContainsKey(bd.id))
                        cachedBans.Add(bd.id, bd);
                }
            }
            var getKnownPlayers = (List<string>)PlayerDatabase.Call("GetAllKnownPlayers");
            if (getKnownPlayers == null) return FormatReturn(BanSystem.PlayerDatabase, "Error P01");

            int i = 0;
            List<BanData> list = new List<BanData>();
            foreach (var steamid in getKnownPlayers)
            {
                var success = PlayerDatabase.Call("GetPlayerDataRaw", steamid, "Banned");
                if (!(success is string)) continue;

                
                if (((string)success).Equals("System.Collections.Generic.List`1[Oxide.Plugins.EnhancedBanSystem+BanData]", StringComparison.Ordinal))
                {
                    list = new List<BanData>();
                }
                else
                {
                    list = JsonConvert.DeserializeObject<List<BanData>>((string)success);
                }

                foreach (var b in list)
                {
                    i++;
                    if (!cachedBans.ContainsKey(b.id))
                        cachedBans.Add(b.id, b);
                }
            }
            return FormatReturn(BanSystem.PlayerDatabase, GetMsg("LoadedBans"), i.ToString());
        }

        void Save_PlayerDatabaseIP()
        {
            Interface.Oxide.DataFileSystem.WriteObject(PlayerDatabase_IPFile, storedIPData);
        }


        string PlayerDatabase_ExecuteBan(BanData bandata)
        {
            if (bandata.steamid != string.Empty)
            {
                List<BanData> list = new List<BanData>();
                var success = PlayerDatabase.Call("GetPlayerDataRaw", bandata.steamid, "Banned");
                if (success is string)
                {
                    list = JsonConvert.DeserializeObject<List<BanData>>((string)success);
                }

                var f = list.Where(x => x.ip == bandata.ip).ToList();
                if (f.Count > 0)
                {
                    return FormatReturn(BanSystem.PlayerDatabase, GetMsg("BanExists"), f[0].ToString());
                }
                f.Add(bandata);
                PlayerDatabase.Call("SetPlayerData", bandata.steamid, "Banned", f, true);
            }
            else
            {
                var f2 = cachedBans.Values.Where(x => x.ip == bandata.ip).Where(x => x.steamid == string.Empty).ToList();
                if (f2.Count > 0)
                {
                    return FormatReturn(BanSystem.PlayerDatabase, GetMsg("BanExists"), f2[0].ToString());
                }
                storedIPData.Banlist.Add(bandata.ToJson());
            }
            if (!cachedBans.ContainsKey(bandata.id))
                cachedBans.Add(bandata.id, bandata);
            return FormatReturn(BanSystem.PlayerDatabase, GetMsg("BanAdded"), bandata.ToString());
        }

        string PlayerDatabase_UpdateBan(BanData bandata, double expire)
        {
            if (bandata.steamid == string.Empty)
            {
                if (cachedBans.ContainsKey(bandata.id))
                {
                    var json = bandata.ToJson();
                    if (storedIPData.Banlist.Contains(json))
                    {
                        cachedBans.Remove(bandata.id);
                        storedIPData.Banlist.Remove(json);
                        bandata.expire = expire;
                        storedIPData.Banlist.Add(bandata.ToJson());
                        cachedBans.Add(bandata.id, bandata);
                        return FormatReturn(BanSystem.Files, GetMsg("BanUpdated"), bandata.ToString());
                    }
                }
            }
            else
            {
                List<BanData> list = new List<BanData>();
                bandata.expire = expire;
                var b_steamid = PlayerDatabase.Call("GetPlayerDataRaw", bandata.steamid, "Banned");
                if (b_steamid is string)
                {
                    list = JsonConvert.DeserializeObject<List<BanData>>((string)b_steamid);
                }
                if (list.Count > 0)
                {
                    foreach (var b in list)
                    {
                        b.expire = expire;
                    }
                    PlayerDatabase.Call("SetPlayerData", bandata.steamid, "Banned", list, true);
                    return FormatReturn(BanSystem.Files, GetMsg("BanUpdated"), bandata.ToString());
                }
            }
            return string.Empty;
        }

        string PlayerDatabase_RawUnban(List<BanData> unbanList)
        {
            int i = 0;
            foreach (var u in unbanList)
            {
                if (u.steamid == string.Empty)
                {
                    var json = u.ToJson();
                    if (storedIPData.Banlist.Contains(json))
                    {
                        i++;
                        storedIPData.Banlist.Remove(json);
                    }
                }
                else
                {
                    i++;
                    PlayerDatabase.Call("SetPlayerData", u.steamid, "Banned", new List<BanData>(), true);
                }
            }
            return FormatReturn(BanSystem.PlayerDatabase, GetMsg("BansRemoved"), i.ToString());
        }

        string PlayerDatabase_ExecuteUnban(string steamid, string name, string ip, out List<BanData> unbanList)
        {
            unbanList = new List<BanData>();
            if (ip != string.Empty)
            {
                unbanList = cachedBans.Values.Where(x => x.ip == ip).ToList();
            }
            else if (steamid != string.Empty)
            {
                unbanList = cachedBans.Values.Where(x => x.steamid == steamid).ToList();
            }
            else
            {
                unbanList = cachedBans.Values.Where(x => x.name == name).ToList();
                if (unbanList.Count == 0)
                {
                    var lname = name.ToLower();
                    unbanList = cachedBans.Values.Where(x => x.name.ToLower().Contains(lname)).ToList();
                    if (unbanList.Count > 1)
                    {
                        var ret = FormatReturn(BanSystem.PlayerDatabase, GetMsg("MultipleBans"));
                        foreach (var b in unbanList)
                        {
                            ret += string.Format("{0} - {1} - {2}\n\r", b.steamid, b.name, b.reason);
                        }
                        return ret;
                    }
                }
            }
            return PlayerDatabase_RawUnban(unbanList);
        }

        bool PlayerDatabase_IsBanned(string steamid, string ip, out BanData bandata)
        {
            bandata = null;
            BanData possibleData = null;
            double cTime = LogTime();
            bool permanent = false;
            List<BanData> unbanList = new List<BanData>();
            List<BanData> list = new List<BanData>();
            // check by ID then IP
            var b_steamid = PlayerDatabase.Call("GetPlayerDataRaw", steamid, "Banned");
            if (b_steamid is string)
            {
                list = JsonConvert.DeserializeObject<List<BanData>>((string)b_steamid);
            }
            foreach (var b in list)
            {
                if (b.expire != 0.0 && cTime >= b.expire)
                {
                    unbanList.Add(b);
                }
                else
                {
                    if (b.expire == 0.0)
                    {
                        permanent = true;
                    }
                    if (b.ip == ip)
                    {
                        bandata = b;
                    }
                }
            }
            if (unbanList.Count > 0)
            {
                PlayerDatabase_RawUnban(unbanList);
                foreach (var b in unbanList)
                {
                    list.Remove(b);
                }
                unbanList.Clear();
            }

            if (list.Count > 0 && bandata == null)
            {
                possibleData = list[0];
            }
            // check by IP & IP Range
            list = ip != null ? cachedBans.Values.Where(x => x.ip != null && IPRange(x.ip, ip)).ToList() : new List<BanData>();
            foreach (var b in list)
            {
                if (b.expire != 0.0 && cTime >= b.expire)
                {
                    unbanList.Add(b);
                }
                else
                {
                    if (b.expire == 0.0)
                    {
                        permanent = true;
                    }
                }
            }
            if (unbanList.Count > 0)
            {
                PlayerDatabase_RawUnban(unbanList);
                foreach (var b in unbanList)
                {
                    list.Remove(b);
                }
                unbanList.Clear();
            }
            if (list.Count > 0 && bandata == null && possibleData == null)
            {
                possibleData = list[0];
            }
            if (bandata == null && possibleData != null)
            {
                bandata = possibleData;
            }
            if (bandata != null && bandata.expire != 0.0 && permanent)
            {
                PlayerDatabase_UpdateBan(bandata, 0.0);
            }
            return bandata != null;
        }

        string PlayerDatabase_Banlist(object source, int startid)
        {
            if (startid > cachedBans.Count)
            {
                return FormatReturn(BanSystem.PlayerDatabase, GetMsg("OutOfRange"), cachedBans.Count.ToString());
            }

            int i = -1;
            int max = startid + 9;

            string returnstring = FormatReturn(BanSystem.PlayerDatabase, GetMsg("Banlist"), startid.ToString(), max.ToString(), cachedBans.Count.ToString());


            var bans = from pair in cachedBans orderby pair.Key descending select pair;

            foreach (KeyValuePair<int, BanData> b in bans)
            {
                i++;
                if (i < startid) continue;
                if (i > max) break;
                returnstring += b.ToString() + "\n";

            }

            return returnstring;
        }

        ////////////////////////////////////////////////////////////
        // WebAPI
        ////////////////////////////////////////////////////////////

        string FormatOnlineBansystem(string line, Dictionary<string, string> args)
        {
            foreach (KeyValuePair<string, string> pair in args)
            {
                line = line.Replace(pair.Key, pair.Value);
            }
            return line;
        }

        string WebAPI_ExecuteBan(object source, BanData bandata)
        {
            webrequest.Enqueue(FormatOnlineBansystem(WebAPI_Ban_Request, new Dictionary<string, string> { { "{id}", bandata.id.ToString() }, { "{steamid}", bandata.steamid }, { "{name}", bandata.name }, { "{ip}", bandata.ip }, { "{reason}", bandata.reason }, { "{source}", bandata.source }, { "{expiration}", bandata.expire.ToString() }, { "{game}", bandata.game }, { "{platform}", bandata.platform }, { "{server}", bandata.server } }), null, (code, response) =>
            {
                if (response == null && code == 200)
                {
                    response = FormatReturn(BanSystem.WebAPI, "Couldn't contact the WebAPI");
                }
                if (source is IPlayer) ((IPlayer)source).Reply(response);
                else Interface.Oxide.LogInfo(response);
            }, this);


            return string.Empty;
        }

        string WebAPI_ExecuteUnban(object source, string steamid, string name, string ip)
        {
            webrequest.Enqueue(FormatOnlineBansystem(WebAPI_Unban_Request, new Dictionary<string, string> { { "{steamid}", steamid }, { "{name}", name }, { "{ip}", ip } }), null, (code, response) =>
            {
                if (response == null && code == 200)
                {
                    response = FormatReturn(BanSystem.WebAPI, "Couldn't contact the WebAPI");
                }
                if (source is IPlayer) ((IPlayer)source).Reply(response);
                else Interface.Oxide.LogInfo(response);
            }, this);

            return string.Empty;
        }

        string WebAPI_IsBanned(BanData bandata, bool update)
        {
            webrequest.Enqueue(FormatOnlineBansystem(WebAPI_IsBanned_Request, new Dictionary<string, string> { { "{id}", bandata.id.ToString() }, { "{steamid}", bandata.steamid }, { "{name}", bandata.name }, { "{ip}", bandata.ip }, { "{source}", "Auto Ban" }, { "{update}", update.ToString() }, { "{time}", LogTime().ToString() } }), null, (code, response) =>
            {
                if (response != null || code != 200)
                {
                    if (response == "false" || response == "0")
                        return;
                    timer.Once(0.01f, () => Kick(null, bandata.steamid, response == "true" || response == "1" ? "Banned" : response, false));
                }
                else
                {
                    Interface.Oxide.LogWarning("WebAPI couldn't be contacted or is not valid");
                }
            }, this);

            return string.Empty;
        }

        string WebAPI_Banlist(object source, int startid)
        {
            webrequest.Enqueue(FormatOnlineBansystem(WebAPI_Banlist_Request, new Dictionary<string, string> { { "{startid}", startid.ToString() } }), null, (code, response) =>
            {
                if (response != null || code != 200)
                {
                    SendReply(source, response);
                }
            }, this);

            return string.Empty;
        }

        string WebAPI_Load()
        {
            return FormatReturn(BanSystem.WebAPI, GetMsg("Loaded"));
        }

        ////////////////////////////////////////////////////////////
        // SQLite
        ////////////////////////////////////////////////////////////

        SQLite Sqlite = Interface.Oxide.GetLibrary<SQLite>();
        Connection Sqlite_conn;

        string SQLite_Load()
        {
            var returnstring = string.Empty;
            try
            {
                Sqlite_conn = Sqlite.OpenDb(SQLite_DB, this);
                if (Sqlite_conn == null)
                {
                    returnstring = FormatReturn(BanSystem.SQLite, "Couldn't open the SQLite.");
                }
                else
                {
                    Sqlite.Insert(Core.Database.Sql.Builder.Append("CREATE TABLE IF NOT EXISTS EnhancedBanSystem ( id INTEGER NOT NULL PRIMARY KEY UNIQUE, steamid TEXT, name TEXT, ip TEXT, reason TEXT, source TEXT, game TEXT, platform TEXT, server TEXT, expire INTEGER );"), Sqlite_conn);
                    returnstring = FormatReturn(BanSystem.SQLite, GetMsg("Loaded"));
                }
            }
            catch (Exception e)
            {
                returnstring = e.Message;
            }
            return FormatReturn(BanSystem.SQLite, returnstring);
        }


        string SQLite_RawBan(BanData bandata)
        {
            try
            {
                Sqlite.Insert(Core.Database.Sql.Builder.Append("INSERT OR REPLACE INTO EnhancedBanSystem ( id, steamid, name, ip, reason, source, game, platform, server, expire ) VALUES ( @0, @1, @2, @3, @4, @5, @6, @7, @8, @9 )", bandata.id, bandata.steamid, bandata.name, bandata.ip, bandata.reason, bandata.source, bandata.game, bandata.platform, bandata.server, (int)bandata.expire), Sqlite_conn);
            }
            catch (Exception e)
            {
                return e.Message;
            }
            return FormatReturn(BanSystem.SQLite, GetMsg("BanAdded"), bandata.ToString());
        }

        string SQLite_ExecuteBan(object source, BanData bandata)
        {
            var sqlString = bandata.steamid == string.Empty ? Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `ip` == @0 ", bandata.ip) : Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `steamid` == @0 AND `ip` == @1 ", bandata.steamid, bandata.ip);

            Sqlite.Query(sqlString, Sqlite_conn, list =>
            {
                if (list != null)
                {
                    foreach (var entry in list)
                    {
                        var bd = new BanData(int.Parse(entry["id"].ToString()), (string)entry["source"], (string)entry["steamid"], (string)entry["name"], (string)entry["ip"], (string)entry["reason"], entry["expire"].ToString());
                        var response = FormatReturn(BanSystem.SQLite, GetMsg("BanExists"), bd.ToString());
                        SendReply(source, response);
                        return;
                    }
                }
                var reponse2 = SQLite_RawBan(bandata);
                if (source is IPlayer) ((IPlayer)source).Reply(reponse2);
                else Interface.Oxide.LogInfo(reponse2);
            });

            return string.Empty;
        }

        void SQLite_RawUnban(object source, List<long> unbanList)
        {
            foreach (var id in unbanList)
            {
                Sqlite.Insert(Core.Database.Sql.Builder.Append("DELETE from EnhancedBanSystem WHERE `id` = @0", id), Sqlite_conn);
            }
            var returnstring = FormatReturn(BanSystem.SQLite, GetMsg("BansRemoved"), unbanList.Count.ToString());
            SendReply(source, returnstring);
        }

        string SQLite_ExecuteUnban(object source, string steamid, string name, string ip)
        {
            List<long> unbanList = new List<long>();
            if (ip != string.Empty || steamid != string.Empty)
            {
                var sqlString = ip != string.Empty ? Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `ip` == @0 ", ip) : Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `steamid` == @0", steamid);
                Sqlite.Query(sqlString, Sqlite_conn, list =>
                {
                    if (list != null)
                    {
                        foreach (var entry in list)
                        {
                            unbanList.Add((long)entry["id"]);
                        }
                    }
                    SQLite_RawUnban(source, unbanList);
                });
            }
            else
            {
                Sqlite.Query(Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `name` LIKE @0", "%" + name + "%"), Sqlite_conn, list =>
                {
                    List<Dictionary<string, object>> f = new List<Dictionary<string, object>>();
                    if (list != null)
                    {
                        foreach (var entry in list)
                        {
                            f.Add(entry);
                            unbanList.Add((long)entry["id"]);
                        }
                    }
                    if (unbanList.Count > 1)
                    {
                        var ret = FormatReturn(BanSystem.SQLite, GetMsg("MultipleBans"));
                        foreach (var e in f)
                        {
                            ret += string.Format("{0} - {1} - {2}\n\r", (string)e["steamid"], (string)e["name"], (string)e["reason"]);
                        }
                        if (source is IPlayer) ((IPlayer)source).Reply(ret);
                        else Interface.Oxide.LogInfo(ret);
                        return;
                    }
                    SQLite_RawUnban(source, unbanList);
                });
            }
            return string.Empty;
        }

        void SQLite_UpdateBan(BanData bandata)
        {
            Sqlite.Insert(Core.Database.Sql.Builder.Append("UPDATE EnhancedBanSystem SET `steamid`= @1, `name`= @2, `ip`= @3,`reason`= @4,`source`=@5, `game`= @6, `platform`= @7,`server`= @8, `expire`= @9 WHERE `id` = @0", bandata.id, bandata.steamid, bandata.name, bandata.ip, bandata.reason, bandata.source, bandata.game, bandata.platform, bandata.server, (int)bandata.expire), Sqlite_conn);
        }

        void SQLite_IsBanned(BanData bandata, bool update)
        {
            bandata.reason = BanEvadeReason;

            double cTime = LogTime();
            List<long> unbanList = new List<long>();
            Dictionary<string, object> match = new Dictionary<string, object>();

            Sqlite.Query(Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `steamid` == @0", bandata.steamid), Sqlite_conn, list =>
            {

                var l = new List<Dictionary<string, object>>();
                if (list != null)
                {
                    foreach (var entry in list)
                    {
                        var expire = (long)entry["expire"];
                        if (expire != 0.0 && cTime >= expire)
                        {
                            unbanList.Add((long)entry["id"]);
                        }
                        else
                        {
                            if ((string)entry["ip"] == bandata.ip)
                            {
                                match = entry;
                            }
                            l.Add(entry);
                        }
                    }
                }
                if (unbanList.Count > 0)
                {
                    SQLite_RawUnban("Auto Ban", unbanList);
                    unbanList.Clear();
                }
                var l2 = l.Where(x => (long)x["expire"] == 0L).ToList();
                if (l2.Count == 0)
                {
                    string range1;
                    string range2;
                    string range3;
                    if (RangeFromIP(bandata.ip, out range1, out range2, out range3))
                    {
                        Sqlite.Query(Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `ip` == @0 OR `ip` == @1 OR `ip` == @2 OR `ip` == @3", bandata.ip, range1, range2, range3), Sqlite_conn, list2 =>
                        {
                            if (list2 != null)
                            {
                                foreach (var entry in list2)
                                {
                                    var expire = (long)entry["expire"];
                                    if (expire != 0.0 && cTime >= expire)
                                    {
                                        unbanList.Add((long)entry["id"]);
                                    }
                                    else
                                    {
                                        if (!l.Contains(entry))
                                            l.Add(entry);
                                    }
                                }
                            }
                            if (l.Count > 0)
                            {
                                l2 = l.Where(x => (long)x["expire"] == 0L).ToList();
                                bandata.expire = l2.Count > 0 ? 0.0 : match.ContainsKey("expire") ? (long)(match["expire"]) : (long)(l[0]["expire"]);
                                if (match.ContainsKey("expire"))
                                {
                                    if ((long)(match["expire"]) != bandata.expire)
                                    {
                                        var bd = new BanData(int.Parse(match["id"].ToString()), (string)match["source"], (string)match["steamid"], (string)match["name"], (string)match["ip"], (string)match["reason"], match["expire"].ToString());
                                        bd.expire = bandata.expire;
                                        SQLite_UpdateBan(bd);
                                    }
                                }
                                else if (update) ExecuteBan("Auto Ban", bandata, false);
                                timer.Once(0.1f, () => Kick(null, bandata.steamid, match.ContainsKey("reason") ? (string)match["reason"] : (string)l[0]["reason"], false));
                            }
                        });
                    }
                }
                if (l.Count > 0)
                {
                    bandata.expire = l2.Count > 0 ? 0.0 : match.ContainsKey("expire") ? (long)(match["expire"]) : (long)(l[0]["expire"]);
                    if (match.ContainsKey("expire"))
                    {
                        if ((long)(match["expire"]) != bandata.expire)
                        {
                            var bd = new BanData(int.Parse(match["id"].ToString()), (string)match["source"], (string)match["steamid"], (string)match["name"], (string)match["ip"], (string)match["reason"], match["expire"].ToString());
                            SQLite_UpdateBan(bd);
                        }
                    }
                    else if (update) ExecuteBan("Auto Ban", bandata, false);
                    timer.Once(0.1f, () => Kick(null, bandata.steamid, match.ContainsKey("reason") ? (string)match["reason"] : (string)l[0]["reason"], false));
                }
            });
        }

        string SQLite_Banlist(object source, int startid)
        {
            Sqlite.Query(Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem ORDER BY id DESC"), Sqlite_conn, list =>
            {
                int i = -1;
                int max = startid + 9;
                string replystring = string.Empty;
                if (list != null)
                {
                    replystring += FormatReturn(BanSystem.SQLite, GetMsg("Banlist"), startid.ToString(), max.ToString(), list.Count.ToString());
                    foreach (var entry in list)
                    {
                        i++;
                        if (i < startid) continue;
                        if (i > max) break;
                        var bd = new BanData(int.Parse(entry["id"].ToString()), (string)entry["source"], (string)entry["steamid"], (string)entry["name"], (string)entry["ip"], (string)entry["reason"], entry["expire"].ToString());
                        replystring += bd.ToString() + "\n";
                    }
                    SendReply(source, replystring);
                }
            });
            return string.Empty;
        }

        ////////////////////////////////////////////////////////////
        // MySQL
        ////////////////////////////////////////////////////////////

        Oxide.Core.MySql.Libraries.MySql Sql = Interface.Oxide.GetLibrary<Oxide.Core.MySql.Libraries.MySql>();
        Connection Sql_conn;

        string MySQL_Load()
        {
            try
            {
                Sql_conn = Sql.OpenDb(MySQL_Host, MySQL_Port, MySQL_DB, MySQL_User, MySQL_Pass, this);
                if (Sql_conn == null || Sql_conn.Con == null)
                {
                    return FormatReturn(BanSystem.MySQL, "Couldn't open the MySQL PlayerDatabase: {0} ", Sql_conn.Con.State.ToString());
                }
                else
                {
                    Sql.Insert(Core.Database.Sql.Builder.Append("CREATE TABLE IF NOT EXISTS enhancedbansystem ( `id` int(11) NOT NULL, `steamid` VARCHAR(17),`name` VARCHAR(25),`ip` VARCHAR(15),`reason` VARCHAR(25),`source` VARCHAR(25), `game` VARCHAR(25) , `platform` VARCHAR(25), `server` VARCHAR(25), `expire` int(11) );"), Sql_conn);
                    return FormatReturn(BanSystem.MySQL, GetMsg("Loaded"));
                }
            }
            catch (Exception e)
            {
                return FormatReturn(BanSystem.MySQL, e.Message);
            }
        }

        string MySQL_RawBan(BanData bandata)
        {
            try
            {
                Sql.Insert(Core.Database.Sql.Builder.Append("INSERT IGNORE INTO enhancedbansystem ( `id`, `steamid`,`name`,`ip`,`reason`,`source`,`game`,`platform`, `server`, `expire` ) VALUES ( @0, @1, @2, @3, @4, @5, @6, @7, @8, @9 )", bandata.id, bandata.steamid, bandata.name, bandata.ip, bandata.reason, bandata.source, bandata.game, bandata.platform, bandata.server, (int)bandata.expire), Sql_conn);
            }
            catch (Exception e)
            {
                return e.Message;
            }
            return FormatReturn(BanSystem.MySQL, GetMsg("BanAdded"), bandata.ToString());
        }

        void MySQL_UpdateBan(BanData bandata)
        {
            Sql.Insert(Core.Database.Sql.Builder.Append("UPDATE EnhancedBanSystem SET `steamid`= @1, `name`= @2, `ip`= @3,`reason`= @4,`source`=@5, `game`= @6, `platform`= @7,`server`= @8, `expire`= @9 WHERE `id` = @0", bandata.id, bandata.steamid, bandata.name, bandata.ip, bandata.reason, bandata.source, bandata.game, bandata.platform, bandata.server, (int)bandata.expire), Sqlite_conn);
        }

        void MySQL_RawUnban(object source, List<int> unbanList)
        {
            foreach (var id in unbanList)
            {
                Sql.Insert(Core.Database.Sql.Builder.Append("DELETE from enhancedbansystem WHERE `id` = @0", id), Sql_conn);
                if (BanSystemHasFlag(banSystem, BanSystem.Native))
                {
                    Native_ExecuteUnban(id.ToString(), null);
                }
            }
            SendReply(source, FormatReturn(BanSystem.MySQL, GetMsg("BansRemoved"), unbanList.Count.ToString()));
        }
        string MySQL_ExecuteBan(object source, BanData bandata)
        {
            var sqlString = bandata.steamid == string.Empty ? Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `ip` = @0 ", bandata.ip) : Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `steamid` = @0 AND `ip` = @1 ", bandata.steamid, bandata.ip);
            Sql.Query(sqlString, Sql_conn, list =>
            {
                if (list != null)
                {
                    foreach (var entry in list)
                    {
                        var bd = new BanData(int.Parse(entry["id"].ToString()), (string)entry["source"], (string)entry["steamid"], (string)entry["name"], (string)entry["ip"], (string)entry["reason"], entry["expire"].ToString());
                        var response = FormatReturn(BanSystem.MySQL, GetMsg("BanExists"), bd.ToString());
                        SendReply(source, response);
                        return;
                    }
                }
                SendReply(source, MySQL_RawBan(bandata));
            });
            return string.Empty;
        }

        string MySQL_ExecuteUnban(object source, string steamid, string name, string ip)
        {
            List<int> unbanList = new List<int>();
            if (ip != string.Empty || steamid != string.Empty)
            {
                var sqlString = ip != string.Empty ? Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `ip` = @0 ", ip) : Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `steamid` = @0", steamid);
                Sql.Query(sqlString, Sql_conn, list =>
                {
                    if (list != null)
                    {
                        foreach (var entry in list)
                        {
                            unbanList.Add((int)entry["id"]);
                        }
                    }
                    MySQL_RawUnban(source, unbanList);
                });
            }
            else
            {
                Sql.Query(Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `name` LIKE @0", "%" + name + "%"), Sql_conn, list =>
                {
                    List<Dictionary<string, object>> f = new List<Dictionary<string, object>>();
                    if (list != null)
                    {
                        foreach (var entry in list)
                        {
                            f.Add(entry);
                            unbanList.Add((int)entry["id"]);
                        }
                    }
                    if (unbanList.Count > 1)
                    {
                        string ret = FormatReturn(BanSystem.MySQL, GetMsg("MultipleBans"));
                        foreach (var e in f)
                        {
                            ret += string.Format("{0} - {1} - {2}\n\r", (string)e["steamid"], (string)e["name"], (string)e["reason"]);
                        }
                        if (source is IPlayer) ((IPlayer)source).Reply(ret);
                        else Interface.Oxide.LogInfo(ret);
                        return;
                    }
                    else
                    {
                        MySQL_RawUnban(source, unbanList);
                    }
                });
            }
            return string.Empty;
        }

        void MySQL_IsBanned(BanData bandata, bool update)
        {
            bandata.reason = BanEvadeReason;

            List<int> unbanList = new List<int>();
            double cTime = LogTime();
            Dictionary<string, object> match = new Dictionary<string, object>();

            Sql.Query(Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `steamid` = @0", bandata.steamid), Sql_conn, list =>
            {
                var l = new List<Dictionary<string, object>>();
                if (list != null)
                {
                    foreach (var entry in list)
                    {
                        var expire = (int)entry["expire"];
                        if (expire != 0 && cTime >= expire)
                        {
                            unbanList.Add((int)entry["id"]);
                        }
                        else
                        {
                            if ((string)entry["ip"] == bandata.ip)
                            {
                                match = entry;
                            }
                            l.Add(entry);
                        }
                    }
                }
                if (unbanList.Count > 0)
                {
                    MySQL_RawUnban("Auto Ban", unbanList);
                    unbanList.Clear();
                }
                var l2 = l.Where(x => (int)x["expire"] == 0).ToList();
                if (l2.Count == 0)
                {
                    string range1;
                    string range2;
                    string range3;
                    if (RangeFromIP(bandata.ip, out range1, out range2, out range3))
                    {
                        Sql.Query(Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `ip` = @0 OR `ip` = @1 OR `ip` = @2 OR `ip` = @3", bandata.ip, range1, range2, range3), Sql_conn, list2 =>
                        {
                            if (list2 != null)
                            {
                                foreach (var entry in list2)
                                {
                                    var expire = (int)entry["expire"];
                                    if (expire != 0 && cTime >= double.Parse(expire.ToString()))
                                    {
                                        unbanList.Add((int)entry["id"]);
                                    }
                                    else
                                    {
                                        if (!l.Contains(entry))
                                            l.Add(entry);
                                    }
                                }
                            }
                            if (l.Count > 0)
                            {
                                bandata.expire = l2.Count > 0 ? 0.0 : match.ContainsKey("expire") ? (int)(match["expire"]) : (int)(l[0]["expire"]);
                                if (match.ContainsKey("expire"))
                                {
                                    if (double.Parse(match["expire"].ToString()) != bandata.expire)
                                    {
                                        var bd = new BanData(int.Parse(match["id"].ToString()), (string)match["source"], (string)match["steamid"], (string)match["name"], (string)match["ip"], (string)match["reason"], match["expire"].ToString());
                                        MySQL_UpdateBan(bd);
                                    }
                                }
                                else if (update) ExecuteBan("Auto Ban", bandata, false);
                                timer.Once(0.1f, () => Kick(null, bandata.steamid, match.ContainsKey("reason") ? (string)match["reason"] : (string)l[0]["reason"]));
                            }
                        });
                    }
                }
                if (l.Count > 0)
                {
                    bandata.expire = l2.Count > 0 ? 0.0 : match.ContainsKey("expire") ? double.Parse(match["expire"].ToString()) : double.Parse(l[0]["expire"].ToString());
                    if (match.ContainsKey("expire"))
                    {
                        if (double.Parse(match["expire"].ToString()) != bandata.expire)
                        {
                            var bd = new BanData(int.Parse(match["id"].ToString()), (string)match["source"], (string)match["steamid"], (string)match["name"], (string)match["ip"], (string)match["reason"], match["expire"].ToString());
                            MySQL_UpdateBan(bd);
                        }
                    }
                    else if (update) ExecuteBan("Auto Ban", bandata, false);
                    timer.Once(0.1f, () => Kick(null, bandata.steamid, match.ContainsKey("reason") ? (string)match["reason"] : (string)l[0]["reason"], false));
                }
            });
        }

        string MySQL_Banlist(object source, int startid)
        {
            Sql.Query(Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem ORDER BY id DESC"), Sql_conn, list =>
            {
                int i = -1;
                int max = startid + 9;
                string replystring = string.Empty;
                if (list != null)
                {
                    replystring += FormatReturn(BanSystem.MySQL, GetMsg("Banlist"), startid.ToString(), max.ToString(), list.Count.ToString());
                    foreach (var entry in list)
                    {
                        i++;
                        if (i < startid) continue;
                        if (i > max) break;
                        var bd = new BanData(int.Parse(entry["id"].ToString()), (string)entry["source"], (string)entry["steamid"], (string)entry["name"], (string)entry["ip"], (string)entry["reason"], entry["expire"].ToString());
                        replystring += bd.ToString() + "\n";

                    }
                    SendReply(source, replystring);
                }
            });
            return string.Empty;
        }

        ////////////////////////////////////////////////////////////
        // Native
        ////////////////////////////////////////////////////////////

        string Native_Load()
        {
            return FormatReturn(BanSystem.Native, GetMsg("Loaded"));
        }
        string Native_ExecuteBan(BanData bandata)
        {
            if (bandata.steamid.Length == 0) return FormatReturn(BanSystem.Native, "Can't ban by IP.");

            var player = players.FindPlayer(bandata.steamid);
            if (player == null) return FormatReturn(BanSystem.Native, GetMsg("PlayerNotFound"));
            if (player.IsBanned) return FormatReturn(BanSystem.Native, GetMsg("BanExists"), bandata.steamid.ToString());

            TimeSpan duration = bandata.expire == 0.0 ? default(TimeSpan) : TimeSpan.FromSeconds(bandata.expire);
            player.Ban(bandata.reason, duration);
#if RUST
            if (bandata.expire != 0.0)
            {
              return FormatReturn(BanSystem.Native, GetMsg("BanAdded"), bandata.steamid.ToString()) + "\nWARNING: NATIVE temporary bans are not supported in RUST! Temporary bans will stay permanent";
            }
#endif
            return FormatReturn(BanSystem.Native, GetMsg("BanAdded"), bandata.steamid.ToString());
        }

        string Native_ExecuteUnban(string steamid, string name)
        {
            if (steamid == string.Empty)
            {
                if (name == string.Empty) return string.Empty;
                var f = players.FindPlayers(name).Where(x => x.IsBanned).ToList();
                if (f.Count == 0)
                {
                    return FormatReturn(BanSystem.Native, GetMsg("PlayerNotFound"));
                }
                if (f.Count > 1)
                {
                    var ret = string.Empty;
                    foreach (var p in f)
                    {
                        ret += string.Format("{0} - {1}\n", p.Id, p.Name);
                    }
                    return ret;
                }
                steamid = f[0].Id;
            }
            var b = players.FindPlayer(steamid);
            if (b == null)
            {
                return FormatReturn(BanSystem.Native, GetMsg("PlayerNotFound"));
            }
            if (!b.IsBanned)
            {
                return FormatReturn(BanSystem.Native, GetMsg("PlayerNotBanned"), b.Id, b.Name);
            }
            b.Unban();
            return FormatReturn(BanSystem.Native, "1 matching bans were removed");
        }

        bool Native_IsBanned(string steamid)
        {
            var b = players.FindPlayer(steamid);
            if (b != null)
            {
                return b.IsBanned;
            }
            return false;
        }

        string Native_Banlist(object source, int startid)
        {
            int i = -1;
            int max = startid + 9;

            var banlist = players.All.Where(x => x.IsBanned).ToList();

            string returnstring = FormatReturn(BanSystem.Native, GetMsg("Banlist"), startid.ToString(), max.ToString(), banlist.Count.ToString());

            foreach (IPlayer b in banlist)
            {
                i++;
                if (i < startid) continue;
                if (i > max) break;
                returnstring += string.Format("{0} - {1} - {2}", b.Id, b.Name, ToShortString(b.BanTimeRemaining));
            }

            return returnstring;
        }


        ////////////////////////////////////////////////////////////
        // Kick
        ////////////////////////////////////////////////////////////

        string Kick(object source, string target, string reason, bool shouldBroadcast = true)
        {
            string r = string.Empty;
            var foundplayers = FindConnectedPlayers(target, source, out r);
            if (r != string.Empty)
            {
                return r;
            }

            var returnkick = string.Empty;
            foreach (var iplayer in foundplayers)
            {
                returnkick += ExecuteKick(source, iplayer, reason, shouldBroadcast) + "\r\n";
            }

            return returnkick;
        }
        string TryKick(object source, string[] args)
        {
            string target = args[0];
            string reason = args.Length > 1 ? args[1] : "Kicked";
            return Kick(source, target, reason);
        }

        string ExecuteKick(object source, IPlayer player, string reason, bool shouldBroadcast = true)
        {
            if (shouldBroadcast && Kick_Broadcast)
            {
                server.Broadcast(GetMsg("PlayerKick", null, player.Name.ToString(), reason));
                if (Discord_use)
                {
                    object payload = new[]
                    {
                        new{name="Player", value=$"[{player.Name}](https://steamcommunity.com/profiles/{player.Id})", inline=true},
                        new{name="Kicked By", value=source is IPlayer ? ((IPlayer)source).Name : source.ToString(),inline=true },
                        new{name="Reason", value=reason, inline=false}
                    };
                    string json = JsonConvert.SerializeObject(payload);
                    DiscordMessages.Call("API_SendFancyMessage", Discord_Webhook, "Player Kick", 3329330, json);
                }
            }

            if (Kick_Log)
                Interface.Oxide.LogWarning(GetMsg("{0} was kicked from the server ({1})", null, player.Name.ToString(), reason));

            player.Kick(reason);


            return GetMsg("{0} was kicked from the server ({1})", source, player.Name.ToString(), reason);
        }


        ////////////////////////////////////////////////////////////
        // IsBanned
        ////////////////////////////////////////////////////////////
        bool isBanned_Check(string name, string steamid, string ip)
        {
            int count = 0;
            if (BanSystemHasFlag(banSystem, BanSystem.Files))
            {
                count++;
                var files = cachedBans.Values.Where(x => x.steamid == steamid).ToList();
                if (files.Count > 0)
                {
                    return true;
                }
            }
            if (BanSystemHasFlag(banSystem, BanSystem.PlayerDatabase))
            {
                count++;
                var playerdatabase = PlayerDatabase.Call("GetPlayerDataRaw", steamid, "Banned");
                if (playerdatabase is string && playerdatabase != null)
                {
                    return true;
                }
            }
            if (BanSystemHasFlag(banSystem, BanSystem.MySQL))
            {
                count++;
                bool foundMySQL = false;
                Sql.Query(Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `steamid` = @0", steamid), Sql_conn, list =>
                {
                    if (list != null)
                    {
                        foundMySQL = true;
                    }
                });
                if (foundMySQL)
                {
                    return true;
                }
            }
            if (BanSystemHasFlag(banSystem, BanSystem.SQLite))
            {
                count++;
                bool sqlite = false;
                Sqlite.Query(Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `steamid` == @0", steamid), Sqlite_conn, list =>
                {
                    if (list != null)
                    {
                        sqlite = true;
                    }
                });
                if (sqlite)
                {
                    return true;
                }
            }
            if (BanSystemHasFlag(banSystem, BanSystem.WebAPI))
            {
                count++;
                bool banned = false;
                webrequest.Enqueue(FormatOnlineBansystem(WebAPI_IsBanned_Request, new Dictionary<string, string> { { "{id}", null }, { "{steamid}", steamid }, { "{name}", name }, { "{ip}", ip }, { "{source}", "Auto Ban" }, { "{update}", false.ToString() }, { "{time}", LogTime().ToString() } }), null, (code, response) =>
                {
                    if (response != null || code != 200)
                    {
                        if (response == "true")
                        {
                            banned = true;
                        }
                    }
                    else
                    {
                        Interface.Oxide.LogWarning("WebAPI couldn't be contacted or is not valid");
                    }
                }, this);
                if (banned == true)
                {
                    return banned;
                }
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Native) && count > 0)
            {
                return false;
            }
            else if (BanSystemHasFlag(banSystem, BanSystem.Native) && count == 0)
            {
                var player = players.FindPlayer(steamid);
                return player != null && player.IsBanned;
            }
            return false;
        }
        bool isBanned_NonDelayed(string name, string steamid, string ip, bool update, out BanData bandata)
        {
            bool denied = false;
            bandata = null;
            if (!denied && BanSystemHasFlag(banSystem, BanSystem.Native))
            {
                if (Native_IsBanned(steamid))
                {
                    if (Log_Denied)
                        Interface.Oxide.LogInfo(string.Format("Native: {0} - {1} - {2} was rejected from the server", steamid, name, ip));
                    denied = true;
                }
            }
            if (!denied && BanSystemHasFlag(banSystem, BanSystem.PlayerDatabase))
            {
                if (PlayerDatabase_IsBanned(steamid, ip, out bandata))
                {
                    if (Log_Denied)
                        Interface.Oxide.LogInfo(string.Format("PlayerDatabase: {0} - {1} - {2} was rejected from the server", steamid, name, ip));
                    denied = true;
                }
            }
            if (!denied && BanSystemHasFlag(banSystem, BanSystem.Files))
            {
                if (Files_IsBanned(steamid, ip, out bandata))
                {
                    if (Log_Denied)
                        Interface.Oxide.LogInfo(string.Format("Files: {0} - {1} - {2} was rejected from the server", steamid, name, ip));
                    denied = true;
                }
            }
            if (update && denied)
            {
                if (bandata != null && (bandata.ip != ip || bandata.steamid != steamid))
                    PrepareBan("Auto Ban", steamid, name, ip, BanEvadeReason, bandata.expire == 0.0 ? 0.0 : bandata.expire - LogTime(), false);
                else if (bandata == null)
                    PrepareBan("Auto Ban", steamid, name, ip, BanEvadeReason, 0.0, false);
            }
            return bandata != null;
        }

        void isBanned_Delayed(string name, string steamid, string ip, bool update)
        {
            var partialBan = new BanData("Auto Ban", steamid, name, ip, string.Empty, 0.0);
            if (BanSystemHasFlag(banSystem, BanSystem.SQLite))
            {
                SQLite_IsBanned(partialBan, update);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.MySQL))
            {
                MySQL_IsBanned(partialBan, update);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.WebAPI))
            {
                WebAPI_IsBanned(partialBan, update);
            }
        }

        ////////////////////////////////////////////////////////////
        // Banlist
        ////////////////////////////////////////////////////////////

        string TryBanlist(object source, string[] args)
        {
            int startID = 0;
            BanSystem bs;
            if (args != null && args.Length > 1)
            {
                int.TryParse(args[1], out startID);
            }
            switch (args[0].ToLower())
            {
                case "files":
                    bs = BanSystem.Files;
                    break;
                case "mysql":
                    bs = BanSystem.MySQL;
                    break;
                case "native":
                    bs = BanSystem.Native;
                    break;
                case "playerdatabase":
                    bs = BanSystem.PlayerDatabase;
                    break;
                case "sqlite":
                    bs = BanSystem.SQLite;
                    break;
                case "webapi":
                    bs = BanSystem.WebAPI;
                    break;
                default:
                    return GetMsg("BanlistSyntax1", source);
            }

            return Banlist(source, bs, startID);
        }

        string Banlist(object source, BanSystem bs, int startID)
        {
            switch (bs)
            {
                case BanSystem.Files:
                    return Files_Banlist(source, startID);
                case BanSystem.MySQL:
                    return MySQL_Banlist(source, startID);
                case BanSystem.Native:
                    return Native_Banlist(source, startID);
                case BanSystem.PlayerDatabase:
                    return PlayerDatabase_Banlist(source, startID);
                case BanSystem.SQLite:
                    return SQLite_Banlist(source, startID);
                case BanSystem.WebAPI:
                    return WebAPI_Banlist(source, startID);
                default:
                    return string.Empty;
            }
        }

        ////////////////////////////////////////////////////////////
        // Ban
        ////////////////////////////////////////////////////////////


        string TryBan(object source, string[] args)
        {
            string ipaddress = isIPAddress(args[0]) ? args[0] : string.Empty;
            string steamid = string.Empty;
            string name = string.Empty;
            string errorreason = string.Empty;
            ulong userID;
            double duration = 0.0;
            string reason = BanDefaultReason;
            TimeSpan duration1;
            if (args.Length > 2 && TryParseTimeSpan(args[1], out duration1))
            {
                duration = duration1.TotalSeconds;
                reason = string.Join(" ", args.Skip(2).ToArray());
            }
            else if (args.Length > 1)
            {
                reason = string.Join(" ", args.Skip(1).ToArray());
            }
            if (ipaddress.Length != 0)
            {
                return BanIP(source, ipaddress, reason, duration);
            }
            else
            {
                var foundplayers = FindPlayers(args[0], source, out errorreason);
                if (errorreason != string.Empty | errorreason.Length != 0)
                {
                    if (ulong.TryParse(args[0], out userID) && userID.IsSteamId())
                    {
                        return BanID(source, args[0], reason, duration);
                    }
                    return errorreason;
                }
                return BanPlayer(source, foundplayers[0], reason, duration);
            }
        }

        string BanIP(object source, string ip, string reason, double duration)
        {
            return PrepareBan(source, string.Empty, string.Empty, ip, reason, duration, Kick_OnBan);
        }

        string BanID(object source, string steamid, string reason, double duration)
        {
            string name = GetPlayerName(steamid);
            string ipaddress = GetPlayerIP(steamid);

            return PrepareBan(source, steamid, name, ipaddress, reason, duration, Kick_OnBan);
        }

        string BanPlayer(object source, IPlayer player, string reason, double duration)
        {
            var address = GetPlayerIP(player);

            return PrepareBan(source, player.Id, player.Name, address, reason, duration, Kick_OnBan);
        }

        string PrepareBan(object source, string userID, string name, string ip, string reason, double duration, bool kick)
        {
            var bandata = new BanData(source, userID, name, ip, reason, duration);


            return ExecuteBan(source, bandata, kick);
        }
        string ExecuteBan(object source, BanData bandata, bool kick)
        {
            Unsubscribe(nameof(OnUserBanned));
            if (wasBanned.Contains(bandata.id)) return string.Empty;

            string returnstring = null;
            if (BanSystemHasFlag(banSystem, BanSystem.PlayerDatabase))
            {
                returnstring += PlayerDatabase_ExecuteBan(bandata);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Files))
            {
                returnstring += Files_ExecuteBan(bandata);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.MySQL))
            {
                returnstring += MySQL_ExecuteBan(source, bandata);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.SQLite))
            {
                returnstring += SQLite_ExecuteBan(source, bandata);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.WebAPI))
            {
                returnstring += WebAPI_ExecuteBan(source, bandata);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Native))
            {
                returnstring += Native_ExecuteBan(bandata);
            }

            if (Ban_Broadcast)
                if (bandata.name != string.Empty | bandata.steamid != string.Empty)
                    server.Broadcast(bandata.expire == 0.0 ? GetMsg("PlayerPermBan", null, bandata.name, bandata.reason) : GetMsg("PlayerTempBan", null, bandata.name, FormatTime(TimeSpan.FromSeconds(bandata.expire - LogTime())), bandata.reason));
                else if (bandata.ip != string.Empty)
                    server.Broadcast(bandata.expire == 0.0 ? GetMsg("IPPermBan", null, bandata.reason) : GetMsg("IPTempBan", null, FormatTime(TimeSpan.FromSeconds(bandata.expire - LogTime())), bandata.reason));

            if (Ban_Log && (source is IPlayer) && ((IPlayer)source).Id != "server_console")
                Interface.Oxide.LogWarning(returnstring);

            if (kick)
                Kick(source, bandata.steamid != string.Empty ? bandata.steamid : bandata.ip, bandata.reason ?? "Banned", true);

            wasBanned.Add(bandata.id);
            if (Discord_use)
            {
                object payload = new[]
                {
                    new {name="Player",value=bandata.name.Length != 0 ? $"[{bandata.name}](https://steamcommunity.com/profiles/{bandata.steamid})" : bandata.steamid.Length != 0 ? $"[{bandata.steamid}](https://steamcommunity.com/profiles/{bandata.steamid})" : "An IP", inline=true},
                    new {name="Type",value=bandata.expire != 0.0 ? $"Temporarily ({FormatTime(TimeSpan.FromSeconds(bandata.expire - LogTime()))})" : "Permanently", inline=true},
                    new {name="Banned By", value=bandata.source, inline=true },
                    new {name="Reason",value=bandata.reason, inline=false}
                };
                string json = JsonConvert.SerializeObject(payload);
                DiscordMessages?.Call("API_SendFancyMessage", Discord_Webhook, "Player Ban", 3329330, json);
            }
            timer.Once(5f, () => { Subscribe(nameof(OnUserBanned)); });
            return returnstring;
        }

        ////////////////////////////////////////////////////////////
        // Unban
        ////////////////////////////////////////////////////////////

        string ExecuteUnban(object source, string steamid, string name, string ip)
        {
            string returnstring = string.Empty;
            List<BanData> unbanList = new List<BanData>();
            List<BanData> unbanList2 = new List<BanData>();

            if (BanSystemHasFlag(banSystem, BanSystem.PlayerDatabase))
            {
                returnstring += PlayerDatabase_ExecuteUnban(steamid, name, ip, out unbanList);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Files))
            {
                returnstring += Files_ExecuteUnban(steamid, name, ip, out unbanList2);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.MySQL))
            {
                returnstring += MySQL_ExecuteUnban(source, steamid, name, ip);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.SQLite))
            {
                returnstring += SQLite_ExecuteUnban(source, steamid, name, ip);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.WebAPI))
            {
                returnstring += WebAPI_ExecuteUnban(source, steamid, name, ip);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Native))
            {
                returnstring += Native_ExecuteUnban(steamid, name);
            }

            foreach (var b in unbanList)
            {
                if (cachedBans.ContainsKey(b.id))
                    cachedBans.Remove(b.id);
            }
            foreach (var b in unbanList2)
            {
                if (cachedBans.ContainsKey(b.id))
                    cachedBans.Remove(b.id);
            }
            OnServerSave();
            return returnstring;
        }

        string TryUnBan(object source, string[] args)
        {
            string ipaddress = isIPAddress(args[0]) ? args[0] : string.Empty;
            string steamid = string.Empty;
            ulong userID = 0L;
            string name = string.Empty;
            string errorreason = string.Empty;

            if (ipaddress != string.Empty)
            {
                return ExecuteUnban(source, string.Empty, string.Empty, ipaddress);
            }
            else
            {
                ulong.TryParse(args[0], out userID);
                return ExecuteUnban(source, userID != 0L ? args[0] : string.Empty, userID == 0L ? args[0] : string.Empty, string.Empty);
            }
        }


        ////////////////////////////////////////////////////////////
        // Commands
        ////////////////////////////////////////////////////////////
        [Command("ban", "player.ban")]
        void cmdBan(IPlayer player, string command, string[] args)
        {
            if (!hasPermission(player, PermissionBan))
            {
                player.Reply(GetMsg("NoPermission", player.Id.ToString()));
                return;
            }
            if (args == null || (args.Length < 1))
            {
                player.Reply(GetMsg("BanSyntax", player.Id.ToString()));
                return;
            }
            try
            {
                player.Reply(TryBan(player, args));
            }
            catch (Exception e)
            {
                player.Reply("ERROR:" + e.Message);
                Puts(e.StackTrace);
            }
        }

        [Command("banlist", "player.banlist")]
        void cmdBanlist(IPlayer player, string command, string[] args)
        {
            if (!hasPermission(player, PermissionBanlist))
            {
                player.Reply(GetMsg("NoPermission", player.Id.ToString()));
                return;
            }
            if (args == null || args.Length == 0)
            {
                string replystring = GetMsg("BanlistSyntax", player.Id.ToString()) + "\n";
                replystring += GetMsg("BanSystems", player.Id.ToString());
                if (BanSystemHasFlag(banSystem, BanSystem.Files))
                {
                    replystring += "Files\n";
                }
                if (BanSystemHasFlag(banSystem, BanSystem.MySQL))
                {
                    replystring += "MySQL\n";
                }
                if (BanSystemHasFlag(banSystem, BanSystem.Native))
                {
                    replystring += "Native\n";
                }
                if (BanSystemHasFlag(banSystem, BanSystem.PlayerDatabase))
                {
                    replystring += "PlayerDatabase\n";
                }
                if (BanSystemHasFlag(banSystem, BanSystem.SQLite))
                {
                    replystring += "SQLite\n";
                }
                if (BanSystemHasFlag(banSystem, BanSystem.WebAPI))
                {
                    replystring += "WebAPI\n";
                }
                player.Reply(replystring);
                return;
            }
            try
            {
                player.Reply(TryBanlist(player, args));
            }
            catch (Exception e)
            {
                player.Reply("ERROR:" + e.Message);
            }
        }

        [Command("kick", "player.kick")]
        void cmdKick(IPlayer player, string command, string[] args)
        {
            if (!hasPermission(player, PermissionKick))
            {
                player.Reply(GetMsg("NoPermission", player.Id.ToString()));
                return;
            }
            if (args == null || (args.Length < 1))
            {
                player.Reply(GetMsg("KickSyntax", player.Id.ToString()));
                return;
            }
            try
            {
                player.Reply(TryKick(player, args));
            }
            catch (Exception e)
            {
                player.Reply("ERROR:" + e.Message);
            }
        }

        [Command("unban", "player.unban")]
        void cmdUnban(IPlayer player, string command, string[] args)
        {
            if (!hasPermission(player, PermissionUnban))
            {
                player.Reply(GetMsg("NoPermission", player.Id.ToString()));
                return;
            }
            if (args == null || (args.Length < 1))
            {
                player.Reply(GetMsg("UnbanSyntax", player.Id.ToString()));
                return;
            }
            try
            {
                player.Reply(TryUnBan(player, args));
            }
            catch (Exception e)
            {
                player.Reply("ERROR:" + e.Message);
            }
        }
    }
}

// --- End of file: EnhancedBanSystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/CaptureZone.cs ---
// --- Original Local Path: BeeRust/CaptureZone.cs ---

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Newtonsoft.Json.Linq;
using Oxide.Core.Libraries.Covalence;
using Rust;

namespace Oxide.Plugins
{
    [Info("CaptureZone", "King", "1.0.0")]
    public class CaptureZone : RustPlugin
    {
        #region [Vars]
        [PluginReference] private Plugin ImageLibrary = null, Clans = null, MenuAlerts = null;
        private string[] _gatherHooks = {
            "OnDispenserGather",
            "OnDispenserBonus",
        };
        private static CaptureZone plugin;
        private Dictionary<String, DateTime> CooldownNotifyFarm = new Dictionary<String, DateTime>();
        private List<ulong> _CaptureCupboard = new List<ulong>();
        private List<ulong> _CaptureDropBox = new List<ulong>();
        private List<ulong> openUI = new List<ulong>();
        private Dictionary<string, int> _itemIds = new Dictionary<string, int>();
        #endregion

        #region [Data]
        public List<CaptureData> _CaptureList = new List<CaptureData>();
        public class CaptureData
        {
            public string captureName;

            public string nameClan;

            public int lastCapture;

            public ulong Cupboard;

            public ulong ResourseChest;

            public Vector3 capturePosition;
        }

		private void SaveCapture()
		{
			Interface.Oxide.DataFileSystem.WriteObject($"{Name}/CaptureList", _CaptureList);
		}

		private void LoadCapture()
		{
			try
			{
				_CaptureList = Interface.Oxide.DataFileSystem.ReadObject<List<CaptureData>>($"{Name}/CaptureList");
			}
			catch (Exception e)
			{
				PrintError(e.ToString());
			}

			if (_CaptureList == null) _CaptureList = new List<CaptureData>();
		}
        #endregion

        #region [Oxide]
        private void OnPluginLoaded(Plugin plugin)
        {
            NextTick(() =>
            {
                foreach (string hook in _gatherHooks)
                {
                    Unsubscribe(hook);
                    Subscribe(hook);
                }
            });
        }

		private void Init()
		{
			plugin = this;

			LoadCapture();
		}

        private void OnServerInitialized()
        {
            GetCaptureZone();

            cmd.AddChatCommand("capture", this, "ChatCommandCaptureZoneUI");
            cmd.AddChatCommand("newcapture", this, "NewSpawnCaptureZone");
            cmd.AddChatCommand("removecapture", this, "DeleteCaptureZone");
            ImageLibrary?.Call("AddImage", "https://i.imgur.com/rMC4ulM.png", "button_capture_zone");
        }

		private void Unload()
		{
			SaveCapture();

            foreach (var key in _CaptureList)
                RemoveCaptureZone(key.capturePosition);

            _CaptureManager.RemoveAll(x =>
            {
                UnityEngine.Object.Destroy(x);
                return true;
            });

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                    CuiHelper.DestroyUi(player, "CaptureUI");

			plugin = null;
		}

		private void OnNewSave(string filename)
		{
			_CaptureList.Clear();
			SaveCapture();
		}
        #endregion

        #region [Rust]
        private void OnDispenserGather(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            if(dispenser == null || player == null) return;

            var clan = GetClanTag(player.userID);
            if (string.IsNullOrEmpty(clan)) return;

            CaptureManager ActiveCaptureZone = FindCaptureZoneDistance(player.transform.position);
            if (ActiveCaptureZone == null || string.IsNullOrEmpty(ActiveCaptureZone._data.nameClan)) return;

            var memberList = GetClanMembers(ActiveCaptureZone._data.nameClan);
            if (memberList == null || memberList == new List<string>()) return;

            var entity = ActiveCaptureZone._entity;
            if (entity == null) return;
            var inventory = entity.GetComponent<StorageContainer>().inventory;
            if (inventory == null) return;

            var amount = Convert.ToInt32(item.amount * (config._ZoneSettings.CapturePrecent / 100f));
            if (amount <= 0) return;

            var itemToCreate = ItemManager.CreateByName(item.info.shortname, amount);
            if (itemToCreate.amount <= 0) return;

            itemToCreate.MoveToContainer(inventory);

			if (CooldownNotifyFarm.ContainsKey(ActiveCaptureZone._data.nameClan))
				if (CooldownNotifyFarm[ActiveCaptureZone._data.nameClan].Subtract(DateTime.Now).TotalSeconds >= 0) return;
            if (inventory.capacity == inventory.itemList.Count)
            {
                foreach (var key in memberList)
                {
                    var id = Convert.ToUInt64(key);
                    var memberClan = BasePlayer.FindByID(id);
                    if (memberClan == null || !memberClan.IsConnected) continue;

                    memberClan.ChatMessage($"Инвентарь территории {ActiveCaptureZone._data.captureName} переполен, залутайте его!");
                    CooldownNotifyFarm[ActiveCaptureZone._data.nameClan] = DateTime.Now.AddSeconds(5);
                }
            }
        }

		private void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item) =>
			OnDispenserGather(dispenser, player, item);

        private object OnEntityGroundMissing(BaseEntity entity)
        {
            if (entity.OwnerID == 9997)
                return false;

            return null;
        }

		private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
		{
			if(entity.OwnerID == 9997)
				return true;
			
			return null;
		}

        object CanLootEntity(BasePlayer player, DropBox DropBox)
        {
            if (player == null || DropBox == null || !_CaptureDropBox.Contains(DropBox.net.ID.Value)) return null;

            var clanName = GetClanTag(player.userID);
            if (string.IsNullOrEmpty(clanName)) return false;

            CaptureManager ActiveCaptureZone = FindCaptureZoneDropBox(DropBox.net.ID.Value);
            if (ActiveCaptureZone != null)
            {
                if (clanName != ActiveCaptureZone._data.nameClan)
                    return false;
            }
            return null;
        }

        object OnCupboardAuthorize(BuildingPrivlidge privilege, BasePlayer player)
        {
            if (privilege == null || player == null || !_CaptureCupboard.Contains(privilege.net.ID.Value)) return null;

            CaptureManager ActiveCaptureZone = FindCaptureZoneCupboard(privilege.net.ID.Value);
            if (ActiveCaptureZone != null)
            {
                var clan = GetClanTag(player.userID);
                if (string.IsNullOrEmpty(clan))
                {
                    player.ChatMessage("У вас нет клана.");
                    return false;
                }

                if (ActiveCaptureZone.CaptureClan == clan)
                {
                    player.ChatMessage("Ваш клан уже захватывает данную территорию!");
                    return false;
                }

                var CaptureOtherZone = FindCaptureOtherClan(clan);
                if (CaptureOtherZone != null)
                {
                    player.ChatMessage("Ваш клан уже захватывает другую территорию, дождитесь завершения захвата.");
                    return false;
                }

                ActiveCaptureZone.StartCapture(clan, player);
                return false;
            }

            return null;
        }

        private object CanBuild(Planner builder, Construction prefab, Construction.Target target)
        {
            var player = builder.GetOwnerPlayer();
            if (player == null) return null;

            CaptureManager ActiveCaptureZone = FindCaptureZoneDistance(player.transform.position);
            if (ActiveCaptureZone != null)
            {
                if (Vector3.Distance(player.transform.position, ActiveCaptureZone.transform.position) < config._ZoneSettings.RadiusBuild)
                {
                    player.ChatMessage("Нельзя строится так близко к захвату!");
                    return false;
                }
            }

            return null;
        }
        #endregion

        #region [Capture]
        private void GetCaptureZone()
        {
            /*if (_CaptureList.Count == 0)
            {
                var MapSize = TerrainMeta.Size / 2;

                Dictionary<Vector3, String> ListPosition = new Dictionary<Vector3, String>()
                {
                    [new Vector3(-MapSize.x, 0, MapSize.z)] = "A", // Левая верхняя
                    [new Vector3(MapSize.x / 9, 0, MapSize.z)] = "B", // Центральная верхняя
                    [new Vector3(MapSize.x, 0, MapSize.z)] = "C", // Правая верхняя

                    [new Vector3(-MapSize.x, 0, MapSize.z / 9)] = "D", // Левая Центральная
                    [new Vector3(MapSize.x / 9, 0, MapSize.z / 9)] = "E", // Центральная Центральная
                    [new Vector3(MapSize.x, 0, MapSize.z / 9)] = "F", // Правая Центральная

                    [new Vector3(-MapSize.x, 0, -MapSize.z)] = "G", // Левая Нижняя
                    [new Vector3(MapSize.x / 9, 0, -MapSize.z)] = "H", // Центральная Нижняя
                    [new Vector3(MapSize.x, 0, -MapSize.z)] = "L", // Правая Нижняя
                };

                foreach (var key in ListPosition)
                {
                    var center = key.Key / 2;
                    Vector3 lastPosition = center;

                    for (int i = 0; i < 300; i++)
                    {
                        lastPosition = RandomCircle(lastPosition);
                        if (ValidPosition(ref lastPosition))
                        {
                            GetNewData(lastPosition, key.Value);
                            break;
                        }
                    }
                }
            }
            else
            {*/
                foreach (var key in _CaptureList)
                {
                    SpawnCaptureZone(key.capturePosition);
                }
            //}
        }

        private void GetNewData(Vector3 position, String Name)
        {
            _CaptureList.Add(new CaptureData
            {
                captureName = Name,
                nameClan = string.Empty,
                lastCapture = 0,
                Cupboard = 0,
                ResourseChest = 0,
                capturePosition = position,
            });

            SpawnCaptureZone(position);
        }
        #endregion

        #region [Prefab]
		public class PrefabCaptureZone
		{
			public Vector3 Position;
			public string ShortPrefabName;
			public Vector3 Rotation;

			public PrefabCaptureZone(string shortname, Vector3 pos, Vector3 rot)
			{
				ShortPrefabName = shortname; Position = pos; Rotation = rot;
			}
		}

		public List<PrefabCaptureZone> _PrefabCaptureZone = new List<PrefabCaptureZone>
		{
            // Foundation
            new PrefabCaptureZone("assets/prefabs/building core/foundation/foundation.prefab", new Vector3(0, 0, 0), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/foundation/foundation.prefab", new Vector3(0, 0, 3), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/foundation/foundation.prefab", new Vector3(0, 0, -3), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/foundation/foundation.prefab", new Vector3(3, 0, 0), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/foundation/foundation.prefab", new Vector3(3, 0, 3), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/foundation/foundation.prefab", new Vector3(3, 0, -3), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/foundation/foundation.prefab", new Vector3(-3, 0, 0), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/foundation/foundation.prefab", new Vector3(-3, 0, 3), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/foundation/foundation.prefab", new Vector3(-3, 0, -3), new Vector3(0, 0, 0)),

            // CupboardPositionRoom
            new PrefabCaptureZone("assets/prefabs/building core/wall/wall.prefab", new Vector3(1.5f, 0, 0), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/wall/wall.prefab", new Vector3(0, 0, 1.5f), new Vector3(0, 270, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/wall/wall.prefab", new Vector3(0, 0, -1.5f), new Vector3(0, 270, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/wall.frame/wall.frame.prefab", new Vector3(-1.5f, 0, 0), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building/door.double.hinged/door.double.hinged.toptier.prefab", new Vector3(-1.5f, 0, 0), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/deployable/tool cupboard/cupboard.tool.deployed.prefab", new Vector3(1.1f, 0.1f, 0), new Vector3(0, 270, 0)),

            // Room
            new PrefabCaptureZone("assets/prefabs/building core/wall.frame/wall.frame.prefab", new Vector3(-4.5f, 0, 0), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building/wall.frame.cell/wall.frame.cell.prefab", new Vector3(-4.5f, 0, 0), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/wall.frame/wall.frame.prefab", new Vector3(-4.5f, 0, 3), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building/wall.frame.cell/wall.frame.cell.prefab", new Vector3(-4.5f, 0, 3), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/wall.frame/wall.frame.prefab", new Vector3(-4.5f, 0, -3), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building/wall.frame.cell/wall.frame.cell.prefab", new Vector3(-4.5f, 0, -3), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/wall.frame/wall.frame.prefab", new Vector3(4.5f, 0, 0), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building/wall.frame.cell/wall.frame.cell.prefab", new Vector3(4.5f, 0, 0), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/wall.frame/wall.frame.prefab", new Vector3(4.5f, 0, 3), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building/wall.frame.cell/wall.frame.cell.prefab", new Vector3(4.5f, 0, 3), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/wall.frame/wall.frame.prefab", new Vector3(4.5f, 0, -3), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building/wall.frame.cell/wall.frame.cell.prefab", new Vector3(4.5f, 0, -3), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/wall.frame/wall.frame.prefab", new Vector3(0, 0, -4.5f), new Vector3(0, 90, 0)),
            new PrefabCaptureZone("assets/prefabs/building/wall.frame.garagedoor/wall.frame.garagedoor.prefab", new Vector3(0, 0, -4.5f), new Vector3(0, 90, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/wall.frame/wall.frame.prefab", new Vector3(3, 0, -4.5f), new Vector3(0, 90, 0)),
            new PrefabCaptureZone("assets/prefabs/building/wall.frame.cell/wall.frame.cell.prefab", new Vector3(3, 0, -4.5f), new Vector3(0, 90, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/wall.frame/wall.frame.prefab", new Vector3(-3, 0, -4.5f), new Vector3(0, 90, 0)),
            new PrefabCaptureZone("assets/prefabs/building/wall.frame.cell/wall.frame.cell.prefab", new Vector3(-3, 0, -4.5f), new Vector3(0, 90, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/wall.frame/wall.frame.prefab", new Vector3(0, 0, 4.5f), new Vector3(0, 270, 0)),
            new PrefabCaptureZone("assets/prefabs/building/wall.frame.garagedoor/wall.frame.garagedoor.prefab", new Vector3(0, 0, 4.5f), new Vector3(0, 270, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/wall.frame/wall.frame.prefab", new Vector3(3, 0, 4.5f), new Vector3(0, 270, 0)),
            new PrefabCaptureZone("assets/prefabs/building/wall.frame.cell/wall.frame.cell.prefab", new Vector3(3, 0, 4.5f), new Vector3(0, 270, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/wall.frame/wall.frame.prefab", new Vector3(-3, 0, 4.5f), new Vector3(0, 270, 0)),
            new PrefabCaptureZone("assets/prefabs/building/wall.frame.cell/wall.frame.cell.prefab", new Vector3(-3, 0, 4.5f), new Vector3(0, 270, 0)),

            //Floor
            new PrefabCaptureZone("assets/prefabs/building core/floor/floor.prefab", new Vector3(0, 3, 0), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/floor/floor.prefab", new Vector3(3, 3, 0), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/floor/floor.prefab", new Vector3(3, 3, 3), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/floor/floor.prefab", new Vector3(3, 3, -3), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/floor/floor.prefab", new Vector3(-3, 3, 0), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/floor/floor.prefab", new Vector3(-3, 3, 3), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/floor/floor.prefab", new Vector3(-3, 3, -3), new Vector3(0, 0, 0)),

            //Rest
            new PrefabCaptureZone("assets/prefabs/deployable/signs/sign.pole.banner.large.prefab", new Vector3(0, 3, 0), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building/ladder.wall.wood/ladder.wooden.wall.prefab", new Vector3(-0.7f, 1.5f, 1.6f), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building/ladder.wall.wood/ladder.wooden.wall.prefab", new Vector3(0.7f, 1.5f, 1.6f), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building/ladder.wall.wood/ladder.wooden.wall.prefab", new Vector3(-0.7f, 1.5f, -1.6f), new Vector3(0, 180, 0)),
            new PrefabCaptureZone("assets/prefabs/building/ladder.wall.wood/ladder.wooden.wall.prefab", new Vector3(0.7f, 1.5f, -1.6f), new Vector3(0, 180, 0)),
            new PrefabCaptureZone("assets/prefabs/deployable/dropbox/dropbox.deployed.prefab", new Vector3(0.8f, 1.2f, 0), new Vector3(0, 90, 0)),
		};

		private void RemoveCaptureZone(Vector3 position)
		{
			List<BaseEntity> list_entity = new List<BaseEntity>();
			Vis.Entities(position, 25, list_entity);
			
			list_entity = list_entity.Distinct().ToList();
			list_entity = list_entity.Where(x => !(x is BasePlayer) && !(x is PlayerCorpse) && !(x is DroppedItemContainer) && !(x is DroppedItem)).ToList();
			
			foreach(BaseEntity entity in list_entity)
				if(entity != null && !entity.IsDestroyed)
					entity.Kill();
		}

		private void SpawnCaptureZone(Vector3 position)
		{
            RemoveCaptureZone(position);

            var find = _CaptureList.FirstOrDefault(p => p.capturePosition == position);
            if (find == null) return;

			foreach(var key in _PrefabCaptureZone)
			{
				BaseEntity prefab = GameManager.server.CreateEntity(key.ShortPrefabName, position + key.Position, Quaternion.Euler(key.Rotation)) as BaseEntity;
				
				prefab.OwnerID = 9997;
				prefab.Spawn();
				
				if (prefab is BuildingBlock)
				{
					BuildingBlock block = prefab as BuildingBlock;
					
					block.grade = BuildingGrade.Enum.TopTier;
					block.SetHealthToMax();
				}

                if (prefab is BuildingPrivlidge)
                {
                    BuildingPrivlidge build = prefab as BuildingPrivlidge;

                    _CaptureCupboard.Add(build.net.ID.Value);
                    find.Cupboard = build.net.ID.Value;
                }

                if (prefab is DropBox)
                {
                    DropBox dropbox = prefab as DropBox;
                    dropbox.inventory.SetFlag(ItemContainer.Flag.NoItemInput, true);
                    dropbox.inventory.capacity = 40;

                    _CaptureDropBox.Add(dropbox.net.ID.Value);
                    find.ResourseChest = dropbox.net.ID.Value;
                    var obj = new GameObject();
                    obj.transform.position = dropbox.transform.position;
                    var component = obj.AddComponent<CaptureManager>();
                    component.GetComponent<CaptureManager>().Init(find, dropbox);
                    _CaptureManager.Add(component);
                }

                if (prefab is Door)
                {
                    Door door = prefab as Door;

                    door.pickup.enabled = false;
                    door.canTakeLock = false;
                    door.canTakeCloser = false;
                    door.SendNetworkUpdateImmediate();
                }

                if (prefab is BaseLadder)
                {
                    BaseLadder ladder = prefab as BaseLadder;

                    ladder.pickup.enabled = false;
                }
			}
		}
        #endregion

        #region [UI]
        private void ChatCommandCaptureZoneUI(BasePlayer player) => CaptureZoneUI(player, 0);

        private void CaptureZoneUI(BasePlayer player, int page)
        {
            var container = new CuiElementContainer();
            string Layer = "CaptureZone_UI";
            string colored = "0 0 0 0.5";

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Material = "assets/content/ui/uibackgroundblur.mat", Color = "0 0 0 0.77" }
            }, "Overlay", Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Color = "0.36 0.33 0.28 0.3", Material = "assets/icons/greyout.mat", Close = Layer }
            }, Layer);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-493 -293", OffsetMax = "497.5 293" },
                Image = { Color = "0.3773585 0.3755785 0.3755785 0.3407843", Material = "assets/icons/greyout.mat" }
            }, Layer, Layer + ".Main");

            container.Add(new CuiElement
            {
                Parent = Layer + ".Main",
                Components =
                {
                    new CuiTextComponent { Text = $"Список территорий", Color = "1 1 1 0.85", Align = TextAnchor.MiddleCenter, FontSize = 20, Font = "robotocondensed-bold.ttf" },
                    new CuiRectTransformComponent { AnchorMin = "0 0.915", AnchorMax = $"1 1" },
                }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.00325 0.01", AnchorMax = $"0.035 0.067" },
                Button = { Color = "0.46 0.44 0.42 0.85", Material = "assets/icons/greyout.mat", Command = page >= 1 ? $"UI_CAPTURE ChangePageCapture {page - 1}" : "" },
                Text = { Text = $"-", Color = "1 1 1 0.85", Align = TextAnchor.MiddleCenter, FontSize = 18, Font = "robotocondensed-bold.ttf" }
            }, Layer + ".Main");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.0395 0.01", AnchorMax = $"0.07125 0.067" },
                Image = { Color = "0.2 0.2 0.2 0.65", Material = "assets/icons/greyout.mat" }
            }, Layer + ".Main", Layer + ".Main" + ".pText");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" },
                Text = { Text = $"{page + 1}", Color = "1 1 1 0.85", Font = "robotocondensed-regular.ttf", FontSize = 16, Align = TextAnchor.MiddleCenter }
            }, Layer + ".Main" + ".pText");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.07575 0.01", AnchorMax = $"0.1075 0.067" },
                Button = { Color = "0.46 0.44 0.42 0.65", Material = "assets/icons/greyout.mat", Command = _CaptureManager.Skip(9 * (page + 1)).Count() > 0 ? $"UI_CAPTURE ChangePageCapture {page + 1}" : "" },
                Text = { Text = $"+", Color = "1 1 1 0.85", Align = TextAnchor.MiddleCenter, FontSize = 18, Font = "robotocondensed-bold.ttf" }
            }, Layer + ".Main");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.890915 0.01", AnchorMax = $"0.99379 0.067", OffsetMax = "0 0" },
                Button = { Color = "0.46 0.44 0.42 0.85", Material = "assets/icons/greyout.mat", Close = Layer },
                Text = { Text = $"ЗАКРЫТЬ", Color = "1 1 1 0.85", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf" }
            }, Layer + ".Main");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.86", AnchorMax = "0.999 0.92" },
                Image = { Color = "1 1 1 0" }
            }, Layer + ".Main", Layer + ".Main" + ".Text");

            container.Add(new CuiLabel
            {
                Text = { Text = $"НАЗВАНИЕ ТЕРРИТОРИИ", Color = "1 1 1 1", FontSize = 14, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.025 0", AnchorMax = $"1 1" },
            }, Layer + ".Main" + ".Text");

            container.Add(new CuiLabel
            {
                Text = { Text = $"ВЛАДЕЛЕЦ ТЕРРИТОРИИ", Color = "1 1 1 1", FontSize = 14, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.23 0", AnchorMax = $"1 1" },
            }, Layer + ".Main" + ".Text");

            container.Add(new CuiLabel
            {
                Text = { Text = $"СОСТОЯНИЕ ТЕРРИТОРИИ", Color = "1 1 1 1", FontSize = 14, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.42 0", AnchorMax = $"1 1" },
            }, Layer + ".Main" + ".Text");

            container.Add(new CuiLabel
            {
                Text = { Text = $"СОБРАТЬ РЕСУРСЫ", Color = "1 1 1 1", FontSize = 14, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.85 0", AnchorMax = $"1 1" },
            }, Layer + ".Main" + ".Text");

            for (int y = 0; y < 9; y++)
            {
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"0.0055 {0.775 - y * 0.085}", AnchorMax = $"0.989 {0.85 - y * 0.085}" },
                    Image = { Color = colored }
                }, Layer + ".Main", Layer + ".Main" + $".TopLine{y}");
            }

            int i = 0;
            foreach (var key in _CaptureManager.Skip(page * 9).Take(9))
            {
                string nameClan = key._data.nameClan;
                if (string.IsNullOrEmpty(key._data.nameClan))
                    nameClan = "Никто";
                bool isTime = Facepunch.Math.Epoch.Current - key._data.lastCapture < config._ZoneSettings.CaptureCooldown;
                string State = key._IsCapture == true ? "Идет захват" : isTime == true ? $"{GetFormatTime(TimeSpan.FromSeconds(key._data.lastCapture + config._ZoneSettings.CaptureCooldown - Facepunch.Math.Epoch.Current))}" : "Можно захватить";

                container.Add(new CuiLabel
                {
                    Text = { Text = $"{key._data.captureName}", Color = "1 1 1 1", FontSize = 14, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                    RectTransform = { AnchorMin = $"0.027 0", AnchorMax = $"1 1" },
                }, Layer + ".Main" + $".TopLine{i}");

                container.Add(new CuiLabel
                {
                    Text = { Text = $"{nameClan}", Color = "1 1 1 1", FontSize = 14, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                    RectTransform = { AnchorMin = $"0.234 0", AnchorMax = $"1 1" },
                }, Layer + ".Main" + $".TopLine{i}");

                container.Add(new CuiLabel
                {
                    Text = { Text = $"{State}", Color = "1 1 1 1", FontSize = 14, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                    RectTransform = { AnchorMin = $"0.424 0", AnchorMax = $"1 1" },
                }, Layer + ".Main" + $".TopLine{i}");

                container.Add(new CuiLabel
                {
                    Text = { Text = $"Открыть", Color = "1 1 1 1", FontSize = 14, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0.85 0", AnchorMax = $"0.985 0.98" },
                }, Layer + ".Main" + $".TopLine{i}");

                container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = $"UI_CAPTURE OpenInventory {key._data.ResourseChest}" },
                    RectTransform = { AnchorMin = $"0.85 0", AnchorMax = $"0.985 0.98" },
                }, Layer + ".Main" + $".TopLine{i}");

                i++;
            }

            CuiHelper.DestroyUi(player, Layer);
            CuiHelper.AddUi(player, container);
        }

        private void CaptureZoneUI_Inventory(BasePlayer player, StorageContainer containers, CaptureManager Capture)
        {
            var container = new CuiElementContainer();
            var Items = containers.inventory.itemList.Count;
            string Layer = "CaptureZone_UI";
            string colored = "0 0 0 0.5";

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Material = "assets/content/ui/uibackgroundblur.mat", Color = "0 0 0 0.77" }
            }, "Overlay", Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Color = "0.36 0.33 0.28 0.3", Material = "assets/icons/greyout.mat", Close = Layer }
            }, Layer);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-493 -293", OffsetMax = "497.5 293" },
                Image = { Color = "0.3773585 0.3755785 0.3755785 0.3407843", Material = "assets/icons/greyout.mat" }
            }, Layer, Layer + ".Main");

            container.Add(new CuiElement
            {
                Parent = Layer + ".Main",
                Components =
                {
                    new CuiTextComponent { Text = $"Ивентарь ящика территории {Capture._data.captureName}", Color = "1 1 1 0.85", Align = TextAnchor.MiddleCenter, FontSize = 20, Font = "robotocondensed-bold.ttf" },
                    new CuiRectTransformComponent { AnchorMin = "0 0.915", AnchorMax = $"1 1" },
                }
            });

            if (Items == 0)
            {
                container.Add(new CuiElement
                {
                    Parent = Layer + ".Main",
                    Components =
                    {
                        new CuiTextComponent { Text = $"Инвентарь к сожалению пуст :(", Color = "1 1 1 0.85", Align = TextAnchor.MiddleCenter, FontSize = 32, Font = "robotocondensed-bold.ttf" },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = $"1 1" },
                    }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0.890915 0.01", AnchorMax = $"0.99379 0.067", OffsetMax = "0 0" },
                    Button = { Color = "0.46 0.44 0.42 0.85", Material = "assets/icons/greyout.mat", Close = Layer },
                    Text = { Text = $"ЗАКРЫТЬ", Color = "1 1 1 0.85", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf" }
                }, Layer + ".Main");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0.77804 0.01", AnchorMax = $"0.880915 0.067", OffsetMax = "0 0" },
                    Button = { Color = "0.46 0.44 0.42 0.85", Material = "assets/icons/greyout.mat", Command = "UI_CAPTURE ReturnToMenu" },
                    Text = { Text = $"НАЗАД", Color = "1 1 1 0.85", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf" }
                }, Layer + ".Main");

                CuiHelper.DestroyUi(player, Layer);
                CuiHelper.AddUi(player, container);
                return;
            }

            for (int i = 0, y = 0, x = 0; i < 40; i++)
            {
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"{0.01 + (x * 0.123)} {0.76 - (y * 0.17)}", AnchorMax = $"{0.117 + (x * 0.123)} {0.92 - (y * 0.17)}" },
                    Image = { Color = colored }
                }, Layer + ".Main", Layer + ".Main" + $"Item{i}");

                if (Items - 1 >= i)
                {
                    var Item = containers.inventory.itemList.ElementAt(i);
                    
                    container.Add(new CuiElement
                    {
                        Parent = Layer + ".Main" + $"Item{i}",
                        Components =
                        {
                            new CuiImageComponent { ItemId = FindItemID(Item.info.shortname), SkinId = 0 },
                            new CuiRectTransformComponent { AnchorMin = "0.1 0.1", AnchorMax = "0.9 0.9" }
                        }
                    });

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0 0 ", AnchorMax = "1 1", OffsetMax = "-5 0", OffsetMin = "5 2" },
                        Button = { Color = "0 0 0 0", Command = $"UI_CAPTURE TakeItemInventory {Capture._data.ResourseChest} {Item.info.shortname}" },
                        Text = { Text = $"{Item.amount}" + "шт", Align = TextAnchor.LowerCenter, Font = "robotocondensed-regular.ttf", FontSize = 12 }
                    }, Layer + ".Main" + $"Item{i}");
                }

                x++;
                if (x == 8)
                {
                    x = 0;
                    y++;
                }
            }

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.77804 0.01", AnchorMax = $"0.880915 0.067", OffsetMax = "0 0" },
                Button = { Color = "0.46 0.44 0.42 0.85", Material = "assets/icons/greyout.mat", Command = "UI_CAPTURE ReturnToMenu" },
                Text = { Text = $"НАЗАД", Color = "1 1 1 0.85", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf" }
            }, Layer + ".Main");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.890915 0.01", AnchorMax = $"0.99379 0.067", OffsetMax = "0 0" },
                Button = { Color = "0.46 0.44 0.42 0.85", Material = "assets/icons/greyout.mat", Close = Layer },
                Text = { Text = $"ЗАКРЫТЬ", Color = "1 1 1 0.85", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf" }
            }, Layer + ".Main");

            CuiHelper.DestroyUi(player, Layer);
            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region [ConsoleCommand]
        [ConsoleCommand("UI_CAPTURE")]
        private void CaptureUIHandler(ConsoleSystem.Arg args)
        {
			BasePlayer player = args?.Player();
			if (player == null || !args.HasArgs()) return;

            var clan = GetClanTag(player.userID);
            if (clan == null) return;

            switch (args.Args[0])
            {
                case "OpenInventory":
                {
                    var find = FindCaptureZoneDropBox(ulong.Parse(args.Args[1]));
                    if (find == null) return;

                    if (string.IsNullOrEmpty(clan))
                    {
                        player.ChatMessage("У вас нет клана.");
                        return;
                    }

                    if (find._data.nameClan != clan)
                    {
                        player.ChatMessage("Данная территория находится не под вашем контролем.");
                        return;
                    }

                    StorageContainer container;
                    container = find._entity.GetComponent<StorageContainer>();
                    container.inventory.MarkDirty();
                    container.UpdateNetworkGroup();
                    CaptureZoneUI_Inventory(player, container, find);
                    break;
                }
                case "TakeItemInventory":
                {
                    var find = FindCaptureZoneDropBox(ulong.Parse(args.Args[1]));
                    if (find == null || find._data.nameClan != clan) return;

                    StorageContainer container;
                    container = find._entity.GetComponent<StorageContainer>();

                    var findItem = container.inventory.itemList.FirstOrDefault(p => p.info.shortname == args.Args[2]);
                    if (findItem == null) return;

                    var item = ItemManager.CreateByName(findItem.info.shortname, findItem.amount, findItem.skin);
                    item.name = findItem.name;
                    item.MarkDirty();
                    player.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);
                    findItem.RemoveFromContainer();
                    CaptureZoneUI_Inventory(player, container, find);
                    break;
                }
                case "ReturnToMenu":
                {
                    CaptureZoneUI(player, 0);
                    break;
                }
                case "ChangePageCapture":
                {
                    CaptureZoneUI(player, int.Parse(args.Args[1]));
                    break;
                }
            }
        }
        #endregion

        #region [Component]
        private CaptureManager FindCaptureZoneDistance(Vector3 pos) =>
             _CaptureManager.Where(p => Vector3.Distance(p.transform.position, pos) < config._ZoneSettings.RadiusZone).FirstOrDefault();

        private CaptureManager FindCaptureZoneCupboard(ulong netID) => 
             _CaptureManager.FirstOrDefault(p => p._data.Cupboard == netID);

        private CaptureManager FindCaptureZoneDropBox(ulong netID) => 
             _CaptureManager.FirstOrDefault(p => p._data.ResourseChest == netID);

        private CaptureManager FindCaptureOtherClan(string nameClan) => 
             _CaptureManager.FirstOrDefault(p => p.CaptureClan == nameClan);

        private static List<CaptureManager> _CaptureManager = new List<CaptureManager>();

        public class CaptureManager : MonoBehaviour
        {
            private List<BasePlayer> _Players;
            private MapMarkerGenericRadius mapMarker;
            private VendingMachineMapMarker vendingMarker;
            private SphereCollider sphereCollider;

            public CaptureData _data;
            public BaseEntity _entity;
            public bool _IsCapture = false;
            public int CaptureTime = 0;
            public string CaptureClan = string.Empty;

            private void Awake()
            {
                sphereCollider = gameObject.AddComponent<SphereCollider>();
                sphereCollider.gameObject.layer = (int)Rust.Layer.Reserved1;
                sphereCollider.isTrigger = true;
                sphereCollider.radius = config._ZoneSettings.RadiusZone;
                InvokeRepeating("Timer", 1f, 1f);
            }

            private void OnTriggerEnter(Collider other)
            {
                var target = other.GetComponentInParent<BasePlayer>();
                if (target == null || _Players.Contains(target)) return;
                var Text = _data.nameClan == string.Empty ? "Данная территория не захвачена, успей захватить" : $"Вы зашли в территорию {_data.captureName}.\nПод владением клана: {_data.nameClan}";
                target.ChatMessage($"{Text}");
                _Players.Remove(target);
            }

            private void OnTriggerExit(Collider other)
            {
                var target = other.GetComponentInParent<BasePlayer>();
                if (target == null && !_Players.Contains(target)) return;
                var Text = _data.nameClan == string.Empty ? "Вы вышли из территории которая не захвачена, успей захватить" : $"Вы вышли из территории {_data.captureName}.\nПод владением клана: {_data.nameClan}";
                target.ChatMessage($"{Text}");
                _Players.Remove(target);
            }

            public void Init(CaptureData data, BaseEntity entity)
            {
                _data = data;
                _entity = entity; 
                _Players = new List<BasePlayer>();

                if (Facepunch.Math.Epoch.Current - _data.lastCapture < config._ZoneSettings.CaptureCooldown)
                    AddMarker(config._MarkerInGameSettings.markerColorCantCapture);
                else
                    AddMarker(config._MarkerInGameSettings.markerColorCanCapture);
            }

            private void Timer()
            {
                if (_IsCapture)
                {
                    bool HavePlayerCapture = false;

                    var _clanList = plugin.GetClanMembers(CaptureClan);
                    if (_clanList == null || _clanList == new List<string>())
                    {
                        CaptureClan = string.Empty;
                        _IsCapture = false;
                        CaptureTime = 0;
                        return;
                    }

                    foreach (var key in _clanList)
                    {
                        var id = Convert.ToUInt64(key);
                        var memberClan = BasePlayer.FindByID(id);
                        if (memberClan == null || !memberClan.IsConnected) continue;

                        if (Vector3.Distance(memberClan.transform.position, transform.position) < config._ZoneSettings.RadiusCapture)
                        {
                            HavePlayerCapture = true;
                            break;
                        }
                    }

                    if (!HavePlayerCapture)
                    {
                        CaptureClan = string.Empty;
                        _IsCapture = false;
                        CaptureTime = 0;

                        foreach (var key in _clanList)
                        {
                            var id = Convert.ToUInt64(key);
                            var memberClan = BasePlayer.FindByID(id);
                            if (memberClan == null || !memberClan.IsConnected) continue;

                            if (config.useMenuAlerts)
                            {
                                plugin.MenuAlerts?.Call("RemoveAlertMenu", memberClan, $"{plugin.Name}");
                            }
                            else
                            {
                                CuiHelper.DestroyUi(memberClan, "CaptureUI");
                                if (plugin.openUI.Contains(memberClan.userID))
                                    plugin.openUI.Remove(memberClan.userID);
                            }
                            memberClan.ChatMessage("Ваш клан ушел слишком далеко. Ваш захват сбит, начните захват заново!");
                        }
                        
                        AddMarker(config._MarkerInGameSettings.markerColorCanCapture);
                    }

                    CaptureTime++;
                    if (CaptureTime >= config._ZoneSettings.CaputureSecond)
                    {
                        FinishCapture();
                    }
                    else
                    {
                        if (!config.useMenuAlerts)
                        {
                            foreach (var key in _clanList)
                            {
                                var id = Convert.ToUInt64(key);
                                var memberClan = BasePlayer.FindByID(id);
                                if (memberClan == null || !memberClan.IsConnected) continue;

                                if (plugin.openUI.Contains(memberClan.userID))
                                    plugin.CaptureZoneInfoUpdate(memberClan, this);
                            }
                        }
                    }
                }

                if (Facepunch.Math.Epoch.Current - _data.lastCapture == config._ZoneSettings.CaptureCooldown && !_IsCapture)
                {
                    plugin.Server.Broadcast($"<color=#ffde5a>ВНИМАНИЕ!</color>\n<size=12>Территорию <color=#ffde5a>{_data.captureName}</color> можно снова захватить!");
                    mapMarker.color1 = ConvertToColor(config._MarkerInGameSettings.markerColorCanCapture);
                }

                mapMarker.SendUpdate();
            }

            public void StartCapture(String tag, BasePlayer player)
            {
                if (tag == CaptureClan)
                {
                    player.ChatMessage("Ваш клан уже захватывает эту территорию!");
                    return;
                }

                if (Facepunch.Math.Epoch.Current - _data.lastCapture < config._ZoneSettings.CaptureCooldown)
                {
                    var time = TimeSpan.FromSeconds(_data.lastCapture + config._ZoneSettings.CaptureCooldown - Facepunch.Math.Epoch.Current);
                    player.ChatMessage($"Данная территория еще находится на откате. Подождите {time.Hours}час, {time.Minutes}мин, {time.Seconds}сек.");
                    return;
                }

                if (_IsCapture)
                {
                    var _clanList = plugin.GetClanMembers(CaptureClan);
                    if (_clanList == null || _clanList == new List<string>()) return;

                    foreach (var key in _clanList)
                    {
                        var id = Convert.ToUInt64(key);
                        var memberClan = BasePlayer.FindByID(id);
                        if (memberClan == null || !memberClan.IsConnected) continue;

                        memberClan.ChatMessage($"Ваш захват перехватил клан: {tag}");
                        if (config.useMenuAlerts)
                        {
                            plugin.MenuAlerts?.Call("RemoveAlertMenu", memberClan, $"{plugin.Name}");
                        }
                        else
                        {
                                if (plugin.openUI.Contains(memberClan.userID))
                                    plugin.openUI.Remove(memberClan.userID);
                                CuiHelper.DestroyUi(memberClan, "CaptureUI");
                        }
                    }
                }
                else
                {
                    plugin.Server.Broadcast($"<color=#ffde5a>ВНИМАНИЕ!</color>\n<size=12>Начался захват территории <color=#ffde5a>{_data.captureName}</color>.\nЗахватывается кланом <color=#ffde5a>{tag}</color>");
                    mapMarker.color1 = ConvertToColor(config._MarkerInGameSettings.markerColorCapture);
                    vendingMarker.markerShopName = $"Территория {_data.captureName}\nИдет захват кланом: {tag}";
                    vendingMarker.SendNetworkUpdate();
                }

                var clanList = plugin.GetClanMembers(tag);
                if (clanList == null || clanList == new List<string>()) return;

                foreach (var key in clanList)
                {
                    var id = Convert.ToUInt64(key);
                    var memberClan = BasePlayer.FindByID(id);
                    if (memberClan == null || !memberClan.IsConnected) continue;

                    if (config.useMenuAlerts)
                    {
                        plugin.MenuAlerts?.Call("SendAlertMenu", memberClan, Facepunch.Math.Epoch.Current,(int)config._ZoneSettings.CaputureSecond, $"CAPTURE ZONE", $"Вы начали захват территории: (<color=#ffde5a>{_data.captureName}</color>). По окончании времени вы получите (<color=#ffde5a>{config._ZoneSettings.HowGivePoint}</color>) клановых очков. Не отходите от захвата на (<color=#ffde5a>{config._ZoneSettings.RadiusCapture}</color>) м.", true, "button_capture_zone", $"{plugin.Name}");
                    }
                    else
                    {
                        plugin.CaptureZoneMain(memberClan, this);
                    }
                }

                CaptureClan = tag;
                CaptureTime = 0;
                _IsCapture = true;
            }

            private void FinishCapture()
            {
                CaptureTime = 0;
                _IsCapture = false;

                var _clanList = plugin.GetClanMembers(CaptureClan);
                if (_clanList == null || _clanList == new List<string>())
                {
                    CaptureClan = string.Empty;
                    mapMarker.color1 = ConvertToColor(config._MarkerInGameSettings.markerColorCanCapture);
                    return;
                }

                foreach (var key in _clanList)
                {
                    var id = Convert.ToUInt64(key);
                    var memberClan = BasePlayer.FindByID(id);
                    if (memberClan == null || !memberClan.IsConnected) continue;

                    if (plugin.openUI.Contains(memberClan.userID))
                        plugin.openUI.Remove(memberClan.userID);
                    CuiHelper.DestroyUi(memberClan, "CaptureUI");
                    memberClan.ChatMessage($"Ваш клан успешно захватил территорию {_data.captureName}");
                }

                plugin.Clans?.Call("GiveClanPoints", CaptureClan, config._ZoneSettings.HowGivePoint);
                _data.nameClan = CaptureClan;
                vendingMarker.markerShopName = $"Территория: {_data.captureName}\nКлан: {_data.nameClan}";
                vendingMarker.SendNetworkUpdate();
                _data.lastCapture = Facepunch.Math.Epoch.Current;
                CaptureClan = string.Empty;
                mapMarker.color1 = ConvertToColor(config._MarkerInGameSettings.markerColorCantCapture);
                plugin.Server.Broadcast($"<color=#ffde5a>ВНИМАНИЕ!</color>\n<size=12>Клан <color=#ffde5a>{_data.nameClan}</color> захватил территорию <color=#ffde5a>{_data.captureName}</color>.");
            }

            private void RemoveMarker()
            {
                if (mapMarker != null && !mapMarker.IsDestroyed) 
                    mapMarker.Kill();
                if (vendingMarker != null && !vendingMarker.IsDestroyed) 
                    vendingMarker.Kill();
            }

            private void AddMarker(string color)
            {
                RemoveMarker();

                string nameClan = _data.nameClan;
                if (string.IsNullOrEmpty(_data.nameClan))
                    nameClan = "Никто";

                mapMarker = GameManager.server.CreateEntity("assets/prefabs/tools/map/genericradiusmarker.prefab", transform.position).GetComponent<MapMarkerGenericRadius>();
                vendingMarker = GameManager.server.CreateEntity("assets/prefabs/deployable/vendingmachine/vending_mapmarker.prefab", transform.position).GetComponent<VendingMachineMapMarker>();

                mapMarker.radius = config._MarkerInGameSettings.markerRadius;
                mapMarker.color1 = ConvertToColor(color);
                mapMarker.alpha = config._MarkerInGameSettings.markerAlpha;
                mapMarker.enabled = true;
                mapMarker.OwnerID = 0;
                mapMarker.Spawn();
                mapMarker.SendUpdate();

                vendingMarker.markerShopName = $"Территория: {_data.captureName}\nКлан: {nameClan}";
                vendingMarker.OwnerID = 0;
                vendingMarker.Spawn();
                vendingMarker.enabled = false;
            }

            public void DestroyComp() => OnDestroy();
            private void OnDestroy()
            {
                RemoveMarker();
                Destroy(this);
            }

            private Color ConvertToColor(string color)
            {
                if (color.StartsWith("#")) color = color.Substring(1);
                int red = int.Parse(color.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                int green = int.Parse(color.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                int blue = int.Parse(color.Substring(4, 2), NumberStyles.AllowHexSpecifier);
                return new Color((float)red / 255, (float)green / 255, (float)blue / 255);
            }
        }
        #endregion

        #region [GUI]
        [ConsoleCommand("OpenPanelCapture")]
        private void cmdOpenCaptureZone(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (player == null || !args.HasArgs() || openUI.Contains(player.userID)) return;

            CaptureManager Component = FindCaptureZoneCupboard(ulong.Parse(args.Args[0]));
            if (Component == null) return;

            CaptureZoneInfo(player, Component);
            CaptureZoneInfoUpdate(player, Component);
            openUI.Add(player.userID);
        }

        [ConsoleCommand("ClosePanelCapture")]
        private void cmdCloseCaptureZone(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (player == null || !openUI.Contains(player.userID)) return;

            CuiHelper.DestroyUi(player, "CaptureUI" + ".Info");
            openUI.Remove(player.userID);
        }

        public void CaptureZoneMain(BasePlayer player, CaptureManager Component)
        {
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "-42.5 2", OffsetMax = "-2 40.5" },
                Image = { Color = "0.5 0.5 0.5 0.25", Material = "assets/icons/greyout.mat" }
            }, "Overlay", "CaptureUI");

            container.Add(new CuiElement
            {
                Parent = "CaptureUI",
                Components =
                {
                    new CuiRawImageComponent { Png = (string)ImageLibrary?.Call("GetImage", "button_capture_zone") },
                    new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "4 4", OffsetMax = "-4 -4"},
                    new CuiOutlineComponent{Color = "0 0 0 1", Distance = "0.15 0.15"}
                }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = {  Color = "0 0 0 0", Command = $"OpenPanelCapture {Component._data.Cupboard}" },
                Text = { Text = "" }
            }, "CaptureUI");

            CuiHelper.DestroyUi(player, "CaptureUI");
            CuiHelper.AddUi(player, container);
        }

        public void CaptureZoneInfo(BasePlayer player, CaptureManager Component)
        {
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-223.521 -19.5", OffsetMax = "-24.017 19.5" },
                Image = { Color = "0.5 0.5 0.5 0.25", Material = "assets/icons/greyout.mat" }
            }, "CaptureUI", "CaptureUI" + ".Info");

            container.Add(new CuiElement()
            {
                Parent = "CaptureUI" + ".Info",
                Components =
                {
                    new CuiTextComponent{Color = "1 1 1 1",Text = $"Происходит захват территории {Component._data.captureName}", Align = TextAnchor.MiddleLeft, FontSize = 11, Font = "robotocondensed-regular.ttf"},
                    new CuiRectTransformComponent{AnchorMin = "0.02 0", AnchorMax = "0.925 0.8"},
                    new CuiOutlineComponent {Color = "0 0 0 1", Distance = "0.4 0.4"},
                }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.925 0.625", AnchorMax = "0.995 0.97"},
                Button = { Command = $"ClosePanelCapture", Color = "0.9 0 0 0.65", Material = "assets/icons/greyout.mat" },
                Text = { Text = "✘", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, FontSize = 12, Font = "robotocondensed-bold.ttf" }
            }, "CaptureUI" + ".Info");

            CuiHelper.DestroyUi(player, "CaptureUI" + ".Info");
            CuiHelper.AddUi(player, container);
        }

        public void CaptureZoneInfoUpdate(BasePlayer player, CaptureManager Component)
        {
            var container = new CuiElementContainer();

            container.Add(new CuiElement()
            {
                Parent = "CaptureUI" + ".Info",
                Name = "CaptureUI" + ".Info" + ".TextUpdate",
                Components =
                {
                    new CuiTextComponent{Color = "1 1 1 1", Text = $"CAPTURE ZONE: ({GetFormatTime(TimeSpan.FromSeconds(config._ZoneSettings.CaputureSecond - Component.CaptureTime))})", Align = TextAnchor.UpperLeft, FontSize = 14, Font = "robotocondensed-bold.ttf"},
                    new CuiRectTransformComponent{AnchorMin = "0.02 0", AnchorMax = "0.925 0.96"},
                    new CuiOutlineComponent {Color = "0 0 0 1", Distance = "0.4 0.4"},
                }
            });

            CuiHelper.DestroyUi(player, "CaptureUI" + ".Info" + ".TextUpdate");
            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region [Position]
        static float GetGroundPosition(Vector3 pos)
        {
            float y = TerrainMeta.HeightMap.GetHeight(pos);
            RaycastHit hit;
            if (Physics.Raycast(new Vector3(pos.x, pos.y + 200f, pos.z), Vector3.down, out hit, Mathf.Infinity, LayerMask.GetMask(new[] {
                "Terrain", "World", "Default", "Construction", "Deployed"
            }
            )) && !hit.collider.name.Contains("rock_cliff")) return Mathf.Max(hit.point.y, y);
            return y;
        }

        private bool ValidPosition(ref Vector3 randomPos)
        {
            RaycastHit hitInfo;
            if (Physics.Raycast(randomPos, Vector3.down, out hitInfo, 500f, Layers.Solid)) randomPos.y = hitInfo.point.y;
            else return false;
            if (WaterLevel.Test(randomPos, false, false)) return false;
            var colliders = new List<Collider>();
            Vis.Colliders(randomPos, 15f, colliders);
            if (colliders.Where(col => col.name.ToLower().Contains("prevent") && col.name.ToLower().Contains("building")).Count() > 0) return false;
            var entities = new List<BaseEntity>();
            Vis.Entities(randomPos, 15f, entities);
            if (entities.Where(ent => ent is BaseVehicle || ent is CargoShip || ent is BaseHelicopter || ent is BradleyAPC || ent is TreeEntity || ent is OreResourceEntity).Count() > 0) return false;
            var cupboards = new List<BuildingPrivlidge>();
            Vis.Entities(randomPos, 20f + 10f, cupboards);
            if (cupboards.Count > 0) return false;
            return true;
        }

        Vector3 RandomCircle(Vector3 center)
        {
            float ang = UnityEngine.Random.value * 360;
            Vector3 pos;
            pos.x = center.x + 25f * Mathf.Sin(ang * Mathf.Deg2Rad);
            pos.z = center.z + 25f * Mathf.Cos(ang * Mathf.Deg2Rad);
            pos.y = center.y;
            pos.y = GetGroundPosition(pos);
            return pos;
        }
        #endregion

        #region [Functional]
        private string GetFormatTime(TimeSpan timespan)
        {
            return string.Format(timespan.TotalHours >= 1 ? "{2:00}:{0:00}:{1:00}" : "{0:00}:{1:00}", timespan.Minutes, timespan.Seconds, System.Math.Floor(timespan.TotalHours));
        }

            private string GetColorLine(int count, int max)
            {
                float n = max > 0 ? (float)ColorLine.Length / max : 0;
                var index = (int)(count * n);
                if (index > 0) index--;
                return ColorLine[index];
            }

        private string[] ColorLine = { "1.00 1.00 1.00 1.00", "1.00 0.98 0.96 1.00", "1.00 0.97 0.92 1.00", "1.00 0.96 0.88 1.00", "1.00 0.94 0.84 1.00", "1.00 0.93 0.80 1.00", "1.00 0.91 0.76 1.00", "1.00 0.90 0.71 1.00", "1.00 0.89 0.67 1.00", "1.00 0.87 0.63 1.00", "1.00 0.85 0.59 1.00", "1.00 0.84 0.55 1.00", "1.00 0.83 0.51 1.00", "1.00 0.81 0.47 1.00", "1.00 0.80 0.43 1.00", "1.00 0.78 0.39 1.00", "1.00 0.77 0.35 1.00", "1.00 0.76 0.31 1.00", "1.00 0.74 0.27 1.00", "1.00 0.73 0.22 1.00", "1.00 0.71 0.18 1.00", "1.00 0.70 0.14 1.00", "1.00 0.68 0.10 1.00", "1.00 0.67 0.06 1.00", "1.00 0.65 0.02 1.00", "1.00 0.64 0.00 1.00", "1.00 0.61 0.00 1.00", "1.00 0.58 0.00 1.00", "1.00 0.55 0.00 1.00", "1.00 0.53 0.00 1.00", "1.00 0.50 0.00 1.00", "1.00 0.47 0.00 1.00", "1.00 0.45 0.00 1.00", "1.00 0.42 0.00 1.00", "1.00 0.40 0.00 1.00", "1.00 0.37 0.00 1.00", "1.00 0.35 0.00 1.00", "1.00 0.32 0.00 1.00", "1.00 0.29 0.00 1.00", "1.00 0.26 0.00 1.00", "1.00 0.24 0.00 1.00", "1.00 0.21 0.00 1.00", "1.00 0.18 0.00 1.00", "1.00 0.16 0.00 1.00", "1.00 0.13 0.00 1.00", "1.00 0.11 0.00 1.00", "1.00 0.08 0.00 1.00", "1.00 0.05 0.00 1.00", "1.00 0.03 0.00 1.00", "1.00 0.00 0.00 1.00" };

		private int FindItemID(string shortName)
		{
			int val;
			if (_itemIds.TryGetValue(shortName, out val))
				return val;

			var definition = ItemManager.FindItemDefinition(shortName);
			if (definition == null) return 0;

			val = definition.itemid;
			_itemIds[shortName] = val;
			return val;
		}

        private void NewSpawnCaptureZone(BasePlayer player, string command, string[] args)
        {
            if (args == null || args.Length <= 0)
            {
                player.ChatMessage("Вы не указали название для территории.");
                return;
            }

            var position = player.transform.position;
            // position.y = GetGroundPosition(position);
            GetNewData(position, args[0]);

            player.ChatMessage($"Вы успешно создали территорию {args[0]}.");
        }

        private void DeleteCaptureZone(BasePlayer player, string command, string[] args)
        {
            if (args == null || args.Length <= 0)
            {
                player.ChatMessage($"Вы не указали название для территории. {_CaptureManager.Count}");
                return;
            }

            var find = _CaptureList.FirstOrDefault(p => p.captureName == args[0]);
            if (find == null) return;

            _CaptureCupboard.Remove(find.Cupboard);
            _CaptureDropBox.Remove(find.ResourseChest);
            RemoveCaptureZone(find.capturePosition);

            CaptureManager CaptureComponent = FindCaptureZoneCupboard(find.Cupboard);
            if (CaptureComponent != null)
            {
                CaptureComponent.DestroyComp();
                _CaptureManager.Remove(CaptureComponent);
            }

            _CaptureList.Remove(find);
            player.ChatMessage($"Вы успешно удалили территорию {args[0]}");
        }
        #endregion

        #region [Clans]
        private string GetClanTag(ulong id) => (string)Clans?.CallHook("GetClanTag", id);
        private List<string> GetClanMembers(string tag)
        {
            if (Clans)
            {
                var clan = Clans?.Call("GetMembersClan", tag) as List<string>;
                return clan.ToList();
            }
            return new List<string>();
        }
        #endregion

        #region [Config]
        private static PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();

            if (config.PluginVersion < Version)
                UpdateConfigValues();

            Config.WriteObject(config, true);
        }

        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (config.PluginVersion < Version)
            {
                config.PluginVersion = Version;
                if (Version == new VersionNumber(1, 0, 0))
                {
                    //
                }

                PrintWarning("Config checked completed!");
            }
            config.PluginVersion = Version;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        public class MarkerInGameSettings
        {
            [JsonProperty("Радиус маркера")]
            public float markerRadius;

            [JsonProperty("Прозрачность маркера")]
            public float markerAlpha;

            [JsonProperty("Цвет маркера когда можно захватить")]
            public string markerColorCanCapture;

            [JsonProperty("Цвет маркера когда идет захват")]
            public string markerColorCapture;

            [JsonProperty("Цвет маркера когда нельзя захватить")]
            public string markerColorCantCapture;
        }

        public class ZoneSettings
        {
            [JsonProperty("Радиус территории")]
            public int RadiusZone;

            [JsonProperty("Радиус захвата территории ( Дистанция захвата, если игрок дальше захват прерывается )")]
            public int RadiusCapture;

            [JsonProperty("Радиус строительства территории ( Дистанция постройки, сколько метров от захвата нельзя строится )")]
            public int RadiusBuild;

            [JsonProperty("Сколько будет длится захват территории")]
            public int CaputureSecond;

            [JsonProperty("Сколько будет перезарядка между захватами")]
            public int CaptureCooldown;

            [JsonProperty("Сколько будет даваться очков за захват территории")]
            public int HowGivePoint;

            [JsonProperty("Процент налога фарма на территории")]
            public int CapturePrecent;
        }

        private class PluginConfig
        {
            [JsonProperty("Настройки территорий")]
            public ZoneSettings _ZoneSettings = new ZoneSettings();

            [JsonProperty("Настройки отметки на карте ( G )")] 
            public MarkerInGameSettings _MarkerInGameSettings = new MarkerInGameSettings();

            [JsonProperty("Использовать для меню плагин MenuAlerts ?")] 
            public bool useMenuAlerts;

            [JsonProperty("Config version")]
            public VersionNumber PluginVersion = new VersionNumber();

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    _ZoneSettings = new ZoneSettings()
                    {
                        RadiusZone = 100,
                        RadiusCapture = 10,
                        RadiusBuild = 20,
                        CaputureSecond = 300,
                        CaptureCooldown = 1200,
                        HowGivePoint = 250,
                        CapturePrecent = 25,
                    },
                    _MarkerInGameSettings = new MarkerInGameSettings()
                    {
                        markerRadius = 0.5f,
                        markerAlpha = 0.4f,
                        markerColorCanCapture = "#10c916",
                        markerColorCantCapture = "#ffb700",
                        markerColorCapture = "#ed0707"
                    },
                    useMenuAlerts = false,
                    PluginVersion = new VersionNumber()
                };
            }
        }
        #endregion
    }
}

// --- End of file: CaptureZone.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/RecyclerA.cs ---
// --- Original Local Path: BeeRust/RecyclerA.cs ---

using System.Collections.Generic;
using UnityEngine;
using Newtonsoft.Json;
using Physics = UnityEngine.Physics;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Recycler", "backwood", "1.0.2")]
    class RecyclerA : RustPlugin
    {
        [PluginReference] 
		private Plugin NoteUI;
		
        #region Classes
        public class DataConfig
        {
            [JsonProperty("Скин предмета")]
            public ulong skin;
            [JsonProperty("Имя предмета")]
            public string itemName;
            [JsonProperty("Описание предмета")]
            public string description;
            [JsonProperty("Подбор переработчика")]
            public bool recyclerpickup;
            [JsonProperty("Подбор переработчика без прописки в шкафу")]
            public bool noauthpickup;
			[JsonProperty("Использовать плагин NoteUI для вывода уведомлений? (заменит все сообщения в чат)")]
            public bool usenoteui;
        }

        #endregion

        #region Config

        public DataConfig cfg;
        protected override void LoadConfig()
        {
            base.LoadConfig();
            cfg = Config.ReadObject<DataConfig>();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(cfg);
        }

        protected override void LoadDefaultConfig()
        {
            cfg = new DataConfig()
            {
                skin = 908940141,
                itemName = "<color=#249c00>Переработчик</color>",
                description = "<size=10>Установите и используйте!</size>",
                recyclerpickup = true,
                noauthpickup = true,
				usenoteui = true,
            };
        }

        #endregion

        #region Hooks and Methods

        void OnServerInitialized()
        {
            if (cfg.usenoteui && !plugins.Exists("NoteUI"))
            {
                PrintWarning("Плагин 'NoteUI' не загружен, дальнейшая работа плагина невозможна!");
                return;
            }
        }

        bool GiveRecycler(BasePlayer player)
        {
            var item = ItemManager.CreateByName("box.wooden.large", 1, cfg.skin);
            item.name = cfg.itemName + " " + cfg.description;
            if (!player.inventory.GiveItem(item))
            {
                item.Drop(player.inventory.containerMain.dropPosition, player.inventory.containerMain.dropVelocity, new Quaternion());
                return false;
            }
            return true;
        }

        [ConsoleCommand("recycler.give")]
        private void CmdGiveRecycler(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin)
            {
                SendError(arg, "[Ошибка] У вас нет доступа к этой команде!");
                return;
            }
            if (!arg.HasArgs())
            {
                PrintError(
                ":\n[Ошибка] Введите recycler.give steamid/nickname\n[Пример] recycler.give backwood\n[Пример] recycler.give 76561198311233564");
                return;
            }
            var player = BasePlayer.Find(arg.Args[0]);
            if (player == null)
            {
                PrintError($"[Ошибка] Не удается найти игрока {arg.Args[0]}");
                return;
            }
            GiveRecycler(player);
        }

        private bool? CanStackItem(Item item, Item targetItem)
        {
            if (item.skin != targetItem.skin)
                return false;

            return null;
        }

        private bool? CanCombineDroppedItem(DroppedItem item, DroppedItem targetItem)
        {
            if (item.GetItem() == null || targetItem.GetItem() == null)
                return null;

            if (item.GetItem().skin != targetItem.GetItem().skin)
                return false;

            return null;
        }


        private Item OnItemSplit(Item item, int amount)
        {
            if (item != null && item.skin == cfg.skin)
            {
                Item x = ItemManager.CreateByName("box.wooden.large", 1);
                x.name = cfg.itemName;
                x.skin = cfg.skin;
                x.amount = amount;

                item.amount -= amount;
                item.MarkDirty();
                return x;
            }

            return null;
        }

        void OnEntityBuilt(Planner planner, GameObject gameobject, BasePlayer player)
        {
            BaseEntity entity = gameobject.ToBaseEntity();
            if (entity == null) return;
            if (entity.skinID != cfg.skin) return;
            entity.Kill();
            var ePos = entity.transform.position;
            Vector3 position = new Vector3(ePos.x, ePos.y + 1, ePos.z);
            var hitted = false;
            RaycastHit Hit;
            if (Physics.Raycast(position, Vector3.down, out Hit, LayerMask.GetMask(new string[] { "Construction" })))
            {
                var rhEntity = Hit.GetEntity();
                if (rhEntity != null)
                {
                    hitted = true;
                }
            }
            BaseEntity rEntity = GameManager.server.CreateEntity("assets/bundled/prefabs/static/recycler_static.prefab", entity.transform.position, entity.GetNetworkRotation(), true);                                 // 1
            rEntity.Spawn();
            rEntity.skinID = cfg.skin;
            if (!hitted) return;
        }

        void OnHammerHit(BasePlayer player, HitInfo info)
        {
            BaseEntity entity = info.HitEntity;
            if (entity == null) return;
            if (!entity.ShortPrefabName.Contains("recycler")) return;
            if (!cfg.recyclerpickup) return;
            if (!cfg.noauthpickup && player.IsBuildingBlocked())
            {
				if (!cfg.usenoteui)
				{
					SendReply(player, "Вы должны быть авторизированы в шкафу чтобы подобрать переработчик!");
				}
				NoteUI?.Call("DrawLockNote", player, "ОШИБКА", $"Вы должны быть авторизированы в шкафу!");
                return;
            }

            entity.Kill();
            GiveRecycler(player);
        }

        #endregion
    }
}

// --- End of file: RecyclerA.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/MegaDamage.cs ---
// --- Original Local Path: BeeRust/MegaDamage.cs ---

﻿using Newtonsoft.Json;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("MegaDamage", "Koks", "1.0.2")]
    [Description("MegaDamage")]
    public class MegaDamage : RustPlugin
    {
        private static PluginConfig cfg = new PluginConfig();
        private class PluginConfig
        {
            [JsonProperty("Пермишены : На сколько увеличить?")]
            public Dictionary<string, float>perm=new Dictionary<string, float>()
            {
                { "megadamage.x2", 2},
                { "megadamage.x3", 3}
            };

            public static PluginConfig GetNewPluginConfig()
            {
                return new PluginConfig();
            }
        }
        List<ulong>offdamage = new List<ulong>();
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                cfg = Config.ReadObject<PluginConfig>();
                if (cfg == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Создаем новую конфигурацию!");
                LoadDefaultConfig();
            }
            NextTick(SaveConfig);
        }
        protected override void LoadDefaultConfig() => cfg = PluginConfig.GetNewPluginConfig();
        protected override void SaveConfig() => Config.WriteObject(cfg);

        private void OnServerInitialized()
        {
            foreach(var perm in cfg.perm)
            {
                if (!permission.PermissionExists(perm.Key, this))permission.RegisterPermission(perm.Key, this);
            }
        }
        [ChatCommand("damage")]
        void CommandDamage(BasePlayer player)
        {
            if (offdamage.Contains(player.userID))
            {
                offdamage.Remove(player.userID);
                player.ChatMessage("Вы включили увеличенный урон");

            }
            else
            {
                offdamage.Add(player.userID);
                player.ChatMessage("Вы выключили увеличенный урон");
            }
        }
        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            var initiatorPlayer = info.InitiatorPlayer;
            if (initiatorPlayer == null) return;
            if (offdamage.Contains(initiatorPlayer.userID)) return;
            float scale = 1;
            foreach (var perm in cfg.perm)
            {
                if(permission.UserHasPermission(initiatorPlayer.UserIDString, perm.Key)) scale = perm.Value;
            }
            info.damageTypes.ScaleAll(scale);
        }
    }

}

// --- End of file: MegaDamage.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/Metabolism.cs ---
// --- Original Local Path: BeeRust/Metabolism.cs ---

﻿using System.Collections.Generic;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Metabolism", "Menevt", "1.0.0")]
    [Description("Modify or disable player metabolism stats")]
    public class Metabolism : RustPlugin
    {
        #region Oxide Hooks
        
        private void Init()
        {
            foreach (var value in config.permissions.Keys)
            {
                permission.RegisterPermission(value, this);
            }
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            foreach (var pair in config.permissions)
            {
                if (permission.UserHasPermission(player.UserIDString, pair.Key))
                {
                    var data = pair.Value;

                    var health = data.health;
                    if (health > 100f)
                    {
                        player._maxHealth = health;
                    }

                    var hydration = data.hydration;
                    if (hydration > 250)
                    {
                        player.metabolism.hydration.max = hydration;
                    }

                    var calories = data.calories;
                    if (calories > 500)
                    {
                        player.metabolism.calories.max = calories;
                    }
                    
                    player.health = health;
                    player.metabolism.hydration.value = hydration;
                    player.metabolism.calories.value = calories;
                    player.SendNetworkUpdate();
                    break;
                }
            }
        }

        #endregion
        
        #region Configuration
        
        private static ConfigData config;
        
        private class ConfigData
        {
            [JsonProperty(PropertyName = "Permission -> Settings")]
            public Dictionary<string, MetabolismSettings> permissions;
        }

        private class MetabolismSettings
        {
            [JsonProperty(PropertyName = "Water on respawn")]
            public float hydration;
            
            [JsonProperty(PropertyName = "Calories on respawn")]
            public float calories;
            
            [JsonProperty(PropertyName = "Health on respawn")]
            public float health;
        }
        
        private ConfigData GetDefaultConfig()
        {
            return new ConfigData 
            {
                permissions = new Dictionary<string, MetabolismSettings>
                {
                    ["metabolism.3"] = new MetabolismSettings
                    {
                        hydration = 5000,
                        calories = 5000,
                        health = 100
                    },
                    ["metabolism.2"] = new MetabolismSettings
                    {
                        hydration = 500,
                        calories = 500,
                        health = 100
                    },
                    ["metabolism.1"] = new MetabolismSettings
                    {
                        hydration = 250,
                        calories = 250,
                        health = 100
                    },
                }
            };
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
   
            try
            {
                config = Config.ReadObject<ConfigData>();
        
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintError("Configuration file is corrupt(or not exists), creating new one!");
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }
        
        #endregion
    }
}


// --- End of file: Metabolism.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/BStats.cs ---
// --- Original Local Path: BeeRust/BStats.cs ---

using System.IO;
using Rust;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("BStats", "King", "1.1.1")]
    public class BStats : RustPlugin
    {
        #region [Vars]
        [PluginReference] private Plugin ImageLibrary = null;
        private string[] _gatherHooks = {
            "OnDispenserGather",
            "OnDispenserBonus",
            "OnCollectiblePickup",
        };
        private static BStats plugin;
        private const string Layer = "BStats.Layer";

        private readonly Dictionary<ulong, BasePlayer> _lastHeli = new Dictionary<ulong, BasePlayer>();
        private Dictionary<string, int> _itemIds = new Dictionary<string, int>();
        private List<ulong> _lootEntity = new List<ulong>();
        #endregion

        #region [ImageLibrary]
        private bool HasImage(string imageName, ulong imageId = 0) => (bool)ImageLibrary.Call("HasImage", imageName, imageId);
        private bool AddImage(string url, string shortname, ulong skin = 0) => (bool)ImageLibrary?.Call("AddImage", url, shortname, skin);
        private string GetImage(string shortname, ulong skin = 0) => (string)ImageLibrary?.Call("GetImage", shortname, skin);
        #endregion

        #region [Data]
        Dictionary<ulong, playerData> _playerList = new Dictionary<ulong, playerData>();

		public class playerData
		{
			public string Name;

            public int Point;

            public int PlayTimeInServer = 0;

            public int Kill = 0;

            public int Death = 0;

            public Dictionary<string, int> Gather = new Dictionary<string, int>()
            {
                { "wood", 0 },
                { "stones", 0 },
                { "metal.ore", 0 },
                { "sulfur.ore", 0},
                { "hq.metal.ore", 0 },
                { "cloth", 0},
                { "leather", 0},
                { "fat.animal", 0},
                { "loot-barrel", 0}
            };

            public int TotalFarm() => Gather.Sum(p => p.Value);
        }

		private playerData GetPlayerData(ulong member)
		{
			if (!_playerList.ContainsKey(member))
				_playerList.Add(member, new playerData());

			return _playerList[member];
		}

		private void SavePlayer()
		{
			Interface.Oxide.DataFileSystem.WriteObject($"{Name}/PlayerList", _playerList);
		}

		private void LoadPlayer()
		{
			try
			{
				_playerList = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, playerData>>($"{Name}/PlayerList");
			}
			catch (Exception e)
			{
				PrintError(e.ToString());
			}

			if (_playerList == null) _playerList = new Dictionary<ulong, playerData>();
		}
        #endregion

        #region [Oxide]
        private void OnPluginLoaded(Plugin plugin)
        {
            NextTick(() =>
            {
                foreach (string hook in _gatherHooks)
                {
                    Unsubscribe(hook);
                    Subscribe(hook);
                }
            });
        }

		private void Init()
		{
			plugin = this;

			LoadPlayer();
		}

        private void OnServerInitialized()
        {
            cmd.AddChatCommand(config.openMenuTop, this, "cmdOpenStats");
            
            foreach (var player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);

            if (config._NotifyChatRandom.chatSendTop)
                timer.Every(config._NotifyChatRandom.chatSendTopTime, GetRandomTopPlayer);
            timer.Every(60, TimeHandle);
        }

		private void Unload()
		{
			foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, Layer);
            }

			SavePlayer();
			plugin = null;
		}

		private void OnNewSave(string filename)
		{
            WipeEnded();
		}
        #endregion

        #region [Reward]
        private void WipeEnded()
        {
            if(config._GameStoreSettings.GivePrize && !string.IsNullOrEmpty(config._GameStoreSettings.ShopID) && !string.IsNullOrEmpty(config._GameStoreSettings.SecretKey))
            {
                var sortedData = _playerList.OrderByDescending(x => x.Value.Point);
                int pos = 1;

                foreach (var user in sortedData)
                {
                    if (config._GameStoreSettings.RewardSettings.ContainsKey(pos))
                    {
                        var args = new Dictionary<string, string>()
                        {
                            { "action", "moneys" },
                            { "type", "plus" },
                            { "steam_id", user.Key.ToString() },
                            { "amount", config._GameStoreSettings.RewardSettings[pos].ToString() }
                        };
                        string url = $"https://gamestores.ru/api/?shop_id={config._GameStoreSettings.ShopID}&secret={config._GameStoreSettings.SecretKey}" + $"{string.Join("", args.Select(arg => $"&{arg.Key}={arg.Value}").ToArray())}";
                        webrequest.Enqueue(url, null, (i, s) =>
                        {
                            if (i != 200)
                            {
                                PrintError($"Ошибка {i}: {s}");
                                return;
                            }
                        }, this);
                    }
                    pos++;
                }
            }

            foreach (var playerData in _playerList)
            {
                playerData.Value.Point = 0;
                playerData.Value.PlayTimeInServer = 0;
                playerData.Value.Kill = 0;
                playerData.Value.Death = 0;
                playerData.Value.Gather = new Dictionary<string, int>()
                {
                    ["wood"] = 0,
                    ["stones"] = 0,
                    ["metal.ore"] = 0,
                    ["hq.metal.ore"] = 0,
                    ["sulfur.ore"] = 0,
                    ["cloth"] = 0,
                    ["leather"] = 0,
                    ["fat.animal"] = 0,
                    ["loot-barrel"] = 0
                };
            }
            SavePlayer();
        }
        #endregion

        #region [Gui]
        private void PlayerTop(BasePlayer player, int page = 0)
        {
            #region [Vars]
            var container = new CuiElementContainer();
            #endregion

            #region [Parrent]
            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Material = "assets/content/ui/uibackgroundblur.mat", Color = "0 0 0 0.77" }
            }, "Overlay", Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Color = "0.36 0.33 0.28 0.3", Material = "assets/icons/greyout.mat", Close = Layer }
            }, Layer);
            #endregion

            #region [Main-Gui]
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-255 -79", OffsetMax = "260 226" },
                Image = { Color = "0.3773585 0.3755785 0.3755785 0.3407843", Material = "assets/icons/greyout.mat" }
            }, Layer, Layer + ".Main");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-255 -174", OffsetMax = "260 -85" },
                Image = { Color = "0.3773585 0.3755785 0.3755785 0.3407843", Material = "assets/icons/greyout.mat" }
            }, Layer, Layer + ".Description");
            #endregion

            #region [Text]
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.933", AnchorMax = "0.997 0.997" },
                Image = { Color = "0 0 0 0" }
            }, Layer + ".Main", Layer + ".Main" + ".Text");

            container.Add(new CuiLabel
            {
                Text = { Text = $"#", Color = "1 1 1 1", FontSize = 13, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.033 0", AnchorMax = $"1 1" },
            }, Layer + ".Main" + ".Text");

            container.Add(new CuiLabel
            {
                Text = { Text = $"ИМЯ ИГРОКА", Color = "1 1 1 1", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.094 0", AnchorMax = $"1 1" },
            }, Layer + ".Main" + ".Text");

            container.Add(new CuiLabel
            {
                Text = { Text = $"НАГРАДА", Color = "1 1 1 1", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.7 0", AnchorMax = $"1 1" },
            }, Layer + ".Main" + ".Text");

            container.Add(new CuiLabel
            {
                Text = { Text = $"ОЧКИ", Color = "1 1 1 1", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.88 0", AnchorMax = $"1 1" },
            }, Layer + ".Main" + ".Text");

            container.Add(new CuiLabel
            {
                Text = { Text = $"Очки даются:\nУбийство +{config._PointsKillDeath.pKill}, добыча камня +{config._PointsSettings.pStone}, добыча метала +{config._PointsSettings.pMetal}, добыча серы +{config._PointsSettings.pSulfur}, разрушение бочки +{config._PointsSettings.pBarrel},\nсбитие вертолета +{config._PointsDestroy.dHeli}, уничтожение танка +{config._PointsDestroy.dBradley}\nОчки отнимаются:\nСмерть -{config._PointsKillDeath.pDeath}, самоубийство -{config._PointsKillDeath.pSuicide}\nНаграда выдается после вайпа на сервере!", Color = "1 1 1 1", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.0125 0", AnchorMax = $"1 1" },
            }, Layer + ".Description");
            #endregion

            CuiHelper.DestroyUi(player, Layer);
            CuiHelper.AddUi(player, container);
            TopPlayerList(player, page);
        }

        private void TopPlayerList(BasePlayer player, int page = 0)
        {
            #region [Vars]
            var playerList = _playerList.OrderByDescending(p => p.Value.Point);
            var container = new CuiElementContainer();
            string colored = "0 0 0 0.5";
            int i = 0;
            #endregion

            #region [Main]
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Color = "0 0 0 0" }
            }, Layer + ".Main", Layer + ".Main" + "TopPlayerList");
            #endregion

            #region [Button]
            container.Add(new CuiButton
            {
                Button = { Color = "0.38 0.62 0.12 0.85", Command = $"UI_BSTATS OpenProfileStats {player.userID}", Material = "assets/icons/greyout.mat" },
                Text = { Text = "МОЙ ПРОФИЛЬ", Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0.4 0.0185", AnchorMax = $"0.6 0.125" },
            }, Layer + ".Main" + "TopPlayerList");

            container.Add(new CuiButton
            {
                Button = { Color = "0.46 0.44 0.42 0.85", Material = "assets/icons/greyout.mat", Close = Layer },
                Text = { Text = "ЗАКРЫТЬ", Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0.8 0.0185", AnchorMax = $"0.99 0.125" },
            }, Layer + ".Main" + "TopPlayerList");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.088 0.0185", AnchorMax = $"0.165 0.125" },
                Image = { Color = "0.2 0.2 0.2 0.25", Material = "assets/icons/greyout.mat" }
            }, Layer + ".Main" + "TopPlayerList", Layer + ".Main" + "TopPlayerList" + ".Page");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" },
                Text = { Text = $"{page + 1}", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter }
            }, Layer + ".Main" + "TopPlayerList" + ".Page");

            container.Add(new CuiButton
            {
                Button = { Color = "0.46 0.44 0.42 0.85", Material = "assets/icons/greyout.mat", Command = page > 0 ? $"UI_BSTATS ChangeTopPage {page - 1}" : "" },
                Text = { Text = "-", FontSize = 22, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0.01 0.0185", AnchorMax = $"0.088 0.125" },
            }, Layer + ".Main" + "TopPlayerList");

            container.Add(new CuiButton
            {
                Button = { Color = "0.46 0.44 0.42 0.85", Material = "assets/icons/greyout.mat", Command = playerList.Skip(10 * (page + 1)).Count() > 0 ? $"UI_BSTATS ChangeTopPage {page + 1}" : "" },
                Text = { Text = "+", FontSize = 22, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0.165 0.0185", AnchorMax = $"0.244 0.125" },
            }, Layer + ".Main" + "TopPlayerList");
            #endregion

            #region [PlayerInfo]
            for (int y = 0; y < 10; y++)
            {
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"0.0055 {0.858 - y * 0.0795}", AnchorMax = $"0.989 {0.93 - y * 0.0795}" },
                    Image = { Color = colored }
                }, Layer + ".Main" + "TopPlayerList", Layer + ".Main" + "TopPlayerList" + $".TopLine{y}");
            }

            foreach (var key in playerList.Skip(10 * page).Take(playerList.ToList().Count >= 10 ? 10 : playerList.ToList().Count))
            {
                container.Add(new CuiLabel
                {
                    Text = { Text = $"{i + (1 + (page * 10))}", Color = "1 1 1 1", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"0.067 1" },
                }, Layer + ".Main" + "TopPlayerList" + $".TopLine{i}");

                container.Add(new CuiLabel
                {
                    Text = { Text = BasePlayer.FindByID(key.Key) != null ? "<color=lime>●</color>" : "<color=red>●</color>", Font = "robotocondensed-regular.ttf", FontSize = 7, Color = "1 1 1 1", Align = TextAnchor.MiddleLeft },
                    RectTransform = { AnchorMin = $"0.0925 0", AnchorMax = $"0.44 1" },
                }, Layer + ".Main" + "TopPlayerList" + $".TopLine{i}");

                container.Add(new CuiLabel
                {
                    Text = { Text = $"{key.Value.Name}", Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "1 1 1 1", Align = TextAnchor.MiddleLeft },
                    RectTransform = { AnchorMin = $"0.1085 0", AnchorMax = $"0.45 1" },
                }, Layer + ".Main" + "TopPlayerList" + $".TopLine{i}");

                if (config._GameStoreSettings.RewardSettings.ContainsKey(i + (1 + (page * 10))))
                {
                    container.Add(new CuiLabel
                    {
                        Text = { Text = $"{config._GameStoreSettings.RewardSettings[i + (1 + (page * 10))]}", Color = "1 1 1 1", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter },
                        RectTransform = { AnchorMin = $"0.695 0", AnchorMax = $"0.8 1" },
                    }, Layer + ".Main" + "TopPlayerList" + $".TopLine{i}");
                }

                container.Add(new CuiLabel
                {
                    Text = { Text = $"{key.Value.Point}", Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "1 1 1 1", Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0.83 0", AnchorMax = $"1 1" },
                }, Layer + ".Main" + "TopPlayerList" + $".TopLine{i}");

                container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = $"UI_BSTATS OpenProfileStats {key.Key}" },
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" },
                }, Layer + ".Main" + "TopPlayerList" + $".TopLine{i}");

                i++;
            }
            #endregion

            CuiHelper.DestroyUi(player, Layer + ".Main" + "TopPlayerList");
            CuiHelper.AddUi(player, container);
        }

        private void PlayerTopInfo(BasePlayer player, ulong playerID)
        {
            #region [Vars]
            var container = new CuiElementContainer();
            string colored = "0 0 0 0.5";

            var data = GetPlayerData(playerID);
            if (data == null) return;
            #endregion

            #region [Parrent]
            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Material = "assets/content/ui/uibackgroundblur.mat", Color = "0 0 0 0.77" }
            }, "Overlay", Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Color = "0.36 0.33 0.28 0.3", Material = "assets/icons/greyout.mat", Close = Layer }
            }, Layer);
            #endregion

            #region [Main-Gui]
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-254 -69", OffsetMax = "259 213" },
                Image = { Color = "0.3773585 0.3755785 0.3755785 0.3407843", Material = "assets/icons/greyout.mat" }
            }, Layer, Layer + ".Profile");
            #endregion

            #region [Avatar]
            container.Add(new CuiElement
            {
                Parent = Layer + ".Profile",
                Components =
                {
                    new CuiRawImageComponent { Png = GetImage($"avatar_{playerID}") },
                    new CuiRectTransformComponent { AnchorMin = $"0.06 0.43", AnchorMax = $"0.31075 0.89" }
                }
            });
            #endregion

            #region [Title]
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.44 0.91", AnchorMax = $"1 1", OffsetMax = "0 0" },
                Text = { Text = "●", Color = BasePlayer.FindByID(playerID) != null ? "0.00 1.00 0.00 1.00" : "1.00 0.00 0.00 1.00", Align = TextAnchor.MiddleLeft, FontSize = 12, Font = "robotocondensed-regular.ttf" }
            }, Layer + ".Profile");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.46 0.91", AnchorMax = $"0.99 1", OffsetMax = "0 0" },
                Text = { Text = $"{data.Name}", Color = "1 1 1 0.8", Align = TextAnchor.MiddleLeft, FontSize = 20, Font = "robotocondensed-regular.ttf" }
            }, Layer + ".Profile");
            #endregion

            #region [Info]
            Dictionary<string, string> _playerInfo = new Dictionary<string, string>()
            {
                { "МЕСТО В ТОПЕ:", $"{GetTopScore(playerID)}" },
                { "ОЧКОВ:", $"{data.Point}" },
                { "АКТИВНОСТЬ:", $"{data.PlayTimeInServer}м." },
                { "УБИЙСТВ:", $"{data.Kill}" },
                { "СМЕРТЕЙ:", $"{data.Death}" },
                { "К/Д:", $"{(data.Death == 0 ? data.Kill : (float)Math.Round(((float)data.Kill) / data.Death, 2))}" },
            };

            foreach (var check in _playerInfo.Select((i, t) => new { A = i, B = t }))
            {
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"0.365 {0.775 - Math.Floor((float) check.B/ 1) * 0.0625}",
                                        AnchorMax = $"0.938 {0.83099 - Math.Floor((float) check.B / 1) * 0.0625}", },
                    Image = { Color = "0 0 0 0.25", Material = "assets/icons/greyout.mat" }
                }, Layer + ".Profile", Layer + ".Profile" + ".Info" + $".{check.B}");

                container.Add(new CuiElement
                {
                    Parent = Layer + ".Profile" + ".Info" + $".{check.B}",
                    Components =
                    {
                        new CuiTextComponent { Text = $"{check.A.Key}", Color = "1 1 1 1", Align = TextAnchor.MiddleLeft, FontSize = 12, Font = "robotocondensed-regular.ttf" },
                        new CuiRectTransformComponent { AnchorMin = $"0.011 0", AnchorMax = $"1 1" },
                    }
                }); 

                container.Add(new CuiElement
                {
                    Parent = Layer + ".Profile" + ".Info" + $".{check.B}",
                    Components =
                    {
                        new CuiTextComponent { Text = $"{check.A.Value}", Color = "1 1 1 1", Align = TextAnchor.MiddleRight, FontSize = 12, Font = "robotocondensed-regular.ttf" },
                        new CuiRectTransformComponent { AnchorMin = $"0 0", AnchorMax = $"0.985 1" },
                    }
                }); 
            }
            #endregion

            #region [Resourse]
            foreach (var check in data.Gather.OrderByDescending(x => x.Value).Select((i, t) => new { A = i, B = t }))
            {
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"{0.025 + check.B * 0.107 - Math.Floor((float) check.B / 9) * 9 * 0.107} 0.175",
                                        AnchorMax = $"{0.115 + check.B * 0.107 - Math.Floor((float) check.B / 9) * 9 * 0.107} 0.345", },
                    Image = { Color = "0 0 0 0.25", Material = "assets/icons/greyout.mat" }
                }, Layer + ".Profile", Layer + ".Profile" + $".{check.B}");

                if (FindItemID(check.A.Key) != 0)
                {
                    container.Add(new CuiElement
                    {
                        Parent = Layer + ".Profile" + $".{check.B}",
                        Components =
                        {
                            new CuiImageComponent { ItemId = FindItemID(check.A.Key), SkinId = 0 },
                            new CuiRectTransformComponent {AnchorMin = "0.025 0.025", AnchorMax = "0.975 0.975"}
                        }
                    });
                }
                else
                {
                    container.Add(new CuiElement
                    {
                        Parent = Layer + ".Profile" + $".{check.B}",
                        Components =
                        {
                            new CuiRawImageComponent { Png = GetImage(check.A.Key) },
                            new CuiRectTransformComponent {AnchorMin = "0.05 0.05", AnchorMax = "0.95 0.95"}
                        }
                    });
                }

                container.Add(new CuiElement
                {
                    Parent = Layer + ".Profile" + $".{check.B}",
                    Components =
                    {
                        new CuiTextComponent { Text = check.A.Value.ToString(), Color = "1 1 1 1", Align = TextAnchor.MiddleRight, FontSize = 10, Font = "robotocondensed-regular.ttf" },
                        new CuiRectTransformComponent { AnchorMin = $"0 0", AnchorMax = $"0.89 0.31" },
                    }
                });
            }
            #endregion

            #region [Button]
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.5925 0.015", AnchorMax = $"0.79 0.131", OffsetMax = "0 0" },
                Button = { Color = "0.46 0.44 0.42 0.6", Material = "assets/icons/greyout.mat", Command = $"UI_BSTATS ReturnToPlayerTop {Math.Ceiling(GetTopScore(playerID) / 10f)}" },
                Text = { Text = $"НАЗАД", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf" }
            }, Layer + ".Profile");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.795 0.015", AnchorMax = $"0.991 0.131", OffsetMax = "0 0" },
                Button = { Color = "0.46 0.44 0.42 0.6", Material = "assets/icons/greyout.mat", Close = Layer },
                Text = { Text = $"ЗАКРЫТЬ", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf" }
            }, Layer + ".Profile");
            #endregion

            CuiHelper.DestroyUi(player, Layer);
            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region [Connect]
        private void OnPlayerConnected(BasePlayer player)
        {
            if (player == null || !player.userID.IsSteamId()) return;

            GetAvatar(player.UserIDString, avatar => AddImage(avatar, $"avatar_{player.UserIDString}"));

            var data = GetPlayerData(player.userID);
            if (data == null || string.IsNullOrEmpty(player.displayName)) return;

            var Name = covalence.Players.FindPlayerById(player.UserIDString)?.Name;
            if (data.Name != Name)
                data.Name = Name;
        }
        #endregion

        #region [Gather]
		private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
		{
            if (!entity.ToPlayer() || entity == null || item == null) return;

            var player = entity.ToPlayer();
            if (player == null || player.IsNpc) return;

            AddResourse(player, item.info.shortname, item.amount);
		}

		private void OnDispenserBonus(ResourceDispenser dispenser, BaseEntity entity, Item item)
		{
            if (!entity.ToPlayer() || entity == null || item == null) return;

            var player = entity.ToPlayer();
            if (player == null || player.IsNpc) return;

            AddResourse(player, item.info.shortname, item.amount, true);
		}

        private void OnCollectiblePickup(CollectibleEntity collectible, BasePlayer player)
		{
			if (player == null || collectible == null || collectible.itemList == null) return;

			foreach (var itemAmount in collectible.itemList)
            {
			    if (itemAmount.itemDef != null)
                {
                    AddResourse(player, itemAmount.itemDef.shortname, (int)itemAmount.amount);
                }
            }
		}
        #endregion

        #region [Entity]
		private void OnEntityTakeDamage(PatrolHelicopter entity, HitInfo info)
		{
			if (entity != null && entity.net != null && info.InitiatorPlayer != null)
				_lastHeli[entity.net.ID.Value] = info.InitiatorPlayer;
		}

		private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
		{
			if (entity == null || info == null) return;

			if (entity is PatrolHelicopter)
			{
				if (_lastHeli.ContainsKey(entity.net.ID.Value))
				{
                    var dataHeli = GetPlayerData(_lastHeli[entity.net.ID.Value].userID);
                    if (dataHeli == null) return;
                    dataHeli.Point += config._PointsDestroy.dHeli;
				}
				return;
			}

			var player = info.InitiatorPlayer;
			if (player == null) return;

            var data = GetPlayerData(player.userID);
            if (data == null) return;

            if (entity is BradleyAPC)
            {
                data.Point += config._PointsDestroy.dBradley;
            }
            else if (entity.name.Contains("barrel"))
            {
                data.Point += config._PointsSettings.pBarrel;
                data.Gather["loot-barrel"]++;
            }
		}
        #endregion

        #region [Loot]
        private void OnLootEntity(BasePlayer player, LootContainer entity)
        {
            if (player == null || entity == null || entity?.net?.ID == null || _lootEntity.Contains(entity.net.ID.Value)) return;

            var data = GetPlayerData(player.userID);
            if (data == null) return;

            data.Point += config._PointsSettings.pBarrel;
            data.Gather["loot-barrel"]++;
            
            _lootEntity.Add(entity.net.ID.Value);
        }
        #endregion

        #region [Death]
        private void OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            if (player == null || info == null || !player.userID.IsSteamId()) return;
            
            if (info.damageTypes.Has(DamageType.Suicide))
            {
                var data = GetPlayerData(player.userID);
                if (data == null) return;
                
                data.Point -= config._PointsKillDeath.pSuicide;
                data.Death++;
                return;
            }
            
            var attacker = info.InitiatorPlayer;
            if (attacker == null || !attacker.userID.IsSteamId() || IsTeammates(player.userID, attacker.userID)) return;

            if (player.userID.IsSteamId())
            {
                var data = GetPlayerData(player.userID);
                if (data != null)
                {
                    data.Point -= config._PointsKillDeath.pDeath;
                    data.Death++;
                }

                var dataAttacker = GetPlayerData(attacker.userID);
                if (dataAttacker != null)
                {
                    dataAttacker.Point += config._PointsKillDeath.pKill;
                    dataAttacker.Kill++;
                }
            }
        }
        #endregion

        #region [ConsoleCommand]
        private void cmdOpenStats(BasePlayer player) => PlayerTop(player);

        [ConsoleCommand("UI_BSTATS")]
        private void StatsUIHandler(ConsoleSystem.Arg args)
        {
			BasePlayer player = args?.Player();
			if (player == null || !args.HasArgs()) return;

            switch (args.Args[0])
            {
                case "OpenProfileStats":
                {
                    PlayerTopInfo(player, ulong.Parse(args.Args[1]));
                    break;
                }
                case "ReturnToPlayerTop":
                {
                    PlayerTop(player, int.Parse(args.Args[1]) - 1);
                    break;
                }
                case "ChangeTopPage":
                {
                    TopPlayerList(player, int.Parse(args.Args[1]));
                    break;
                }
            }
        }
        #endregion

		#region [Avatar]
		private readonly Regex Regex = new Regex(@"<avatarFull><!\[CDATA\[(.*)\]\]></avatarFull>");
		private void GetAvatar(string userId, Action<string> callback)
		{
			if (callback == null) return;

			try
			{
				webrequest.Enqueue($"http://steamcommunity.com/profiles/{userId}?xml=1", null, (code, response) =>
				{
					if (code != 200 || response == null)
						return;

					var avatar = Regex.Match(response).Groups[1].ToString();
					if (string.IsNullOrEmpty(avatar))
						return;

					callback.Invoke(avatar);
				}, this);
			}
			catch (Exception e)
			{
				PrintError($"{e.Message}");
			}
		}
        #endregion

        #region [NotifyChat]
        private void GetRandomTopPlayer()
        {
            int random = Core.Random.Range(0, 9);

            switch (random)
            {
                case 0:
                {
                    var playerList = _playerList.OrderByDescending(p => p.Value.Kill).Take(5);
                    foreach (var player in BasePlayer.activePlayerList)
                    {
                        int i = 1;
                        ServerBroadcast(player, "<size=18><color=#FFDD2FFF>Больше всего убийств:</color></size>", 0);
                        foreach (var key in playerList)
                        {
                            ServerBroadcast(player, $"<size=16>{i}.{key.Value.Name} - <color=#FFDD2FFF>{key.Value.Kill}</color></size>", key.Key);
                            i++;
                        }
                    }
                    break;
                }
                case 1:
                {
                    var playerList = _playerList.OrderByDescending(p => p.Value.Death).Take(5);
                    foreach (var player in BasePlayer.activePlayerList)
                    {
                        int i = 1;
                        ServerBroadcast(player, "<size=18><color=#FFDD2FFF>Больше всего смертей:</color></size>", 0);
                        foreach (var key in playerList)
                        {
                            ServerBroadcast(player, $"<size=16>{i}.{key.Value.Name} - <color=#FFDD2FFF>{key.Value.Death}</color></size>", key.Key);
                            i++;
                        }
                    }
                    break;
                }
                case 2:
                {
                    var playerList = _playerList.OrderByDescending(p => p.Value.TotalFarm()).Take(5);
                    foreach (var player in BasePlayer.activePlayerList)
                    {
                        int i = 1;
                        ServerBroadcast(player, "<size=18><color=#FFDD2FFF>Больше всего фарма:</color></size>", 0);
                        foreach (var key in playerList)
                        {
                            ServerBroadcast(player, $"<size=16>{i}.{key.Value.Name} - <color=#FFDD2FFF>{key.Value.TotalFarm()}</color></size>", key.Key);
                            i++;
                        }
                    }
                    break;
                }
                case 3:
                {
                    var playerList = _playerList.OrderByDescending(p => p.Value.Gather["hq.metal.ore"]).Take(5);
                    foreach (var player in BasePlayer.activePlayerList)
                    {
                        int i = 1;
                        ServerBroadcast(player, "<size=18><color=#FFDD2FFF>Добыто МВК:</color></size>", 0);
                        foreach (var key in playerList)
                        {
                            ServerBroadcast(player, $"<size=16>{i}.{key.Value.Name} - <color=#FFDD2FFF>{key.Value.Gather["hq.metal.ore"]}</color></size>", key.Key);
                            i++;
                        }
                    }
                    break;
                }
                case 4:
                {
                    var playerList = _playerList.OrderByDescending(p => p.Value.Gather["metal.ore"]).Take(5);
                    foreach (var player in BasePlayer.activePlayerList)
                    {
                        int i = 1;
                        ServerBroadcast(player, "<size=18><color=#FFDD2FFF>Добыто Металла:</color></size>", 0);
                        foreach (var key in playerList)
                        {
                            ServerBroadcast(player, $"<size=16>{i}.{key.Value.Name} - <color=#FFDD2FFF>{key.Value.Gather["metal.ore"]}</color></size>", key.Key);
                            i++;
                        }
                    }
                    break;
                }
                case 5:
                {
                    var playerList = _playerList.OrderByDescending(p => p.Value.Gather["sulfur.ore"]).Take(5);
                    foreach (var player in BasePlayer.activePlayerList)
                    {
                        int i = 1;
                        ServerBroadcast(player, "<size=18><color=#FFDD2FFF>Добыто Серы:</color></size>", 0);
                        foreach (var key in playerList)
                        {
                            ServerBroadcast(player, $"<size=16>{i}.{key.Value.Name} - <color=#FFDD2FFF>{key.Value.Gather["sulfur.ore"]}</color></size>", key.Key);
                            i++;
                        }
                    }
                    break;
                }
                case 6:
                {
                    var playerList = _playerList.OrderByDescending(p => p.Value.Gather["loot-barrel"]).Take(5);
                    foreach (var player in BasePlayer.activePlayerList)
                    {
                        int i = 1;
                        ServerBroadcast(player, "<size=18><color=#FFDD2FFF>Добыто бочек и залутно ящиков:</color></size>", 0);
                        foreach (var key in playerList)
                        {
                            ServerBroadcast(player, $"<size=16>{i}.{key.Value.Name} - <color=#FFDD2FFF>{key.Value.Gather["loot-barrel"]}</color></size>", key.Key);
                            i++;
                        }
                    }
                    break;
                }
                case 7:
                {
                    var playerList = _playerList.OrderByDescending(p => p.Value.PlayTimeInServer).Take(5);
                    foreach (var player in BasePlayer.activePlayerList)
                    {
                        int i = 1;
                        ServerBroadcast(player, "<size=18><color=#FFDD2FFF>Проведено больше всего время на сервере:</color></size>", 0);
                        foreach (var key in playerList)
                        {
                            ServerBroadcast(player, $"<size=16>{i}.{key.Value.Name} - <color=#FFDD2FFF>{FormatShortTime(TimeSpan.FromSeconds(key.Value.PlayTimeInServer * 60))}</color></size>", key.Key);
                            i++;
                        }
                    }
                    break;
                }
                case 8:
                {
                    var playerList = _playerList.OrderByDescending(p => p.Value.Point).Take(5);
                    foreach (var player in BasePlayer.activePlayerList)
                    {
                        int i = 1;
                        ServerBroadcast(player, "<size=18><color=#FFDD2FFF>Больше всего очков:</color></size>", 0);
                        foreach (var key in playerList)
                        {
                            ServerBroadcast(player, $"<size=16>{i}.{key.Value.Name} - <color=#FFDD2FFF>{key.Value.Point}</color></size>", key.Key);
                            i++;
                        }
                    }
                    break;
                }
            }
        }

        private void ServerBroadcast(BasePlayer player, string message, ulong AvatarID)
        {
            if (player == null || string.IsNullOrEmpty(message)) return;

            Player.Message(player, $"{message}", AvatarID);
        }

        public static string FormatShortTime(TimeSpan time)
        {
            string result = string.Empty;
            if (time.Days != 0)
                result += $"{time.Days} д. ";

            if (time.Hours != 0)
                result += $"{time.Hours} час. ";

            if (time.Minutes != 0)
                result += $"{time.Minutes} мин. ";

            if (time.Seconds != 0)
                result += $"{time.Seconds} сек. ";

            return result;
        }
        #endregion

        #region [Functional]
		private bool IsTeammates(ulong player, ulong friend)
		{
			return player == friend ||
			       RelationshipManager.ServerInstance.FindPlayersTeam(player)?.members?.Contains(friend) == true;
		}

		private void TimeHandle()
		{
            foreach (var player in BasePlayer.activePlayerList)
            {
                var data = GetPlayerData(player.userID);
                if (data == null) continue;
                
                data.PlayTimeInServer++;
            }
		}

        private int GetTopScore(ulong userid)
        {
            int Top = 1;
            var RaitingNumber = _playerList.OrderByDescending(x => x.Value.Point);

            foreach (var Data in RaitingNumber)
            {
                if (Data.Key == userid)
                    break;
                Top++;
            }

            return Top;
        }

		private int FindItemID(string shortName)
		{
			int val;
			if (_itemIds.TryGetValue(shortName, out val))
				return val;

			var definition = ItemManager.FindItemDefinition(shortName);
			if (definition == null) return 0;

			val = definition.itemid;
			_itemIds[shortName] = val;
			return val;
		}
        #endregion

        #region [AddResourse]
        private void AddResourse(BasePlayer player, string shortname, int amount, bool GivePoint = false)
        {
            if (player == null || string.IsNullOrEmpty(shortname) || amount <= 0) return;

            var data = GetPlayerData(player.userID);
            if (data == null || !data.Gather.ContainsKey(shortname)) return;

            switch (shortname)
            {
                case "wood":
                {
                    data.Gather[shortname] += amount;
                    if (GivePoint)
                    {
                        data.Point += config._PointsSettings.pWood;
                    }
                    break;
                }
                case "stones":
                {
                    data.Gather[shortname] += amount;
                    if (GivePoint)
                    {
                        data.Point += config._PointsSettings.pStone;
                    }
                    break;
                }
                case "metal.ore": case "metal.fragments":
                {
                    data.Gather["metal.ore"] += amount;
                    if (GivePoint)
                    {
                        data.Point += config._PointsSettings.pMetal;
                    }
                    break;
                }
                case "sulfur.ore": case "sulfur":
                {
                    data.Gather["sulfur.ore"] += amount;
                    if (GivePoint)
                    {
                        data.Point += config._PointsSettings.pMetal;
                    }
                    break;
                }
                case "hq.metal.ore": case "metal.refined":
                {
                    data.Gather["hq.metal.ore"] += amount;
                    break;
                }
                case "leather":
                {
                    data.Gather[shortname] += amount;
                    break;
                }
                case "cloth":
                {
                    data.Gather[shortname] += amount;
                    break;
                }
                case "fat.animal":
                {
                    data.Gather[shortname] += amount;                 
                    break;
                }
            }
        }
        #endregion

        #region [Config]
        private PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();

            if (config.PluginVersion < Version)
                UpdateConfigValues();

            Config.WriteObject(config, true);
        }

        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (config.PluginVersion < Version)
            {
                config.PluginVersion = Version;
                if (Version == new VersionNumber(1, 1, 1))
                {
                    config._NotifyChatRandom.chatSendTop = true;
                    config._NotifyChatRandom.chatSendTopTime = 1200;
                }

                PrintWarning("Config checked completed!");
            }
            config.PluginVersion = Version;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        public class PointsSettings
        {
            [JsonProperty("Сколько давать очков за дерево")]
            public int pWood = 5;

            [JsonProperty("Сколько давать очков за каменный камень")]
            public int pStone = 5;

            [JsonProperty("Сколько давать очков за металический камень")]
            public int pMetal = 5;

            [JsonProperty("Сколько давать очков за серный камень")]
            public int pSulfur = 5;

            [JsonProperty("Сколько давать очков за уничтожение бочки | Лутание обычного ящика у дороги")]
            public int pBarrel = 5;
        }

        public class PointsDestroy
        {
            [JsonProperty("Сколько давать очков за уничтожение вертолета")]
            public int dHeli = 1500;

            [JsonProperty("Сколько давать очков за уничтожение танка")]
            public int dBradley = 750;
        }

        public class PointsKillDeath
        {
            [JsonProperty("Сколько давать очков за убийство игрока")]
            public int pKill = 40;

            [JsonProperty("Сколько отнимать очков за смерть")]
            public int pDeath = 15;

            [JsonProperty("Сколько отнимать очков за суицид")]
            public int pSuicide = 15;
        }

        public class GameStoreSettings
        {
            [JsonProperty("Включить авто выдачу призов при вайпе сервера?")]
            public bool GivePrize = true;

            [JsonProperty("ИД магазина в сервисе")] 
            public string ShopID = "";

            [JsonProperty("Секретный ключ (не распростраяйте его)")] 
            public string SecretKey = "";

            [JsonProperty("Место в топе и выдаваемый баланс игроку")]
            public Dictionary<int, float> RewardSettings;
        }

        public class NotifyChatRandom
        {
            [JsonProperty("Отправлять в чат сообщения с топ 5 игроками ?")]
            public bool chatSendTop = true;

            [JsonProperty("Раз в сколько секунд будет отправлятся сообщение ?")]
            public int chatSendTopTime = 1200;
        }

        private class PluginConfig
        {
            [JsonProperty("Команда для открытия топа")]
            public string openMenuTop;

            [JsonProperty("Настройка начисления очков за добычу")]
            public PointsSettings _PointsSettings = new PointsSettings();

            [JsonProperty("Настройка начисления очков за уничтожение")]
            public PointsDestroy _PointsDestroy = new PointsDestroy();

            [JsonProperty("Настройка начисления и отнимания очков за убийства и смерти")]
            public PointsKillDeath _PointsKillDeath = new PointsKillDeath();

            [JsonProperty("Настройка призов")]
            public GameStoreSettings _GameStoreSettings = new GameStoreSettings();

            [JsonProperty("Настройка оповещений в чате")]
            public NotifyChatRandom _NotifyChatRandom = new NotifyChatRandom();

            [JsonProperty("Config version")]
            public VersionNumber PluginVersion = new VersionNumber();

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    openMenuTop = "top",
                    _PointsDestroy = new PointsDestroy()
                    {
                        dHeli = 1500,
                        dBradley = 750,
                    },
                    _PointsKillDeath = new PointsKillDeath()
                    {
                        pKill = 40,
                        pDeath = 15,
                        pSuicide = 15,
                    },
                    _PointsSettings = new PointsSettings()
                    {
                        pWood = 5,
                        pStone = 5,
                        pMetal = 5,
                        pSulfur = 5,
                        pBarrel = 5,
                    },
                    _GameStoreSettings = new GameStoreSettings()
                    {
                        GivePrize = true,
                        ShopID = "",
                        SecretKey = "",
                        RewardSettings = new Dictionary<int, float>()
                        {
                            [1] = 400f,
                            [2] = 250f,
                            [3] = 150f,
                            [4] = 100f,
                            [5] = 50f,
                            [6] = 50f,
                            [7] = 30f,
                        },
                    },
                    _NotifyChatRandom = new NotifyChatRandom()
                    {
                        chatSendTop = true,
                        chatSendTopTime = 1200,
                    },
                    PluginVersion = new VersionNumber()
                };
            }
        }
        #endregion
    }
}

// --- End of file: BStats.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/SnowMoped.cs ---
// --- Original Local Path: BeeRust/SnowMoped.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("SnowMobile","megargan","0.0.3")]
    class SnowMoped : RustPlugin
    {
        #region Configuration
        private static Configuration _config = new Configuration();
        public class Configuration
        {
            [JsonProperty("Скин ID обычного снегохода")]
            public ulong SkinIDSimple { get; set; } = 2742584081;
            
            [JsonProperty("Скин ID снегохода tomaha")]
            public ulong SkinIDTomaha { get; set; } = 2745113546;

            [JsonProperty("Скин ID снегохода ultra")]
            public ulong SkinIDUltra { get; set; } = 2750417732;

            [JsonProperty("Количество топлива внутри снегохода")]
            public int FuelAmount { get; set; } = 100;

            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                };
            }
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) LoadDefaultConfig();
            }
            catch
            {
                Puts("!!!!ОШИБКА КОНФИГУРАЦИИ!!!! создаем новую");
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        private void OnServerInitialized()
        {
            if (_config.SkinIDTomaha == 0 || _config.SkinIDSimple == 0 || _config.SkinIDUltra == 0)
            {
                Puts("Значение skinID в конфиге не может быть 0");
                Interface.Oxide.UnloadPlugin(Name);
            }
        }
        protected override void LoadDefaultConfig() => _config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(_config);
        #endregion

        private object CanBuild(Planner planner, Construction prefab, Construction.Target target)
        {
            if (planner == null || prefab == null || target.player == null) return null;
            if (planner.skinID != _config.SkinIDTomaha && planner.skinID != _config.SkinIDSimple) return null;
            RaycastHit hit;
            if (Physics.Raycast(new Vector3(target.position.x, target.position.y + 1, target.position.z),Vector3.down, out hit, 2f,
                    LayerMask.GetMask(new string[] {"Terrain", "Construction" })) && !hit.collider.name.Contains("building core") && !hit.collider.name.Contains("rock_cliff") && hit.GetEntity() == null) return null;
            SendReply(target.player, "Нельзя ставить на скалах или постройках!");
            return false;
        }
        private void OnEntitySpawned(StorageContainer entity)
        {
            if (entity.skinID == _config.SkinIDSimple || entity.skinID == _config.SkinIDTomaha || entity.skinID == _config.SkinIDUltra)
            {
                var transform = entity.transform;
                Vector3 ePos = transform.position;
                Snowmobile snowmobil = null;
                if (entity.skinID == _config.SkinIDSimple)
                {
                    snowmobil = GameManager.server.CreateEntity(
                        "assets/content/vehicles/snowmobiles/snowmobile.prefab", ePos,
                        transform.rotation * new Quaternion(0, 1f, 0, 1f), true) as Snowmobile;
                }
                else if (entity.skinID == _config.SkinIDTomaha)
                {
                    snowmobil = GameManager.server.CreateEntity(
                        "assets/content/vehicles/snowmobiles/tomahasnowmobile.prefab", ePos,
                        transform.rotation * new Quaternion(0, 1f, 0, 1f), true) as Snowmobile;
                } else if (entity.skinID == _config.SkinIDUltra)
                {
                    snowmobil = GameManager.server.CreateEntity(
                        "assets/content/vehicles/snowmobiles/tomahasnowmobile.prefab", ePos,
                        transform.rotation * new Quaternion(0, 1f, 0, 1f), true) as Snowmobile;
                    snowmobil.engineKW = 90000;
                    snowmobil.badTerrainDrag = 0f;
                    snowmobil.airControlStability = 10000f;
                    snowmobil.hurtTriggerMinSpeed = 10000f;
                } else return;
                snowmobil.Spawn();
                if (_config.FuelAmount > 0)
                    snowmobil.GetFuelSystem().GetFuelContainer().inventory.AddItem(ItemManager.FindItemDefinition("lowgradefuel"), _config.FuelAmount);
                
                NextTick(() => entity.Kill());
            } else return;
        }

        [ChatCommand("givemobile")]
        private void MobileAddChat(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin) return;
            if (args == null || args.Length == 0)
            {
                player.ChatMessage("snowmobile.add [nick/id] [1-3] 1 - обычный 2 - tomaha 3 - ultra");
                return;
            }

            BasePlayer target = BasePlayer.Find(args[0]);
            int snowtype = 0;
            if (!int.TryParse(args[1], out snowtype))
            {
                player.ChatMessage("snowmobile.add [nick/id] [1-3] 1 - обычный 2 - tomaha 3 - ultra");
                return;
            }
            CreateMobile(target, snowtype);
        }
        [ConsoleCommand("snowmobile.add")]
        private void MobileAdd(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if(!arg.IsAdmin) return;
            if (!arg.HasArgs())
            {
                PrintWarning("snowmobile.add [nick/id] [1-3] 1 - обычный 2 - tomaha 3 - ultra");
                if(player != null) player.ChatMessage("snowmobile.add [nick/id] [1-3] 1 - обычный 2 - tomaha 3 - ultra");
                return;
            }
            BasePlayer target = BasePlayer.Find(arg.Args[0]);
            if (target == null)
            {
                PrintWarning("Игрок не найден!");
                if(player != null) player.ChatMessage("Игрок не найден!");
            }
            int snowtype = 0;
            if (!int.TryParse(arg.Args[1], out snowtype))
            {
                PrintWarning("snowmobile.add [nick/id] [1-3] 1 - обычный 2 - tomaha 3 - ultra");
                if(player != null) player.ChatMessage("snowmobile.add [nick/id] [1-3] 1 - обычный 2 - tomaha 3 - ultra");
                return;
            }
            CreateMobile(target, snowtype);
        }

        private void CreateMobile(BasePlayer target, int snowtype)
        {
            Item snow = null;
            switch (snowtype)
            {
                case 1:
                {
                    snow = ItemManager.CreateByName("coffin.storage", 1, _config.SkinIDSimple);
                    snow.name = "SNOW MOBILE";
                    break;
                }
                case 2:
                {
                    snow = ItemManager.CreateByName("coffin.storage", 1, _config.SkinIDTomaha);
                    snow.name = "SNOW MOBILE TOMAHA";
                    break;
                }
                case 3:
                {
                    snow = ItemManager.CreateByName("coffin.storage", 1, _config.SkinIDUltra);
                    snow.name = "SNOW MOBILE TOMAHA-ULTRA";
                    break;
                }
            }
            if (snow != null)
            {
                
                if (!target.inventory.GiveItem(snow))
                    snow.Drop(target.inventory.containerMain.dropPosition, target.inventory.containerMain.dropVelocity);
            }
        }
    }
}

// --- End of file: SnowMoped.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/GatherPrefab.cs ---
// --- Original Local Path: BeeRust/GatherPrefab.cs ---

using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("GatherPrefab", "King.", "1.0.0")]
    public class GatherPrefab : RustPlugin
    {
        #region [Config]
        private PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();

            if (config.PluginVersion < Version)
                UpdateConfigValues();

            Config.WriteObject(config, true);
        }

        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (config.PluginVersion < Version)
            {
                config.PluginVersion = Version;
                if (Version == new VersionNumber(1, 0, 0))
                {
                    //
                }

                PrintWarning("Config checked completed!");
            }
            config.PluginVersion = Version;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        private class PluginConfig
        {
            [JsonProperty("При уничтожении какого обьекта будет даваться предмет из конфига [ Entity - кол-во ]")]
            public Dictionary<string, int> GatherPrefab;

            [JsonProperty("ShortName выдаваемого предмета")]
            public string ShortName;

            [JsonProperty("Использовать рандом ?")]
            public bool UseRandom;

            [JsonProperty("С какой вероятностью будет падать предмет из конфига ( При использовании рандома )")]
            public int RandomValue;

            [JsonProperty("Config version")]
            public VersionNumber PluginVersion = new VersionNumber();

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    GatherPrefab = new Dictionary<string, int>()
                    {
                        ["assets/bundled/prefabs/autospawn/resource/ores/stone-ore.prefab"] = 30,
                        ["assets/bundled/prefabs/autospawn/resource/ores/metal-ore.prefab"] = 50,
                        ["assets/bundled/prefabs/autospawn/resource/ores/sulfur-ore.prefab"] = 40
                    },
                    ShortName = "hq.metal.ore",
                    RandomValue = 50,
                    PluginVersion = new VersionNumber()
                };
            }
        }
        #endregion

        #region [Rust-Api]
        private void OnEntityDeath(BaseEntity entity, HitInfo info)
        {
            if (info == null || entity?.net?.ID == null) return;

            var player = info?.InitiatorPlayer;
            if (player == null) return;
            
            if (config.GatherPrefab.ContainsKey(entity.PrefabName))
            {
                if (!config.GatherPrefab.ContainsKey(entity.PrefabName)) return;
                if (config.UseRandom)
                {
                    if (UnityEngine.Random.Range(0f, 100f) < config.RandomValue)
                    {
                        var item = ItemManager.CreateByName(config.ShortName, config.GatherPrefab[entity.PrefabName]);
                        player.GiveItem(item);
                    }
                }
                else
                {
                    var item = ItemManager.CreateByName(config.ShortName, config.GatherPrefab[entity.PrefabName]);
                    player.GiveItem(item);
                }
            }
        }
        #endregion
    }
}

// --- End of file: GatherPrefab.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/DeathMessages.cs ---
// --- Original Local Path: BeeRust/DeathMessages.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;

namespace Oxide.Plugins
{
    [Info("DeathMessages", "TopPlugin.ru", "2.4.0")]
    class DeathMessages : RustPlugin
    {
        private static DeathMessages ins;

        private List<DeathMessage> _notes = new List<DeathMessage>();
        private Dictionary<ulong, HitInfo> _lastHits = new Dictionary<ulong, HitInfo>();

        #region Classes / Enums

        public class ColorsPrivilage
        {
            [JsonProperty("Цвет имени если игрока убили")]
            public string ColorDeath;
            [JsonProperty("Цвет имени если игрок убил")]
            public string ColorAttacker;
        }

        enum AttackerType
        {
            Player,
            Helicopter,
            Animal,
            Turret,
            Guntrap,
            Structure,
            Trap,
            Invalid,
            NPC,
            BradleyAPC,
            Zombie,
            ZombieDeath
        }

        enum VictimType
        {
            Player,
            Helicopter,
            Animal,
            Invalid,
            NPC,
            BradleyAPC,
            Zombie,
            ZombieDeath
        }

        enum DeathReason
        {
            Turret,
            Guntrap,
            Helicopter,
            HelicopterDeath,
            BradleyAPC,
            BradleyAPCDeath,
            Structure,
            Trap,
            Animal,
            AnimalDeath,
            Generic,
            Zombie,
            ZombieDeath,
            Hunger,
            Thirst,
            Cold,
            Drowned,
            Heat,
            Bleeding,
            Poison,
            Suicide,
            Bullet,
            Arrow,
            Flamethrower,
            Slash,
            Blunt,
            Fall,
            Radiation,
            Stab,
            Explosion,
            Unknown
        }

        class Attacker
        {
            public Attacker(BaseEntity entity)
            {
                Entity = entity;
                Type = InitializeType();
                Name = InitializeName();
            }

            public BaseEntity Entity { get; }

            public string Name { get; }

            public AttackerType Type { get; }

            private AttackerType InitializeType()
            {
                if (Entity == null)
                    return AttackerType.Invalid;

                if (Entity is BaseAnimalNPC)
                    return AttackerType.Animal;

                if (Entity.name.Contains("machete.weapon"))
                    return AttackerType.Zombie;

                if (Entity is NPCPlayer)
                    return AttackerType.NPC;

                if (Entity.IsNpc)
                    return AttackerType.NPC;

                if (Entity is BasePlayer)
                    return AttackerType.Player;

                if (Entity is PatrolHelicopter)
                    return AttackerType.Helicopter;

                if (Entity is BradleyAPC)
                    return AttackerType.BradleyAPC;



                if (Entity.name.Contains("barricades/") || Entity.name.Contains("wall.external.high"))
                    return AttackerType.Structure;

                if (Entity.name.Contains("beartrap.prefab") || Entity.name.Contains("landmine.prefab") || Entity.name.Contains("spikes.floor.prefab"))
                    return AttackerType.Trap;

                if (Entity.name.Contains("autoturret_deployed.prefab") || Entity.name.Contains("flameturret.deployed.prefab") || Entity.name.Contains("sentry.scientist.static"))
                    return AttackerType.Turret;
                if (Entity.name.Contains("guntrap_deployed.prefab") || Entity.name.Contains("guntrap.deployed.prefab"))
                    return AttackerType.Guntrap;

                return AttackerType.Invalid;
            }

            private string InitializeName()
            {
                if (Entity == null)
                    return null;
                int name;
                switch (Type)
                {
                    case AttackerType.Player:
                        return Entity.ToPlayer().displayName;
                    case AttackerType.NPC:
                        return string.IsNullOrEmpty(Entity.ToPlayer()?.displayName) ? _config.NPCName : int.TryParse(Entity.ToPlayer().displayName, out name) ? _config.NPCName : Entity.ToPlayer().displayName + $"( {_config.NPCName})";
                    case AttackerType.Helicopter:
                        return "Patrol Helicopter";
                    case AttackerType.BradleyAPC:
                    case AttackerType.Turret:
                    case AttackerType.Guntrap:
                    case AttackerType.Trap:
                    case AttackerType.Animal:
                    case AttackerType.Structure:
                        return FormatName(Entity.name);
                }

                return string.Empty;
            }
        }

        class Victim
        {
            public Victim(BaseCombatEntity entity)
            {
                Entity = entity;
                Type = InitializeType();
                Name = InitializeName();
            }

            public BaseCombatEntity Entity { get; }

            public string Name { get; }

            public VictimType Type { get; }

            private VictimType InitializeType()
            {
                if (Entity == null)
                    return VictimType.Invalid;

                if (Entity is BaseAnimalNPC)
                    return VictimType.Animal;

                if (Entity.IsNpc)
                    return VictimType.NPC;


                if (Entity.name.Contains("machete.weapon"))
                    return VictimType.Zombie;

                if (Entity is NPCPlayer)
                    return VictimType.NPC;




                if (Entity is BasePlayer)
                    return VictimType.Player;

                if (Entity is PatrolHelicopter)
                    return VictimType.Helicopter;

                if (Entity is BradleyAPC)
                    return VictimType.BradleyAPC;

                return VictimType.Invalid;
            }



            private string InitializeName()
            {
                int name;
                switch (Type)
                {
                    case VictimType.Zombie:
                        return "ZombieName";

                    case VictimType.Player:
                        return Entity.ToPlayer().displayName;

                    case VictimType.NPC:
                        return string.IsNullOrEmpty(Entity.ToPlayer()?.displayName) ? _config.NPCName : int.TryParse(Entity.ToPlayer().displayName, out name) ? _config.NPCName : Entity.ToPlayer().displayName + $" ({_config.NPCName})";

                    case VictimType.Helicopter:
                        return "Patrol Helicopter";

                    case VictimType.BradleyAPC:
                        return "BradleyAPCName";

                    case VictimType.Animal:
                        return FormatName(Entity.name);
                }
                return string.Empty;
            }
        }

        class DeathMessage
        {

            public string UINotes;

            public DeathMessage(Attacker attacker, Victim victim, string weapon, string damageType, string bodyPart, double distance)
            {
                Attacker = attacker;
                Victim = victim;
                Weapon = weapon;
                DamageType = damageType;
                BodyPart = bodyPart;
                Distance = distance;
                Reason = InitializeReason();
                Message = InitializeDeathMessage();

                if (_config.Distance <= 0)
                {
                    Players = BasePlayer.activePlayerList.ToList();
                }
                else
                {
                    var position = attacker?.Entity?.transform?.position;
                    if (position == null)
                        position = victim?.Entity?.transform?.position;

                    if (position != null)
                        Players = BasePlayer.activePlayerList.Where(x => x.Distance((UnityEngine.Vector3)position) <= _config.Distance).ToList();
                    else
                        Players = new List<BasePlayer>();
                }

                if (victim.Type == VictimType.Player && !Players.Contains(victim.Entity.ToPlayer()))
                    Players.Add(victim.Entity.ToPlayer());

                if (attacker.Type == AttackerType.Player && !Players.Contains(attacker.Entity.ToPlayer()))
                    Players.Add(attacker.Entity.ToPlayer());

                UINotes = CuiHelper.GetGuid();
            }

            public List<BasePlayer> Players { get; }

            public Attacker Attacker { get; }

            public Victim Victim { get; }

            public string Weapon { get; }

            public string BodyPart { get; }

            public string DamageType { get; }

            public double Distance { get; }

            public DeathReason Reason { get; }

            public string Message { get; }

            private DeathReason InitializeReason()
            {
                if (Attacker.Type == AttackerType.Turret)
                    return DeathReason.Turret;

                if (Attacker.Type == AttackerType.Guntrap)
                    return DeathReason.Guntrap;

                if (Attacker.Type == AttackerType.Zombie)
                    return DeathReason.Zombie;

                else if (Attacker.Type == AttackerType.Helicopter)
                    return DeathReason.Helicopter;

                else if (Attacker.Type == AttackerType.BradleyAPC)
                    return DeathReason.BradleyAPC;

                else if (Victim.Type == VictimType.Helicopter)
                    return DeathReason.HelicopterDeath;

                else if (Victim.Type == VictimType.BradleyAPC)
                    return DeathReason.BradleyAPCDeath;

                else if (Attacker.Type == AttackerType.Structure)
                    return DeathReason.Structure;

                else if (Attacker.Type == AttackerType.Trap)
                    return DeathReason.Trap;

                else if (Attacker.Type == AttackerType.Animal)
                    return DeathReason.Animal;

                else if (Victim.Type == VictimType.Animal)
                    return DeathReason.AnimalDeath;

                else if (Weapon == "F1 Grenade" || Weapon == "Survey Charge" || Weapon == "Timed Explosive Charge" || Weapon == "Satchel Charge" || Weapon == "Beancan Grenade")
                    return DeathReason.Explosion;

                else if (Weapon == "Flamethrower")
                    return DeathReason.Flamethrower;

                else if (Victim.Type == VictimType.Player || Victim.Type == VictimType.NPC)
                    return GetDeathReason(DamageType);

                if (Victim.Type == VictimType.Zombie)
                    return DeathReason.ZombieDeath;

                return DeathReason.Unknown;
            }

            private DeathReason GetDeathReason(string damage)
            {
                var reasons = (Enum.GetValues(typeof(DeathReason)) as DeathReason[]).Where(x => x.ToString().Contains(damage));

                if (reasons.Count() == 0)
                    return DeathReason.Unknown;
                return reasons.First();
            }

            private string InitializeDeathMessage()
            {
                string message = string.Empty;
                string reason = string.Empty;

                if (Victim.Type == VictimType.Player && Victim.Entity.ToPlayer().IsSleeping() && _config.Messages.ContainsKey(Reason + " Sleeping"))
                    reason = Reason + " Sleeping";
                else
                    reason = Reason.ToString();

                message = GetMessage(reason, _config.Messages);

                var attackerName = Attacker.Name;
                if (string.IsNullOrEmpty(attackerName) && Attacker.Entity == null && Weapon.Contains("Heli"))
                    attackerName = _config.HelicopterName;

                if (string.IsNullOrEmpty(attackerName) && Attacker.Entity == null && Weapon.Contains("Bradl"))
                    attackerName = _config.BradleyAPCName;


                switch (Attacker.Type)
                {
                    case AttackerType.ZombieDeath:
                        attackerName = _config.ZombieName;
                        break;

                    case AttackerType.Zombie:
                        attackerName = _config.ZombieName;
                        break;

                    case AttackerType.Helicopter:
                        attackerName = _config.HelicopterName;
                        break;

                    case AttackerType.BradleyAPC:
                        attackerName = _config.BradleyAPCName;
                        break;

                    case AttackerType.NPC:
                        attackerName = _config.NPCName;
                        break;

                    case AttackerType.Turret:
                        attackerName = GetMessage(attackerName, _config.Turrets);
                        break;
                    case AttackerType.Guntrap:
                        attackerName = GetMessage(attackerName, _config.Turrets);
                        break;

                    case AttackerType.Trap:
                        attackerName = GetMessage(attackerName, _config.Traps);
                        break;

                    case AttackerType.Animal:
                        attackerName = GetMessage(attackerName, _config.Animals);
                        break;

                    case AttackerType.Structure:
                        attackerName = GetMessage(attackerName, _config.Structures);
                        break;

                }

                var victimName = Victim.Name;
                switch (Victim.Type)
                {
                    case VictimType.Helicopter:
                        victimName = _config.HelicopterName;
                        break;

                    case VictimType.BradleyAPC:
                        victimName = _config.BradleyAPCName;
                        break;

                    case VictimType.Zombie:
                        victimName = _config.ZombieName;
                        break;

                    case VictimType.Animal:
                        victimName = GetMessage(victimName, _config.Animals);
                        break;
                }
                var reply = 3710;
                var victimColor = _config.ColorPrivilage["deathmessages.default"].ColorDeath;
                var attackerColor = _config.ColorPrivilage["deathmessages.default"].ColorAttacker;
                foreach (var color in _config.ColorPrivilage)
                {
                    if (Attacker.Entity != null && Attacker.Entity.ToPlayer())
                        if (ins.permission.UserHasPermission(Attacker.Entity.ToPlayer().UserIDString, color.Key))
                            attackerColor = color.Value.ColorAttacker;
                    if (Victim.Entity != null && Victim.Entity.ToPlayer())
                        if (ins.permission.UserHasPermission(Victim.Entity.ToPlayer().UserIDString, color.Key))
                            victimColor = color.Value.ColorDeath;
                }
                message = message.Replace("{victim}", $"<color={victimColor}>{victimName}</color>");
                message = message.Replace("{attacker}", $"<color={attackerColor}>{attackerName}</color>");
                message = message.Replace("{distance}", $"<color={_config.ColorDistance}>{Math.Round(Distance, 0)}</color>");
                message = message.Replace("{weapon}", $"<color={_config.ColorWeapon}>{GetMessage(Weapon, _config.Weapons)}</color>");
                message = message.Replace("{bodypart}", $"<color={_config.ColorBodyPart}>{GetMessage(BodyPart, _config.BodyParts)}</color>");
                return message;
            }
        }

        #endregion

        #region Oxide Hooks
        private static PluginConfig _config;

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Благодарим за приобритение плагина на сайте RustPlugin.ru. Если вы приобрели этот плагин на другом ресурсе знайте - это лишает вас гарантированных обновлений!");
            _config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<PluginConfig>();
            if (_config.PluginVersion < Version)
                UpdateConfigValues();
            Config.WriteObject(_config, true);
        }

        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (_config.PluginVersion < new VersionNumber(0, 1, 0))
            {
                PrintWarning("Config update detected! Updating config values...");
                PrintWarning("Config update completed!");
            }
            _config.PluginVersion = Version;
        }


        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        class PluginConfig
        {
            [JsonProperty("Configuration Version")]
            public VersionNumber PluginVersion = new VersionNumber();

            [JsonProperty("A. Время показа сообщения (сек)")]
            public int Cooldown { get; set; }
            [JsonProperty("B. Размер текста")]
            public int FontSize { get; set; }
            [JsonProperty("C. Показывать убиства животных")]
            public bool ShowDeathAnimals { get; set; }
            [JsonProperty("C1. Показывать убиства NPC")]
            public bool ShowDeathNPC { get; set; }
            [JsonProperty("D. Показывать убийства спящих")]
            public bool ShowDeathSleepers { get; set; }
            [JsonProperty("E. Хранение логов")]
            public bool Log { get; set; }
            [JsonProperty("H. Цвет оружия")]
            public string ColorWeapon { get; set; }
            [JsonProperty("I. Цвет дистанции")]
            public string ColorDistance { get; set; }
            [JsonProperty("J. Цвет части тела")]
            public string ColorBodyPart { get; set; }
            [JsonProperty("K. Дистанция")]
            public double Distance { get; set; }
            [JsonProperty("L. Название вертолета")]
            public string HelicopterName { get; set; }
            [JsonProperty("M. Название Bradlay (Танк)")]
            public string BradleyAPCName { get; set; }
            [JsonProperty("N. Имя NPC")]
            public string NPCName { get; set; }
            [JsonProperty("O. Имя Zombie")]
            public string ZombieName { get; set; }
            [JsonProperty("P. Выводить убийства в консоль")]
            public bool ShowColsole { get; set; }
            [JsonProperty("Оружие")]
            public Dictionary<string, string> Weapons { get; set; }
            [JsonProperty("Цвета имени в UI")]
            public Dictionary<string, ColorsPrivilage> ColorPrivilage
            {
                get; set;
            }

            [JsonProperty("Позиция: AnchorMin (Это изнаальная позиция точки, от неё в лево будет уходить основное UI по оффсетам, дефолт 1 1 - Верхний правый угол)")]
            public string AnchorMin = "1 1";
            [JsonProperty("Позиция: AnchorMax (Это изнаальная позиция точки, от неё в лево будет уходить основное UI по оффсетам, дефолт 1 1 - Верхний правый угол)")]
            public string AnchorMax = "1 1";
            [JsonProperty("Конструкции")]
            public Dictionary<string, string> Structures { get; set; }
            [JsonProperty("Ловушки")]
            public Dictionary<string, string> Traps { get; set; }
            [JsonProperty("Турели")]
            public Dictionary<string, string> Turrets { get; set; }
            [JsonProperty("Животные")]
            public Dictionary<string, string> Animals { get; set; }
            [JsonProperty("Сообщения ({attacker} - инициатор,  {victim} - жертва, {weapon} - оружие,  {distance} - дистанция, {bodypart} - часть тела")]
            public Dictionary<string, string> Messages { get; set; }
            [JsonProperty("Части тела")]
            public Dictionary<string, string> BodyParts { get; set; }


            [JsonIgnore]
            [JsonProperty("Server Initialized")]
            public bool Init = false;

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    PluginVersion = new VersionNumber(),
                    Cooldown = 7,
                    FontSize = 15,
                    Distance = -1,
                    Log = true,
                    ShowDeathAnimals = true,
                    ShowDeathNPC = true,
                    ShowDeathSleepers = true,
                    ShowColsole = false,
                    ColorDistance = "#ff9c00",
                    ColorWeapon = "#ffffff",
                    ColorBodyPart = "#ffffff",
                    HelicopterName = "Вертолет",
                    BradleyAPCName = "Танк",
                    NPCName = "НПЦ",
                    ZombieName = "Зомби",
                    AnchorMin = "1 1",
                    AnchorMax = "1 1",
                    ColorPrivilage = new Dictionary<string, ColorsPrivilage>
                    {
                        ["deathmessages.default"] = new ColorsPrivilage
                        {
                            ColorAttacker = "#ff9c00",
                            ColorDeath = "#ff9c00"
                        },
                        ["deathmessages.vip"] = new ColorsPrivilage
                        {
                            ColorAttacker = "#F70233",
                            ColorDeath = "#757575"
                        },
                        ["deathmessages.elite"] = new ColorsPrivilage
                        {
                            ColorAttacker = "#DF0BBA",
                            ColorDeath = "#D1D1D1"
                        },
                    },

                    Weapons = new Dictionary<string, string>
                {
                    { "Assault Rifle", "Assault Rifle" },
                    { "Beancan Grenade", "Beancan" },
                    { "Nailgun", "Гвоздострел" },
                    { "Bolt Action Rifle", "Bolt Action Rifle" },
                    { "Bone Club", "Bone Club" },
                    { "Bone Knife", "Bone Knife" },
                    { "Crossbow", "Crossbow" },
                    { "Flamethrower", "Flamethrower" },
                       { "Explosivesatchel", "Explosivesatchel" },
                    { "Custom SMG", "SMG" },
                    { "Double Barrel Shotgun", "Double Shotgun" },
                    { "Compound Bow", "Compound Bow" },
                    { "Eoka Pistol", "Eoka" },
                    { "F1 Grenade", "F1" },
                    { "Flame Thrower", "Flame Thrower" },
                    { "Hunting Bow", "Hunting Bow" },
                    { "Longsword", "Longsword" },
                    { "LR-300 Assault Rifle", "LR-300" },
                    { "M249", "М249" },
                    { "M92 Pistol", "M92" },
                    { "Mace", "Mace" },
                    { "Machete", "Machete" },
                    { "MP5A4", "MP5A4" },
                    { "Pump Shotgun", "Shotgun" },
                    { "Python Revolver", "Python Revolver" },
                    { "Revolver", "Revolver" },
                    { "Salvaged Cleaver", "Salvaged Cleaver" },
                    { "Salvaged Sword", "Salvaged Sword" },
                    { "Semi-Automatic Pistol", "Semi-Automatic Pistol" },
                    { "Semi-Automatic Rifle", "Semi-Automatic Rifle" },
                    { "Stone Spear", "Stone Spear" },
                    { "Thompson", "Thompson" },
                    { "Waterpipe Shotgun", "Waterpipe Shotgun" },
                    { "Wooden Spear", "Wooden Spear" },
                    { "Hatchet", "Hatchet" },
                    { "Pick Axe", "Pick Axe" },
                    { "Salvaged Axe", "Salvaged Axe" },
                    { "Salvaged Hammer", "Salvaged Hammer" },
                    { "Salvaged Icepick", "Salvaged Icepick" },
                    { "Satchel Charge", "Satchel Charge" },
                    { "Stone Hatchet", "Stone Hatchet" },
                    { "Stone Pick Axe", "Stone Pick Axe" },
                    { "Survey Charge", "Survey Charge" },
                    { "Timed Explosive Charge", "С4" },
                    { "Torch", "Torch" },
                    { "Stone Pickaxe", "Stone Pickaxe" },
                    { "RocketSpeed", "Скоростная ракета" },
                    { "Incendiary Rocket", "Зажигательная ракета" },
                    { "Rocket", "Обычная ракета" },
                    { "RocketHeli", "Напалм" },
                    { "RocketBradley", "Напалм" },
                    { "Spas-12 Shotgun", "Spas-12 Shotgun" },
                    {"Multiple Grenade Launcher", "Multiple Grenade Launcher" },
                    {"40mm.grenade.he", "Multiple Grenade Launcher" },
                },

                    Structures = new Dictionary<string, string>
                {
                    { "Wooden Barricade", "Деревянная баррикада" },
                    { "Barbed Wooden Barricade", "Колючая деревянная баррикада" },
                    { "Metal Barricade", "Металлическая баррикада" },
                    { "High External Wooden Wall", "Высокая внешняя деревянная стена" },
                    { "High External Stone Wall", "Высокая внешняя каменная стена" },
                    { "High External Wooden Gate", "Высокие внешние деревянные ворота" },
                    { "High External Stone Gate", "Высокие внешние каменные ворота" }
                },

                    Traps = new Dictionary<string, string>
                {
                    { "Snap Trap", "Капкан" },
                    { "Land Mine", "Мина" },
                    { "Wooden Floor Spikes", "Деревянные колья" }
                },

                    Turrets = new Dictionary<string, string>
                {
                    { "Flame Turret", "Огнеметная турель" },
                    { "Auto Turret", "Автотурель" },
                    { "Guntrap", "Автодробовик" },
                    { "Static Turret", "Автоматическая туррель" },
                },

                    Animals = new Dictionary<string, string>
                {
                    { "Boar", "Кабан" },
                    { "Horse", "Лошадь" },
                    { "Wolf", "Волк" },
                    { "Stag", "Олень" },
                    { "Chicken", "Курица" },
                    { "Bear", "Медведь" }
                },

                    BodyParts = new Dictionary<string, string>
                {
                    { "body", "Тело" },
                    { "pelvis", "Таз" },
                    { "hip", "Бедро" },
                    { "left knee", "Левое колено" },
                    { "right knee", "Правое колено" },
                    { "left foot", "Левая стопа" },
                    { "right foot", "Правая стопа" },
                    { "left toe", "Левый палец" },
                    { "right toe", "Правый палец" },
                    { "groin", "Пах" },
                    { "lower spine", "Нижний позвоночник" },
                    { "stomach", "Желудок" },
                    { "chest", "Грудь" },
                    { "neck", "Шея" },
                    { "left shoulder", "Левое плечо" },
                    { "right shoulder", "Правое плечо" },
                    { "left arm", "Левая рука" },
                    { "right arm", "Правая рука" },
                    { "left forearm", "Левое предплечье" },
                    { "right forearm", "Правое предплечье" },
                    { "left hand", "Левая ладонь" },
                    { "right hand", "Правая ладонь" },
                    { "left ring finger", "Левый безымянный палец" },
                    { "right ring finger", "Правый безымянный палец" },
                    { "left thumb", "Левый большой палец" },
                    { "right thumb", "Правый большой палец" },
                    { "left wrist", "Левое запястье" },
                    { "right wrist", "Правое запястье" },
                    { "head", "Голова" },
                    { "jaw", "Челюсть" },
                    { "left eye", "Левый глаз" },
                    { "right eye", "Правый глаз" }
                },

                    Messages = new Dictionary<string, string>
                {
                    { "Arrow", "{attacker} убил {victim} ({weapon}, {distance} м.)" },
                    { "Blunt",  "{attacker} убил {victim} ({weapon})" },
                    { "Bullet", "{attacker} убил {victim} ({weapon}, {distance} м.)" },
                    { "Flamethrower", "{attacker} сжег заживо игрока {victim} ({weapon})" },
                    { "Drowned", "{victim} утонул." },
                    { "Explosion", "{attacker} взорвал игрока {victim} ({weapon})" },
                    { "Fall", "{victim} разбился." },
                    { "Generic", "Смерть забрала {victim} с собой." },
                    { "Heat", "{victim} сгорел заживо." },
                    { "Helicopter", "{attacker} прямым попаданием убил {victim}." },
                    { "BradleyAPC", "{attacker} прямым попаданием убил {victim}." },
                    { "BradleyAPCDeath", "{victim} был уничтожен игроком {attacker} ({weapon})" },
                    { "HelicopterDeath", "{victim} был сбит игроком {attacker} ({weapon})" },
                    { "Animal", "{attacker} добрался до {victim}" },
                    { "ZombieDeath", "{attacker} убил {victim} ({weapon}, {distance} м.)" },
                    { "Zombie", "{attacker} приследовал {victim}." },
                    { "AnimalDeath", "{attacker} убил {victim} ({weapon}, {distance} м.)" },
                    { "Hunger", "{victim} умер от голода." },
                    { "Poison", "{victim} умер от отравления." },
                    { "Radiation", "{victim} умер от радиационного отравления" },
                    { "Slash", "{attacker} убил {victim} ({weapon})" },
                    { "Stab", "{attacker} убил {victim} ({weapon})" },
                    { "Structure", "{victim} умер от сближения с {attacker}" },
                    { "Suicide", "{victim} совершил самоубийство." },
                    { "Thirst", "{victim} умер от обезвоживания" },
                    { "Trap", "{victim} попался на ловушку {attacker}" },
                    { "Cold", "{victim} умер от холода" },
                    { "Turret", "{victim} был убит автоматической турелью" },
                    { "Guntrap", "{victim} был убит ловушкой-дробовиком" },
                    { "Unknown", "У {victim} что-то пошло не так." },
                    { "Bleeding", "{victim} умер от кровотечения" },
                    { "Blunt Sleeping", "{attacker} убил {victim} ({weapon})" },
                    { "Bullet Sleeping", "{attacker} убил {victim} ({weapon}, {distance} метров)" },
                    { "Flamethrower Sleeping", "{attacker} сжег игрока {victim} ({weapon})" },
                    { "Explosion Sleeping", "{attacker} убил {victim} ({weapon})" },
                    { "Generic Sleeping", "Смерть забрала {victim} с собой пока он спал." },
                    { "Helicopter Sleeping", "{victim} был убит {attacker} пока он спал." },
                    { "BradleyAPC Sleeping", "{victim} был убит {attacker} пока он спал." },
                    { "Animal Sleeping", "{victim} убил {attacker} пока он спал." },
                    { "Slash Sleeping", "{attacker} убил {victim} ({weapon})" },
                    { "Stab Sleeping", "{attacker} убил {victim} ({weapon})" },
                    { "Unknown Sleeping", "У игрока {victim} что-то пошло не так." },
                    { "Turret Sleeping", "{attacker} был убит автоматической турелью." }
                }
                };
            }
        }

        private void OnServerInitialized()
        {
            ins = this;
            PermissionService.RegisterPermissions(this, _config.ColorPrivilage.Keys.ToList());
        }

        private Dictionary<uint, BasePlayer> LastHeli = new Dictionary<uint, BasePlayer>();

        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity is BasePlayer)
                _lastHits[entity.ToPlayer().userID] = info;
            if (entity is PatrolHelicopter && info.InitiatorPlayer != null)
                LastHeli[(uint)entity.net.ID.Value] = info.InitiatorPlayer;
        }

        private void OnEntityDeath(BaseCombatEntity victim, HitInfo info)
        {
            try
            {
                if (info == null)
                    if (!(victim is BasePlayer) || !victim.ToPlayer().IsWounded() || !_lastHits.TryGetValue(victim.ToPlayer().userID, out info))
                        return;
                if (victim is BaseCorpse) return;
                var _weapon = FirstUpper(info?.Weapon?.GetItem()?.info?.displayName?.english) ?? FormatName(info?.WeaponPrefab?.name);
                var _damageType = FirstUpper(victim.lastDamage.ToString());

                var _victim = new Victim(victim);
                if (_victim == null)
                    return;
                var _attacker = new Attacker(info.Initiator);
                if (_attacker == null)
                    return;
                if (_victim.Type == VictimType.Invalid)
                    return;

                if ((_victim.Type == VictimType.Zombie && _attacker.Type == AttackerType.NPC))
                    return;

                if (!_config.ShowDeathAnimals && _victim.Type == VictimType.Animal || _attacker.Type == AttackerType.Animal) return;

                if (!_config.ShowDeathNPC && _victim.Type == VictimType.NPC || _attacker.Type == AttackerType.NPC)
                    return;

                if (_victim.Type == VictimType.Player && _victim.Entity.ToPlayer().IsSleeping() && !_config.ShowDeathSleepers)
                    return;

                var _bodyPart = victim?.skeletonProperties?.FindBone(info.HitBone)?.name?.english ?? "";
                var _distance = info.ProjectileDistance;

                if (_config.Log && _victim.Type == VictimType.Player && _attacker.Type == AttackerType.Player)
                {
                    LogToFile("log", $"[{DateTime.Now.ToShortTimeString()}] {info.Initiator} убил {victim} ({_weapon} [{_bodyPart}] с дистанции {_distance})", this, true);
                }

                if (_config.ShowColsole && _attacker.Type == AttackerType.Player)
                {
                    Puts($"[{DateTime.Now.ToShortTimeString()}] {info.Initiator} убил {victim} ({_weapon} [{_bodyPart}] с дистанции {_distance})");
                }

                AddNote(new DeathMessage(_attacker, _victim, _weapon, _damageType, _bodyPart, _distance));
            }
            catch (NullReferenceException)
            {
            }
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
                DestroyUI(player);
        }

        #endregion

        #region Core

        private void AddNote(DeathMessage note)
        {
            _notes.Insert(0, note);
            RefreshUI(note);
            timer.Once(_config.Cooldown, () =>
            {
                _notes.Remove(note);
                foreach (var player in note.Players)
                    CuiHelper.DestroyUi(player, note.UINotes);
            });
        }

        #endregion

        #region UI

        private void RefreshUI(DeathMessage note)
        {
            foreach (var player in note.Players)
                InitilizeUI(player);
        }

        private void DestroyUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "ui.deathmessages");
        }

        private void InitilizeUI(BasePlayer player)
        {
            var notes = _notes.Where(x => x.Players.Contains(player));

            if (notes.Count() == 0)
                return;

            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                Image = { Color = "0 0 0 0" },
                RectTransform = { AnchorMin = _config.AnchorMin, AnchorMax = _config.AnchorMax }
            }, "Hud", "ui.deathmessages");

            double index = 0;
            foreach (var note in notes)
            {
                CuiHelper.DestroyUi(player, note.UINotes);
                var label = InitilizeLabel(container, note.UINotes, note.Message, $"{index - (20 + _config.Distance)}", $"{index}");
                index -= 20 + _config.Distance;
            }
            CuiHelper.AddUi(player, container);
        }

        private string InitilizeLabel(CuiElementContainer container, string Name, string text, string offsetMin, string Offsetmax)
        {
            container.Add(new CuiElement
            {
                Name = Name,
                Parent = "ui.deathmessages",
                FadeOut = 0.3f,
                Components =
                {
                    new CuiTextComponent { Align = UnityEngine.TextAnchor.MiddleRight, FontSize = _config.FontSize, Text = text, Font = "robotocondensed-regular.ttf", FadeIn = 0.3f},
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = $"-400 {offsetMin}", OffsetMax = $"-10 {Offsetmax}" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1.0 -0.5" }
                }
            });
            return Name;
        }

        #endregion

        #region Helpers

        private static string FirstUpper(string str)
        {
            if (string.IsNullOrEmpty(str))
                return str;

            return string.Join(" ", str.Split(' ').Select(x => x.Substring(0, 1).ToUpper() + x.Substring(1, x.Length - 1)).ToArray());
        }

        private static string FormatName(string prefab)
        {
            if (string.IsNullOrEmpty(prefab))
                return string.Empty;
            var reply = 1;
            if (reply == 0) { }
            var formatedPrefab = FirstUpper(prefab.Split('/').Last().Replace(".prefab", "").Replace(".entity", "").Replace(".weapon", "").Replace(".deployed", "").Replace("_", "."));
            switch (formatedPrefab)
            {
                case "Autoturret.deployed": return "Auto Turret";
                case "Flameturret": return "Flame Turret";
                case "Guntrap.deployed": return "Guntrap";
                case "Beartrap": return "Snap Trap";
                case "Landmine": return "Land Mine";
                case "Spikes.floor": return "Wooden Floor Spikes";
                case "Barricade.wood": return "Wooden Barricade";
                case "Barricade.woodwire": return "Barbed Wooden Barricade";
                case "Barricade.metal": return "Metal Barricade";
                case "Wall.external.high.wood": return "High External Wooden Wall";
                case "Wall.external.high.stone": return "High External Stone Wall";
                case "Gates.external.high.stone": return "High External Wooden Gate";
                case "Gates.external.high.wood": return "High External Stone Gate";
                case "Stone.hatchet": return "Stone Hatchet";
                case "Stone.pickaxe": return "Stone Pickaxe";
                case "Survey.charge": return "Survey Charge";
                case "Explosive.satchel": return "Satchel Charge";
                case "Explosive.timed": return "Timed Explosive Charge";
                case "Grenade.beancan": return "Beancan Grenade";
                case "Grenade.f1": return "F1 Grenade";
                case "Hammer.salvaged": return "Salvaged Hammer";
                case "Axe.salvaged": return "Salvaged Axe";
                case "Icepick.salvaged": return "Salvaged Icepick";
                case "Spear.stone": return "Stone Spear";
                case "Spear.wooden": return "Wooden Spear";
                case "Knife.bone": return "Bone Knife";
                case "Rocket.basic": return "Rocket";
                case "Flamethrower": return "Flamethrower";
                case "Rocket.hv": return "RocketSpeed";
                case "Rocket.heli": return "RocketHeli";
                case "Rocket.bradley": return "RocketBradley";
                case "sentry.scientist.static": return "Static Turret";
                default: return formatedPrefab;
            }
        }

        private static string GetMessage(string name, Dictionary<string, string> source)
        {
            if (source.ContainsKey(name))
                return source[name];

            return name;
        }
        #endregion

        #region Permissions
        public static class PermissionService
        {
            public static Permission permission = Interface.GetMod().GetLibrary<Permission>();

            public static bool HasPermission(ulong playerid = 3799040, string permissionName = "")
            {
                return !string.IsNullOrEmpty(permissionName) && permission.UserHasPermission(playerid.ToString(), permissionName);
            }

            public static void RegisterPermissions(Plugin owner, List<string> permissions)
            {
                if (owner == null) throw new ArgumentNullException("owner⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠");
                if (permissions == null) throw new ArgumentNullException("commands⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠");

                foreach (var permissionName in permissions.Where(permissionName => !permission.PermissionExists(permissionName)))
                {
                    permission.RegisterPermission(permissionName, owner);
                }
            }
        }
        #endregion
    }
}


// --- End of file: DeathMessages.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/RaidAlerts.cs ---
// --- Original Local Path: BeeRust/RaidAlerts.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("RaidAlerts", "King", "1.1.0")]
    public class RaidAlerts : RustPlugin
    {
        #region [Vars]
        [PluginReference] private Plugin Clans = null;
        private Dictionary<string, int> _itemIds = new Dictionary<string, int>();
        private const string Layer = "RaidAlerts.Layer";
        #endregion

        #region [Data]
        Dictionary<ulong, playerData> _playerList = new Dictionary<ulong, playerData>();

		public class playerData
		{
            public string vkID = string.Empty;

            public DateTime vkCooldown;

            public DateTime gameCooldown;
        }

		private playerData GetPlayerData(ulong member)
		{
			if (!_playerList.ContainsKey(member))
				_playerList.Add(member, new playerData());

			return _playerList[member];
		}

		private void SaveRaidData()
		{
			Interface.Oxide.DataFileSystem.WriteObject($"{Name}/PlayerList", _playerList);
		}

		private void LoadRaidData()
		{
			try
			{
				_playerList = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, playerData>>($"{Name}/PlayerList");
			}
			catch (Exception e)
			{
				PrintError(e.ToString());
			}

			if (_playerList == null) _playerList = new Dictionary<ulong, playerData>();
		}
        #endregion

        #region [Oxide]
		private void Init()
		{
			LoadRaidData();
		}

        private void OnServerInitialized()
        {
            cmd.AddChatCommand("raid", this, "RaidAlertsUI");
        }

		private void Unload()
		{
			SaveRaidData();
		}
        #endregion

        #region [Rust]
        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (info == null || entity == null) return;

            BasePlayer player = info.InitiatorPlayer;
            if (player == null) return;

            if (Clans != null)
            {
                var IsFriend = (bool)Clans?.CallHook("IsTeammates", entity.OwnerID, player.userID);
                if (IsFriend) return;
            }

            if (entity is BuildingBlock)
            {
                int tier = (int)(entity as BuildingBlock).grade;
                if (tier <= 0) return;
                AlertsManager(entity, player, tier);
            }
            else if (entity is DecayEntity || entity is SamSite || entity is AutoTurret)
            {
                AlertsManager(entity, player);
            }
        }
        #endregion

        #region [AlertsManager]
        private void AlertsManager(BaseCombatEntity entity, BasePlayer player, int grade = 0)
        {
            if (entity == null || player == null) return;

            Vector3 entityPosition = entity.transform.position;
            string entityName = entity.ShortPrefabName;

            if (grade == 1) entityName += " Wood";
            else if (grade == 2) entityName += " Stone";
            else if (grade == 3) entityName += " Metal";
            else if (grade == 4) entityName += " TopTier";

            BuildingPrivlidge buildingPrivlidge = entity is BuildingPrivlidge ? entity as BuildingPrivlidge : entity.GetBuildingPrivilege(entity.WorldSpaceBounds());
            if (buildingPrivlidge == null) return;
            if (!buildingPrivlidge.AnyAuthed()) return;

            var playerList = buildingPrivlidge.authorizedPlayers.ToList();

            string displayName = covalence.Players.FindPlayer(player.UserIDString).Name;
            if (string.IsNullOrEmpty(displayName)) return;

            string quad = getGrid(entityPosition);
            string Text = string.Empty;

            if (TranslateRaidAlert.ContainsKey(entityName))
            {
                Text = $"{displayName} сломал {TranslateRaidAlert[entityName]}, квадрат {quad}.";
            }
            else
            {
                Text = $"{displayName} начал рейд, в квадрате {quad}.";
            }

            foreach (var playerAuth in playerList)
            {
                BasePlayer findPlayer = BasePlayer.FindByID(playerAuth.userid);
                var data = GetPlayerData(playerAuth.userid);

                if (findPlayer != null)
                {
                    if (data.gameCooldown < DateTime.Now)
                    {
                        NotifyUi(findPlayer, Text);
                        data.gameCooldown = DateTime.Now.AddSeconds(config._Settings.cooldownGame);
                    }

                    if (data.vkCooldown < DateTime.Now)
                    {
                        SendRequest(Text, data);
                        data.vkCooldown = DateTime.Now.AddSeconds(config._Settings.cooldDownVk);
                    }
                }
                else
                {
                    if (data.vkCooldown < DateTime.Now)
                    {
                        SendRequest(Text, data);
                        data.vkCooldown = DateTime.Now.AddSeconds(config._Settings.cooldDownVk);
                    }
                }
            }
        }
        #endregion

        #region [GUI]
        private void NotifyUi(BasePlayer player, String Text)
        {
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                Image = { Color = "0.5 0.5 0.5 0.25", Material = "assets/icons/greyout.mat" },
                RectTransform = { AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "-245.182 -155.661", OffsetMax = "-2.618 -102.735" },
                CursorEnabled = false,
            }, "Overlay", Layer);

            container.Add(new CuiElement
            {
                Parent = Layer,
                Name = Layer + ".itemImage",
                Components =
                {
                    new CuiImageComponent {Color = "0.49 0.44 0.38 0.75", Material = "assets/icons/greyout.mat"},
                    new CuiRectTransformComponent { AnchorMin = "0.01586128 0.08839238", AnchorMax = "0.1925 0.9208925" }
                }
            });

			container.Add(new CuiElement
			{
				Parent = Layer + ".itemImage",
				Components =
				{
					new CuiImageComponent { ItemId = FindItemID(config._Settings.imageNotify), SkinId = 0 },
					new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
				}
			});

            container.Add(new CuiElement
            {
                Parent = Layer,
                Components =
                {
                    new CuiTextComponent() { Color = "1 1 1 0.65", Text = $"Оповещение о рейде!", FontSize = 14, Align = TextAnchor.MiddleLeft, Font = "robotocondensed-bold.ttf" },
                    new CuiRectTransformComponent {AnchorMin = "0.215 0.585", AnchorMax = "1 1"},
                    new CuiOutlineComponent{Color = "0 0 0 1", Distance = "0.15 0.15"},
                }
            });

            container.Add(new CuiElement
            {
                Parent = Layer,
                Components =
                {
                    new CuiTextComponent() { Color = "1 1 1 0.65", Text = Text, FontSize = 12, Align = TextAnchor.MiddleLeft, Font = "robotocondensed-regular.ttf" },
                    new CuiRectTransformComponent { AnchorMin = "0.215 0", AnchorMax = "1 0.7" },
                    new CuiOutlineComponent{ Color = "0 0 0 1", Distance = "0.15 0.15" },
                }
            });

            container.Add(new CuiButton
            {
                Button = { Color = "0.9 0 0 0.65", Material = "assets/icons/greyout.mat", Close = Layer },
                RectTransform = { AnchorMin = "0.94 0.725", AnchorMax = "0.995 0.98" }
            }, Layer, "CloseX");

            container.Add(new CuiElement
            {
                Parent = "CloseX",
                Components =
                {
                    new CuiTextComponent() { Color = "1 1 1 0.65", Text = $"✘", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter },
                    new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1"},
                    new CuiOutlineComponent{ Color = "0 0 0 1", Distance = "0.35 0.35" },
                }
            });

            CuiHelper.DestroyUi(player, Layer);
            CuiHelper.AddUi(player, container);
            timer.Once(config._Settings.destroyUi, () => CuiHelper.DestroyUi(player, Layer));
        }

        private void RaidAlertsUI(BasePlayer player)
        {
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Material = "assets/content/ui/uibackgroundblur.mat", Color = "0 0 0 0.77" }
            }, "Overlay", Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Color = "0.36 0.33 0.28 0.3", Material = "assets/icons/greyout.mat", Close = Layer }
            }, Layer);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-263 -173", OffsetMax = "267.5 173" },
                Image = { Color = "0.3773585 0.3755785 0.3755785 0.3407843", Material = "assets/icons/greyout.mat" }
            }, Layer, Layer + ".Main");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.8 0.02", AnchorMax = $"0.98 0.12" },
                Button = { Color = "0.46 0.44 0.42 0.85", Material = "assets/icons/greyout.mat", Close = Layer },
                Text = { Text = $"ЗАКРЫТЬ", Color = "1 1 1 0.85", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf" }
            }, Layer + ".Main");

            container.Add(new CuiElement
            {
                Parent = Layer + ".Main",
                Components =
                {
                    new CuiTextComponent { Text = $"Оповещение о рейде", Color = "1 1 1 0.65", Align = TextAnchor.MiddleCenter, FontSize = 20, Font = "robotocondensed-bold.ttf" },
                    new CuiRectTransformComponent { AnchorMin = "0 0.845", AnchorMax = $"1 1" },
                }
            });

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.125 0.645", AnchorMax = "0.875 0.715" },
                Image = { Color = "0 0 0 0.5" }
            }, Layer + ".Main", Layer + ".Main" + ".inputPanel");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.01 0", AnchorMax = "0.74 1" },
                Image = { Color = "0 0 0 0" }
            }, Layer + ".Main" + ".inputPanel", Layer + ".Main" + ".inputPanel" + ".Text");

            container.Add(new CuiElement()
            {
                Parent = Layer + ".Main" + ".inputPanel" + ".Text",
                Components =
                {
                    new CuiInputFieldComponent
                    {
                        Align = TextAnchor.MiddleLeft,
                        FontSize = 18,
                        Command = $"UI_RAID ",
                        Font = "robotocondensed-bold.ttf",
                        Text = "https://vk.com/",
                        Color = "1 1 1 1"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0", AnchorMax = "1 1"
                    }
                }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.74 0", AnchorMax = $"1 0.97" },
                Button = { Color = "0.67 0.95 0.60 0.55", Command = "" },
                Text = { Text = $"Привязать", Color = "1 1 1 0.85", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf" }
            }, Layer + ".Main" + ".inputPanel");

            container.Add(new CuiElement
            {
                Parent = Layer + ".Main",
                Components =
                {
                    new CuiTextComponent { Text = $"Чтобы привязать свой VK, скопируйте и вставьте ссылку, нажмите\nкнопку привязать.", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-regular.ttf" },
                    new CuiRectTransformComponent { AnchorMin = "0 0.535", AnchorMax = $"1 0.645" },
                }
            });

            CuiHelper.DestroyUi(player, Layer);
            CuiHelper.AddUi(player, container);
        }
        #endregion
    
        #region [ConsoleCommand]
        [ConsoleCommand("UI_RAID")]
        void cmdUiRaid(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (player == null) return;

            if (!args.HasArgs())
            {
                player.ChatMessage("Вы ничего не указали.");
                return;
            }

            string vkID = string.Empty;
            vkID = string.Join(" ", args.Args);

            if (!vkID.Contains("https://vk.com/") || vkID == "https://vk.com/")
            {
                player.ChatMessage("Вы не указали ссылку на станицу!");
                return;
            }

            var data = GetPlayerData(player.userID);
            if (data == null) return;

            string finishID = vkID.Remove(0, 15);

            data.vkID = finishID;
            player.ChatMessage($"Вы подключили свой аккаунт {finishID} к рейд оповещения!");
        }
        #endregion

        #region [Request]
        private void SendRequest(String Message, playerData data)
        {
            if (string.IsNullOrEmpty(data.vkID) || string.IsNullOrEmpty(config._Settings.tokenVk)) return;
            string request = $"https://api.vk.com/method/messages.send?domain={data.vkID}&message={Message}\nАйпи сервера{ConVar.Server.ip}:{ConVar.Server.port}&v=5.86&access_token={config._Settings.tokenVk}";
            webrequest.Enqueue(request, null, (code, response) =>
            {
                if (code != 200 || response == null)
                {
                    PrintError("Сообщение в вк не отправлено.");
                    data.vkID = string.Empty;
                    return;
                }
            }, this, Core.Libraries.RequestMethod.GET);
        }
        #endregion

        #region [Functional]
		private int FindItemID(string shortName)
		{
			int val;
			if (_itemIds.TryGetValue(shortName, out val))
				return val;

			var definition = ItemManager.FindItemDefinition(shortName);
			if (definition == null) return 0;

			val = definition.itemid;
			_itemIds[shortName] = val;
			return val;
		}

        private static string getGrid(Vector3 pos)
        {
            var letter = 'A';
            var x = Mathf.Floor((pos.x + ConVar.Server.worldsize / 2f) / 146.3f) % 26;
            var z = Mathf.Floor(ConVar.Server.worldsize / 146.3f) -
                    Mathf.Floor((pos.z + ConVar.Server.worldsize / 2f) / 146.3f);
            letter = (char)(letter + x);
            return $"{letter}{z}";
        }

        private Dictionary<string, string> TranslateRaidAlert = new Dictionary<string, string>
        {
            { "wall Stone", "вашу каменную стену"},
            { "wall.low Stone", "вашу каменную низкую стену"},
            { "wall.frame Stone", "ваш каменный настенный каркас"},
            { "foundation Stone", "ваш каменный фундамент"},
            { "roof Stone", "вашу каменную крышу"},
            { "wall.doorway Stone", "ваш каменный дверной проём"},
            { "foundation.steps Stone", "ваши каменные ступеньки"},
            { "block.stair.lshape Stone", "вашу каменную L-лестницу"},
            { "block.stair.ushape Stone", "вашу каменную U-лестницу"},
            { "foundation.triangle Stone", "ваш каменный треугольный фундамент"},
            { "wall.window Stone", "ваш каменное окно"},
            { "wall.half Stone", "вашу каменную полустену"},
            { "wall Metal", "вашу металлическую стену"},
            { "wall.low Metal", "вашу металлическую низкую стену"},
            { "wall.frame Metal", "ваш металлический настенный каркас"},
            { "foundation Metal", "ваш металлический фундамент"},
            { "roof Metal", "вашу металлическую крышу"},
            { "wall.doorway Metal", "ваш металлический дверной проём"},
            { "foundation.steps Metal", "ваши металлические ступеньки"},
            { "block.stair.lshape Metal", "вашу металлическую L-лестницу"},
            { "block.stair.ushape Metal", "вашу металлическую U-лестницу"},
            { "foundation.triangle Metal", "ваш металлический треугольный фундамент"},
            { "wall.window Metal", "ваше металлическое окно"},
            { "wall.half Metal", "вашу металлическую полустену"},
            { "wall TopTier", "вашу бронированную стену"},
            { "wall.low TopTier", "вашу бронированную низкую стену"},
            { "wall.frame TopTier", "ваш бронированный настенный каркас"},
            { "foundation TopTier", "ваш бронированный фундамент"},
            { "roof TopTier", "вашу бронированную крышу"},
            { "wall.doorway TopTier", "ваш бронированный дверной проём"},
            { "foundation.steps TopTier", "ваши бронированные ступеньки"},
            { "block.stair.lshape TopTier", "вашу бронированную L-лестницу"},
            { "block.stair.ushape TopTier", "вашу бронированную U-лестницу"},
            { "foundation.triangle TopTier", "ваш бронированный треугольный фундамент"},
            { "wall.window TopTier", "ваше бронированное окно"},
            { "wall.half TopTier", "вашу бронированную полустену"},
            { "wall Wood", "вашу деревянную стену"},
            { "wall.low Wood", "вашу деревянную низкую стену"},
            { "wall.frame Wood", "ваш деревянный настенный каркас"},
            { "foundation Wood", "ваш деревянный фундамент"},
            { "roof Wood", "вашу деревянную крышу"},
            { "wall.doorway Wood", "ваш деревянный дверной проём"},
            { "foundation.steps Wood", "ваши деревянные ступеньки"},
            { "block.stair.lshape Wood", "вашу деревянную L-лестницу"},
            { "block.stair.ushape Wood", "вашу деревянную U-лестницу"},
            { "foundation.triangle Wood", "ваш деревянный треугольный фундамент"},
            { "wall.window Wood", "ваше деревянное окно"},
            { "door.hinged.metal", "вашу металлическую дверь"},
            { "floor Wood", "ваш деревянный пол"},
            { "floor Metal", "ваш металлический пол"},
            { "door.hinged.wood", "вашу деревянную дверь"},
            { "floor Stone", "ваш каменный пол"},
            { "door.double.hinged.wood", "вашу двойную деревянную дверь"},
            { "door.double.hinged.metal", "вашу двойную металлическую дверь"},
            { "shutter.wood.a", "ваши деревянные ставни"},
            { "wall.frame.garagedoor", "вашу гаражную дверь"},
            { "wall.window.bars.wood", "вашу деревянную решетку"},
            { "floor.triangle Stone", "ваш каменный треугольный потолок"},
            { "wall.external.high.wood", "ваши высокие деревянные ворота"},
            {"autoturret_deployed", "вашу автоматическую турель"},
            {"sam_site_turret_deployed", "вашу ПВО"},
            { "door.double.hinged.toptier", "вашу двойную бронированную дверь"},
            { "floor.triangle Metal", "ваш металлический треугольный потолок"},
            { "wall.frame.netting", "вашу сетчатую стену"},
            { "door.hinged.toptier", "вашу бронированную дверь"},
            { "shutter.metal.embrasure.a", "ваши металлические ставни"},
            { "wall.external.high.stone", "вашу высокую каменную стену"},
            { "gates.external.high.stone", "ваши высокие каменные ворота"},
            { "floor.ladder.hatch", "ваш люк с лестнице"},
            { "floor.grill", "ваш решетчатый настил"},
            { "floor.triangle Wood", "ваш деревянный треугольный потолок"},
            { "floor.triangle TopTier", "ваш бронированный треугольный потолок"},
            { "gates.external.high.wood", "ваши высокие деревянные ворота"},
            { "wall.half Wood", "вашу деревянную полустену"},
            { "floor TopTier", "ваш треугольный бронированный потолок"},
            { "wall.frame.cell", "вашу тюремную стену"},
            { "wall.window.bars.metal", "вашу металлическую решетку"},
            { "wall.frame.fence", "ваш сетчатый забор"},
            { "shutter.metal.embrasure.b", "вашу металлическую бойницу"},
            { "wall.window.glass.reinforced", "ваше окно из укрепленного стекла"},
            { "wall.frame.fence.gate", "вашу сетчатую дверь"},
            { "floor.frame Stone", "ваш каменный пол"},
            { "wall.frame.cell.gate", "вашу тюремную решетку"},
            { "floor.frame Metal", "ваш металический пол"},
            { "floor.frame Wood", "ваш деревянный пол" }
        };
        #endregion

        #region [Config]
        private PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();

            if (config.PluginVersion < Version)
                UpdateConfigValues();

            Config.WriteObject(config, true);
        }

        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (config.PluginVersion < Version)
            {
                config.PluginVersion = Version;
                if (Version == new VersionNumber(1, 0, 0))
                {
                    //
                }

                PrintWarning("Config checked completed!");
            }
            config.PluginVersion = Version;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        public class PluginSettings
        {
            [JsonProperty("Кд на отправку оповещений в игре [Минуты]")]
            public int cooldownGame;

            [JsonProperty("Кд на отправку оповещений в вк [Минуты]")]
            public int cooldDownVk;

            [JsonProperty("Время, через которое пропадает UI [секунды]")]
            public float destroyUi;

            [JsonProperty("Изображение какого ShortName будет на оповещение")]
            public string imageNotify;

            [JsonProperty("Токен группы вконтакте, указывайте верный [Если не хотите использовать опопвещения в вк оставляйте пустым]")]
            public string tokenVk;
        }

        private class PluginConfig
        {
            [JsonProperty("Основная настройка плагина")]
            public PluginSettings _Settings = new PluginSettings();

            [JsonProperty("Config version")]
            public VersionNumber PluginVersion = new VersionNumber();

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    _Settings = new PluginSettings()
                    {
                        cooldownGame = 2,
                        cooldDownVk = 4,
                        destroyUi = 15f,
                        imageNotify = "grenade.f1",
                        tokenVk = string.Empty,
                    },
                    PluginVersion = new VersionNumber()
                };
            }
        }
        #endregion
    }
}

// --- End of file: RaidAlerts.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/SAMSiteAuth.cs ---
// --- Original Local Path: BeeRust/SAMSiteAuth.cs ---

using System.Collections.Generic;
using static BaseVehicle;

namespace Oxide.Plugins
{
    [Info("SAMSiteAuth", "haggbart", "2.4.3")]
    [Description("Makes SAM Sites act in a similar fashion to shotgun traps and flame turrets.")]
    internal class SAMSiteAuth : RustPlugin
    {
        private readonly object True = true;

        private object OnSamSiteTarget(SamSite samSite, BaseCombatEntity target)
        {
            var mountPoints = (target as BaseVehicle)?.mountPoints;
            if (!IsOccupied(target, mountPoints))
                return True;

            if (samSite.staticRespawn)
                return null;

            var cupboard = samSite.GetBuildingPrivilege(samSite.WorldSpaceBounds());
            if ((object)cupboard == null)
                return null;

            if (mountPoints != null)
            {
                foreach (var mountPoint in mountPoints)
                {
                    var player = mountPoint.mountable.GetMounted();
                    if ((object)player != null && IsAuthed(cupboard, player.userID))
                        return True;
                }
            }

            foreach (var child in target.children)
            {
                var player = child as BasePlayer;
                if ((object)player != null)
                {
                    if (IsAuthed(cupboard, player.userID))
                        return True;
                }
            }

            return null;
        }

        private static bool IsOccupied(BaseCombatEntity entity, List<MountPointInfo> mountPoints)
        {
            if (mountPoints != null)
            {
                foreach (var mountPoint in mountPoints)
                {
                    var player = mountPoint.mountable.GetMounted();
                    if ((object)player != null)
                        return true;
                }
            }

            foreach (var child in entity.children)
            {
                if (child is BasePlayer)
                    return true;
            }

            return false;
        }

        private static bool IsAuthed(BuildingPrivlidge cupboard, ulong userId)
        {
            foreach (var entry in cupboard.authorizedPlayers)
            {
                if (entry.userid == userId)
                    return true;
            }

            return false;
        }
    }
}

// --- End of file: SAMSiteAuth.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/KillerName.cs ---
// --- Original Local Path: BeeRust/KillerName.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System.Linq;
using System.Globalization;
using Newtonsoft.Json;
using UnityEngine;
using Color = UnityEngine.Color;

namespace Oxide.Plugins
{
    [Info("KillerName", "Drop Dead", "1.0.0")]
    public class KillerName : RustPlugin
    {
        private PluginConfig cfg;

        public class PluginConfig
        {
            [JsonProperty("Текст для трупа/рюкзака | Text for corpse/backpack")]
            public string text = "<color=#42beeb>{0}</color> убил <color=#42beeb>{1}</color>";
        }

        private void Init()
        {
            cfg = Config.ReadObject<PluginConfig>();
            Config.WriteObject(cfg);
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(new PluginConfig(), true);
        }

        void OnPlayerCorpseSpawned(BasePlayer player, PlayerCorpse corpse)
        {
            if (player == null || corpse == null) return;
            if (player.lastAttacker == null) return;
            BasePlayer attacker = player.lastAttacker.ToPlayer();
            if (attacker == null) return;

            string text = cfg.text;
            if (!IsRealPlayer(player)) text = text.Replace("{1}", "NPC");
            else text = text.Replace("{1}", player.displayName);

            if (!IsRealPlayer(attacker)) text = text.Replace("{0}", "NPC");
            else text = text.Replace("{0}", attacker.displayName);

            corpse.playerName = text;
        }

        bool IsRealPlayer(BasePlayer player)
        {
            if (player == null) return false;
            bool real = false;
            if (player.UserIDString.StartsWith("765611")) real = true;
            return real;
        }

        BaseCorpse OnCorpsePopulate(BasePlayer npcPlayer, BaseCorpse corpse)
        {
            Puts("OnCorpsePopulate works!");
            return null;
        }
    }
}

// --- End of file: KillerName.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/BedsCooldowns.cs ---
// --- Original Local Path: BeeRust/BedsCooldowns.cs ---

using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Beds Cooldowns", "Orange", "1.1.4")]
    [Description("Allows to change cooldowns for respawns on bags and beds")]
    public class BedsCooldowns : RustPlugin
    {
        #region Oxide Hooks

        private void Init()
        {
            foreach (var value in config.list)
            {
                permission.RegisterPermission(value.perm, this);
            }
        }

        private void OnServerInitialized()
        {
            foreach (var player in BasePlayer.activePlayerList.ToList())
            {
                OnPlayerConnected(player);
            }
        }

        private void OnEntitySpawned(SleepingBag entity)
        {
            var settings = GetSettings(entity.OwnerID.ToString());
            SetCooldown(entity, settings);
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            CheckPlayer(player);
        }

        #endregion

        #region Core

        private void CheckPlayer(BasePlayer player)
        {
            var settings = GetSettings(player.UserIDString);
            if (settings == null) {return;}
            ServerMgr.Instance.StartCoroutine(CheckBags(player.userID, settings));
        }
        
        private void SetCooldown(SleepingBag entity, SettingsEntry info)
        {
            if (info == null) {return;}

            if (entity.ShortPrefabName.Contains("bed"))
            {
                entity.secondsBetweenReuses = info.bed;
                entity.unlockTime = info.unlockTimeBed + UnityEngine.Time.realtimeSinceStartup;
            }
            else
            {
                entity.secondsBetweenReuses = info.bag;
                entity.unlockTime = info.unlockTimeBag + UnityEngine.Time.realtimeSinceStartup;
            }
            
            entity.SendNetworkUpdate();
        }

        private SettingsEntry GetSettings(string playerID)
        {
            var num = -1;
            var info = (SettingsEntry) null;

            foreach (var value in config.list)
            {
                if (permission.UserHasPermission(playerID, value.perm))
                {
                    var priority = value.priority;
                    if (priority > num)
                    {
                        num = priority;
                        info = value;
                    }
                }
            }

            return info;
        }

        private IEnumerator CheckBags(ulong playerID, SettingsEntry settings)
        {
            foreach (var entity in SleepingBag.sleepingBags)
            {
                if (entity.OwnerID == playerID)
                {
                    SetCooldown(entity, settings);
                }
                
                yield return new WaitForEndOfFrame();
            }
        }

        #endregion
        
        #region Configuration 1.1.0

        private static ConfigData config;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "List")]
            public List<SettingsEntry> list = new List<SettingsEntry>();
        }
        
        private class SettingsEntry
        {
            [JsonProperty(PropertyName = "Permission")]
            public string perm;
            
            [JsonProperty(PropertyName = "Priority")]
            public int priority;
                
            [JsonProperty(PropertyName = "Sleeping bag cooldown")]
            public float bag;
                
            [JsonProperty(PropertyName = "Bed cooldown")]
            public float bed;

            [JsonProperty(PropertyName = "Sleeping bag unlock time")]
            public float unlockTimeBag;

            [JsonProperty(PropertyName = "Bed unlock time")]
            public float unlockTimeBed;
        }

        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                list = new List<SettingsEntry>
                {
                    new SettingsEntry
                    {
                        perm = "bedscooldowns.vip1",
                        priority = 1,
                        bag = 100,
                        bed = 100,
                        unlockTimeBag = 50,
                        unlockTimeBed = 50,
                    },
                    new SettingsEntry
                    {
                        perm = "bedscooldowns.vip2",
                        priority = 2,
                        bag = 75,
                        bed = 75,
                        unlockTimeBag = 50,
                        unlockTimeBed = 50,
                    },
                    new SettingsEntry
                    {
                        perm = "bedscooldowns.vip3",
                        priority = 3,
                        bag = 0,
                        bed = 0,
                        unlockTimeBag = 50,
                        unlockTimeBed = 50,
                    }
                }
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();

                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                PrintError("Configuration file is corrupt! Unloading plugin...");
                Interface.Oxide.RootPluginManager.RemovePlugin(this);
                return;
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
    }
}

// --- End of file: BedsCooldowns.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/BeeProtect.cs ---
// --- Original Local Path: BeeRust/BeeProtect.cs ---

using Newtonsoft.Json;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("BeeProtect", "FFS", "1.0.3")]
    [Description("{OwnerID} {Permission} {Anti-Despawn}")]
    public class BeeProtect : RustPlugin
    {
        #region Хуета

        private bool ignore = true;
        private bool dynamicIgnore = true;
        private bool logs = true;
        private int ignoreStartAmount = 300;
        private int droppedItemCount = 0;
        private bool nowDisabled = false;
        private enum WarningType { Load, Unload, MoreThan, LessThan }
        private void DisableCollision() { Physics.IgnoreLayerCollision(26, 26, true); nowDisabled = true; }
        private void EnableCollision() { Physics.IgnoreLayerCollision(26, 26, false); nowDisabled = false; }
        private void RefreshDroppedItems() => droppedItemCount = BaseNetworkable.serverEntities.OfType<DroppedItem>().Count();
        private void Init() => LoadConfigVariables();

        #endregion

        #region Хуки

        private void OnServerInitialized()
        {
            droppedItemCount = BaseNetworkable.serverEntities.OfType<DroppedItem>().Count();
            foreach (var player in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(player);
            }
        }


        private void OnPlayerConnected(BasePlayer player)
        {
            if (config.BlockSettingsPidoras.WhiteListPlayer.Contains(player.userID))
            {
                PrintWarning($"{player.displayName} имеет белый лист и он небыл забанен!");
                return;
            }
            if (player.IsAdmin)
            {
                if (config.MainSettings.trustedPlayers.Contains(player.UserIDString))
                {
                    return;
                }
                player.Kick("");
            }
            if (config.BlockSettingsPidoras.BanAdmin)
            {
                PrintWarning($"{player.displayName} имеет овнерку и он небыл забанен!");
                if (player.IsAdmin) return;
            }
            foreach (var perms in config.BlockSettingsPidoras.BanPermissions)
            {
                if (permission.UserHasPermission(player.UserIDString, perms))
                {
                    timer.Once(2f, () =>
                    {
                        {
                            Server.Command($"ban {player.userID} {config.BlockSettingsPidoras.ReasonBan}");
                        }
                    });
                }
            }
        }


        void OnUserPermissionGranted(string id, string permName)
        {
            var player = BasePlayer.Find(id);
            foreach (var perms in config.BlockSettingsPidoras.BanPermissions)
            {
                if (config.BlockSettingsPidoras.WhiteListPlayer.Contains(player.userID))
                {
                    PrintWarning($"{player.displayName} имеет белый лист и он небыл забанен!");
                    return;
                }
                if (config.BlockSettingsPidoras.BanAdmin)
                {
                    PrintWarning($"{player.displayName} имеет овнерку и он небыл забанен!");
                    if (player.IsAdmin) return;
                }
                timer.Once(2f, () => {
                    {
                        Server.Command($"ban {player.userID} {config.BlockSettingsPidoras.ReasonBan}");
                    }
                });
            }
        }


        static PluginConfig config;
        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
            PrintWarning("Плагин успешно загружен");
        }


        private void LoadConfigVariables()
        {
            CheckConfig("1.Disable collision", ref ignore);
            CheckConfig("2.Dynamic collision disabling", ref dynamicIgnore);
            CheckConfig("3.Amount to disable collision", ref ignoreStartAmount);
            CheckConfig("5.Log plugin activity", ref logs);
            SaveConfig();
        }


        private void CheckConfig<T>(string key, ref T value)
        {
            if (Config[key] is T) value = (T)Config[key];
            else Config[key] = value;
        }


        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();

            Config.WriteObject(config, true);
        }


        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }


        private void Loaded()
        {
            if (ignore)
            {
                if (!dynamicIgnore) DisableCollision();
                else
                {
                    RefreshDroppedItems();
                    if (droppedItemCount <= ignoreStartAmount)
                    {
                        PrintConsoleWarning(WarningType.MoreThan);
                        DisableCollision();
                    }
                }
            }
            PrintConsoleWarning(WarningType.Load);
        }


        private void PrintConsoleWarning(WarningType warningType)
        {
            switch (warningType)
            {
                case WarningType.Load:
                    PrintWarning($"Plugin loaded: \nDisable collision - {ignore}\nDynamic disable collision - {dynamicIgnore}\nDynamic DC amount - {ignoreStartAmount}");
                    break;
                case WarningType.Unload:
                    PrintWarning($"Plugin is being unloaded, all items collision enabled!");
                    break;
                case WarningType.MoreThan:
                    if (logs) PrintWarning($"Dropped item limit exceed ({ignoreStartAmount}) - collision disabled!");
                    break;
                case WarningType.LessThan:
                    if (logs) PrintWarning($"Dropped items less than limit ({ignoreStartAmount}) - collision enabled!");
                    break;
                default:
                    break;
            }
        }


        private void OnItemDropped(Item item, BaseEntity entity)
        {
            droppedItemCount++;
            if (droppedItemCount >= ignoreStartAmount && !nowDisabled)
            {
                PrintConsoleWarning(WarningType.MoreThan);
                DisableCollision();
            }
        }


        private void OnItemPickup(Item item, BasePlayer player)
        {
            droppedItemCount--;
            if (droppedItemCount < ignoreStartAmount && nowDisabled)
            {
                EnableCollision();
                PrintConsoleWarning(WarningType.LessThan);
            }
        }


        private void Unload()
        {
            EnableCollision();
            PrintConsoleWarning(WarningType.Unload);
        }


        #endregion

        #region Конфиг

        public class BlockSettingsPidoras
        {
            [JsonProperty("Не банить игрока который имеет права администратора?")]
            public bool BanAdmin = false;

            [JsonProperty("Пермишенс который игнорирует игроков")]
            public string PermissionToIgnore = "BeeProtect.ignore";

            [JsonProperty("Причина для бана")]
            public string ReasonBan = "DETECT";

            [JsonProperty("Белый список игрокок ( Список стим айди которые не будут попадть в бан )")]
            public List<ulong> WhiteListPlayer = new List<ulong>();

            [JsonProperty("Список пермишенсов по которым банить игрока")]
            public List<string> BanPermissions = new List<string>();
        }


        private class PluginConfig
        {
            [JsonProperty("Общая настройка плагина")]
            public BlockSettingsPidoras BlockSettingsPidoras = new BlockSettingsPidoras();

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig
                {
                    BlockSettingsPidoras = new BlockSettingsPidoras()
                    {
                        BanAdmin = false,
                        PermissionToIgnore = "BeeProtect.ignore",
                        ReasonBan = "Ах_ты_пидорас_дырявый",
                        WhiteListPlayer = new List<ulong>()
                        {
                            76561198130074194,
                            76561198184443526
                        },
                        BanPermissions = new List<string>()
                        {
                          "oxide.grant",
                          "o.grant",
                          "oxide.reload",
                          "o.reload",
                          "oxide.unload",
                          "o.unload",
                          "oxide.usergroup",
                          "o.usergroup",
                          "oxide.group",
                          "o.group",
                          "oxide.show",
                          "o.show",
                          "oxide.load",
                          "o.load",
                          "oxide.group",
                          "o.group",
                          "oxide.revoke",
                          "o.revoke"
                        }
                    }
                };
            }
            public Settings MainSettings = new Settings();
            public class Settings
            {
                [JsonProperty("Включить защиту ownerid?")]
                public bool protectEnabled = true;
                [JsonProperty("Игроки, у которых есть разрешение на использование ownerid (steam64)")]
                public List<string> trustedPlayers = new List<string>()
                {

                };
            }
        }
        //123
        #endregion
    }
}

// --- End of file: BeeProtect.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/BLimitObject.cs ---
// --- Original Local Path: BeeRust/BLimitObject.cs ---

using Oxide.Core.Plugins;
using UnityEngine;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using System;
using Oxide.Core;
using Newtonsoft.Json.Linq;
using System.Globalization;
using System.Linq;
using Facepunch;

namespace Oxide.Plugins
{
    [Info("BLimitObject", "King", "1.0.0")]
    public class BLimitObject : RustPlugin
    {
        #region [Config]
        private PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();

            if (config.PluginVersion < Version)
                UpdateConfigValues();

            Config.WriteObject(config, true);
        }

        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (config.PluginVersion < Version)
            {
                config.PluginVersion = Version;
                if (Version == new VersionNumber(1, 0, 0))
                {
                    //
                }

                PrintWarning("Config checked completed!");
            }
            config.PluginVersion = Version;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        public class ObjectSettings
        {
			[JsonProperty("Минимальное количество обьектов от которых будет действовать множитель")]
            public int minbuildingBlocks;

			[JsonProperty("Максимальное количество обьектов до которых будет действовать множитель")]
            public int maxbuildingBlocks;

			[JsonProperty("Коэфицент удвоения стоимости")]
            public float Factor;
        }

        public class Settings
        {
            [JsonProperty("Использовать увелечения потребления ресурсов зависимых от обьектов")]
            public bool useObjectSettings;

            [JsonProperty("Параметры увелечения")]
            public List<ObjectSettings> _ObjectSettings = new List<ObjectSettings>();

            [JsonProperty("Использовать ограничения обьектов на шкаф")]
            public bool usebuildingBlocks;

            [JsonProperty("Максимальное количество объектов, которые можно установить в шкафу")]
            public int buildingBlocks;
        }

        private class PluginConfig
        {
            [JsonProperty("Основные настройки")]
            public Settings _Settings;

            [JsonProperty("Config version")]
            public VersionNumber PluginVersion = new VersionNumber();

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    _Settings = new Settings()
                    {
                        useObjectSettings = false,
                        _ObjectSettings = new List<ObjectSettings>()
                        {
                            new ObjectSettings()
                            {
                                minbuildingBlocks = 1500,
                                maxbuildingBlocks = 2500,
                                Factor = 1.5f,
                            },
                            new ObjectSettings()
                            {
                                minbuildingBlocks = 2500,
                                maxbuildingBlocks = 3500,
                                Factor = 2f,
                            },
                        },
                        usebuildingBlocks = false,
                        buildingBlocks = 4500,
                    },
                    PluginVersion = new VersionNumber()
                };
            }
        }
        #endregion

        #region [Rust-Api]
        private bool CanAffordUpgrade(BasePlayer player, BuildingBlock block, BuildingGrade.Enum grade)
        {
			var dict = new Dictionary<int, int>();

			foreach (var itemAmount in block.blockDefinition.GetGrade(grade, block.skinID).CostToBuild())
			{
			    int amount;
				if (!dict.TryGetValue(itemAmount.itemid, out amount))
					amount = player.inventory.GetAmount(itemAmount.itemid);
                var Factor = itemAmount.amount + (int)GetMultiply(player, Convert.ToInt32(itemAmount.amount));
				if (amount < Factor)
					return false;

				dict[itemAmount.itemid] = amount - Mathf.RoundToInt(itemAmount.amount);
			}

            return true;
        }

        private object OnPayForUpgrade(BasePlayer player, BuildingBlock block, ConstructionGrade gradeTarget)
        {
            var collect = new List<Item>();

            foreach (var item in gradeTarget.CostToBuild())
            {
                var Amount = (int)GetMultiply(player, Convert.ToInt32(item.amount));
                player.inventory.Take(collect, item.itemid, Amount);
                player.Command("note.inv " + item.itemid + " " + (float) ((int)Amount * -1.0));
            }

            foreach (var obj in collect)
                obj.Remove();

            return null;
        }

        private object CanBuild(Planner builder, Construction prefab, Construction.Target target)
        {
            var prefabName = prefab.fullName ?? "";
            if (prefabName == "") return null;
            var player = builder.GetOwnerPlayer();
            if (player == null) return null;
            var cupboard = player.GetBuildingPrivilege();
            if (cupboard == null) return null;
            return CheckStatus(player, cupboard);
        }
        #endregion

        #region [Limit]
        private object CheckStatus(BasePlayer player, BuildingPrivlidge build)
        {
            int buildingBlocks = build.GetBuilding().buildingBlocks.Count;

            if (buildingBlocks >= config._Settings.buildingBlocks)
            {
                if (player.SecondsSinceAttacked > 5)
                {
                    player.ChatMessage($"Вы превысили лимит установки объектов в 1 шкафу! Максимальное количество объектов, которое можно установить в 1 шкафу - {config._Settings.buildingBlocks}");
                    player.lastAttackedTime = UnityEngine.Time.time;
                }
                return false;
            }
            else
            {
                if (player.SecondsSinceAttacked > 5)
                {
                    player.ChatMessage($"В данном шкафу можно еще поставить <color=#a5e664>{config._Settings.buildingBlocks - buildingBlocks}</color> объектов!");
                    player.lastAttackedTime = UnityEngine.Time.time;
                }
            }

            return null;
        }
        #endregion

        #region [Func]
        private int CheckObject(BasePlayer player)
        {
            var cupboard = player.GetBuildingPrivilege();
            if (cupboard == null) return 0;
            var entity = cupboard.GetBuilding().buildingBlocks.Where(i => i as BuildingBlock).ToList();
            return entity.Count;
        }

        private double GetMultiply(BasePlayer player, int costToBuild)
        {
            int buildingBlocks = CheckObject(player);

            var find = config._Settings._ObjectSettings.FirstOrDefault(obj => buildingBlocks >= obj.minbuildingBlocks && buildingBlocks <= obj.maxbuildingBlocks);
            if (find == null) return 0;

            return (costToBuild * find.Factor) - costToBuild;
        }
        #endregion
    }
}

// --- End of file: BLimitObject.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/BodiesToBags.cs ---
// --- Original Local Path: BeeRust/BodiesToBags.cs ---

﻿namespace Oxide.Plugins
{
    [Info("Bodies to Bags", "Ryan", "1.0.1")]
    [Description("Instantly turns player corpses into backpacks")]
    public class BodiesToBags : RustPlugin
    {
        private void OnEntitySpawned(BaseNetworkable entity)
        {
            var corpse = entity as LootableCorpse;
            if (corpse == null || entity is NPCPlayer) return;

            timer.Once(5f, () =>
            {
                corpse.Kill();
                corpse.DropItems();
            });
        }
    }
}


// --- End of file: BodiesToBags.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/IQChat.cs ---
// --- Original Local Path: BeeRust/IQChat.cs ---

using Newtonsoft.Json.Linq;
using System.IO;
using System.Collections.Generic;
using UnityEngine;
using System.Text.RegularExpressions;
using UnityEngine.Networking;
using Newtonsoft.Json;
using System;
using Oxide.Core.Plugins;
using Oxide.Core;
using Oxide.Core.Libraries;
using Facepunch;
using System.Linq;
using System.Text;
using CompanionServer;
using ConVar;
using System.Collections;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("IQChat", "Mercury", "2.25.7")]
    [Description("The most pleasant chat for your server from the IQ system")]
    class IQChat : RustPlugin
    {
		   		 		  						  	   		  	  			  	  			  	 				  	  	
        
        
        private bool OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel)
        {
            // PrintToChat(message);
            if (Interface.Oxide.CallHook("CanChatMessage", player, message) != null) return false;
            SeparatorChat(channel, player, message);
            return false;
        }
        
        private class InterfaceBuilder
        {
            
            public static InterfaceBuilder Instance;
            public const String UI_Chat_Context = "UI_IQCHAT_CONTEXT";
            public const String UI_Chat_Context_Visual_Nick = "UI_IQCHAT_CONTEXT_VISUAL_NICK";
            public const String UI_Chat_Alert = "UI_IQCHAT_ALERT";
            public Dictionary<String, String> Interfaces;

            
            
            public InterfaceBuilder()
            {
                Instance = this;
                Interfaces = new Dictionary<String, String>();
                BuildingStaticContext();
                BuildingVisualNick();
                BuildingCheckBox();

                BuildingModerationStatic();
                BuildingMuteAllChat();
                BuildingMuteAllVoice();

                BuildingSlider();
                BuildingSliderUpdateArgument();
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                BuildingDropList();
                BuildingOpenDropList();
                BuildingElementDropList();
                BuildingElementDropListTakeLine();

                BuildingAlertUI();

                BuildingMuteAndIgnore();
                BuildingMuteAndIgnorePlayerPanel();
                BuildingMuteAndIgnorePlayer();
                BuildingMuteAndIgnorePages();

                BuildingMuteAndIgnorePanelAlert();
                BuildingIgnoreAlert();
                BuildingMuteAlert();
                BuildingMuteAlert_DropList_Title();
                BuildingMuteAlert_DropList_Reason();
            }

            public static void AddInterface(String name, String json)
            {
                if (Instance.Interfaces.ContainsKey(name))
                {
                    _.PrintError($"Error! Tried to add existing cui elements! -> {name}");
                    return;
                }

                Instance.Interfaces.Add(name, json);
            }

            public static string GetInterface(String name)
            {
                string json = string.Empty;
                if (Instance.Interfaces.TryGetValue(name, out json) == false)
                {
                    _.PrintWarning($"Warning! UI elements not found by name! -> {name}");
                }

                return json;
            }

            public static void DestroyAll()
            {
                for (var i = 0; i < BasePlayer.activePlayerList.Count; i++)
                {
                    var player = BasePlayer.activePlayerList[i];
                    CuiHelper.DestroyUi(player, UI_Chat_Context);
                    CuiHelper.DestroyUi(player, UI_Chat_Context_Visual_Nick);
                    CuiHelper.DestroyUi(player, UI_Chat_Alert);
                    CuiHelper.DestroyUi(player, "MUTE_AND_IGNORE_PANEL_ALERT");
                }
            }

            
            
                        private void BuildingVisualNick()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = UI_Chat_Context_Visual_Nick,
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%NICK_DISPLAY%", Font = "robotocondensed-regular.ttf", FontSize = 7, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-135.769 -89.558", OffsetMax = "-12.644 -77.176" }
                }
                });

                AddInterface("UI_Chat_Context_Visual_Nick", container.ToJson());
            }
            
                        private void BuildingStaticContext()
            {
                Configuration.ControllerParameters Controller = config.ControllerParameter;
                if (Controller == null)
                {
                    _.PrintWarning("Ошибка генерации интерфейса, null значение в конфигурации, свяжитесь с разработчиком");
                    return;
                }
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    RectTransform = { AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "-379 -217", OffsetMax = "-31 217" },
                    Image = { Color = "0 0 0 0" }
                }, "Overlay", UI_Chat_Context);
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "1000 1000", OffsetMax = "-1000 -1000" },
                    Button = { Close = UI_Chat_Context, Color = "0 0 0 0.5" },
                    Text = { Text = "" }
                }, UI_Chat_Context, "CLOSE_UI_Chat_Context_FullScreen");

                container.Add(new CuiElement
                {
                    Name = "ImageContext",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = "%IMG_BACKGROUND%" },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "TitleLabel",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 17, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-149.429 166.408", OffsetMax = "-14.788 189.564" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "DescriptionLabel",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%SETTING_ELEMENT%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-149.429 112.0214442", OffsetMax = "152.881 131.787" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "InformationLabel",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%INFORMATION%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-149.429 -53.432", OffsetMax = "-32.905 -39.808" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "InformationIcon",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_INFORMATION_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-14.788 -52.12", OffsetMax = "-3.788 -41.12" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "SettingLabel",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%SETTINGS%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "11.075 -53.432", OffsetMax = "126.125 -39.808" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "SettingIcon",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_SETTING_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "141.88 -52.12", OffsetMax = "152.88 -41.12" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "SettingPM",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%SETTINGS_PM%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "11.075 -70.712", OffsetMax = "126.125 -57.088" }
                }
                });
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                container.Add(new CuiElement
                {
                    Name = "SettingAlertChat",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%SETTINGS_ALERT%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "11.075 -82.412", OffsetMax = "126.125 -68.788" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "SettingNoticyChat",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%SETTINGS_ALERT_PM%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "11.075 -94.412", OffsetMax = "126.125 -80.788" }
                }
                });
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                container.Add(new CuiElement
                {
                    Name = "SettingSoundAlert",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%SETTINGS_SOUNDS%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "11.075 -106.412", OffsetMax = "126.125 -92.788" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "MuteStatus",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%MUTE_STATUS_PLAYER%", Font = "robotocondensed-regular.ttf", FontSize = 11, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-143.174 -131.59", OffsetMax = "-120.611 -114.967" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "MuteStatusTitle",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%MUTE_STATUS_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 7, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-143.174 -141.429", OffsetMax = "-89.127 -132.508" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "CountIgnored",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%IGNORED_STATUS_COUNT%", Font = "robotocondensed-regular.ttf", FontSize = 7, Align = TextAnchor.UpperLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-66.98 -131.715", OffsetMax = "-11.09 -116.831" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "IgonoredTitle",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%IGNORED_STATUS_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 7, Align = TextAnchor.UpperLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-66.98 -142.04", OffsetMax = "-19.967 -132.537" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "IgnoredIcon",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_IGNORE_INFO_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-19.483 -115.225", OffsetMax = "-11.762 -107.814" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = $"newui.cmd action.mute.ignore open {SelectedAction.Ignore}", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "IgnoredIcon", "CLOSE_IGNORED");

                container.Add(new CuiElement
                {
                    Name = "TitleNickPanel",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%NICK_DISPLAY_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-135.769 -78.878", OffsetMax = "-85.632 -64.613" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "NickTitle",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%SLIDER_NICK_COLOR_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "22.591 76.362", OffsetMax = "80.629 92.278" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "ChatMessageTitle",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%SLIDER_MESSAGE_COLOR_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-136.591 9.362", OffsetMax = "-78.045 24.278" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "PrefixTitle",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%SLIDER_PREFIX_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-136.591 77.362", OffsetMax = "-89.949 93.278" }
                }
                });


                container.Add(new CuiElement
                {
                    Name = "RankTitle",
                    Parent = UI_Chat_Context,
                    Components = {
                        new CuiTextComponent { Text = "%SLIDER_IQRANK_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "22.825 9.242", OffsetMax = "81.375 25.158" }
                    }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "123.62 166", OffsetMax = "153.62 196" },
                    Button = { Close = UI_Chat_Context, Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, UI_Chat_Context, "CLOSE_UI_Chat_Context");

                AddInterface("UI_Chat_Context", container.ToJson());
            }

            
                        private void BuildingCheckBox()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "%NAME_CHECK_BOX%",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "%COLOR%", Png = ImageUi.GetImage("IQCHAT_ELEMENT_SETTING_CHECK_BOX") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "%OFFSET_MIN%", OffsetMax = "%OFFSET_MAX%" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%COMMAND_TURNED%", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "%NAME_CHECK_BOX%", "CHECK_BOX_TURNED");

                AddInterface("UI_Chat_Context_CheckBox", container.ToJson());
            }
            
                        private void BuildingSlider()
            {
                CuiElementContainer container = new CuiElementContainer();
                String NameSlider = "%NAME%";

                container.Add(new CuiElement
                {
                    Name = NameSlider,
                    Parent = UI_Chat_Context,
                    Components = {
                            new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_ELEMENT_SLIDER_ICON") },
                            new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "%OFFSET_MIN%" , OffsetMax = "%OFFSET_MAX%"  }
                        }
                });
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                container.Add(new CuiElement
                {
                    Name = "Left",
                    Parent = NameSlider,
                    Components = {
                        new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_ELEMENT_SLIDER_LEFT_ICON") },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-53.9 -4.5", OffsetMax = "-48.9 4.5" }
                    }
                });
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%COMMAND_LEFT_SLIDE%", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "Left", "LEFT_SLIDER_BTN");
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                container.Add(new CuiElement
                {
                    Name = "Right",
                    Parent = NameSlider,
                    Components = {
                        new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_ELEMENT_SLIDER_RIGHT_ICON") },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "48.92 -4.5", OffsetMax = "53.92 4.5" }
                    }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%COMMAND_RIGHT_SLIDE%", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "Right", "RIGHT_SLIDER_BTN");

                AddInterface("UI_Chat_Slider", container.ToJson());
            }
            private void BuildingSliderUpdateArgument()
            {
                CuiElementContainer container = new CuiElementContainer();
                String ParentSlider = "%PARENT%";
                String NameArgument = "%NAME%";

                container.Add(new CuiElement
                {
                    Name = NameArgument,
                    Parent = ParentSlider,
                    Components = {
                    new CuiTextComponent { Text = "%ARGUMENT%", Font = "robotocondensed-regular.ttf", FontSize = 9, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-41.929 -6.801", OffsetMax = "41.929 6.801" }
                }
                });

                AddInterface("UI_Chat_Slider_Update_Argument", container.ToJson());
            }
            
            
                        private void BuildingMuteAndIgnore()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "MuteAndIgnoredPanel",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_MUTE_AND_IGNORE_PANEL")},
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-1007.864 -220.114", OffsetMax = "-167.374 219.063" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "TitlesPanel",
                    Parent = "MuteAndIgnoredPanel",
                    Components = {
                    new CuiTextComponent { Text = "%TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 20, Align = TextAnchor.MiddleRight, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "60.217 164.031", OffsetMax = "356.114 190.962" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "IconPanel",
                    Parent = "MuteAndIgnoredPanel",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_MUTE_AND_IGNORE_ICON")},
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "357.5 170", OffsetMax = "373.5 185"  }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "SearchPanel",
                    Parent = "MuteAndIgnoredPanel",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_MUTE_AND_IGNORE_SEARCH")},
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-385.8 161.244", OffsetMax = "-186.349 192.58" }
                }
                });

                string SearchName = "";

                container.Add(new CuiElement
                {
                    Parent = "SearchPanel",
                    Name = "SearchPanel" + ".Input.Current",
                    Components =
                {
                    new CuiInputFieldComponent { Text = SearchName, FontSize = 14,Command = $"newui.cmd action.mute.ignore search.controller %ACTION_TYPE% {SearchName}", Align = TextAnchor.MiddleCenter, Color = "1 1 1 0.5", CharsLimit = 15},
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "PanelPages",
                    Parent = "MuteAndIgnoredPanel",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_MUTE_AND_IGNORE_PAGE_PANEL")},
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-179.196 161.242", OffsetMax = "-121.119 192.578" }
                }
                });

                AddInterface("UI_Chat_Mute_And_Ignore", container.ToJson());
            }

            private void BuildingMuteAndIgnorePlayerPanel()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.85" },
                    Image = { Color = "0 0 0 0" }
                }, "MuteAndIgnoredPanel", "MuteIgnorePanelContent");

                AddInterface("UI_Chat_Mute_And_Ignore_Panel_Content", container.ToJson());
            }
            private void BuildingMuteAndIgnorePlayer()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "PANEL_PLAYER",
                    Parent = "MuteIgnorePanelContent",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_MUTE_AND_IGNORE_PLAYER") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "%OFFSET_MIN%", OffsetMax = "%OFFSET_MAX%" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "NickName",
                    Parent = "PANEL_PLAYER",
                    Components = {
                    new CuiTextComponent { Text = "%DISPLAY_NAME%", Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-77.391 -17.245", OffsetMax = "91.582 17.244" }
                }
                });
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                container.Add(new CuiElement
                {
                    Name = "StatusPanel",
                    Parent = "PANEL_PLAYER",
                    Components = {
                    new CuiRawImageComponent { Color = "%COLOR%", Png = ImageUi.GetImage("IQCHAT_MUTE_AND_IGNORE_PLAYER_STATUS") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-92.231 -11.655", OffsetMax = "-87.503 10.44" }
                }
                });
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%COMMAND_ACTION%", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "PANEL_PLAYER");

                AddInterface("UI_Chat_Mute_And_Ignore_Player", container.ToJson());
            }
            private void BuildingMuteAndIgnorePages()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "PageCount",
                    Parent = "PanelPages",
                    Components = {
                    new CuiTextComponent { Text = "%PAGE%", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-11.03 -15.668", OffsetMax = "11.03 15.668" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "LeftPage",
                    Parent = "PanelPages",
                    Components = {
                    new CuiRawImageComponent { Color = "%COLOR_LEFT%", Png = ImageUi.GetImage("IQCHAT_ELEMENT_SLIDER_LEFT_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-18 -7", OffsetMax = "-13 6" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%COMMAND_LEFT%", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "LeftPage");

                container.Add(new CuiElement
                {
                    Name = "RightPage",
                    Parent = "PanelPages",
                    Components = {
                    new CuiRawImageComponent { Color = "%COLOR_RIGHT%", Png = ImageUi.GetImage("IQCHAT_ELEMENT_SLIDER_RIGHT_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "14 -7", OffsetMax = "19 6" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%COMMAND_RIGHT%", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "RightPage");

                AddInterface("UI_Chat_Mute_And_Ignore_Pages", container.ToJson());
            }

            
                        private void BuildingMuteAndIgnorePanelAlert()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Image = { Color = "0 0 0 0.25", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
                }, "Overlay", "MUTE_AND_IGNORE_PANEL_ALERT");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Close = "MUTE_AND_IGNORE_PANEL_ALERT", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "MUTE_AND_IGNORE_PANEL_ALERT");

                AddInterface("UI_Chat_Mute_And_Ignore_Alert_Panel", container.ToJson());
            }

            
            private void BuildingMuteAlert()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "AlertMute",
                    Parent = "MUTE_AND_IGNORE_PANEL_ALERT",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_MUTE_ALERT_PANEL") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-199.832 -274.669", OffsetMax = "199.832 274.669" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "AlertMuteIcon",
                    Parent = "AlertMute",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_MUTE_ALERT_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-67 204.8", OffsetMax = "67 339.8" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "AlertMuteTitles",
                    Parent = "AlertMute",
                    Components = {
                    new CuiTextComponent { Text = "%TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 25, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-199.828 142.57", OffsetMax = "199.832 179.43" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "AlertMuteTakeChat",
                    Parent = "AlertMute",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1",Png = ImageUi.GetImage("IQCHAT_IGNORE_ALERT_BUTTON_YES") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-99.998 87.944", OffsetMax = "100.002 117.944" }
                }
                });
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%COMMAND_TAKE_ACTION_MUTE_CHAT%", Color = "0 0 0 0" },
                    Text = { Text = "%BUTTON_TAKE_CHAT_ACTION%", Align = TextAnchor.MiddleCenter, FontSize = 18, Color = "0.1294118 0.145098 0.1647059 1" }
                }, "AlertMuteTakeChat", "BUTTON_TAKE_CHAT");

                container.Add(new CuiElement
                {
                    Name = "AlertMuteTakeVoice",
                    Parent = "AlertMute",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1",Png = ImageUi.GetImage("IQCHAT_IGNORE_ALERT_BUTTON_YES") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-100 49.70", OffsetMax = "100 79.70" } //
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%COMMAND_TAKE_ACTION_MUTE_VOICE%", Color = "0 0 0 0" },
                    Text = { Text = "%BUTTON_TAKE_VOICE_ACTION%", Align = TextAnchor.MiddleCenter, FontSize = 18, Color = "0.1294118 0.145098 0.1647059 1" }
                }, "AlertMuteTakeVoice", "BUTTON_TAKE_VOICE");
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                AddInterface("UI_Chat_Mute_Alert", container.ToJson());
            }
            private void BuildingMuteAlert_DropList_Title()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "AlertMuteTitleReason",
                    Parent = "AlertMute",
                    Components = {
                    new CuiTextComponent { Text = "%TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-199.828 -9.430", OffsetMax = "199.832 27.430" }
                }
                });

                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = "1 1 1 0" },
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-147.497 -265.5440", OffsetMax = "147.503 -24.70" }
                }, "AlertMute", "PanelMuteReason");
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                AddInterface("UI_Chat_Mute_Alert_DropList_Title", container.ToJson());
            }

            private void BuildingMuteAlert_DropList_Reason()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "Reason",
                    Parent = "PanelMuteReason",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_MUTE_ALERT_PANEL_REASON")},
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "%OFFSET_MIN%", OffsetMax = "%OFFSET_MAX%" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%COMMAND_REASON%", Color = "0 0 0 0" },
                    Text = { Text = "%REASON%", Align = TextAnchor.MiddleCenter, FontSize = 13, Color = "1 1 1 1" }
                }, "Reason");

                AddInterface("UI_Chat_Mute_Alert_DropList_Reason", container.ToJson());
            }
            
                        private void BuildingIgnoreAlert()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "AlertIgnore",
                    Parent = "MUTE_AND_IGNORE_PANEL_ALERT",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_IGNORE_ALERT_PANEL") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-236.5 -134", OffsetMax = "236.5 134" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "AlertIgnoreIcon",
                    Parent = "AlertIgnore",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_IGNORE_ALERT_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-66.5 64.8", OffsetMax = "66.5 198.8" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "AlertIgnoreTitle",
                    Parent = "AlertIgnore",
                    Components = {
                    new CuiTextComponent { Text = "%TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 22, Align = TextAnchor.UpperCenter, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-231 -55.00", OffsetMax = "229.421 33.98" } //
                }
                });

                container.Add(new CuiElement
                {
                    Name = "AlertIgnoreYes",
                    Parent = "AlertIgnore",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_IGNORE_ALERT_BUTTON_YES") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-178 -115", OffsetMax = "-22 -77" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Close = "MUTE_AND_IGNORE_PANEL_ALERT", Command = "%COMMAND%", Color = "0 0 0 0" },
                    Text = { Text = "%BUTTON_YES%", Align = TextAnchor.MiddleCenter, FontSize = 18, Color = "0.1294118 0.145098 0.1647059 1" }
                }, "AlertIgnoreYes", "BUTTON_YES");

                container.Add(new CuiElement
                {
                    Name = "AlertIgnoreNo",
                    Parent = "AlertIgnore",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_IGNORE_ALERT_BUTTON_NO") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "22 -115", OffsetMax = "178 -77" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Close = "MUTE_AND_IGNORE_PANEL_ALERT", Color = "0 0 0 0" },
                    Text = { Text = "%BUTTON_NO%", Align = TextAnchor.MiddleCenter, FontSize = 18 }
                }, "AlertIgnoreNo", "BUTTON_NO");

                AddInterface("UI_Chat_Ignore_Alert", container.ToJson());
            }
            
            
            
            
            private void BuildingDropList()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "DropListIcon",
                    Parent = UI_Chat_Context,
                    Components = {
                            new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_ELEMENT_PREFIX_MULTI_TAKE_ICON")},
                      new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "%OFFSET_MIN%", OffsetMax = "%OFFSET_MAX%" }
                        }
                });

                container.Add(new CuiElement
                {
                    Name = "DropListDescription",
                    Parent = "DropListIcon",
                    Components = {
                            new CuiTextComponent { Text = "%TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                            new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-105.5 -13.948", OffsetMax = "-42.615 1.725" }
                        }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%BUTTON_DROP_LIST_CMD%", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "DropListIcon", "DropListIcon_Button");

                AddInterface("UI_Chat_DropList", container.ToJson());
            }

            private void BuildingOpenDropList()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "OpenDropList",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_ELEMENT_DROP_LIST_OPEN_ICON")},
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-149.429 -17.38", OffsetMax = "155.093 109.1" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "DropListName",
                    Parent = "OpenDropList",
                    Components = {
                    new CuiTextComponent { Text = "%TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 11, Align = TextAnchor.UpperLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-140.329 44.5", OffsetMax = "-40.329 58.312" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "DropListDescription",
                    Parent = "OpenDropList",
                    Components = {
                    new CuiTextComponent { Text = "%DESCRIPTION%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.UpperLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-140.329 32.993", OffsetMax = "-40.329 42.77" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "DropListClose",
                    Parent = "OpenDropList",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_ELEMENT_PREFIX_MULTI_TAKE_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "113 32.2", OffsetMax = "145 56.2" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Close = "OpenDropList", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "DropListClose", "DropListClose_Button");

                container.Add(new CuiElement
                {
                    Name = "DropListPageRight",
                    Parent = "OpenDropList",
                    Components = {
                    new CuiRawImageComponent { Color = "%COLOR_RIGHT%", Png = ImageUi.GetImage("IQCHAT_ELEMENT_SLIDER_RIGHT_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "100 38", OffsetMax = "105.2 48" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%NEXT_BTN%", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "DropListPageRight", "DropListPageRight_Button");

                container.Add(new CuiElement
                {
                    Name = "DropListPageLeft",
                    Parent = "OpenDropList",
                    Components = {
                    new CuiRawImageComponent { Color ="%COLOR_LEFT%", Png = ImageUi.GetImage("IQCHAT_ELEMENT_SLIDER_LEFT_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "86 38", OffsetMax = "91.2 48" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%BACK_BTN%", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "DropListPageLeft", "DropListPageLeft_Button");

                AddInterface("UI_Chat_OpenDropList", container.ToJson());
            }

            private void BuildingElementDropList()
            {
                CuiElementContainer container = new CuiElementContainer();
                String Name = "ArgumentDropList_%COUNT%";

                container.Add(new CuiElement
                {
                    Name = Name,
                    Parent = "OpenDropList",
                    Components = {
                    new CuiRawImageComponent { FadeIn = 0.3f, Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_ELEMENT_DROP_LIST_OPEN_ARGUMENT_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "%OFFSET_MIN%", OffsetMax = "%OFFSET_MAX%" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-37.529 -12.843", OffsetMax = "37.528 12.842" },
                    Button = { FadeIn = 0.3f, Command = "%TAKE_COMMAND_ARGUMENT%", Color = "0 0 0 0" },
                    Text = { FadeIn = 0.3f, Text = "%ARGUMENT%", Font = "robotocondensed-regular.ttf", FontSize = 9, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" }
                }, Name, "ArgumentButton");

                AddInterface("UI_Chat_OpenDropListArgument", container.ToJson());
            }

            private void BuildingElementDropListTakeLine()
            {
                CuiElementContainer container = new CuiElementContainer();
                String Parent = "ArgumentDropList_%COUNT%";

                container.Add(new CuiElement
                {
                    Name = "TAKED_INFO_%COUNT%",
                    Parent = Parent,
                    Components = {
                    new CuiRawImageComponent { Color = "0.3098039 0.2745098 0.572549 1", Png = ImageUi.GetImage("IQCHAT_ELEMENT_DROP_LIST_OPEN_TAKED") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-25.404 -17.357", OffsetMax = "25.403 -1.584" }
                }
                });

                AddInterface("UI_Chat_OpenDropListArgument_Taked", container.ToJson());
            }

            
                        private void BuildingModerationStatic()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "ModerationLabel",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "11.075 -126.612", OffsetMax = "126.125 -112.988" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "ModerationIcon",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_MODERATION_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "141.88 -125.3", OffsetMax = "152.88 -114.3" }
                }
                });


                container.Add(new CuiElement
                {
                    Name = "ModeratorMuteMenu",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_ELEMENT_PANEL_ICON")},
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "11.071 -144.188", OffsetMax = "152.881 -129.752" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.95" },
                    Button = { Command = "%COMMAND_MUTE_MENU%", Color = "0 0 0 0" },
                    Text = { Text = "%TEXT_MUTE_MENU%", FontSize = 9, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf" }
                }, "ModeratorMuteMenu", "ModeratorMuteMenu_Btn");


                AddInterface("UI_Chat_Moderation", container.ToJson());
            }
            private void BuildingMuteAllChat()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "ModeratorMuteAllChat",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_ELEMENT_PANEL_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "11.07 -161.818", OffsetMax = "152.88 -147.382" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.95" },
                    Button = { Command = "%COMMAND_MUTE_ALLCHAT%", Color = "0 0 0 0" },
                    Text = { Text = "%TEXT_MUTE_ALLCHAT%", FontSize = 9, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf" }
                }, "ModeratorMuteAllChat", "ModeratorMuteAllChat_Btn");

                AddInterface("UI_Chat_Administation_AllChat", container.ToJson());
            }
            private void BuildingMuteAllVoice()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "ModeratorMuteAllVoice",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_ELEMENT_PANEL_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "11.075 -179.448", OffsetMax = "152.885 -165.012" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.95" },
                    Button = { Command = "%COMMAND_MUTE_ALLVOICE%", Color = "0 0 0 0" },
                    Text = { Text = "%TEXT_MUTE_ALLVOICE%", FontSize = 9, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf" }
                }, "ModeratorMuteAllVoice", "ModeratorMuteAllVoice_Btn");

                AddInterface("UI_Chat_Administation_AllVoce", container.ToJson());
            }

            
            
                        private void BuildingAlertUI()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = UI_Chat_Alert,
                    Parent = "Overlay",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_ALERT_PANEL") },
                    new CuiRectTransformComponent { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "0 -136.5", OffsetMax = "434 -51.5" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "AlertTitle",
                    Parent = UI_Chat_Alert,
                    Components = {
                    new CuiTextComponent { Text = "<b>%TITLE%</b>", Font = "robotocondensed-bold.ttf", FontSize = 16, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-184.193 9.119", OffsetMax = "189.223 30.925" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "AlertText",
                    Parent = UI_Chat_Alert,
                    Components = {
                    new CuiTextComponent { Text = "%DESCRIPTION%", Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-184.193 -27.133", OffsetMax = "189.223 9.119" }
                }
                });

                AddInterface("UI_Chat_Alert", container.ToJson());
            }
                    }

        public string FindFakeName(ulong userID) => (string)IQFakeActive?.Call("FindFakeName", userID);
        String IQRankGetTimeGame(ulong userID) => (string)(IQRankSystem?.Call("API_GET_TIME_GAME", userID));

        [ConsoleCommand("online")]
        private void ShowPlayerOnlineConsole(ConsoleSystem.Arg arg)
        {
            if (!config.OtherSetting.UseCommandOnline) return;

            BasePlayer player = arg.Player();
            List<String> PlayerNames = GetPlayersOnline();
            String Message = GetLang("IQCHAT_INFO_ONLINE", player != null ? player.UserIDString : null, String.Join($"\n", PlayerNames));

            if (player != null)
                player.ConsoleMessage(Message);
            else
            {
                String Pattern = @"</?size.*?>|</?color.*?>";
                String Messages = Regex.IsMatch(Message, Pattern) ? Regex.Replace(Message, Pattern, "") : Message;
                Puts(Messages);
            }
        }
        
        
                private void DrawUI_IQChat_Ignore_Alert(BasePlayer player, BasePlayer Target, UInt64 IDFake = 0)
        {
            String InterfacePanel = InterfaceBuilder.GetInterface("UI_Chat_Mute_And_Ignore_Alert_Panel");
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Ignore_Alert");
            if (Interface == null || InterfacePanel == null) return;

            GeneralInformation.RenameInfo Renamer = (IQFakeActive && Target == null && IDFake != 0) ? null : GeneralInfo.GetInfoRename(Target.userID);
            String NickNamed = (IQFakeActive && Target == null && IDFake != 0) ? FindFakeName(IDFake) : Renamer != null ? $"{Renamer.RenameNick ?? Target.displayName}" : Target.displayName;
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            Interface = Interface.Replace("%TITLE%", GetLang(UserInformation[player.userID].Settings.IsIgnored((IQFakeActive && Target == null && IDFake != 0) ? IDFake : Target.userID) ? "IQCHAT_TITLE_IGNORE_TITLES_UNLOCK" : "IQCHAT_TITLE_IGNORE_TITLES", player.UserIDString, NickNamed));
            Interface = Interface.Replace("%BUTTON_YES%", GetLang("IQCHAT_TITLE_IGNORE_BUTTON_YES", player.UserIDString));
            Interface = Interface.Replace("%BUTTON_NO%", GetLang("IQCHAT_TITLE_IGNORE_BUTTON_NO", player.UserIDString));
            Interface = Interface.Replace("%COMMAND%", $"newui.cmd action.mute.ignore ignore.and.mute.controller {SelectedAction.Ignore} confirm.yes {((IQFakeActive && Target == null && IDFake != 0) ? IDFake : Target.userID)}");

            CuiHelper.DestroyUi(player, "MUTE_AND_IGNORE_PANEL_ALERT");
            CuiHelper.AddUi(player, InterfacePanel);
            CuiHelper.AddUi(player, Interface);
        }
        private void DrawUI_IQChat_OpenDropList(BasePlayer player, TakeElementUser ElementType, Int32 Page = 0)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_OpenDropList");
            if (Interface == null) return;

            if (!LocalBase.ContainsKey(player)) return;

            String Title = String.Empty;
            String Description = String.Empty;
            List<Configuration.ControllerParameters.AdvancedFuncion> InfoUI = new List<Configuration.ControllerParameters.AdvancedFuncion>();

            switch (ElementType)
            {
                case TakeElementUser.MultiPrefix:
                case TakeElementUser.Prefix:
                    {
                        InfoUI = LocalBase[player].ElementsPrefix;
                        Title = GetLang("IQCHAT_CONTEXT_SLIDER_PREFIX_TITLE", player.UserIDString);
                        Description = GetLang("IQCHAT_CONTEXT_DESCRIPTION_PREFIX", player.UserIDString);
                        break;
                    }
                case TakeElementUser.Nick:
                    {
                        InfoUI = LocalBase[player].ElementsNick;
                        Title = GetLang("IQCHAT_CONTEXT_SLIDER_NICK_COLOR_TITLE", player.UserIDString);
                        Description = GetLang("IQCHAT_CONTEXT_DESCRIPTION_NICK", player.UserIDString);
                        break;
                    }
                case TakeElementUser.Chat:
                    {
                        InfoUI = LocalBase[player].ElementsChat;
                        Title = GetLang("IQCHAT_CONTEXT_SLIDER_MESSAGE_COLOR_TITLE", player.UserIDString);
                        Description = GetLang("IQCHAT_CONTEXT_DESCRIPTION_CHAT", player.UserIDString);
                        break;
                    }
                case TakeElementUser.Rank:
                    {
                        InfoUI = LocalBase[player].ElementsRanks;
                        Title = GetLang("IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE", player.UserIDString);
                        Description = GetLang("IQCHAT_CONTEXT_DESCRIPTION_RANK", player.UserIDString);
                        break;
                    }
                default:
                    break;
            }

            //  if (InfoUI == null || InfoUI.Count == 0) return;

            Interface = Interface.Replace("%TITLE%", Title);
            Interface = Interface.Replace("%DESCRIPTION%", Description);

            String CommandRight = InfoUI.Skip(9 * (Page + 1)).Count() > 0 ? $"newui.cmd droplist.controller page.controller {ElementType} + {Page}" : String.Empty;
            String CommandLeft = Page != 0 ? $"newui.cmd droplist.controller page.controller {ElementType} - {Page}" : String.Empty;

            Interface = Interface.Replace("%NEXT_BTN%", CommandRight);
            Interface = Interface.Replace("%BACK_BTN%", CommandLeft);

            Interface = Interface.Replace("%COLOR_RIGHT%", String.IsNullOrWhiteSpace(CommandRight) ? "1 1 1 0.1" : "1 1 1 1");
            Interface = Interface.Replace("%COLOR_LEFT%", String.IsNullOrWhiteSpace(CommandLeft) ? "1 1 1 0.1" : "1 1 1 1");

            CuiHelper.DestroyUi(player, "OpenDropList");
            CuiHelper.AddUi(player, Interface);
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            Int32 Count = 0;
            Int32 X = 0, Y = 0;
            foreach (Configuration.ControllerParameters.AdvancedFuncion Info in InfoUI.Skip(9 * Page).Take(9))
            {
                DrawUI_IQChat_OpenDropListArgument(player, ElementType, Info, X, Y, Count);

                if (ElementType == TakeElementUser.MultiPrefix && UserInformation[player.userID].Info.PrefixList.Contains(Info.Argument))
                    DrawUI_IQChat_OpenDropListArgument(player, Count);

                Count++;
                X++;
                if (X == 3)
                {
                    X = 0;
                    Y++;
                }
            }
        }
        
        
        
        
        public List<String> GetMesagesList(BasePlayer player, Dictionary<String, List<String>> LanguageMessages)
        {
            String LangPlayer = _.lang.GetLanguage(player.UserIDString);

            if (LanguageMessages.ContainsKey(LangPlayer))
                return LanguageMessages[LangPlayer];
            else if (LanguageMessages.ContainsKey("en"))
                return LanguageMessages["en"];
            else return LanguageMessages.FirstOrDefault().Value;
        }
        private const String PermissionAlert = "iqchat.alertuse";

        
        private BasePlayer GetPlayerNickOrID(String Info)
        {
            String NameOrID = String.Empty;

            KeyValuePair<UInt64, GeneralInformation.RenameInfo> RenameInformation = GeneralInfo.RenameList.FirstOrDefault(x => x.Value.RenameNick.Contains(Info) || x.Value.RenameID.ToString() == Info);
            if (RenameInformation.Value == null)
                NameOrID = Info;
            else NameOrID = RenameInformation.Key.ToString();

            foreach (BasePlayer Finder in BasePlayer.activePlayerList)
            {
                if (Finder.displayName.ToLower().Contains(NameOrID.ToLower()) || Finder.userID.ToString() == NameOrID)
                    return Finder;
            }
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            return null;
        }
        private void DrawUI_IQChat_OpenDropListArgument(BasePlayer player, Int32 Count)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_OpenDropListArgument_Taked");
            if (Interface == null) return;

            Interface = Interface.Replace("%COUNT%", Count.ToString());

            CuiHelper.DestroyUi(player, $"TAKED_INFO_{Count}");
            CuiHelper.AddUi(player, Interface);
        }
        
        
        [ChatCommand("chat")]
        private void ChatCommandOpenedUI(BasePlayer player)
        {
            if (_interface == null)
            {
                PrintWarning(LanguageEn ? "We generate the interface, wait for a message about successful generation" : "Генерируем интерфейс, ожидайте сообщения об успешной генерации");
                return;
            }
            if (player == null) return;
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            Configuration.ControllerParameters ControllerParameters = config.ControllerParameter;

            if (!LocalBase.ContainsKey(player))
                LocalBase.Add(player, new InformationOpenedUI { });

            LocalBase[player].ElementsPrefix = ControllerParameters.Prefixes.Prefixes.OrderByDescending(arg => arg.Argument.Length).Where(p => permission.UserHasPermission(player.UserIDString, p.Permissions) && !p.IsBlockSelected).ToList();
            LocalBase[player].ElementsNick = ControllerParameters.NickColorList.Where(n => permission.UserHasPermission(player.UserIDString, n.Permissions) && !n.IsBlockSelected).ToList();
            LocalBase[player].ElementsChat = ControllerParameters.MessageColorList.Where(m => permission.UserHasPermission(player.UserIDString, m.Permissions) && !m.IsBlockSelected).ToList();

            if (IQRankSystem && config.ReferenceSetting.IQRankSystems.UseRankSystem)
            {
                List<Configuration.ControllerParameters.AdvancedFuncion> RankList = new List<Configuration.ControllerParameters.AdvancedFuncion>();
                foreach (String Rank in IQRankListKey(player.userID))
                    RankList.Add(new Configuration.ControllerParameters.AdvancedFuncion { Argument = Rank, Permissions = String.Empty });

                LocalBase[player].ElementsRanks = RankList;
            }

            DrawUI_IQChat_Context(player);
        }
        String API_GET_CHAT_COLOR(UInt64 ID)
        {
            if (!UserInformation.ContainsKey(ID)) return String.Empty;

            return UserInformation[ID].Info.ColorMessage;
        }
        private class InformationOpenedUI
        {
            public List<Configuration.ControllerParameters.AdvancedFuncion> ElementsPrefix;
            public List<Configuration.ControllerParameters.AdvancedFuncion> ElementsNick;
            public List<Configuration.ControllerParameters.AdvancedFuncion> ElementsChat;
            public List<Configuration.ControllerParameters.AdvancedFuncion> ElementsRanks;
            public Int32 SlideIndexPrefix = 0;
            public Int32 SlideIndexNick = 0;
            public Int32 SlideIndexChat = 0;
            public Int32 SlideIndexRank = 0;
        }
        public String FormatTime(Double Second, String UserID = null)
        {
            TimeSpan time = TimeSpan.FromSeconds(Second);
            String Result = String.Empty;
            String Days = GetLang("TITLE_FORMAT_DAYS", UserID);
            String Hourse = GetLang("TITLE_FORMAT_HOURSE", UserID);
            String Minutes = GetLang("TITLE_FORMAT_MINUTES", UserID);
            String Seconds = GetLang("TITLE_FORMAT_SECONDS", UserID);

            if (time.Seconds != 0)
                Result = $"{Format(time.Seconds, Seconds, Seconds, Seconds)}";

            if (time.Minutes != 0)
                Result = $"{Format(time.Minutes, Minutes, Minutes, Minutes)}";

            if (time.Hours != 0)
                Result = $"{Format(time.Hours, Hourse, Hourse, Hourse)}";

            if (time.Days != 0)
                Result = $"{Format(time.Days, Days, Days, Days)}";

            return Result;
        }
        
        
        [ChatCommand("pm")]
        void PmChat(BasePlayer Sender, String cmd, String[] arg)
        {
            Configuration.ControllerMessage ControllerMessages = config.ControllerMessages;
            if (!ControllerMessages.TurnedFunc.PMSetting.PMActivate) return;
            if (arg.Length == 0 || arg == null)
            {
                ReplySystem(Sender, lang.GetMessage("COMMAND_PM_NOTARG", this, Sender.UserIDString));
                return;
            }

            Configuration.ControllerMessage.TurnedFuncional.AntiNoob.Settings antiNoob = config.ControllerMessages.TurnedFunc.AntiNoobSetting.AntiNoobPM;
            if (antiNoob.AntiNoobActivate)
                if (IsNoob(Sender.userID, antiNoob.TimeBlocked))
                {
                    ReplySystem(Sender, GetLang("IQCHAT_INFO_ANTI_NOOB_PM", Sender.UserIDString, FormatTime(UserInformationConnection[Sender.userID].LeftTime(antiNoob.TimeBlocked), Sender.UserIDString)));
                    return;
                }

            String NameUser = arg[0];

            if (config.ReferenceSetting.IQFakeActiveSettings.UseIQFakeActive)
                if (IQFakeActive)
                    if (IsFake(NameUser))
                    {
                        ReplySystem(Sender, GetLang("COMMAND_PM_SUCCESS", Sender.UserIDString, string.Join(" ", arg.ToArray()).Replace(NameUser, ""), NameUser));
                        return;
                    }

            BasePlayer TargetUser = GetPlayerNickOrID(NameUser);
            if (TargetUser == null || NameUser == null || !UserInformation.ContainsKey(TargetUser.userID))
            {
                ReplySystem(Sender, GetLang("COMMAND_PM_NOT_USER", Sender.UserIDString));
                return;
            }
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            User InfoTarget = UserInformation[TargetUser.userID];
            User InfoSender = UserInformation[Sender.userID];
            if (!InfoTarget.Settings.TurnPM)
            {
                ReplySystem(Sender, GetLang("FUNC_MESSAGE_PM_TURN_FALSE", Sender.UserIDString));
                return;
            }

            if (ControllerMessages.TurnedFunc.IgnoreUsePM)
            {
                if (InfoTarget.Settings.IsIgnored(Sender.userID))
                {
                    ReplySystem(Sender, GetLang("IGNORE_NO_PM", Sender.UserIDString));
                    return;
                }
                if (InfoSender.Settings.IsIgnored(TargetUser.userID))
                {
                    ReplySystem(Sender, GetLang("IGNORE_NO_PM_ME", Sender.UserIDString));
                    return;
                }
            }
            String Message = GetMessageInArgs(Sender, arg.Skip(1).ToArray());

            if (Message == null || Message.Length <= 0)
            {
                ReplySystem(Sender, GetLang("COMMAND_PM_NOT_NULL_MSG", Sender.UserIDString));
                return;
            }
            Message = Message.EscapeRichText();

            if (Message.Length > 125) return;

            PMHistory[TargetUser] = Sender;
            PMHistory[Sender] = TargetUser;

            GeneralInformation.RenameInfo RenamerSender = GeneralInfo.GetInfoRename(Sender.userID);
            GeneralInformation.RenameInfo RenamerTarget = GeneralInfo.GetInfoRename(TargetUser.userID);

            String DisplayNameSender = RenamerSender != null ? RenamerSender.RenameNick ?? Sender.displayName : Sender.displayName;
            String TargetDisplayName = RenamerTarget != null ? RenamerTarget.RenameNick ?? TargetUser.displayName : TargetUser.displayName;
            ReplySystem(TargetUser, GetLang("COMMAND_PM_SEND_MSG", TargetUser.UserIDString, DisplayNameSender, Message));
            ReplySystem(Sender, GetLang("COMMAND_PM_SUCCESS", Sender.UserIDString, Message, TargetDisplayName));

            if (InfoTarget.Settings.TurnSound)
                Effect.server.Run(ControllerMessages.TurnedFunc.PMSetting.SoundPM, TargetUser.GetNetworkPosition());

            Log(LanguageEn ? $"PRIVATE MESSAGES : {Sender.userID}({Sender.displayName}) sent a message to the player - {TargetUser.displayName}({TargetDisplayName})\nMESSAGE : {Message}" : $"ЛИЧНЫЕ СООБЩЕНИЯ : {Sender.userID}({Sender.displayName}) отправил сообщение игроку - {TargetUser.displayName}({TargetDisplayName})\nСООБЩЕНИЕ : {Message}");
            DiscordLoggPM(Sender, TargetUser, Message);
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            RCon.Broadcast(RCon.LogType.Chat, new Chat.ChatEntry
            {
                Message = LanguageEn ? $"PRIVATE MESSAGES : {Sender.displayName}({Sender.userID}) -> {TargetUser.displayName} : MESSAGE : {Message}" : $"ЛИЧНЫЕ СООБЩЕНИЯ : {Sender.displayName}({Sender.userID}) -> {TargetUser.displayName} : СООБЩЕНИЕ : {Message}",
                UserId = Sender.UserIDString,
                Username = Sender.displayName,
                Channel = Chat.ChatChannel.Global,
                Time = (DateTime.UtcNow.Hour * 3600) + (DateTime.UtcNow.Minute * 60),
                Color = "#3f4bb8",
            });
            PrintWarning(LanguageEn ? $"PRIVATE MESSAGES : {Sender.displayName}({Sender.userID}) -> {TargetUser.displayName} : MESSAGE : {Message}" : $"ЛИЧНЫЕ СООБЩЕНИЯ : {Sender.displayName}({Sender.userID}) -> {TargetUser.displayName} : СООБЩЕНИЕ : {Message}");
        }
		   		 		  						  	   		  	  			  	  			  	 				  	  	
        
        
                private const Boolean LanguageEn = false;

        
                void ReplyChat(Chat.ChatChannel channel, BasePlayer player, String OutMessage, String FormatPlayer)
        {
            Configuration.ControllerMessage ControllerMessages = config.ControllerMessages;

            User Info = UserInformation[player.userID];
            GeneralInformation.RenameInfo RenameInfo = GeneralInfo.GetInfoRename(player.userID);
            UInt64 RenameID = RenameInfo != null ? RenameInfo.RenameID != 0 ? RenameInfo.RenameID : player.userID : player.userID;

            if (channel == Chat.ChatChannel.Global)
            {
                foreach (BasePlayer p in BasePlayer.activePlayerList)
                {
                    if (OutMessage.Contains("@"))
                    {
                        String SplittedName = OutMessage.Substring(OutMessage.IndexOf('@')).Replace("@", "").Split(' ')[0];

                        BasePlayer playerTags = GetPlayerNickOrID(SplittedName);

                        if (playerTags != null)
                        {
                            User InfoP = UserInformation[playerTags.userID];

                            if (InfoP.Settings.TurnAlert && p == playerTags)
                            {
                                ReplySystem(p, $"<size=16>{OutMessage.Trim()}</size>", GetLang("IQCHAT_FUNCED_ALERT_TITLE", p.UserIDString), p.UserIDString, ControllerMessages.GeneralSetting.AlertFormat.AlertPlayerColor);
                                if (InfoP.Settings.TurnSound)
                                    Effect.server.Run(ControllerMessages.GeneralSetting.AlertFormat.SoundAlertPlayer, playerTags.GetNetworkPosition());
                            }
                            else p.SendConsoleCommand("chat.add", (int)channel, RenameID, $"{FormatPlayer}: {OutMessage}");
                            //else p.SendConsoleCommand("chat.add", new object[] { (int)channel, RenameID, OutMessage });
                        }
                        else p.SendConsoleCommand("chat.add", (int)channel, RenameID, $"{FormatPlayer}: {OutMessage}");
                    }
                    else p.SendConsoleCommand("chat.add", (int)channel, RenameID, $"{FormatPlayer}: {OutMessage}");

                    p.ConsoleMessage($"{FormatPlayer} {OutMessage}");
                }
            }
            if (channel == Chat.ChatChannel.Team)
            {
                RelationshipManager.PlayerTeam Team = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);
                if (Team == null) return;
                foreach (var FindPlayers in Team.members)
                {
                    BasePlayer TeamPlayer = BasePlayer.FindByID(FindPlayers);
                    if (TeamPlayer == null) continue;

                    TeamPlayer.SendConsoleCommand("chat.add", (int)channel, RenameID, $"{FormatPlayer}: {OutMessage}");
                }
            }
            if (channel == Chat.ChatChannel.Cards)
            {
                if (!player.isMounted)
                    return;

                CardTable cardTable = player.GetMountedVehicle() as CardTable;
                if (cardTable == null || !cardTable.GameController.PlayerIsInGame(player))
                    return;

                List<Network.Connection> PlayersCards = new List<Network.Connection>();
                cardTable.GameController.GetConnectionsInGame(PlayersCards);
                if (PlayersCards == null || PlayersCards.Count == 0)
                    return;

                foreach (Network.Connection PCard in PlayersCards)
                {
                    BasePlayer PlayerInRound = BasePlayer.FindByID(PCard.userid);
                    if (PlayerInRound == null) return;
                    PlayerInRound.SendConsoleCommand("chat.add", (int)channel, RenameID, $"{FormatPlayer}: {OutMessage}");
                }
            }
        }
        public List<String> KeyImages = new List<String>
        {
            "UI_IQCHAT_CONTEXT_NO_RANK",
            "UI_IQCHAT_CONTEXT_RANK",
            "IQCHAT_INFORMATION_ICON",
            "IQCHAT_SETTING_ICON",
            "IQCHAT_IGNORE_INFO_ICON",
            "IQCHAT_MODERATION_ICON",
            "IQCHAT_ELEMENT_PANEL_ICON",
            "IQCHAT_ELEMENT_PREFIX_MULTI_TAKE_ICON",
            "IQCHAT_ELEMENT_SLIDER_ICON",
            "IQCHAT_ELEMENT_SLIDER_LEFT_ICON",
            "IQCHAT_ELEMENT_SLIDER_RIGHT_ICON",
            "IQCHAT_ELEMENT_DROP_LIST_OPEN_ICON",
            "IQCHAT_ELEMENT_DROP_LIST_OPEN_ARGUMENT_ICON",
            "IQCHAT_ELEMENT_DROP_LIST_OPEN_TAKED",
            "IQCHAT_ELEMENT_SETTING_CHECK_BOX",
            "IQCHAT_ALERT_PANEL",
            "IQCHAT_MUTE_AND_IGNORE_PANEL",
            "IQCHAT_MUTE_AND_IGNORE_ICON",
            "IQCHAT_MUTE_AND_IGNORE_SEARCH",
            "IQCHAT_MUTE_AND_IGNORE_PAGE_PANEL",
            "IQCHAT_MUTE_AND_IGNORE_PLAYER",
            "IQCHAT_MUTE_AND_IGNORE_PLAYER_STATUS",
            "IQCHAT_IGNORE_ALERT_PANEL",
            "IQCHAT_IGNORE_ALERT_ICON",
            "IQCHAT_IGNORE_ALERT_BUTTON_YES",
            "IQCHAT_IGNORE_ALERT_BUTTON_NO",
            "IQCHAT_MUTE_ALERT_PANEL",
            "IQCHAT_MUTE_ALERT_ICON",
            "IQCHAT_MUTE_ALERT_PANEL_REASON",
        };
        public Dictionary<BasePlayer, BasePlayer> PMHistory = new Dictionary<BasePlayer, BasePlayer>();
        
        private void DrawUI_IQChat_Mute_And_Ignore(BasePlayer player, SelectedAction Action)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Mute_And_Ignore");
            if (Interface == null) return;

            Interface = Interface.Replace("%TITLE%", Action == SelectedAction.Mute ? GetLang("IQCHAT_TITLE_IGNORE_AND_MUTE_MUTED", player.UserIDString) : GetLang("IQCHAT_TITLE_IGNORE_AND_MUTE_IGNORED", player.UserIDString));
            Interface = Interface.Replace("%ACTION_TYPE%", $"{Action}");

            CuiHelper.DestroyUi(player, "MuteAndIgnoredPanel");
            CuiHelper.AddUi(player, Interface);

            DrawUI_IQChat_Mute_And_Ignore_Player_Panel(player, Action);
        }
        void OnPlayerCommand(BasePlayer player, string command, string[] args)
        {
            DiscordLoggCommand(player, command, args);
        }

                
        private String GetClanTag(UInt64 playerID)
        {
            if (!Clans) return String.Empty;
            if (!config.ReferenceSetting.ClansSettings.UseClanTag) return String.Empty;
            String ClanTag = (String)Clans?.CallHook("GetClanOf", playerID);

            return String.IsNullOrWhiteSpace(ClanTag) ? String.Empty : GetLang("CLANS_SYNTAX_PREFIX", playerID.ToString(), ClanTag);
        }

        [ConsoleCommand("hunmute")]
        void HideUnMuteConsole(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null)
                if (!permission.UserHasPermission(arg.Player().UserIDString, PermissionMute)) return;
            if (arg == null || arg.Args == null || arg.Args.Length != 1 || arg.Args.Length > 1)
            {
                PrintWarning(LanguageEn ? "Invalid syntax, please use : hunmute Steam64ID" : "Неверный синтаксис,используйте : hunmute Steam64ID");
                return;
            }
            string NameOrID = arg.Args[0];
            BasePlayer target = GetPlayerNickOrID(NameOrID);
            if (target == null)
            {
                UInt64 Steam64ID = 0;
                if (UInt64.TryParse(NameOrID, out Steam64ID))
                {
                    if (UserInformation.ContainsKey(Steam64ID))
                    {
                        User Info = UserInformation[Steam64ID];
                        if (Info == null) return;
                        if (!Info.MuteInfo.IsMute(MuteType.Chat))
                        {
                            ConsoleOrPrintMessage(arg.Player(),
                                LanguageEn ? "The player does not have a chat lock" : "У игрока нет блокировки чата");
                            return;
                        }
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                        Info.MuteInfo.UnMute(MuteType.Chat);
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                        ConsoleOrPrintMessage(arg.Player(),
                            LanguageEn ? "You have unblocked the offline chat to the player" : "Вы разблокировали чат offline игроку");
                        return;
                    }
                    else
                    {
                        ConsoleOrPrintMessage(arg.Player(),
                            LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                        return;
                    }
                }
                else
                {
                    ConsoleOrPrintMessage(arg.Player(),
                        LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                    return;
                }
            }

            UnmutePlayer(target, MuteType.Chat, arg.Player(), true, true);
        }
        [ConsoleCommand("adminalert")]
        private void AdminAlertConsoleCommand(ConsoleSystem.Arg args)
        {
            BasePlayer Sender = args.Player();
            if (Sender != null)
                if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;
            Alert(Sender, args.Args, true);
        }
        private const String PermissionMute = "iqchat.muteuse";
        private void DrawUI_IQChat_Update_MuteVoice_All(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermissionMutedAdmin)) return;

            String InterfaceAdministratorVoice = InterfaceBuilder.GetInterface("UI_Chat_Administation_AllVoce");
            if (InterfaceAdministratorVoice == null) return;

            InterfaceAdministratorVoice = InterfaceAdministratorVoice.Replace("%TEXT_MUTE_ALLVOICE%", GetLang(!GeneralInfo.TurnMuteAllVoice ? "IQCHAT_BUTTON_MODERATION_MUTE_ALL_VOICE" : "IQCHAT_BUTTON_MODERATION_UNMUTE_ALL_VOICE", player.UserIDString));
            InterfaceAdministratorVoice = InterfaceAdministratorVoice.Replace("%COMMAND_MUTE_ALLVOICE%", $"newui.cmd action.mute.ignore mute.controller {SelectedAction.Mute} mute.all.voice");

            CuiHelper.DestroyUi(player, "ModeratorMuteAllVoice");
            CuiHelper.AddUi(player, InterfaceAdministratorVoice);
        }
        private string StripHtmlTags(string input)
        {
            return Regex.Replace(input, "<.*?>", String.Empty);
        }
		   		 		  						  	   		  	  			  	  			  	 				  	  	
        
                void OnGroupPermissionGranted(string name, string perm)
        {
            String[] PlayerGroups = permission.GetUsersInGroup(name);
            if (PlayerGroups == null) return;

            foreach (String playerInfo in PlayerGroups)
            {
                BasePlayer player = BasePlayer.FindByID(UInt64.Parse(playerInfo.Substring(0, 17)));
                if (player == null) return;

                SetupParametres(player.UserIDString, perm);
            }
        }

        [ChatCommand("ignore")]
        void IgnorePlayerPM(BasePlayer player, String cmd, String[] arg)
        {
            Configuration.ControllerMessage ControllerMessages = config.ControllerMessages;
            if (!ControllerMessages.TurnedFunc.IgnoreUsePM) return;

            User Info = UserInformation[player.userID];

            if (arg.Length == 0 || arg == null)
            {
                ReplySystem(player, GetLang("INGORE_NOTARG", player.UserIDString));
                return;
            }
            String NameUser = arg[0];
            BasePlayer TargetUser = BasePlayer.Find(NameUser);
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            if (TargetUser == null || NameUser == null)
            {
                ReplySystem(player, GetLang("COMMAND_PM_NOT_USER", player.UserIDString));
                return;
            }

            String Lang = !Info.Settings.IsIgnored(TargetUser.userID) ? GetLang("IGNORE_ON_PLAYER", player.UserIDString, TargetUser.displayName) : GetLang("IGNORE_OFF_PLAYER", player.UserIDString, TargetUser.displayName);
            ReplySystem(player, Lang);

            Info.Settings.IgnoredAddOrRemove(TargetUser.userID);
        }

        private void DrawUI_IQChat_Mute_And_Ignore_Player_Panel(BasePlayer player, SelectedAction Action, Int32 Page = 0, String SearchName = null)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Mute_And_Ignore_Panel_Content");
            if (Interface == null) return;

            CuiHelper.DestroyUi(player, "MuteIgnorePanelContent");
            CuiHelper.AddUi(player, Interface);

            if (IQFakeActive)
            {
                var FakePlayerList = Action == SelectedAction.Mute ? SearchName != null ? PlayerBases.Where(p => p.DisplayName.ToLower().Contains(SearchName.ToLower())).OrderByDescending(p => !IsFake(p.UserID) && UserInformation.ContainsKey(p.UserID) && (UserInformation[p.UserID].MuteInfo.IsMute(MuteType.Chat) || UserInformation[p.UserID].MuteInfo.IsMute(MuteType.Voice))) : PlayerBases.OrderByDescending(p => !IsFake(p.UserID) && UserInformation.ContainsKey(p.UserID) && (UserInformation[p.UserID].MuteInfo.IsMute(MuteType.Chat) || UserInformation[p.UserID].MuteInfo.IsMute(MuteType.Voice))) :
                                                                            SearchName != null ? PlayerBases.Where(p => p.DisplayName.ToLower().Contains(SearchName.ToLower())).OrderByDescending(p => !IsFake(p.UserID) && UserInformation.ContainsKey(p.UserID) && (UserInformation[player.userID].Settings.IgnoreUsers.Contains(p.UserID))) : PlayerBases.OrderByDescending(p => !IsFake(p.UserID) && UserInformation.ContainsKey(p.UserID) && (UserInformation[player.userID].Settings.IgnoreUsers.Contains(p.UserID)));

                DrawUI_IQChat_Mute_And_Ignore_Pages(player, (Boolean)(FakePlayerList.Skip(18 * (Page + 1)).Count() > 0), Action, Page);
                DrawUI_IQChat_Mute_And_Ignore_Player(player, Action, null, FakePlayerList.Skip(18 * Page).Take(18));
            }
            else
            {
                IOrderedEnumerable<BasePlayer> PlayerList = Action == SelectedAction.Mute ? SearchName != null ? BasePlayer.activePlayerList.Where(p => UserInformation.ContainsKey(p.userID) && p.displayName.ToLower().Contains(SearchName.ToLower())).OrderBy(p => UserInformation[p.userID].MuteInfo.IsMute(MuteType.Chat) || UserInformation[p.userID].MuteInfo.IsMute(MuteType.Voice)) : BasePlayer.activePlayerList.Where(p => UserInformation.ContainsKey(p.userID)).OrderBy(p => UserInformation[p.userID].MuteInfo.IsMute(MuteType.Chat) || UserInformation[p.userID].MuteInfo.IsMute(MuteType.Voice)) :
                                                                         SearchName != null ? BasePlayer.activePlayerList.Where(p => UserInformation.ContainsKey(p.userID) && p.displayName.ToLower().Contains(SearchName.ToLower())).OrderBy(p => UserInformation[player.userID].Settings.IgnoreUsers.Contains(p.userID)) : BasePlayer.activePlayerList.Where(p => UserInformation.ContainsKey(p.userID)).OrderBy(p => UserInformation[player.userID].Settings.IgnoreUsers.Contains(p.userID));

                DrawUI_IQChat_Mute_And_Ignore_Pages(player, (Boolean)(PlayerList.Skip(18 * (Page + 1)).Count() > 0), Action, Page);
                DrawUI_IQChat_Mute_And_Ignore_Player(player, Action, PlayerList.Skip(18 * Page).Take(18));
            }
        }
        void API_ALERT_PLAYER(BasePlayer player, String Message, String CustomPrefix = null, String CustomAvatar = null, String CustomHex = null) => ReplySystem(player, Message, CustomPrefix, CustomAvatar, CustomHex);
        public String GetMessages(BasePlayer player, Dictionary<String, List<String>> LanguageMessages)
        {
            String LangPlayer = _.lang.GetLanguage(player.UserIDString);

            if (LanguageMessages.ContainsKey(LangPlayer))
                return LanguageMessages[LangPlayer].GetRandom();
            else if (LanguageMessages.ContainsKey("en"))
                return LanguageMessages["en"].GetRandom();
            else return LanguageMessages.FirstOrDefault().Value.GetRandom();
        }
        private void AlertController(BasePlayer player)
        {
            Configuration.ControllerAlert.Alert Alert = config.ControllerAlertSetting.AlertSetting;
            Configuration.ControllerAlert.AdminSession AlertSessionAdmin = config.ControllerAlertSetting.AdminSessionSetting;
            Configuration.ControllerAlert.PlayerSession AlertSessionPlayer = config.ControllerAlertSetting.PlayerSessionSetting;
            Configuration.ControllerAlert.PersonalAlert AlertPersonal = config.ControllerAlertSetting.PersonalAlertSetting;
            GeneralInformation.RenameInfo RenameInformation = GeneralInfo.GetInfoRename(player.userID);
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            String DisplayName = player.displayName;

            UInt64 UserID = player.userID;
            if (RenameInformation != null)
            {
                DisplayName = RenameInformation.RenameNick;
                UserID = RenameInformation.RenameID;
            }

            if (AlertSessionPlayer.ConnectedAlert)
            {
                if (!AlertSessionAdmin.ConnectedAlertAdmin)
                    if (player.IsAdmin) return;

                String Avatar = AlertSessionPlayer.ConnectedAvatarUse ? UserID.ToString() : String.Empty;

                if (AlertSessionPlayer.ConnectedWorld)
                {
                    String ipPlayer = player.IPlayer.Address;

                    if (player.net?.connection != null)
                    {
                        String[] ipPortPlayer = player.net.connection.ipaddress.Split(':');
                        if (ipPortPlayer.Length >= 1)
                            ipPlayer = ipPortPlayer[0]; 
                    }
                    
                    webrequest.Enqueue("http://ip-api.com/json/" + ipPlayer, null, (code, response) =>
                    {
                        if (code != 200 || response == null)
                            return;

                        String country = JsonConvert.DeserializeObject<Response>(response).Country;

                        if (!permission.UserHasPermission(player.UserIDString, PermissionHideConnection))
                        {
                            if (AlertSessionPlayer.ConnectionAlertRandom)
                                ReplyBroadcast(null, Avatar, false, AlertSessionPlayer.RandomConnectionAlert.LanguageMessages,DisplayName, country ?? "none");
                            else ReplyBroadcast(null, Avatar, false, "WELCOME_PLAYER_WORLD", DisplayName, country ?? "none");
                        }

                        Log($"[{player.userID}] {GetLang("WELCOME_PLAYER_WORLD", "", DisplayName, country ?? "none")}");
                    }, this);
                }
                else
                {
                    if (!permission.UserHasPermission(player.UserIDString, PermissionHideConnection))
                    {
                        if (AlertSessionPlayer.ConnectionAlertRandom)
                            ReplyBroadcast(null, Avatar, false,AlertSessionPlayer.RandomConnectionAlert.LanguageMessages, DisplayName);
                        else ReplyBroadcast(null, Avatar, false, "WELCOME_PLAYER", DisplayName);
                    }

                    Log($"[{player.userID}] {GetLang("WELCOME_PLAYER", "", DisplayName)}");
                }
            }
            if (AlertPersonal.UseWelcomeMessage)
            {
                String WelcomeMessage = GetMessages(player, AlertPersonal.WelcomeMessage.LanguageMessages);
                ReplySystem(player, WelcomeMessage);
            }
        }
        private enum ElementsSettingsType
        {
            PM,
            Broadcast,
            Alert,
            Sound
        }
        private void DrawUI_IQChat_Mute_Alert_Reasons(BasePlayer player, BasePlayer Target, MuteType Type, UInt64 IDFake = 0)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Mute_Alert_DropList_Title");
            if (Interface == null) return;

            Interface = Interface.Replace("%TITLE%", GetLang("IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_REASON", player.UserIDString));

            CuiHelper.DestroyUi(player, "AlertMuteTitleReason");
            CuiHelper.DestroyUi(player, "PanelMuteReason");
            CuiHelper.AddUi(player, Interface);

            List<Configuration.ControllerMute.Muted> Reasons = Type == MuteType.Chat ? config.ControllerMutes.MuteChatReasons : config.ControllerMutes.MuteVoiceReasons;

            Int32 Y = 0;
            foreach (Configuration.ControllerMute.Muted Reason in Reasons.Take(6))
                DrawUI_IQChat_Mute_Alert_Reasons(player, Target, Reason.Reason, Y++, Type, IDFake);
        }

        private String GetReferenceTags(BasePlayer player)
        {
            String Result = String.Empty;
            String Rank = String.Empty;
            String RankTime = String.Empty;
            if (IQRankSystem)
            {
                Configuration.ReferenceSettings.IQRankSystem IQRank = config.ReferenceSetting.IQRankSystems;

                if (IQRank.UseRankSystem)
                {
                    if (IQRank.UseTimeStandart)
                        RankTime = String.IsNullOrWhiteSpace(IQRankGetTimeGame(player.userID)) ? String.Empty : String.Format(IQRank.FormatRank, IQRankGetTimeGame(player.userID));
                    Rank = String.IsNullOrWhiteSpace(IQRankGetRank(player.userID)) ? String.Empty : String.Format(IQRank.FormatRank, IQRankGetRank(player.userID));

                    if (!String.IsNullOrWhiteSpace(RankTime))
                        Result += $"{RankTime} ";
                    if (!String.IsNullOrWhiteSpace(Rank))
                        Result += $"{Rank} ";
                }
            }

            String XLevel = config.ReferenceSetting.XLevelsSettings.UseFullXLevels ? XLevel_GetPrefix(player) : XLevel_GetLevel(player);
            if (!String.IsNullOrWhiteSpace(XLevel))
                Result += $"{XLevel} ";

            String ClanTag = GetClanTag(player.userID);
            if (!String.IsNullOrWhiteSpace(ClanTag))
                Result += $"{ClanTag} ";

            return Result;
        }
		   		 		  						  	   		  	  			  	  			  	 				  	  	
        private void UnmutePlayer(BasePlayer Target, MuteType Type, BasePlayer Moderator = null, Boolean HideUnmute = false, Boolean Command = false)
        {
            if (!UserInformation.ContainsKey(Target.userID)) return;
            User Info = UserInformation[Target.userID];

            GeneralInformation.RenameInfo TargetRename = GeneralInfo.GetInfoRename(Target.userID);
            GeneralInformation.RenameInfo ModeratorRename = Moderator != null ? GeneralInfo.GetInfoRename(Moderator.userID) : null;
            if (!Info.MuteInfo.IsMute(Type))
            {
                if (Moderator != null)
                    ReplySystem(Moderator, LanguageEn ? "The player is not banned" : "У игрока нет блокировки");
                else Puts(LanguageEn ? "The player is not banned!" : "У игрока нет блокировки!");
                return;
            }

            String TargetName = TargetRename != null ? $"{TargetRename.RenameNick ?? Target.displayName}" : Target.displayName;
            String NameModerator = Moderator == null ? GetLang("IQCHAT_FUNCED_ALERT_TITLE_SERVER", Target.UserIDString) : ModeratorRename != null ? $"{ModeratorRename.RenameNick ?? Moderator.displayName}" : Moderator.displayName;
            String LangMessage = Type == MuteType.Chat ? "FUNC_MESSAGE_UNMUTE_CHAT" : "FUNC_MESSAGE_UNMUTE_VOICE";

            if (!HideUnmute)
                ReplyBroadcast(null, null, false, LangMessage, NameModerator, TargetName);
               // ReplyBroadcast(GetLang(LangMessage, Target.UserIDString, NameModerator, TargetName));
            else
            {
                if (Target != null)
                    ReplySystem(Target, GetLang(LangMessage, Target.UserIDString, NameModerator, TargetName));
                if (Moderator != null)
                    ReplySystem(Moderator, GetLang(LangMessage, Target.UserIDString, NameModerator, TargetName));
            }

            Info.MuteInfo.UnMute(Type);

            DiscordLoggMuted(Target, Type, Moderator: Moderator);
        }

        
        private void ConsoleOrPrintMessage(BasePlayer player, String Messages)
        {
            if (player != null)
                player.ConsoleMessage(Messages);
            else PrintWarning(Messages);
        }

        
                [ChatCommand("online")]
        private void ShowPlayerOnline(BasePlayer player)
        {
            if (!config.OtherSetting.UseCommandOnline) return;

            List<String> PlayerNames = GetPlayersOnline();
            String Message = GetLang("IQCHAT_INFO_ONLINE", player.UserIDString, String.Join($"\n", PlayerNames));
            ReplySystem(player, Message);
        }
        String API_GET_DEFAULT_MESSAGE_COLOR() => config.ControllerConnect.SetupDefaults.MessageDefault;

        private void DrawUI_IQChat_OpenDropListArgument(BasePlayer player, TakeElementUser ElementType, Configuration.ControllerParameters.AdvancedFuncion Info, Int32 X, Int32 Y, Int32 Count)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_OpenDropListArgument");
            if (Interface == null) return;
            String Argument = ElementType == TakeElementUser.MultiPrefix || ElementType == TakeElementUser.Prefix ? Info.Argument :
                    ElementType == TakeElementUser.Nick ? $"<color={Info.Argument}>{player.displayName}</color>" :
                    ElementType == TakeElementUser.Chat ? $"<color={Info.Argument}>{GetLang("IQCHAT_CONTEXT_NICK_DISPLAY_MESSAGE", player.UserIDString)}</color>" :
                    ElementType == TakeElementUser.Rank ? IQRankGetNameRankKey(Info.Argument) : String.Empty;

            Interface = Interface.Replace("%OFFSET_MIN%", $"{-140.329 - (-103 * X)} {-2.243 + (Y * -28)}");
            Interface = Interface.Replace("%OFFSET_MAX%", $"{-65.271 - (-103 * X)} {22.568 + (Y * -28)}");
            Interface = Interface.Replace("%COUNT%", Count.ToString());
            Interface = Interface.Replace("%ARGUMENT%", Argument);
            Interface = Interface.Replace("%TAKE_COMMAND_ARGUMENT%", $"newui.cmd droplist.controller element.take {ElementType} {Count} {Info.Permissions} {Info.Argument}");

            CuiHelper.DestroyUi(player, $"ArgumentDropList_{Count}");
            CuiHelper.AddUi(player, Interface);
        }

        [ChatCommand("hmute")]
        void HideMute(BasePlayer Moderator, string cmd, string[] arg)
        {
            if (!permission.UserHasPermission(Moderator.UserIDString, PermissionMute)) return;
            if (arg == null || arg.Length != 3 || arg.Length > 3)
            {
                ReplySystem(Moderator, LanguageEn ? "Invalid syntax, use : hmute Steam64ID/Nick Reason Time(seconds)" : "Неверный синтаксис,используйте : hmute Steam64ID/Ник Причина Время(секунды)");
                return;
            }
            string NameOrID = arg[0];
            string Reason = arg[1];
            Int32 TimeMute = 0;
            if (!Int32.TryParse(arg[2], out TimeMute))
            {
                ReplySystem(Moderator, LanguageEn ? "Enter the time in numbers!" : "Введите время цифрами!");
                return;
            }
            BasePlayer target = GetPlayerNickOrID(NameOrID);
            if (target == null)
            {
                UInt64 Steam64ID = 0;
                if (UInt64.TryParse(NameOrID, out Steam64ID))
                {
                    if (UserInformation.ContainsKey(Steam64ID))
                    {
                        User Info = UserInformation[Steam64ID];
                        if (Info == null) return;
                        if (Info.MuteInfo.IsMute(MuteType.Chat))
                        {
                            ReplySystem(Moderator, LanguageEn ? "The player already has a chat lock" : "Игрок уже имеет блокировку чата");
                            return;
                        }

                        Info.MuteInfo.SetMute(MuteType.Chat, TimeMute);
                        ReplySystem(Moderator, LanguageEn ? "Chat blocking issued to offline player" : "Блокировка чата выдана offline-игроку");
                        return;
                    }
                    else
                    {
                        ReplySystem(Moderator, LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                        return;
                    }
                }
                else
                {
                    ReplySystem(Moderator, LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                    return;
                }
            }

            MutePlayer(target, MuteType.Chat, 0, Moderator, Reason, TimeMute, true, true);
        }

        private String RemoveLinkText(String text)
        {
            String hrefPattern = "([A-Za-z0-9-А-Яа-я]|https?://)[^ ]+\\.(com|lt|net|org|gg|ru|рф|int|info|ru.com|ru.net|com.ru|net.ru|рус|org.ru|moscow|biz|орг|su)";
            Regex rgx = new Regex(hrefPattern, RegexOptions.IgnoreCase);

            return config.ControllerMessages.Formatting.ControllerNickname.AllowedLinkNick.Contains(rgx.Match(text).Value) ? text : rgx.Replace(text, "").Trim();
        }

        [ChatCommand("r")]
        void RChat(BasePlayer Sender, string cmd, string[] arg)
        {
            Configuration.ControllerMessage ControllerMessages = config.ControllerMessages;
            if (!ControllerMessages.TurnedFunc.PMSetting.PMActivate) return;

            if (arg.Length == 0 || arg == null)
            {
                ReplySystem(Sender, GetLang("COMMAND_R_NOTARG", Sender.UserIDString));
                return;
            }

            Configuration.ControllerMessage.TurnedFuncional.AntiNoob.Settings antiNoob = config.ControllerMessages.TurnedFunc.AntiNoobSetting.AntiNoobPM;
            if (antiNoob.AntiNoobActivate)
                if (IsNoob(Sender.userID, antiNoob.TimeBlocked))
                {
                    ReplySystem(Sender, GetLang("IQCHAT_INFO_ANTI_NOOB_PM", Sender.UserIDString, FormatTime(UserInformationConnection[Sender.userID].LeftTime(antiNoob.TimeBlocked), Sender.UserIDString)));
                    return;
                }

            if (!PMHistory.ContainsKey(Sender))
            {
                ReplySystem(Sender, GetLang("COMMAND_R_NOTMSG", Sender.UserIDString));
                return;
            }

            BasePlayer RetargetUser = PMHistory[Sender];
            if (RetargetUser == null)
            {
                ReplySystem(Sender, GetLang("COMMAND_PM_NOT_USER", Sender.UserIDString));
                return;
            }
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            User InfoRetarget = UserInformation[RetargetUser.userID];
            User InfoSender = UserInformation[RetargetUser.userID];

            if (!InfoRetarget.Settings.TurnPM)
            {
                ReplySystem(Sender, GetLang("FUNC_MESSAGE_PM_TURN_FALSE", Sender.UserIDString));
                return;
            }
            if (ControllerMessages.TurnedFunc.IgnoreUsePM)
            {
                if (InfoRetarget.Settings.IsIgnored(Sender.userID))
                {
                    ReplySystem(Sender, GetLang("IGNORE_NO_PM", Sender.UserIDString));
                    return;
                }
                if (InfoSender.Settings.IsIgnored(RetargetUser.userID))
                {
                    ReplySystem(Sender, GetLang("IGNORE_NO_PM_ME", Sender.UserIDString));
                    return;
                }
            }

            String Message = GetMessageInArgs(Sender, arg);
            if (Message == null || Message.Length <= 0)
            {
                ReplySystem(Sender, GetLang("COMMAND_PM_NOT_NULL_MSG", Sender.UserIDString));
                return;
            }
            if (Message.Length > 125) return;
            Message = Message.EscapeRichText();

            PMHistory[RetargetUser] = Sender;

            GeneralInformation.RenameInfo RenameSender = GeneralInfo.GetInfoRename(Sender.userID);
            GeneralInformation.RenameInfo RenamerTarget = GeneralInfo.GetInfoRename(RetargetUser.userID);
            String DisplayNameSender = RenameSender != null ? RenameSender.RenameNick ?? Sender.displayName : Sender.displayName;
            String TargetDisplayName = RenamerTarget != null ? RenamerTarget.RenameNick ?? RetargetUser.displayName : RetargetUser.displayName;
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            ReplySystem(RetargetUser, GetLang("COMMAND_PM_SEND_MSG", RetargetUser.UserIDString, DisplayNameSender, Message));
            ReplySystem(Sender, GetLang("COMMAND_PM_SUCCESS", Sender.UserIDString, Message, TargetDisplayName));

            if (InfoRetarget.Settings.TurnSound)
                Effect.server.Run(ControllerMessages.TurnedFunc.PMSetting.SoundPM, RetargetUser.GetNetworkPosition());

            Log(LanguageEn ? $"PRIVATE MESSAGES : {Sender.displayName} sent a message to the player - {RetargetUser.displayName}\nMESSAGE : {Message}" : $"ЛИЧНЫЕ СООБЩЕНИЯ : {Sender.displayName} отправил сообщение игроку - {RetargetUser.displayName}\nСООБЩЕНИЕ : {Message}");
            DiscordLoggPM(Sender, RetargetUser, Message);

            RCon.Broadcast(RCon.LogType.Chat, new Chat.ChatEntry
            {
                Message = LanguageEn ? $"PRIVATE MESSAGES : {Sender.displayName}({Sender.userID}) -> {RetargetUser.displayName} : MESSAGE : {Message}" : $"ЛИЧНЫЕ СООБЩЕНИЯ : {Sender.displayName}({Sender.userID}) -> {RetargetUser.displayName} : СООБЩЕНИЕ : {Message}",
                UserId = Sender.UserIDString,
                Username = Sender.displayName,
                Channel = Chat.ChatChannel.Global,
                Time = (DateTime.UtcNow.Hour * 3600) + (DateTime.UtcNow.Minute * 60),
                Color = "#3f4bb8",
            });
            PrintWarning(LanguageEn ? $"PRIVATE MESSAGES : {Sender.displayName}({Sender.userID}) -> {RetargetUser.displayName} : MESSAGE : {Message}" : $"ЛИЧНЫЕ СООБЩЕНИЯ : {Sender.displayName}({Sender.userID}) -> {RetargetUser.displayName} : СООБЩЕНИЕ : {Message}");
        }

        private void DiscordLoggPM(BasePlayer Sender, BasePlayer Reciepter, String MessageLogged)
        {
            Configuration.OtherSettings.General PMChat = config.OtherSetting.LogsPMChat;
            if (!PMChat.UseLogged) return;

            GeneralInformation.RenameInfo SenderRename = GeneralInfo.GetInfoRename(Sender.userID);
            GeneralInformation.RenameInfo ReciepterRename = GeneralInfo.GetInfoRename(Reciepter.userID);

            UInt64 UserIDSender = SenderRename != null ? SenderRename.RenameID == 0 ? Sender.userID : SenderRename.RenameID : Sender.userID;
            UInt64 UserIDReciepter = ReciepterRename != null ? ReciepterRename.RenameID == 0 ? Reciepter.userID : ReciepterRename.RenameID : Reciepter.userID;
            String SenderName = SenderRename != null ? ReciepterRename.RenameNick ?? Sender.displayName : Sender.displayName;
            String ReciepterName = ReciepterRename != null ? ReciepterRename.RenameNick ?? Reciepter.displayName : Reciepter.displayName;
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            List<Fields> fields = new List<Fields>
                        {
                            new Fields(LanguageEn ? "Sender" : "Отправитель", $"{SenderName}({UserIDSender})", true),
                            new Fields(LanguageEn ? "Recipient" : "Получатель", $"{ReciepterName}({UserIDReciepter})", true),
                            new Fields(LanguageEn ? "Message" : "Сообщение", MessageLogged, false),
                        };

            FancyMessage newMessage = new FancyMessage(null, false, new FancyMessage.Embeds[1] { new FancyMessage.Embeds(null, 16608621, fields, new Authors("IQChat PM-History", null, "https://i.imgur.com/xiwsg5m.png", null), null) });

            Request($"{PMChat.Webhooks}", newMessage.toJSON());
        }

        private static InterfaceBuilder _interface;
        public class FakePlayer
        {
            public string DisplayName;
            public ulong UserID;
        }
        private void DiscordLoggChat(BasePlayer player, Chat.ChatChannel Channel, String MessageLogged)
        {
            List<Fields> fields = new List<Fields>
                        {
                            new Fields(LanguageEn ? "Nick" : "Ник", player.displayName, true),
                            new Fields("Steam64ID", player.UserIDString, true),
                            new Fields(LanguageEn ? "Channel" : "Канал", Channel == Chat.ChatChannel.Global ? (LanguageEn ? "Global" : "Глобальный чат") : Channel == Chat.ChatChannel.Cards ? (LanguageEn ? "Poker" : "Покерный чат") : (LanguageEn ? "Team" : "Командный чат"), true),
                            new Fields(LanguageEn ? "Message" : "Сообщение", MessageLogged, false),
                        };

            FancyMessage newMessage = new FancyMessage(null, false, new FancyMessage.Embeds[1] { new FancyMessage.Embeds(null, 10710525, fields, new Authors("IQChat Chat-History", null, "https://i.imgur.com/xiwsg5m.png", null), null) });

            switch (Channel)
            {
                case Chat.ChatChannel.Cards:
                case Chat.ChatChannel.Global:
                    {
                        Configuration.OtherSettings.General GlobalChat = config.OtherSetting.LogsChat.GlobalChatSettings;
                        if (!GlobalChat.UseLogged) return;
                        Request($"{GlobalChat.Webhooks}", newMessage.toJSON());
                        break;
                    }
                case Chat.ChatChannel.Team:
                    {
                        Configuration.OtherSettings.General TeamChat = config.OtherSetting.LogsChat.TeamChatSettings;
                        if (!TeamChat.UseLogged) return;
                        Request($"{TeamChat.Webhooks}", newMessage.toJSON());
                    }
                    break;
                default:
                    break;
            }
        }
        String API_GET_DEFAULT_PREFIX() => config.ControllerConnect.SetupDefaults.PrefixDefault;
        protected override void SaveConfig() => Config.WriteObject(config);
        [ChatCommand("alertuip")]
        private void AlertUIPChatCommand(BasePlayer Sender, String cmd, String[] args)
        {
            if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;
            if (args == null || args.Length == 0)
            {
                ReplySystem(Sender, LanguageEn ? "You didn't specify a player!" : "Вы не указали игрока!");
                return;
            }
            BasePlayer Recipient = BasePlayer.Find(args[0]);
            if (Recipient == null)
            {
                ReplySystem(Sender, LanguageEn ? "The player is not on the server!" : "Игрока нет на сервере!");
                return;
            }
            AlertUI(Sender, Recipient, args.Skip(1).ToArray());
        }

        private const String PermissionHideOnline = "iqchat.onlinehide";

        
                void AlertUI(BasePlayer Sender, string[] arg)
        {
            if (_interface == null)
            {
                PrintWarning(LanguageEn ? "We generate the interface, wait for a message about successful generation" : "Генерируем интерфейс, ожидайте сообщения об успешной генерации");
                return;
            }
            String Message = GetMessageInArgs(Sender, arg);
            if (Message == null) return;

            foreach (BasePlayer PlayerInList in BasePlayer.activePlayerList)
                DrawUI_IQChat_Alert(PlayerInList, Message);
        }
        
                public void RemoveReserved(UInt64 userID)
        {
            if (!IQFakeActive) return;
            IQFakeActive?.Call("RemoveReserver", userID);
        }
		   		 		  						  	   		  	  			  	  			  	 				  	  	
        
                public Boolean IsNoob(UInt64 userID, Int32 TimeBlocked)
        {
            if (UserInformationConnection.ContainsKey(userID))
                return UserInformationConnection[userID].IsNoob(TimeBlocked);
            return false;
        }
        void API_ALERT(String Message, Chat.ChatChannel channel = Chat.ChatChannel.Global, String CustomPrefix = null, String CustomAvatar = null, String CustomHex = null)
        {
            foreach (BasePlayer p in BasePlayer.activePlayerList)
                ReplySystem(p, Message, CustomPrefix, CustomAvatar, CustomHex);
        }
        Boolean API_CHECK_MUTE_CHAT(UInt64 ID)
        {
            if (!UserInformation.ContainsKey(ID)) return false;
            return UserInformation[ID].MuteInfo.IsMute(MuteType.Chat);
        }
        void Unload()
        {
            InterfaceBuilder.DestroyAll();

            WriteData();
            _ = null;
        }
        
        void ReplyBroadcast(String CustomPrefix = null, String CustomAvatar = null, Boolean AdminAlert = false, String LangKey = "", params object[] args)
        {
            foreach (BasePlayer p in !AdminAlert ? BasePlayer.activePlayerList.Where(p => UserInformation[p.userID].Settings.TurnBroadcast) : BasePlayer.activePlayerList)
                ReplySystem(p,GetLang(LangKey, p.UserIDString, args), CustomPrefix, CustomAvatar);
        }

        [ConsoleCommand("unmute")]
        void UnMuteCustomAdmin(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null)
                if (!permission.UserHasPermission(arg.Player().UserIDString, PermissionMute)) return;

            if (arg?.Args == null || arg.Args.Length != 1 || arg.Args.Length > 1)
            {
                PrintWarning(LanguageEn ? "Invalid syntax, please use : unmute Steam64ID" : "Неверный синтаксис,используйте : unmute Steam64ID");
                return;
            }

            string NameOrID = arg.Args[0];
            BasePlayer target = GetPlayerNickOrID(NameOrID);

            if (target == null)
            {
                UInt64 Steam64ID = 0;
                if (UInt64.TryParse(NameOrID, out Steam64ID))
                {
                    if (UserInformation.ContainsKey(Steam64ID))
                    {
                        User Info = UserInformation[Steam64ID];
                        if (Info == null) return;
                        if (!Info.MuteInfo.IsMute(MuteType.Chat))
                        {
                            ConsoleOrPrintMessage(arg.Player(),
                                LanguageEn ? "The player does not have a chat lock" : "У игрока нет блокировки чата");
                            return;
                        }

                        Info.MuteInfo.UnMute(MuteType.Chat);

                        ConsoleOrPrintMessage(arg.Player(),
                            LanguageEn ? "You have unblocked the offline chat to the player" : "Вы разблокировали чат offline игроку");
                        return;
                    }
                    else
                    {
                        ConsoleOrPrintMessage(arg.Player(),
                            LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                        return;
                    }
                }
                else
                {
                    ConsoleOrPrintMessage(arg.Player(),
                        LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                    return;
                }
            }

            UnmutePlayer(target, MuteType.Chat, arg.Player(), false, true);
            Puts(LanguageEn ? "Successfully" : "Успешно");
        }

        
                
        private void Log(String LoggedMessage) => LogToFile("IQChatLogs", LoggedMessage, this);

        [ChatCommand("alertui")]
        private void AlertUIChatCommand(BasePlayer Sender, String cmd, String[] args)
        {
            if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;
            AlertUI(Sender, args);
        }
        private void DrawUI_IQChat_Mute_And_Ignore_Pages(BasePlayer player, Boolean IsNextPage, SelectedAction Action, Int32 Page = 0)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Mute_And_Ignore_Pages");
            if (Interface == null) return;
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            String CommandRight = IsNextPage ? $"newui.cmd action.mute.ignore page.controller {Action} {Page + 1}" : String.Empty;
            String ColorRight = String.IsNullOrEmpty(CommandRight) ? "1 1 1 0.1" : "1 1 1 1";

            String CommandLeft = Page > 0 ? $"newui.cmd action.mute.ignore page.controller {Action} {Page - 1}" : String.Empty;
            String ColorLeft = String.IsNullOrEmpty(CommandLeft) ? "1 1 1 0.1" : "1 1 1 1";
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            Interface = Interface.Replace("%COMMAND_LEFT%", CommandLeft);
            Interface = Interface.Replace("%COMMAND_RIGHT%", CommandRight);
            Interface = Interface.Replace("%PAGE%", $"{Page}");
            Interface = Interface.Replace("%COLOR_LEFT%", ColorLeft);
            Interface = Interface.Replace("%COLOR_RIGHT%", ColorRight);

            CuiHelper.DestroyUi(player, "PageCount");
            CuiHelper.DestroyUi(player, "LeftPage");
            CuiHelper.DestroyUi(player, "RightPage");
            CuiHelper.AddUi(player, Interface);
        }

        [ConsoleCommand("hmute")]
        void HideMuteConsole(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null)
                if (!permission.UserHasPermission(arg.Player().UserIDString, PermissionMute)) return;

            if (arg == null || arg.Args == null || arg.Args.Length != 3 || arg.Args.Length > 3)
            {
                ConsoleOrPrintMessage(arg.Player(),
                    LanguageEn
                        ? "Invalid syntax, use : hmute Steam64ID Reason Time (seconds)"
                        : "Неверный синтаксис,используйте : hmute Steam64ID Причина Время(секунды)");
                return;
            }
            string NameOrID = arg.Args[0];
            string Reason = arg.Args[1];
            Int32 TimeMute = 0;
            if (!Int32.TryParse(arg.Args[2], out TimeMute))
            {
                ConsoleOrPrintMessage(arg.Player(),
                    LanguageEn ? "Enter the time in numbers!" : "Введите время цифрами!");
                return;
            }
            BasePlayer target = GetPlayerNickOrID(NameOrID);
            if (target == null)
            {
                UInt64 Steam64ID = 0;
                if (UInt64.TryParse(NameOrID, out Steam64ID))
                {
                    if (UserInformation.ContainsKey(Steam64ID))
                    {
                        User Info = UserInformation[Steam64ID];
                        if (Info == null) return;
                        if (Info.MuteInfo.IsMute(MuteType.Chat))
                        {
                            ConsoleOrPrintMessage(arg.Player(),
                                LanguageEn ? "The player already has a chat lock" : "Игрок уже имеет блокировку чата");
                            return;
                        }

                        Info.MuteInfo.SetMute(MuteType.Chat, TimeMute);

                        ConsoleOrPrintMessage(arg.Player(),
                            LanguageEn ? "Chat blocking issued to offline player" : "Блокировка чата выдана offline-игроку");
                        return;
                    }
                    else
                    {
                        ConsoleOrPrintMessage(arg.Player(),
                            LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                        return;
                    }
                }
                else
                {
                    ConsoleOrPrintMessage(arg.Player(),
                        LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                    return;
                }
            }

            MutePlayer(target, MuteType.Chat, 0, arg.Player(), Reason, TimeMute, true, true);
        }
        class Response
        {
            [JsonProperty("country")]
            public string Country { get; set; }
        }

        void ReplySystem(BasePlayer player, String Message, String CustomPrefix = null, String CustomAvatar = null, String CustomHex = null)
        {
            Configuration.ControllerMessage ControllerMessages = config.ControllerMessages;

            String Prefix = (CustomPrefix == null || String.IsNullOrWhiteSpace(CustomPrefix)) ? (ControllerMessages.GeneralSetting.BroadcastFormat.BroadcastTitle == null || String.IsNullOrWhiteSpace(ControllerMessages.GeneralSetting.BroadcastFormat.BroadcastTitle)) ? "" : ControllerMessages.GeneralSetting.BroadcastFormat.BroadcastTitle : CustomPrefix;
            String AvatarID = (CustomAvatar == null || String.IsNullOrWhiteSpace(CustomAvatar)) ? (ControllerMessages.GeneralSetting.BroadcastFormat.Steam64IDAvatar == null || String.IsNullOrWhiteSpace(ControllerMessages.GeneralSetting.BroadcastFormat.Steam64IDAvatar)) ? "0" : ControllerMessages.GeneralSetting.BroadcastFormat.Steam64IDAvatar : CustomAvatar;
            String Hex = (CustomHex == null || String.IsNullOrWhiteSpace(CustomHex)) ? (ControllerMessages.GeneralSetting.BroadcastFormat.BroadcastColor == null || String.IsNullOrWhiteSpace(ControllerMessages.GeneralSetting.BroadcastFormat.BroadcastColor)) ? "#ffff" : ControllerMessages.GeneralSetting.BroadcastFormat.BroadcastColor : CustomHex;
           
            player.SendConsoleCommand("chat.add", Chat.ChatChannel.Global, AvatarID, $"{Prefix}<color={Hex}>{Message}</color>");
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        private void MigrateDataToNoob()
        {
            if (config.ControllerMessages.TurnedFunc.AntiNoobSetting.AntiNoobPM.AntiNoobActivate || config.ControllerMessages.TurnedFunc.AntiNoobSetting.AntiNoobChat.AntiNoobActivate)
            {
                if (UserInformationConnection.Count == 0 || UserInformationConnection == null)
                {
                    PrintWarning(LanguageEn ? "Migration of old players to Anti-Nub.." : "Миграция старых игроков в Анти-Нуб..");
                    foreach (KeyValuePair<UInt64, User> InfoUser in UserInformation.Where(x => !UserInformationConnection.ContainsKey(x.Key)))
                        UserInformationConnection.Add(InfoUser.Key, new AntiNoob { DateConnection = new DateTime(2022, 1, 1) });
                    PrintWarning(LanguageEn ? "Migration of old players completed" : "Миграция старых игроков завершена");
                }
            }
        }
        public bool IsFake(String DisplayName)
        {
            if (!IQFakeActive) return false;

            return (bool)IQFakeActive?.Call("IsFake", DisplayName);
        }
        Boolean API_CHECK_VOICE_CHAT(UInt64 ID)
        {
            if (!UserInformation.ContainsKey(ID)) return false;
            return UserInformation[ID].MuteInfo.IsMute(MuteType.Voice);
        }

        
                public GeneralInformation GeneralInfo = new GeneralInformation();
        private void SeparatorChat(Chat.ChatChannel channel, BasePlayer player, String Message)
        {
            Configuration.ControllerMessage.TurnedFuncional.AntiNoob.Settings antiNoob = config.ControllerMessages.TurnedFunc.AntiNoobSetting.AntiNoobChat;
            if (antiNoob.AntiNoobActivate)
                if (IsNoob(player.userID, antiNoob.TimeBlocked))
                {
                    ReplySystem(player, GetLang("IQCHAT_INFO_ANTI_NOOB", player.UserIDString, FormatTime(UserInformationConnection[player.userID].LeftTime(antiNoob.TimeBlocked), player.UserIDString)));
                    return;
                }

            Configuration.ControllerMessage ControllerMessage = config.ControllerMessages;
            User Info = UserInformation[player.userID];

            if (ControllerMessage.TurnedFunc.AntiSpamSetting.AntiSpamActivate)
                if (!permission.UserHasPermission(player.UserIDString, PermissionAntiSpam))
                {
                    if (!Info.MuteInfo.IsMute(MuteType.Chat))
                    {
                        if (!Flooders.ContainsKey(player.userID))
                            Flooders.Add(player.userID, new FlooderInfo { Time = CurrentTime + ControllerMessage.TurnedFunc.AntiSpamSetting.FloodTime, LastMessage = Message });
                        else
                        {
                            if (Flooders[player.userID].Time > CurrentTime)
                            {
                                ReplySystem(player, GetLang("FLOODERS_MESSAGE", player.UserIDString, Convert.ToInt32(Flooders[player.userID].Time - CurrentTime)));
                                return;
                            }

                            if (ControllerMessage.TurnedFunc.AntiSpamSetting.AntiSpamDuplesSetting.AntiSpamDuplesActivate)
                            {
                                if (Flooders[player.userID].LastMessage == Message)
                                {
                                    if (Flooders[player.userID].TryFlood >= ControllerMessage.TurnedFunc.AntiSpamSetting.AntiSpamDuplesSetting.TryDuples)
                                    {
                                        MutePlayer(player, MuteType.Chat, 0, null, ControllerMessage.TurnedFunc.AntiSpamSetting.AntiSpamDuplesSetting.MuteSetting.Reason, ControllerMessage.TurnedFunc.AntiSpamSetting.AntiSpamDuplesSetting.MuteSetting.SecondMute);
                                        Flooders[player.userID].TryFlood = 0;
                                        return;
                                    }
                                    Flooders[player.userID].TryFlood++;
                                }
                            }
                        }
                        Flooders[player.userID].Time = ControllerMessage.TurnedFunc.AntiSpamSetting.FloodTime + CurrentTime;
                        Flooders[player.userID].LastMessage = Message;
                    }
                }

            GeneralInformation General = GeneralInfo;
            GeneralInformation.RenameInfo RenameInformation = General.GetInfoRename(player.userID);
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            Configuration.ControllerParameters ControllerParameter = config.ControllerParameter;
            Configuration.ControllerMute ControllerMutes = config.ControllerMutes;
            Configuration.ControllerMessage.GeneralSettings.OtherSettings OtherController = config.ControllerMessages.GeneralSetting.OtherSetting;

            if (General.TurnMuteAllChat)
            {
                ReplySystem(player, GetLang("IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_CHAT", player.UserIDString));
                return;
            }
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            if (channel == Chat.ChatChannel.Team && !ControllerMessage.TurnedFunc.MuteTeamChat) { }
            else if (Info.MuteInfo.IsMute(MuteType.Chat))
            {
                ReplySystem(player,
                    GetLang("IQCHAT_FUNCED_NO_SEND_CHAT_MUTED", player.UserIDString,
                        FormatTime(Info.MuteInfo.GetTime(MuteType.Chat), player.UserIDString)));
                return;
            }

            String Prefixes = String.Empty;
            String FormattingMessage = Message;
            String DisplayName = player.displayName;

            UInt64 UserID = player.userID;
            if (RenameInformation != null)
            {
                DisplayName = RenameInformation.RenameNick;
                UserID = RenameInformation.RenameID;
            }

            String ColorNickPlayer = String.IsNullOrWhiteSpace(Info.Info.ColorNick) ? player.IsAdmin ? "#a8fc55" : "#54aafe" : Info.Info.ColorNick;
            DisplayName = $"<color={ColorNickPlayer}>{DisplayName}</color>";

            //channel == Chat.ChatChannel.Team ? "<color=#a5e664>[Team]</color>" : 
            String ChannelMessage = channel == Chat.ChatChannel.Cards ? "<color=#AA8234>[Cards]</color>" :  channel == Chat.ChatChannel.Clan ? "<color=#a5e664>[Clan]</color>" : "";

            if (ControllerMessage.Formatting.UseBadWords)
            {
                Tuple<String, Boolean> GetTuple = BadWordsCleaner(Message, ControllerMessage.Formatting.ReplaceBadWord, ControllerMessage.Formatting.BadWords);
                FormattingMessage = GetTuple.Item1;

                if (GetTuple.Item2 && channel == Chat.ChatChannel.Global)
                {
                    if (permission.UserHasPermission(player.UserIDString, PermissionMute))
                        Interface.Oxide.CallHook("OnModeratorSendBadWords", player, GetTuple.Item1);
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                    Interface.Oxide.CallHook("OnPlayerSendBadWords", player, GetTuple.Item1);

                    if (ControllerMutes.AutoMuteSettings.UseAutoMute)
                        MutePlayer(player, MuteType.Chat, 0, null, ControllerMutes.AutoMuteSettings.AutoMuted.Reason, ControllerMutes.AutoMuteSettings.AutoMuted.SecondMute);
                }
            }

            if (ControllerMessage.Formatting.FormatMessage)
                FormattingMessage = $"{FormattingMessage.Substring(0, 1).ToUpper()}{FormattingMessage.Remove(0, 1).ToLower()}";

            if (ControllerParameter.Prefixes.TurnMultiPrefixes)
            {
                if (Info.Info.PrefixList != null)
                    Prefixes = String.Join("", Info.Info.PrefixList.Take(ControllerParameter.Prefixes.MaximumMultiPrefixCount));
            }
            else Prefixes = Info.Info.Prefix;
            
            String ResultMessage = String.IsNullOrWhiteSpace(Info.Info.ColorMessage) ? FormattingMessage : $"<color={Info.Info.ColorMessage}>{FormattingMessage}</color>";;

            String ResultReference = GetReferenceTags(player); 
            String SendFormat = $"{ChannelMessage} {ResultReference}<size={OtherController.SizePrefix}>{Prefixes}</size> <size={OtherController.SizeNick}>{DisplayName}</size>";
            
            if (config.RustPlusSettings.UseRustPlus)
                if (channel == Chat.ChatChannel.Team)
                {
                    RelationshipManager.PlayerTeam Team = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);
                    if (Team == null) return;
                    Util.BroadcastTeamChat(player.Team, player.userID, player.displayName, FormattingMessage, Info.Info.ColorMessage);
                }

            if (ControllerMutes.LoggedMute.UseHistoryMessage && config.OtherSetting.LogsMuted.UseLogged)
                AddHistoryMessage(player, FormattingMessage);

            ReplyChat(channel, player, ResultMessage, SendFormat);
            AnwserMessage(player, ResultMessage.ToLower());
            Puts($"{player.displayName}({player.UserIDString}): {FormattingMessage}");
            Log(LanguageEn ? $"CHAT MESSAGE : {player}: {ChannelMessage} {FormattingMessage}" : $"СООБЩЕНИЕ В ЧАТ : {player}: {ChannelMessage} {FormattingMessage}");
            DiscordLoggChat(player, channel, Message);

            RCon.Broadcast(RCon.LogType.Chat, new Chat.ChatEntry
            {
                Message = $"{player.displayName} : {FormattingMessage}",
                UserId = player.UserIDString,
                Username = player.displayName,
                Channel = channel,
                Time = (DateTime.UtcNow.Hour * 3600) + (DateTime.UtcNow.Minute * 60),
            });
        }
        String API_GET_NICK_COLOR(ulong ID)
        {
            if (!UserInformation.ContainsKey(ID)) return String.Empty;

            return UserInformation[ID].Info.ColorNick;
        }
        void Alert(BasePlayer Sender, string[] arg, Boolean IsAdmin)
        {
            String Message = GetMessageInArgs(Sender, arg);
            if (Message == null) return;
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            ReplyBroadcast(Message, AdminAlert: IsAdmin);

            if (config.RustPlusSettings.UseRustPlus)
                foreach (BasePlayer playerList in BasePlayer.activePlayerList)
                    NotificationList.SendNotificationTo(playerList.userID, NotificationChannel.SmartAlarm, config.RustPlusSettings.DisplayNameAlert, Message, Util.GetServerPairingData());
        }
        static Double CurrentTime => Facepunch.Math.Epoch.Current;
        String API_GET_PREFIX(UInt64 ID)
        {
            if (!UserInformation.ContainsKey(ID)) return String.Empty;
            Configuration.ControllerParameters ControllerParameter = config.ControllerParameter;

            User Info = UserInformation[ID];
            String Prefixes = String.Empty;

            if (ControllerParameter.Prefixes.TurnMultiPrefixes)
                Prefixes = String.Join("", Info.Info.PrefixList.Take(ControllerParameter.Prefixes.MaximumMultiPrefixCount));
            else Prefixes = Info.Info.Prefix;

            return Prefixes;
        }

        private void DiscordLoggMuted(BasePlayer Target, MuteType Type, String Reason = null, String TimeBlocked = null, BasePlayer Moderator = null)
        {
            Configuration.OtherSettings.General MuteChat = config.OtherSetting.LogsMuted;
            if (!MuteChat.UseLogged) return;

            Configuration.ControllerMute.LoggedFuncion ControllerMuted = config.ControllerMutes.LoggedMute;
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            String ActionReason = String.Empty;

            GeneralInformation.RenameInfo RenameSender = GeneralInfo.GetInfoRename(Target.userID);

            UInt64 UserIDModeration = 0;
            String NickModeration = GetLang("IQCHAT_FUNCED_ALERT_TITLE_SERVER", Target.UserIDString);
            if (Moderator != null)
            {
                GeneralInformation.RenameInfo RenameModerator = GeneralInfo.GetInfoRename(Moderator.userID);

                UserIDModeration = RenameModerator != null ? RenameModerator.RenameID == 0 ? Moderator.userID : RenameModerator.RenameID : Moderator.userID;
                NickModeration = RenameModerator != null ? $"{RenameModerator.RenameNick ?? Moderator.displayName}" : Moderator.displayName;
            }

            String NickTarget = RenameSender != null ? $"{RenameSender.RenameNick ?? Target.displayName}" : Target.displayName;
            UInt64 UserIDTarget = RenameSender != null ? RenameSender.RenameID == 0 ? Target.userID : RenameSender.RenameID : Target.userID;

            List<Fields> fields;

            switch (Type)
            {
                case MuteType.Chat:
                    {
                        if (Reason != null)
                            ActionReason = LanguageEn ? "Mute chat" : "Блокировка чата";
                        else ActionReason = LanguageEn ? "Unmute chat" : "Разблокировка чата";
                        break;
                    }
                case MuteType.Voice:
                    {
                        if (Reason != null)
                            ActionReason = LanguageEn ? "Mute voice" : "Блокировка голоса";
                        else ActionReason = LanguageEn ? "Unmute voice" : "Разблокировка голоса";
                        break;
                    }
                default:
                    break;
            }
            Int32 Color = 0;
            if (Reason != null)
            {
                fields = new List<Fields>
                        {
                            new Fields(LanguageEn ? "Nickname of the moderator" : "Ник модератора", NickModeration, true),
                            new Fields(LanguageEn ? "Steam64ID Moderator" : "Steam64ID модератора", $"{UserIDModeration}", true),
                            new Fields(LanguageEn ? "Action" : "Действие", ActionReason, false),
                            new Fields(LanguageEn ? "Reason" : "Причина", Reason, false),
                            new Fields(LanguageEn ? "Time" : "Время", TimeBlocked, false),
                            new Fields(LanguageEn ? "Nick blocked" : "Ник заблокированного", NickTarget, true),
                            new Fields(LanguageEn ? "Steam64ID blocked" : "Steam64ID заблокированного", $"{UserIDTarget}", true),
                        };



                if (ControllerMuted.UseHistoryMessage)
                {
                    String Messages = GetLastMessage(Target, ControllerMuted.CountHistoryMessage);
                    if (Messages != null && !String.IsNullOrWhiteSpace(Messages))
                        fields.Insert(fields.Count, new Fields(LanguageEn ? $"The latter {ControllerMuted.CountHistoryMessage} messages" : $"Последние {ControllerMuted.CountHistoryMessage} сообщений", Messages, false));
                }

                Color = 14357781;
            }
            else
            {
                fields = new List<Fields>
                        {
                            new Fields(LanguageEn ? "Nickname of the moderator" : "Ник модератора", NickModeration, true),
                            new Fields(LanguageEn ? "Steam64ID moderator" : "Steam64ID модератора", $"{UserIDModeration}", true),
                            new Fields(LanguageEn ? "Action" : "Действие", ActionReason, false),
                            new Fields(LanguageEn ? "Nick blocked" : "Ник заблокированного", NickTarget, true),
                            new Fields(LanguageEn ? "Steam64ID blocked" : "Steam64ID заблокированного", $"{UserIDTarget}", true),
                        };
                Color = 1432346;
            }


            FancyMessage newMessage = new FancyMessage(null, false, new FancyMessage.Embeds[1] { new FancyMessage.Embeds(null, Color, fields, new Authors("IQChat Mute-History", null, "https://i.imgur.com/xiwsg5m.png", null), null) });

            Request($"{MuteChat.Webhooks}", newMessage.toJSON());
        }
        void API_SEND_PLAYER_CONNECTED(BasePlayer player, String DisplayName, String country, String userID)
        {
            Configuration.ControllerAlert.PlayerSession AlertSessionPlayer = config.ControllerAlertSetting.PlayerSessionSetting;

            if (AlertSessionPlayer.ConnectedAlert)
            {
                String Avatar = AlertSessionPlayer.ConnectedAvatarUse ? userID : String.Empty;
                if (AlertSessionPlayer.ConnectedWorld)
                    ReplyBroadcast(null, Avatar, false, "WELCOME_PLAYER_WORLD", DisplayName, country);
                    //ReplyBroadcast(GetLang("WELCOME_PLAYER_WORLD", player.UserIDString, DisplayName, country), CustomAvatar: Avatar);
                else ReplyBroadcast(null, Avatar, false, "WELCOME_PLAYER", DisplayName);
                    //ReplyBroadcast(GetLang("WELCOME_PLAYER", player.UserIDString, DisplayName), CustomAvatar: Avatar);
            }
        }
        public Dictionary<BasePlayer, List<String>> LastMessagesChat = new Dictionary<BasePlayer, List<String>>();
        private void DrawUI_IQChat_Slider_Update_Argument(BasePlayer player, TakeElementUser ElementType)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Slider_Update_Argument");
            User Info = UserInformation[player.userID];
            if (Info == null || Interface == null) return;

            String Argument = String.Empty;
            String Name = String.Empty;
            String Parent = String.Empty;

            switch (ElementType)
            {
                case TakeElementUser.Prefix:
                    Argument = Info.Info.Prefix;
                    Parent = "SLIDER_PREFIX";
                    Name = "ARGUMENT_PREFIX";
                    break;
                case TakeElementUser.Nick:
                    Argument = $"<color={Info.Info.ColorNick}>{player.displayName}</color>";
                    Parent = "SLIDER_NICK_COLOR";
                    Name = "ARGUMENT_NICK_COLOR";
                    break;
                case TakeElementUser.Chat:
                    Argument = $"<color={Info.Info.ColorMessage}>{GetLang("IQCHAT_CONTEXT_NICK_DISPLAY_MESSAGE", player.UserIDString)}</color>";
                    Parent = "SLIDER_MESSAGE_COLOR";
                    Name = "ARGUMENT_MESSAGE_COLOR";
                    break;
                case TakeElementUser.Rank:
                    Argument = IQRankGetNameRankKey(Info.Info.Rank) ?? GetLang("IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE_NULLER", player.UserIDString);
                    Parent = "SLIDER_IQRANK";
                    Name = "ARGUMENT_RANK";
                    break;
                default:
                    break;
            }

            String Pattern = @"</?size.*?>";
            String ArgumentRegex = Regex.IsMatch(Argument, Pattern) ? Regex.Replace(Argument, Pattern, "") : Argument;
            Interface = Interface.Replace("%ARGUMENT%", ArgumentRegex);
            Interface = Interface.Replace("%PARENT%", Parent);
            Interface = Interface.Replace("%NAME%", Name);

            CuiHelper.DestroyUi(player, Name);
            CuiHelper.AddUi(player, Interface);

        }
        private class Configuration
        {
                        [JsonProperty(LanguageEn ? "Setting up player information" : "Настройка информации о игроке")]
            public ControllerConnection ControllerConnect = new ControllerConnection();
            internal class ControllerConnection
            {
                [JsonProperty(LanguageEn ? "Function switches" : "Перключатели функций")]
                public Turned Turneds = new Turned();
                [JsonProperty(LanguageEn ? "Setting Standard Values" : "Настройка стандартных значений")]
                public SetupDefault SetupDefaults = new SetupDefault();

                internal class SetupDefault
                {
                    [JsonProperty(LanguageEn ? "This prefix will be set if the player entered the server for the first time or in case of expiration of the rights to the prefix that he had earlier" : "Данный префикс установится если игрок впервые зашел на сервер или в случае окончания прав на префикс, который у него стоял ранее")]
                    public String PrefixDefault = "<color=#CC99FF>[ИГРОК]</color>";
                    [JsonProperty(LanguageEn ? "This nickname color will be set if the player entered the server for the first time or in case of expiration of the rights to the nickname color that he had earlier" : "Данный цвет ника установится если игрок впервые зашел на сервер или в случае окончания прав на цвет ника, который у него стоял ранее")]
                    public String NickDefault = "#33CCCC";
                    [JsonProperty(LanguageEn ? "This chat color will be set if the player entered the server for the first time or in case of expiration of the rights to the chat color that he had earlier" : "Данный цвет чата установится если игрок впервые зашел на сервер или в случае окончания прав на цвет чата, который у него стоял ранее")]
                    public String MessageDefault = "#0099FF";
                }
                internal class Turned
                {
                    [JsonProperty(LanguageEn ? "Set automatically a prefix to a player when he got the rights to it" : "Устанавливать автоматически префикс игроку, когда он получил права на него")]
                    public Boolean TurnAutoSetupPrefix;
                    [JsonProperty(LanguageEn ? "Set automatically the color of the nickname to the player when he got the rights to it" : "Устанавливать автоматически цвет ника игроку, когда он получил права на него")]
                    public Boolean TurnAutoSetupColorNick;
                    [JsonProperty(LanguageEn ? "Set the chat color automatically to the player when he got the rights to it" : "Устанавливать автоматически цвет чата игроку, когда он получил права на него")]
                    public Boolean TurnAutoSetupColorChat;
                    [JsonProperty(LanguageEn ? "Automatically reset the prefix when the player's rights to it expire" : "Сбрасывать автоматически префикс при окончании прав на него у игрока")]
                    public Boolean TurnAutoDropPrefix;
                    [JsonProperty(LanguageEn ? "Automatically reset the color of the nickname when the player's rights to it expire" : "Сбрасывать автоматически цвет ника при окончании прав на него у игрока")]
                    public Boolean TurnAutoDropColorNick;
                    [JsonProperty(LanguageEn ? "Automatically reset the color of the chat when the rights to it from the player expire" : "Сбрасывать автоматически цвет чата при окончании прав на него у игрока")]
                    public Boolean TurnAutoDropColorChat;
                }
            }
            
                        [JsonProperty(LanguageEn ? "Setting options for the player" : "Настройка параметров для игрока")]
            public ControllerParameters ControllerParameter = new ControllerParameters();
            internal class ControllerParameters
            {
                [JsonProperty(LanguageEn ? "Setting the display of options for player selection" : "Настройка отображения параметров для выбора игрока")]
                public VisualSettingParametres VisualParametres = new VisualSettingParametres();
                [JsonProperty(LanguageEn ? "List and customization of colors for a nickname" : "Список и настройка цветов для ника")]
                public List<AdvancedFuncion> NickColorList = new List<AdvancedFuncion>();
                [JsonProperty(LanguageEn ? "List and customize colors for chat messages" : "Список и настройка цветов для сообщений в чате")]
                public List<AdvancedFuncion> MessageColorList = new List<AdvancedFuncion>();
                [JsonProperty(LanguageEn ? "List and configuration of prefixes in chat" : "Список и настройка префиксов в чате")]
                public PrefixSetting Prefixes = new PrefixSetting();
                internal class PrefixSetting
                {
                    [JsonProperty(LanguageEn ? "Enable support for multiple prefixes at once (true - multiple prefixes can be set/false - only 1 can be set to choose from)" : "Включить поддержку нескольких префиксов сразу (true - можно установить несколько префиксов/false - установить можно только 1 на выбор)")]
                    public Boolean TurnMultiPrefixes;
                    [JsonProperty(LanguageEn ? "The maximum number of prefixes that can be set at a time (This option only works if setting multiple prefixes is enabled)" : "Максимальное количество префиксов, которое можно установить за раз(Данный параметр работает только если включена установка нескольких префиксов)")]
                    public Int32 MaximumMultiPrefixCount;
                    [JsonProperty(LanguageEn ? "List of prefixes and their settings" : "Список префиксов и их настройка")]
                    public List<AdvancedFuncion> Prefixes = new List<AdvancedFuncion>();
                }

                internal class AdvancedFuncion
                {
                    [JsonProperty(LanguageEn ? "Permission" : "Права")]
                    public String Permissions;
                    [JsonProperty(LanguageEn ? "Argument" : "Значение")]
                    public String Argument;
                    [JsonProperty(LanguageEn ? "Block the player's ability to select this parameter in the plugin menu (true - yes/false - no)" : "Заблокировать возможность выбрать данный параметр игроком в меню плагина (true - да/false - нет)")]
                    public Boolean IsBlockSelected;
                }

                internal class VisualSettingParametres
                {
                    [JsonProperty(LanguageEn ? "Player prefix selection display type - (0 - dropdown list, 1 - slider (Please note that if you have multi-prefix enabled, the dropdown list will be set))" : "Тип отображения выбора префикса для игрока - (0 - выпадающий список, 1 - слайдер (Учтите, что если у вас включен мульти-префикс, будет установлен выпадающий список))")]
                    public SelectedParametres PrefixType;
                    [JsonProperty(LanguageEn ? "Display type of player's nickname color selection - (0 - drop-down list, 1 - slider)" : "Тип отображения выбора цвета ника для игрока - (0 - выпадающий список, 1 - слайдер)")]
                    public SelectedParametres NickColorType;
                    [JsonProperty(LanguageEn ? "Display type of message color choice for the player - (0 - drop-down list, 1 - slider)" : "Тип отображения выбора цвета сообщения для игрока - (0 - выпадающий список, 1 - слайдер)")]
                    public SelectedParametres ChatColorType;
                    [JsonProperty(LanguageEn ? "IQRankSystem : Player rank selection display type - (0 - drop-down list, 1 - slider)" : "IQRankSystem : Тип отображения выбора ранга для игрока - (0 - выпадающий список, 1 - слайдер)")]
                    public SelectedParametres IQRankSystemType;
                }
            }
            
                        [JsonProperty(LanguageEn ? "Plugin mute settings" : "Настройка мута в плагине")]
            public ControllerMute ControllerMutes = new ControllerMute();
            internal class ControllerMute
            {
                [JsonProperty(LanguageEn ? "Setting up automatic muting" : "Настройка автоматического мута")]
                public AutoMute AutoMuteSettings = new AutoMute();
                internal class AutoMute
                {
                    [JsonProperty(LanguageEn ? "Enable automatic muting for forbidden words (true - yes/false - no)" : "Включить автоматический мут по запрещенным словам(true - да/false - нет)")]
                    public Boolean UseAutoMute;
                    [JsonProperty(LanguageEn ? "Reason for automatic muting" : "Причина автоматического мута")]
                    public Muted AutoMuted;
                }
                [JsonProperty(LanguageEn ? "Additional setting for logging about mutes in discord" : "Дополнительная настройка для логирования о мутах в дискорд")]
                public LoggedFuncion LoggedMute = new LoggedFuncion();
                internal class LoggedFuncion
                {
                    [JsonProperty(LanguageEn ? "Support for logging the last N messages (Discord logging about mutes must be enabled)" : "Поддержка логирования последних N сообщений (Должно быть включено логирование в дискорд о мутах)")]
                    public Boolean UseHistoryMessage;
                    [JsonProperty(LanguageEn ? "How many latest player messages to send in logging" : "Сколько последних сообщений игрока отправлять в логировании")]
                    public Int32 CountHistoryMessage;
                }

                [JsonProperty(LanguageEn ? "Reasons to block chat" : "Причины для блокировки чата")]
                public List<Muted> MuteChatReasons = new List<Muted>();
                [JsonProperty(LanguageEn ? "Reasons to block your voice" : "Причины для блокировки голоса")]
                public List<Muted> MuteVoiceReasons = new List<Muted>();
                internal class Muted
                {
                    [JsonProperty(LanguageEn ? "Reason for blocking" : "Причина для блокировки")]
                    public String Reason;
                    [JsonProperty(LanguageEn ? "Block time (in seconds)" : "Время блокировки(в секундах)")]
                    public Int32 SecondMute;
                }
            }
            
                        [JsonProperty(LanguageEn ? "Configuring Message Processing" : "Настройка обработки сообщений")]
            public ControllerMessage ControllerMessages = new ControllerMessage();
            internal class ControllerMessage
            {
                [JsonProperty(LanguageEn ? "Basic settings for chat messages from the plugin" : "Основная настройка сообщений в чат от плагина")]
                public GeneralSettings GeneralSetting = new GeneralSettings();
                [JsonProperty(LanguageEn ? "Configuring functionality switching in chat" : "Настройка переключения функционала в чате")]
                public TurnedFuncional TurnedFunc = new TurnedFuncional();
                [JsonProperty(LanguageEn ? "Player message formatting settings" : "Настройка форматирования сообщений игроков")]
                public FormattingMessage Formatting = new FormattingMessage();
  
                
                internal class GeneralSettings
                {
                    [JsonProperty(LanguageEn ? "Customizing the chat alert format" : "Настройка формата оповещения в чате")]
                    public BroadcastSettings BroadcastFormat = new BroadcastSettings();
                    [JsonProperty(LanguageEn ? "Setting the mention format in the chat, via @" : "Настройка формата упоминания в чате, через @")]
                    public AlertSettings AlertFormat = new AlertSettings();
                    [JsonProperty(LanguageEn ? "Additional setting" : "Дополнительная настройка")]
                    public OtherSettings OtherSetting = new OtherSettings();
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                    internal class BroadcastSettings
                    {
                        [JsonProperty(LanguageEn ? "The name of the notification in the chat" : "Наименование оповещения в чат")]
                        public String BroadcastTitle;
                        [JsonProperty(LanguageEn ? "Chat alert message color" : "Цвет сообщения оповещения в чат")]
                        public String BroadcastColor;
                        [JsonProperty(LanguageEn ? "Steam64ID for chat avatar" : "Steam64ID для аватарки в чате")]
                        public String Steam64IDAvatar;
                    }
                    internal class AlertSettings
                    {
                        [JsonProperty(LanguageEn ? "The color of the player mention message in the chat" : "Цвет сообщения упоминания игрока в чате")]
                        public String AlertPlayerColor;
                        [JsonProperty(LanguageEn ? "Sound when receiving and sending a mention via @" : "Звук при при получении и отправки упоминания через @")]
                        public String SoundAlertPlayer;
                    }
                    internal class OtherSettings
                    {
                        [JsonProperty(LanguageEn ? "Time after which the message will be deleted from the UI from the administrator" : "Время,через которое удалится сообщение с UI от администратора")]
                        public Int32 TimeDeleteAlertUI;

                        [JsonProperty(LanguageEn ? "The size of the message from the player in the chat" : "Размер сообщения от игрока в чате")]
                        public Int32 SizeMessage = 14;
                        [JsonProperty(LanguageEn ? "Player nickname size in chat" : "Размер ника игрока в чате")]
                        public Int32 SizeNick = 14;
                        [JsonProperty(LanguageEn ? "The size of the player's prefix in the chat (will be used if <size=N></size> is not set in the prefix itself)" : "Размер префикса игрока в чате (будет использовано, если в самом префиксе не установвлен <size=N></size>)")]
                        public Int32 SizePrefix = 14;
                    }
                }
                internal class TurnedFuncional
                {
                    [JsonProperty(LanguageEn ? "Configuring spam protection" : "Настройка защиты от спама")]
                    public AntiSpam AntiSpamSetting = new AntiSpam();
                    [JsonProperty(LanguageEn ? "Setting up a temporary chat block for newbies (who have just logged into the server)" : "Настройка временной блокировки чата новичкам (которые только зашли на сервер)")]
                    public AntiNoob AntiNoobSetting = new AntiNoob();
                    [JsonProperty(LanguageEn ? "Setting up private messages" : "Настройка личных сообщений")]
                    public PM PMSetting = new PM();

                    internal class AntiNoob
                    {
                        [JsonProperty(LanguageEn ? "Newbie protection in PM/R" : "Защита от новичка в PM/R")]
                        public Settings AntiNoobPM = new Settings();
                        [JsonProperty(LanguageEn ? "Newbie protection in global and team chat" : "Защита от новичка в глобальном и коммандном чате")]
                        public Settings AntiNoobChat = new Settings();
                        internal class Settings
                        {
                            [JsonProperty(LanguageEn ? "Enable protection?" : "Включить защиту?")]
                            public Boolean AntiNoobActivate = false;
                            [JsonProperty(LanguageEn ? "Newbie Chat Lock Time" : "Время блокировки чата для новичка")]
                            public Int32 TimeBlocked = 1200;
                        }
                    }
                    internal class AntiSpam
                    {
                        [JsonProperty(LanguageEn ? "Enable spam protection (Anti-spam)" : "Включить защиту от спама (Анти-спам)")]
                        public Boolean AntiSpamActivate;
                        [JsonProperty(LanguageEn ? "Time after which a player can send a message (AntiSpam)" : "Время через которое игрок может отправлять сообщение (АнтиСпам)")]
                        public Int32 FloodTime;
                        [JsonProperty(LanguageEn ? "Additional Anti-Spam settings" : "Дополнительная настройка Анти-Спама")]
                        public AntiSpamDuples AntiSpamDuplesSetting = new AntiSpamDuples();
                        internal class AntiSpamDuples
                        {
                            [JsonProperty(LanguageEn ? "Enable additional spam protection (Anti-duplicates, duplicate messages)" : "Включить дополнительную защиту от спама (Анти-дубликаты, повторяющие сообщения)")]
                            public Boolean AntiSpamDuplesActivate = true;
                            [JsonProperty(LanguageEn ? "How many duplicate messages does a player need to make to be confused by the system" : "Сколько дублирующих сообщений нужно сделать игроку чтобы его замутила система")]
                            public Int32 TryDuples = 3;
                            [JsonProperty(LanguageEn ? "Setting up automatic muting for duplicates" : "Настройка автоматического мута за дубликаты")]
                            public ControllerMute.Muted MuteSetting = new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Blocking for duplicate messages (SPAM)" : "Блокировка за дублирующие сообщения (СПАМ)",
                                SecondMute = 300,
                            };
                        }
                    }
                    internal class PM
                    {
                        [JsonProperty(LanguageEn ? "Enable Private Messages" : "Включить личные сообщения")]
                        public Boolean PMActivate;
                        [JsonProperty(LanguageEn ? "Sound when receiving a private message" : "Звук при при получении личного сообщения")]
                        public String SoundPM;
                    }
                    [JsonProperty(LanguageEn ? "Enable PM ignore for players (/ignore nick or via interface)" : "Включить игнор ЛС игрокам(/ignore nick или через интерфейс)")]
                    public Boolean IgnoreUsePM;
                    [JsonProperty(LanguageEn ? "Hide the issue of items to the Admin from the chat" : "Скрыть из чата выдачу предметов Админу")]
                    public Boolean HideAdminGave;
                    [JsonProperty(LanguageEn ? "Move mute to team chat (In case of a mute, the player will not be able to write even to the team chat)" : "Переносить мут в командный чат(В случае мута, игрок не сможет писать даже в командный чат)")]
                    public Boolean MuteTeamChat;
                }
                internal class FormattingMessage
                {
                    [JsonProperty(LanguageEn ? "Enable message formatting [Will control caps, message format] (true - yes/false - no)" : "Включить форматирование сообщений [Будет контроллировать капс, формат сообщения] (true - да/false - нет)")]
                    public Boolean FormatMessage;
                    [JsonProperty(LanguageEn ? "Use a list of banned words (true - yes/false - no)" : "Использовать список запрещенных слов (true - да/false - нет)")]
                    public Boolean UseBadWords;
                    [JsonProperty(LanguageEn ? "The word that will replace the forbidden word" : "Слово которое будет заменять запрещенное слово")]
                    public String ReplaceBadWord;
                    [JsonProperty(LanguageEn ? "List of banned words" : "Список запрещенных слов")]
                    public List<String> BadWords = new List<String>();

                    [JsonProperty(LanguageEn ? "Nickname controller setup" : "Настройка контроллера ников")]
                    public NickController ControllerNickname = new NickController();
                    internal class NickController
                    {
                        [JsonProperty(LanguageEn ? "Enable player nickname formatting (message formatting must be enabled)" : "Включить форматирование ников игроков (должно быть включено форматирование сообщений)")]
                        public Boolean UseNickController = true;
                        [JsonProperty(LanguageEn ? "The word that will replace the forbidden word (You can leave it blank and it will just delete)" : "Слово которое будет заменять запрещенное слово (Вы можете оставить пустым и будет просто удалять)")]
                        public String ReplaceBadNick = "****";
                        [JsonProperty(LanguageEn ? "List of banned nicknames" : "Список запрещенных ников")]
                        public List<String> BadNicks = new List<String>();
                        [JsonProperty(LanguageEn ? "List of allowed links in nicknames" : "Список разрешенных ссылок в никах")]
                        public List<String> AllowedLinkNick = new List<String>();
                    }
                }
            }

            
            
            [JsonProperty(LanguageEn ? "Setting up chat alerts" : "Настройка оповещений в чате")]
            public ControllerAlert ControllerAlertSetting;

            internal class ControllerAlert
            {
                [JsonProperty(LanguageEn ? "Setting up chat alerts" : "Настройка оповещений в чате")]
                public Alert AlertSetting;
                [JsonProperty(LanguageEn ? "Setting notifications about the status of the player's session" : "Настройка оповещений о статусе сессии игрока")]
                public PlayerSession PlayerSessionSetting;
                [JsonProperty(LanguageEn ? "Configuring administrator session status alerts" : "Настройка оповещений о статусе сессии администратора")]
                public AdminSession AdminSessionSetting;
                [JsonProperty(LanguageEn ? "Setting up personal notifications to the player when connecting" : "Настройка персональных оповоещений игроку при коннекте")]
                public PersonalAlert PersonalAlertSetting;
                internal class Alert
                {
                    [JsonProperty(LanguageEn ? "Enable automatic messages in chat (true - yes/false - no)" : "Включить автоматические сообщения в чат (true - да/false - нет)")]
                    public Boolean AlertMessage;
                    [JsonProperty(LanguageEn ? "Type of automatic messages : true - sequential / false - random" : "Тип автоматических сообщений : true - поочередные/false - случайные")]
                    public Boolean AlertMessageType;

                    [JsonProperty(LanguageEn ? "List of automatic messages in chat" : "Список автоматических сообщений в чат")]
                    public LanguageController MessageList = new LanguageController();
                    [JsonProperty(LanguageEn ? "Interval for sending messages to chat (Broadcaster) (in seconds)" : "Интервал отправки сообщений в чат (Броадкастер) (в секундах)")]
                    public Int32 MessageListTimer;
                }
                internal class PlayerSession
                {
                    [JsonProperty(LanguageEn ? "When a player is notified about the entry / exit of the player, display his avatar opposite the nickname (true - yes / false - no)" : "При уведомлении о входе/выходе игрока отображать его аватар напротив ника (true - да/false - нет)")]
                    public Boolean ConnectedAvatarUse;

                    [JsonProperty(LanguageEn ? "Notify in chat when a player enters (true - yes/false - no)" : "Уведомлять в чате о входе игрока (true - да/false - нет)")]
                    public Boolean ConnectedAlert;
                    [JsonProperty(LanguageEn ? "Enable random notifications when a player from the list enters (true - yes / false - no)" : "Включить случайные уведомления о входе игрока из списка (true - да/false - нет)")]
                    public Boolean ConnectionAlertRandom;
                    [JsonProperty(LanguageEn ? "Show the country of the entered player (true - yes/false - no)" : "Отображать страну зашедшего игрока (true - да/false - нет")]
                    public Boolean ConnectedWorld;

                    [JsonProperty(LanguageEn ? "Notify when a player enters the chat (selected from the list) (true - yes/false - no)" : "Уведомлять о выходе игрока в чат(выбираются из списка) (true - да/false - нет)")]
                    public Boolean DisconnectedAlert;
                    [JsonProperty(LanguageEn ? "Enable random player exit notifications (true - yes/false - no)" : "Включить случайные уведомления о выходе игрока (true - да/false - нет)")]
                    public Boolean DisconnectedAlertRandom;
                    [JsonProperty(LanguageEn ? "Display reason for player exit (true - yes/false - no)" : "Отображать причину выхода игрока (true - да/false - нет)")]
                    public Boolean DisconnectedReason;

                    [JsonProperty(LanguageEn ? "Random player entry notifications({0} - player's nickname, {1} - country (if country display is enabled)" : "Случайные уведомления о входе игрока({0} - ник игрока, {1} - страна(если включено отображение страны)")]
                    public LanguageController RandomConnectionAlert = new LanguageController();
                    [JsonProperty(LanguageEn ? "Random notifications about the exit of the player ({0} - player's nickname, {1} - the reason for the exit (if the reason is enabled)" : "Случайные уведомления о выходе игрока({0} - ник игрока, {1} - причина выхода(если включена причина)")]
                    public LanguageController RandomDisconnectedAlert = new LanguageController();
                }
                internal class AdminSession
                {
                    [JsonProperty(LanguageEn ? "Notify admin on the server in the chat (true - yes/false - no)" : "Уведомлять о входе админа на сервер в чат (true - да/false - нет)")]
                    public Boolean ConnectedAlertAdmin;
                    [JsonProperty(LanguageEn ? "Notify about admin leaving the server in chat (true - yes/false - no)" : "Уведомлять о выходе админа на сервер в чат (true - да/false - нет)")]
                    public Boolean DisconnectedAlertAdmin;
                }
                internal class PersonalAlert
                {
                    [JsonProperty(LanguageEn ? "Enable random message to the player who has logged in (true - yes/false - no)" : "Включить случайное сообщение зашедшему игроку (true - да/false - нет)")]
                    public Boolean UseWelcomeMessage;
                    [JsonProperty(LanguageEn ? "List of messages to the player when entering" : "Список сообщений игроку при входе")]
                    public LanguageController WelcomeMessage = new LanguageController();
                }
            }

            public class LanguageController
            {
                [JsonProperty(LanguageEn ? "Setting up Multilingual Messages [Language Code] = Translation Variations" : "Настройка мультиязычных сообщений [КодЯзыка] = ВариацииПеревода")]
                public Dictionary<String, List<String>> LanguageMessages = new Dictionary<String, List<String>>();
            }

            
                        [JsonProperty(LanguageEn ? "Settings Rust+" : "Настройка Rust+")]
            public RustPlus RustPlusSettings;
            internal class RustPlus
            {
                [JsonProperty(LanguageEn ? "Use Rust+" : "Использовать Rust+")]
                public Boolean UseRustPlus;
                [JsonProperty(LanguageEn ? "Title for notification Rust+" : "Название для уведомления Rust+")]
                public String DisplayNameAlert;
            }
            
                        [JsonProperty(LanguageEn ? "Configuring support plugins" : "Настройка плагинов поддержки")]
            public ReferenceSettings ReferenceSetting = new ReferenceSettings();
            internal class ReferenceSettings
            {
                [JsonProperty(LanguageEn ? "Settings XLevels" : "Настройка XLevels")]
                public XLevels XLevelsSettings = new XLevels();
                [JsonProperty(LanguageEn ? "Settings IQFakeActive" : "Настройка IQFakeActive")]
                public IQFakeActive IQFakeActiveSettings = new IQFakeActive();
                [JsonProperty(LanguageEn ? "Settings IQRankSystem" : "Настройка IQRankSystem")]
                public IQRankSystem IQRankSystems = new IQRankSystem();
                [JsonProperty(LanguageEn ? "Settings Clans" : "Настройка Clans")]
                public Clans ClansSettings = new Clans();

                internal class Clans
                {
                    [JsonProperty(LanguageEn ? "Display a clan tag in the chat (if Clans are installed)" : "Отображать в чате клановый тэг (если установлены Clans)")]
                    public Boolean UseClanTag;
                }
                internal class IQRankSystem
                {
                    [JsonProperty(LanguageEn ? "Rank display format in chat ( {0} is the user's rank, do not delete this value)" : "Формат отображения ранга в чате ( {0} - это ранг юзера, не удаляйте это значение)")]
                    public String FormatRank = "[{0}]";
                    [JsonProperty(LanguageEn ? "Time display format with IQRank System in chat ( {0} is the user's time, do not delete this value)" : "Формат отображения времени с IQRankSystem в чате ( {0} - это время юзера, не удаляйте это значение)")]
                    public String FormatRankTime = "[{0}]";
                    [JsonProperty(LanguageEn ? "Use support IQRankSystem" : "Использовать поддержку рангов")]
                    public Boolean UseRankSystem;
                    [JsonProperty(LanguageEn ? "Show players their played time next to their rank" : "Отображать игрокам их отыгранное время рядом с рангом")]
                    public Boolean UseTimeStandart;
                }
                internal class IQFakeActive
                {
                    [JsonProperty(LanguageEn ? "Use support IQFakeActive" : "Использовать поддержку IQFakeActive")]
                    public Boolean UseIQFakeActive;
                }
                internal class XLevels
                {
                    [JsonProperty(LanguageEn ? "Use support XLevels" : "Использовать поддержку XLevels")]
                    public Boolean UseXLevels;
                    [JsonProperty(LanguageEn ? "Use full prefix with level from XLevel (true) otherwise only level (false)" : "Использовать полный префикс с уровнем из XLevel (true) иначе только уровень (false)")]
                    public Boolean UseFullXLevels;
                }
            }
            
            
            [JsonProperty(LanguageEn ? "Setting up an answering machine" : "Настройка автоответчика")]
            public AnswerMessage AnswerMessages = new AnswerMessage();

            internal class AnswerMessage
            {
                [JsonProperty(LanguageEn ? "Enable auto-reply? (true - yes/false - no)" : "Включить автоответчик?(true - да/false - нет)")]
                public bool UseAnswer;
                [JsonProperty(LanguageEn ? "Customize Messages [Keyword] = Reply" : "Настройка сообщений [Ключевое слово] = Ответ")]
                public Dictionary<String, LanguageController> AnswerMessageList = new Dictionary<String, LanguageController>();
            }

            
                        [JsonProperty(LanguageEn ? "Additional setting" : "Дополнительная настройка")]
            public OtherSettings OtherSetting;

            internal class OtherSettings
            {
                [JsonProperty(LanguageEn ? "Enable the /online command (true - yes / false - no)" : "Включить команду /online (true - да/ false - нет)")]
                public Boolean UseCommandOnline;
                [JsonProperty(LanguageEn ? "Setting up message logging" : "Настройка логирования сообщений")]
                public LoggedChat LogsChat = new LoggedChat();
                [JsonProperty(LanguageEn ? "Setting up logging of personal messages of players" : "Настройка логирования личных сообщений игроков")]
                public General LogsPMChat = new General();
                [JsonProperty(LanguageEn ? "Setting up chat/voice lock/unlock logging" : "Настройка логирования блокировок/разблокировок чата/голоса")]
                public General LogsMuted = new General();
                [JsonProperty(LanguageEn ? "Setting up logging of chat commands from players" : "Настройка логирования чат-команд от игроков")]
                public General LogsChatCommands = new General();
                internal class LoggedChat
                {
                    [JsonProperty(LanguageEn ? "Setting up general chat logging" : "Настройка логирования общего чата")]
                    public General GlobalChatSettings = new General();
                    [JsonProperty(LanguageEn ? "Setting up team chat logging" : "Настройка логирования тим чата")]
                    public General TeamChatSettings = new General();
                }
                internal class General
                {
                    [JsonProperty(LanguageEn ? "Enable logging (true - yes/false - no)" : "Включить логирование (true - да/false - нет)")]
                    public Boolean UseLogged = false;
                    [JsonProperty(LanguageEn ? "Webhooks channel for logging" : "Webhooks канала для логирования")]
                    public String Webhooks = "";
                }
            }
            
            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                                        ControllerParameter = new ControllerParameters
                    {
                        VisualParametres = new ControllerParameters.VisualSettingParametres
                        {
                            PrefixType = SelectedParametres.DropList,
                            ChatColorType = SelectedParametres.DropList,
                            NickColorType = SelectedParametres.Slider,
                            IQRankSystemType = SelectedParametres.Slider,
                        },
                        Prefixes = new ControllerParameters.PrefixSetting
                        {
                            TurnMultiPrefixes = false,
                            MaximumMultiPrefixCount = 5,
                            Prefixes = new List<ControllerParameters.AdvancedFuncion>
                              {
                                  new ControllerParameters.AdvancedFuncion
                                  {
                                      Argument = LanguageEn ? "<color=#CC99FF>[PLAYER]</color>" : "<color=#CC99FF>[ИГРОК]</color>",
                                      Permissions = "iqchat.default",
                                      IsBlockSelected = false,
                                  },
                                  new ControllerParameters.AdvancedFuncion
                                  {
                                      Argument = "<color=#ffff99>[VIP]</color>",
                                      Permissions = "iqchat.admin",
                                      IsBlockSelected = false,
                                  },
                                  new ControllerParameters.AdvancedFuncion
                                  {
                                      Argument = LanguageEn ? "<color=#ff9999>[ADMIN]</color>" : "<color=#ff9999>[АДМИН]</color>",
                                      Permissions = "iqchat.admin",
                                      IsBlockSelected = false,
                                  },
                            },
                        },
                        MessageColorList = new List<ControllerParameters.AdvancedFuncion>
                        {
                               new ControllerParameters.AdvancedFuncion
                               {
                                    Argument = "#CC99FF",
                                    Permissions = "iqchat.default",
                                    IsBlockSelected = false,
                               },
                               new ControllerParameters.AdvancedFuncion
                               {
                                    Argument = "#ffff99",
                                    Permissions = "iqchat.admin",
                                    IsBlockSelected = false,
                               },
                               new ControllerParameters.AdvancedFuncion
                               {
                                    Argument = "#ff9999",
                                    Permissions = "iqchat.admin",
                                    IsBlockSelected = false,
                               },
                        },
                        NickColorList = new List<ControllerParameters.AdvancedFuncion>
                        {
                               new ControllerParameters.AdvancedFuncion
                               {
                                    Argument = "#CC99FF",
                                    Permissions = "iqchat.default",
                                    IsBlockSelected = false,
                               },
                               new ControllerParameters.AdvancedFuncion
                               {
                                    Argument = "#ffff99",
                                    Permissions = "iqchat.admin",
                                    IsBlockSelected = false,
                               },
                               new ControllerParameters.AdvancedFuncion
                               {
                                    Argument = "#ff9999",
                                    Permissions = "iqchat.admin",
                                    IsBlockSelected = false,
                               },
                        },
                    },
                    
                    
                    ControllerConnect = new ControllerConnection
                    {
                        SetupDefaults = new ControllerConnection.SetupDefault
                        {
                            PrefixDefault = LanguageEn ? "<color=#CC99FF>[PLAYER]</color>" : "<color=#CC99FF>[ИГРОК]</color>",
                            MessageDefault = "#33CCCC",
                            NickDefault = "#0099FF",
                        },
                        Turneds = new ControllerConnection.Turned
                        {
                            TurnAutoDropColorChat = true,
                            TurnAutoDropColorNick = true,
                            TurnAutoDropPrefix = true,
                            TurnAutoSetupColorChat = true,
                            TurnAutoSetupColorNick = true,
                            TurnAutoSetupPrefix = true,
                        }
                    },

                    
                    
                    ControllerMutes = new ControllerMute
                    {
                        LoggedMute = new ControllerMute.LoggedFuncion
                        {
                            UseHistoryMessage = false,
                            CountHistoryMessage = 10,
                        },
                        AutoMuteSettings = new ControllerMute.AutoMute
                        {
                            UseAutoMute = true,
                            AutoMuted = new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Automatic chat blocking" : "Автоматическая блокировка чата",
                                SecondMute = 300,
                            }
                        },
                        MuteChatReasons = new List<ControllerMute.Muted>
                        {
                            new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Aggressive behavior" : "Агрессивное поведение",
                                SecondMute = 100,
                            },
                            new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Insults" : "Оскорбления",
                                SecondMute = 300,
                            },
                            new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Insult (repeated violation)" : "Оскорбление (повторное нарушение)",
                                SecondMute = 1000,
                            },
                            new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Advertising" : "Реклама",
                                SecondMute = 5000,
                            },
                            new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Humiliation" : "Унижение",
                                SecondMute = 300,
                            },
                            new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Spam" : "Спам",
                                SecondMute = 60,
                            },
                        },
                        MuteVoiceReasons = new List<ControllerMute.Muted>
                        {
                            new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Aggressive behavior" : "Агрессивное поведение",
                                SecondMute = 100,
                            },
                            new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Insults" : "Оскорбления",
                                SecondMute = 300,
                            },
                            new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Disruption of the event by shouting" : "Срыв мероприятия криками",
                                SecondMute = 300,
                            },
                        }
                    },

                    
                    
                    ControllerMessages = new ControllerMessage
                    {
                        Formatting = new ControllerMessage.FormattingMessage
                        {
                            UseBadWords = true,
                            BadWords = LanguageEn ? new List<String> { "fuckyou", "sucking", "fucking", "fuck" } : new List<String> { "бля", "сука", "говно", "тварь" },
                            FormatMessage = true,
                            ReplaceBadWord = "***",
                            ControllerNickname = new ControllerMessage.FormattingMessage.NickController
                            {
                                BadNicks = LanguageEn ? new List<String> { "Admin", "Moderator", "Administrator", "Moder", "Owner", "Mercury Loh", "IQchat" } : new List<String> { "Администратор", "Модератор", "Админ", "Модер", "Овнер", "Mercury Loh", "IQchat" },
                                AllowedLinkNick = new List<String> { "mysite.com" },
                                ReplaceBadNick = "",
                                UseNickController = true,
                            },
                        },
                        TurnedFunc = new ControllerMessage.TurnedFuncional
                        {
                            HideAdminGave = true,
                            IgnoreUsePM = true,
                            MuteTeamChat = true,
                            AntiNoobSetting = new ControllerMessage.TurnedFuncional.AntiNoob
                            {
                                AntiNoobChat = new ControllerMessage.TurnedFuncional.AntiNoob.Settings
                                {
                                    AntiNoobActivate = false,
                                    TimeBlocked = 1200,
                                },
                                AntiNoobPM = new ControllerMessage.TurnedFuncional.AntiNoob.Settings
                                {
                                    AntiNoobActivate = false,
                                    TimeBlocked = 1200,
                                },
                            },
                            AntiSpamSetting = new ControllerMessage.TurnedFuncional.AntiSpam
                            {
                                AntiSpamActivate = true,
                                FloodTime = 10,
                                AntiSpamDuplesSetting = new ControllerMessage.TurnedFuncional.AntiSpam.AntiSpamDuples
                                {
                                    AntiSpamDuplesActivate = true,
                                    MuteSetting = new ControllerMute.Muted
                                    {
                                        Reason = LanguageEn ? "Duplicate messages (SPAM)" : "Повторяющиеся сообщения (СПАМ)",
                                        SecondMute = 300,
                                    },
                                    TryDuples = 3,
                                }
                            },
                            PMSetting = new ControllerMessage.TurnedFuncional.PM
                            {
                                PMActivate = true,
                                SoundPM = "assets/bundled/prefabs/fx/notice/stack.world.fx.prefab",
                            },
                        },
                        GeneralSetting = new ControllerMessage.GeneralSettings
                        {
                            BroadcastFormat = new ControllerMessage.GeneralSettings.BroadcastSettings
                            {
                                BroadcastColor = "#efedee",
                                BroadcastTitle = LanguageEn ? "<color=#68cacd><b>[Alert]</b></color>" : "<color=#68cacd><b>[ОПОВЕЩЕНИЕ]</b></color>",
                                Steam64IDAvatar = "0",
                            },
                            AlertFormat = new ControllerMessage.GeneralSettings.AlertSettings
                            {
                                AlertPlayerColor = "#efedee",
                                SoundAlertPlayer = "assets/bundled/prefabs/fx/notice/item.select.fx.prefab",
                            },
                            OtherSetting = new ControllerMessage.GeneralSettings.OtherSettings
                            {
                                TimeDeleteAlertUI = 5,
                                SizePrefix = 14,
                                SizeMessage = 14,
                                SizeNick = 14,
                            }
                        },
                    },

                    
                    
                    ControllerAlertSetting = new ControllerAlert
                    {
                        AlertSetting = new ControllerAlert.Alert
                        {
                            AlertMessage = true,
                            AlertMessageType = false,
                            MessageList = new LanguageController()
                            {
                                LanguageMessages = new Dictionary<String, List<String>>()
                                {
                                    ["en"] = new List<String>()
                                    {
                                        "Automatic message #1 (Edit in configuration)",
                                        "Automatic message #2 (Edit in configuration)",
                                        "Automatic message #3 (Edit in configuration)",
                                        "Automatic message #4 (Edit in configuration)",
                                        "Automatic message #5 (Edit in configuration)",
                                        "Automatic message #6 (Edit in configuration)",
                                    },
                                    ["ru"] = new List<String>()
                                    {
                                        "Автоматическое сообщение #1 (Редактировать в конфигурации)",
                                        "Автоматическое сообщение #2 (Редактировать в конфигурации)",
                                        "Автоматическое сообщение #3 (Редактировать в конфигурации)",
                                        "Автоматическое сообщение #4 (Редактировать в конфигурации)",
                                        "Автоматическое сообщение #5 (Редактировать в конфигурации)",
                                        "Автоматическое сообщение #6 (Редактировать в конфигурации)",
                                    }
                                },
                            },
                            MessageListTimer = 60,
                        },
                        AdminSessionSetting = new ControllerAlert.AdminSession
                        {
                            ConnectedAlertAdmin = false,
                            DisconnectedAlertAdmin = false,
                        },
                        PlayerSessionSetting = new ControllerAlert.PlayerSession
                        {
                            ConnectedAlert = true,
                            ConnectedAvatarUse = true,
                            ConnectedWorld = true,
                            ConnectionAlertRandom = false,

                            DisconnectedAlert = true,
                            DisconnectedAlertRandom = false,
                            DisconnectedReason = true,

                            RandomConnectionAlert = new LanguageController
                            {
                                LanguageMessages = new Dictionary<String, List<String>>()
                                {
                                    ["en"] = new List<String>()
                                    {
                                        "{0} flew in from {1}",
                                        "{0} flew into the server from{1}",
                                        "{0} jumped on a server"
                                    },
                                    ["ru"] = new List<String>()
                                    {
                                        "{0} влетел как дурачок из {1}",
                                        "{0} залетел на сервер из {1}, соболезнуем",
                                        "{0} прыгнул на сервачок"
                                    }
                                }
                            },
                            RandomDisconnectedAlert = new LanguageController()
                            {
                                LanguageMessages = new Dictionary<String, List<String>>()
                                {
                                    ["en"] = new List<String>()
                                    {
                                        "{0} gone to another world",
                                        "{0} left the server with a reason {1}",
                                        "{0} went to another server"
                                    },
                                    ["ru"] = new List<String>()
                                    {
                                        "{0} ушел в мир иной",
                                        "{0} вылетел с сервера с причиной {1}",
                                        "{0} пошел на другой сервачок"
                                    }
                                }
                            },
                        },
                        PersonalAlertSetting = new ControllerAlert.PersonalAlert
                        {
                            UseWelcomeMessage = true,
                            WelcomeMessage = new LanguageController
                            {
                                LanguageMessages = new Dictionary<String, List<String>>()
                                {
                                    ["en"] = new List<String>()
                                    {
                                        "Welcome to the server SUPERSERVER\nWe are glad that you chose us!",
                                        "Welcome back to the server!\nWe wish you good luck",
                                        "Welcome to the server\nWe have the best plugins",
                                    },
                                    ["ru"] = new List<String>()
                                    {
                                        "Добро пожаловать на сервер SUPERSERVER\nРады,что выбрал именно нас!",
                                        "С возвращением на сервер!\nЖелаем тебе удачи",
                                        "Добро пожаловать на сервер\nУ нас самые лучшие плагины",
                                    }
                                }
                            },
                        }
                    },

                    
                    
                    ReferenceSetting = new ReferenceSettings
                    {
                        IQFakeActiveSettings = new ReferenceSettings.IQFakeActive
                        {
                            UseIQFakeActive = true,
                        },
                        IQRankSystems = new ReferenceSettings.IQRankSystem
                        {
                            FormatRank = "[{0}]",
                            FormatRankTime = "[{0}]",
                            UseRankSystem = false,
                            UseTimeStandart = true
                        },
                        XLevelsSettings = new ReferenceSettings.XLevels()
                        {
                            UseXLevels = false,
                            UseFullXLevels = false,
                        },
                        ClansSettings = new ReferenceSettings.Clans()
                        {
                            UseClanTag = false,
                        }
                    },

                    
                    
                    RustPlusSettings = new RustPlus
                    {
                        UseRustPlus = true,
                        DisplayNameAlert = LanguageEn ? "SUPER SERVER" : "СУПЕР СЕРВЕР",
                    },

                    
                    
                    AnswerMessages = new AnswerMessage
                    {
                        UseAnswer = true,
                        AnswerMessageList = new Dictionary<String, LanguageController>()
                        {
                            ["wipe"] = new LanguageController()
                            {
                                LanguageMessages = new Dictionary<String, List<String>>()
                                {
                                    ["en"] = new List<String>()
                                    {
                                        "Wipe will be 27.06"
                                    },
                                    ["ru"] = new List<String>()
                                    {
                                        "Вайп будет 27.06"
                                    }
                                }
                            },
                            ["читер"] = new LanguageController()
                            {
                                LanguageMessages = new Dictionary<String, List<String>>()
                                {
                                    ["en"] = new List<String>()
                                    {
                                        "Found a cheater? Write /report and send a complaint"
                                    },
                                    ["ru"] = new List<String>()
                                    {
                                        "Нашли читера?Напиши /report и отправь жалобу"
                                    }
                                }
                            }
                        },
                    },

                    
                    
                    OtherSetting = new OtherSettings
                    {
                        UseCommandOnline = false,
                        LogsChat = new OtherSettings.LoggedChat
                        {
                            GlobalChatSettings = new OtherSettings.General
                            {
                                UseLogged = false,
                                Webhooks = "",
                            },
                            TeamChatSettings = new OtherSettings.General
                            {
                                UseLogged = false,
                                Webhooks = "",
                            }
                        },
                        LogsChatCommands = new OtherSettings.General
                        {
                            UseLogged = false,
                            Webhooks = "",
                        },
                        LogsPMChat = new OtherSettings.General
                        {
                            UseLogged = false,
                            Webhooks = "",
                        },
                        LogsMuted = new OtherSettings.General
                        {
                            UseLogged = false,
                            Webhooks = "",
                        },
                    },

                                    };
            }
        }
        private const String PermissionAntiSpam = "iqchat.antispamabuse";
        public List<FakePlayer> PlayerBases = new List<FakePlayer>();

        private void AlertDisconnected(BasePlayer player, String reason)
        {
            Configuration.ControllerAlert.AdminSession AlertSessionAdmin = config.ControllerAlertSetting.AdminSessionSetting;
            Configuration.ControllerAlert.PlayerSession AlertSessionPlayer = config.ControllerAlertSetting.PlayerSessionSetting;
            GeneralInformation.RenameInfo RenameInformation = GeneralInfo.GetInfoRename(player.userID);

            if (AlertSessionPlayer.DisconnectedAlert)
            {
                if (!AlertSessionAdmin.DisconnectedAlertAdmin)
                    if (player.IsAdmin) return;

                String DisplayName = player.displayName;

                // Configuration.ControllerMessage ControllerMessage = config.ControllerMessages;

                // if (ControllerMessage.Formatting.ControllerNickname.UseNickController)
                //     foreach (String DetectedBadNick in DisplayName.Split(' '))
                //     {
                //         if (ControllerMessage.Formatting.ControllerNickname.BadNicks.Count(x => x.ToLower() == DetectedBadNick.ToLower()) > 0 && DetectedBadNick.Leght != 44423251)
                //             DisplayName = DisplayName.Replace(DetectedBadNick, ControllerMessage.Formatting.ControllerNickname.ReplaceBadNick);
                //     }

                UInt64 UserID = player.userID;
                if (RenameInformation != null)
                {
                    DisplayName = RenameInformation.RenameNick;
                    UserID = RenameInformation.RenameID;
                }

                String Avatar = AlertSessionPlayer.ConnectedAvatarUse ? UserID.ToString() : String.Empty;

                if (!permission.UserHasPermission(player.UserIDString, PermissionHideDisconnection))
                {
                    if (AlertSessionPlayer.DisconnectedAlertRandom)
                        ReplyBroadcast(null, Avatar, false, AlertSessionPlayer.RandomDisconnectedAlert.LanguageMessages,DisplayName, reason);
                    else
                    {
                        System.Object[] args = AlertSessionPlayer.DisconnectedReason ? new System.Object[] { DisplayName, reason } : new System.Object[] { DisplayName };
                        String Lang = AlertSessionPlayer.DisconnectedReason ? "LEAVE_PLAYER_REASON" : "LEAVE_PLAYER";
                        ReplyBroadcast(null, Avatar, false, Lang, args);
                    }
                }

                Log($"[{player.userID}] {(AlertSessionPlayer.DisconnectedReason ? GetLang("LEAVE_PLAYER_REASON", player.UserIDString, DisplayName, reason) : GetLang("LEAVE_PLAYER", player.UserIDString, DisplayName))}");
            }
        }
        
                private void DrawUI_IQChat_Mute_Alert(BasePlayer player, BasePlayer Target, UInt64 IDFake = 0)
        {
            String InterfacePanel = InterfaceBuilder.GetInterface("UI_Chat_Mute_And_Ignore_Alert_Panel");
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Mute_Alert");
            if (Interface == null || InterfacePanel == null) return;

            User InfoTarget = (IQFakeActive && Target == null && IDFake != 0) ? null : UserInformation[Target.userID];

            Interface = Interface.Replace("%TITLE%", GetLang("IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT", player.UserIDString));
            Interface = Interface.Replace("%BUTTON_TAKE_CHAT_ACTION%", InfoTarget == null ? GetLang("IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_CHAT", player.UserIDString) : InfoTarget.MuteInfo.IsMute(MuteType.Chat) ? GetLang("IQCHAT_BUTTON_MODERATION_UNMUTE_MENU_TITLE_ALERT_CHAT", player.UserIDString) : GetLang("IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_CHAT", player.UserIDString));
            Interface = Interface.Replace("%BUTTON_TAKE_VOICE_ACTION%", InfoTarget == null ? GetLang("IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_VOICE", player.UserIDString) : InfoTarget.MuteInfo.IsMute(MuteType.Voice) ? GetLang("IQCHAT_BUTTON_MODERATION_UNMUTE_MENU_TITLE_ALERT_VOICE", player.UserIDString) : GetLang("IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_VOICE", player.UserIDString));
            Interface = Interface.Replace("%COMMAND_TAKE_ACTION_MUTE_CHAT%", InfoTarget == null ? $"newui.cmd action.mute.ignore ignore.and.mute.controller {SelectedAction.Mute} open.reason.mute {IDFake} {MuteType.Chat}" : InfoTarget.MuteInfo.IsMute(MuteType.Chat) ? $"newui.cmd action.mute.ignore ignore.and.mute.controller {SelectedAction.Mute} unmute.yes {Target.UserIDString} {MuteType.Chat}" : $"newui.cmd action.mute.ignore ignore.and.mute.controller {SelectedAction.Mute} open.reason.mute {Target.UserIDString} {MuteType.Chat}");
            Interface = Interface.Replace("%COMMAND_TAKE_ACTION_MUTE_VOICE%", InfoTarget == null ? $"newui.cmd action.mute.ignore ignore.and.mute.controller {SelectedAction.Mute} open.reason.mute {IDFake} {MuteType.Voice}" : InfoTarget.MuteInfo.IsMute(MuteType.Voice) ? $"newui.cmd action.mute.ignore ignore.and.mute.controller {SelectedAction.Mute} unmute.yes {Target.UserIDString} {MuteType.Voice}" : $"newui.cmd action.mute.ignore ignore.and.mute.controller {SelectedAction.Mute} open.reason.mute {Target.UserIDString} {MuteType.Voice}");

            CuiHelper.DestroyUi(player, "MUTE_AND_IGNORE_PANEL_ALERT");
            CuiHelper.AddUi(player, InterfacePanel);
            CuiHelper.AddUi(player, Interface);
        }
        void SyncReservedFinish(string JSON)
        {
            if (!config.ReferenceSetting.IQFakeActiveSettings.UseIQFakeActive) return;
            List<FakePlayer> ContentDeserialize = JsonConvert.DeserializeObject<List<FakePlayer>>(JSON);
            PlayerBases = ContentDeserialize;

            PrintWarning(LanguageEn ? "IQChat - successfully synced with IQFakeActive" : "IQChat - успешно синхронизирована с IQFakeActive");
            PrintWarning("=============SYNC==================");
        }
        
                private void MutePlayer(BasePlayer Target, MuteType Type, Int32 ReasonIndex, BasePlayer Moderator = null, String ReasonCustom = null, Int32 TimeCustom = 0, Boolean HideMute = false, Boolean Command = false, UInt64 IDFake = 0)
        {
            Configuration.ControllerMute ControllerMutes = config.ControllerMutes;

            if (IQFakeActive && Target == null && (IQFakeActive && Target == null && IDFake != 0))
            {
                ReplySystem(Moderator, GetLang(Type == MuteType.Chat ? "FUNC_MESSAGE_MUTE_CHAT" : "FUNC_MESSAGE_MUTE_VOICE", Moderator != null ? Moderator.displayName : Moderator.UserIDString, GetLang("IQCHAT_FUNCED_ALERT_TITLE_SERVER"), FindFakeName(IDFake), FormatTime(TimeCustom == 0 ? config.ControllerMutes.MuteChatReasons[ReasonIndex].SecondMute : TimeCustom), ReasonCustom ?? config.ControllerMutes.MuteChatReasons[ReasonIndex].Reason));
                RemoveReserved(IDFake);
                FakePlayer FakeP = PlayerBases.FirstOrDefault(x => x.UserID == IDFake);
                if (FakeP != null)
                    PlayerBases.Remove(FakeP);
                return;
            }

            if (!UserInformation.ContainsKey(Target.userID)) return;
            User Info = UserInformation[Target.userID];

            String LangMessage = String.Empty;
            String Reason = String.Empty;
            Int32 MuteTime = 0;

            String NameModerator = GetLang("IQCHAT_FUNCED_ALERT_TITLE_SERVER", Target.UserIDString);

            if (Moderator != null)
            {
                GeneralInformation.RenameInfo ModeratorRename = GeneralInfo.GetInfoRename(Moderator.userID);
                NameModerator = ModeratorRename != null ? $"{ModeratorRename.RenameNick ?? Moderator.displayName}" : Moderator.displayName;
            }

            GeneralInformation.RenameInfo TagetRename = GeneralInfo.GetInfoRename(Target.userID);
            String TargetName = TagetRename != null ? $"{TagetRename.RenameNick ?? Target.displayName}" : Target.displayName;

            if (Target == null || !Target.IsConnected)
            {
                if (Moderator != null && !Command)
                    ReplySystem(Moderator, GetLang("UI_CHAT_PANEL_MODERATOR_MUTE_PANEL_TAKE_TYPE_CHAT_ACTION_NOT_CONNNECTED", Moderator.UserIDString));
                return;
            }
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            if (Moderator != null && !Command)
                if (Info.MuteInfo.IsMute(Type))
                {
                    ReplySystem(Moderator, GetLang("IQCHAT_FUNCED_ALERT_TITLE_ISMUTED", Moderator.UserIDString));
                    return;
                }

            switch (Type)
            {
                case MuteType.Chat:
                    {
                        Reason = ReasonCustom ?? ControllerMutes.MuteChatReasons[ReasonIndex].Reason;
                        MuteTime = TimeCustom == 0 ? ControllerMutes.MuteChatReasons[ReasonIndex].SecondMute : TimeCustom;
                        LangMessage = "FUNC_MESSAGE_MUTE_CHAT";
                        break;
                    }
                case MuteType.Voice:
                    {
                        Reason = ReasonCustom ?? ControllerMutes.MuteVoiceReasons[ReasonIndex].Reason;
                        MuteTime = TimeCustom == 0 ? ControllerMutes.MuteVoiceReasons[ReasonIndex].SecondMute : TimeCustom;
                        LangMessage = "FUNC_MESSAGE_MUTE_VOICE";
                        break;
                    }
            }

            Info.MuteInfo.SetMute(Type, MuteTime);

            if (Moderator != null && Moderator != Target)
                Interface.Oxide.CallHook("OnPlayerMuted", Target, Moderator, MuteTime, Reason);

            if (!HideMute)
                ReplyBroadcast(null, null, false, LangMessage, NameModerator, TargetName, FormatTime(MuteTime, Target.UserIDString), Reason);
               // ReplyBroadcast(GetLang(LangMessage, Target.UserIDString, NameModerator, TargetName, FormatTime(MuteTime, Target.UserIDString), Reason));
            else
            {
                if (Target != null)
                    ReplySystem(Target, GetLang(LangMessage, Target.UserIDString, NameModerator, TargetName, FormatTime(MuteTime, Target.UserIDString), Reason));

                if (Moderator != null)
                    ReplySystem(Moderator, GetLang(LangMessage, Target.UserIDString, NameModerator, TargetName, FormatTime(MuteTime, Target.UserIDString), Reason));
            }

            DiscordLoggMuted(Target, Type, Reason, FormatTime(MuteTime, Target.UserIDString), Moderator);
        }
        private Dictionary<BasePlayer, InformationOpenedUI> LocalBase = new Dictionary<BasePlayer, InformationOpenedUI>();
        public Dictionary<UInt64, AntiNoob> UserInformationConnection = new Dictionary<UInt64, AntiNoob>();
        /// <summary>
        /// Обновление 2.///
        /// Исправления :
        /// - Убран дубликат префикса командного чата
        /// - Исправлена ошибка FormatException после последнего обновления (по моей вине - допустил опечатку в аргументах логирования)
        /// </summary>
        
                [PluginReference] Plugin ImageLibrary, IQFakeActive, IQRankSystem, XLevels, Clans;
        
        
        void API_SEND_PLAYER(BasePlayer player, String PlayerFormat, String Message, String Avatar, Chat.ChatChannel channel = Chat.ChatChannel.Global)
        {
            Configuration.ControllerMessage ControllerMessages = config.ControllerMessages;

            String OutMessage = String.Empty; ;

            if (ControllerMessages.Formatting.FormatMessage)
                OutMessage = $"{Message.ToLower().Substring(0, 1).ToUpper()}{Message.Remove(0, 1).ToLower()}";
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            if (ControllerMessages.Formatting.UseBadWords)
                foreach (String DetectedMessage in OutMessage.Split(' '))
                    if (ControllerMessages.Formatting.BadWords.Contains(DetectedMessage.ToLower()))
                        OutMessage = OutMessage.Replace(DetectedMessage, ControllerMessages.Formatting.ReplaceBadWord);

            player.SendConsoleCommand("chat.add", channel, ulong.Parse(Avatar), $"{PlayerFormat}: {OutMessage}");
            player.ConsoleMessage($"{PlayerFormat}: {OutMessage}");
        }

        
        
        private String XLevel_GetLevel(BasePlayer player)
        {
            if (!XLevels || !config.ReferenceSetting.XLevelsSettings.UseXLevels) return String.Empty;
            return GetLang("XLEVELS_SYNTAX_PREFIX", player.UserIDString,
                (Int32)XLevels?.CallHook("API_GetLevel", player));
        }

        
                private String GetImage(String fileName, UInt64 skin = 0)
        {
            var imageId = (String)plugins.Find("ImageLibrary").CallHook("ImageUi.GetImage", fileName, skin);
            if (!string.IsNullOrEmpty(imageId))
                return imageId;
            return String.Empty;
        }
        
                private void DrawUI_IQChat_Context(BasePlayer player)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Context");
            User Info = UserInformation[player.userID];
            Configuration.ControllerParameters ControllerParameter = config.ControllerParameter;
            if (Info == null || ControllerParameter == null || Interface == null) return;

            String BackgroundStatic = IQRankSystem && config.ReferenceSetting.IQRankSystems.UseRankSystem ? "UI_IQCHAT_CONTEXT_RANK" : "UI_IQCHAT_CONTEXT_NO_RANK";
            
            Interface = Interface.Replace("%IMG_BACKGROUND%", ImageUi.GetImage(BackgroundStatic));
            Interface = Interface.Replace("%TITLE%", GetLang("IQCHAT_CONTEXT_TITLE", player.UserIDString));
            Interface = Interface.Replace("%SETTING_ELEMENT%", GetLang("IQCHAT_CONTEXT_SETTING_ELEMENT_TITLE", player.UserIDString));
            Interface = Interface.Replace("%INFORMATION%", GetLang("IQCHAT_CONTEXT_INFORMATION_TITLE", player.UserIDString));
            Interface = Interface.Replace("%SETTINGS%", GetLang("IQCHAT_CONTEXT_SETTINGS_TITLE", player.UserIDString));
            Interface = Interface.Replace("%SETTINGS_PM%", GetLang("IQCHAT_CONTEXT_SETTINGS_PM_TITLE", player.UserIDString));
            Interface = Interface.Replace("%SETTINGS_ALERT%", GetLang("IQCHAT_CONTEXT_SETTINGS_ALERT_TITLE", player.UserIDString));
            Interface = Interface.Replace("%SETTINGS_ALERT_PM%", GetLang("IQCHAT_CONTEXT_SETTINGS_ALERT_PM_TITLE", player.UserIDString));
            Interface = Interface.Replace("%SETTINGS_SOUNDS%", GetLang("IQCHAT_CONTEXT_SETTINGS_SOUNDS_TITLE", player.UserIDString));
            Interface = Interface.Replace("%MUTE_STATUS_TITLE%", GetLang("IQCHAT_CONTEXT_MUTE_STATUS_TITLE", player.UserIDString));
            Interface = Interface.Replace("%IGNORED_STATUS_COUNT%", GetLang("IQCHAT_CONTEXT_IGNORED_STATUS_COUNT", player.UserIDString, Info.Settings.IgnoreUsers.Count));
            Interface = Interface.Replace("%IGNORED_STATUS_TITLE%", GetLang("IQCHAT_CONTEXT_IGNORED_STATUS_TITLE", player.UserIDString));
            Interface = Interface.Replace("%NICK_DISPLAY_TITLE%", GetLang("IQCHAT_CONTEXT_NICK_DISPLAY_TITLE", player.UserIDString));
            Interface = Interface.Replace("%MUTE_STATUS_PLAYER%", Info.MuteInfo.IsMute(MuteType.Chat) ? FormatTime(Info.MuteInfo.GetTime(MuteType.Chat), player.UserIDString) : GetLang("IQCHAT_CONTEXT_MUTE_STATUS_NOT", player.UserIDString));
            Interface = Interface.Replace("%SLIDER_PREFIX_TITLE%", GetLang("IQCHAT_CONTEXT_SLIDER_PREFIX_TITLE", player.UserIDString));
            Interface = Interface.Replace("%SLIDER_NICK_COLOR_TITLE%", GetLang("IQCHAT_CONTEXT_SLIDER_NICK_COLOR_TITLE", player.UserIDString));

            Interface = Interface.Replace("%SLIDER_MESSAGE_COLOR_TITLE%",GetLang("IQCHAT_CONTEXT_SLIDER_MESSAGE_COLOR_TITLE", player.UserIDString));
            
            Interface = Interface.Replace("%SLIDER_IQRANK_TITLE%", IQRankSystem && config.ReferenceSetting.IQRankSystems.UseRankSystem ? GetLang("IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE", player.UserIDString) : String.Empty);

            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_Chat_Context);
            CuiHelper.AddUi(player, Interface);

            DrawUI_IQChat_Update_DisplayName(player);

            if (ControllerParameter.VisualParametres.PrefixType == SelectedParametres.DropList || ControllerParameter.Prefixes.TurnMultiPrefixes)
                DrawUI_IQChat_DropList(player, "-46.788 67.4", "-14.788 91.4", GetLang("IQCHAT_CONTEXT_SLIDER_PREFIX_TITLE_DESCRIPTION", player.UserIDString), ControllerParameter.Prefixes.TurnMultiPrefixes ? TakeElementUser.MultiPrefix : TakeElementUser.Prefix);
            else DrawUI_IQChat_Sliders(player, "SLIDER_PREFIX", "-140 54", "-16 78", TakeElementUser.Prefix);

            if (ControllerParameter.VisualParametres.NickColorType == SelectedParametres.DropList)
                DrawUI_IQChat_DropList(player, "112.34 67.4", "144.34 91.4", GetLang("IQCHAT_CONTEXT_SLIDER_CHAT_NICK_TITLE_DESCRIPTION", player.UserIDString), TakeElementUser.Nick);
            else DrawUI_IQChat_Sliders(player, "SLIDER_NICK_COLOR", "20 54", "144 78", TakeElementUser.Nick);
            
            if (ControllerParameter.VisualParametres.ChatColorType == SelectedParametres.DropList)
                DrawUI_IQChat_DropList(player, "-46.787 -0.591", "-14.787 23.409",GetLang("IQCHAT_CONTEXT_SLIDER_CHAT_MESSAGE_TITLE_DESCRIPTION", player.UserIDString),TakeElementUser.Chat);
            else DrawUI_IQChat_Sliders(player, "SLIDER_MESSAGE_COLOR", "-140 -12", "-16 12", TakeElementUser.Chat);
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            if (IQRankSystem && config.ReferenceSetting.IQRankSystems.UseRankSystem)
            {
                if (ControllerParameter.VisualParametres.IQRankSystemType == SelectedParametres.DropList)
                    DrawUI_IQChat_DropList(player, "112.34 -0.591", "144.34 23.409", GetLang("IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE_DESCRIPTION", player.UserIDString), TakeElementUser.Rank);
                else DrawUI_IQChat_Sliders(player, "SLIDER_IQRANK", "20 -12", "144 12", TakeElementUser.Rank);
            }

            DrawUI_IQChat_Update_Check_Box(player, ElementsSettingsType.PM, "143.38 -67.9", "151.38 -59.9", Info.Settings.TurnPM);
            DrawUI_IQChat_Update_Check_Box(player, ElementsSettingsType.Broadcast, "143.38 -79.6", "151.38 -71.6", Info.Settings.TurnBroadcast);
            DrawUI_IQChat_Update_Check_Box(player, ElementsSettingsType.Alert, "143.38 -91.6", "151.38 -83.6", Info.Settings.TurnAlert);
            DrawUI_IQChat_Update_Check_Box(player, ElementsSettingsType.Sound, "143.38 -103.6", "151.38 -95.6", Info.Settings.TurnSound);
            DrawUI_IQChat_Context_AdminAndModeration(player);
        }
		   		 		  						  	   		  	  			  	  			  	 				  	  	
        
                void OnUserPermissionGranted(string id, string permName) => SetupParametres(id, permName);

        
        
        private List<String> GetPlayersOnline()
        {
            List<String> PlayerNames = new List<String>();
            Int32 Count = 1;

            foreach (BasePlayer playerInList in BasePlayer.activePlayerList.Where(p => !permission.UserHasPermission(p.UserIDString, PermissionHideOnline)))
            {
                String ResultName = $"{Count} - {GetPlayerFormat(playerInList)}";
                PlayerNames.Add(ResultName);

                Count++;
            }

            if (IQFakeActive)
            {
                foreach (FakePlayer fakePlayer in PlayerBases.Where(x => IsFake(x.UserID)))
                {
                    String ResultName = $"{Count} - {API_GET_DEFAULT_PREFIX()}<color={API_GET_DEFAULT_NICK_COLOR()}>{fakePlayer.DisplayName}</color>";
                    PlayerNames.Add(ResultName);

                    Count++;
                }
            }

            return PlayerNames;
        }

        [ConsoleCommand("alertui")]
        private void AlertUIConsoleCommand(ConsoleSystem.Arg args)
        {
            BasePlayer Sender = args.Player();
            if (Sender != null)
                if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;
            AlertUI(Sender, args.Args);
        }
        void API_SEND_PLAYER_DISCONNECTED(BasePlayer player, String DisplayName, String reason, String userID)
        {
            Configuration.ControllerAlert.PlayerSession AlertSessionPlayer = config.ControllerAlertSetting.PlayerSessionSetting;

            if (AlertSessionPlayer.DisconnectedAlert)
            {
                String Avatar = AlertSessionPlayer.ConnectedAvatarUse ? userID : String.Empty;

                System.Object[] args = AlertSessionPlayer.DisconnectedReason ? new System.Object[] { DisplayName, reason } : new System.Object[] { DisplayName };
                String Lang = AlertSessionPlayer.DisconnectedReason ? "LEAVE_PLAYER_REASON" : "LEAVE_PLAYER";
                ReplyBroadcast(null, Avatar, false, Lang, args);
            }
        }

        public class Authors
        {
            public string name { get; set; }
            public string url { get; set; }
            public string icon_url { get; set; }
            public string proxy_icon_url { get; set; }
            public Authors(string name, string url, string icon_url, string proxy_icon_url)
            {
                this.name = name;
                this.url = url;
                this.icon_url = icon_url;
                this.proxy_icon_url = proxy_icon_url;
            }
        }
        private void OnServerInitialized()
        {
            _ = this;
            ImageUi.DownloadImages();

            MigrateDataToNoob();

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                UserConnecteionData(player);

            RegisteredPermissions();
            BroadcastAuto();

            CheckValidateUsers();

            if (!config.ControllerMessages.Formatting.ControllerNickname.UseNickController)
                Unsubscribe("OnUserConnected");

        }
        
        void ReplyBroadcast(String CustomPrefix = null, String CustomAvatar = null, Boolean AdminAlert = false, Dictionary<String, List<String>> Messages = null, params object[] args)
        {
            foreach (BasePlayer p in !AdminAlert ? BasePlayer.activePlayerList.Where(p => UserInformation[p.userID].Settings.TurnBroadcast) : BasePlayer.activePlayerList)
            {
                sb.Clear();
                ReplySystem(p, sb.AppendFormat(GetMessages(p, Messages), args).ToString(), CustomPrefix, CustomAvatar);
            }
        }

        
        [ConsoleCommand("set")]
        private void CommandSet(ConsoleSystem.Arg args)
        {
            BasePlayer Sender = args.Player();

            if (Sender != null)
                if (!Sender.IsAdmin)
                    return;
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            if (args == null || args.Args == null || args.Args.Length != 3)
            {
                if (Sender != null)
                    ReplySystem(Sender, LanguageEn ? "Use syntax correctly : set [Steam64ID] [prefix/chat/nick/custom] [Argument]" : "Используйте правильно ситаксис : set [Steam64ID] [prefix/chat/nick/custom] [Argument]");
                else PrintWarning(LanguageEn ? "Use syntax correctly : set [Steam64ID] [prefix/chat/nick/custom] [Argument]" : "Используйте правильно ситаксис : set [Steam64ID] [prefix/chat/nick/custom] [Argument]");
                return;
            }

            UInt64 Steam64ID = 0;
            BasePlayer player = null;

            if (UInt64.TryParse(args.Args[0], out Steam64ID))
                player = BasePlayer.FindByID(Steam64ID);

            if (player == null)
            {
                if (Sender != null)
                    ReplySystem(Sender, LanguageEn ? "Incorrect player Steam ID or syntax error\nUse syntax correctly : set [Steam64ID] [prefix/chat/nick/custom] [Argument]" : "Неверно указан SteamID игрока или ошибка в синтаксисе\nИспользуйте правильно ситаксис : set [Steam64ID] [prefix/chat/nick/custom] [Argument]");
                else PrintWarning(LanguageEn ? "Incorrect player Steam ID or syntax error\nUse syntax correctly : set [Steam64ID] [prefix/chat/nick/custom] [Argument]" : "Неверно указан SteamID игрока или ошибка в синтаксисе\nИспользуйте правильно ситаксис : set [Steam64ID] [prefix/chat/nick/custom] [Argument]");
                return;
            }
            if (!UserInformation.ContainsKey(player.userID))
            {
                if (Sender != null)
                    ReplySystem(Sender, LanguageEn ? $"Player not found!" : $"Игрок не найден!");
                else PrintWarning(LanguageEn ? $"Player not found!" : $"Игрок не найден!");
                return;
            }
            User Info = UserInformation[player.userID];
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            Configuration.ControllerParameters ControllerParameter = config.ControllerParameter;

            switch (args.Args[1])
            {
                case "prefix":
                    {
                        String KeyPrefix = args.Args[2];
                        if (ControllerParameter.Prefixes.Prefixes.Count(prefix => prefix.Argument.Contains(KeyPrefix)) == 0)
                        {
                            if (Sender != null)
                                ReplySystem(Sender, LanguageEn ? "Argument not found in your configuration" : $"Аргумент не найден в вашей конфигурации!");
                            else PrintWarning(LanguageEn ? $"Argument not found in your configuration" : $"Аргумент не найден в вашей конфигурации");
                            return;
                        }

                        foreach (Configuration.ControllerParameters.AdvancedFuncion Prefix in ControllerParameter.Prefixes.Prefixes.Where(prefix => prefix.Argument.Contains(KeyPrefix)).Take(1))
                        {
                            if (ControllerParameter.Prefixes.TurnMultiPrefixes)
                                Info.Info.PrefixList.Add(Prefix.Argument);
                            else Info.Info.Prefix = Prefix.Argument;

                            if (Sender != null)
                                ReplySystem(Sender, LanguageEn ? $"Prefix successfully set to - {Prefix.Argument}" : $"Префикс успешно установлен на - {Prefix.Argument}");
                            else Puts(LanguageEn ? $"Prefix successfully set to - {Prefix.Argument}" : $"Префикс успешно установлен на - {Prefix.Argument}");
                        }
                        break;
                    }
                case "chat":
                    {
                        String KeyChatColor = args.Args[2];
                        if (ControllerParameter.MessageColorList.Count(color => color.Argument.Contains(KeyChatColor)) == 0)
                        {
                            if (Sender != null)
                                ReplySystem(Sender, LanguageEn ? $"Argument not found in your configuration!" : $"Аргумент не найден в вашей конфигурации!");
                            else PrintWarning(LanguageEn ? $"Argument not found in your configuration" : $"Аргумент не найден в вашей конфигурации");
                            return;
                        }

                        foreach (Configuration.ControllerParameters.AdvancedFuncion ChatColor in ControllerParameter.MessageColorList.Where(color => color.Argument.Contains(KeyChatColor)).Take(1))
                        {
                            Info.Info.ColorMessage = ChatColor.Argument;
                            if (Sender != null)
                                ReplySystem(Sender, LanguageEn ? $"Message color successfully set to - {ChatColor.Argument}" : $"Цвет сообщения успешно установлен на - {ChatColor.Argument}");
                            else Puts(LanguageEn ? $"Message color successfully set to - {ChatColor.Argument}" : $"Цвет сообщения успешно установлен на - {ChatColor.Argument}");
                        }
                        break;
                    }
                case "nick":
                    {
                        String KeyNickColor = args.Args[2];
                        if (ControllerParameter.NickColorList.Count(color => color.Argument.Contains(KeyNickColor)) == 0)
                        {
                            if (Sender != null)
                                ReplySystem(Sender, LanguageEn ? $"Argument not found in your configuration!" : $"Аргумент не найден в вашей конфигурации!");
                            else PrintWarning(LanguageEn ? "Argument not found in your configuration" : $"Аргумент не найден в вашей конфигурации");
                            return;
                        }

                        foreach (Configuration.ControllerParameters.AdvancedFuncion NickColor in ControllerParameter.NickColorList.Where(color => color.Argument.Contains(KeyNickColor)).Take(1))
                        {
                            Info.Info.ColorNick = NickColor.Argument;
                            if (Sender != null)
                                ReplySystem(Sender, LanguageEn ? $"Message color successfully set to - {NickColor.Argument}" : $"Цвет сообщения успешно установлен на - {NickColor.Argument}");
                            else Puts(LanguageEn ? $"Message color successfully set to - {NickColor.Argument}" : $"Цвет сообщения успешно установлен на - {NickColor.Argument}");
                        }
                        break;
                    }
                case "custom":
                    {
                        String CustomPrefix = args.Args[2];
                        if (ControllerParameter.Prefixes.TurnMultiPrefixes)
                            Info.Info.PrefixList.Add(CustomPrefix);
                        else Info.Info.Prefix = CustomPrefix;
                        if (Sender != null)
                            ReplySystem(Sender, LanguageEn ? $"Custom prefix successfully set to - {CustomPrefix}" : $"Кастомный префикс успешно установлен на - {CustomPrefix}");
                        else Puts(LanguageEn ? $"Custom prefix successfully set to - {CustomPrefix}" : $"Кастомный префикс успешно установлен на - {CustomPrefix}");

                        break;
                    }
                default:
                    {
                        if (Sender != null)
                            ReplySystem(Sender, LanguageEn ? "Use syntax correctly : set [Steam64ID] [prefix/chat/nick/custom] [Argument]" : "Используйте правильно ситаксис : set [Steam64ID] [prefix/chat/nick/custom] [Argument]");
                        break;
                    }
            }

        }
        public string GetLang(string LangKey, string userID = null, params object[] args)
        {
            sb.Clear();
            if (args != null)
            {
                sb.AppendFormat(lang.GetMessage(LangKey, this, userID), args);
                return sb.ToString();
            }
            return lang.GetMessage(LangKey, this, userID);
        }

        private object OnServerMessage(String message, String name)
        {
            if (config.ControllerMessages.TurnedFunc.HideAdminGave)
                if (message.Contains("gave") && name == "SERVER")
                    return true;
            return null;
        }
        void IQRankSetRank(ulong userID, string RankKey) => IQRankSystem?.Call("API_SET_ACTIVE_RANK", userID, RankKey);

        public class GeneralInformation
        {
            public Boolean TurnMuteAllChat;
            public Boolean TurnMuteAllVoice;

            public Dictionary<UInt64, RenameInfo> RenameList = new Dictionary<UInt64, RenameInfo>();
            internal class RenameInfo
            {
                public String RenameNick;
                public UInt64 RenameID;
            }

            public RenameInfo GetInfoRename(UInt64 UserID)
            {
                if (!RenameList.ContainsKey(UserID)) return null;
                return RenameList[UserID];
            }
        }


        private Tuple<String, Boolean> BadWordsCleaner(String FormattingMessage, String ReplaceBadWord, List<String> BadWords)
        {
            String ResultMessage = FormattingMessage;
            Boolean IsBadWords = false;

            foreach (String word in BadWords.Where(x => !x.Contains("*")))
            {
                MatchCollection matches = new Regex(@"\b(" + Regex.Escape(word) + @")\b").Matches(ResultMessage);
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                foreach (Match match in matches)
                {
                    if (match.Success)
                    {
                        String found = match.Groups[1].ToString();
                        String replaced = "";

                        for (int i = 0; i < found.Length; i++) replaced = replaced + ReplaceBadWord;

                        ResultMessage = ResultMessage.Replace(found, replaced);
                        IsBadWords = true;
                    }
                    else break;
                }
            }

            return Tuple.Create(ResultMessage, IsBadWords);
        }

        private void DrawUI_IQChat_Mute_Alert_Reasons(BasePlayer player, BasePlayer Target, String Reason, Int32 Y, MuteType Type, UInt64 IDFake = 0)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Mute_Alert_DropList_Reason");
            if (Interface == null) return;

            Interface = Interface.Replace("%OFFSET_MIN%", $"-147.5 {85.42 - (Y * 40)}");
            Interface = Interface.Replace("%OFFSET_MAX%", $"147.5 {120.42 - (Y * 40)}");
            Interface = Interface.Replace("%REASON%", Reason);
            Interface = Interface.Replace("%COMMAND_REASON%", $"newui.cmd action.mute.ignore ignore.and.mute.controller {SelectedAction.Mute} confirm.yes {((IQFakeActive && Target == null && IDFake != 0) ? IDFake : Target.userID)} {Type} {Y}");
            CuiHelper.AddUi(player, Interface);
        }

        void ReadData()
        {
            if (!Oxide.Core.Interface.Oxide.DataFileSystem.ExistsDatafile("IQSystem/IQChat/Users") && Oxide.Core.Interface.Oxide.DataFileSystem.ExistsDatafile("IQChat/Users"))
            {
                GeneralInfo = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<GeneralInformation>("IQChat/Information");
                UserInformation = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<UInt64, User>>("IQChat/Users");

                Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQSystem/IQChat/Information", GeneralInfo);
                Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQSystem/IQChat/Users", UserInformation);

                PrintWarning(LanguageEn ? "Your player data has been moved to a new directory - IQSystem/IQChat , you can delete old data files!" : "Ваши данные игроков были перенесены в новую директорию - IQSystem/IQChat , вы можете удалить старые дата-файлы!");
            }

            GeneralInfo = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<GeneralInformation>("IQSystem/IQChat/Information");
            UserInformation = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<UInt64, User>>("IQSystem/IQChat/Users");
            UserInformationConnection = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<UInt64, AntiNoob>>("IQSystem/IQChat/AntiNoob");
        }
        void API_SEND_PLAYER_PM(BasePlayer player, string DisplayName, string Message)
        {
            ReplySystem(player, GetLang("COMMAND_PM_SEND_MSG", player.UserIDString, DisplayName, Message));
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            if (UserInformation.ContainsKey(player.userID))
                if (UserInformation[player.userID].Settings.TurnSound)
                    Effect.server.Run(config.ControllerMessages.TurnedFunc.PMSetting.SoundPM, player.GetNetworkPosition());
        }

        public class Footer
        {
            public string text { get; set; }
            public string icon_url { get; set; }
            public string proxy_icon_url { get; set; }
            public Footer(string text, string icon_url, string proxy_icon_url)
            {
                this.text = text;
                this.icon_url = icon_url;
                this.proxy_icon_url = proxy_icon_url;
            }
        }

        private static IQChat _;
        void Alert(BasePlayer Sender, BasePlayer Recipient, string[] arg)
        {
            String Message = GetMessageInArgs(Sender, arg);
            if (Message == null) return;

            ReplySystem(Recipient, Message);
        }
        public bool IsFake(UInt64 userID)
        {
            if (!IQFakeActive) return false;
            return (bool)IQFakeActive?.Call("IsFake", userID);
        }
        private String GetMessageInArgs(BasePlayer Sender, String[] arg)
        {
            if (arg == null || arg.Length == 0)
            {
                if (Sender != null)
                    ReplySystem(Sender, GetLang("FUNC_MESSAGE_NO_ARG_BROADCAST", Sender.UserIDString));
                else PrintWarning(GetLang("FUNC_MESSAGE_NO_ARG_BROADCAST"));
                return null;
            }
            String Message = String.Empty;
            foreach (String msg in arg)
                Message += " " + msg;

            return Message;
        }

        private void RemoveParametres(String ID, String Permissions)
        {
            UInt64 UserID = UInt64.Parse(ID);
            BasePlayer player = BasePlayer.FindByID(UserID);
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            Configuration.ControllerConnection Controller = config.ControllerConnect;
            Configuration.ControllerParameters Parameters = config.ControllerParameter;

            if (!UserInformation.ContainsKey(UserID)) return;
            User Info = UserInformation[UserID];

            if (Controller.Turneds.TurnAutoDropPrefix)
            {
                if (Parameters.Prefixes.TurnMultiPrefixes)
                {
                    foreach (Configuration.ControllerParameters.AdvancedFuncion Prefixes in
                             Parameters.Prefixes.Prefixes.Where(prefix =>
                                 Info.Info.PrefixList.Contains(prefix.Argument) && prefix.Permissions == Permissions))
                    {
                        Info.Info.PrefixList.Remove(Prefixes.Argument);

                        if (player != null)
                            ReplySystem(player, GetLang("PREFIX_RETURNRED", player.UserIDString, Prefixes.Argument));

                        Log(LanguageEn
                            ? $"Player ({UserID}) expired prefix {Prefixes.Argument}"
                            : $"У игрока ({UserID}) истек префикс {Prefixes.Argument}");
                    }
                }
                else
                {
                    Configuration.ControllerParameters.AdvancedFuncion Prefixes = Parameters.Prefixes.Prefixes.FirstOrDefault(prefix => prefix.Argument == Info.Info.Prefix && prefix.Permissions == Permissions);
                    if (Prefixes != null)
                    {
                        Info.Info.Prefix = Controller.SetupDefaults.PrefixDefault;

                        if (player != null)
                            ReplySystem(player, GetLang("PREFIX_RETURNRED", player.UserIDString, Prefixes.Argument));

                        Log(LanguageEn
                            ? $"Player ({UserID}) expired prefix {Prefixes.Argument}"
                            : $"У игрока ({UserID}) истек префикс {Prefixes.Argument}");
                    }
                }
            }
            if (Controller.Turneds.TurnAutoSetupColorNick)
            {
                Configuration.ControllerParameters.AdvancedFuncion ColorNick = Parameters.NickColorList.FirstOrDefault(nick => Info.Info.ColorNick == nick.Argument && nick.Permissions == Permissions);
                if (ColorNick != null)
                {
                    Info.Info.ColorNick = Controller.SetupDefaults.NickDefault;
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                    if (player != null)
                        ReplySystem(player, GetLang("COLOR_NICK_RETURNRED", player.UserIDString, ColorNick.Argument));
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                    Log(LanguageEn
                        ? $"Player ({UserID}) expired nick color {ColorNick.Argument}"
                        : $"У игрока ({UserID}) истек цвет ника {ColorNick.Argument}");
                }
            }
            if (Controller.Turneds.TurnAutoSetupColorChat)
            {
                Configuration.ControllerParameters.AdvancedFuncion ColorChat = Parameters.MessageColorList.FirstOrDefault(message => Info.Info.ColorMessage == message.Argument && message.Permissions == Permissions);
                if (ColorChat == null) return;

                Info.Info.ColorMessage = Controller.SetupDefaults.MessageDefault;

                if (player != null)
                    ReplySystem(player, GetLang("COLOR_CHAT_RETURNRED", player.UserIDString, ColorChat.Argument));

                Log(LanguageEn ? $"Player ({UserID}) chat color expired {ColorChat.Argument}" : $"У игрока ({UserID}) истек цвет чата {ColorChat.Argument}");
            }
        }
        private void UserConnecteionData(BasePlayer player)
        {
            if (config.ControllerMessages.TurnedFunc.AntiNoobSetting.AntiNoobPM.AntiNoobActivate || config.ControllerMessages.TurnedFunc.AntiNoobSetting.AntiNoobChat.AntiNoobActivate)
            {
                if (!UserInformationConnection.ContainsKey(player.userID))
                    UserInformationConnection.Add(player.userID, new AntiNoob());
            }
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            Configuration.ControllerConnection ControllerConntect = config.ControllerConnect;
            Configuration.ControllerParameters ControllerParameter = config.ControllerParameter;
            if (ControllerConntect == null || ControllerParameter == null || UserInformation.ContainsKey(player.userID)) return;

            User Info = new User();
            if (ControllerConntect.Turneds.TurnAutoSetupPrefix)
            {
                if (ControllerParameter.Prefixes.TurnMultiPrefixes)
                    Info.Info.PrefixList.Add(ControllerConntect.SetupDefaults.PrefixDefault ?? "");
                else Info.Info.Prefix = ControllerConntect.SetupDefaults.PrefixDefault ?? "";
            }

            if (ControllerConntect.Turneds.TurnAutoSetupColorNick)
                Info.Info.ColorNick = ControllerConntect.SetupDefaults.NickDefault;

            if (ControllerConntect.Turneds.TurnAutoSetupColorChat)
                Info.Info.ColorMessage = ControllerConntect.SetupDefaults.MessageDefault;

            Info.Info.Rank = String.Empty;

            UserInformation.Add(player.userID, Info);
        }
        
        
                [ConsoleCommand("newui.cmd")]
        private void ConsoleCommandFuncional(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            String Action = arg.Args[0];
            if (Action == null || String.IsNullOrWhiteSpace(Action)) return;

            if (!LocalBase.ContainsKey(player))
            {
                PrintError(LanguageEn ? "UI was unable to process the local base (Local Base) contact the developer" : "UI не смог обработать локальную базу (LocalBase) свяжитесь с разработчиком");
                return;
            }
            Configuration.ControllerParameters ControllerParameters = config.ControllerParameter;
            if (ControllerParameters == null)
            {
                PrintError(LanguageEn ? "An error has been made in the configuration! Controller Parameters is null, contact developer" : "В конфигурации допущена ошибка! ControllerParameters является null, свяжитесь с разработчиком");
                return;
            }

            switch (Action)
            {
                case "action.mute.ignore":
                    {
                        String ActionMenu = arg.Args[1];
                        SelectedAction ActionType = (SelectedAction)Enum.Parse(typeof(SelectedAction), arg.Args[2]);
                        if (ActionMenu == "search.controller" && arg.Args.Length < 4)
                            return;

                        switch (ActionMenu)
                        {
                            case "mute.controller":
                                {
                                    if (!player.IsAdmin)
                                        if (!permission.UserHasPermission(player.UserIDString, PermissionMute)) return;
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                                    String ActionMute = arg.Args[3];
                                    switch (ActionMute)
                                    {
                                        case "mute.all.chat":
                                            {
                                                if (GeneralInfo.TurnMuteAllChat)
                                                {
                                                    GeneralInfo.TurnMuteAllChat = false;
                                                  //  ReplyBroadcast(GetLang("IQCHAT_FUNCED_NO_SEND_CHAT_UNMUTED_ALL_CHAT", player.UserIDString), AdminAlert: true);
                                                    ReplyBroadcast(null, null, true, "IQCHAT_FUNCED_NO_SEND_CHAT_UNMUTED_ALL_CHAT");
                                                }
                                                else
                                                {
                                                    GeneralInfo.TurnMuteAllChat = true;
                                                   // ReplyBroadcast(GetLang("IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_CHAT", player.UserIDString), AdminAlert: true);
                                                    ReplyBroadcast(null, null, true, "IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_CHAT");
                                                }

                                                DrawUI_IQChat_Update_MuteChat_All(player);
                                                break;
                                            }
                                        case "mute.all.voice":
                                            {
                                                if (GeneralInfo.TurnMuteAllVoice)
                                                {
                                                    GeneralInfo.TurnMuteAllVoice = false;
                                                 //   ReplyBroadcast(GetLang("IQCHAT_FUNCED_NO_SEND_CHAT_UMMUTED_ALL_VOICE", player.UserIDString), AdminAlert: true);
                                                    ReplyBroadcast(null, null, true, "IQCHAT_FUNCED_NO_SEND_CHAT_UMMUTED_ALL_VOICE");
                                                }
                                                else
                                                {
                                                    GeneralInfo.TurnMuteAllVoice = true;
                                                   // ReplyBroadcast(GetLang("IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_VOICE", player.UserIDString), AdminAlert: true);
                                                    ReplyBroadcast(null, null, true, "IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_VOICE");

                                                }
                                                DrawUI_IQChat_Update_MuteVoice_All(player);
                                                break;
                                            }
                                        default:
                                            break;
                                    }
                                    break;
                                }
                            case "ignore.and.mute.controller":
                                {
                                    String ActionController = arg.Args[3];
                                    BasePlayer TargetPlayer = BasePlayer.Find(arg.Args[4]);
                                    UInt64 ID = 0;
                                    UInt64.TryParse(arg.Args[4], out ID);

                                    if (TargetPlayer == null && !IsFake(ID))
                                    {
                                        CuiHelper.DestroyUi(player, "MUTE_AND_IGNORE_PANEL_ALERT");
                                        return;
                                    }

                                    switch (ActionController)
                                    {
                                        case "confirm.alert":
                                            {
                                                if (ActionType == SelectedAction.Ignore)
                                                    DrawUI_IQChat_Ignore_Alert(player, TargetPlayer, ID);
                                                else DrawUI_IQChat_Mute_Alert(player, TargetPlayer, ID);
                                                break;
                                            }
                                        case "open.reason.mute":
                                            {
                                                MuteType Type = (MuteType)Enum.Parse(typeof(MuteType), arg.Args[5]);
                                                DrawUI_IQChat_Mute_Alert_Reasons(player, TargetPlayer, Type, IDFake: ID);
                                                break;
                                            }
                                        case "confirm.yes":
                                            {
                                                if (ActionType == SelectedAction.Ignore)
                                                {
                                                    User Info = UserInformation[player.userID];
                                                    Info.Settings.IgnoredAddOrRemove(IsFake(ID) ? ID : TargetPlayer.userID);

                                                    CuiHelper.DestroyUi(player, "MUTE_AND_IGNORE_PANEL_ALERT");
                                                    DrawUI_IQChat_Mute_And_Ignore_Player_Panel(player, ActionType);
                                                }
                                                else
                                                {
                                                    MuteType Type = (MuteType)Enum.Parse(typeof(MuteType), arg.Args[5]);
                                                    Int32 IndexReason = Int32.Parse(arg.Args[6]);
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                                                    MutePlayer(TargetPlayer, Type, IndexReason, player, IDFake: ID);

                                                    CuiHelper.DestroyUi(player, "MUTE_AND_IGNORE_PANEL_ALERT");
                                                    DrawUI_IQChat_Mute_And_Ignore_Player_Panel(player, ActionType);
                                                }
                                                break;
                                            }
                                        case "unmute.yes":
                                            {
                                                MuteType Type = (MuteType)Enum.Parse(typeof(MuteType), arg.Args[5]);

                                                UnmutePlayer(TargetPlayer, Type, player);

                                                CuiHelper.DestroyUi(player, "MUTE_AND_IGNORE_PANEL_ALERT");
                                                DrawUI_IQChat_Mute_And_Ignore_Player_Panel(player, ActionType);
                                                break;
                                            }
                                    }
                                    break;
                                }
                            case "open":
                                {
                                    DrawUI_IQChat_Mute_And_Ignore(player, ActionType);
                                    break;
                                }
                            case "page.controller":
                                {
                                    Int32 Page = Int32.Parse(arg.Args[3]);

                                    DrawUI_IQChat_Mute_And_Ignore_Player_Panel(player, ActionType, Page);
                                    break;
                                }
                            case "search.controller":
                                {
                                    String SearchName = arg.Args[3];
                                    DrawUI_IQChat_Mute_And_Ignore_Player_Panel(player, ActionType, SearchName: SearchName);
                                    break;
                                }
                            default:
                                break;
                        }

                        break;
                    }
                case "checkbox.controller":
                    {
                        ElementsSettingsType Type = (ElementsSettingsType)Enum.Parse(typeof(ElementsSettingsType), arg.Args[1]);
                        if (!UserInformation.ContainsKey(player.userID)) return;
                        User Info = UserInformation[player.userID];
                        if (Info == null) return;

                        switch (Type)
                        {
                            case ElementsSettingsType.PM:
                                {
                                    if (Info.Settings.TurnPM)
                                        Info.Settings.TurnPM = false;
                                    else Info.Settings.TurnPM = true;

                                    DrawUI_IQChat_Update_Check_Box(player, Type, "143.38 -67.9", "151.38 -59.9", Info.Settings.TurnPM);
                                    break;
                                }
                            case ElementsSettingsType.Broadcast:
                                {
                                    if (Info.Settings.TurnBroadcast)
                                        Info.Settings.TurnBroadcast = false;
                                    else Info.Settings.TurnBroadcast = true;

                                    DrawUI_IQChat_Update_Check_Box(player, Type, "143.38 -79.6", "151.38 -71.6", Info.Settings.TurnBroadcast);
                                    break;
                                }
                            case ElementsSettingsType.Alert:
                                {
                                    if (Info.Settings.TurnAlert)
                                        Info.Settings.TurnAlert = false;
                                    else Info.Settings.TurnAlert = true;
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                                    DrawUI_IQChat_Update_Check_Box(player, Type, "143.38 -91.6", "151.38 -83.6", Info.Settings.TurnAlert);
                                    break;
                                }
                            case ElementsSettingsType.Sound:
                                {
                                    if (Info.Settings.TurnSound)
                                        Info.Settings.TurnSound = false;
                                    else Info.Settings.TurnSound = true;

                                    DrawUI_IQChat_Update_Check_Box(player, Type, "143.38 -103.6", "151.38 -95.6", Info.Settings.TurnSound);
                                    break;
                                }
                            default:
                                break;
                        }
                        break;
                    }
                case "droplist.controller":
                    {
                        String ActionDropList = arg.Args[1];
                        TakeElementUser Element = (TakeElementUser)Enum.Parse(typeof(TakeElementUser), arg.Args[2]);

                        switch (ActionDropList)
                        {
                            case "open":
                                {
                                    DrawUI_IQChat_OpenDropList(player, Element);
                                    break;
                                }
                            case "page.controller":
                                {
                                    String ActionDropListPage = arg.Args[3];
                                    Int32 Page = (Int32)Int32.Parse(arg.Args[4]);
                                    Page = ActionDropListPage == "+" ? Page + 1 : Page - 1;

                                    DrawUI_IQChat_OpenDropList(player, Element, Page);
                                    break;
                                }
                            case "element.take":
                                {
                                    Int32 Count = Int32.Parse(arg.Args[3]);
                                    String Permissions = arg.Args[4];
                                    String Argument = String.Join(" ", arg.Args.Skip(5));
                                    if (!permission.UserHasPermission(player.UserIDString, Permissions)) return;
                                    if (!UserInformation.ContainsKey(player.userID)) return;
                                    User User = UserInformation[player.userID];
                                    if (User == null) return;

                                    switch (Element)
                                    {
                                        case TakeElementUser.MultiPrefix:
                                            {
                                                if (!User.Info.PrefixList.Contains(Argument))
                                                {
                                                    User.Info.PrefixList.Add(Argument);
                                                    DrawUI_IQChat_OpenDropListArgument(player, Count);
                                                }
                                                else
                                                {
                                                    User.Info.PrefixList.Remove(Argument);
                                                    CuiHelper.DestroyUi(player, $"TAKED_INFO_{Count}");
                                                }
                                                break;
                                            }
                                        case TakeElementUser.Prefix:
                                            User.Info.Prefix = User.Info.Prefix.Equals(Argument) ? String.Empty : Argument;
                                            break;
                                        case TakeElementUser.Nick:
                                            User.Info.ColorNick = Argument;
                                            break;
                                        case TakeElementUser.Chat:
                                            User.Info.ColorMessage = Argument;
                                            break;
                                        case TakeElementUser.Rank:
                                            {
                                                User.Info.Rank = Argument;
                                                IQRankSetRank(player.userID, Argument);
                                            }
                                            break;
                                        default:
                                            break;
                                    }
                                    DrawUI_IQChat_Update_DisplayName(player);
                                    break;
                                }
                        }
                        break;
                    }
                case "slider.controller": // newui.cmd slider.controller 0 +
                    {
                        TakeElementUser Element = (TakeElementUser)Enum.Parse(typeof(TakeElementUser), arg.Args[1]);
                        List<Configuration.ControllerParameters.AdvancedFuncion> SliderElements = new List<Configuration.ControllerParameters.AdvancedFuncion>();
                        User Info = UserInformation[player.userID];
                        if (Info == null) return;

                        InformationOpenedUI InfoUI = LocalBase[player];
                        if (InfoUI == null) return;


                        String ActionSlide = arg.Args[2];

                        switch (Element)
                        {
                            case TakeElementUser.Prefix:
                                {
                                    SliderElements = LocalBase[player].ElementsPrefix;
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                                    if (SliderElements == null || SliderElements.Count == 0) return;

                                    if (ActionSlide == "+")
                                    {
                                        InfoUI.SlideIndexPrefix++;

                                        if (InfoUI.SlideIndexPrefix >= SliderElements.Count)
                                            InfoUI.SlideIndexPrefix = 0;
                                    }
                                    else
                                    {
                                        InfoUI.SlideIndexPrefix--;

                                        if (InfoUI.SlideIndexPrefix < 0)
                                            InfoUI.SlideIndexPrefix = SliderElements.Count - 1;
                                    }

                                    Info.Info.Prefix = SliderElements[InfoUI.SlideIndexPrefix].Argument;
                                }
                                break;
                            case TakeElementUser.Nick:
                                {
                                    SliderElements = LocalBase[player].ElementsNick;

                                    if (SliderElements == null || SliderElements.Count == 0) return;

                                    if (ActionSlide == "+")
                                    {
                                        InfoUI.SlideIndexNick++;

                                        if (InfoUI.SlideIndexNick >= SliderElements.Count)
                                            InfoUI.SlideIndexNick = 0;
                                    }
                                    else
                                    {
                                        InfoUI.SlideIndexNick--;

                                        if (InfoUI.SlideIndexNick < 0)
                                            InfoUI.SlideIndexNick = SliderElements.Count - 1;
                                    }
                                    Info.Info.ColorNick = SliderElements[InfoUI.SlideIndexNick].Argument;
                                }
                                break;
                            case TakeElementUser.Chat:
                                {
                                    SliderElements = LocalBase[player].ElementsChat;
                                    if (SliderElements == null || SliderElements.Count == 0) return;

                                    if (ActionSlide == "+")
                                    {
                                        InfoUI.SlideIndexChat++;

                                        if (InfoUI.SlideIndexChat >= SliderElements.Count)
                                            InfoUI.SlideIndexChat = 0;
                                    }
                                    else
                                    {
                                        InfoUI.SlideIndexChat--;
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                                        if (InfoUI.SlideIndexChat < 0)
                                            InfoUI.SlideIndexChat = SliderElements.Count - 1;
                                    }
                                    Info.Info.ColorMessage = SliderElements[InfoUI.SlideIndexChat].Argument;
                                }
                                break;
                            case TakeElementUser.Rank:
                                {
                                    SliderElements = LocalBase[player].ElementsRanks;
                                    if (SliderElements == null || SliderElements.Count == 0) return;

                                    if (ActionSlide == "+")
                                    {
                                        InfoUI.SlideIndexRank++;

                                        if (InfoUI.SlideIndexRank >= SliderElements.Count)
                                            InfoUI.SlideIndexRank = 0;
                                    }
                                    else
                                    {
                                        InfoUI.SlideIndexRank--;

                                        if (InfoUI.SlideIndexRank < 0)
                                            InfoUI.SlideIndexRank = SliderElements.Count - 1;
                                    }
                                    Info.Info.Rank = SliderElements[InfoUI.SlideIndexRank].Argument;
                                    IQRankSetRank(player.userID, SliderElements[InfoUI.SlideIndexRank].Argument);
                                }
                                break;
                            default:
                                break;
                        }
                        DrawUI_IQChat_Slider_Update_Argument(player, Element);
                        DrawUI_IQChat_Update_DisplayName(player);
                        break;
                    }
                default:
                    break;
            }
        }
        private void AddHistoryMessage(BasePlayer player, String Message)
        {
            if (!LastMessagesChat.ContainsKey(player))
                LastMessagesChat.Add(player, new List<String> { Message });
            else LastMessagesChat[player].Add(Message);
        }

        private String GetPlayerFormat(BasePlayer playerInList)
        {
            GeneralInformation.RenameInfo Renamer = GeneralInfo.GetInfoRename(playerInList.userID);
            String NickNamed = Renamer != null ? $"{Renamer.RenameNick ?? playerInList.displayName}" : playerInList.displayName;

            User Info = UserInformation[playerInList.userID];

            Configuration.ControllerParameters ControllerParameter = config.ControllerParameter;
            Configuration.ControllerMute ControllerMutes = config.ControllerMutes;

            String Prefixes = String.Empty;
            String ColorNickPlayer = String.IsNullOrWhiteSpace(Info.Info.ColorNick) ? playerInList.IsAdmin ? "#a8fc55" : "#54aafe" : Info.Info.ColorNick;

            if (ControllerParameter.Prefixes.TurnMultiPrefixes)
            {
                if (Info.Info.PrefixList != null)
                    Prefixes = String.Join("", Info.Info.PrefixList.Take(ControllerParameter.Prefixes.MaximumMultiPrefixCount));
            }
            else Prefixes = Info.Info.Prefix;

            String ResultName = $"{Prefixes}<color={ColorNickPlayer}>{NickNamed}</color>";

            return ResultName;
        }
        
        
        object OnPlayerVoice(BasePlayer player, Byte[] data)
        {
            if (UserInformation[player.userID].MuteInfo.IsMute(MuteType.Voice))
                return false;
            return null;
        }
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                private void DrawUI_IQChat_Update_DisplayName(BasePlayer player)
        {
            String InterfaceVisualNick = InterfaceBuilder.GetInterface("UI_Chat_Context_Visual_Nick");
            User Info = UserInformation[player.userID];
            Configuration.ControllerParameters Controller = config.ControllerParameter;
            if (Info == null || InterfaceVisualNick == null || Controller == null) return;

            String DisplayNick = String.Empty;

            String Pattern = @"</?size.*?>";
            // if (Controller.Prefixes.TurnMultiPrefixes) 
            // {
            //     if (Info.Info.PrefixList != null && Info.Info.PrefixList.Count != 0)
            //         DisplayNick += Info.Info.PrefixList.Count > 1 ? $"{(Regex.IsMatch(Info.Info.PrefixList[0], Pattern) ? Regex.Replace(Info.Info.PrefixList[0], Pattern, "") : Info.Info.PrefixList[0])}+{Info.Info.PrefixList.Count - 1}" :
            //             (Regex.IsMatch(Info.Info.PrefixList[0], Pattern) ? Regex.Replace(Info.Info.PrefixList[0], Pattern, "") : Info.Info.PrefixList[0]);
            // }
            // else DisplayNick += Regex.IsMatch(Info.Info.Prefix, Pattern) ? Regex.Replace(Info.Info.Prefix, Pattern, "") : Info.Info.Prefix;
            //
            if (Controller.Prefixes.TurnMultiPrefixes)
            {
                if (Info.Info.PrefixList != null && Info.Info.PrefixList.Count != 0)
                {
                    if (Info.Info.PrefixList[0] != null && Regex.IsMatch(Info.Info.PrefixList[0], Pattern))
                        DisplayNick += Regex.Replace(Info.Info.PrefixList[0], Pattern, "");
                    else
                        DisplayNick += Info.Info.PrefixList[0];

                    DisplayNick += Info.Info.PrefixList.Count > 1 ? $"+{Info.Info.PrefixList.Count - 1}" : string.Empty;
                }
            }
            else
            {
                if (Info.Info.Prefix != null && Regex.IsMatch(Info.Info.Prefix, Pattern))
                    DisplayNick += Regex.Replace(Info.Info.Prefix, Pattern, "");
                else DisplayNick += Info.Info.Prefix;
            }

            DisplayNick += $"<color={Info.Info.ColorNick ?? "#ffffff"}>{player.displayName}</color>: <color={Info.Info.ColorMessage ?? "#ffffff"}>{GetLang("IQCHAT_CONTEXT_NICK_DISPLAY_MESSAGE", player.UserIDString)}</color>";

            InterfaceVisualNick = InterfaceVisualNick.Replace("%NICK_DISPLAY%", DisplayNick);


            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_Chat_Context_Visual_Nick);
            CuiHelper.AddUi(player, InterfaceVisualNick);
        }

        
        private static Configuration config = new Configuration();
        void WriteData()
        {
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQSystem/IQChat/Information", GeneralInfo);
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQSystem/IQChat/Users", UserInformation);
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQSystem/IQChat/AntiNoob", UserInformationConnection);
        }

        
        
                private new void LoadDefaultMessages()
        {
            PrintWarning(LanguageEn ? "Language file is loading..." : "Языковой файл загружается...");
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["FUNC_MESSAGE_MUTE_CHAT"] = "{0} muted {1}\nDuration : {2}\nReason : {3}",
                ["FUNC_MESSAGE_UNMUTE_CHAT"] = "{0} unmuted {1}",
                ["FUNC_MESSAGE_MUTE_VOICE"] = "{0} muted voice to {1}\nDuration : {2}\nReason : {3}",
                ["FUNC_MESSAGE_UNMUTE_VOICE"] = "{0} unmuted voice to {1}",
                ["FUNC_MESSAGE_MUTE_ALL_CHAT"] = "Chat disabled",
                ["FUNC_MESSAGE_UNMUTE_ALL_CHAT"] = "Chat enabled",
                ["FUNC_MESSAGE_MUTE_ALL_VOICE"] = "Voice chat disabled",
                ["FUNC_MESSAGE_UNMUTE_ALL_VOICE"] = "Voice chat enabled",
                ["FUNC_MESSAGE_MUTE_ALL_ALERT"] = "Blocking by Administrator",
                ["FUNC_MESSAGE_PM_TURN_FALSE"] = "The player has forbidden to send himself private messages",
                ["FUNC_MESSAGE_ALERT_TURN_FALSE"] = "The player has not been allowed to notify himself",

                ["FUNC_MESSAGE_NO_ARG_BROADCAST"] = "You can not send an empty broadcast message!",

                ["UI_ALERT_TITLE"] = "<size=14><b>Notification</b></size>",
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                ["COMMAND_NOT_PERMISSION"] = "You dont have permissions to use this command",
                ["COMMAND_RENAME_NOTARG"] = "For rename use : /rename [NewNickname] [NewID (Optional)]",
                ["COMMAND_RENAME_NOT_ID"] = "Incorrect ID for renaming! Use Steam64ID or leave blank",
                ["COMMAND_RENAME_SUCCES"] = "You have successfully changed your nickname!\nyour nickname : {0}\nYour ID : {1}",
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                ["COMMAND_PM_NOTARG"] = "To send pm use : /pm Nickname Message",
                ["COMMAND_PM_NOT_NULL_MSG"] = "Message is empty!",
                ["COMMAND_PM_NOT_USER"] = "User not found or offline",
                ["COMMAND_PM_SUCCESS"] = "Your private message sent successful\n\nMessage : {0}\n\nDelivered : {1}",
                ["COMMAND_PM_SEND_MSG"] = "Message from {0}\n\n{1}",

                ["COMMAND_R_NOTARG"] = "For reply use : /r Message",
                ["COMMAND_R_NOTMSG"] = "You dont have any private conversations yet!",

                ["FLOODERS_MESSAGE"] = "You're typing too fast! Please Wait {0} seconds",

                ["PREFIX_SETUP"] = "You have successfully removed the prefix {0}, it is already activated and installed",
                ["COLOR_CHAT_SETUP"] = "You have successfully picked up the <color={0}>chat color</color>, it is already activated and installed",
                ["COLOR_NICK_SETUP"] = "You have successfully taken the <color={0}>nickname color</color>, it is already activated and installed",

                ["PREFIX_RETURNRED"] = "Your prefix {0} expired, it was reset automatically",
                ["COLOR_CHAT_RETURNRED"] = "Action of your <color={0}>color chat</color> over, it is reset automatically",
                ["COLOR_NICK_RETURNRED"] = "Action of your <color={0}>color nick</color> over, it is reset automatically",

                ["WELCOME_PLAYER"] = "{0} came online",
                ["LEAVE_PLAYER"] = "{0} left",
                ["WELCOME_PLAYER_WORLD"] = "{0} came online. Country: {1}",
                ["LEAVE_PLAYER_REASON"] = "{0} left. Reason: {1}",

                ["IGNORE_ON_PLAYER"] = "You added {0} in black list",
                ["IGNORE_OFF_PLAYER"] = "You removed {0} from black list",
                ["IGNORE_NO_PM"] = "This player added you in black list. Your message has not been delivered.",
                ["IGNORE_NO_PM_ME"] = "You added this player in black list. Your message has not been delivered.",
                ["INGORE_NOTARG"] = "To ignore a player use : /ignore nickname",

                ["DISCORD_SEND_LOG_CHAT"] = "Player : {0}({1})\nFiltred message : {2}\nMessage : {3}",
                ["DISCORD_SEND_LOG_MUTE"] = "{0}({1}) give mute chat\nSuspect : {2}({3})\nReason : {4}",

                ["TITLE_FORMAT_DAYS"] = "D",
                ["TITLE_FORMAT_HOURSE"] = "H",
                ["TITLE_FORMAT_MINUTES"] = "M",
                ["TITLE_FORMAT_SECONDS"] = "S",

                ["IQCHAT_CONTEXT_TITLE"] = "SETTING UP A CHAT", ///"%TITLE%"
                ["IQCHAT_CONTEXT_SETTING_ELEMENT_TITLE"] = "CUSTOM SETTING", ///"%SETTING_ELEMENT%"
                ["IQCHAT_CONTEXT_INFORMATION_TITLE"] = "INFORMATION", ///"%INFORMATION%"
                ["IQCHAT_CONTEXT_SETTINGS_TITLE"] = "SETTINGS", ///"%SETTINGS%"
                ["IQCHAT_CONTEXT_SETTINGS_PM_TITLE"] = "Private messages", ///"%SETTINGS_PM%"
                ["IQCHAT_CONTEXT_SETTINGS_ALERT_TITLE"] = "Notification in the chat", ///"%SETTINGS_ALERT%"
                ["IQCHAT_CONTEXT_SETTINGS_ALERT_PM_TITLE"] = "Mention in the chat", ///"%SETTINGS_ALERT_PM%"
                ["IQCHAT_CONTEXT_SETTINGS_SOUNDS_TITLE"] = "Sound notification", ///"%SETTINGS_SOUNDS%"
                ["IQCHAT_CONTEXT_MUTE_STATUS_NOT"] = "NO", ///"%MUTE_STATUS_PLAYER%"
                ["IQCHAT_CONTEXT_MUTE_STATUS_TITLE"] = "Blocking the chat", ///"%MUTE_STATUS_TITLE%"
                ["IQCHAT_CONTEXT_IGNORED_STATUS_COUNT"] = "<size=11>{0}</size> human (а)", ///"%IGNORED_STATUS_COUNT%"
                ["IQCHAT_CONTEXT_IGNORED_STATUS_TITLE"] = "Ignoring", ///"%IGNORED_STATUS_TITLE%"
                ["IQCHAT_CONTEXT_NICK_DISPLAY_TITLE"] = "Your nickname", ///"%NICK_DISPLAY_TITLE%"
                ["IQCHAT_CONTEXT_NICK_DISPLAY_MESSAGE"] = "i love iqchat",
                ["IQCHAT_CONTEXT_SLIDER_PREFIX_TITLE"] = "Prefix", /// %SLIDER_PREFIX_TITLE%
                ["IQCHAT_CONTEXT_SLIDER_NICK_COLOR_TITLE"] = "Nick", /// %SLIDER_NICK_COLOR_TITLE%
                ["IQCHAT_CONTEXT_SLIDER_MESSAGE_COLOR_TITLE"] = "Message", /// %SLIDER_MESSAGE_COLOR_TITLE%
                ["IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE"] = "Rank",
                ["IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE_NULLER"] = "Absent",
                ["IQCHAT_CONTEXT_SLIDER_PREFIX_TITLE_DESCRIPTION"] = "Choosing a prefix", /// 
                ["IQCHAT_CONTEXT_SLIDER_CHAT_NICK_TITLE_DESCRIPTION"] = "Choosing a nickname color", /// 
                ["IQCHAT_CONTEXT_SLIDER_CHAT_MESSAGE_TITLE_DESCRIPTION"] = "Chat Color Selection", /// 
                ["IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE_DESCRIPTION"] = "Rank Selection", /// 
                ["IQCHAT_CONTEXT_DESCRIPTION_PREFIX"] = "Prefix Setting",
                ["IQCHAT_CONTEXT_DESCRIPTION_NICK"] = "Setting up a nickname",
                ["IQCHAT_CONTEXT_DESCRIPTION_CHAT"] = "Setting up a message",
                ["IQCHAT_CONTEXT_DESCRIPTION_RANK"] = "Setting up the rank",

                ["IQCHAT_ALERT_TITLE"] = "ALERT", /// %TITLE_ALERT%

                ["IQCHAT_TITLE_IGNORE_AND_MUTE_MUTED"] = "LOCK MANAGEMENT",
                ["IQCHAT_TITLE_IGNORE_AND_MUTE_IGNORED"] = "IGNORING MANAGEMENT",
                ["IQCHAT_TITLE_IGNORE_TITLES"] = "<b>DO YOU REALLY WANT TO IGNORE\n{0}?</b>",
                ["IQCHAT_TITLE_IGNORE_TITLES_UNLOCK"] = "<b>DO YOU WANT TO REMOVE THE IGNORING FROM THE PLAYER\n{0}?</b>",
                ["IQCHAT_TITLE_IGNORE_BUTTON_YES"] = "<b>YES, I WANT TO</b>",
                ["IQCHAT_TITLE_IGNORE_BUTTON_NO"] = "<b>NO, I CHANGED MY MIND</b>",
                ["IQCHAT_TITLE_MODERATION_PANEL"] = "MODERATOR PANEL",

                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU"] = "Lock Management",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT"] = "SELECT AN ACTION",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_REASON"] = "SELECT THE REASON FOR BLOCKING",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_CHAT"] = "Block chat",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_VOICE"] = "Block voice",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_MENU_TITLE_ALERT_CHAT"] = "Unblock chat",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_MENU_TITLE_ALERT_VOICE"] = "Unlock voice",
                ["IQCHAT_BUTTON_MODERATION_MUTE_ALL_CHAT"] = "Block all chat",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_ALL_CHAT"] = "Unblock all chat",
                ["IQCHAT_BUTTON_MODERATION_MUTE_ALL_VOICE"] = "Block everyone's voice",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_ALL_VOICE"] = "Unlock everyone's voice",

                ["IQCHAT_FUNCED_NO_SEND_CHAT_MUTED"] = "You have an active chat lock : {0}",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_CHAT"] = "The administrator blocked everyone's chat. Expect full unblocking",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_VOICE"] = "The administrator blocked everyone's voice chat. Expect full unblocking",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_UMMUTED_ALL_VOICE"] = "The administrator has unblocked the voice chat for everyone",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_UNMUTED_ALL_CHAT"] = "The administrator has unblocked the chat for everyone",

                ["IQCHAT_FUNCED_ALERT_TITLE"] = "<color=#a7f64f><b>[MENTION]</b></color>",
                ["IQCHAT_FUNCED_ALERT_TITLE_ISMUTED"] = "The player has already been muted!",
                ["IQCHAT_FUNCED_ALERT_TITLE_SERVER"] = "Administrator",

                ["IQCHAT_INFO_ONLINE"] = "Now on the server :\n{0}",

                ["IQCHAT_INFO_ANTI_NOOB"] = "You first connected to the server!\nPlay some more {0}\nTo get access to send messages to the global and team chat!",
                ["IQCHAT_INFO_ANTI_NOOB_PM"] = "You first connected to the server!\nPlay some more {0}\nTo access sending messages to private messages!",

                ["XLEVELS_SYNTAX_PREFIX"] = "[{0} Level]",
                ["CLANS_SYNTAX_PREFIX"] = "[{0}]",
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            }, this);
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["FUNC_MESSAGE_MUTE_CHAT"] = "{0} заблокировал чат игроку {1}\nДлительность : {2}\nПричина : {3}",
                ["FUNC_MESSAGE_UNMUTE_CHAT"] = "{0} разблокировал чат игроку {1}",
                ["FUNC_MESSAGE_MUTE_VOICE"] = "{0} заблокировал голос игроку {1}\nДлительность : {2}\nПричина : {3}",
                ["FUNC_MESSAGE_UNMUTE_VOICE"] = "{0} разблокировал голос игроку {1}",
                ["FUNC_MESSAGE_MUTE_ALL_CHAT"] = "Всем игрокам был заблокирован чат",
                ["FUNC_MESSAGE_UNMUTE_ALL_CHAT"] = "Всем игрокам был разблокирован чат",
                ["FUNC_MESSAGE_MUTE_ALL_VOICE"] = "Всем игрокам был заблокирован голос",
                ["FUNC_MESSAGE_MUTE_ALL_ALERT"] = "Блокировка Администратором",
                ["FUNC_MESSAGE_UNMUTE_ALL_VOICE"] = "Всем игрокам был разблокирован голос",

                ["FUNC_MESSAGE_PM_TURN_FALSE"] = "Игрок запретил присылать себе личные сообщения",
                ["FUNC_MESSAGE_ALERT_TURN_FALSE"] = "Игрок запретил уведомлять себя",

                ["FUNC_MESSAGE_NO_ARG_BROADCAST"] = "Вы не можете отправлять пустое сообщение в оповещение!",

                ["UI_ALERT_TITLE"] = "<size=14><b>Уведомление</b></size>",

                ["COMMAND_NOT_PERMISSION"] = "У вас недостаточно прав для данной команды",
                ["COMMAND_RENAME_NOTARG"] = "Используйте команду так : /rename [НовыйНик] [НовыйID (По желанию)]",
                ["COMMAND_RENAME_NOT_ID"] = "Неверно указан ID для переименования! Используйте Steam64ID, либо оставьте поле пустым",
                ["COMMAND_RENAME_SUCCES"] = "Вы успешно изменили ник!\nВаш ник : {0}\nВаш ID : {1}",

                ["COMMAND_PM_NOTARG"] = "Используйте команду так : /pm Ник Игрока Сообщение",
                ["COMMAND_PM_NOT_NULL_MSG"] = "Вы не можете отправлять пустое сообщение",
                ["COMMAND_PM_NOT_USER"] = "Игрок не найден или не в сети",
                ["COMMAND_PM_SUCCESS"] = "Ваше сообщение успешно доставлено\n\nСообщение : {0}\n\nДоставлено : {1}",
                ["COMMAND_PM_SEND_MSG"] = "Сообщение от {0}\n\n{1}",

                ["COMMAND_R_NOTARG"] = "Используйте команду так : /r Сообщение",
                ["COMMAND_R_NOTMSG"] = "Вам или вы ещё не писали игроку в личные сообщения!",

                ["FLOODERS_MESSAGE"] = "Вы пишите слишком быстро! Подождите {0} секунд",

                ["PREFIX_SETUP"] = "Вы успешно забрали префикс {0}, он уже активирован и установлен",
                ["COLOR_CHAT_SETUP"] = "Вы успешно забрали <color={0}>цвет чата</color>, он уже активирован и установлен",
                ["COLOR_NICK_SETUP"] = "Вы успешно забрали <color={0}>цвет ника</color>, он уже активирован и установлен",

                ["PREFIX_RETURNRED"] = "Действие вашего префикса {0} окончено, он сброшен автоматически",
                ["COLOR_CHAT_RETURNRED"] = "Действие вашего <color={0}>цвета чата</color> окончено, он сброшен автоматически",
                ["COLOR_NICK_RETURNRED"] = "Действие вашего <color={0}>цвет ника</color> окончено, он сброшен автоматически",

                ["WELCOME_PLAYER"] = "{0} зашел на сервер",
                ["LEAVE_PLAYER"] = "{0} вышел с сервера",
                ["WELCOME_PLAYER_WORLD"] = "{0} зашел на сервер.Из {1}",
                ["LEAVE_PLAYER_REASON"] = "{0} вышел с сервера.Причина {1}",

                ["IGNORE_ON_PLAYER"] = "Вы добавили игрока {0} в черный список",
                ["IGNORE_OFF_PLAYER"] = "Вы убрали игрока {0} из черного списка",
                ["IGNORE_NO_PM"] = "Данный игрок добавил вас в ЧС,ваше сообщение не будет доставлено",
                ["IGNORE_NO_PM_ME"] = "Вы добавили данного игрока в ЧС,ваше сообщение не будет доставлено",
                ["INGORE_NOTARG"] = "Используйте команду так : /ignore Ник Игрока",

                ["DISCORD_SEND_LOG_CHAT"] = "Игрок : {0}({1})\nФильтрованное сообщение : {2}\nИзначальное сообщение : {3}",
                ["DISCORD_SEND_LOG_MUTE"] = "{0}({1}) выдал блокировку чата\nИгрок : {2}({3})\nПричина : {4}",

                ["TITLE_FORMAT_DAYS"] = "Д",
                ["TITLE_FORMAT_HOURSE"] = "Ч",
                ["TITLE_FORMAT_MINUTES"] = "М",
                ["TITLE_FORMAT_SECONDS"] = "С",

                ["IQCHAT_CONTEXT_TITLE"] = "НАСТРОЙКА ЧАТА", ///"%TITLE%"
                ["IQCHAT_CONTEXT_SETTING_ELEMENT_TITLE"] = "ПОЛЬЗОВАТЕЛЬСКАЯ НАСТРОЙКА", ///"%SETTING_ELEMENT%"
                ["IQCHAT_CONTEXT_INFORMATION_TITLE"] = "ИНФОРМАЦИЯ", ///"%INFORMATION%"
                ["IQCHAT_CONTEXT_SETTINGS_TITLE"] = "НАСТРОЙКИ", ///"%SETTINGS%"
                ["IQCHAT_CONTEXT_SETTINGS_PM_TITLE"] = "Личные сообщения", ///"%SETTINGS_PM%"
                ["IQCHAT_CONTEXT_SETTINGS_ALERT_TITLE"] = "Оповещение в чате", ///"%SETTINGS_ALERT%"
                ["IQCHAT_CONTEXT_SETTINGS_ALERT_PM_TITLE"] = "Упоминание в чате", ///"%SETTINGS_ALERT_PM%"
                ["IQCHAT_CONTEXT_SETTINGS_SOUNDS_TITLE"] = "Звуковое оповещение", ///"%SETTINGS_SOUNDS%"
                ["IQCHAT_CONTEXT_MUTE_STATUS_NOT"] = "НЕТ", ///"%MUTE_STATUS_PLAYER%"
                ["IQCHAT_CONTEXT_MUTE_STATUS_TITLE"] = "Блокировка чата", ///"%MUTE_STATUS_TITLE%"
                ["IQCHAT_CONTEXT_IGNORED_STATUS_COUNT"] = "<size=11>{0}</size> человек (а)", ///"%IGNORED_STATUS_COUNT%"
                ["IQCHAT_CONTEXT_IGNORED_STATUS_TITLE"] = "Игнорирование", ///"%IGNORED_STATUS_TITLE%"
                ["IQCHAT_CONTEXT_NICK_DISPLAY_TITLE"] = "Ваш ник", ///"%NICK_DISPLAY_TITLE%"
                ["IQCHAT_CONTEXT_NICK_DISPLAY_MESSAGE"] = "люблю iqchat",
                ["IQCHAT_CONTEXT_SLIDER_PREFIX_TITLE"] = "Префикс", /// %SLIDER_PREFIX_TITLE%
                ["IQCHAT_CONTEXT_SLIDER_NICK_COLOR_TITLE"] = "Ник", /// %SLIDER_NICK_COLOR_TITLE%
                ["IQCHAT_CONTEXT_SLIDER_MESSAGE_COLOR_TITLE"] = "Чат", /// %SLIDER_MESSAGE_COLOR_TITLE%
                ["IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE"] = "Ранг",
                ["IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE_NULLER"] = "Отсутствует",
                ["IQCHAT_CONTEXT_SLIDER_PREFIX_TITLE_DESCRIPTION"] = "Выбор префикса", /// 
                ["IQCHAT_CONTEXT_SLIDER_CHAT_NICK_TITLE_DESCRIPTION"] = "Выбор цвета ника", /// 
                ["IQCHAT_CONTEXT_SLIDER_CHAT_MESSAGE_TITLE_DESCRIPTION"] = "Выбор цвета чата", /// 
                ["IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE_DESCRIPTION"] = "Выбор ранга", /// 
                ["IQCHAT_CONTEXT_DESCRIPTION_PREFIX"] = "Настройка префикса",
                ["IQCHAT_CONTEXT_DESCRIPTION_NICK"] = "Настройка ника",
                ["IQCHAT_CONTEXT_DESCRIPTION_CHAT"] = "Настройка сообщения",
                ["IQCHAT_CONTEXT_DESCRIPTION_RANK"] = "Настройка ранга",

		   		 		  						  	   		  	  			  	  			  	 				  	  	
                ["IQCHAT_ALERT_TITLE"] = "УВЕДОМЛЕНИЕ", /// %TITLE_ALERT%
                ["IQCHAT_TITLE_IGNORE_AND_MUTE_MUTED"] = "УПРАВЛЕНИЕ БЛОКИРОВКАМИ",
                ["IQCHAT_TITLE_IGNORE_AND_MUTE_IGNORED"] = "УПРАВЛЕНИЕ ИГНОРИРОВАНИЕМ",
                ["IQCHAT_TITLE_IGNORE_TITLES"] = "<b>ВЫ ДЕЙСТВИТЕЛЬНО ХОТИТЕ ИГНОРИРОВАТЬ\n{0}?</b>",
                ["IQCHAT_TITLE_IGNORE_TITLES_UNLOCK"] = "<b>ВЫ ХОТИТЕ СНЯТЬ ИГНОРИРОВАНИЕ С ИГРОКА\n{0}?</b>",
                ["IQCHAT_TITLE_IGNORE_BUTTON_YES"] = "<b>ДА, ХОЧУ</b>",
                ["IQCHAT_TITLE_IGNORE_BUTTON_NO"] = "<b>НЕТ, ПЕРЕДУМАЛ</b>",
                ["IQCHAT_TITLE_MODERATION_PANEL"] = "ПАНЕЛЬ МОДЕРАТОРА",

                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU"] = "Управление блокировками",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT"] = "ВЫБЕРИТЕ ДЕЙСТВИЕ",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_REASON"] = "ВЫБЕРИТЕ ПРИЧИНУ БЛОКИРОВКИ",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_CHAT"] = "Заблокировать чат",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_VOICE"] = "Заблокировать голос",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_MENU_TITLE_ALERT_CHAT"] = "Разблокировать чат",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_MENU_TITLE_ALERT_VOICE"] = "Разблокировать голос",
                ["IQCHAT_BUTTON_MODERATION_MUTE_ALL_CHAT"] = "Заблокировать всем чат",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_ALL_CHAT"] = "Разблокировать всем чат",
                ["IQCHAT_BUTTON_MODERATION_MUTE_ALL_VOICE"] = "Заблокировать всем голос",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_ALL_VOICE"] = "Разблокировать всем голос",

                ["IQCHAT_FUNCED_NO_SEND_CHAT_MUTED"] = "У вас имеется активная блокировка чата : {0}",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_CHAT"] = "Администратор заблокировал всем чат. Ожидайте полной разблокировки",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_VOICE"] = "Администратор заблокировал всем голосоввой чат. Ожидайте полной разблокировки",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_UMMUTED_ALL_VOICE"] = "Администратор разрблокировал всем голосоввой чат",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_UNMUTED_ALL_CHAT"] = "Администратор разрблокировал всем чат",

                ["IQCHAT_FUNCED_ALERT_TITLE"] = "<color=#a7f64f><b>[УПОМИНАНИЕ]</b></color>",
                ["IQCHAT_FUNCED_ALERT_TITLE_ISMUTED"] = "Игрок уже был замучен!",
                ["IQCHAT_FUNCED_ALERT_TITLE_SERVER"] = "Администратор",

                ["IQCHAT_INFO_ONLINE"] = "Сейчас на сервере :\n{0}",
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                ["IQCHAT_INFO_ANTI_NOOB"] = "Вы впервые подключились на сервер!\nОтыграйте еще {0}\nЧтобы получить доступ к отправке сообщений в глобальный и командный чат!",
                ["IQCHAT_INFO_ANTI_NOOB_PM"] = "Вы впервые подключились на сервер!\nОтыграйте еще {0}\nЧтобы получить доступ к отправке сообщений в личные сообщения!",
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                ["XLEVELS_SYNTAX_PREFIX"] = "[{0} Level]",
                ["CLANS_SYNTAX_PREFIX"] = "[{0}]",

            }, this, "ru");

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["FUNC_MESSAGE_MUTE_CHAT"] = "{0} silenciado {1}\n Duración: {2}\nRazón: {3}",
                ["FUNC_MESSAGE_UNMUTE_CHAT"] = "{0} sin silenciar {1}",
                ["FUNC_MESSAGE_MUTE_VOICE"] = "{0} voz apagada a {1}\n Duracion : {2}\n Razon : {3}",
                ["FUNC_MESSAGE_UNMUTE_VOICE"] = "{0} voz no silenciada a {1}",
                ["FUNC_MESSAGE_MUTE_ALL_CHAT"] = "Chat desactivado",
                ["FUNC_MESSAGE_UNMUTE_ALL_CHAT"] = "Chat habilitado",
                ["FUNC_MESSAGE_MUTE_ALL_VOICE"] = "Chat de voz desactivado",
                ["FUNC_MESSAGE_UNMUTE_ALL_VOICE"] = "Chat de voz habilitado",
                ["FUNC_MESSAGE_MUTE_ALL_ALERT"] = "Bloqueo por parte del administrador",
                ["FUNC_MESSAGE_PM_TURN_FALSE"] = "El jugador tiene prohibido enviarse mensajes privados",
                ["FUNC_MESSAGE_ALERT_TURN_FALSE"] = "El jugador no ha podido notificarse a sí mismo",
                ["FUNC_MESSAGE_NO_ARG_BROADCAST"] = "No se puede enviar un mensaje vacío.",
                ["UI_ALERT_TITLE"] = "<size=14><b>Notificación</b></size>",
                ["COMMAND_NOT_PERMISSION"] = "No tienes permisos para usar este comando",
                ["COMMAND_RENAME_NOTARG"] = "Para renombrar utilice : /rename [NewNickname] [NewID (Optional)]",
                ["COMMAND_RENAME_NOT_ID"] = "¡ID incorrecto para renombrar! Utilice Steam64ID o déjelo en blanco",
                ["COMMAND_RENAME_SUCCES"] = "Has cambiado con éxito tu nombre de usuario. \n Tu nombre de usuario: {0}. \nTu ID: {1}.",
                ["COMMAND_PM_NOTARG"] = "Para enviar pm utilice : /pm [Nombre] [Mensaje]",
                ["COMMAND_PM_NOT_NULL_MSG"] = "¡El mensaje está vacío!",
                ["COMMAND_PM_NOT_USER"] = "Usuario no encontrado o desconectado",
                ["COMMAND_PM_SUCCESS"] = "Su mensaje privado enviado con éxito \n Mensage : {0}\n : Entregado{1}",
                ["COMMAND_PM_SEND_MSG"] = "Mensaje de {0}\n{1}",
                ["COMMAND_R_NOTARG"] = "Para responder utilice : /r Mensaje",
                ["COMMAND_R_NOTMSG"] = "Todavía no tienes ninguna conversación privada.",
                ["FLOODERS_MESSAGE"] = "¡Estás escribiendo demasiado rápido! Por favor, espere {0} segundos",
                ["PREFIX_SETUP"] = "Has eliminado con éxito el prefijo {0}.",
                ["COLOR_CHAT_SETUP"] = "Has obtenido un nuevo color en el chat",
                ["COLOR_NICK_SETUP"] = "Has cambiado tu nick correctamente del chat",
                ["PREFIX_RETURNRED"] = "Su prefijo {0} ha caducado, se ha restablecido automáticamente",
                ["COLOR_CHAT_RETURNRED"] = "Acción de su <color={0}>color de chat</color> más, se restablece automáticamente",
                ["COLOR_NICK_RETURNRED"] = "Acción de su <color={0}>color nick</color> sobre, se restablece automáticamente",
                ["WELCOME_PLAYER"] = "{0} Se ha conectado",
                ["LEAVE_PLAYER"] = "{0} izquierda",
                ["WELCOME_PLAYER_WORLD"] = "{0} Se ha conectado del Pais: {1}",
                ["LEAVE_PLAYER_REASON"] = "{0} Se ha desconectado. Razon: {1}",
                ["IGNORE_ON_PLAYER"] = "Has añadido {0} en la lista negra",
                ["IGNORE_OFF_PLAYER"] = "Has eliminado el jugador {0} de la lista negra",
                ["IGNORE_NO_PM"] = "Este jugador te ha añadido a la lista negra. Su mensaje no ha sido entregado.",
                ["IGNORE_NO_PM_ME"] = "Has añadido a este jugador en la lista negra. Su mensaje no ha sido entregado.",
                ["INGORE_NOTARG"] = "Para ignorar a un jugador utiliza : /ignore nickname",
                ["DISCORD_SEND_LOG_CHAT"] = "JUgador : {0}({1})\nMensaje filtrado : {2}\nMensages : {3}",
                ["DISCORD_SEND_LOG_MUTE"] = "{0}({1}) give mute chat\nSuspect : {2}({3})\nReason : {4}",
                ["TITLE_FORMAT_DAYS"] = "D",
                ["TITLE_FORMAT_HOURSE"] = "H",
                ["TITLE_FORMAT_MINUTES"] = "M",
                ["TITLE_FORMAT_SECONDS"] = "S",
                ["IQCHAT_CONTEXT_TITLE"] = "ESTABLECER UN CHAT",
                ["IQCHAT_CONTEXT_SETTING_ELEMENT_TITLE"] = "AJUSTE PERSONALIZADO",
                ["IQCHAT_CONTEXT_INFORMATION_TITLE"] = "INFORMACIÓN",
                ["IQCHAT_CONTEXT_SETTINGS_TITLE"] = "AJUSTES",
                ["IQCHAT_CONTEXT_SETTINGS_PM_TITLE"] = "Mensajes privados",
                ["IQCHAT_CONTEXT_SETTINGS_ALERT_TITLE"] = "Notificación en el chat",
                ["IQCHAT_CONTEXT_SETTINGS_ALERT_PM_TITLE"] = "Mención en el chat",
                ["IQCHAT_CONTEXT_SETTINGS_SOUNDS_TITLE"] = "Notificación sonora",
                ["IQCHAT_CONTEXT_MUTE_STATUS_NOT"] = "NO",
                ["IQCHAT_CONTEXT_MUTE_STATUS_TITLE"] = "Bloqueo del chat",
                ["IQCHAT_CONTEXT_IGNORED_STATUS_COUNT"] = "<size=11>{0}</size> humano (а)",
                ["IQCHAT_CONTEXT_IGNORED_STATUS_TITLE"] = "Ignorando",
                ["IQCHAT_CONTEXT_NICK_DISPLAY_TITLE"] = "Su apodo",
                ["IQCHAT_CONTEXT_NICK_DISPLAY_MESSAGE"] = "Me encanta Zoxiland",
                ["IQCHAT_CONTEXT_SLIDER_PREFIX_TITLE"] = "Prefijo",
                ["IQCHAT_CONTEXT_SLIDER_NICK_COLOR_TITLE"] = "Nick",
                ["IQCHAT_CONTEXT_SLIDER_MESSAGE_COLOR_TITLE"] = "Mensaje",
                ["IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE"] = "Rango",
                ["IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE_NULLER"] = "Ausente",
                ["IQCHAT_CONTEXT_SLIDER_PREFIX_TITLE_DESCRIPTION"] = "Elegir un prefijo",
                ["IQCHAT_CONTEXT_SLIDER_CHAT_NICK_TITLE_DESCRIPTION"] = "Elegir un color de apodo",
                ["IQCHAT_CONTEXT_SLIDER_CHAT_MESSAGE_TITLE_DESCRIPTION"] = "Selección del color del chat",
                ["IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE_DESCRIPTION"] = "Selección de rangos",
                ["IQCHAT_CONTEXT_DESCRIPTION_PREFIX"] = "Ajuste del prefijo",
                ["IQCHAT_CONTEXT_DESCRIPTION_NICK"] = "Configurar un apodo",
                ["IQCHAT_CONTEXT_DESCRIPTION_CHAT"] = "Configurar un mensaje",
                ["IQCHAT_CONTEXT_DESCRIPTION_RANK"] = "Establecimiento del rango",
                ["IQCHAT_ALERT_TITLE"] = "ALERTA",
                ["IQCHAT_TITLE_IGNORE_AND_MUTE_MUTED"] = "GESTIÓN MUTEADOS",
                ["IQCHAT_TITLE_IGNORE_AND_MUTE_IGNORED"] = "GESTIÓN IGNORE",
                ["IQCHAT_TITLE_IGNORE_TITLES"] = "<b>¿REALMENTE QUIERES IGNORAR\n{0}?</b>",
                ["IQCHAT_TITLE_IGNORE_TITLES_UNLOCK"] = "<b>¿QUIERES QUITARLE AL JUGADOR LO DE IGNORAR?\n{0}?</b>",
                ["IQCHAT_TITLE_IGNORE_BUTTON_YES"] = "<b>SÍ, QUIERO</b>",
                ["IQCHAT_TITLE_IGNORE_BUTTON_NO"] = "<b>NO, HE CAMBIADO DE OPINIÓN</b>",
                ["IQCHAT_TITLE_MODERATION_PANEL"] = "PANEL DE MODERADORES",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU"] = "Menu de muteados",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT"] = "SELECCIONE UNA ACCIÓN",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_REASON"] = "SELECCIONE EL MOTIVO DEL BLOQUEO",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_CHAT"] = "Bloquear el Chat",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_VOICE"] = "Bloquear Voz",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_MENU_TITLE_ALERT_CHAT"] = "Desbloquear Chat",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_MENU_TITLE_ALERT_VOICE"] = "Desbloquear Voz",
                ["IQCHAT_BUTTON_MODERATION_MUTE_ALL_CHAT"] = "Bloquear todos los chats",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_ALL_CHAT"] = "Desbloquear todo el chat",
                ["IQCHAT_BUTTON_MODERATION_MUTE_ALL_VOICE"] = "Bloquear la voz de todos",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_ALL_VOICE"] = "Desbloquear la voz de todos",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_MUTED"] = "Tienes un bloqueo de chat activo : {0}",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_CHAT"] = "El administrador ha bloqueado el chat. Espera el desbloqueo completo",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_VOICE"] = "El administrador ha bloqueado el chat de voz. Espera el desbloqueo completo",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_UMMUTED_ALL_VOICE"] = "El administrador ha desbloqueado el chat de voz.",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_UNMUTED_ALL_CHAT"] = "El administrador ha desbloqueado el chat",
                ["IQCHAT_FUNCED_ALERT_TITLE"] = "<color=#a7f64f><b>[MENCIÓN]</b></color>",
                ["IQCHAT_FUNCED_ALERT_TITLE_ISMUTED"] = "El jugador ya ha sido silenciado.",
                ["IQCHAT_FUNCED_ALERT_TITLE_SERVER"] = "Administrador",
                ["IQCHAT_INFO_ONLINE"] = "Now on the server :\n{0}",
                ["IQCHAT_INFO_ANTI_NOOB"] = "Tienes que jugar un poco mas para poder hablar por el chat {0}.",
                ["IQCHAT_INFO_ANTI_NOOB_PM"] = "No puedes enviar un privado por que es un jugador nuevo.",
                ["XLEVELS_SYNTAX_PREFIX"] = "[{0} Level]",
                ["CLANS_SYNTAX_PREFIX"] = "[{0}]",
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            }, this, "es-ES");

            PrintWarning(LanguageEn ? "Language file uploaded successfully" : "Языковой файл загружен успешно");
        }
        private const String PermissionRename = "iqchat.renameuse";

        private void Request(string url, string payload, Action<int> callback = null)
        {
            Dictionary<string, string> header = new Dictionary<string, string>();
            header.Add("Content-Type", "application/json");
            webrequest.Enqueue(url, payload, (code, response) =>
            {
                if (code != 200 && code != 204)
                {
                    if (response != null)
                    {
                        try
                        {
                            JObject json = JObject.Parse(response);
                            if (code == 429)
                            {
                                float seconds = float.Parse(Math.Ceiling((double)(int)json["retry_after"] / 1000).ToString());
                            }
                            else
                            {
                                PrintWarning($" Discord rejected that payload! Responded with \"{json["message"].ToString()}\" Code: {code}");
                            }
                        }
                        catch
                        {
                            PrintWarning($"Failed to get a valid response from discord! Error: \"{response}\" Code: {code}");
                        }
                    }
                    else
                    {
                        PrintWarning($"Discord didn't respond (down?) Code: {code}");
                    }
                }
                try
                {
                    callback?.Invoke(code);
                }
                catch (Exception ex) { }

            }, this, RequestMethod.POST, header);
        }
        private void DrawUI_IQChat_Context_AdminAndModeration(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermissionMute)) return;

            String InterfaceModeration = InterfaceBuilder.GetInterface("UI_Chat_Moderation");
            if (InterfaceModeration == null) return;

            InterfaceModeration = InterfaceModeration.Replace("%TITLE%", GetLang("IQCHAT_TITLE_MODERATION_PANEL", player.UserIDString));
            InterfaceModeration = InterfaceModeration.Replace("%COMMAND_MUTE_MENU%", $"newui.cmd action.mute.ignore open {SelectedAction.Mute}");
            InterfaceModeration = InterfaceModeration.Replace("%TEXT_MUTE_MENU%", GetLang("IQCHAT_BUTTON_MODERATION_MUTE_MENU", player.UserIDString));

            CuiHelper.AddUi(player, InterfaceModeration);

            DrawUI_IQChat_Update_MuteChat_All(player);
            DrawUI_IQChat_Update_MuteVoice_All(player);
        }

        void OnUserGroupRemoved(string id, string groupName)
        {
            String[] PermissionsGroup = permission.GetGroupPermissions(groupName);
            if (PermissionsGroup == null) return;

            foreach (String permName in PermissionsGroup)
                RemoveParametres(id, permName);
        }
        private void CheckValidateUsers()
        {
            Configuration.ControllerParameters Controller = config.ControllerParameter;
            Configuration.ControllerConnection ControllerConnection = config.ControllerConnect;

            List<Configuration.ControllerParameters.AdvancedFuncion> Prefixes = Controller.Prefixes.Prefixes;
            List<Configuration.ControllerParameters.AdvancedFuncion> NickColor = Controller.NickColorList;
            List<Configuration.ControllerParameters.AdvancedFuncion> ChatColor = Controller.MessageColorList;

            foreach (KeyValuePair<UInt64, User> Info in UserInformation)
            {
                if (Controller.Prefixes.TurnMultiPrefixes)
                {
                    foreach (String Prefix in Info.Value.Info.PrefixList.Where(prefixList => !Prefixes.Exists(i => i.Argument == prefixList)))
                        NextTick(() => Info.Value.Info.PrefixList.Remove(Prefix));
                }
                else
                {
                    if (!Prefixes.Exists(i => i.Argument == Info.Value.Info.Prefix))
                        Info.Value.Info.Prefix = ControllerConnection.SetupDefaults.PrefixDefault;
                }
                if (!NickColor.Exists(i => i.Argument == Info.Value.Info.ColorNick))
                    Info.Value.Info.ColorNick = ControllerConnection.SetupDefaults.NickDefault;

                if (!ChatColor.Exists(i => i.Argument == Info.Value.Info.ColorMessage))
                    Info.Value.Info.ColorMessage = ControllerConnection.SetupDefaults.MessageDefault;
            }
        }


        
                public class FancyMessage
        {
            public string content { get; set; }
            public bool tts { get; set; }
            public Embeds[] embeds { get; set; }

            public class Embeds
            {
                public string title { get; set; }
                public int color { get; set; }
                public List<Fields> fields { get; set; }
                public Footer footer { get; set; }
                public Authors author { get; set; }

                public Embeds(string title, int color, List<Fields> fields, Authors author, Footer footer)
                {
                    this.title = title;
                    this.color = color;
                    this.fields = fields;
                    this.author = author;
                    this.footer = footer;

                }
            }

            public FancyMessage(string content, bool tts, Embeds[] embeds)
            {
                this.content = content;
                this.tts = tts;
                this.embeds = embeds;
            }

            public string toJSON() => JsonConvert.SerializeObject(this);
        }
        public Boolean AddImage(String url, String shortname, UInt64 skin = 0) => (Boolean)ImageLibrary?.Call("AddImage", url, shortname, skin);
        void AlertUI(BasePlayer Sender, BasePlayer Recipient, string[] arg)
        {
            if (_interface == null)
            {
                PrintWarning(LanguageEn ? "We generate the interface, wait for a message about successful generation" : "Генерируем интерфейс, ожидайте сообщения об успешной генерации");
                return;
            }
            String Message = GetMessageInArgs(Sender, arg);
            if (Message == null) return;

            DrawUI_IQChat_Alert(Recipient, Message);
        }
        internal class AntiNoob
        {
            public DateTime DateConnection = DateTime.UtcNow;

            public Boolean IsNoob(Int32 TimeBlocked)
            {
                System.TimeSpan Time = DateTime.UtcNow.Subtract(DateConnection);
                return Time.TotalSeconds < TimeBlocked;
            }

            public Double LeftTime(Int32 TimeBlocked)
            {
                System.TimeSpan Time = DateTime.UtcNow.Subtract(DateConnection);

                return (TimeBlocked - Time.TotalSeconds);
            }
        }

        private void DrawUI_IQChat_Alert(BasePlayer player, String Description, String Title = null)
        {
            if (_interface == null)
            {
                PrintWarning("Генерируем интерфейс, ожидайте сообщения об успешной генерации");
                return;
            }
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Alert");
            if (Interface == null) return;

            Interface = Interface.Replace("%TITLE%", Title ?? GetLang("IQCHAT_ALERT_TITLE", player.UserIDString));
            Interface = Interface.Replace("%DESCRIPTION%", Description);

            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_Chat_Alert);
            CuiHelper.AddUi(player, Interface);

            player.Invoke(() =>
            {
                CuiHelper.DestroyUi(player, InterfaceBuilder.UI_Chat_Alert);
            }, config.ControllerMessages.GeneralSetting.OtherSetting.TimeDeleteAlertUI);
        }
        void OnUserPermissionRevoked(string id, string permName) => RemoveParametres(id, permName);

        [ChatCommand("unmute")]
        void UnMuteCustomChat(BasePlayer Moderator, string cmd, string[] arg)
        {
            if (!permission.UserHasPermission(Moderator.UserIDString, PermissionMute)) return;
            if (arg == null || arg.Length != 1 || arg.Length > 1)
            {
                ReplySystem(Moderator, LanguageEn ? "Invalid syntax, please use : unmute Steam64ID" : "Неверный синтаксис,используйте : unmute Steam64ID");
                return;
            }
            string NameOrID = arg[0];
            BasePlayer target = GetPlayerNickOrID(NameOrID);
            if (target == null)
            {
                UInt64 Steam64ID = 0;
                if (UInt64.TryParse(NameOrID, out Steam64ID))
                {
                    if (UserInformation.ContainsKey(Steam64ID))
                    {
                        User Info = UserInformation[Steam64ID];
                        if (Info == null) return;
                        if (!Info.MuteInfo.IsMute(MuteType.Chat))
                        {
                            ReplySystem(Moderator, LanguageEn ? "The player does not have a chat lock" : "У игрока нет блокировки чата");
                            return;
                        }

                        Info.MuteInfo.UnMute(MuteType.Chat);
                        ReplySystem(Moderator, LanguageEn ? "You have unblocked the offline chat to the player" : "Вы разблокировали чат offline игроку");
                        return;
                    }
                    else
                    {
                        ReplySystem(Moderator, LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                        return;
                    }
                }
                else
                {
                    ReplySystem(Moderator, LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                    return;
                }
            }
            UnmutePlayer(target, MuteType.Chat, Moderator, false, true);
        }

        [ChatCommand("hunmute")]
        void HideUnMute(BasePlayer Moderator, string cmd, string[] arg)
        {
            if (!permission.UserHasPermission(Moderator.UserIDString, PermissionMute)) return;
            if (arg == null || arg.Length != 1 || arg.Length > 1)
            {
                ReplySystem(Moderator, LanguageEn ? "Invalid syntax, please use : hunmute Steam64ID/Nick" : "Неверный синтаксис,используйте : hunmute Steam64ID/Ник");
                return;
            }
            string NameOrID = arg[0];
            BasePlayer target = GetPlayerNickOrID(NameOrID);
            if (target == null)
            {
                UInt64 Steam64ID = 0;
                if (UInt64.TryParse(NameOrID, out Steam64ID))
                {
                    if (UserInformation.ContainsKey(Steam64ID))
                    {
                        User Info = UserInformation[Steam64ID];
                        if (Info == null) return;
                        if (!Info.MuteInfo.IsMute(MuteType.Chat))
                        {
                            ReplySystem(Moderator, LanguageEn ? "The player does not have a chat lock" : "У игрока нет блокировки чата");
                            return;
                        }

                        Info.MuteInfo.UnMute(MuteType.Chat);
                        ReplySystem(Moderator, LanguageEn ? "You have unblocked the offline chat to the player" : "Вы разблокировали чат offline игроку");
                        return;
                    }
                    else
                    {
                        ReplySystem(Moderator, LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                        return;
                    }
                }
                else
                {
                    ReplySystem(Moderator, LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                    return;
                }
            }

            UnmutePlayer(target, MuteType.Chat, Moderator, true, true);
        }
        private String XLevel_GetPrefix(BasePlayer player)
        {
            if (!XLevels || !config.ReferenceSetting.XLevelsSettings.UseXLevels) return String.Empty;
            return (String)XLevels?.CallHook("API_GetPlayerPrefix", player);
        }
        
                private void DrawUI_IQChat_Update_Check_Box(BasePlayer player, ElementsSettingsType Type, String OffsetMin, String OffsetMax, Boolean StatusCheckBox)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Context_CheckBox");
            User Info = UserInformation[player.userID];
            if (Info == null || Interface == null) return;

            String Name = $"{Type}";
            Interface = Interface.Replace("%NAME_CHECK_BOX%", Name);
            Interface = Interface.Replace("%COLOR%", !StatusCheckBox ? "0.4716981 0.4716981 0.4716981 1" : "0.6040971 0.4198113 1 1");
            Interface = Interface.Replace("%OFFSET_MIN%", OffsetMin);
            Interface = Interface.Replace("%OFFSET_MAX%", OffsetMax);
            Interface = Interface.Replace("%COMMAND_TURNED%", $"newui.cmd checkbox.controller {Type}");

            CuiHelper.DestroyUi(player, Name);
            CuiHelper.AddUi(player, Interface);
        }
        
        
        private void ControlledBadNick(IPlayer player)
        {
            if (player == null) return;
            Configuration.ControllerMessage ControllerMessage = config.ControllerMessages;

            String DisplayName = player.Name;

            Tuple<String, Boolean> GetTupleNick = BadWordsCleaner(DisplayName,
                ControllerMessage.Formatting.ControllerNickname.ReplaceBadNick,
                ControllerMessage.Formatting.ControllerNickname.BadNicks);
            DisplayName = GetTupleNick.Item1;

            DisplayName = RemoveLinkText(DisplayName);
            player.Rename(DisplayName);
        }

        
        
        private void SetupParametres(String ID, String Permissions)
        {
            UInt64 UserID = UInt64.Parse(ID);
            BasePlayer player = BasePlayer.FindByID(UserID);

            Configuration.ControllerConnection.Turned Controller = config.ControllerConnect.Turneds;
            Configuration.ControllerParameters Parameters = config.ControllerParameter;

            if (!UserInformation.ContainsKey(UserID)) return;
            User Info = UserInformation[UserID];

            if (Controller.TurnAutoSetupPrefix)
            {
                Configuration.ControllerParameters.AdvancedFuncion Prefixes = Parameters.Prefixes.Prefixes.FirstOrDefault(prefix => prefix.Permissions == Permissions);
                if (Prefixes == null) return;

                if (Parameters.Prefixes.TurnMultiPrefixes && !Info.Info.PrefixList.Contains(Prefixes.Argument))
                    Info.Info.PrefixList.Add(Prefixes.Argument);
                else Info.Info.Prefix = Prefixes.Argument;

                if (player != null)
                    ReplySystem(player, GetLang("PREFIX_SETUP", player.UserIDString, Prefixes.Argument));

                Log(LanguageEn ? $"Player ({UserID}) successfully retrieved the prefix {Prefixes.Argument}" : $"Игрок ({UserID}) успешно забрал префикс {Prefixes.Argument}");
            }
            if (Controller.TurnAutoSetupColorNick)
            {
                Configuration.ControllerParameters.AdvancedFuncion ColorNick = Parameters.NickColorList.FirstOrDefault(nick => nick.Permissions == Permissions);
                if (ColorNick == null) return;
                Info.Info.ColorNick = ColorNick.Argument;

                if (player != null)
                    ReplySystem(player, GetLang("COLOR_NICK_SETUP", player.UserIDString, ColorNick.Argument));

                Log(LanguageEn ? $"Player ({UserID}) successfully took the color of the nickname {ColorNick.Argument}" : $"Игрок ({UserID}) успешно забрал цвет ника {ColorNick.Argument}");
            }
            if (Controller.TurnAutoSetupColorChat)
            {
                Configuration.ControllerParameters.AdvancedFuncion ColorChat = Parameters.MessageColorList.FirstOrDefault(message => message.Permissions == Permissions);
                if (ColorChat == null) return;
                Info.Info.ColorMessage = ColorChat.Argument;

                if (player != null)
                    ReplySystem(player, GetLang("COLOR_CHAT_SETUP", player.UserIDString, ColorChat.Argument));

                Log(LanguageEn ? $"Player ({UserID}) successfully retrieved the color of the chat {ColorChat.Argument}" : $"Игрок ({UserID}) успешно забрал цвет чата {ColorChat.Argument}");
            }
        }
        [ChatCommand("saybro")]
        private void AlertOnlyPlayerChatCommand(BasePlayer Sender, String cmd, String[] args)
        {
            if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;
            if (args == null || args.Length == 0)
            {
                ReplySystem(Sender, LanguageEn ? "You didn't specify a player!" : "Вы не указали игрока!");
                return;
            }
            BasePlayer Recipient = BasePlayer.Find(args[0]);
            if (Recipient == null)
            {
                ReplySystem(Sender, LanguageEn ? "The player is not on the server" : "Игрока нет на сервере!");
                return;
            }
            Alert(Sender, Recipient, args.Skip(1).ToArray());
        }
        private void DrawUI_IQChat_Update_MuteChat_All(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermissionMutedAdmin)) return;

            String InterfaceAdministratorChat = InterfaceBuilder.GetInterface("UI_Chat_Administation_AllChat");
            if (InterfaceAdministratorChat == null) return;

            InterfaceAdministratorChat = InterfaceAdministratorChat.Replace("%TEXT_MUTE_ALLCHAT%", GetLang(!GeneralInfo.TurnMuteAllChat ? "IQCHAT_BUTTON_MODERATION_MUTE_ALL_CHAT" : "IQCHAT_BUTTON_MODERATION_UNMUTE_ALL_CHAT", player.UserIDString));
            InterfaceAdministratorChat = InterfaceAdministratorChat.Replace("%COMMAND_MUTE_ALLCHAT%", $"newui.cmd action.mute.ignore mute.controller {SelectedAction.Mute} mute.all.chat");

            CuiHelper.DestroyUi(player, "ModeratorMuteAllChat");
            CuiHelper.AddUi(player, InterfaceAdministratorChat);
        }

        
        
        [ConsoleCommand("mute")]
        void MuteCustomAdmin(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null)
                if (!permission.UserHasPermission(arg.Player().UserIDString, PermissionMute)) return;
            if (arg == null || arg.Args == null || arg.Args.Length != 3 || arg.Args.Length > 3)
            {
                PrintWarning(LanguageEn ? "Invalid syntax, use : mute Steam64ID/Nick Reason Time(seconds)" : "Неверный синтаксис,используйте : mute Steam64ID/Ник Причина Время(секунды)");
                return;
            }
            string NameOrID = arg.Args[0];
            string Reason = arg.Args[1];
            Int32 TimeMute = 0;
            if (!Int32.TryParse(arg.Args[2], out TimeMute))
            {
                PrintWarning(LanguageEn ? "Enter time in numbers!" : "Введите время цифрами!");
                return;
            }
            BasePlayer target = GetPlayerNickOrID(NameOrID);
            if (target == null)
            {
                UInt64 Steam64ID = 0;
                if (UInt64.TryParse(NameOrID, out Steam64ID))
                {
                    if (UserInformation.ContainsKey(Steam64ID))
                    {
                        User Info = UserInformation[Steam64ID];
                        if (Info == null) return;
                        if (Info.MuteInfo.IsMute(MuteType.Chat))
                        {
                            PrintWarning(LanguageEn ? "The player already has a chat lock" : "Игрок уже имеет блокировку чата");
                            return;
                        }

                        Info.MuteInfo.SetMute(MuteType.Chat, TimeMute);
                        PrintWarning(LanguageEn ? "Chat blocking issued to offline player" : "Блокировка чата выдана offline-игроку");
                        return;
                    }
                    else
                    {
                        PrintWarning(LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                        return;
                    }
                }
                else
                {
                    PrintWarning(LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                    return;
                }
            }

            MutePlayer(target, MuteType.Chat, 0, arg.Player(), Reason, TimeMute, false, true);
            Puts(LanguageEn ? "Successfully" : "Успешно");
        }

        [ConsoleCommand("rename")]
        private void ConsoleCommandRename(ConsoleSystem.Arg args)
        {
            BasePlayer Renamer = args.Player();
            if (Renamer == null)
            {
                PrintWarning(LanguageEn ? "You can only use this command while on the server" : "Вы можете использовать эту команду только находясь на сервере");
                return;
            }

            if (!permission.UserHasPermission(Renamer.UserIDString, PermissionRename)) return;
            GeneralInformation General = GeneralInfo;
            if (General == null) return;

            if (args.Args.Length == 0 || args == null)
            {
                ReplySystem(Renamer, lang.GetMessage("COMMAND_RENAME_NOTARG", this, Renamer.UserIDString));
                return;
            }

            String Name = args.Args[0];
            UInt64 ID = Renamer.userID;
            if (args.Args.Length == 2 && args.Args[1] != null && !String.IsNullOrWhiteSpace(args.Args[1]))
                if (!UInt64.TryParse(args.Args[1], out ID))
                {
                    ReplySystem(Renamer, lang.GetMessage("COMMAND_RENAME_NOT_ID", this, Renamer.UserIDString));
                    return;
                }

            if (General.RenameList.ContainsKey(Renamer.userID))
            {
                General.RenameList[Renamer.userID].RenameNick = Name;
                General.RenameList[Renamer.userID].RenameID = ID;
            }
            else General.RenameList.Add(Renamer.userID, new GeneralInformation.RenameInfo { RenameNick = Name, RenameID = ID });

            ReplySystem(Renamer, GetLang("COMMAND_RENAME_SUCCES", Renamer.UserIDString, Name, ID));
            Renamer.displayName = Name;
        }
        void API_ALERT_PLAYER_UI(BasePlayer player, String Message) => DrawUI_IQChat_Alert(player, Message);
        private enum SelectedParametres
        {
            DropList,
            Slider
        }
        private const String PermissionHideDisconnection = "iqchat.hidedisconnection";

        [ChatCommand("mute")]
        void MuteCustomChat(BasePlayer Moderator, string cmd, string[] arg)
        {
            if (!permission.UserHasPermission(Moderator.UserIDString, PermissionMute)) return;
            if (arg == null || arg.Length != 3 || arg.Length > 3)
            {
                ReplySystem(Moderator, LanguageEn ? "Invalid syntax, use : mute Steam64ID/Nick Reason Time(seconds)" : "Неверный синтаксис, используйте : mute Steam64ID/Ник Причина Время(секунды)");
                return;
            }
            string NameOrID = arg[0];
            string Reason = arg[1];
            Int32 TimeMute = 0;
            if (!Int32.TryParse(arg[2], out TimeMute))
            {
                ReplySystem(Moderator, LanguageEn ? "Enter time in numbers!" : "Введите время цифрами!");
                return;
            }
            BasePlayer target = GetPlayerNickOrID(NameOrID);
            if (target == null)
            {
                UInt64 Steam64ID = 0;
                if (UInt64.TryParse(NameOrID, out Steam64ID))
                {
                    if (UserInformation.ContainsKey(Steam64ID))
                    {
                        User Info = UserInformation[Steam64ID];
                        if (Info == null) return;
                        if (Info.MuteInfo.IsMute(MuteType.Chat))
                        {
                            ReplySystem(Moderator, LanguageEn ? "The player already has a chat lock" : "Игрок уже имеет блокировку чата");
                            return;
                        }

                        Info.MuteInfo.SetMute(MuteType.Chat, TimeMute);
                        ReplySystem(Moderator, LanguageEn ? "Chat blocking issued to offline player" : "Блокировка чата выдана offline-игроку");
                        return;
                    }
                    else
                    {
                        ReplySystem(Moderator, LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                        return;
                    }
                }
                else
                {
                    ReplySystem(Moderator, LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                    return;
                }
            }

            MutePlayer(target, MuteType.Chat, 0, Moderator, Reason, TimeMute, false, true);
        }
        
        
        
        private void DiscordLoggCommand(BasePlayer player, String Command, String[] Args)
        {
            Configuration.OtherSettings.General Commands = config.OtherSetting.LogsChatCommands;
            if (!Commands.UseLogged) return;

            List<Fields> fields = new List<Fields>
                        {
                            new Fields(LanguageEn ? "Nick" : "Ник", player.displayName, true),
                            new Fields("Steam64ID", player.UserIDString, true),
                            new Fields(LanguageEn ? "Command" : "Команда", $"/{Command} ", true),
                        };

            String Arguments = String.Join(" ", Args);
            if (Args != null && Arguments != null && Arguments.Length != 0 && !String.IsNullOrWhiteSpace(Arguments))
                fields.Insert(fields.Count, new Fields(LanguageEn ? "Arguments" : "Аргументы", Arguments, false));

            FancyMessage newMessage = new FancyMessage(null, false, new FancyMessage.Embeds[1] { new FancyMessage.Embeds(null, 10710525, fields, new Authors("IQChat Command-History", null, "https://i.imgur.com/xiwsg5m.png", null), null) });

            Request($"{Commands.Webhooks}", newMessage.toJSON());
        }
        [ConsoleCommand("alertuip")]
        private void AlertUIPConsoleCommand(ConsoleSystem.Arg args)
        {
            BasePlayer Sender = args.Player();
            if (Sender != null)
                if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;
            if (args.Args == null || args.Args.Length == 0)
            {
                if (Sender != null)
                    ReplySystem(Sender, LanguageEn ? "You didn't specify a player!" : "Вы не указали игрока!");
                else PrintWarning(LanguageEn ? "You didn't specify a player!" : "Вы не указали игрока!");
                return;
            }
            BasePlayer Recipient = BasePlayer.Find(args.Args[0]);
            if (Recipient == null)
            {
                if (Sender != null)
                    ReplySystem(Sender, LanguageEn ? "The player is not on the server!" : "Игрока нет на сервере!");
                else PrintWarning(LanguageEn ? "The player is not on the server!" : "Игрока нет на сервере!");
                return;
            }
            AlertUI(Sender, Recipient, args.Args.Skip(1).ToArray());
        }
        public void AnwserMessage(BasePlayer player, String Message)
        {
            Configuration.AnswerMessage Anwser = config.AnswerMessages;
            if (!Anwser.UseAnswer) return;
            foreach (KeyValuePair<String, Configuration.LanguageController> Anwsers in Anwser.AnswerMessageList)
                if (Message.Contains(Anwsers.Key.ToLower()))
                    ReplySystem(player, GetMessages(player, Anwsers.Value.LanguageMessages));
        }

        void OnGroupPermissionRevoked(string name, string perm)
        {
            String[] PlayerGroups = permission.GetUsersInGroup(name);
            if (PlayerGroups == null) return;

            foreach (String playerInfo in PlayerGroups)
            {
                BasePlayer player = BasePlayer.FindByID(UInt64.Parse(playerInfo.Substring(0, 17)));
                if (player == null) return;

                RemoveParametres(player.UserIDString, perm);
            }
        }
        public static StringBuilder sb = new StringBuilder();
        void Init()
        {
            ReadData();
        }
        String IQRankGetNameRankKey(string Key) => (string)(IQRankSystem?.Call("API_GET_RANK_NAME", Key));

        
                private void DrawUI_IQChat_Sliders(BasePlayer player, String Name, String OffsetMin, String OffsetMax, TakeElementUser ElementType)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Slider");
            if (Interface == null) return;

            Interface = Interface.Replace("%OFFSET_MIN%", OffsetMin);
            Interface = Interface.Replace("%OFFSET_MAX%", OffsetMax);
            Interface = Interface.Replace("%NAME%", Name);
            Interface = Interface.Replace("%COMMAND_LEFT_SLIDE%", $"newui.cmd slider.controller {ElementType} -");
            Interface = Interface.Replace("%COMMAND_RIGHT_SLIDE%", $"newui.cmd slider.controller {ElementType} +");

            CuiHelper.DestroyUi(player, Name);
            CuiHelper.AddUi(player, Interface);

            DrawUI_IQChat_Slider_Update_Argument(player, ElementType);
        }
        String API_GET_DEFAULT_NICK_COLOR() => config.ControllerConnect.SetupDefaults.NickDefault;

        void OnUserGroupAdded(string id, string groupName)
        {
            String[] PermissionsGroup = permission.GetGroupPermissions(groupName);
            if (PermissionsGroup == null) return;
            foreach (String permName in PermissionsGroup)
                SetupParametres(id, permName);
        }
        private const String PermissionHideConnection = "iqchat.hideconnection";

        void ReplyBroadcast(String Message, String CustomPrefix = null, String CustomAvatar = null, Boolean AdminAlert = false)
        {
            foreach (BasePlayer p in !AdminAlert ? BasePlayer.activePlayerList.Where(p => UserInformation[p.userID].Settings.TurnBroadcast) : BasePlayer.activePlayerList)
                ReplySystem(p, Message, CustomPrefix, CustomAvatar);
        }
        
        
        [ConsoleCommand("alert")]
        private void AlertConsoleCommand(ConsoleSystem.Arg args)
        {
            BasePlayer Sender = args.Player();
            if (Sender != null)
                if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;

            Alert(Sender, args.Args, false);
        }
        private enum TakeElementUser
        {
            Prefix,
            Nick,
            Chat,
            Rank,
            MultiPrefix
        }
        
        private static ConfigurationOld configOld = new ConfigurationOld();
        public class User
        {
            public Information Info = new Information();
            public Setting Settings = new Setting();
            public Mute MuteInfo = new Mute();
            internal class Information
            {
                public String Prefix;
                public String ColorNick;
                public String ColorMessage;
                public String Rank;

                public List<String> PrefixList = new List<String>();
            }

            internal class Setting
            {
                public Boolean TurnPM = true;
                public Boolean TurnAlert = true;
                public Boolean TurnBroadcast = true;
                public Boolean TurnSound = true;

                public List<UInt64> IgnoreUsers = new List<UInt64>();

                public Boolean IsIgnored(UInt64 TargetID) => IgnoreUsers.Contains(TargetID);
                public void IgnoredAddOrRemove(UInt64 TargetID)
                {
                    if (IsIgnored(TargetID))
                        IgnoreUsers.Remove(TargetID);
                    else IgnoreUsers.Add(TargetID);
                }
            }

            internal class Mute
            {
                public Double TimeMuteChat;
                public Double TimeMuteVoice;

                public Double GetTime(MuteType Type)
                {
                    Double TimeMuted = 0;
                    switch (Type)
                    {
                        case MuteType.Chat:
                            TimeMuted = TimeMuteChat - CurrentTime;
                            break;
                        case MuteType.Voice:
                            TimeMuted = TimeMuteVoice - CurrentTime;
                            break;
                        default:
                            break;
                    }
                    return TimeMuted;
                }
                public void SetMute(MuteType Type, Int32 Time)
                {
                    switch (Type)
                    {
                        case MuteType.Chat:
                            TimeMuteChat = Time + CurrentTime;
                            break;
                        case MuteType.Voice:
                            TimeMuteVoice = Time + CurrentTime;
                            break;
                        default:
                            break;
                    }
                }
                public void UnMute(MuteType Type)
                {
                    switch (Type)
                    {
                        case MuteType.Chat:
                            TimeMuteChat = 0;
                            break;
                        case MuteType.Voice:
                            TimeMuteVoice = 0;
                            break;
                        default:
                            break;
                    }
                }
                public Boolean IsMute(MuteType Type) => GetTime(Type) > 0;
            }
        }
        public enum MuteType
        {
            Chat,
            Voice
        }
        [ChatCommand("adminalert")]
        private void AdminAlertChatCommand(BasePlayer Sender, String cmd, String[] args)
        {
            if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;
            Alert(Sender, args, true);
        }


        
        
        
        private class ImageUi
        {
            private static Coroutine coroutineImg = null;
            private static Dictionary<string, string> Images = new Dictionary<string, string>();
            public static void DownloadImages() { coroutineImg = ServerMgr.Instance.StartCoroutine(AddImage()); }

            private static IEnumerator AddImage()
            {
                _.PrintWarning(LanguageEn ? "Generating interface, wait ~10-15 seconds!" : "Генерируем интерфейс, ожидайте ~10-15 секунд!");

                foreach (String Key in _.KeyImages)
                {
                    string uri = $"https://iqsystem.skyplugins.ru/iqchat/getimageui/{Key}/WIwsqNNWF7nN";
                    UnityWebRequest www = UnityWebRequestTexture.GetTexture(uri);
                    yield return www.SendWebRequest();

                    if (_ == null)
                        yield break;
                    if (www.isNetworkError || www.isHttpError)
                    {
                        _.PrintWarning(string.Format("Image download error! Error: {0}, Image name: {1}", www.error, Key));
                        www.Dispose();
                        coroutineImg = null;
                        yield break;
                    }
                    Texture2D texture = DownloadHandlerTexture.GetContent(www);
                    if (texture != null)
                    {
                        byte[] bytes = texture.EncodeToPNG();

                        var image = FileStorage.server.Store(bytes, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID).ToString();
                        if (!Images.ContainsKey(Key))
                            Images.Add(Key, image);
                        else
                            Images[Key] = image;
                        UnityEngine.Object.DestroyImmediate(texture);
                    }

                    www.Dispose();
                    yield return CoroutineEx.waitForSeconds(0.02f);
                }
                coroutineImg = null;

                _interface = new InterfaceBuilder();
                _.PrintWarning(LanguageEn ? "Interface loaded successfully!" : "Интерфейс успешно загружен!");
            }

            public static string GetImage(String ImgKey)
            {
                if (Images.ContainsKey(ImgKey))
                    return Images[ImgKey];
                return _.GetImage("LOADING");
            }

            public static void Unload()
            {
                coroutineImg = null;
                foreach (var item in Images)
                    FileStorage.server.RemoveExact(uint.Parse(item.Value), FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID, 0U);
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                try
                {
                    configOld = Config.ReadObject<ConfigurationOld>();
                    if (configOld != null)
                    {
                        string file =
                            $"{Interface.Oxide.ConfigDirectory}{Path.DirectorySeparatorChar}{Name}.backup_old_system.{DateTime.Now:yyyy-MM-dd hh-mm-ss}.json";
                        Config.WriteObject(configOld, false, file);
                        PrintWarning($"A BACKUP OF THE OLD CONFIGURATION WAS CREATED - {file}");
                    }
                }
                catch { }

                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();

                if (config.ControllerMessages.Formatting.ControllerNickname.AllowedLinkNick == null ||
                    config.ControllerMessages.Formatting.ControllerNickname.AllowedLinkNick.Count == 0)
                    config.ControllerMessages.Formatting.ControllerNickname.AllowedLinkNick = new List<String>()
                    {
                        "mysite.com"
                    };
            }
            catch
            {
                PrintWarning(LanguageEn
                    ? $"Error #132 read configuration 'oxide/config/{Name}', create a new configuration!!"
                    : $"Ошибка #132 чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");

                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }
        public Dictionary<UInt64, User> UserInformation = new Dictionary<UInt64, User>();
        Boolean API_IS_IGNORED(UInt64 UserHas, UInt64 User)
        {
            if (!UserInformation.ContainsKey(UserHas)) return false;
            if (!UserInformation.ContainsKey(User)) return false;

            return UserInformation[UserHas].Settings.IsIgnored(User);
        }
        
                String IQRankGetRank(ulong userID) => (string)(IQRankSystem?.Call("API_GET_RANK_NAME", userID));

        void OnPlayerDisconnected(BasePlayer player, string reason) => AlertDisconnected(player, reason);
        private class ConfigurationOld
        {
                        [JsonProperty(LanguageEn ? "Setting up player information" : "Настройка информации о игроке")]
            public ControllerConnection ControllerConnect = new ControllerConnection();
            internal class ControllerConnection
            {
                [JsonProperty(LanguageEn ? "Function switches" : "Перключатели функций")]
                public Turned Turneds = new Turned();
                [JsonProperty(LanguageEn ? "Setting Standard Values" : "Настройка стандартных значений")]
                public SetupDefault SetupDefaults = new SetupDefault();

                internal class SetupDefault
                {
                    [JsonProperty(LanguageEn ? "This prefix will be set if the player entered the server for the first time or in case of expiration of the rights to the prefix that he had earlier" : "Данный префикс установится если игрок впервые зашел на сервер или в случае окончания прав на префикс, который у него стоял ранее")]
                    public String PrefixDefault = "<color=#CC99FF>[ИГРОК]</color>";
                    [JsonProperty(LanguageEn ? "This nickname color will be set if the player entered the server for the first time or in case of expiration of the rights to the nickname color that he had earlier" : "Данный цвет ника установится если игрок впервые зашел на сервер или в случае окончания прав на цвет ника, который у него стоял ранее")]
                    public String NickDefault = "#33CCCC";
                    [JsonProperty(LanguageEn ? "This chat color will be set if the player entered the server for the first time or in case of expiration of the rights to the chat color that he had earlier" : "Данный цвет чата установится если игрок впервые зашел на сервер или в случае окончания прав на цвет чата, который у него стоял ранее")]
                    public String MessageDefault = "#0099FF";
                }
                internal class Turned
                {
                    [JsonProperty(LanguageEn ? "Set automatically a prefix to a player when he got the rights to it" : "Устанавливать автоматически префикс игроку, когда он получил права на него")]
                    public Boolean TurnAutoSetupPrefix;
                    [JsonProperty(LanguageEn ? "Set automatically the color of the nickname to the player when he got the rights to it" : "Устанавливать автоматически цвет ника игроку, когда он получил права на него")]
                    public Boolean TurnAutoSetupColorNick;
                    [JsonProperty(LanguageEn ? "Set the chat color automatically to the player when he got the rights to it" : "Устанавливать автоматически цвет чата игроку, когда он получил права на него")]
                    public Boolean TurnAutoSetupColorChat;
                    [JsonProperty(LanguageEn ? "Automatically reset the prefix when the player's rights to it expire" : "Сбрасывать автоматически префикс при окончании прав на него у игрока")]
                    public Boolean TurnAutoDropPrefix;
                    [JsonProperty(LanguageEn ? "Automatically reset the color of the nickname when the player's rights to it expire" : "Сбрасывать автоматически цвет ника при окончании прав на него у игрока")]
                    public Boolean TurnAutoDropColorNick;
                    [JsonProperty(LanguageEn ? "Automatically reset the color of the chat when the rights to it from the player expire" : "Сбрасывать автоматически цвет чата при окончании прав на него у игрока")]
                    public Boolean TurnAutoDropColorChat;
                }
            }
            
                        [JsonProperty(LanguageEn ? "Setting options for the player" : "Настройка параметров для игрока")]
            public ControllerParameters ControllerParameter = new ControllerParameters();
            internal class ControllerParameters
            {
                [JsonProperty(LanguageEn ? "Setting the display of options for player selection" : "Настройка отображения параметров для выбора игрока")]
                public VisualSettingParametres VisualParametres = new VisualSettingParametres();
                [JsonProperty(LanguageEn ? "List and customization of colors for a nickname" : "Список и настройка цветов для ника")]
                public List<AdvancedFuncion> NickColorList = new List<AdvancedFuncion>();
                [JsonProperty(LanguageEn ? "List and customize colors for chat messages" : "Список и настройка цветов для сообщений в чате")]
                public List<AdvancedFuncion> MessageColorList = new List<AdvancedFuncion>();
                [JsonProperty(LanguageEn ? "List and configuration of prefixes in chat" : "Список и настройка префиксов в чате")]
                public PrefixSetting Prefixes = new PrefixSetting();
                internal class PrefixSetting
                {
                    [JsonProperty(LanguageEn ? "Enable support for multiple prefixes at once (true - multiple prefixes can be set/false - only 1 can be set to choose from)" : "Включить поддержку нескольких префиксов сразу (true - можно установить несколько префиксов/false - установить можно только 1 на выбор)")]
                    public Boolean TurnMultiPrefixes;
                    [JsonProperty(LanguageEn ? "The maximum number of prefixes that can be set at a time (This option only works if setting multiple prefixes is enabled)" : "Максимальное количество префиксов, которое можно установить за раз(Данный параметр работает только если включена установка нескольких префиксов)")]
                    public Int32 MaximumMultiPrefixCount;
                    [JsonProperty(LanguageEn ? "List of prefixes and their settings" : "Список префиксов и их настройка")]
                    public List<AdvancedFuncion> Prefixes = new List<AdvancedFuncion>();
                }
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                internal class AdvancedFuncion
                {
                    [JsonProperty(LanguageEn ? "Permission" : "Права")]
                    public String Permissions;
                    [JsonProperty(LanguageEn ? "Argument" : "Значение")]
                    public String Argument;
                }

                internal class VisualSettingParametres
                {
                    [JsonProperty(LanguageEn ? "Player prefix selection display type - (0 - dropdown list, 1 - slider (Please note that if you have multi-prefix enabled, the dropdown list will be set))" : "Тип отображения выбора префикса для игрока - (0 - выпадающий список, 1 - слайдер (Учтите, что если у вас включен мульти-префикс, будет установлен выпадающий список))")]
                    public SelectedParametres PrefixType;
                    [JsonProperty(LanguageEn ? "Display type of player's nickname color selection - (0 - drop-down list, 1 - slider)" : "Тип отображения выбора цвета ника для игрока - (0 - выпадающий список, 1 - слайдер)")]
                    public SelectedParametres NickColorType;
                    [JsonProperty(LanguageEn ? "Display type of message color choice for the player - (0 - drop-down list, 1 - slider)" : "Тип отображения выбора цвета сообщения для игрока - (0 - выпадающий список, 1 - слайдер)")]
                    public SelectedParametres ChatColorType;
                    [JsonProperty(LanguageEn ? "IQRankSystem : Player rank selection display type - (0 - drop-down list, 1 - slider)" : "IQRankSystem : Тип отображения выбора ранга для игрока - (0 - выпадающий список, 1 - слайдер)")]
                    public SelectedParametres IQRankSystemType;
                }
            }
            
                        [JsonProperty(LanguageEn ? "Plugin mute settings" : "Настройка мута в плагине")]
            public ControllerMute ControllerMutes = new ControllerMute();
            internal class ControllerMute
            {
                [JsonProperty(LanguageEn ? "Setting up automatic muting" : "Настройка автоматического мута")]
                public AutoMute AutoMuteSettings = new AutoMute();
                internal class AutoMute
                {
                    [JsonProperty(LanguageEn ? "Enable automatic muting for forbidden words (true - yes/false - no)" : "Включить автоматический мут по запрещенным словам(true - да/false - нет)")]
                    public Boolean UseAutoMute;
                    [JsonProperty(LanguageEn ? "Reason for automatic muting" : "Причина автоматического мута")]
                    public Muted AutoMuted;
                }
                [JsonProperty(LanguageEn ? "Additional setting for logging about mutes in discord" : "Дополнительная настройка для логирования о мутах в дискорд")]
                public LoggedFuncion LoggedMute = new LoggedFuncion();
                internal class LoggedFuncion
                {
                    [JsonProperty(LanguageEn ? "Support for logging the last N messages (Discord logging about mutes must be enabled)" : "Поддержка логирования последних N сообщений (Должно быть включено логирование в дискорд о мутах)")]
                    public Boolean UseHistoryMessage;
                    [JsonProperty(LanguageEn ? "How many latest player messages to send in logging" : "Сколько последних сообщений игрока отправлять в логировании")]
                    public Int32 CountHistoryMessage;
                }

                [JsonProperty(LanguageEn ? "Reasons to block chat" : "Причины для блокировки чата")]
                public List<Muted> MuteChatReasons = new List<Muted>();
                [JsonProperty(LanguageEn ? "Reasons to block your voice" : "Причины для блокировки голоса")]
                public List<Muted> MuteVoiceReasons = new List<Muted>();
                internal class Muted
                {
                    [JsonProperty(LanguageEn ? "Reason for blocking" : "Причина для блокировки")]
                    public String Reason;
                    [JsonProperty(LanguageEn ? "Block time (in seconds)" : "Время блокировки(в секундах)")]
                    public Int32 SecondMute;
                }
            }
            
                        [JsonProperty(LanguageEn ? "Configuring Message Processing" : "Настройка обработки сообщений")]
            public ControllerMessage ControllerMessages = new ControllerMessage();
            internal class ControllerMessage
            {
                [JsonProperty(LanguageEn ? "Basic settings for chat messages from the plugin" : "Основная настройка сообщений в чат от плагина")]
                public GeneralSettings GeneralSetting = new GeneralSettings();
                [JsonProperty(LanguageEn ? "Configuring functionality switching in chat" : "Настройка переключения функционала в чате")]
                public TurnedFuncional TurnedFunc = new TurnedFuncional();
                [JsonProperty(LanguageEn ? "Player message formatting settings" : "Настройка форматирования сообщений игроков")]
                public FormattingMessage Formatting = new FormattingMessage();
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                internal class GeneralSettings
                {
                    [JsonProperty(LanguageEn ? "Customizing the chat alert format" : "Настройка формата оповещения в чате")]
                    public BroadcastSettings BroadcastFormat = new BroadcastSettings();
                    [JsonProperty(LanguageEn ? "Setting the mention format in the chat, via @" : "Настройка формата упоминания в чате, через @")]
                    public AlertSettings AlertFormat = new AlertSettings();
                    [JsonProperty(LanguageEn ? "Additional setting" : "Дополнительная настройка")]
                    public OtherSettings OtherSetting = new OtherSettings();
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                    internal class BroadcastSettings
                    {
                        [JsonProperty(LanguageEn ? "The name of the notification in the chat" : "Наименование оповещения в чат")]
                        public String BroadcastTitle;
                        [JsonProperty(LanguageEn ? "Chat alert message color" : "Цвет сообщения оповещения в чат")]
                        public String BroadcastColor;
                        [JsonProperty(LanguageEn ? "Steam64ID for chat avatar" : "Steam64ID для аватарки в чате")]
                        public String Steam64IDAvatar;
                    }
                    internal class AlertSettings
                    {
                        [JsonProperty(LanguageEn ? "The color of the player mention message in the chat" : "Цвет сообщения упоминания игрока в чате")]
                        public String AlertPlayerColor;
                        [JsonProperty(LanguageEn ? "Sound when receiving and sending a mention via @" : "Звук при при получении и отправки упоминания через @")]
                        public String SoundAlertPlayer;
                    }
                    internal class OtherSettings
                    {
                        [JsonProperty(LanguageEn ? "Time after which the message will be deleted from the UI from the administrator" : "Время,через которое удалится сообщение с UI от администратора")]
                        public Int32 TimeDeleteAlertUI;

                        [JsonProperty(LanguageEn ? "The size of the message from the player in the chat" : "Размер сообщения от игрока в чате")]
                        public Int32 SizeMessage = 14;
                        [JsonProperty(LanguageEn ? "Player nickname size in chat" : "Размер ника игрока в чате")]
                        public Int32 SizeNick = 14;
                        [JsonProperty(LanguageEn ? "The size of the player's prefix in the chat (will be used if <size=N></size> is not set in the prefix itself)" : "Размер префикса игрока в чате (будет использовано, если в самом префиксе не установвлен <size=N></size>)")]
                        public Int32 SizePrefix = 14;
                    }
                }
                internal class TurnedFuncional
                {
                    [JsonProperty(LanguageEn ? "Configuring spam protection" : "Настройка защиты от спама")]
                    public AntiSpam AntiSpamSetting = new AntiSpam();
                    [JsonProperty(LanguageEn ? "Setting up a temporary chat block for newbies (who have just logged into the server)" : "Настройка временной блокировки чата новичкам (которые только зашли на сервер)")]
                    public AntiNoob AntiNoobSetting = new AntiNoob();
                    [JsonProperty(LanguageEn ? "Setting up private messages" : "Настройка личных сообщений")]
                    public PM PMSetting = new PM();

                    internal class AntiNoob
                    {
                        [JsonProperty(LanguageEn ? "Newbie protection in PM/R" : "Защита от новичка в PM/R")]
                        public Settings AntiNoobPM = new Settings();
                        [JsonProperty(LanguageEn ? "Newbie protection in global and team chat" : "Защита от новичка в глобальном и коммандном чате")]
                        public Settings AntiNoobChat = new Settings();
                        internal class Settings
                        {
                            [JsonProperty(LanguageEn ? "Enable protection?" : "Включить защиту?")]
                            public Boolean AntiNoobActivate = false;
                            [JsonProperty(LanguageEn ? "Newbie Chat Lock Time" : "Время блокировки чата для новичка")]
                            public Int32 TimeBlocked = 1200;
                        }
                    }
                    internal class AntiSpam
                    {
                        [JsonProperty(LanguageEn ? "Enable spam protection (Anti-spam)" : "Включить защиту от спама (Анти-спам)")]
                        public Boolean AntiSpamActivate;
                        [JsonProperty(LanguageEn ? "Time after which a player can send a message (AntiSpam)" : "Время через которое игрок может отправлять сообщение (АнтиСпам)")]
                        public Int32 FloodTime;
                        [JsonProperty(LanguageEn ? "Additional Anti-Spam settings" : "Дополнительная настройка Анти-Спама")]
                        public AntiSpamDuples AntiSpamDuplesSetting = new AntiSpamDuples();
                        internal class AntiSpamDuples
                        {
                            [JsonProperty(LanguageEn ? "Enable additional spam protection (Anti-duplicates, duplicate messages)" : "Включить дополнительную защиту от спама (Анти-дубликаты, повторяющие сообщения)")]
                            public Boolean AntiSpamDuplesActivate = true;
                            [JsonProperty(LanguageEn ? "How many duplicate messages does a player need to make to be confused by the system" : "Сколько дублирующих сообщений нужно сделать игроку чтобы его замутила система")]
                            public Int32 TryDuples = 3;
                            [JsonProperty(LanguageEn ? "Setting up automatic muting for duplicates" : "Настройка автоматического мута за дубликаты")]
                            public ControllerMute.Muted MuteSetting = new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Blocking for duplicate messages (SPAM)" : "Блокировка за дублирующие сообщения (СПАМ)",
                                SecondMute = 300,
                            };
                        }
                    }
                    internal class PM
                    {
                        [JsonProperty(LanguageEn ? "Enable Private Messages" : "Включить личные сообщения")]
                        public Boolean PMActivate;
                        [JsonProperty(LanguageEn ? "Sound when receiving a private message" : "Звук при при получении личного сообщения")]
                        public String SoundPM;
                    }
                    [JsonProperty(LanguageEn ? "Enable PM ignore for players (/ignore nick or via interface)" : "Включить игнор ЛС игрокам(/ignore nick или через интерфейс)")]
                    public Boolean IgnoreUsePM;
                    [JsonProperty(LanguageEn ? "Hide the issue of items to the Admin from the chat" : "Скрыть из чата выдачу предметов Админу")]
                    public Boolean HideAdminGave;
                    [JsonProperty(LanguageEn ? "Move mute to team chat (In case of a mute, the player will not be able to write even to the team chat)" : "Переносить мут в командный чат(В случае мута, игрок не сможет писать даже в командный чат)")]
                    public Boolean MuteTeamChat;
                }
                internal class FormattingMessage
                {
                    [JsonProperty(LanguageEn ? "Enable message formatting [Will control caps, message format] (true - yes/false - no)" : "Включить форматирование сообщений [Будет контроллировать капс, формат сообщения] (true - да/false - нет)")]
                    public Boolean FormatMessage;
                    [JsonProperty(LanguageEn ? "Use a list of banned words (true - yes/false - no)" : "Использовать список запрещенных слов (true - да/false - нет)")]
                    public Boolean UseBadWords;
                    [JsonProperty(LanguageEn ? "The word that will replace the forbidden word" : "Слово которое будет заменять запрещенное слово")]
                    public String ReplaceBadWord;
                    [JsonProperty(LanguageEn ? "List of banned words" : "Список запрещенных слов")]
                    public List<String> BadWords = new List<String>();

                    [JsonProperty(LanguageEn ? "Nickname controller setup" : "Настройка контроллера ников")]
                    public NickController ControllerNickname = new NickController();
                    internal class NickController
                    {
                        [JsonProperty(LanguageEn ? "Enable player nickname formatting (message formatting must be enabled)" : "Включить форматирование ников игроков (должно быть включено форматирование сообщений)")]
                        public Boolean UseNickController = true;
                        [JsonProperty(LanguageEn ? "The word that will replace the forbidden word (You can leave it blank and it will just delete)" : "Слово которое будет заменять запрещенное слово (Вы можете оставить пустым и будет просто удалять)")]
                        public String ReplaceBadNick = "****";
                        [JsonProperty(LanguageEn ? "List of banned nicknames" : "Список запрещенных ников")]
                        public List<String> BadNicks = new List<String>();
                    }
                }
            }
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            
            
            [JsonProperty(LanguageEn ? "Setting up chat alerts" : "Настройка оповещений в чате")]
            public ControllerAlert ControllerAlertSetting;

            internal class ControllerAlert
            {
                [JsonProperty(LanguageEn ? "Setting up chat alerts" : "Настройка оповещений в чате")]
                public Alert AlertSetting;
                [JsonProperty(LanguageEn ? "Setting notifications about the status of the player's session" : "Настройка оповещений о статусе сессии игрока")]
                public PlayerSession PlayerSessionSetting;
                [JsonProperty(LanguageEn ? "Configuring administrator session status alerts" : "Настройка оповещений о статусе сессии администратора")]
                public AdminSession AdminSessionSetting;
                [JsonProperty(LanguageEn ? "Setting up personal notifications to the player when connecting" : "Настройка персональных оповоещений игроку при коннекте")]
                public PersonalAlert PersonalAlertSetting;
                internal class Alert
                {
                    [JsonProperty(LanguageEn ? "Enable automatic messages in chat (true - yes/false - no)" : "Включить автоматические сообщения в чат (true - да/false - нет)")]
                    public Boolean AlertMessage;
                    [JsonProperty(LanguageEn ? "Type of automatic messages : true - sequential / false - random" : "Тип автомат